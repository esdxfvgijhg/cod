<?xml version="1.0"?><st-source><!-- Name: PDFNotice: The MIT LicenseCopyright © 2011-2016 Christian HaiderPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.BundleName: PDFBundleStructure: a Store.BundleForParcelComment: The runtime code for writing and reading PDF filesDevelopmentPrerequisites: #(#(#any 'Compression-ZLib' '') #(#any 'MD5' '') #(#any 'Values' '') #(#any 'Fonts' ''))Parcel: nilParcelName: PDFPrerequisiteDescriptions: #(#(#name 'Compression-ZLib') #(#name 'MD5') #(#name 'Values' #componentType #package) #(#name 'Fonts' #componentType #bundle))PrerequisiteParcels: #(#('Compression-ZLib' '') #('MD5' '') #('Values' '') #('Fonts' ''))Version: 1.4.4.0Date: 12:00:52 PM June 17, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jun16.2) of 10 June 2016 on 17 June 2016 at 12:00:52</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>PDF</name><environment>Graphics</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>PDF Namespace</package></attributes></name-space><class><name>Entity</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.Entity</class-id><body>Any object which can appear in a PDF file.Such entity can be read by or with a PDF reader andcan be written to a PDF writer.The sister hierarchy for immutable PDF objects is PdfValue.</body></comment><class><name>Filter</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Entity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>internal external </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.Filter</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 22.A de-/en-coder for the contents of PDF Streams.A filter has two buffers:	external: 	The encoded contents as read from an external source.				This is written to a file or used as #internal to the next filter.	internal: 	The decoded contents as used internally by the system or as #external by the next filter.A new filter is created with either the external or the internal content.The other buffer is filled lazy on demand.Any error is stored in the corresponding buffer.</body></comment><class><name>ASCIIFilter</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Filter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.ASCIIFilter</class-id><body>ASCII filters as defined in PDF 32000_2008.pdf pp. 24.This class implements no functionality but serves only for structuring purposes.</body></comment><class><name>ASCII85Decode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ASCIIFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.ASCII85Decode</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 25.Decodes data encoded in an ASCII base-85 representation, reproducing the original binary data.</body></comment><class><name>PDFObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Entity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>content </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.PDFObject</class-id><body>Super class of all PDF objects defined in PDF 32000_2008.pdf pp. 14.All PDFObjects are defined in the PDF namespace and use their proper name from the specification.Many PDFObjects have the same class name as normal Smalltalk objects - Do not confuse them!The creation of these objects is done by a PDF.File with a PDF.Reader.</body></comment><class><name>Dictionary</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.Dictionary</class-id><body>PDF Dictionary object as defined in PDF 32000_2008.pdf pp. 18.Dictionaries use PDFNames as keys. Internally the implementation uses Symbols as keys for efficency.The keys must be symbols.Dictionaries hold PDF objects only. Any object put into it will be converted to its corresponding PDF object.Dictionaries always answer PDF objects.</body></comment><class><name>TypedDictionary</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.TypedDictionary</class-id><body>Super class of all dictionaries with a 'Type' key</body></comment><class><name>Annot</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.Annot</class-id><body>PDF Annotation dictionary as defined in PDF 32000_2008.pdf, section 12.5.2, pp. 382.The optional Annots entry in a page object holds an array of annotation dictionaries, each representing an annotation associated with the given page.The dictionary may contain additional entries specific to a particular annotation type.A given annotation dictionary shall be referenced from the Annots array of only one page.This requirement applies only to the annotation dictionary itself, not to subsidiary objects, which may be shared among multiple annotations.</body></comment><class><name>Markup</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Annot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.Markup</class-id><body>PDF Markup Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.2, pp. 391.Many annotation types are defined as markup annotations because they are used primarily to mark up PDF documents.These annotations have text that appears as part of the annotation and may be displayed in other ways by a conforming reader, such as in a Comments pane.</body></comment><class><name>RedactAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.RedactAnnotation</class-id><body>PDF Redaction Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.23, pp. 412.A redaction annotation identifies content that is intended to be removed from the document.The intent of redaction annotations is to enable the following process:	a)	Content identification. A user applies redact annotations that specify the pieces or regions of content that should be removed.		Up until the next step is performed, the user can see, move and redefine these annotations.	b)	Content removal. The user instructs the viewer application to apply the redact annotations, after which the content in the area specified by the redact annotations is removed.		In the removed content’s place, some marking appears to indicate the area has been redacted.		Also, the redact annotations are removed from the PDF document.Redaction annotations provide a mechanism for the first step in the redaction process (content identification).This allows content to be marked for redaction in a non-destructive way, thus enabling a review process for evaluating potential redactions prior to removing the specified content.Redaction annotations shall provide enough information to be used in the second phase of the redaction process (content removal).This phase is application-specific and requires the conforming reader to remove all content identified by the redaction annotation, as well as the annotation itself.</body></comment><class><name>Type</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pdfType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.Type</class-id><body>A type specified by a pragma in an attribute method.Used for type checking attribute values and their specialization.</body></comment><class><name>DictionaryType</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.DictionaryType</class-id><body>This type matches a uniform dictionary of attribute values of the same class.The values of the dictionary are checked and specialized with the type</body></comment><class><name>RunLengthDecode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Filter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.RunLengthDecode</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 29.Decompresses data encoded using a byte-oriented run-length encoding algorithm, reproducing the original text or binary data(typically monochrome image data, or any data that contains frequent long runs of a single byte value).</body></comment><class><name>ShadingDictionary</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Shading</package></attributes></class><comment><class-id>Graphics.PDF.ShadingDictionary</class-id><body>PDF Shading as defined in PDF 32000_2008.pdf pp. 182.A shading dictionary specifies details of a particular gradient fill, including the type of shading to be used, the geometry of the area to be shaded, and the geometry of the gradient fill.See ShadingStream</body></comment><class><name>AxialShading</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ShadingDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Shading</package></attributes></class><comment><class-id>Graphics.PDF.AxialShading</class-id><body>PDF Shading as defined in PDF 32000_2008.pdf pp. 185.Type 2 (axial) shadings define a colour blend that varies along a linear axis between two endpoints and extends indefinitely perpendicular to that axis. The shading may optionally be extended beyond either or both endpoints by continuing the boundary colours indefinitely.This type of shading shall not be used with an Indexed colour space.</body></comment><class><name>Operation</name><environment>Graphics.PDF</environment><super>Value</super><private>true</private><indexed-type>none</indexed-type><inst-vars>operands </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.Operation</class-id><body>PDF Operator as defined in PDF 32000_2008.pdf pp. 82.An operator is a PDF keyword specifying some action that shall be performed, such as painting a graphical shape on the page.An operator keyword shall be distinguished from a name object by the absence of an initial SOLIDUS character (2Fh) (/).Operators shall be meaningful only inside a content stream.</body></comment><class><name>TextObjectOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.TextObjectOperation</class-id><body>PDF Text Object Operator as defined in PDF 32000_2008.pdf, section 9.4, pp. 248.A PDF text object consists of operators that may show text strings, move the text position, and set text state and certain other parameters. In addition, three parameters may be specified only within a text object and shall not persist from one text object to the next:	•	Tm, 	the text matrix	•	Tlm, 	the text line matrix	•	Trm, 	the text rendering matrix, which is actually just an intermediate result that combines the effects of text state parameters, 				the text matrix (Tm), and the current transformation matrix.A text object begins with the BT operator and ends with the ET operator.</body></comment><class><name>EndText</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextObjectOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.EndText</class-id><body>End a text object, discarding the text matrix</body></comment><class><name>TextStateOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.TextStateOperation</class-id><body>PDF Text State Operator as defined in PDF 32000_2008.pdf, section 9.3.1, pp. 243.The text state comprises those graphics state parameters that only affect text. There are nine parameters in the text state.	Tc		Character spacing	Tw		Word spacing	Th		Horizontal scaling	Tl		Leading	Tf		Text font	Tfs		Text font size	Tmode	Text rendering mode	Trise	Text rise	Tk		Text knockoutExcept for the previously described Tf and Tfs, these parameters are discussed further in subsequent sub-clauses. (three additional text-related parameters may occur only within a text object: 	Tm, the text matrix; 	Tlm, the text line matrix; and 	Trm, the text rendering matrix.) The values of the text state parameters shall be consulted when text is positioned and shown. In particular, the spacing and scaling parameters shall be used in a computation. The text knockout parameter, Tk, shall be set through the TK entry in a graphics state parameter dictionary by using the gs operator. There is no specific operator for setting this parameter.The text state operators may appear outside text objects, and the values they set are retained across text objects in a single content stream. Like other graphics state parameters, these parameters shall be initialized to their default values at the beginning of each page</body></comment><class><name>TextFont</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.TextFont</class-id><body>Set the text font, Tf, to font and the text font size, Tfs, to size. font shall be the name of a font resource in the Font subdictionary of the current resource dictionary; size shall be a number representing a scale factor. There is no initial value for either font or size; they shall be specified explicitly by using Tf before any text is shown</body></comment><class><name>TextPositioningOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.TextPositioningOperation</class-id><body>PDF Text Positioning Operator as defined in PDF 32000_2008.pdf, section 9.4.2, pp. 249.Text space is the coordinate system in which text is shown. It shall be defined by the text matrix, Tm, and the text state parameters Tfs, Th, and Trise, which together shall determine the transformation from text space to user space. Specifically, the origin of the first glyph shown by a text-showing operator shall be placed at the origin of text space. If text space has been translated, scaled, or rotated, then the position, size, or orientation of the glyph in user space shall be correspondingly altered.The text-positioning operators shall only appear within text objects.</body></comment><class><name>SetTextMatrix</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextPositioningOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetTextMatrix</class-id><body>Set the text matrix, Tm, and the text line matrix, Tlm.                    [ a b 0 ]Tm := Tlm := [ c d 0 ]                    [ e f 1 ]The operands shall all be numbers, and the initial value for Tm and Tlm shall be the identity matrix, [1 0 0 1 0 0]. Although the operands specify a matrix, they shall be passed to Tm as six separate numbers, not as an array.The matrix specified by the operands shall not be concatenated onto the current text matrix, but shall replace it</body></comment><class><name>PathPaintingOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.PathPaintingOperation</class-id><body>PDF Path-Painting Operators as defined in PDF 32000_2008.pdf, section 8.5.3, pp. 134.The path-painting operators end a path object, causing it to be painted on the current page in the manner that the operator specifies. The principal path-painting operators shall be S (for stroking) and f (for filling). Variants of these operators combine stroking and filling in a single operation or apply different rules for determining the area to be filled.</body></comment><class><name>FillEvenOdd</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathPaintingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.FillEvenOdd</class-id><body>Fill the path, using the even-odd rule to determine the region to fill</body></comment><class><name>TextShowingOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.TextShowingOperation</class-id><body>PDF Text Showing Operator as defined in PDF 32000_2008.pdf, section 9.4.3, pp. 250.The text-showing operators shall show text on the page, repositioning text space as they do so. All of the operators shall interpret the text string and apply the text state parameters.The text-showing operators shall only appear within text objects.</body></comment><class><name>ShowTextOnNextLine</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextShowingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.ShowTextOnNextLine</class-id><body>Move to the next line and show a text string. This operator shall have the same effect as the code	T*	string Tj</body></comment><class><name>PDFValue</name><environment>Graphics.PDF</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.PDFValue</class-id><body>A PDF value entity.Abstract superclass of all PDF values, i.e. objects which do not change after creation.The sister class hierarchy contains PDF Objects.</body></comment><class><name>NativeValue</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>content </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.NativeValue</class-id><body>A PDF value which has a corresponding Smalltalk class.The Smalltalk value is held in the instvar #value.Values are created with: #on:</body></comment><class><name>Number</name><environment>Graphics.PDF</environment><super>Graphics.PDF.NativeValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.Number</class-id><body>PDF Number object as defined in PDF 32000_2008.pdf p. 14.Real objects represent mathematical real numbers.The range and precision of numbers may be limited by the internal representations used in the computer on which the conforming reader is running.</body></comment><class><name>Real</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.Real</class-id><body>PDF Number object as defined in PDF 32000_2008.pdf p. 14.A real value shall be written as one or more decimal digits with an optional sign and a leading, trailing, or embedded PERIOD (2Eh) (decimal point).The value shall be interpreted as a real number and shall be converted to a real object.</body></comment><class><name>GraphicsObject</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operations state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.GraphicsObject</class-id><body>An object occuring in the page contents stream</body></comment><class><name>TextSegment</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.TextSegment</class-id><body>a string styled in a uniform wayThe text cannot contail line breaks</body></comment><class><name>CalRGBColourSpaceDictionary</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.CalRGBColourSpaceDictionary</class-id><body>PDF CalRGB Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.5.3, pp. 146.A CalRGB colour space is a CIE-based ABC colour space with only one transformation stage instead of two. In this type of space, A, B, and C represent calibrated red, green, and blue colour values. These three colour components shall be in the range 0.0 to 1.0; component values falling outside that range shall be adjusted to the nearest valid value without error indication. The decoding functions are gamma functions whose coefficients shall be specified by the Gamma entry in the colour space dictionary. The transformation matrix shall be defined by the dictionary’s Matrix entry. Since there is no second transformation stage, “Decode LMN” and “Matrix LMN” shall be implicitly taken to be identity transformations.</body></comment><class><name>Reference</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Entity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>number generation referent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.Reference</class-id><body>PDF Reference to an indirect object as defined in PDF 32000_2008.pdf pp. 21.</body></comment><class><name>LinkAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Annot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.LinkAnnotation</class-id><body>PDF Link Annotation as defined in PDF 32000_2008.pdf, section 12.5.6.5, pp. 394.A link annotation represents either a hypertext link to a destination elsewhere in the document or an action to be performed</body></comment><class><name>XObjectOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.XObjectOperation</class-id><body>PDF External Objects as defined in PDF 32000_2008.pdf, section 8.8, pp. 201.An external object (commonly called an XObject) is a graphics object whose contents are defined by a self-contained stream, separate from the content stream in which it is used. There are three types of external objects:	•	An image XObject represents a sampled visual image such as a photograph.	•	A form XObject is a self-contained description of an arbitrary sequence of graphics objects.	•	A PostScript XObject contains a fragment of code expressed in the PostScript page description language. 		PostScript XObjects should not be used.Two further categories of external objects, group XObjects and reference XObjects (both PDF 1.4), are actually specialized types of form XObjects with additional properties.Any XObject can be painted as part of another content stream by means of the Do operator. This operator applies to any type of XObject—image, form, or PostScript. The syntax is the same in all cases, although details of the operator’s behaviour differ depending on the type.</body></comment><class><name>Stream</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter internal external encrypted </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Streams</package></attributes></class><comment><class-id>Graphics.PDF.Stream</class-id><body>PDF Stream object as defined in PDF 32000_2008.pdf pp. 19.</body></comment><class><name>ICCProfileStream</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.ICCProfileStream</class-id><body>PDF ICCBased Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.5.5, pp. 149.ICCBased colour spaces (PDF 1.3) shall be based on a cross-platform colour profile as defined by the International Color Consortium (ICC).Unlike the CalGray, CalRGB, and Lab colour spaces, which are characterized by entries in the colour space dictionary, an ICCBased colour space shall be characterized by a sequence of bytes in a standard format.</body></comment><class><name>Predictor</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.Predictor</class-id><body>A de/encoder used by ZipFilters as defined in PDF 32000_2008.pdf pp. 27.(see http://gnupdf.org/PNG_and_TIFF_Predictors_Filter)Only the PNG Predictors are implemented.</body></comment><class><name>TIFFPredictor</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Predictor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.TIFFPredictor</class-id><body>The TIFF predictor is not implemented, since it applies mostly to images which is not my focus.See the TIFF specification (http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf) section 14, Horizontal Differencing, for details.</body></comment><class><name>GroupAttributes</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF XObjects</package></attributes></class><comment><class-id>Graphics.PDF.GroupAttributes</class-id><body>PDF Group XObjects as defined in PDF 32000_2008.pdf, section 8.10.3, pp. 220.Every group XObject shall have a group subtype (specified by the S entry in the group attributes dictionary) that determines the format and meaning of the dictionary’s remaining entries. This specification only defines one subtype, a transparency group XObject (subtype Transparency) representing a transparency group for use in the transparent imaging model.</body></comment><class><name>TextMarkup</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.TextMarkup</class-id><body>PDF Text Markup Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.10, pp. 403.Text markup annotations shall appear as highlights, underlines, strikeouts, or jagged (“squiggly”) underlines in the text of a document.When opened, they shall display a pop-up window containing the text of the associated note.</body></comment><class><name>StrikeOutAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextMarkup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.StrikeOutAnnotation</class-id><body>PDF Text Markup Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.10, pp. 403.Text markup annotations shall appear as highlights, underlines, strikeouts, or jagged (“squiggly”) underlines in the text of a document.When opened, they shall display a pop-up window containing the text of the associated note.</body></comment><class><name>HorizontalScaling</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.HorizontalScaling</class-id><body>Set the horizontal scaling, Th, to (scale ÷ 100). scale shall be a number specifying the percentage of the normal width. Initial value: 100 (normal width)</body></comment><class><name>Font</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.Font</class-id><body>PDF Font as defined in PDF 32000_2008.pdf, clause 9.5, pp. 253.A font shall be represented in PDF as a dictionary specifying the type of font, its PostScript name, its encoding, and information that can be used to provide a substitute when the font program is not available. Optionally, the font program may be embedded as a stream object in the PDF file.The font types are distinguished by the Subtype entry in the font dictionary. Type 0 fonts are called composite fonts; other types of fonts are called simple fonts. In addition to fonts, PDF supports two classes of font-related objects, called CIDFonts and CMaps. CIDFonts, like fonts, are collections of glyphs; however, a CIDFont shall not be used directly but only as a component of a Type 0 font.</body></comment><class><name>Parser</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream tokenActions errors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Parsing</package></attributes></class><comment><class-id>Graphics.PDF.Parser</class-id><body>Reads PDF objects of a byte stream.Comments are not remembered</body></comment><class><name>ContentParser</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Parsing</package></attributes></class><comment><class-id>Graphics.PDF.ContentParser</class-id><body>This parser reads PDF content streams.Special restrictions apply.From PDF 32000_2008.pdf pp.81:A content stream, after decoding with any specified filters, shall be interpreted according to the PDF syntax rules.It consists of PDF objects denoting operands and operators.The operands needed by an operator shall precede it in the stream.An operand is a direct object belonging to any of the basic PDF data types except a stream.Dictionaries shall be permitted as operands only by certain specific operators.Indirect objects and object references shall not be permitted at all.An operator is a PDF keyword specifying some action that shall be performed, such as painting a graphical shape on the page.An operator keyword shall be distinguished from a name object by the absence of an initial SOLIDUS character (2Fh) (/).Operators shall be meaningful only inside a content stream.NOTE This postfix notation, in which an operator is preceded by its operands, is superficially the same as in the PostScript language.However, PDF has no concept of an operand stack as PostScript has.In PDF, all of the operands needed by an operator shall immediately precede that operator.Operators do not return results, and operands shall not be left over when an operator finishes execution.</body></comment><class><name>OptionalContentGroup</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.OptionalContentGroup</class-id><body>PDF Optional Content as defined in PDF 32000_2008.pdf section 8.11.2.1, pp. 222.An optional content group is a dictionary representing a collection of graphics that can be made visible or invisible dynamically by users of conforming readers.The graphics belonging to such a group may reside anywhere in the document: they need not be consecutive in drawing order, nor even belong to the same content stream</body></comment><class><name>NameTree</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.NameTree</class-id><body>PDF Name Trees as defined in PDF 32000_2008.pdf pp. 88.A name tree serves a similar purpose to a dictionary—associating keys and values—but by different means.A name tree differs from a dictionary in the following important ways:	• Unlike the keys in a dictionary, which are name objects, those in a name tree are strings.	• The keys are ordered.	• The values associated with the keys may be objects of any type.	Stream objects shall be specified by indirect object references.	The dictionary, array, and string objects should be specified by indirect object references, and other PDF objects (nulls, numbers, booleans, and names) should be specified as direct objects.	• The data structure can represent an arbitrarily large collection of key-value pairs, which can be looked up efficiently without requiring the entire data structure to be read from the PDF file. (In contrast, a dictionary can be subject to an implementation limit on the number of entries it can contain.)A name tree shall be constructed of nodes, each of which shall be a dictionary object.The nodes shall be of three kinds, depending on the specific entries they contain.The tree shall always have exactly one root node, which shall contain a single entry: either Kids or Names but not both.If the root node has a Names entry, it shall be the only node in the tree.If it has a Kids entry, each of the remaining nodes shall be either an intermediate node, that shall contain a Limits entry and a Kids entry, or a leaf node, that shall contain a Limits entry and a Names entry.</body></comment><class><name>NameTreeNode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.NameTree</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.NameTreeNode</class-id><body>PDF Name Trees as defined in PDF 32000_2008.pdf pp. 88.The Kids entries in the root and intermediate nodes define the tree’s structure by identifying the immediate children of each node.</body></comment><class><name>InlineImageOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.InlineImageOperation</class-id><body>PDF Inline Images as defined in PDF 32000_2008.pdf, section 8.9.7, pp. 214.As an alternative to the image XObjects, a sampled image may be specified in the form of an inline image. This type of image shall be defined directly within the content stream in which it will be painted rather than as a separate object. Because the inline format gives the reader less flexibility in managing the image data, it shall be used only for small images (4 KB or less).An inline image object shall be delimited in the content stream by the operators BI (begin image), ID (image data), and EI (end image). BI and ID shall bracket a series of key-value pairs specifying the characteristics of the image, such as its dimensions and colour space; the image data shall follow between the ID and EI operators. The format is thus analogous to that of a stream object such as an image XObject:	BI	…Key-value pairs…	ID	…Image data…	EI</body></comment><class><name>BeginInlineImage</name><environment>Graphics.PDF</environment><super>Graphics.PDF.InlineImageOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.BeginInlineImage</class-id><body>Begin an inline image object</body></comment><class><name>ColourOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.ColourOperation</class-id><body>PDF Colour Operators as defined in PDF 32000_2008.pdf, section 8.6.8, pp. 171.The PDF operators that control colour spaces and colour values. Also colour-related is the graphics state operator ri. Colour operators may appear at the page description level or inside text objects.</body></comment><class><name>SetStrokingRGB</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetStrokingRGB</class-id><body>Set the stroking colour space to DeviceRGB (or the DefaultRGB colour space) and set the colour to use for stroking operations. Each operand shall be a number between 0.0 (minimum intensity) and 1.0 (maximum intensity).</body></comment><class><name>PDFArray</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.PDFArray</class-id><body>PDF Array object as defined in PDF 32000_2008.pdf, section 7.3.6, pp. 18.An array object is a one-dimensional collection of objects arranged sequentially.Unlike arrays in many other computer languages, PDF arrays may be heterogeneous; that is, an array’s elements may be any combination of numbers, strings, dictionaries, or any other objects, including other arrays.An array may have zero elements.</body></comment><class><name>SpecialColourSpace</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.SpecialColourSpace</class-id><body>PDF Special Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.6, pp. 155.Special colour spaces add features or properties to an underlying colour space. There are four special colour space families: Pattern, Indexed, Separation, and DeviceN.</body></comment><class><name>Separation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.SpecialColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.Separation</class-id><body>PDF Separation Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.6.4, pp. 157.A Separation colour space (PDF 1.2) provides a means for specifying the use of additional colorants or for isolating the control of individual colour components of a device colour space for a subtractive device. When such a space is the current colour space, the current colour shall be a single-component value, called a tint, that controls the application of the given colorant or colour components only.</body></comment><class><name>MovieActivation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.MovieActivation</class-id><body>PDF Movies as defined in PDF 32000_2008.pdf, section 13.4, pp. 508.The features described in this sub-clause are obsolescent and their use is no longer recommended.They are superseded by the general multimedia framework described in 13.2, “Multimedia.”PDF shall embed movies within a document by means of movie annotations.Despite the name, a movie may consist entirely of sound with no visible images to be displayed on the screen.The Movie and A (activation) entries in the movie annotation dictionary shall refer, respectively, to a movie dictionary that shall describe the static characteristics of the movie and a movie activation dictionary that shall specify how it shall be presented.</body></comment><class><name>Name</name><environment>Graphics.PDF</environment><super>Graphics.PDF.NativeValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.Name</class-id><body>PDF Name object as defined in PDF 32000_2008.pdf pp. 17.A name is represented by a Symbol, for browsing references</body></comment><class><name>Identity</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Name</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.Identity</class-id><body>the identity function</body></comment><class><name>PathConstructionOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.PathConstructionOperation</class-id><body>PDF Path Construction Operators as defined in PDF 32000_2008.pdf, section 8.5.2, pp. 132.A page description shall begin with an empty path and shall build up its definition by invoking one or more path construction operators to add segments to it. The path construction operators may be invoked in any sequence, but the first one invoked shall be m or re to begin a new subpath. The path definition may conclude with the application of a path-painting operator such as S, f, or b; this operator may optionally be preceded by one of the clipping path operators W or W*.NOTENote that the path construction operators do not place any marks on the page; only the painting operators do that. A path definition is not complete until a path-painting operator has been applied to it.The path currently under construction is called the current path. In PDF (unlike PostScript), the current path is not part of the graphics state and is not saved and restored along with the other graphics state parameters. PDF paths shall be strictly internal objects with no explicit representation. After the current path has been painted, it shall become no longer defined; there is then no current path until a new one is begun with the m or re operator.The trailing endpoint of the segment most recently added to the current path is referred to as the current point.If the current path is empty, the current point shall be undefined. Most operators that add a segment to the current path start at the current point; if the current point is undefined, an error shall be generated.All operands shall be numbers denoting coordinates in user space.</body></comment><class><name>Move</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathConstructionOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.Move</class-id><body>Begin a new subpath by moving the current point to coordinates (x, y), omitting any connecting line segment. If the previous path construction operator in the current path was also m, the new m overrides it; no vestige of the previous m operation remains in the path</body></comment><class><name>Document</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root info version previousId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.Document</class-id><body>A PDF Document represents a sequence of PDF objects for generating a PDF file.The Document shall be created programatically by adding PDF objects to it.A Document writes its objects to a PDF file and takes care of cross references and the file structure.</body></comment><class><name>MarkedContentOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.MarkedContentOperation</class-id><body>PDF Marked Content as defined in PDF 32000_2008.pdf, section 14.6, pp. 552.Marked-content operators (PDF 1.2) may identify a portion of a PDF content stream as a marked-content element of interest to a particular conforming product. Marked-content elements and the operators that mark them shall fall into two categories:	•	The MP and DP operators shall designate a single marked-content point in the content stream.	•	The BMC, BDC, and EMC operators shall bracket a marked-content sequence of objects within the content stream.NOTE 1		This is a sequence not simply of bytes in the content stream but of complete graphics objects. 			Each object is fully qualified by the parameters of the graphics state in which it is rendered.NOTE 2		A graphics application, for example, might use marked content to identify a set of related objects as a group to be processed as a single unit. 			A text-processing application might use it to maintain a connection between a footnote marker in the body of a document and 			the corresponding footnote text at the bottom of the page. 			The PDF logical structure facilities use marked-content sequences to associate graphical content with structure elements.All marked-content operators except EMC shall take a tag operand indicating the role or significance of the marked-content element to the conforming reader. All such tags shall be registered with Adobe Systems to avoid conflicts between different applications marking the same content stream. In addition to the tag operand, the DP and BDC operators shall specify a property list containing further information associated with the marked content. Marked-content operators may appear only between graphics objects in the content stream. They may not occur within a graphics object or between a graphics state operator and its operands. Marked-content sequences may be nested one within another, but each sequence shall be entirely contained within a single content stream.NOTE 3		A marked-content sequence may not cross page boundaries.NOTE 4		The Contents entry of a page object, which may be either a single stream or an array of streams, 			is considered a single stream with respect to marked-content sequences.</body></comment><class><name>MarkedContentPoint</name><environment>Graphics.PDF</environment><super>Graphics.PDF.MarkedContentOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.MarkedContentPoint</class-id><body>Designate a marked-content point. tag shall be a name object indicating the role or significance of the point</body></comment><class><name>Renderer</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>product bounds colorspace contentOperators idsAtfonts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Rendering</package></attributes></class><comment><class-id>Graphics.PDF.Renderer</class-id><body>Renders a graphical object on a PDF Page.Initialized on a PDF Document with a Page</body></comment><class><name>FormRenderer</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Renderer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Rendering</package></attributes></class><comment><class-id>Graphics.PDF.FormRenderer</class-id><body>renders contents on a form</body></comment><class><name>EndMarkedContent</name><environment>Graphics.PDF</environment><super>Graphics.PDF.MarkedContentOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.EndMarkedContent</class-id><body>End a marked-content sequence begun by a BMC or BDC operator</body></comment><class><name>NumberTree</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.NumberTree</class-id><body>PDF Number Trees as defined in PDF 32000_2008.pdf pp. 91.A number tree is similar to a name tree (see NameTree), except that its keys shall be integers instead of strings and shall be sorted in ascending numerical order.The entries in the leaf (or root) nodes containing the key-value pairs shall be named Nums instead of Names as in a name tree.</body></comment><class><name>CharacterSpacing</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.CharacterSpacing</class-id><body>Set the character spacing, Tc, to charSpace, which shall be a number expressed in unscaled text space units. Character spacing shall be used by the Tj, TJ, and ' operators. Initial value: 0</body></comment><class><name>ShowTextPositioned</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextShowingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.ShowTextPositioned</class-id><body>Show one or more text strings, allowing individual glyph positioning. Each element of array shall be either a string or a number. If the element is a string, this operator shall show the string. If it is a number, the operator shall adjust the text position by that amount; that is, it shall translate the text matrix, Tm. The number shall be expressed in thousandths of a unit of text space. This amount shall be subtracted from the current horizontal or vertical coordinate, depending on the writing mode. In the default coordinate system, a positive adjustment has the effect of moving the next glyph painted either to the left or down by the given amount</body></comment><class><name>FillAndStrokeClosed</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathPaintingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.FillAndStrokeClosed</class-id><body>Close, fill, and then stroke the path, using the nonzero winding number rule to determine the region to fill. This operator shall have the same effect as the sequence h B</body></comment><class><name>CIEColourSpace</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.CIEColourSpace</class-id><body>PDF CIE-Based Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.5, pp. 144.Calibrated colour in PDF shall be defined in terms of an international standard used in the graphic arts, television, and printing industries. CIE-based colour spaces enable a page description to specify colour values in a way that is related to human visual perception. The goal is for the same colour specification to produce consistent results on different output devices, within the limitations of each device; Figure L.2 in Annex Lillustrates the kind of variation in colour reproduction that can result from the use of uncalibrated colour on different devices. PDF 1.1 supports three CIE-based colour space families, named CalGray, CalRGB, and Lab; PDF 1.3 added a fourth, named ICCBased.NOTE 1		In PDF 1.1, a colour space family named CalCMYK was partially defined, with the expectation that its definition would be completed in a future version. 			However, this feature has been deprecated. PDF 1.3 and later versions support calibrated four-component colour spaces by means of ICC profiles. 			A conforming reader should ignore CalCMYK colour space attributes and render colours specified in this family as if they had been specified using DeviceCMYK.NOTE 2		The details of the CIE colourimetric system and the theory on which it is based are beyond the scope of this specification; 			see the Bibliography for sources of further information. 			The semantics of CIE-based colour spaces are defined in terms of the relationship between 			the space’s components and the tristimulus values X, Y, and Z of the CIE 1931 XYZ space. 			The CalRGB and Lab colour spaces (PDF 1.1) are special cases of three-component CIE-based colour spaces, 			known as CIE-based ABC colour spaces. 			These spaces are defined in terms of a two-stage, nonlinear transformation of the CIE 1931 XYZ space. 			The formulation of such colour spaces models a simple zone theory of colour vision, 			consisting of a nonlinear trichromatic first stage combined with a nonlinear opponent-colour second stage. 			This formulation allows colours to be digitized with minimum loss of fidelity, an important consideration in sampled images.Colour values in a CIE-based ABC colour space shall have three components, arbitrarily named A, B, and C.The first stage shall transform these components by first forcing their values to a specified range, then applying decoding functions, and then multiplying the results by a 3-by-3 matrix, producing three intermediate components arbitrarily named L, M, and N. The second stage shall transform these intermediate components in a similar fashion, producing the final X, Y, and Z components of the CIE 1931 XYZ space.Colour spaces in the CIE-based families shall be defined by an array	[name dictionary]where name is the name of the family and dictionary is a dictionary containing parameters that further characterize the space. The entries in this dictionary have specific interpretations that depend on the colour space; some entries are required and some are optional. Setting the current stroking or nonstroking colour space to any CIE-based colour space shall initialize all components of the corresponding current colour to 0.0 (unless the range of valid values for a given component does not include 0.0, in which case the nearest valid value shall be substituted.).NOTE 3		The model and terminology used here—CIE-based ABC (above) and CIE-based A (below)—are derived from the PostScript language, 			which supports these colour space families in their full generality. 			PDF supports specific useful cases of CIE-based ABC and CIE-based A spaces; most others can be represented as ICCBased spaces.</body></comment><class><name>TypedStream</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Streams</package></attributes></class><comment><class-id>Graphics.PDF.TypedStream</class-id><body>Super class of all streams with a 'Type' key</body></comment><class><name>XObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF XObjects</package></attributes></class><comment><class-id>Graphics.PDF.XObject</class-id><body>PDF External Objects as defined in PDF 32000_2008.pdf, section 8.8, pp. 201.An external object (commonly called an XObject) is a graphics object whose contents are defined by a self-contained stream, separate from the content stream in which it is used. There are three types of external objects:	•	An image XObject represents a sampled visual image such as a photograph.	•	A form XObject is a self-contained description of an arbitrary sequence of graphics objects.	•	A PostScript XObject contains a fragment of code expressed in the PostScript page description language. 		PostScript XObjects should not be used.Two further categories of external objects, group XObjects and reference XObjects (both PDF 1.4), are actually specialized types of form XObjects with additional properties.Any XObject can be painted as part of another content stream by means of the Do operator. This operator applies to any type of XObject—image, form, or PostScript. The syntax is the same in all cases, although details of the operator’s behaviour differ depending on the type.</body></comment><class><name>FormXObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.XObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF XObjects</package></attributes></class><comment><class-id>Graphics.PDF.FormXObject</class-id><body>PDF Form XObjects as defined in PDF 32000_2008.pdf, section 8.10, pp. 217.A form XObject is a PDF content stream that is a self-contained description of any sequence of graphics objects (including path objects, text objects, and sampled images). A form XObject may be painted multiple times—either on several pages or at several locations on the same page—and produces the same results each time, subject only to the graphics state at the time it is invoked. Not only is this shared definition economical to represent in the PDF file, but under suitable circumstances the conforming reader can optimize execution by caching the results of rendering the form XObject for repeated reuse.NOTE 1		The term form also refers to a completely different kind of object, an interactive form (sometimes called an AcroForm). 			Whereas the form XObjects described in this sub-clause correspond to the notion of forms in the PostScript language, 			interactive forms are the PDF equivalent of the familiar paper instrument. 			Any unqualified use of the word form is understood to refer to an interactive form; 			the type of form described here is always referred to explicitly as a form XObject.</body></comment><class><name>DeviceColourSpace</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Name</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.DeviceColourSpace</class-id><body>PDF Device Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.4, pp. 142.The device colour spaces enable a page description to specify colour values that are directly related to their representation on an output device. Colour values in these spaces map directly (or by simple conversions) to the application of device colorants, such as quantities of ink or intensities of display phosphors. This enables a conforming writer to control colours precisely for a particular device, but the results might not be consistent from one device to another.Output devices form colours either by adding light sources together or by subtracting light from an illuminating source. Computer displays and film recorders typically add colours; printing inks typically subtract them. These two ways of forming colours give rise to two complementary methods of colour specification, called additive and subtractive colour. The most widely used forms of these two types of colour specification are known as RGB and CMYK, respectively, for the names of the primary colours on which they are based. They correspond to the following device colour spaces:	•	DeviceGray controls the intensity of achromatic light, on a scale from black to white.	•	DeviceRGB controls the intensities of red, green, and blue light, the three additive primary colours used in displays.	•	DeviceCMYK controls the concentrations of cyan, magenta, yellow, and black inks, the four subtractive process colours used in printing.NOTEAlthough the notion of explicit colour spaces is a PDF 1.1 feature, the operators for specifying colours in the device colour spaces—G, g, RG, rg, K, and k—are available in all versions of PDF. Beginning with PDF 1.2, colours specified in device colour spaces can optionally be remapped systematically into other colour spaces.In the transparent imaging model (PDF 1.4), the use of device colour spaces is subject to special treatment within a transparency group whose group colour space is CIE-based. In particular, the device colour space operators should be used only if device colour spaces have been remapped to CIE-based spaces by means of the default colour space mechanism. Otherwise, the results are implementation-dependent and unpredictable.</body></comment><class><name>DeviceRGB</name><environment>Graphics.PDF</environment><super>Graphics.PDF.DeviceColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.DeviceRGB</class-id><body>PDF DeviceRGB Colour Space as defined in PDF 32000_2008.pdf, section 8.6.4.3, pp. 143.Colours in the DeviceRGB colour space shall be specified according to the additive RGB (red-green-blue) colour model, in which colour values shall be defined by three components representing the intensities of the additive primary colorants red, green, and blue. Each component shall be specified by a number in the range 0.0 to 1.0, where 0.0 shall denote the complete absence of a primary component and 1.0 shall denote maximum intensity.EXAMPLEThis example shows alternative ways to select the DeviceRGB colour space and a specific colour within that space for stroking operations.	/DeviceRGB CS 	% Set DeviceRGB colour space	red green blue SC 	% Set colour	red green blue RG 	% Set both in one operationThe CS and SC operators shall select the current stroking colour space and current stroking colour separately; RG shall set them in combination. The cs, sc, and rg operators shall perform the same functions for nonstroking operations. Setting either current colour space to DeviceRGB shall initialize the red, green, and blue components of the corresponding current colour to 0.0.</body></comment><class><name>FileEntity</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Entity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.FileEntity</class-id><body>Super class of all PDF objects which make up a File as defined in PDF 32000_2008.pdf pp. 38.The creation of these objects is done by the class method #readFrom: using a PDF.Reader.</body></comment><class><name>Header</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FileEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.Header</class-id><body>PDF File Header as defined in PDF 32000_2008.pdf pp. 40.</body></comment><class><name>ObjectRead</name><environment>Graphics.PDF</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reference object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.ObjectRead</class-id><body>Announced when an object was read from the stream.Includes the reference and the object</body></comment><class><name>PieceInfo</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.PieceInfo</class-id><body>PDF Page-Piece Dictionaries as defined in PDF 32000_2008.pdf, section 14.5, pp. 551.A page-piece dictionary (PDF 1.3) may be used to hold private conforming product data. The data may be associated with a page or form XObject by means of the optional PieceInfo entry in the page object or form dictionary. Beginning with PDF 1.4, private data may also be associated with the PDF document by means of the PieceInfo entry in the document catalogue.NOTE 1		Conforming products may use this dictionary as a place to store private data in connection with that document, page, or form. Such private data can convey information meaningful to the conforming product that produces it (such as information on object grouping for a graphics editor or the layer information used by Adobe Photoshop®) but may be ignored by general-purpose conforming readers.A page-piece dictionary may contain any number of entries, each keyed by the name of a distinct conforming product or of a well-known data type recognized by a family of conforming products. The value associated with each key shall be a data dictionary containing the private data that shall be used by the conforming product. The Private entry may have a value of any data type, but typically it is a dictionary containing all of the private data needed by the conforming product other than the actual content of the document, page, or form.</body></comment><class><name>CmykColor</name><environment>Graphics</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name cyan magenta yellow black rgb </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostScript</category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.CmykColor</class-id><body>CmykColor used for printing.This class is defined in the Smalltalk.Graphics namespace, because it is widely used elsewhere.Instance Variables	name		&lt;String&gt;		the color name	cyan		&lt;Number&gt;		between 0 and 1	magenta	&lt;Number&gt;		between 0 and 1	yellow		&lt;Number&gt;		between 0 and 1	black		&lt;Number&gt;		the k component. Between 0 and 1	rgb			&lt;ByteArray&gt;	optional explicit screen color. ByteArray with 3 bytes (RGB)</body></comment><class><name>ShadingOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.ShadingOperation</class-id><body>PDF Shading Operator as defined in PDF 32000_2008.pdf, section 8.7.4.2, pp. 181.When the area to be painted is a relatively simple shape whose geometry is the same as that of the gradient fill itself, the sh operator may be used instead of the usual painting operators. sh accepts a shading dictionary as an operand and applies the corresponding gradient fill directly to current user space. This operator does not require the creation of a pattern dictionary or a path and works without reference to the current colour in the graphics state.NOTE	Patterns defined by type 2 pattern dictionaries do not tile. 		To create a tiling pattern containing a gradient fill, invoke the sh operator from within the content stream of a type 1 (tiling) pattern.</body></comment><class><name>PaintShading</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ShadingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.PaintShading</class-id><body>Paint the shape and colour shading described by a shading dictionary, subject to the current clipping path. The current colour in the graphics state is neither used nor altered. The effect is different from that of painting a path using a shading pattern as the current colour.name is the name of a shading dictionary resource in the Shading subdictionary of the current resource dictionary. All coordinates in the shading dictionary are interpreted relative to the current user space. (By contrast, when a shading dictionary is used in a type 2 pattern, the coordinates are expressed in pattern space.) All colours are interpreted in the colour space identified by the shading dictionary’s ColorSpace entry. The Background entry, if present, is ignored.This operator should be applied only to bounded or geometrically defined shadings. If applied to an unbounded shading, it paints the shading’s gradient fill across the entire clipping region, which may be time-consuming</body></comment><class><name>LineJoin</name><environment>Graphics.PDF</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.LineJoin</class-id><body>PDF Line Cap Style as defined in PDF 32000_2008.pdf, section 8.4.3.4, pp. 125.The line join style shall specify the shape to be used at the corners of paths that are stroked. Table 55 shows the possible values. Join styles shall be significant only at points where consecutive segments of a path connect at an angle; segments that meet or intersect fortuitously shall receive no special treatment.0	Miter join	The outer edges of the strokes for the two segments shall beextended until they meet at an angle, as in a picture frame. 				If the segments meet at too sharp an angle (as defined by the miter limit parameter), a bevel join shall be used instead.1	Round join	An arc of a circle with a diameter equal to the line width shall be drawn around the point where the two segments meet, 				connecting the outer edges of the strokes for the two segments. 				This pieslice-shaped figure shall be filled in, producing a rounded corner.2	Bevel join	The two segments shall be finished with butt caps and the resulting notch beyond the ends of the segments shall be filled with a triangle.</body></comment><class><name>CIDSystemInfo</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.CIDSystemInfo</class-id><body>PDF CIDSystemInfo Dictionaries as defined in PDF 32000_2008.pdf, clause 9.7.3, pp. 268.CIDFont and CMap dictionaries shall contain a CIDSystemInfo entry specifying the character collection assumed by the CIDFont associated with the CMap—that is, the interpretation of the CID numbers used by the CIDFont.A character collection shall be uniquely identified by the Registry, Ordering, and Supplemententries in the CIDSystemInfo dictionary.In order to be compatible, the Registry and Ordering values must be the same.The CIDSystemInfo entry in a CIDFont is a dictionary that shall specify the CIDFont’s character collection.The CIDFont need not contain glyph descriptions for all the CIDs in a collection; it may contain a subset.The CIDSystemInfo entry in a CMap file shall be either a single dictionary or an array of dictionaries, depending on whether it associates codes with a single character collection or with multiple character collections.For proper behaviour, the CIDSystemInfo entry of a CMap shall be compatible with that of the CIDFont or CIDFonts with which it is used.</body></comment><class><name>Type3</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Font</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.Type3</class-id><body>PDF Type3 Font as defined in PDF 32000_2008.pdf, clause 9.6.5, pp. 258.Type 3 fonts differ from the other fonts supported by PDF. A Type 3 font dictionary defines the font; font dictionaries for other fonts simply contain information about the font and refer to a separate font program for the actual glyph descriptions. In Type 3 fonts, glyphs shall be defined by streams of PDF graphics operators. These streams shall be associated with glyph names. A separate encoding entry shall map character codes to the appropriate glyph names for the glyphs.NOTE 1		Type 3 fonts are more flexible than Type 1 fonts because the glyph descriptions may contain arbitrary PDF graphics operators. 			However, Type 3 fonts have no hinting mechanism for improving output at small sizes or low resolutions.</body></comment><class><name>GraphicsStateOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.GraphicsStateOperation</class-id><body>PDF Graphics State Operators as defined in PDF 32000_2008.pdf, section 8.4.4, pp. 127.Operators that set the values of parameters in the graphics state.</body></comment><class><name>SaveState</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SaveState</class-id><body>Save the current graphics state on the graphics state stack</body></comment><class><name>CrossReference</name><environment>Graphics.PDF</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value number generation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.CrossReference</class-id><body>A Cross-Reference Entry in a subsection of a section of the cross-reference table as defined in PDF 32000_2008.pdf pp. 40.Each cross-reference entry shall be exactly 20 bytes long, including the end-of-line marker. There are two kinds of cross-reference entries: one for objects that are in use and another for objects that have been deleted and therefore are free. Both types of entries have similar basic formats, distinguished by the keyword n (for an in-use entry) or f (for a free entry).</body></comment><class><name>UsedReference</name><environment>Graphics.PDF</environment><super>Graphics.PDF.CrossReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.UsedReference</class-id><body>A Cross-Reference in-use Entry as defined in PDF 32000_2008.pdf pp. 40.The format of an in-use entry shall be:	nnnnnnnnnn ggggg n eolwhere:	nnnnnnnnnn shall be a 10-digit byte offset in the decoded stream	ggggg shall be a 5-digit generation number	n shall be a keyword identifying this as an in-use entry	eol shall be a 2-character end-of-line sequenceThe byte offset in the decoded stream shall be a 10-digit number, padded with leading zeros if necessary, giving the number of bytes from the beginning of the file to the beginning of the object. It shall be separated from the generation number by a single SPACE. The generation number shall be a 5-digit number, also padded with leading zeros if necessary. Following the generation number shall be a single SPACE, the keyword n, and a 2-character end-of-line sequence consisting of one of the following: SP CR, SP LF, or CR LF. Thus, the overall length of the entry shall always be exactly 20 bytes.</body></comment><class><name>StreamReference</name><environment>Graphics.PDF</environment><super>Graphics.PDF.UsedReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.StreamReference</class-id><body>A Cross-Reference in-use Entry for an object in an object stream as defined in PDF 32000_2008.pdf pp. 51.</body></comment><class><name>ClosePath</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathConstructionOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.ClosePath</class-id><body>Close the current subpath by appending a straight line segment from the current point to the starting point of the subpath. If the current subpath is already closed, h shall do nothing.This operator terminates the current subpath. Appending another segment to the current path shall begin a new subpath, even if the new segment begins at the endpoint reached by the h operation</body></comment><class><name>SoundAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.SoundAnnotation</class-id><body>PDF Sound Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.16, pp. 406.A sound annotation shall analogous to a text annotation except that instead of a text note, it contains sound recorded from the computer’s microphone or imported from a file.When the annotation is activated, the sound shall be played.The annotation shall behave like a text annotation in most ways, with a different icon (by default, a speaker) to indicate that it represents a sound.</body></comment><class><name>FlateEncodeStream</name><environment>Graphics.PDF</environment><super>OS.ZLib.DeflateStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.ZLib.*			</imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.FlateEncodeStream</class-id><body>A simple zlib deflate stream without header or checksum used by PDF as defined in PDF 32000_2008.pdf pp. 25.</body></comment><class><name>Trailer</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.Trailer</class-id><body>PDF File Trailer as defined in PDF 32000_2008.pdf pp. 42.</body></comment><class><name>FillEvenOddAndStroke</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathPaintingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.FillEvenOddAndStroke</class-id><body>Fill and then stroke the path, using the even-odd rule to determine the region to fill. This operator shall produce the same result as B, except that the path is filled as if with f* instead of f</body></comment><class><name>Type1</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Font</super><private>false</private><indexed-type>none</indexed-type><inst-vars>usedExtraGlyphs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.Type1</class-id><body>PDF Type1 Font as defined in PDF 32000_2008.pdf, clause 9.6.2, pp. 254.A Type 1 font program is a stylized PostScript program that describes glyph shapes. It uses a compact encoding for the glyph descriptions, and it includes hint information that enables high-quality rendering even at small sizes and low resolutions.NOTE 1		Details on this format are provided in a separate specification, Adobe Type 1 Font Format. 			An alternative, more compact but functionally equivalent representation of a Type 1 font program is 			documented in Adobe Technical Note #5176, The Compact Font Format Specification.NOTE 2		Although a Type 1 font program uses PostScript language syntax, using it does not require 			a full PostScript interpreter; a specialized Type 1 font interpreter suffices.Some entries are optional for the standard 14 fonts, but are required otherwise.</body></comment><class><name>TrueType</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type1</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.TrueType</class-id><body>PDF TrueType Fonts as defined in PDF 32000_2008.pdf, clause 9.6.3, pp. 257.A TrueType font dictionary may contain the same entries as a Type 1 font dictionary, with these differences:	•	The value of Subtype shall be TrueType.	•	The value of Encoding is subject to limitations that are described in 9.6.6, "Character Encoding".	•	The value of BaseFont is derived differently.The PostScript name for the value of BaseFont may be determined in one of two ways:	•	If the TrueType font program's “name” table contains a PostScript name, it shall be used.	•	In the absence of such an entry in the “name” table, a PostScript name shall be derived from the name by which the font is known in the host operating system. 		On a Windows system, the name shall be based on the lfFaceName field in a LOGFONT structure; 		in the Mac OS, it shall be based on the name of the FOND resource. 		If the name contains any SPACEs, the SPACEs shall be removed.NOTE 1		The TrueType font format was developed by Apple Computer, Inc., and has been adopted 			as a standard font format for the Microsoft Windows operating system. 			Specifications for the TrueType font file format are available in Apple’s TrueType Reference Manual and 			Microsoft’s TrueType 1.0 Font Files Technical Specification (see Bibliography).NOTE 2		A TrueType font program may be embedded directly in a PDF file as a stream object.NOTE 3		The Type 42 font format that is defined for PostScript does not apply to PDF.NOTE 4		For CJK (Chinese, Japanese, and Korean) fonts, the host font system’s font name is often encoded in the host operating system’s script. 			For instance, a Japanese font may have a name that is written in Japanese using some (unidentified) Japanese encoding. 			Thus, TrueType font names may contain multiple-byte character codes, 			each of which requires multiple characters to represent in a PDF name object (using the # notation to quote special characters as needed).</body></comment><class><name>GraphicsCollector</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.GraphicsCollector</class-id><body>a sequence of GraphicsObjects and maybe nested GraphicsCollectors</body></comment><class><name>MarkedObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.MarkedObject</class-id><body>operations between BDC or BMC and EMC</body></comment><class><name>Fill</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathPaintingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.Fill</class-id><body>Fill the path, using the nonzero winding number rule to determine the region to fill. Any subpaths that are open shall be implicitly closed before being filled</body></comment><class><name>ShadingStream</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Shading</package></attributes></class><comment><class-id>Graphics.PDF.ShadingStream</class-id><body>PDF Shading as defined in PDF 32000_2008.pdf pp. 182.A shading stream specifies details of a particular gradient fill, including the type of shading to be used, the geometry of the area to be shaded, and the geometry of the gradient fill.See ShadingDictionary</body></comment><class><name>FreeFormGouraudShadedMesh</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ShadingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Shading</package></attributes></class><comment><class-id>Graphics.PDF.FreeFormGouraudShadedMesh</class-id><body>PDF Shading as defined in PDF 32000_2008.pdf pp. 189.Type 4 shadings (free-form Gouraud-shaded triangle meshes) are commonly used to represent complex coloured and shaded three-dimensional shapes.The area to be shaded is defined by a path composed entirely of triangles.The colour at each vertex of the triangles is specified, and a technique known as Gouraud interpolation is used to colour the interiors.The interpolation functions defining the shading may be linear or nonlinear.</body></comment><class><name>SetStrokingGray</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetStrokingGray</class-id><body>Set the stroking colour space to DeviceGray (or the DefaultGray colour space) and set the gray level to use for stroking operations. gray shall be a number between 0.0 (black) and 1.0 (white).</body></comment><class><name>UndefinedType</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.UndefinedType</class-id><body>A type for anything unrecognized</body></comment><class><name>TrapNetAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Annot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.TrapNetAnnotation</class-id><body>PDF Trap Network Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.21, pp. 410.and PDF Trapping Support as defined in PDF 32000_2008.pdf, section 14.11.6.2, pp. 636.A trap network annotation may be used to define the trapping characteristics for a page of a PDF document.	NOTE	Trapping is the process of adding marks to a page along colour boundaries to avoid unwanted visual artifacts resulting from misregistration of colorants when the page is printed.A page shall have no more than one trap network annotation, whose Subtype entry has the value TrapNet and which shall always be the last element in the page object’s Annots array.</body></comment><class><name>FunctionDictionary</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.FunctionDictionary</class-id><body>PDF Function Dictionary as defined in PDF 32000_2008.pdf section 7.10, pp. 92.PDF is not a programming language, and a PDF file is not a program.However, PDF provides several types of function objects (PDF 1.2) that represent parameterized classes of functions, including mathematical formulas and sampled representations with arbitrary resolution.</body></comment><class><name>NextLineRelative</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextPositioningOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.NextLineRelative</class-id><body>Move to the start of the next line, offset from the start of the current line by (tx, ty). tx and ty shall denote numbers expressed in unscaled text space units. More precisely, this operator shall perform these assignments:                    [ 1  0  0 ]Tm := Tlm := [  0  1  0 ] * Tlm                    [ tx ty 1 ]</body></comment><class><name>Catalog</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.Catalog</class-id><body>PDF Catalog as defined in PDF 32000_2008.pdf pp. 71.The root of a document’s object hierarchy is the catalog dictionary, located by means of the Root entry in the trailer of the PDF file (see Trailer). The catalog contains references to other objects defining the document’s contents, outline, article threads, named destinations, and other attributes. In addition, it contains information about how the document shall be displayed on the screen, such as whether its outline and thumbnail page images shall be displayed automatically and whether some location other than the first page shall be shown when the document is opened.</body></comment><class><name>Encryption</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.Encryption</class-id><body>PDF Encryption as defined in PDF 32000_2008.pdf pp. 55.A PDF document can be encrypted to protect its contents from unauthorized access.Encryption applies to all strings and streams in the document's PDF file, with the following exceptions:	• The values for the ID entry in the trailer	• Any strings in an Encrypt dictionary	• Any strings that are inside streams such as content streams and compressed object streams, which themselves are encryptedEncryption is not applied to other object types such as integers and boolean values, which are used primarily to convey information about the document's structure rather than its contents.Leaving these values unencrypted allows random access to the objects within a document, whereas encrypting the strings and streams protects the document's contents.When a PDF stream object refers to an external file, the stream’s contents shall not be encrypted, since they are not part of the PDF file itself.However, if the contents of the stream are embedded within the PDF file, they shall be encrypted like any other stream in the file.Beginning with PDF 1.5, embedded files can be encrypted in an otherwise unencrypted document.Encryption-related information shall be stored in a document’s encryption dictionary, which shall be the value of the Encrypt entry in the document’s trailer dictionary.The absence of this entry from the trailer dictionary means that a conforming reader shall consider the document to be not encrypted.</body></comment><class><name>PolygonPolyline</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.PolygonPolyline</class-id><body>PDF Polygon and Polyline Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.9, pp. 402.Polygon annotations display closed polygons on the page.Such polygons may have any number of vertices connected by straight lines.Polyline annotations are similar to polygons, except that the first and last vertex are not implicitly connected.</body></comment><class><name>PolyLineAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PolygonPolyline</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.PolyLineAnnotation</class-id><body>PDF Polygon and Polyline Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.9, pp. 402.Polygon annotations display closed polygons on the page.Such polygons may have any number of vertices connected by straight lines.Polyline annotations are similar to polygons, except that the first and last vertex are not implicitly connected.</body></comment><class><name>ExplicitDestination</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.ExplicitDestination</class-id><body>PDF Explicit Destination as defined in PDF 32000_2008.pdf, section 12.3.2.2, pp. 366.The table shows the allowed syntactic forms for specifying a destination explicitly in a PDF file.In each case, page is an indirect reference to a page object (except in a remote go-to action).All coordinate values (left, right, top, and bottom) shall be expressed in the default user space coordinate system.The page’s bounding box is the smallest rectangle enclosing all of its contents.(If any side of the bounding box lies outside the page’s crop box, the corresponding side of the crop box shall be used instead.)No page object can be specified for a destination associated with a remote go-to action because the destination page is in a different PDF document.In this case, the page parameter specifies an integer page number within the remote document instead of a page object in the current document.[page /XYZ left top zoom]Display the page designated by page, with the coordinates (left, top) positioned at the upper-left corner of the window and the contents of the page magnified by the factor zoom.A null value for any of the parameters left, top, or zoom specifies that the current value of that parameter shall be retained unchanged.A zoom value of 0 has the same meaning as a null value.[page /Fit]Display the page designated by page, with its contents magnified just enough to fit the entire page within the window both horizontally and vertically.If the required horizontal and vertical magnification factors are different, use the smaller of the two, centering the page within the window in the other dimension.[page /FitH top]Display the page designated by page, with the vertical coordinate toppositioned at the top edge of the window and the contents of the page magnified just enough to fit the entire width of the page within the window.A null value for top specifies that the current value of that parameter shall be retained unchanged.[page /FitV left]Display the page designated by page, with the horizontal coordinate left positioned at the left edge of the window and the contents of the page magnified just enough to fit the entire height of the page within the window.A null value for left specifies that the current value of that parameter shall be retained unchanged.[page /FitR left bottom right top]Display the page designated by page, with its contents magnified just enough to fit the rectangle specified by the coordinates left, bottom, right, and top entirely within the window both horizontally and vertically.If the required horizontal and vertical magnification factors are different, use the smaller of the two, centering the rectangle within the window in the other dimension.[page /FitB](PDF 1.1) Display the page designated by page, with its contents magnified just enough to fit its bounding box entirely within the window both horizontally and vertically.If the required horizontal and vertical magnification factors are different, use the smaller of the two, centering the bounding box within the window in the other dimension.[page /FitBH top](PDF 1.1) Display the page designated by page, with the vertical coordinate top positioned at the top edge of the window and the contents of the page magnified just enough to fit the entire width of its bounding box within the window.A null value for top specifies that the current value of that parameter shall be retained unchanged.[page /FitBV left](PDF 1.1) Display the page designated by page, with the horizontal coordinate left positioned at the left edge of the window and the contents of the page magnified just enough to fit the entire height of its bounding box within the window.A null value for left specifies that the current value of that parameter shall be retained unchanged.</body></comment><class><name>GraphicsObjectWithResource</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.GraphicsObjectWithResource</class-id><body>an object with a resource from the Resources dictionary</body></comment><class><name>OperationObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsObjectWithResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>redundant </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.OperationObject</class-id><body>simple wrapper for a single operator.May contain a resolved resource</body></comment><class><name>Indexed</name><environment>Graphics.PDF</environment><super>Graphics.PDF.SpecialColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.Indexed</class-id><body>PDF Indexed Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.6.3, pp. 156.An Indexed colour space specifies that an area is to be painted using a colour map or colour table of arbitrary colours in some other space. A conforming reader shall treat each sample value as an index into the colour table and shall use the colour value it finds there. This technique can considerably reduce the amount of data required to represent a sampled image.</body></comment><class><name>ZipFilter</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Filter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>predictor colors bitsPerComponent columns predictors predicted </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.ZipFilter</class-id><body>Zip filters as defined in PDF 32000_2008.pdf pp. 25.This class implements some common state and functionality for Zip-based filters.</body></comment><class><name>FlateDecode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ZipFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.FlateDecode</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 25.Decompresses data encoded using the zlib/deflate compression method, reproducing the original text or binary data.</body></comment><class><name>Stroke</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathPaintingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.Stroke</class-id><body>Stroke the path</body></comment><class><name>SetStrokingColorSpace</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetStrokingColorSpace</class-id><body>Set the current colour space to use for stroking operations. The operand name shall be a name object. If the colour space is one that can be specified by a name and no additional parameters (DeviceGray, DeviceRGB, DeviceCMYK, and certain cases of Pattern), the name may be specified directly. Otherwise, it shall be a name defined in the ColorSpace subdictionary of the current resource dictionary; the associated value shall be an array describing the colour space.The names DeviceGray, DeviceRGB, DeviceCMYK, and Pattern always identify the corresponding colour spaces directly; they never refer to resources in the ColorSpace subdictionary.The CS operator shall also set the current stroking colour to its initial value, which depends on the colour space:In a DeviceGray, DeviceRGB, CalGray, or CalRGB colour space, the initial colour shall have all components equal to 0.0.In a DeviceCMYK colour space, the initial colour shall be [0.0 0.0 0.0 1.0].In a Lab or ICCBased colour space, the initial colour shall have all components equal to 0.0 unless that falls outside the intervals specified by the space’s Range entry, in which case the nearest valid value shall be substituted.In an Indexed colour space, the initial colour value shall be 0.In a Separation or DeviceN colour space, the initial tint value shall be 1.0 for all colorants.In a Pattern colour space, the initial colour shall be a pattern object that causes nothing to be painted.</body></comment><class><name>Textstream</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Streams</package></attributes></class><comment><class-id>Graphics.PDF.Textstream</class-id><body>PDF Stream object as defined in PDF 32000_2008.pdf pp. 87.A text stream shall be a PDF stream object whose unencoded bytes shall meet the same requirements as a text string with respect to encoding, byte order, and lead bytes.</body></comment><class><name>PageTree</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.PageTree</class-id><body>PDF Page Tree as defined in PDF 32000_2008.pdf pp. 75.The pages of a document are accessed through a structure known as the page tree, which defines the ordering of pages in the document.Using the tree structure, conforming readers using only limited memory, can quickly open a document containing thousands of pages.The tree contains nodes of two types—intermediate nodes, called page tree nodes, and leaf nodes, called page objects.Conforming products shall be prepared to handle any form of tree structure built of such nodes.</body></comment><class><name>Page</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PageTree</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.Page</class-id><body>PDF Page as defined in PDF 32000_2008.pdf pp. 77.The leaves of the page tree are page objects, each of which is a dictionary specifying the attributes of a single page of the document.The table also identifies which attributes a page may inherit from its ancestor nodes in the page tree.Attributes that are not explicitly identified in the table as inheritable shall not be inherited.</body></comment><class><name>ThreeDActivation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.ThreeDActivation</class-id><body>PDF 3D Annotations as defined in PDF 32000_2008.pdf, section 13.6.2, pp. 514.An activation dictionary determines how the state of the annotation and its associated artwork may change.</body></comment><class><name>SetStrokingCMYK</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetStrokingCMYK</class-id><body>Set the stroking colour space to DeviceCMYK (or the DefaultCMYK colour space) and set the colour to use for stroking operations. Each operand shall be a number between 0.0 (zero concentration) and 1.0 (maximum concentration). The behaviour of this operator is affected by the overprint mode.</body></comment><class><name>SetRenderingIntent</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetRenderingIntent</class-id><body>Set the colour rendering intent in the graphics state</body></comment><class><name>DirectType</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.DirectType</class-id><body>This type matches a concrete PDF.Object class - no Reference.</body></comment><class><name>TextRise</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.TextRise</class-id><body>Set the text rise, Trise, to rise, which shall be a number expressed in unscaled text space units. Initial value: 0</body></comment><class><name>DeviceGray</name><environment>Graphics.PDF</environment><super>Graphics.PDF.DeviceColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.DeviceGray</class-id><body>PDF DeviceGrayColour Space as defined in PDF 32000_2008.pdf, section 8.6.4.2, pp. 143.Black, white, and intermediate shades of gray are special cases of full colour. A grayscale value shall be represented by a single number in the range 0.0 to 1.0, where 0.0 corresponds to black, 1.0 to white, and intermediate values to different gray levels.EXAMPLEThis example shows alternative ways to select the DeviceGray colour space and a specific gray level within that space for stroking operations.	/DeviceGray CS 	% Set DeviceGray colour space	gray SC 			% Set gray level	gray G 				% Set both in one operationThe CS and SC operators shall select the current stroking colour space and current stroking colour separately; G shall set them in combination. (The cs, sc, and g operators shall perform the same functions for nonstroking operations.) Setting either current colour space to DeviceGray shall initialize the corresponding current colour to 0.0.</body></comment><class><name>DeviceNMixingHints</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.DeviceNMixingHints</class-id><body>PDF DeviceN Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.6.5, pp. 161.Provides information about the characteristics of colorants that may be used in blending calculations when the actual colorants are not available on the target device.Conforming readers need not use this information</body></comment><class><name>CaretAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.CaretAnnotation</class-id><body>PDF Caret Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.11, pp. 404.A caret annotation is a visual symbol that indicates the presence of text edits.</body></comment><class><name>IsolatedObjectx</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.IsolatedObjectx</class-id><body>operations between #q and #Q</body></comment><class><name>CIDFont</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Font</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.CIDFont</class-id><body>PDF CIDFonts as defined in PDF 32000_2008.pdf, clause 9.7.4, pp. 269.A CIDFont program contains glyph descriptions that are accessed using a CID as the character selector. There are two types of CIDFonts:	•	A Type 0 CIDFont contains glyph descriptions based on CFFNOTE	The term “Type 0” when applied to a CIDFont has a different meaning than for a “Type 0 font”.	•	A Type 2 CIDFont contains glyph descriptions based on the TrueType font formatA CIDFont dictionary is a PDF object that contains information about a CIDFont program. Although its Type value is Font, a CIDFont is not actually a font. It does not have an Encoding entry, it may not be listed in the Font subdictionary of a resource dictionary, and it may not be used as the operand of the Tf operator. It shall be used only as a descendant of a Type 0 font. The CMap in the Type 0 font shall be what defines the encoding that maps character codes to CIDs in the CIDFont.</body></comment><class><name>CIDFontType0</name><environment>Graphics.PDF</environment><super>Graphics.PDF.CIDFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.CIDFontType0</class-id><body>PDF Glyph Selection in CIDFonts as defined in PDF 32000_2008.pdf, clause 9.7.4.2, pp. 270.Type 0 and Type 2 CIDFonts handle the mapping from CIDs to glyph descriptions in somewhat different ways.For Type 0, the CIDFont program contains glyph descriptions that are identified by CIDs. The CIDFont program identifies the character collection by a CIDSystemInfo dictionary, which should be copied into the PDF CIDFont dictionary. CIDs shall be interpreted uniformly in all CIDFont programs supporting a given character collection, whether the program is embedded in the PDF file or obtained from an external source.When the CIDFont contains an embedded font program that is represented in the Compact Font Format (CFF), the FontFile3 entry in the font descriptor may be CIDFontType0C or OpenType. There are two cases, depending on the contents of the font program:	•	The “CFF” font program has a Top DICT that uses CIDFont operators: 		The CIDs shall be used to determine the GID value for the glyph procedure using the charset table in the CFF program. 		The GID value shall then be used to look up the glyph procedure using the CharStrings INDEX table.NOTE	Although in many fonts the CID value and GID value are the same, the CID and GID values may differ.	•	The “CFF” font program has a Top DICT that does not use CIDFont operators: 		The CIDs shall be used directly as GID values, and the glyph procedure shall be retrieved using the CharStrings INDEX.</body></comment><class><name>Error</name><environment>Graphics.PDF</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.Error</class-id><body>Super class of all exceptions thrown by the PDF code</body></comment><class><name>SquareCircle</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.SquareCircle</class-id><body>PDF Square and Circle Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.8, pp. 401.Square and circle annotations shall display, respectively, a rectangle or an ellipse on the page.When opened, they shall display a pop-up window containing the text of the associated note.The rectangle or ellipse shall be inscribed within the annotation rectangle defined by the annotation dictionary’s Rect entry.Despite the names square and circle, the width and height of the annotation rectangle need not be equal.</body></comment><class><name>SquareAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.SquareCircle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.SquareAnnotation</class-id><body>PDF Square and Circle Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.8, pp. 401.Square and circle annotations shall display, respectively, a rectangle or an ellipse on the page.When opened, they shall display a pop-up window containing the text of the associated note.The rectangle or ellipse shall be inscribed within the annotation rectangle defined by the annotation dictionary’s Rect entry.Despite the names square and circle, the width and height of the annotation rectangle need not be equal.</body></comment><class><name>CompatibilityOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.CompatibilityOperation</class-id><body>PDF Content Streams as defined in PDF 32000_2008.pdf, section 7.8.2, pp. 81.Ordinarily, when a conforming reader encounters an operator in a content stream that it does not recognize, an error shall occur. A pair of compatibility operators, BX and EX (PDF 1.1), shall modify this behaviour. These operators shall occur in pairs and may be nested. They bracket a compatibility section, a portion of a content stream within which unrecognized operators shall be ignored without error. This mechanism enables a conforming writer to use operators defined in later versions of PDF without sacrificing compatibility with older applications. It should be used only in cases where ignoring such newer operators is the appropriate thing to do. The BX and EX operators are not themselves part of any graphics object or of the graphics state.</body></comment><class><name>BeginCompatibility</name><environment>Graphics.PDF</environment><super>Graphics.PDF.CompatibilityOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.BeginCompatibility</class-id><body>Begin a compatibility section. Unrecognized operators (along with their operands) shall be ignored without error until the balancing EX operator is encountered.</body></comment><class><name>BorderStyle</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.BorderStyle</class-id><body>PDF border style dictionary as defined in PDF 32000_2008.pdf, section 12.5.4, pp. 386.An annotation may optionally be surrounded by a border when displayed or printed.If present, the border shall be drawn completely inside the annotation rectangle.In PDF 1.1, the characteristics of the border shall be specified by the Border entry in the annotation dictionary.Beginning with PDF 1.2, the border characteristics for some types of annotations may instead be specified in a border style dictionary designated by the annotation’s BS entry.Such dictionaries may also be used to specify the width and dash pattern for the lines drawn by line, square, circle, and ink annotations.If neither the Border nor the BS entry is present, the border shall be drawn as a solid line with a width of 1 point.</body></comment><class><name>SetDash</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetDash</class-id><body>Set the line dash pattern in the graphics state</body></comment><class><name>JBIG2Decode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Filter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.JBIG2Decode</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 31.Decompresses data encoded using the JBIG2 standard, reproducing the original monochrome (1 bit per pixel) image data (or an approximation of that data).</body></comment><class><name>Pattern</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Name</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.Pattern</class-id><body>PDF Pattern Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.6.2, pp. 156.A Pattern colour space (PDF 1.2) specifies that an area is to be painted with a pattern rather than a single colour. The pattern shall be either a tiling pattern (type 1) or a shading pattern (type 2).</body></comment><class><name>Outlines</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.Outlines</class-id><body>PDF Outline dictionary as defined in PDF 32000_2008.pdf, section 12.3.3,  pp. 367.A PDF document may contain a document outline that the conforming reader may display on the screen, allowing the user to navigate interactively from one part of the document to another.The outline consists of a tree-structured hierarchy of outline items (sometimes called bookmarks), which serve as a visual table of contents to display the document’s structure to the user.The user may interactively open and close individual items by clicking them with the mouse.When an item is open, its immediate children in the hierarchy shall become visible on the screen; each child may in turn be open or closed, selectively revealing or hiding further parts of the hierarchy. When an item is closed, all of its descendants in the hierarchy shall be hidden.Clicking the text of any visible item activates the item, causing the conforming reader to jump to a destination or trigger an action associated with the item.The root of a document’s outline hierarchy is an outline dictionary specified by the Outlines entry in the document catalogue.Each individual outline item within the hierarchy shall be defined by an outline item dictionary.The items at each level of the hierarchy form a linked list, chained together through their Prev and Next entries and accessed through the First and Last entries in the parent item (or in the outline dictionary in the case of top-level items).When displayed on the screen, the items at a given level shall appear in the order in which they occur in the linked list.</body></comment><class><name>AppendCurve</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathConstructionOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.AppendCurve</class-id><body>Append a cubic Bézier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using (x1, y1) and (x2, y2) as the Bézier control points. The new current point shall be (x3, y3)</body></comment><class><name>BeginMarkedContent</name><environment>Graphics.PDF</environment><super>Graphics.PDF.MarkedContentOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.BeginMarkedContent</class-id><body>Begin a marked-content sequence terminated by a balancing EMC operator. tag shall be a name object indicating the role or significance of the sequence</body></comment><class><name>CrossReferences</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FileEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>crossReferenceSection trailer previous stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.CrossReferences</class-id><body>Combines one cross-reference section and one trailer.Previous sections and trailers are collected and accessible with #previous.PDF Cross-Reference Table as defined in PDF 32000_2008.pdf pp. 40.The cross-reference table contains information that permits random access to indirect objects within the file so that the entire file need not be read to locate any particular object. The table shall contain a one-line entry for each indirect object, specifying the byte offset of that object within the body of the file. (Beginning with PDF 1.5, some or all of the cross-reference information may alternatively be contained in cross-reference streams).NOTE 1		The cross-reference table is the only part of a PDF file with a fixed format, which permits entries in the table to be accessed randomly.The table comprises one or more cross-reference sections. Initially, the entire table consists of a single section (or two sections if the file is linearized). One additional section shall be added each time the file is incrementally updated.Shares the access protocol with CrossReferenceStream:	#at:	#at:ifAbsent:	#atNumber:	#atNumber:ifAbsent:	#freeReferences	#trailer</body></comment><class><name>PNGPredictor</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Predictor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>offsetLeft </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.PNGPredictor</class-id><body>PNG Predictors as defined in http://www.w3.org/TR/PNG/#9Filters.A nice description can be found at http://www.libpng.org/pub/png/book/LCH-png-chapter.pdf</body></comment><class><name>NoPredictor</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PNGPredictor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.NoPredictor</class-id><body>Each byte is unchanged.</body></comment><class><name>HexStringEncoder</name><environment>Graphics.PDF</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.HexStringEncoder</class-id><body>A de- and en-coder for PDF Hexadecimal Strings (see PDF 32000_2008.pdf p.16)Use String&gt;&gt;fromPdfHexString to convert from PDF to SmalltalkUse String&gt;&gt;asPdfHexString to convert from Smalltalk to PDF</body></comment><class><name>AppendCurveWithoutC2</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathConstructionOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.AppendCurveWithoutC2</class-id><body>Append a cubic Bézier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using (x1, y1) and (x3, y3) as the Bézier control points. The new current point shall be (x3, y3)</body></comment><class><name>ObjectParser</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>peekPositions accessLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Parsing</package></attributes></class><comment><class-id>Graphics.PDF.ObjectParser</class-id><body>This parser reads PDF objects from a file or from an object stream.</body></comment><class><name>FileParser</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ObjectParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Parsing</package></attributes></class><comment><class-id>Graphics.PDF.FileParser</class-id><body>This parser reads PDF objects from a file.Indirect objects are expected to have number, generation and #obj and #endobj tags.Only the file parser knows about streams</body></comment><class><name>Objecttype</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.Objecttype</class-id><body>Subclasses stand for abstract PDF types which have specializations somewhere in the class hierarchy</body></comment><class><name>Destination</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Objecttype</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.Destination</class-id><body>PDF Explicit Destination as defined in PDF 32000_2008.pdf, section 12.3.2, pp. 365.A destination defines a particular view of a document, consisting of the following items:• The page of the document that shall be displayed• The location of the document window on that page• The magnification (zoom) factorDestinations may be associated with outline items, annotations, or actions.In each case, the destination specifies the view of the document that shall be presented when the outline item or annotation is opened or the action is performed. In addition, the optional OpenAction entry in a document’s catalogue may specify a destination that shall be displayed when the document is opened.A destination may be specified either explicitly by an array of parameters defining its properties or indirectly by name.</body></comment><class><name>DeviceNColourSpaceAttributes</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.DeviceNColourSpaceAttributes</class-id><body>PDF DeviceN Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.6.5, pp. 161.The optional attributes parameter shall be a dictionary containing additional information about the components of colour space that conforming readers may use.Conforming readers need not use the alternateSpace and tintTransform parameters, and may instead use custom blending algorithms, along with other information provided in the attributes dictionary if present. (If the value of the Subtype entry in the attributes dictionary is NChannel, such information shall be present.)However, alternateSpace and tintTransform shall always be provided for conforming readers that want to use them or do not support PDF 1.6.</body></comment><class><name>Version</name><environment>Graphics.PDF</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>major minor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.Version</class-id><body>superclass of all concrete PDF Version classes.Each released version has one subclass with specific features.</body></comment><class><name>SquigglyAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextMarkup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.SquigglyAnnotation</class-id><body>PDF Text Markup Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.10, pp. 403.Text markup annotations shall appear as highlights, underlines, strikeouts, or jagged (“squiggly”) underlines in the text of a document.When opened, they shall display a pop-up window containing the text of the associated note.</body></comment><class><name>IsolatedObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.IsolatedObject</class-id><body>operations between #q and #Q</body></comment><class><name>NameTreeType</name><environment>Graphics.PDF</environment><super>Graphics.PDF.DictionaryType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.NameTreeType</class-id><body>This type matches a NameTree with values of a specific type.The elements of the NameTree are checked and specialized with the type</body></comment><class><name>StrokeClosed</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathPaintingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.StrokeClosed</class-id><body>Close and stroke the path. This operator shall have the same effect as the sequence h S</body></comment><class><name>XRefStream</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>previous subsections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.XRefStream</class-id><body>PDF Cross-reference Stream as defined in PDF 32000_2008.pdf pp. 49.Shares the access protocol with CrossReferences:	#at:	#at:ifAbsent:	#atNumber:	#atNumber:ifAbsent:	#freeReferences	#trailer</body></comment><class><name>String</name><environment>Graphics.PDF</environment><super>Graphics.PDF.NativeValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encrypted </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.String</class-id><body>PDF String object as defined in PDF 32000_2008.pdf pp. 15.The value of a String is a ByteArray where each byte represents one character (2 byte per character for UTF16Textstring) in a specific encoding (if any).The encodings are specific to the subclasses:- ASCII 				for AsciiString- PDFDocEncoding 	for Textstring- UTF-16BE			for UTF16Textstring- specified			for EncodedStringThe class String is abstract and is used as interface. All conversions are done automatically.The bytes are written as they are (with escaping non-ASCII characters) to the PDF source and read from it.The methods #pdfSource and (class)#fromPdf: are used for writing and reading.When Strings are created programatically, the characters have to be encoded in a specific way and the encoding has to be remembered for later reencoding.Creation of a String should be done with: (class)#on:encoded: with a Smalltalk ByteString and an encoding. An error is signalled when the string cannot be encoded.For direct creation, use (class)#value: with a ByteArrayTo get a Smalltalk String from a PDF.String, use #asString.In a Contents stream, strings exist only in text object with a specific font. The interpretation of Strings uses the encoding of the selected font.Strings can be represented as Bytestring (in ()) or as hexadecimal string (in &lt;&gt;).</body></comment><class><name>EncodedString</name><environment>Graphics.PDF</environment><super>Graphics.PDF.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.EncodedString</class-id><body>A byte string with a specific encoder</body></comment><class><name>LineCap</name><environment>Graphics.PDF</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.LineCap</class-id><body>PDF Line Cap Style as defined in PDF 32000_2008.pdf, section 8.4.3.3, pp. 125.The line cap style shall specify the shape that shall be used at the ends of open subpaths (and dashes, if any) when they are stroked.0	Butt cap. 				The stroke shall be squared off at the endpoint of the path. There shall be no projection beyond the end of the path.1	Round cap. 				A semicircular arc with a diameter equal to the line width shall be drawn around the endpoint and shall be filled in.2	Projecting square cap. 	The stroke shall continue beyond the endpoint of the path for a distance equal to half the line width and shall besquared off.</body></comment><class><name>StringEncoder</name><environment>Graphics.PDF</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>quoteParenthesis </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.StringEncoder</class-id><body>A de- and en-coder for PDF Literal Strings (see PDF 32000_2008.pdf p.15)Use String&gt;&gt;fromPdfString to convert from PDF to SmalltalkUse String&gt;&gt;asPdfString to convert from Smalltalk to PDF</body></comment><class><name>SetNonStrokingColorSpecial</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetNonStrokingColorSpecial</class-id><body>Same as SCN but used for nonstroking operations.</body></comment><class><name>Leading</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.Leading</class-id><body>Set the text leading, Tl, to leading, which shall be a number expressed in unscaled text space units. Text leading shall be used only by the T*, ', and  operators. Initial value: 0</body></comment><class><name>Null</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.Null</class-id><body>PDF Null object as defined in PDF 32000_2008.pdf p. 21.There is only one sole instance.</body></comment><class><name>OptionalContentUsageCreatorInfo</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.OptionalContentUsageCreatorInfo</class-id><body>PDF Optional Content as defined in PDF 32000_2008.pdf section 8.11.4.4, pp. 232.A dictionary used by the creating application to store application-specific data associated with this optional content group.It shall contain two required entries:	Creator 		A text string specifying the application that created the group.	Subtype 	A name defining the type of content controlled by the group. Suggested values include but shall not be limited to Artwork, for graphic-design or publishing applications, and Technical, for technical designs such as building plans or schematics.Additional entries may be included to present information relevant to the creating application or related applications</body></comment><class><name>ShowText</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextShowingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.ShowText</class-id><body>Show a text string</body></comment><class><name>SetMiterLimit</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetMiterLimit</class-id><body>Set the miter limit in the graphics state</body></comment><class><name>GraphicsInterpreter</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container objects graphicsState graphicsStateStack currentPath operations beginTextIndex currentObjectStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.GraphicsInterpreter</class-id><body>The graphics on one page</body></comment><class><name>ScreenAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Annot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.ScreenAnnotation</class-id><body>PDF Screen Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.18, pp. 407.A screen annotation specifies a region of a page upon which media clips may be played.It also serves as an object from which actions can be triggered.</body></comment><class><name>Pathsegment</name><environment>Graphics.PDF</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.Pathsegment</class-id><body>PDF Path Construction and Painting as defined in PDF 32000_2008.pdf, section 8.5, pp. 131.Paths define shapes, trajectories, and regions of all sorts. They shall be used to draw lines, define the shapes of filled areas, and specify boundaries for clipping other graphics. The graphics state shall include a current clipping path that shall define the clipping boundary for the current page. At the beginning of each page, the clipping path shall be initialized to include the entire page.A path shall be composed of straight and curved line segments, which may connect to one another or may be disconnected. A pair of segments shall be said to connect only if they are defined consecutively, with the second segment starting where the first one ends. Thus, the order in which the segments of a path are defined shall be significant. Nonconsecutive segments that meet or intersect fortuitously shall not be considered to connect.NOTEA path is made up of one or more disconnected subpaths, each comprising a sequence of connected segments. The topology of the path is unrestricted: it may be concave or convex, may contain multiple subpaths representing disjoint areas, and may intersect itself in arbitrary ways.The h operator explicitly shall connect the end of a subpath back to its starting point; such a subpath is said to be closed. A subpath that has not been explicitly closed is said to be open.A path object is defined by a sequence of operators to construct the path, followed by one or more operators to paint the path or to use it as a clipping boundary. PDF path operators fall into three categories:	•	Path construction operators define the geometry of a path. 		A path is constructed by sequentially applying one or more of these operators.	•	Path-painting operators end a path object, usually causing the object to be painted on the current page in any of a variety of ways.	•	Clipping path operators, invoked immediately before a path-painting operator, cause the path object also to be used for clipping of subsequent graphics objects.</body></comment><class><name>Textstring</name><environment>Graphics.PDF</environment><super>Graphics.PDF.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.Textstring</class-id><body>PDF Text String object as defined in PDF 32000_2008.pdf pp. 86.The text string type shall be used for character strings that contain information intended to be human-readable, such as text annotations, bookmark names, article names, document information, and so forth.	NOTE 1		Text string type is a subtype of string type and represents data encoded using specific conventions.The text string type shall be used for character strings that shall be encoded in either PDFDocEncoding or the UTF-16BE Unicode character encoding scheme.The value should be shown with PDFDocEncoding</body></comment><class><name>DeviceCMYK</name><environment>Graphics.PDF</environment><super>Graphics.PDF.DeviceColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.DeviceCMYK</class-id><body>PDF DeviceCMYK Colour Space as defined in PDF 32000_2008.pdf, section 8.6.4.4, pp. 143.The DeviceCMYK colour space allows colours to be specified according to the subtractive CMYK (cyan-magenta-yellow-black) model typical of printers and other paper-based output devices. The four components in a DeviceCMYK colour value shall represent the concentrations of these process colorants. Each component shall be a number in the range 0.0 to 1.0, where 0.0 shall denote the complete absence of a process colorant and 1.0 shall denote maximum concentration (absorbs as much as possible of the additive primary).NOTEAs much as the reflective colours (CMYK) decrease reflection with increased ink values and radiant colours (RGB) increases the intensity of colours with increased values the values work in an opposite manner.EXAMPLEThe following shows alternative ways to select the DeviceCMYK colour space and a specific colour within that space for stroking operations.	/DeviceCMYK CS 					% Set DeviceCMYK colour space	cyan magenta yellow black SC 		% Set colour	cyan magenta yellow black K 		% Set both in one operationThe CS and SC operators shall select the current stroking colour space and current stroking colour separately; K shall set them in combination. The cs, sc, and k operators shall perform the same functions for nonstroking operations. Setting either current colour space to DeviceCMYK shall initialize the cyan, magenta, and yellow components of the corresponding current colour to 0.0 and the black component to 1.0.</body></comment><class><name>OptionalContentProperties</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.OptionalContentProperties</class-id><body>PDF Optional Content as defined in PDF 32000_2008.pdf section 8.11.4.2, pp. 228.The optional OCProperties entry in the document catalog shall contain, when present, the optional content properties dictionary, which contains a list of all the optional content groups in the document, as well as information about the default and alternate configurations for optional content.This dictionary shall be present if the file contains any optional content; if it is missing, a conforming reader shall ignore any optional content structures in the document</body></comment><class><name>InkAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.InkAnnotation</class-id><body>PDF Ink Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.13, pp. 405.An ink annotation represents a freehand “scribble” composed of one or more disjoint paths.When opened, it shall display a pop-up window containing the text of the associated note.</body></comment><class><name>SetLineWidth</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetLineWidth</class-id><body>Set the line width in the graphics state</body></comment><class><name>GraphicsState</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.GraphicsState</class-id><body>PDF Graphics State as defined in PDF 32000_2008.pdf, section 8.4, pp. 121.A conforming reader shall maintain an internal data structure called the graphics state that holds current graphics control parameters. These parameters define the global framework within which the graphics operators execute.EXAMPLE 1The f (fill) operator implicitly uses the current colour parameter, and the S (stroke) operator additionally uses the current line width parameter from the graphics state.A conforming reader shall initialize the graphic state at the beginning of each page with the values specified. Table 52 lists those graphics state parameters that are device-independent and are appropriate to specify in page descriptions. The parameters listed in Table 53 control details of the rendering (scan conversion) process and are device-dependent; a page description that is intended to be device-independent should not be written to modify these parameters.</body></comment><class><name>FunctionStream</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.FunctionStream</class-id><body>PDF Function Dictionary as defined in PDF 32000_2008.pdf pp. 92.PDF is not a programming language, and a PDF file is not a program.However, PDF provides several types of function objects (PDF 1.2) that represent parameterized classes of functions, including mathematical formulas and sampled representations with arbitrary resolution.</body></comment><class><name>PostScriptCalculatorFunction</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FunctionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.PostScriptCalculatorFunction</class-id><body>PDF Function as defined in PDF 32000_2008.pdf pp. 97.A type 4 function, also called a PostScript calculator function, shall be represented as a stream containing code written in a small subset of the PostScript language.Errors in Type 4 FunctionsThe part of a conforming reader that reads a type 4 function (analogous to the PostScript scanner) shall detect and report syntax errors.Any errors detected by the conforming reader shall be errors in the PDF file and shall be handled like other errors in the file.The part of a conforming reader that executes a type 4 function (analogous to the PostScript interpreter) shall detect and report errors.This specification does not define a representation for the errors; those details shall be provided by the conforming reader that processes the PDF file.The following types of errors can occur (among others):	• Stack overflow	• Stack underflow	• A type error (for example, applying not to a real number)	• A range error (for example, applying sqrt to a negative number)	• An undefined result (for example, dividing by 0)</body></comment><class><name>Action</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.Action</class-id><body>PDF Action dictionary as defined in PDF 32000_2008.pdf, section 12.6, pp. 414.An action dictionary defines the characteristics and behaviour of an action.</body></comment><class><name>Sound</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.Sound</class-id><body>PDF Sounds as defined in PDF 32000_2008.pdf, section 13.3, pp. 506.A sound object shall be a stream containing sample values that define a sound to be played through the computer’s speakers.The Sound entry in a sound annotation or sound action dictionary shall identify a sound object representing the sound to be played when the annotation is activated.Since a sound object is a stream, it may contain any of the standard entries common to all streams.In particular, if it contains an F (file specification) entry, the sound shall be defined in an external file.This sound file shall be self-describing, containing all information needed to render the sound; no additional information need be present in the PDF file.	NOTE	The AIFF, AIFF-C (Mac OS), RIFF (.wav), and snd (.au) file formats are all self-describing.If no F entry is present, the sound object itself shall contain the sample data and all other information needed to define the sound.</body></comment><class><name>ZipFilterParameter</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.ZipFilterParameter</class-id><body>PDF Image Dictionaries as defined in PDF 32000_2008.pdf, section 7.4.4.3, pp. 27.The LZWDecode and FlateDecode filters shall accept optional parameters to control the decoding process.NOTE	Most of these parameters are related to techniques that reduce the size of compressed sampled images (rectangular arrays of colour values).For example, image data typically changes very little from sample to sample.Therefore, subtracting the values of adjacent samples (a process called differencing), and encoding the differences rather than the raw sample values, can reduce the size of the output data.Furthermore, when the image data contains several colour components (red-green-blue or cyan-magenta-yellow-black) per sample, taking the difference between the values of corresponding components in adjacent samples, rather than between different colour components in the same sample, often reduces the output data size</body></comment><class><name>LZWFilterParameter</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ZipFilterParameter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.LZWFilterParameter</class-id><body>PDF Image Dictionaries as defined in PDF 32000_2008.pdf, section 7.4.4.3, pp. 27.The LZWDecode and FlateDecode filters shall accept optional parameters to control the decoding process.NOTE	Most of these parameters are related to techniques that reduce the size of compressed sampled images (rectangular arrays of colour values).For example, image data typically changes very little from sample to sample.Therefore, subtracting the values of adjacent samples (a process called differencing), and encoding the differences rather than the raw sample values, can reduce the size of the output data.Furthermore, when the image data contains several colour components (red-green-blue or cyan-magenta-yellow-black) per sample, taking the difference between the values of corresponding components in adjacent samples, rather than between different colour components in the same sample, often reduces the output data size</body></comment><class><name>LZWDecode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ZipFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>earlyChange </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.LZWDecode</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 25.Decompresses data encoded using the LZW (Lempel-Ziv-Welch) adaptive compression method, reproducing the original text or binary data.This filter is depreciated and not (initially implemented.</body></comment><class><name>PDF</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>objecttypes </class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.PDF</class-id><body>Global class for utilities used from anywhere.There are no instances; all functionality is implemented as class methods.</body></comment><class><name>Group</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FormXObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF XObjects</package></attributes></class><comment><class-id>Graphics.PDF.Group</class-id><body>PDF Group XObjects as defined in PDF 32000_2008.pdf, section 8.10.3, pp. 220.A group XObject (PDF 1.4) is a special type of form XObject that can be used to group graphical elements together as a unit for various purposes. It shall be distinguished by the presence of the optional Group entry in the form dictionary. The value of this entry shall be a subsidiary group attributes dictionary describing the properties of the group.Every group XObject shall have a group subtype (specified by the S entry in the group attributes dictionary) that determines the format and meaning of the dictionary’s remaining entries. This specification only defines one subtype, a transparency group XObject (subtype Transparency) representing a transparency group for use in the transparent imaging model.</body></comment><class><name>Path</name><environment>Graphics.PDF</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subpaths clippingingOperator paintingOperator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.Path</class-id><body>PDF Path Construction and Painting as defined in PDF 32000_2008.pdf, section 8.5, pp. 131.Paths define shapes, trajectories, and regions of all sorts. They shall be used to draw lines, define the shapes of filled areas, and specify boundaries for clipping other graphics. The graphics state shall include a current clipping path that shall define the clipping boundary for the current page. At the beginning of each page, the clipping path shall be initialized to include the entire page.A path shall be composed of straight and curved line segments, which may connect to one another or may be disconnected. A pair of segments shall be said to connect only if they are defined consecutively, with the second segment starting where the first one ends. Thus, the order in which the segments of a path are defined shall be significant. Nonconsecutive segments that meet or intersect fortuitously shall not be considered to connect.NOTEA path is made up of one or more disconnected subpaths, each comprising a sequence of connected segments. The topology of the path is unrestricted: it may be concave or convex, may contain multiple subpaths representing disjoint areas, and may intersect itself in arbitrary ways.The h operator explicitly shall connect the end of a subpath back to its starting point; such a subpath is said to be closed. A subpath that has not been explicitly closed is said to be open.A path object is defined by a sequence of operators to construct the path, followed by one or more operators to paint the path or to use it as a clipping boundary. PDF path operators fall into three categories:	•	Path construction operators define the geometry of a path. 		A path is constructed by sequentially applying one or more of these operators.	•	Path-painting operators end a path object, usually causing the object to be painted on the current page in any of a variety of ways.	•	Clipping path operators, invoked immediately before a path-painting operator, cause the path object also to be used for clipping of subsequent graphics objects.</body></comment><class><name>ClippingPathOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.ClippingPathOperation</class-id><body>PDF Graphics State Operators as defined in PDF 32000_2008.pdf, section 8.5.4, pp. 137.The graphics state shall contain a current clipping path that limits the regions of the page affected by painting operators. The closed subpaths of this path shall define the area that can be painted. Marks falling inside this area shall be applied to the page; those falling outside it shall not be.In the context of the transparent imaging model (PDF 1.4), the current clipping path constrains an object’s shape). The effective shape is the intersection of the object’s intrinsic shape with the clipping path; the source shape value shall be 0.0 outside this intersection. Similarly, the shape of a transparency group (defined as the union of the shapes of its constituent objects) shall be influenced both by the clipping path in effect when each of the objects is painted and by the one in effect at the time the group’s results are painted onto its backdrop.The initial clipping path shall include the entire page. A clipping path operator (W or W*) may appear after the last path construction operator and before the path-painting operator that terminates a path object. Although the clipping path operator appears before the painting operator, it shall not alter the clipping path at the point where it appears. Rather, it shall modify the effect of the succeeding painting operator. After the path has been painted, the clipping path in the graphics state shall be set to the intersection of the current clipping path and the newly constructed path.NOTE 1In addition to path objects, text objects may also be used for clipping.The n operator is a no-op path-painting operator; it shall cause no marks to be placed on the page, but can be used with a clipping path operator to establish a new clipping path. That is, after a path has been constructed, the sequence W n shall intersect that path with the current clipping path and shall establish a new clipping path.NOTE 2There is no way to enlarge the current clipping path or to set a new clipping path without reference to the current one. However, since the clipping path is part of the graphics state, its effect can be localized to specific graphics objects by enclosing the modification of the clipping path and the painting of those objects between a pair of q and Q operators. Execution of the Q operator causes the clipping path to revert to the value that was saved by the q operator before the clipping path was modified.</body></comment><class><name>Clip</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ClippingPathOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.Clip</class-id><body>Modify the current clipping path by intersecting it with the current path, using the nonzero winding number rule to determine which regions lie inside the clipping path.</body></comment><class><name>StampAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.StampAnnotation</class-id><body>PDF Rubber Stamp Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.12, pp. 404.A rubber stamp annotation displays text or graphics intended to look as if they were stamped on the page with a rubber stamp.When opened, it shall display a pop-up window containing the text of the associated note.</body></comment><class><name>WidgetAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Annot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.WidgetAnnotation</class-id><body>PDF Widget Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.19, pp. 408.Interactive forms use widget annotations to represent the appearance of fields and to manage user interactions.As a convenience, when a field has only a single associated widget annotation, the contents of the field dictionary and the annotation dictionary may be merged into a single dictionary containing entries that pertain to both a field and an annotation.	NOTE	This presents no ambiguity, since the contents of the two kinds of dictionaries do not conflict.</body></comment><class><name>Pages</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PageTree</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.Pages</class-id><body>PDF Pages as defined in PDF 32000_2008.pdf pp. 75.The pages of a document are accessed through a structure known as the page tree, which defines the ordering of pages in the document. Using the tree structure, conforming readers using only limited memory, can quickly open a document containing thousands of pages. The tree contains nodes of two types—intermediate nodes, called page tree nodes, and leaf nodes, called page objects—whose form is described in the subsequent sub-clauses. Conforming products shall be prepared to handle any form of tree structure built of such nodes.NOTEThe simplest structure can consist of a single page tree node that references all of the document’s page objects directly. However, to optimize application performance, a conforming writer can construct trees of a particular form, known as balanced trees. Further information on this form of tree can be found in Data Structures and Algorithms, by Aho, Hopcroft, and Ullman (see the Bibliography).</body></comment><class><name>SetNonStrokingColor</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetNonStrokingColor</class-id><body>Same as SC but used for nonstroking operations.</body></comment><class><name>SetNonStrokingColorSpace</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetNonStrokingColorSpace</class-id><body>Same as CS but used for nonstroking operations.</body></comment><class><name>Boolean</name><environment>Graphics.PDF</environment><super>Graphics.PDF.NativeValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.Boolean</class-id><body>PDF Boolean object as defined in PDF 32000_2008.pdf pp. 14.</body></comment><class><name>CircleAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.SquareCircle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.CircleAnnotation</class-id><body>PDF Square and Circle Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.8, pp. 401.Square and circle annotations shall display, respectively, a rectangle or an ellipse on the page.When opened, they shall display a pop-up window containing the text of the associated note.The rectangle or ellipse shall be inscribed within the annotation rectangle defined by the annotation dictionary’s Rect entry.Despite the names square and circle, the width and height of the annotation rectangle need not be equal.</body></comment><class><name>RadialShading</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ShadingDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Shading</package></attributes></class><comment><class-id>Graphics.PDF.RadialShading</class-id><body>PDF Shading as defined in PDF 32000_2008.pdf pp. 187.Type 3 (radial) shadings define a colour blend that varies between two circles.Shadings of this type are commonly used to depict three-dimensional spheres and cones.This type of shading shall not be used with an Indexed colour space.</body></comment><class><name>UpPredictor</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PNGPredictor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.UpPredictor</class-id><body>Each byte is replaced with the difference between it and the byte above it (in the previous row, as it was before filtering).</body></comment><class><name>ObjectStreamParser</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ObjectParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Parsing</package></attributes></class><comment><class-id>Graphics.PDF.ObjectStreamParser</class-id><body>This parser reads PDF objects from an object stream.Indirect objects are expected NOT to have number, generation and #obj and #endobj tags.</body></comment><class><name>TextRenderingMode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.TextRenderingMode</class-id><body>Set the text rendering mode, Tmode, to render. Initial value: 0</body></comment><class><name>ClassType</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.ClassType</class-id><body>This type matches concrete classes of attribute values.#subsumes: aPDFObject answers:true, if the class of aPDFObject is the identical class of the receivertrue, if the class of aPDFObject is a subclass of the class of the receiver</body></comment><class><name>AppearanceCharacteristics</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.AppearanceCharacteristics</class-id><body>PDF Widget Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.19, pp. 409.The MK entry may be used to provide an appearance characteristics dictionary containing additional information for constructing the annotation’s appearance stream.</body></comment><class><name>Resources</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.Resources</class-id><body>PDF Catalog as defined in PDF 32000_2008.pdf pp. 82.The operands supplied to operators in a content stream shall only be direct objects; indirect objects and object references shall not be permitted.In some cases, an operator shall refer to a PDF object that is defined outside the content stream, such as a font dictionary or a stream containing image data.This shall be accomplished by defining such objects as named resources and referring to them by name from within the content stream.Named resources shall be meaningful only in the context of a content stream.The scope of a resource name shall be local to a particular content stream and shall be unrelated to externally known identifiers for objects such as fonts.References from one object outside of content streams to another outside of content streams shall be made by means of indirect object references rather than named resources.A content stream’s named resources shall be defined by a resource dictionary, which shall enumerate the named resources needed by the operators in the content stream and the names by which they can be referred to.</body></comment><class><name>LabColourSpaceDictionary</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.LabColourSpaceDictionary</class-id><body>PDF Lab Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.5.4, pp. 148.A Lab colour space is a CIE-based ABC colour space with two transformation stages. In this type of space, A, B, and C represent the L*, a*, and b* components of a CIE 1976 L*a*b* space. The range of the first (L*) component shall be 0 to 100; the ranges of the second and third (a* and b*) components shall be defined by the Range entry in the colour space dictionary.</body></comment><class><name>NextLineRelativeSetLeading</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextPositioningOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.NextLineRelativeSetLeading</class-id><body>Move to the start of the next line, offset from the start of the current line by (tx, ty). As a side effect, this operator shall set the leading parameter in the text state. This operator shall have the same effect as this code:	-ty TL	tx ty Td</body></comment><class><name>OutputIntent</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.OutputIntent</class-id><body>PDF OutputIntent as defined in PDF 32000_2008.pdf pp. 633.Output intents (PDF 1.4) provide a means for matching the colour characteristics of a PDF document with those of a target output device or production environment in which the document will be printed. The optional OutputIntents entry in the document catalogue holds an array of output intent dictionaries, each describing the colour reproduction characteristics of a possible output device or production condition. The contents of these dictionaries may vary for different devices and conditions. The dictionary’s Sentry specifies an output intent subtype that determines the format and meaning of the remaining entries.NOTE 1This use of multiple output intents allows the production process to be customized to the expected workflow and the specific tools available. For example, one production facility might process files conforming to a recognized standard such as PDF/X-1, while another uses the PDF/A standard to produce RGB output for document distribution on the Web. Each of these workflows would require different sets of output intent information. Multiple output intents also allow the same PDF file to be distributed unmodified to multiple production facilities. The choice of which output intent to use in a given production environment is a matter for agreement between the purchaser and provider of production services. PDF intentionally does not include a selector for choosing a particular output intent from within the PDF file.At the time of publication, three output intent subtypes have been defined: 	GTS_PDFX corresponding to the PDF/X format standard specified in ISO 15930, 	GTS_PDFA1 corresponding to the PDF/A standard as defined by ISO 19005, and 	ISO_PDFE1 corresponding to the PDF/E standard as defined by ISO 24517. Other subtypes may be added in the future; the names of any such additional subtypes shall conform to the naming guidelines.</body></comment><class><name>FileAttachmentAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.FileAttachmentAnnotation</class-id><body>PDF File Attachment Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.15, pp. 406.A file attachment annotation contains a reference to a file, which typically shall be embedded in the PDF file.NOTE	A table of data might use a file attachment annotation to link to a spreadsheet file based on that data; activating the annotation extracts the embedded file and gives the user an opportunity to view it or store it in the file system.The Contents entry of the annotation dictionary may specify descriptive text relating to the attached file.Conforming readers shall use this entry rather than the optional Desc entry in the file specification dictionary identified by the annotation’s FS entry.</body></comment><class><name>FillEvenOddAndStrokeClosed</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathPaintingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.FillEvenOddAndStrokeClosed</class-id><body>Close, fill, and then stroke the path, using the even-odd rule to determine the region to fill. This operator shall have the same effect as the sequence h B*</body></comment><class><name>ImageXObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.XObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Images</package></attributes></class><comment><class-id>Graphics.PDF.ImageXObject</class-id><body>PDF Image Dictionaries as defined in PDF 32000_2008.pdf, section 8.9.5, pp. 206.An image dictionary—that is, the dictionary portion of a stream representing an image XObject—may contain the entries in addition to the usual entries common to all streams. There are many relationships among these entries, and the current colour space may limit the choices for some of them. Attempting to use an image dictionary whose entries are inconsistent with each other or with the current colour space shall cause an error.The entries described here are appropriate for a base image—one that is invoked directly with the Do operator. Some of the entries should not be used for images used in other ways, such as for alternate images, image masks, or thumbnail images. Except as noted, such irrelevant entries are simply ignored by a conforming reader.</body></comment><class><name>SoftMaskImage</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ImageXObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Images</package></attributes></class><comment><class-id>Graphics.PDF.SoftMaskImage</class-id><body>PDF Image Dictionaries as defined in PDF 32000_2008.pdf, section 11.6.5.3, pp. 347.The second way to define a soft mask is by associating a soft-mask image with an image XObject. This is a subsidiary image XObject specified in the SMask entry of the parent XObject’s image dictionary (see “Image Dictionaries”). Entries in the subsidiary image dictionary for such a soft-mask image shall have the same format and meaning as in that of an ordinary image XObject (as described in Table 89 in “Image Dictionaries”), subject to the restrictions listed in Table 145. This type of image dictionary may contain an additional entry, Matte</body></comment><class><name>Dest</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.Dest</class-id><body>PDF Explicit Destination as defined in PDF 32000_2008.pdf, section 12.3.2.3, pp. 367.A dictionary with a D entry whose value is an ExplicitDestination.This form allows additional attributes to be associated with the destination, as well as enabling a go-to action that shall be used as the target of a named destination</body></comment><class><name>SetFlatness</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetFlatness</class-id><body>Set the flatness tolerance in the graphics state. flatness is a number in the range 0 to 100; a value of 0 shall specify the output device’s default flatness tolerance</body></comment><class><name>CrossReferenceSubsection</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FileEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstNumber entries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.CrossReferenceSubsection</class-id><body>A Cross-Reference Subsection in a section of the cross-reference table as defined in PDF 32000_2008.pdf pp. 40.Each cross-reference subsection shall contain entries for a contiguous range of object numbers. The subsection shall begin with a line containing two numbers separated by a SPACE (20h), denoting the object number of the first object in this subsection and the number of entries in the subsection.</body></comment><class><name>FontDescriptor</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.FontDescriptor</class-id><body>PDF FontDescriptor as defined in PDF 32000_2008.pdf pp. 281.A font descriptor specifies metrics and other attributes of a simple font or a CIDFont as a whole, as distinct from the metrics of individual glyphs.These font metrics provide information that enables a conforming reader to synthesize a substitute font or select a similar font when the font program is unavailable.The font descriptor may also be used to embed the font program in the PDF file.Font descriptors shall not be used with Type 0 fonts. Beginning with PDF 1.5, font descriptors may be used with Type 3 fonts.A font descriptor is a dictionary whose entries specify various font attributes. All integer values shall be units in glyph space.</body></comment><class><name>SetGraphicsState</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetGraphicsState</class-id><body>Set the specified parameters in the graphics state. dictName shall be the name of a graphics state parameter dictionary in the ExtGState subdictionary of the current resource dictionary</body></comment><class><name>DeviceNProcessDictionary</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.DeviceNProcessDictionary</class-id><body>PDF DeviceN Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.6.5, pp. 161.A dictionary that describes the process colour space whose components are included in the DeviceN colour space</body></comment><class><name>JPXDecode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Filter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.JPXDecode</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 35.Decompresses data encoded using the wavelet-based JPEG2000 standard, reproducing the original image data.</body></comment><class><name>SampledFunction</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FunctionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.SampledFunction</class-id><body>PDF Function as defined in PDF 32000_2008.pdf pp. 93.Type 0 functions use a sequence of sample values (contained in a stream) to provide an approximation for functions whose domains and ranges are bounded.The samples are organized as an m-dimensional table in which each entry has n components.</body></comment><class><name>SetJoin</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetJoin</class-id><body>Set the line join style in the graphics state</body></comment><class><name>LatticeFormGouraudShadedMesh</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ShadingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Shading</package></attributes></class><comment><class-id>Graphics.PDF.LatticeFormGouraudShadedMesh</class-id><body>PDF Shading as defined in PDF 32000_2008.pdf pp. 192.Type 5 shadings (lattice-form Gouraud-shaded triangle meshes) are similar to type 4, but instead of using free-form geometry, their vertices are arranged in a pseudorectangular lattice, which is topologically equivalent to a rectangular grid.The vertices are organized into rows, which need not be geometrically linear.</body></comment><class><name>URI</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Action</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.URI</class-id><body>PDF URI Action as defined in PDF 32000_2008.pdf, section 12.6.4.7, pp. 423.A uniform resource identifier (URI) is a string that identifies (resolves to) a resource on the Internet—typically a file that is the destination of a hypertext link, although it may also resolve to a query or other entity.(URIs are described in Internet RFC 2396, Uniform Resource Identifiers (URI): Generic Syntax)A URI action causes a URI to be resolved</body></comment><class><name>ExponentialInterpolationFunction</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FunctionDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.ExponentialInterpolationFunction</class-id><body>PDF Function as defined in PDF 32000_2008.pdf pp. 96.Type 2 functions include a set of parameters that define an exponential interpolation of one input value and n output values:	f(x) = y0, ..., yn-1</body></comment><class><name>Rectangle</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.Rectangle</class-id><body>PDF Rectangle as defined in PDF 32000_2008.pdf, section 7.9.5, pp. 88.Rectangles are used to describe locations on a page and bounding boxes for a variety of objects.A rectangle shall be written as an array of four numbers giving the coordinates of a pair of diagonally opposite corners.NOTEAlthough rectangles are conventionally specified by their lower-left and upper-right corners, it is acceptable to specify any two diagonally opposite corners.Applications that process PDF should be prepared to normalize such rectangles in situations where specific corners are required.Typically, the array takes the form	[llx lly urx ury]specifying the lower-left x, lower-left y, upper-right x, and upper-right y coordinates of the rectangle, in that order.The other two corners of the rectangle are then assumed to have coordinates (llx, ury) and (urx, lly).</body></comment><class><name>ReadError</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.ReadError</class-id><body>Syntax error while reading a PDF.The parameter contains the position in the PDF file where the error occured</body></comment><class><name>LineAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.LineAnnotation</class-id><body>PDF Line Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.7, pp. 397.The purpose of a line annotation is to display a single straight line on the page.When opened, it shall display a pop-up window containing the text of the associated note.</body></comment><class><name>SoftMask</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF XObjects</package></attributes></class><comment><class-id>Graphics.PDF.SoftMask</class-id><body>PDF Image Dictionaries as defined in PDF 32000_2008.pdf, section 11.6.5.2, pp. 346.The most common way of defining a soft mask is with a soft-mask dictionary specified as the current soft mask in the graphics state.The mask values shall be derived from those of a transparency group, using one of the two methods described in "Deriving a Soft Mask from Group Alpha," and "Deriving a Soft Mask from Group Luminosity."The group shall be defined by a transparency group XObject designated by the G entry in the soft-mask dictionary.The S (subtype) entry shall specify which of the two derivation methods to use:	- If the subtype is Alpha, the transparency group XObject G shall be evaluated to compute a group alpha only.The colours of the constituent objects shall be ignored and the colour compositing computations shall not be performed.The transfer function TR shall then be applied to the computed group alpha to produce the mask values.Outside the bounding box of the transparency group, the mask value shall be the result of applying the transfer function to the input value 0.0.	- If the subtype is Luminosity, the transparency group XObject G shall be composited with a fully opaque backdrop whose colour is everywhere defined by the soft-mask dictionary’s BC entry.The computed result colour shall then be converted to a single-component luminosity value, and the transfer function TR shall be applied to this luminosity to produce the mask values. Outside the transparency group’s bounding box, the mask value shall be derived by transforming the BC colour to luminosity and applying the transfer function to the result.The mask’s coordinate system shall be defined by concatenating the transformation matrix specified by the Matrix entry in the transparency group’s form dictionary with the current transformation matrix at the moment the soft mask is established in the graphics state with the gs operator.In a transparency group XObject that defines a soft mask, spot colour components shall never be available, even if they are available in the group or page on which the soft mask is used.If the group XObject’s content stream specifies a Separation or DeviceN colour space that uses spot colour components, the alternate colour space shall be substituted</body></comment><class><name>SetNonStrokingGray</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetNonStrokingGray</class-id><body>Same as G but used for nonstroking operations.</body></comment><class><name>ConcatenateMatrix</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.ConcatenateMatrix</class-id><body>Modify the current transformation matrix (CTM) by concatenating the specified matrix. Although the operands specify a matrix, they shall be written as six separate numbers, not as an array.</body></comment><class><name>ShowTextOnNextLineWithSpacing</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextShowingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.ShowTextOnNextLineWithSpacing</class-id><body>Move to the next line and show a text string, using aw as the word spacing and ac as the character spacing (setting the corresponding parameters in the text state). aw and ac shall be numbers expressed in unscaled text space units. This operator shall have the same effect as this code:	aw Tw	ac Tc	string '</body></comment><class><name>Dash</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PDF Graphics</category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.Dash</class-id><body>PDF Line Dash Pattern as defined in PDF 32000_2008.pdf, section 8.4.3.6, pp. 126.The line dash pattern shall control the pattern of dashes and gaps used to stroke paths. It shall be specified by a dash array and a dash phase. The dash array's elements shall be numbers that specify the lengths of alternating dashes and gaps; the numbers shall be nonnegative and not all zero. The dash phase shall specify the distance into the dash pattern at which to start the dash. The elements of both the dash array and the dash phase shall be expressed in user space units.Before beginning to stroke a path, the dash array shall be cycled through, adding up the lengths of dashes and gaps. When the accumulated length equals the value specified by the dash phase, stroking of the path shall begin, and the dash array shall be used cyclically from that point onward. As can be seen from the table, an empty dash array and zero phase can be used to restore the dash pattern to a solid line.Dashed lines shall wrap around curves and corners just as solid stroked lines do. The ends of each dash shall be treated with the current line cap style, and corners within dashes shall be treated with the current line join style. A stroking operation shall take no measures to coordinate the dash pattern with features of the path; it simply shall dispense dashes and gaps along the path in the pattern defined by the dash array.When a path consisting of several subpaths is stroked, each subpath shall be treated independently—that is, the dash pattern shall be restarted and the dash phase shall be reapplied to it at the beginning of each subpath.</body></comment><class><name>OptionalContentConfiguration</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.OptionalContentConfiguration</class-id><body>PDF Optional Content as defined in PDF 32000_2008.pdf section 8.11.4.3, pp. 229.The D and Configs entries in a OptionalContentProperties are configuration dictionaries, which represent different presentations of a document’s optional content groups for use by conforming readers.The D configuration dictionary shall be used to specify the initial state of the optional content groups when a document is first opened.Configs lists other configurations that may be used under particular circumstances</body></comment><class><name>Matrix</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.Matrix</class-id><body>PDF Transformation Matrices as defined in PDF 32000_2008.pdf, section 8.3.4, pp. 119.To understand the mathematics of coordinate transformations in PDF, it is vital to remember two points:	• Transformations alter coordinate systems, not graphics objects.	All objects painted before a transformation is applied shall be unaffected by the transformation.	Objects painted after the transformation is applied shall be interpreted in the transformed coordinate system.	• Transformation matrices specify the transformation from the new (transformed) coordinate system to the original (untransformed) coordinate system.	All coordinates used after the transformation shall be expressed in the transformed coordinate system.	PDF applies the transformation matrix to find the equivalent coordinates in the untransformed coordinate system.NOTE 1Many computer graphics textbooks consider transformations of graphics objects rather than of coordinate systems.Although either approach is correct and self-consistent, some details of the calculations differ depending on which point of view is taken.PDF represents coordinates in a two-dimensional space.The point (x, y) in such a space can be expressed in vector form as [x y 1].The constant third element of this vector (1) is needed so that the vector can be used with 3-by-3 matrices in the calculations described below.The transformation between two coordinate systems can be represented by a 3-by-3 transformation matrix written as follows:[a b 0][c d 0][e f 1]Because a transformation matrix has only six elements that can be changed, in most cases in PDF it shall be specified as the six-element array [a b c d e f]</body></comment><class><name>EndPath</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathPaintingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.EndPath</class-id><body>End the path object without filling or stroking it. This operator shall be a path-painting no-op, used primarily for the side effect of changing the current clipping path</body></comment><class><name>BeginText</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextObjectOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.BeginText</class-id><body>Begin a text object, initializing the text matrix, Tm, and the text line matrix, Tlm, to the identity matrix. Text objects shall not be nested; a second BT shall not appear before an ET</body></comment><class><name>TextObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.TextObject</class-id><body>operations between BT and ET</body></comment><class><name>OptionalContentUsage</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.OptionalContentUsage</class-id><body>PDF Optional Content as defined in PDF 32000_2008.pdf section 8.11.4.4, pp. 232.Optional content groups are typically constructed to control the visibility of graphic objects that are related in some way.Objects can be related in several ways; for example, a group may contain content in a particular language or content suitable for viewing at a particular magnification.An optional content group’s usage dictionary (the value of the Usage entry in an optional content group dictionary) shall contain information describing the nature of the content controlled by the group</body></comment><class><name>PrinterMarkAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Annot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.PrinterMarkAnnotation</class-id><body>PDF Printer's Mark Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.20, pp. 410.and PDF Printer's Marks as defined in PDF 32000_2008.pdf, section 14.11.3, pp. 630.A printer’s mark annotation represents a graphic symbol, such as a registration target, colour bar, or cut mark, that may be added to a page to assist production personnel in identifying components of a multiple-plate job and maintaining consistent output during production.</body></comment><class><name>ASCIIHexDecode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ASCIIFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.ASCIIHexDecode</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 24.Decodes data encoded in an ASCII hexadecimal representation, reproducing the original binary data.</body></comment><class><name>PaintXObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.XObjectOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.PaintXObject</class-id><body>Paint the specified XObject. The operand name shall appear as a key in the XObject subdictionary of the current resource dictionary. The associated value shall be a stream whose Type entry, if present, is XObject. The effect of Do depends on the value of the XObject’s Subtype entry, which may be Image, Form, or PS</body></comment><class><name>Encoding</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.Encoding</class-id><body>PDF Character Encoding as defined in PDF 32000_2008.pdf, section 5.5.5, pp. 425.A font program’s built-in encoding can be overridden or altered by including an Encoding entry in the PDF font dictionary. The possible encoding modifications depend on the font type, as discussed below. The value of the Encoding entry is either a named encoding (the name of one of the predefined encodings MacRomanEncoding, MacExpertEncoding, or WinAnsiEncoding) or an encoding dictionary.</body></comment><class><name>PathObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clipping painting intersections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.PathObject</class-id><body>list of path construction operators with a path painting operator</body></comment><class><name>CIDFontType2</name><environment>Graphics.PDF</environment><super>Graphics.PDF.CIDFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.CIDFontType2</class-id><body>PDF Glyph Selection in CIDFonts as defined in PDF 32000_2008.pdf, clause 9.7.4.2, pp. 270.Type 0 and Type 2 CIDFonts handle the mapping from CIDs to glyph descriptions in somewhat different ways.For Type 2, the CIDFont program is actually a TrueType font program, which has no native notion of CIDs. In a TrueType font program, glyph descriptions are identified by glyph index values. Glyph indices are internal to the font and are not defined consistently from one font to another. Instead, a TrueType font program contains a “cmap” table that provides mappings directly from character codes to glyph indices for one or more predefined encodings.TrueType font programs are integrated with the CID-keyed font architecture in one of two ways, depending on whether the font program is embedded in the PDF file:	•	If the TrueType font program is embedded, the Type 2 CIDFont dictionary shall contain a CIDToGIDMap entry 		that maps CIDs to the glyph indices for the appropriate glyph descriptions in that font program.	•	If the TrueType font program is not embedded but is referenced by name, the Type 2 CIDFont dictionary shall not 		contain a CIDToGIDMap entry, since it is not meaningful to refer to glyph indices in an external font program. 		In this case, CIDs shall not participate in glyph selection, and only predefined CMaps may be used with this CIDFont. 		The conforming reader shall select glyphs by translating characters from the encoding specified by the 		predefined CMap to one of the encodings in the TrueType font’s “cmap” table. 		The means by which this is accomplished are implementation-dependent.Even though the CIDs are not used to select glyphs in a Type 2 CIDFont, they shall always be used to determine the glyph metrics, as described in the next sub-clause.Every CIDFont shall contain a glyph description for CID 0, which is analogous to the .notdef character name in simple fonts.</body></comment><class><name>UnderlineAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextMarkup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.UnderlineAnnotation</class-id><body>PDF Text Markup Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.10, pp. 403.Text markup annotations shall appear as highlights, underlines, strikeouts, or jagged (“squiggly”) underlines in the text of a document.When opened, they shall display a pop-up window containing the text of the associated note.</body></comment><class><name>FileIdentifier</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PDFArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.FileIdentifier</class-id><body>PDF File Identifier as defined in PDF 32000_2008.pdf, section 14.4, pp. 551.PDF files may contain references to other PDF files. Simply storing a file name, however, even in a platform-independent format, does not guarantee that the file can be found.Even if the file still exists and its name has not been changed, different server software applications may identify it in different ways.Servers running on DOS platforms convert all file names to 8 characters and a 3-character extension.Different servers may use different strategies for converting longer file names to this format.External file references may be made more reliable by including a file identifier (PDF 1.1) in the file and using it in addition to the normal platform-based file designation.Matching the identifier in the file reference with the one in the file confirms whether the correct file was found.File identifiers shall be defined by the optional ID entry in a PDF file’s trailer dictionary (see Trailer).The ID entry is optional but should be used.The value of this entry shall be an array of two byte strings.The first byte string shall be a permanent identifier based on the contents of the file at the time it was originally created and shall not change when the file is incrementally updated.The second byte string shall be a changing identifier based on the file’s contents at the time it was last updated.When a file is first written, both identifiers shall be set to the same value.If both identifiers match when a file reference is resolved, it is very likely that the correct and unchanged file has been found.If only the first identifier matches, a different version of the correct file has been found.To help ensure the uniqueness of file identifiers, they should be computed by means of a message digest algorithm such as MD5, using the following information:	• The current time	• A string representation of the file’s location, usually a pathname	• The size of the file in bytes	• The values of all entries in the file’s document information dictionaryNOTEThe calculation of the file identifier need not be reproducible; all that matters is that the identifier is likely to be unique.For example, two implementations of the preceding algorithm might use different formats for the current time, causing them to produce different file identifiers for the same file created at the same time, but the uniqueness of the identifier is not affected.</body></comment><class><name>WatermarkAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Annot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.WatermarkAnnotation</class-id><body>PDF Watermark Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.22, pp. 410.A watermark annotation shall be used to represent graphics that shall be printed at a fixed size and position on a page, regardless of the dimensions of the printed page.The FixedPrint entry of a watermark annotation dictionary shall be a dictionary that contains values for specifying the size and position of the annotation.Watermark annotations shall have no pop-up window or other interactive elements.When displaying a watermark annotation on-screen, conforming readers shall use the dimensions of the media box as the page size so that the scroll and zoom behaviour is the same as for other annotations.	NOTE	Since many printing devices have non printable margins, such margins should be taken into consideration when positioning watermark annotations near the edge of a page.</body></comment><class><name>NameTreeLeaf</name><environment>Graphics.PDF</environment><super>Graphics.PDF.NameTree</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.NameTreeLeaf</class-id><body>PDF Name Trees as defined in PDF 32000_2008.pdf pp. 88.The Names entries in the leaf (or root) nodes shall contain the tree’s keys and their associated values, arranged in key-value pairs and shall be sorted lexically in ascending order by key.Shorter keys shall appear before longer ones beginning with the same byte sequence.Any encoding of the keys may be used as long as it is self-consistent; keys shall be compared for equality on a simple byte-by-byte basis.</body></comment><class><name>DocumentInformation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.DocumentInformation</class-id><body>PDF Document Information Dictionary object as defined in PDF 32000_2008.pdf pp. 549.The optional Info entry in the trailer of a PDF file (see Trailer) shall hold a document information dictionary containing metadata for the document.Any entry whose value is not known should be omitted from the dictionary rather than included with an empty string as its value.Some conforming readers may choose to permit searches on the contents of the document information dictionary.To facilitate browsing and editing, all keys in the dictionary shall be fully spelled out, not abbreviated.New keys should be chosen with care so that they make sense to users.The value associated with any key not specifically mentioned in Table 317 shall be a text string.Although conforming readers may store custom metadata in the document information dictionary, they may not store private content or structural information there.Such information shall be stored in the document catalogue instead (see Catalog).</body></comment><class><name>FileSpecification</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.FileSpecification</class-id><body>PDF File Specification Annotations as defined in PDF 32000_2008.pdf, section 7.11.3, pp. 102.The dictionary form of file specification provides more flexibility than the string form, allowing different files to be specified for different file systems or platforms, or for file systems other than the standard ones (DOS/Windows, Mac OS, and UNIX).Regardless of the platform, conforming readers should use the F and UF (beginning with PDF 1.7) entries to specify files.The UF entry is optional, but should be included because it enables cross-platform and cross-language compatibility.</body></comment><class><name>Writer</name><environment>Graphics.PDF</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.Writer</class-id><body>A stream to write PDF objects to a byte stream</body></comment><class><name>ExtGState</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.ExtGState</class-id><body>PDF Graphics State Parameter Dictionaries as defined in PDF 32000_2008.pdf, section 8.4.5, pp. 128.While some parameters in the graphics state may be set with individual operators, others may not. The latter may only be set with the generic graphics state operator gs (PDF 1.2). The operand supplied to this operator shall be the name of a graphics state parameter dictionary whose contents specify the values of one or more graphics state parameters. This name shall be looked up in the ExtGState subdictionary of the current resource dictionary.The graphics state parameter dictionary is also used by type 2 patterns, which do not have a content stream in which the graphics state operators could be invoked.Each entry in the parameter dictionary shall specify the value of an individual graphics state parameter. All entries need not be present for every invocation of the gs operator; the supplied parameter dictionary may include any combination of parameter entries. The results of gs shall be cumulative; parameter values established in previous invocations persist until explicitly overridden.NOTENote that some parameters appear in both Tables; these parameters can be set either with individual graphics state operators or with gs. It is expected that any future extensions to the graphics state will be implemented by adding new entries to the graphics state parameter dictionary rather than by introducing new graphics state operators.</body></comment><class><name>PageRenderer</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Renderer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>globalState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Rendering</package></attributes></class><comment><class-id>Graphics.PDF.PageRenderer</class-id><body>renders contents on a page</body></comment><class><name>EndCompatibility</name><environment>Graphics.PDF</environment><super>Graphics.PDF.CompatibilityOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.EndCompatibility</class-id><body>End a compatibility section begun by a balancing BX operator. Ignore any unrecognized operands and operators from previous matching BX onward.</body></comment><class><name>NumberTreeLeaf</name><environment>Graphics.PDF</environment><super>Graphics.PDF.NumberTree</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.NumberTreeLeaf</class-id><body>PDF Number Trees as defined in PDF 32000_2008.pdf pp. 91.A number tree is similar to a name tree (see NameTree), except that its keys shall be integers instead of strings and shall be sorted in ascending numerical order.The entries in the leaf (or root) nodes containing the key-value pairs shall be named Nums instead of Names as in a name tree.</body></comment><class><name>SubPredictor</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PNGPredictor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.SubPredictor</class-id><body>Each byte is replaced with the difference between it and the ``corresponding byte'' to its left.</body></comment><class><name>RestoreState</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.RestoreState</class-id><body>Restore the graphics state by removing the most recently saved state from the stack and making it the current state</body></comment><class><name>Movie</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.Movie</class-id><body>PDF Movies as defined in PDF 32000_2008.pdf, section 13.4, pp. 507.The features described in this sub-clause are obsolescent and their use is no longer recommended.They are superseded by the general multimedia framework described in 13.2, “Multimedia.”PDF shall embed movies within a document by means of movie annotations.Despite the name, a movie may consist entirely of sound with no visible images to be displayed on the screen.The Movie and A (activation) entries in the movie annotation dictionary shall refer, respectively, to a movie dictionary that shall describe the static characteristics of the movie and a movie activation dictionary that shall specify how it shall be presented.</body></comment><class><name>ICCBased</name><environment>Graphics.PDF</environment><super>Graphics.PDF.CIEColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.ICCBased</class-id><body>PDF ICCBased Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.5.5, pp. 149.ICCBased colour spaces (PDF 1.3) shall be based on a cross-platform colour profile as defined by the International Color Consortium (ICC). Unlike the CalGray, CalRGB, and Lab colour spaces, which are characterized by entries in the colour space dictionary, an ICCBased colour space shall be characterized by a sequence of bytes in a standard format. Details of the profile format can be found in the ICC specification.</body></comment><class><name>FixedPrint</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.FixedPrint</class-id><body>PDF Watermark Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.22, pp. 410.A watermark annotation shall be used to represent graphics that shall be printed at a fixed size and position on a page, regardless of the dimensions of the printed page.The FixedPrint entry of a watermark annotation dictionary shall be a dictionary that contains values for specifying the size and position of the annotation.Watermark annotations shall have no pop-up window or other interactive elements.When displaying a watermark annotation on-screen, conforming readers shall use the dimensions of the media box as the page size so that the scroll and zoom behaviour is the same as for other annotations.	NOTE	Since many printing devices have non printable margins, such margins should be taken into consideration when positioning watermark annotations near the edge of a page.</body></comment><class><name>FreeReference</name><environment>Graphics.PDF</environment><super>Graphics.PDF.CrossReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.FreeReference</class-id><body>A Cross-Reference free Entry as defined in PDF 32000_2008.pdf pp. 41.The cross-reference entry for a free object has essentially the same format, except that the keyword shall be finstead of n and the interpretation of the first item is different:	nnnnnnnnnn ggggg f eolwhere:	nnnnnnnnnn shall be the 10-digit object number of the next free object	ggggg shall be a 5-digit generation number	f shall be a keyword identifying this as a free entry	eol shall be a 2-character end-of-line sequenceThere are two ways an entry may be a member of the free entries list. Using the basic mechanism the free entries in the cross-reference table may form a linked list, with each free entry containing the object number of the next. The first entry in the table (object number 0) shall always be free and shall have a generation number of 65,535; it is shall be the head of the linked list of free objects. The last free entry (the tail of the linked list) links back to object number 0. Using the second mechanism, the table may contain other free entries that link back to object number 0 and have a generation number of 65,535, even though these entries are not in the linked list itself.Except for object number 0, all objects in the cross-reference table shall initially have generation numbers of 0. When an indirect object is deleted, its cross-reference entry shall be marked free and it shall be added to the linked list of free entries. The entry’s generation number shall be incremented by 1 to indicate the generation number to be used the next time an object with that object number is created. Thus, each time the entry is reused, it is given a new generation number. The maximum generation number is 65,535; when a cross-reference entry reaches this value, it shall never be reused.</body></comment><class><name>StandardFont</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type1</super><private>false</private><indexed-type>none</indexed-type><inst-vars>standardWidths </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.StandardFont</class-id><body>PDF Standard Type 1 Fonts as defined in PDF 32000_2008.pdf, clause 9.6.2.2, pp. 256.The PostScript names of 14 Type 1 fonts, known as the standard 14 fonts, are as follows: Times-Roman, Helvetica, Courier, Symbol, Times-Bold, Helvetica-Bold, Courier-Bold, ZapfDingbats, Times-Italic, Helvetica-Oblique, Courier-Oblique, Times-BoldItalic, Helvetica-BoldOblique, Courier-BoldObliqueThese fonts, or their font metrics and suitable substitution fonts, shall be available to the conforming reader</body></comment><class><name>FillOld</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathPaintingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.FillOld</class-id><body>Equivalent to f; included only for compatibility. Although PDF reader applications shall be able to accept this operator, PDF writer applications should use f instead</body></comment><class><name>CalGray</name><environment>Graphics.PDF</environment><super>Graphics.PDF.CIEColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.CalGray</class-id><body>PDF CalGray Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.5.2, pp. 145.A CalGray colour space (PDF 1.1) is a special case of a single-component CIE-based colour space, known as a CIE-based A colour space. This type of space is the one-dimensional (and usually achromatic) analog of CIE-based ABC spaces. Colour values in a CIE-based A space shall have a single component, arbitrarily named A.</body></comment><class><name>Appearance</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.Appearance</class-id><body>PDF appearance dictionary as defined in PDF 32000_2008.pdf, section 12.5.5, pp. 389.An annotation may define as many as three separate appearances:• The normal appearance shall be used when the annotation is not interacting with the user. This appearance is also used for printing the annotation.• The rollover appearance shall be used when the user moves the cursor into the annotation’s active area without pressing the mouse button.• The down appearance shall be used when the mouse button is pressed or held down within the annotation’s active area.NOTE As used here, the term mouse denotes a generic pointing device that controls the location of a cursor on the screen and has at least one button that can be pressed, held down, and released.The normal, rollover, and down appearances shall be defined in an appearance dictionary, which in turn is the value of the AP entry in the annotation dictionary.</body></comment><class><name>Function</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Objecttype</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.Function</class-id><body>PDF Function Dictionary as defined in PDF 32000_2008.pdf pp. 92.PDF is not a programming language, and a PDF file is not a program.However, PDF provides several types of function objects (PDF 1.2) that represent parameterized classes of functions, including mathematical formulas and sampled representations with arbitrary resolution.</body></comment><class><name>PostScriptXObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.XObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF XObjects</package></attributes></class><comment><class-id>Graphics.PDF.PostScriptXObject</class-id><body>PDF PostScript XObjects as defined in PDF 32000_2008.pdf, section 8.8.2, pp. 202.Beginning with PDF 1.1, a content stream may include PostScript language fragments. These fragments may be used only when printing to a PostScript output device; they shall have no effect either when viewing the document on-screen or when printing it to a non-PostScript device. In addition, conforming readers may not be able to interpret the PostScript fragments. Hence, this capability should be used with extreme caution and only if there is no other way to achieve the same result. Inappropriate use of PostScript XObjects can cause PDF files to print incorrectly.A PostScript XObject is an XObject stream whose Subtype entry has the value PS.If a PDF content stream is translated by a conforming reader into the PostScript language, any Do operation that references a PostScript XObject may be replaced by the contents of the XObject stream itself. The stream shall be copied without interpretation. The PostScript fragment may use Type 1 and TrueType fonts listed in the Font subdictionary of the current resource dictionary, accessing them by their BaseFont names using the PostScript findfont operator. The fragment shall not use other types of fonts listed in the Font subdictionary. It should not reference the PostScript definitions corresponding to PDF procedure sets, which are subject to change.</body></comment><class><name>AsciiString</name><environment>Graphics.PDF</environment><super>Graphics.PDF.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.AsciiString</class-id><body>The bytes are all in the ASCII range</body></comment><class><name>UncolouredPattern</name><environment>Graphics.PDF</environment><super>Graphics.PDF.SpecialColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.UncolouredPattern</class-id><body>PDF Uncoloured Tiling Patterns as defined in PDF 32000_2008.pdf, section 8.7.3.3, pp. 178.An uncoloured tiling pattern is a pattern that has no inherent colour: the colour shall be specified separately whenever the pattern is used.It provides a way to tile different regions of the page with pattern cells having the same shape but different colours.This type of pattern shall be identified by a pattern type of 1 and a paint type of 2 in the pattern dictionary.The pattern’s content stream shall not explicitly specify any colours; it may paint an image mask but no other kind of image.A Pattern colour space representing an uncoloured tiling pattern shall have a parameter: an object identifying the underlying colour space in which the actual colour of the pattern shall be specified.The underlying colour space shall be given as the second element of the array that defines the Pattern colour space.</body></comment><class><name>Contents</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.Contents</class-id><body>PDF Catalog as defined in PDF 32000_2008.pdf pp. 81.Content streams are the primary means for describing the appearance of pages and other graphical elements.A content stream depends on information contained in an associated resource dictionary; in combination, these two objects form a self-contained entity.</body></comment><class><name>ContentString</name><environment>Graphics.PDF</environment><super>Graphics.PDF.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.ContentString</class-id><body>PDF String in a stream as defined in PDF 32000_2008.pdf pp. 650.Strings in contents streams have the imlementation limit of 32767 bytes</body></comment><class><name>TextAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.TextAnnotation</class-id><body>PDF Text Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.4, pp. 394.A text annotation represents a “sticky note” attached to a point in the PDF document.When closed, the annotation shall appear as an icon; when open, it shall display a pop-up window containing the text of the note in a font and size chosen by the conforming reader.Text annotations shall not scale and rotate with the page; they shall behave as if the NoZoom and NoRotate annotation flags were always set.</body></comment><class><name>FillAndStroke</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathPaintingOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.FillAndStroke</class-id><body>Fill and then stroke the path, using the nonzero winding number rule to determine the region to fill. This operator shall produce the same result as constructing two identical path objects, painting the first with f and the second with S.NOTEThe filling and stroking portions of the operation consult different values of several graphics state parameters, such as the current colour</body></comment><class><name>OutlineItem</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.OutlineItem</class-id><body>PDF Outline dictionary as defined in PDF 32000_2008.pdf, section 12.3.3,  pp. 367.A PDF document may contain a document outline that the conforming reader may display on the screen, allowing the user to navigate interactively from one part of the document to another.The outline consists of a tree-structured hierarchy of outline items (sometimes called bookmarks), which serve as a visual table of contents to display the document’s structure to the user.The user may interactively open and close individual items by clicking them with the mouse.When an item is open, its immediate children in the hierarchy shall become visible on the screen; each child may in turn be open or closed, selectively revealing or hiding further parts of the hierarchy. When an item is closed, all of its descendants in the hierarchy shall be hidden.Clicking the text of any visible item activates the item, causing the conforming reader to jump to a destination or trigger an action associated with the item.The root of a document’s outline hierarchy is an outline dictionary specified by the Outlines entry in the document catalogue.Each individual outline item within the hierarchy shall be defined by an outline item dictionary.The items at each level of the hierarchy form a linked list, chained together through their Prev and Next entries and accessed through the First and Last entries in the parent item (or in the outline dictionary in the case of top-level items).When displayed on the screen, the items at a given level shall appear in the order in which they occur in the linked list.</body></comment><class><name>TypeError</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.TypeError</class-id><body>signals a type mismatch</body></comment><class><name>SetNonStrokingRGB</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetNonStrokingRGB</class-id><body>Same as RG but used for nonstroking operations.</body></comment><class><name>MarkedContentPointWithProperties</name><environment>Graphics.PDF</environment><super>Graphics.PDF.MarkedContentOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.MarkedContentPointWithProperties</class-id><body>Designate a marked-content point with an associated property list. tag shall be a name object indicating the role or significance of the point. properties shall be either an inline dictionary containing the property list or a name object associated with it in the Properties subdictionary of the current resource dictionary</body></comment><class><name>NameEncoder</name><environment>Graphics.PDF</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.NameEncoder</class-id><body>A de- and en-coder for PDF Names (see PDF 32000_2008.pdf p.17)Use String&gt;&gt;fromPdfName to convert from PDF to SmalltalkUse String&gt;&gt;asPdfName to convert from Smalltalk to PDF</body></comment><class><name>Lab</name><environment>Graphics.PDF</environment><super>Graphics.PDF.CIEColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.Lab</class-id><body>PDF Lab Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.5.4, pp. 148.A Lab colour space is a CIE-based ABC colour space with two transformation stages. In this type of space, A, B, and C represent the L*, a*, and b* components of a CIE 1976 L*a*b* space. The range of the first (L*) component shall be 0 to 100; the ranges of the second and third (a* and b*) components shall be defined by the Range entry in the colour space dictionary.</body></comment><class><name>DCTDecode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Filter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.DCTDecode</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 34.Decompresses data encoded using a DCT (discrete cosine transform) technique based on the JPEG standard, reproducing image sample data that approximates the original data.</body></comment><class><name>Integer</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.Integer</class-id><body>PDF Number object as defined in PDF 32000_2008.pdf p. 14.An integer shall be written as one or more decimal digits optionally preceded by a sign.The value shall be interpreted as a signed decimal integer and shall be converted to an integer object.</body></comment><class><name>BeginMarkedContentWithProperties</name><environment>Graphics.PDF</environment><super>Graphics.PDF.MarkedContentOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.BeginMarkedContentWithProperties</class-id><body>Begin a marked-content sequence with an associated property list, terminated by a balancing EMC operator. tag shall be a name object indicating the role or significance of the sequence. properties shall be either an inline dictionary containing the property list or a name object associated with it in the Properties subdictionary of the current resource dictionary</body></comment><class><name>NextLine</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextPositioningOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.NextLine</class-id><body>Move to the start of the next line. This operator has the same effect as the code	0 -Tl Tdwhere Tl denotes the current leading parameter in the text state. The negative of Tl is used here because Tl is the text leading expressed as a positive number. Going to the next line entails decreasing the y coordinate</body></comment><class><name>Subpath</name><environment>Graphics.PDF</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>segments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.Subpath</class-id><body>PDF Path Construction and Painting as defined in PDF 32000_2008.pdf, section 8.5, pp. 131.Paths define shapes, trajectories, and regions of all sorts. They shall be used to draw lines, define the shapes of filled areas, and specify boundaries for clipping other graphics. The graphics state shall include a current clipping path that shall define the clipping boundary for the current page. At the beginning of each page, the clipping path shall be initialized to include the entire page.A path shall be composed of straight and curved line segments, which may connect to one another or may be disconnected. A pair of segments shall be said to connect only if they are defined consecutively, with the second segment starting where the first one ends. Thus, the order in which the segments of a path are defined shall be significant. Nonconsecutive segments that meet or intersect fortuitously shall not be considered to connect.NOTEA path is made up of one or more disconnected subpaths, each comprising a sequence of connected segments. The topology of the path is unrestricted: it may be concave or convex, may contain multiple subpaths representing disjoint areas, and may intersect itself in arbitrary ways.The h operator explicitly shall connect the end of a subpath back to its starting point; such a subpath is said to be closed. A subpath that has not been explicitly closed is said to be open.A path object is defined by a sequence of operators to construct the path, followed by one or more operators to paint the path or to use it as a clipping boundary. PDF path operators fall into three categories:	•	Path construction operators define the geometry of a path. 		A path is constructed by sequentially applying one or more of these operators.	•	Path-painting operators end a path object, usually causing the object to be painted on the current page in any of a variety of ways.	•	Clipping path operators, invoked immediately before a path-painting operator, cause the path object also to be used for clipping of subsequent graphics objects.</body></comment><class><name>Crypt</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Filter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.Crypt</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 38.Decrypts data encrypted by a security handler, reproducing the data as it was before encryption.</body></comment><class><name>PaethPredictor</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PNGPredictor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.PaethPredictor</class-id><body>Each byte is replaced with the difference between it and the Paeth predictor of the corresponding bytes to its left, above it, and to its upper left.</body></comment><class><name>ArrayType</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.ArrayType</class-id><body>This type matches a uniform array of attribute values of the same class.The elements of the array are checked and specialized with the type</body></comment><class><name>StichingFunction</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FunctionDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.StichingFunction</class-id><body>PDF Function as defined in PDF 32000_2008.pdf pp. 96.Type 3 functions define a stitching of the subdomains of several 1-input functions to produce a single new 1-input function.Since the resulting stitching function is a 1-input function, the domain is given by a two-element array, [Domain0 Domain1].</body></comment><class><name>ExternalGraphicsObject</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsObjectWithResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics</package></attributes></class><comment><class-id>Graphics.PDF.ExternalGraphicsObject</class-id><body>XObject</body></comment><class><name>ThreeDAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Annot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.ThreeDAnnotation</class-id><body>PDF 3D Annotations as defined in PDF 32000_2008.pdf, section 13.6.2, pp. 512.3D annotations are the means by which 3D artwork shall be represented in a PDF document.In addition to these entries, a 3D annotation shall provide an appearance stream in its AP entry that has a normal appearance (the N entry).This appearance may be used by applications that do not support 3D annotations and by all applications for the initial display of the annotation.</body></comment><class><name>Metadata</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.Metadata</class-id><body>PDF Metadata as defined in PDF 32000_2008.pdf pp. 548.A PDF document may include general information, such as the document’s title, author, and creation and modification dates. Such global information about the document (as opposed to its content or structure) is called metadata and is intended to assist in cataloguing and searching for documents in external databases. Beginning with PDF 1.4, metadata may also be specified for individual components of a document.Metadata may be stored in a PDF document in either of the following ways:	•	In a metadata stream (PDF 1.4) associated with the document or a component of the document (14.3.2, “Metadata Streams”)	•	In a document information dictionary associated with the document (14.3.3, “Document Information Dictionary”)NOTEDocument information dictionaries is the original way that metadata was included in a PDF file. Metadata streams were introduced in PDF 1.4 and is now the preferred method to include metadata.Metadata StreamsMetadata, both for an entire document and for components within a document, may be stored in PDF streams called metadata streams (PDF 1.4).NOTE 1Metadata streams have the following advantages over the document information dictionary:	•	PDF-based workflows often embed metadata-bearing artwork as components within larger documents. 		Metadata streams provide a standard way of preserving the metadata of these components for examination downstream. 		PDF-aware conforming products should be able to derive a list of all metadata-bearing document components from the PDF document itself.	•	PDF documents are often made available on the Web or in other environments, where many tools routinely examine, catalogue, and classify documents. 		These tools should be able to understand the self-contained description of the document even if they do not understand PDF.Besides the usual entries common to all stream dictionaries, the metadata stream dictionary shall contain additional entries.The contents of a metadata stream shall be the metadata represented in Extensible Markup Language (XML).NOTE 2This information is visible as plain text to tools that are not PDF-aware only if the metadata stream is both unfiltered and unencrypted.</body></comment><class><name>FileError</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.FileError</class-id><body>Error in the PDF file structure</body></comment><class><name>Unsupported</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF basics</package></attributes></class><comment><class-id>Graphics.PDF.Unsupported</class-id><body>Unsupported is raised when a feature of the PDF specification is not (yet) supported</body></comment><class><name>Type3FontOperation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Operation</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.Type3FontOperation</class-id><body>PDF Type 3 Font Operator as defined in PDF 32000_2008.pdf, section 9.6.5, pp. 260.Type 3 fonts differ from the other fonts supported by PDF. A Type 3 font dictionary defines the font; font dictionaries for other fonts simply contain information about the font and refer to a separate font program for the actual glyph descriptions. In Type 3 fonts, glyphs shall be defined by streams of PDF graphics operators. These streams shall be associated with glyph names. A separate encoding entry shall map character codes to the appropriate glyph names for the glyphs.NOTE 1		Type 3 fonts are more flexible than Type 1 fonts because the glyph descriptions may contain arbitrary PDF graphics operators. 			However, Type 3 fonts have no hinting mechanism for improving output at small sizes or low resolutions.</body></comment><class><name>SetType3GlyphWidth</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type3FontOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetType3GlyphWidth</class-id><body>Set width information for the glyph and declare that the glyph description specifies both its shape and its colour.NOTE	This operator name ends in the digit 0.wx denotes the horizontal displacement in the glyph coordinate system; it shall be consistent with the corresponding width in the font’s Widths array. wy shall be 0.This operator shall only be permitted in a content stream appearing in a Type 3 font’s CharProcs dictionary. It is typically used only if the glyph description executes operators to set the colour explicitly.</body></comment><class><name>HighlightAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextMarkup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.HighlightAnnotation</class-id><body>PDF Text Markup Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.10, pp. 403.Text markup annotations shall appear as highlights, underlines, strikeouts, or jagged (“squiggly”) underlines in the text of a document.When opened, they shall display a pop-up window containing the text of the associated note.</body></comment><class><name>ObjectStream</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TypedStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser offsets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.ObjectStream</class-id><body>PDF Object Stream as defined in PDF 32000_2008.pdf pp. 45.An object stream, is a stream object in which a sequence of indirect objects may be stored, as an alternative to their being stored at the outermost file level.</body></comment><class><name>SetCap</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GraphicsStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetCap</class-id><body>Set the line cap style in the graphics state</body></comment><class><name>CCITTFaxDecode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Filter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.CCITTFaxDecode</class-id><body>PDF Filter as defined in PDF 32000_2008.pdf pp. 30.Decompresses data encoded using the CCITT facsimile standard, reproducing the original data (typically monochrome image data at 1 bit per pixel).</body></comment><class><name>CalRGB</name><environment>Graphics.PDF</environment><super>Graphics.PDF.CIEColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.CalRGB</class-id><body>PDF CalRGB Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.5.3, pp. 146.A CalRGB colour space is a CIE-based ABC colour space with only one transformation stage instead of two. In this type of space, A, B, and C represent calibrated red, green, and blue colour values. These three colour components shall be in the range 0.0 to 1.0; component values falling outside that range shall be adjusted to the nearest valid value without error indication. The decoding functions are gamma functions whose coefficients shall be specified by the Gamma entry in the colour space dictionary. The transformation matrix shall be defined by the dictionary’s Matrix entry. Since there is no second transformation stage, “Decode LMN” and “Matrix LMN” shall be implicitly taken to be identity transformations.</body></comment><class><name>EndInlineImage</name><environment>Graphics.PDF</environment><super>Graphics.PDF.InlineImageOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.EndInlineImage</class-id><body>End an inline image object</body></comment><class><name>SetStrokingColorSpecial</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetStrokingColorSpecial</class-id><body>Same as SC but also supports Pattern, Separation, DeviceN and ICCBased colour spaces.If the current stroking colour space is a Separation, DeviceN, or ICCBased colour space, the operands c1…cn shall be numbers. The number of operands and their interpretation depends on the colour space.If the current stroking colour space is a Pattern colour space, name shall be the name of an entry in the Pattern subdictionary of the current resource dictionary. For an uncoloured tiling pattern (PatternType = 1 and PaintType = 2), c1…cn shall be component values specifying a colour in the pattern’s underlying colour space. For other types of patterns, these operands shall not be specified.</body></comment><class><name>PopupAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Annot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.PopupAnnotation</class-id><body>PDF Pop-up Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.14, pp. 405.A pop-up annotation displays text in a pop-up window for entry and editing.It shall not appear alone but is associated with a markup annotation, its parent annotation, and shall be used for editing the parent’s text.It shall have no appearance stream or associated actions of its own and shall be identified by the Popup entry in the parent’s annotation dictionary.</body></comment><class><name>UTF16Textstring</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Textstring</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.UTF16Textstring</class-id><body>PDF Text String object as defined in PDF 32000_2008.pdf pp. 86.For text strings encoded in Unicode, the first two bytes shall be 254 followed by 255.These two bytes represent the Unicode byte order marker, U+FEFF, indicating that the string is encoded in the UTF-16BE (big-endian) encoding scheme specified in the Unicode standard.The value should be shown with UTF-16BEEncoding</body></comment><class><name>IndirectType</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.IndirectType</class-id><body>This type matches a Reference to a PDF.Object class - the object cannot be direct.</body></comment><class><name>BorderEffect</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.BorderEffect</class-id><body>PDF border effect dictionary as defined in PDF 32000_2008.pdf, section 12.5.4, pp. 387.Beginning with PDF 1.5, some annotations (square, circle, and polygon) may have a BE entry, which is a border effect dictionary that specifies an effect that shall be applied to the border of the annotations.Beginning with PDF 1.6, the free text annotation may also have a BE entry. Table 167 describes the entries in a border effect dictionary.</body></comment><class><name>OptionalContentUsageApplication</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.OptionalContentUsageApplication</class-id><body>PDF Optional Content as defined in PDF 32000_2008.pdf section 8.11.4.4, pp. 233.A usage application dictionary specifies the rules for which usage entries shall be used by conforming readers to automatically manipulate the state of optional content groups, which groups shall be affected, and under which circumstances.Usage application dictionaries shall only be used by interactive conforming readers, and shall not be used by applications that use PDF as final form output</body></comment><class><name>Shading</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Objecttype</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Shading</package></attributes></class><comment><class-id>Graphics.PDF.Shading</class-id><body>PDF Shading Pattern as defined in PDF 32000_2008.pdf, section 8.7.4, pp. 181Shading patterns (PDF 1.3) provide a smooth transition between colours across an area to be painted, independent of the resolution of any particular output device and without specifying the number of steps in the colour transition. Patterns of this type shall be described by pattern dictionaries with a pattern type of 2.</body></comment><class><name>CoonsPatchMesh</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ShadingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Shading</package></attributes></class><comment><class-id>Graphics.PDF.CoonsPatchMesh</class-id><body>PDF Shading as defined in PDF 32000_2008.pdf pp. 194.Type 6 shadings (Coons patch meshes) are constructed from one or more colour patches, each bounded by four cubic Bézier curves.Degenerate Bézier curves are allowed and are useful for certain graphical effects.At least one complete patch shall be specified.A Coons patch generally has two independent aspects:- Colours are specified for each corner of the unit square, and bilinear interpolation is used to fill in colours over the entire unit square.- Coordinates are mapped from the unit square into a four-sided patch whose sides are not necessarily linear.The mapping is continuous: the corners of the unit square map to corners of the patch and the sides of the unit square map to sides of the patch.</body></comment><class><name>AppendLine</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathConstructionOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.AppendLine</class-id><body>Append a straight line segment from the current point to the point (x, y). The new current point shall be (x, y)</body></comment><class><name>Names</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Document</package></attributes></class><comment><class-id>Graphics.PDF.Names</class-id><body>PDF Names as defined in PDF 32000_2008.pdf pp. 80.Some categories of objects in a PDF file can be referred to by name rather than by object reference.The correspondence between names and objects is established by the document’s name dictionary (PDF 1.2), located by means of the Names entry in the document’s catalog.Each entry in this dictionary designates the root of a name tree defining names for a particular category of objects.</body></comment><class><name>FlateDecodeStream</name><environment>Graphics.PDF</environment><super>OS.ZLib.InflateStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.ZLib.*			</imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.FlateDecodeStream</class-id><body>A zlib inflate stream with header and checksum used by PDF as defined in PDF 32000_2008.pdf pp. 25.</body></comment><class><name>FunctionBasedShading</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ShadingDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Shading</package></attributes></class><comment><class-id>Graphics.PDF.FunctionBasedShading</class-id><body>PDF Shading as defined in PDF 32000_2008.pdf pp. 185.In Type 1 (function-based) shadings, the colour at every point in the domain is defined by a specified mathematical function.The function need not be smooth or continuous.This type is the most general of the available shading types and is useful for shadings that cannot be adequately described with any of the other types.This type of shading shall not be used with an Indexed colour space.</body></comment><class><name>MMType1</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type1</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.MMType1</class-id><body>PDF Multiple Master Fonts as defined in PDF 32000_2008.pdf, clause 9.6.2.3, pp. 256.The multiple master font format is an extension of the Type 1 font format that allows the generation of a wide variety of typeface styles from a single font program. This is accomplished through the presence of various design dimensions in the font.EXAMPLE 1	Examples of design dimensions are weight (light to extra-bold) and width (condensed to expanded).Coordinates along these design dimensions (such as the degree of boldness) are specified by numbers. A particular choice of numbers selects an instance of the multiple master font. PDFs can contain multiple master instances.NOTE		Adobe Technical Note #5015, Type 1 Font Format Supplement, describes multiple master fonts in detail.The font dictionary for a multiple master font instance may contain the same entries as a Type 1 font dictionary, with these differences:	•	The value of Subtype shall be MMType1.	•	If the PostScript name of the instance contains SPACEs (20h), the SPACEs shall be replaced by LOW LINEs (underscores) (5Fh) in the value of BaseFont. 		For instance, as illustrated in this example, the name “MinionMM 366 465 11 ” (which ends with a SPACE character) becomes /MinionMM_366_465_11_.If the font program for a multiple master font instance is embedded in the PDF file, it shall be an ordinary Type 1 font program, not a multiple master font program. This font program is called a snapshot of the multiple master font instance that incorporates the chosen values of the design coordinates.</body></comment><class><name>PolygonAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PolygonPolyline</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.PolygonAnnotation</class-id><body>PDF Polygon and Polyline Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.9, pp. 402.Polygon annotations display closed polygons on the page.Such polygons may have any number of vertices connected by straight lines.Polyline annotations are similar to polygons, except that the first and last vertex are not implicitly connected.</body></comment><class><name>ViewerPreferences</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.ViewerPreferences</class-id><body>PDF ViewerPreferences as defined in PDF 32000_2008.pdf, section 12.2,  pp. 362.The ViewerPreferences entry in a document’s catalogue designates a viewer preferences dictionary (PDF 1.2) controlling the way the document shall be presented on the screen or in print.If no such dictionary is specified, conforming readers should behave in accordance with their own current user preference settings.</body></comment><class><name>WordSpacing</name><environment>Graphics.PDF</environment><super>Graphics.PDF.TextStateOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.WordSpacing</class-id><body>Set the word spacing, Tw, to wordSpace, which shall be a number expressed in unscaled text space units. Word spacing shall be used by the Tj, TJ, and ' operators. Initial value: 0</body></comment><class><name>Type0</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Font</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Fonts</package></attributes></class><comment><class-id>Graphics.PDF.Type0</class-id><body>PDF Composite Fonts as defined in PDF 32000_2008.pdf, clause 9.7, pp. 267.A composite font, also called a Type 0 font, is one whose glyphs are obtained from a fontlike object called a CIDFont. A composite font shall be represented by a font dictionary whose Subtype value is Type0. The Type 0 font is known as the root font, and its associated CIDFont is called its descendant.NOTE 1		Composite fonts in PDF are analogous to composite fonts in PostScript but with some limitations. 			In particular, PDF requires that the character encoding be defined by a CMap, which is only one of several encoding methods available in PostScript. 			Also, PostScript allows a Type 0 font to have multiple descendants, which might also be Type 0 fonts. 			PDF supports only a single descendant, which shall be a CIDFont.When the current font is composite, the text-showing operators shall behave differently than with simple fonts. For simple fonts, each byte of a string to be shown selects one glyph, whereas for composite fonts, a sequence of one or more bytes are decoded to select a glyph from the descendant CIDFont.NOTE 2		This facility supports the use of very large character sets, such as those for the Chinese, Japanese, and Korean languages. 			It also simplifies the organization of fonts that have complex encoding requirements.This sub-clause first introduces the architecture of CID-keyed fonts, which are the only kind of composite font supported in PDF. Then it describes the CIDFont and CMap dictionaries, which are the PDF objects that represent the correspondingly named components of a CID-keyed font. Finally, it describes the Type 0 font dictionary, which combines a CIDFont and a CMap to produce a font whose glyphs may be accessed by means of variable-length character codes in a string to be shown.</body></comment><class><name>StandardEncryption</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Encryption</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.StandardEncryption</class-id><body>PDF Standard Encryption as defined in PDF 32000_2008.pdf pp. 60.PDF’s standard security handler shall allow access permissions and up to two passwords to be specified for a document: an owner password and a user password.An application’s decision to encrypt a document shall be based on whether the user creating the document specifies any passwords or access restrictions.</body></comment><class><name>ClipEvenOdd</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ClippingPathOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.ClipEvenOdd</class-id><body>Modify the current clipping path by intersecting it with the current path, using the even-odd rule to determine which regions lie inside the clipping path.</body></comment><class><name>Date</name><environment>Graphics.PDF</environment><super>Graphics.PDF.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Basic Objects</package></attributes></class><comment><class-id>Graphics.PDF.Date</class-id><body>PDF String object as defined in PDF 32000_2008.pdf pp. 87.The internal value is local time.Date values used in a PDF shall conform to a standard date format, which closely follows that of the international standard ASN.1 (Abstract Syntax Notation One), defined in ISO/IEC 8824.A date shall be a text string of the form	(D:YYYYMMDDHHmmSSOHH'mm)where:	YYYY shall be the year	MM shall be the month (01–12)	DD shall be the day (01–31)	HH shall be the hour (00–23)	mm shall be the minute (00–59)	SS shall be the second (00–59)	O shall be the relationship of local time to Universal Time (UT), and shall be denoted by one of the characters PLUS SIGN (U+002B) (+), HYPHEN-MINUS (U+002D) (-), or LATIN CAPITAL LETTER Z (U+005A) (Z) (see below)	HH followed by APOSTROPHE (U+0027) (') shall be the absolute value of the offset from UT in hours (00–23)	mm shall be the absolute value of the offset from UT in minutes (00–59)The prefix D: shall be present, the year field (YYYY) shall be present and all other fields may be present but only if all of their preceding fields are also present. The APOSTROPHE following the hour offset field (HH) shall only be present if the HH field is present. The minute offset field (mm) shall only be present if the APOSTROPHE following the hour offset field (HH) is present. The default values for MM and DD shall be both 01; all other numerical fields shall default to zero values. A PLUS SIGN as the value of the O field signifies that local time is later than UT, a HYPHEN-MINUS signifies that local time is earlier than UT, and the LATIN CAPITAL LETTER Z signifies that local time is equal to UT. If no UT information is specified, the relationship of the specified time to UT shall be considered to be GMT. Regardless of whether the time zone is specified, the rest of the date shall be specified in local time.EXAMPLEFor example, December 23, 1998, at 7:52 PM, U.S. Pacific Standard Time, is represented by the string D:199812231952-08'00</body></comment><class><name>CalGrayColourSpaceDictionary</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.CalGrayColourSpaceDictionary</class-id><body>PDF CalGray Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.5.2, pp. 145.A CalGray colour space (PDF 1.1) is a special case of a single-component CIE-based colour space, known as a CIE-based A colour space. This type of space is the one-dimensional (and usually achromatic) analog of CIE-based ABC spaces. Colour values in a CIE-based A space shall have a single component, arbitrarily named A.</body></comment><class><name>EncryptedFileParser</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FileParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Parsing</package></attributes></class><comment><class-id>Graphics.PDF.EncryptedFileParser</class-id><body>This parser reads PDF objects from an encrypted file.</body></comment><class><name>NumberTreeNode</name><environment>Graphics.PDF</environment><super>Graphics.PDF.NumberTree</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.NumberTreeNode</class-id><body>PDF Number Trees as defined in PDF 32000_2008.pdf pp. 91.A number tree is similar to a name tree (see NameTree), except that its keys shall be integers instead of strings and shall be sorted in ascending numerical order.The entries in the leaf (or root) nodes containing the key-value pairs shall be named Nums instead of Names as in a name tree.</body></comment><class><name>TensorProductPatchMesh</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ShadingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Shading</package></attributes></class><comment><class-id>Graphics.PDF.TensorProductPatchMesh</class-id><body>PDF Shading as defined in PDF 32000_2008.pdf pp. 198.Type 7 shadings (tensor-product patch meshes) are identical to type 6, except that they are based on a bicubic tensor-product patch defined by 16 control points instead of the 12 control points that define a Coons patch.The shading dictionaries representing the two patch types differ only in the value of the ShadingType entry and in the number of control points specified for each patch in the data stream.NOTE	Although the Coons patch is more concise and easier to use, the tensor-product patch affords greater control over colour mapping</body></comment><class><name>AveragePredictor</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PNGPredictor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Filter</package></attributes></class><comment><class-id>Graphics.PDF.AveragePredictor</class-id><body>Each byte is replaced with the difference between it and the average of the corresponding bytes to its left and above it, truncating any fractional part.</body></comment><class><name>FreeTextAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Markup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.FreeTextAnnotation</class-id><body>PDF Free Text Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.6, pp. 395.A free text annotation displays text directly on the page.Unlike an ordinary text annotation, a free text annotation has no open or closed state; instead of being displayed in a pop-up window, the text shall be always visible.</body></comment><class><name>OptionalContentUsageLanguage</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Dictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Data Structures</package></attributes></class><comment><class-id>Graphics.PDF.OptionalContentUsageLanguage</class-id><body>PDF Optional Content as defined in PDF 32000_2008.pdf section 8.11.4.4, pp. 232.A dictionary specifying the language of the content controlled by this optional content group.It may contain the following two entries:	Lang (required) 		A text string that specifies a language and possibly a locale. For example, es-MX represents Mexican Spanish.	Preferred (optional) 	A name whose values shall be either ON or OFF. Default value: OFF. It shall be used by conforming readers when there is a partial match but no exact match between the system language and the language strings in all usage dictionaries</body></comment><class><name>SetNonStrokingCMYK</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetNonStrokingCMYK</class-id><body>Same as K but used for nonstroking operations.</body></comment><class><name>File</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FileEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry objects parser header crossReferences trailer theTrue theFalse theNull </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.File</class-id><body>PDF File as defined in PDF 32000_2008.pdf pp. 38.</body></comment><class><name>BeginImageData</name><environment>Graphics.PDF</environment><super>Graphics.PDF.InlineImageOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.BeginImageData</class-id><body>Begin the image data for an inline image object</body></comment><class><name>CrossReferenceSection</name><environment>Graphics.PDF</environment><super>Graphics.PDF.FileEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subsections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Files</package></attributes></class><comment><class-id>Graphics.PDF.CrossReferenceSection</class-id><body>A Cross-Reference Section of the cross-reference table as defined in PDF 32000_2008.pdf pp. 40.Each cross-reference section shall begin with a line containing the keyword xref. Following this line shall be one or more cross-reference subsections, which may appear in any order. For a file that has never been incrementally updated, the cross-reference section shall contain only one subsection, whose object numbering begins at 0.</body></comment><class><name>TransparencyGroupAttributes</name><environment>Graphics.PDF</environment><super>Graphics.PDF.GroupAttributes</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF XObjects</package></attributes></class><comment><class-id>Graphics.PDF.TransparencyGroupAttributes</class-id><body>PDF transparency group attributes as defined in PDF 32000_2008.pdf pp. 349.A transparency group is represented in PDF as a special type of group XObject called a transparency group XObject. A group XObject is in turn a type of form XObject, distinguished by the presence of a Group entry in its form dictionary. The value of this entry is a subsidiary group attributes dictionary defining the properties of the group. The format and meaning of the dictionary’s contents shall be determined by its group subtype, which is specified by the dictionary’s S entry.A page object may also have a Group entry, whose value is a group attributes dictionary specifying the attributes of the page group. Some of the dictionary entries are interpreted slightly differently for a page group than for a transparency group XObject; see their descriptions in the table for details.</body></comment><class><name>TypeMismatch</name><environment>Graphics.PDF</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>myObject types </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Complex Objects</package></attributes></class><comment><class-id>Graphics.PDF.TypeMismatch</class-id><body>TypeMismatch is a wrapper around a PDF object with the wrong type</body></comment><class><name>TransparencyGroup</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Group</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF XObjects</package></attributes></class><comment><class-id>Graphics.PDF.TransparencyGroup</class-id><body>PDF Transparency Group XObjects as defined in PDF 32000_2008.pdf, section 11.6.6, pp. 349.A transparency group is represented in PDF as a special type of group XObject called a transparency group XObject. A group XObject is in turn a type of form XObject, distinguished by the presence of a Group entry in its form dictionary. The value of this entry is a subsidiary group attributes dictionary defining the properties of the group. The format and meaning of the dictionary’s contents shall be determined by its group subtype, which is specified by the dictionary’s S entry.</body></comment><class><name>AppendCurveWithoutC1</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathConstructionOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.AppendCurveWithoutC1</class-id><body>Append a cubic Bézier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using the current point and (x2, y2) as the Bézier control points. The new current point shall be (x3, y3)</body></comment><class><name>SetStrokingColor</name><environment>Graphics.PDF</environment><super>Graphics.PDF.ColourOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetStrokingColor</class-id><body>Set the colour to use for stroking operations in a device, CIE-based (other than ICCBased), or Indexed colour space. The number of operands required and their interpretation depends on the current stroking colour space:For DeviceGray, CalGray, and Indexed colour spaces, one operand shall be required (n = 1).For DeviceRGB, CalRGB, and Lab colour spaces, three operands shall be required (n = 3).For DeviceCMYK, four operands shall be required (n = 4).</body></comment><class><name>AppendRectangle</name><environment>Graphics.PDF</environment><super>Graphics.PDF.PathConstructionOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.AppendRectangle</class-id><body>Append a rectangle to the current path as a complete subpath, with lower-left corner (x, y) and dimensions width and height in user space. The operation	x y width height reis equivalent to	x y m	(x + width) y l	(x + width) (y + height) l	x (y + height) l	h</body></comment><class><name>ColourSpace</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Objecttype</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.ColourSpace</class-id><body>PDF Colour Space Families as defined in PDF 32000_2008.pdf, section 8.6.3, pp. 139.Colour spaces are classified into colour space families. Spaces within a family share the same general characteristics; they shall be distinguished by parameter values supplied at the time the space is specified. The families fall into three broad categories:	•	Device colour spaces directly specify colours or shades of gray that the output device shall produce. 		They provide a variety of colour specification methods, including grayscale, RGB (red-green-blue), and CMYK(cyan-magenta-yellow-black), 		corresponding to the colour space families DeviceGray, DeviceRGB, and DeviceCMYK. 		Since each of these families consists of just a single colour space with no parameters, 		they may be referred to as the DeviceGray, DeviceRGB, and DeviceCMYK colour spaces.	•	CIE-based colour spaces shall be based on an international standard for colour specification created 		by the Commission Internationale de l’Éclairage (International Commission on Illumination). 		These spaces specify colours in a way that is independent of the characteristics of any particular output device. 		Colour space families in this category include CalGray, CalRGB, Lab, and ICCBased. 		Individual colour spaces within these families shall be specified by means of dictionaries containing the parameter values needed to define the space.	•	Special colour spaces add features or properties to an underlying colour space. 		They include facilities for patterns, colour mapping, separations, and high-fidelity and multitone colour. 		The corresponding colour space families are Pattern, Indexed, Separation, and DeviceN. 		Individual colour spaces within these families shall be specified by means of additional parameters.</body></comment><class><name>MovieAnnotation</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Annot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Interactive Features</package></attributes></class><comment><class-id>Graphics.PDF.MovieAnnotation</class-id><body>PDF Movie Annotations as defined in PDF 32000_2008.pdf, section 12.5.6.17, pp. 407.A movie annotation contains animated graphics and sound to be presented on the computer screen and through the speakers.When the annotation is activated, the movie shall be played.</body></comment><class><name>SetType3GlyphWidthAndBoundingBox</name><environment>Graphics.PDF</environment><super>Graphics.PDF.Type3FontOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Graphics Operations</package></attributes></class><comment><class-id>Graphics.PDF.SetType3GlyphWidthAndBoundingBox</class-id><body>Set width and bounding box information for the glyph and declare that the glyph description specifies only shape, not colour.NOTE	This operator name ends in the digit 1.wx denotes the horizontal displacement in the glyph coordinate system; it shall be consistent with the corresponding width in the font’s Widths array. wy shall be 0.llx and lly denote the coordinates of the lower-left corner, and urx and ury denote the upper-right corner, of the glyph bounding box. The glyph bounding box is the smallest rectangle, oriented with the axes of the glyph coordinate system, that completely encloses all marks placed on the page as a result of executing the glyph’s description. The declared bounding box shall be correct—in other words, sufficiently large to enclose the entire glyph. If any marks fall outside this bounding box, the result is unpredictable.A glyph description that begins with the d1 operator should not execute any operators that set the colour (or other colour-related parameters) in the graphics state; any use of such operators shall be ignored. The glyph description is executed solely to determine the glyph’s shape. Its colour shall be determined by the graphics state in effect each time this glyph is painted by a text-showing operator. For the same reason, the glyph description shall not include an image; however, an image mask is acceptable, since it merely defines a region of the page to be painted with the current colour.This operator shall be used only in a content stream appearing in a Type 3 font’s CharProcs dictionary</body></comment><class><name>DeviceN</name><environment>Graphics.PDF</environment><super>Graphics.PDF.SpecialColourSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PDF Colour</package></attributes></class><comment><class-id>Graphics.PDF.DeviceN</class-id><body>PDF DeviceN Colour Spaces as defined in PDF 32000_2008.pdf, section 8.6.6.5, pp. 159.DeviceN colour spaces (PDF 1.3) may contain an arbitrary number of colour components.</body></comment><shared-variable><name>TypeClasses</name><environment>Graphics.PDF.Type</environment><private>false</private><constant>false</constant><category>typing</category><attributes><package>PDF Complex Objects</package></attributes></shared-variable><shared-variable><name>ClassesAtNames</name><environment>Graphics.PDF.Operation</environment><private>false</private><constant>false</constant><category>mapping</category><attributes><package>PDF Graphics Operations</package></attributes></shared-variable><methods><class-id>Graphics.PDF.Entity</class-id> <category>writing</category><body package="PDF Basic Objects">asPdfString	"&lt;String&gt;	the PDF source for tests with cr instead of lf"	^self pdfSource replaceAll: Character lf with: Character cr</body><body package="PDF Basic Objects">pdfSource	"&lt;String&gt;	the object as PDF source"	| wst |	wst := Writer on: ByteString new.	self writeOn: wst indent: 0.	^wst contents</body><body package="PDF Basic Objects">writeOn: aStream indent: integer	"write the receiver to the PDF stream"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.Entity</class-id> <category>accessing</category><body package="PDF Basic Objects">content	^self</body><body package="PDF Basic Objects">object	"&lt;PDF.Object&gt;	the direct object"	^self</body><body package="PDF Basic Objects">pdfVersion	"&lt;PDFVersion&gt;	the minimal version for this object with its features"	^Version pdf1_0</body><body package="PDF Basic Objects">unspecifiedAttributes	"&lt;Array of: Association&gt;"	^#()</body></methods><methods><class-id>Graphics.PDF.Entity</class-id> <category>testing</category><body package="PDF Basic Objects">isPDF	^true</body><body package="PDF Basic Objects">isReferencedBy: aCrossReference	^false</body><body package="PDF Basic Objects">isSameReference: anObject	^false</body><body package="PDF Basic Objects">refersTo: aPDFReference	^false</body></methods><methods><class-id>Graphics.PDF.Entity</class-id> <category>printing</category><body package="PDF Basic Objects">printOn: aStream	aStream nextPutAll: self pdfSource</body></methods><methods><class-id>Graphics.PDF.Entity</class-id> <category>typing</category><body package="PDF Complex Objects">errorWrongTypes: someTypes	"&lt;TypeMismatch&gt;"	^TypeMismatch for: self expected: someTypes</body></methods><methods><class-id>Graphics.PDF.Entity class</class-id> <category>accessing</category><body package="PDF Basic Objects">documentationPlace	"&lt;Array of Integer&gt;	place of the documentation in the logical structure of the specification PDF 32000_2008.pdf"	^#()</body></methods><methods><class-id>Graphics.PDF.Filter</class-id> <category>accessing</category><body package="PDF Filter">decoded	"&lt;ByteString&gt;"	^Unsupported raiseSignal: self class name asString, ' is not supported (yet)'</body><body package="PDF Filter">encoded	"&lt;ByteString&gt;"	^Unsupported raiseSignal: self class name asString, ' is not supported (yet)'</body><body package="PDF Filter">external	^external ifNil: [		internal ifNotNil: [external := [self encoded] on: Error do: [:ex | ex return: ex]]]</body><body package="PDF Filter">internal	^internal ifNil: [external ifNotNil: [internal := [self decoded] on: Error do: [:ex | ex return: ex]]]</body></methods><methods><class-id>Graphics.PDF.Filter</class-id> <category>writing</category><body package="PDF Filter">writeOn: aStream indent: integer	self class name asPDF writeOn: aStream indent: integer</body></methods><methods><class-id>Graphics.PDF.Filter</class-id> <category>initialize-release</category><body package="PDF Filter">initializeInternal: internalByteString external: externalByteString from: aDecodeParmsOrNil	"initialize the filter with either internal or external content.	Use the parameters in aDecodeParmsOrNil"	((internalByteString isNil and: [	externalByteString isNil]) or: [		internalByteString notNil and: [		externalByteString notNil]]) ifTrue: [			^Error raiseSignal: 'A filter can only be created with EITHER the internal OR the external bytes'].	internal := internalByteString.	external := externalByteString.	aDecodeParmsOrNil ifNotNil: [self initializeParameters: aDecodeParmsOrNil]</body><body package="PDF Filter">initializeParameters: aDecodeParms	"don't do anything by default.	Subclasses may redefine this"</body></methods><methods><class-id>Graphics.PDF.Filter class</class-id> <category>instance creation</category><body package="PDF Filter">external: externalByteString	^self external: externalByteString with: Core.Dictionary new</body><body package="PDF Filter">external: externalByteString with: aDecodeParms	| inst |	inst := self new.	inst initializeInternal: nil external: externalByteString from: aDecodeParms.	^inst</body><body package="PDF Filter">internal: internalByteString	^self internal: internalByteString with: Core.Dictionary new</body><body package="PDF Filter">internal: internalByteString with: aDecodeParms	| inst |	inst := self new.	inst initializeInternal: internalByteString external: nil from: aDecodeParms.	^inst</body></methods><methods><class-id>Graphics.PDF.Filter class</class-id> <category>accessing</category><body package="PDF Filter">subclassNamed: aSymbol	"&lt;Filter class&gt;"	^self allSubclasses detect: [:subclass | subclass name = aSymbol]</body></methods><methods><class-id>Graphics.PDF.ASCII85Decode</class-id> <category>filtering</category><body package="PDF Filter">decodeGroup: inputString	"&lt;ByteString[4]&gt;"	| encodedString number wst |	inputString = 'z' ifTrue: [		^ByteString new: 4 withAll: 0 asCharacter].	inputString size = 1 ifTrue: [		^ReadError raiseSignal: 'Decoding error in ASCII85 encoded string'].	encodedString := inputString.	inputString size &lt; 5 ifTrue: [		encodedString := encodedString , (ByteString new: 5 - inputString size withAll: $u)].	number := encodedString inject: 0 into: [:num :char |		| int |		int := char asInteger.		(int between: 33 and: 117) ifFalse: [			^ReadError raiseSignal: 'Illegal character in ASCII85 encoded string'].		num * 85 + (int - 33)].	(number &gt; 16rFFFFFFFF and: [	inputString size = 5]) ifTrue: [			^ReadError raiseSignal: 'Decoding error in ASCII85 encoded string'].	wst := (ByteString new: 4) writeStream.	4 timesRepeat: [		wst nextPut: (number rem: 256) asCharacter.		number := number quo: 256].	^wst contents reverse first: inputString size - 1</body><body package="PDF Filter">decoded	| wst rst |	self external isSignalledException ifTrue: [		^self external].	wst := (ByteString new: (self external size * 4 / 5) ceiling) writeStream.	rst := self external readStream.	[rst atEnd] whileFalse: [		| input |		input := self nextEncodedGroupFrom: rst.		wst nextPutAll: (self decodeGroup: input)].	^wst contents</body><body package="PDF Filter">encodeGroup: fourByteString	"&lt;ByteString[5]&gt;"	| number wst |	number := fourByteString inject: 0 into: [:num :char | num * 256 + char asInteger].	number isZero ifTrue: [		^'z'].	wst := (ByteString new: 5) writeStream.	5 timesRepeat: [		wst nextPut: ((number rem: 85) + 33) asCharacter.		number := number quo: 85].	^wst contents reverse</body><body package="PDF Filter">encoded	| wst rem last rst |	self internal isSignalledException ifTrue: [		^self internal].	wst := (ByteString new: (self internal size * 5 / 4) ceiling + 2) writeStream.	rem := self internal size rem: 4.	last := rem isZero		ifTrue: [ByteString new]		ifFalse: [self internal last: rem].	rst := (self internal allButLast: rem) readStream.	[rst atEnd] whileFalse: [wst nextPutAll: (self encodeGroup: (rst next: 4))].	last isEmpty ifFalse: [		| input output |		input := last , (ByteString new: 4 - last size withAll: 0 asCharacter).		output := self encodeGroup: input.		output = 'z' ifTrue: [			output := '!!!!!'].		wst nextPutAll: (output first: last size + 1)].	wst		nextPut: 16r7E asCharacter;		nextPut: 16r3E asCharacter.	^wst contents</body><body package="PDF Filter">nextEncodedGroupFrom: aReadStream	"&lt;String&gt;"	| wst |	[aReadStream peek isPdfWhitespace] whileTrue: [aReadStream next].	aReadStream peek == $z ifTrue: [		^ByteString with: aReadStream next].	wst := (ByteString new: 5) writeStream.	[	aReadStream atEnd not and: [	wst position &lt; 5]] whileTrue: [			| char |			char := aReadStream next.			(char = 16r7E asCharacter and: [			aReadStream peek = 16r3E asCharacter]) ifTrue: [					aReadStream setToEnd.					^wst contents].			char isPdfWhitespace ifFalse: [				wst nextPut: char]].	^wst contents</body></methods><methods><class-id>Graphics.PDF.PDFObject</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	"&lt;PDF.Object&gt;"	^self</body><body package="PDF Complex Objects">asType: aType	"&lt;PDFObject | nil&gt;	an instance of aType if the receiver can be specialized"	^self subclassResponsibility</body><body package="PDF Basic Objects">newReference	"&lt;Reference on: PDFObject&gt;"	^Reference referent: self</body></methods><methods><class-id>Graphics.PDF.PDFObject</class-id> <category>accessing</category><body package="PDF Basic Objects">content	"&lt;Core.Object&gt;	the Smalltalk object for the value I represent"	^content</body><body package="PDF Complex Objects">objectAt: aSymbolOrInteger	"&lt;PDF.Object&gt;	returns the object stored in a slot or the value of a Reference"	^(self at: aSymbolOrInteger) object</body><body package="PDF Complex Objects">pdfType	^self class</body></methods><methods><class-id>Graphics.PDF.PDFObject</class-id> <category>tracing</category><body package="PDF Basic Objects">tracedReferences	"&lt;SequenceableCollection of: Reference&gt;"	| list |	list := OrderedCollection new.	self tracedReferences: list do: [:ref | ].	^list</body><body package="PDF Basic Objects">tracedReferences: visitedReferences do: oneArgumentBlock	"executes oneArgumentBlock with a new unique reference"	"direct object. No references here"</body></methods><methods><class-id>Graphics.PDF.PDFObject</class-id> <category>comparing</category><body package="PDF Basic Objects">= anObject	^self class == anObject class and: [	self content = anObject content]</body><body package="PDF Basic Objects">hash	^self content hash</body></methods><methods><class-id>Graphics.PDF.PDFObject</class-id> <category>testing</category><body package="PDF Complex Objects">hasKey: aSymbolOrInteger	"&lt;Boolean&gt;	true, if the receiver has aSymbolOrInteger as accessor for #at:"	^self subclassResponsibility</body><body package="PDF Complex Objects">hasRequiredAttributes	"&lt;Boolean&gt;"	^self subclassResponsibility</body><body package="PDF Basic Objects">isArray	^false</body><body package="PDF Basic Objects">isDirect	^true</body><body package="PDF Complex Objects">isEmpty	^self content isEmpty</body><body package="PDF Basic Objects">isName	^false</body><body package="PDF Basic Objects">isNull	^false</body><body package="PDF Basic Objects">isOperator	^false</body><body package="PDF Complex Objects">isType: aType	"&lt;Boolean&gt;	true, if the receiver is compatible with aType"	^self subclassResponsibility</body><body package="PDF Complex Objects">notEmpty	^self isEmpty not</body></methods><methods><class-id>Graphics.PDF.PDFObject</class-id> <category>initialize-release</category><body package="PDF Basic Objects">initializeContent: aSmalltalkObject	content := aSmalltalkObject</body></methods><methods><class-id>Graphics.PDF.PDFObject</class-id> <category>copying</category><body package="PDF Basic Objects">copy	^self class on: self content</body></methods><methods><class-id>Graphics.PDF.PDFObject</class-id> <category>accessing attributes</category><body package="PDF Complex Objects">attributeCanInherit: anAttributePragma	anAttributePragma method attributeAt: #inheritable ifAbsent: [		^false].	^true</body><body package="PDF Complex Objects">attributeDocumentation: aMethod	| attributes |	attributes := aMethod attributeMessages select: [:attribute |		attribute selector = #attribute:documentation:].	attributes isEmpty ifTrue: [		^ByteString new].	^attributes first arguments last</body><body package="PDF Complex Objects">attributeHighestConditionalVersion: anAttributePragma	"&lt;Integer&gt;	minor pdf version"	| attrValue attributes |	attributes := anAttributePragma method attributeMessages select: [:attribute |		attribute selector = #version:ifValue:].	attributes isEmpty ifTrue: [		^0].	attrValue := (self perform: anAttributePragma selector) content.	^attributes inject: 0 into: [:maxMinor :attributeMessage |		attributeMessage arguments last = attrValue			ifTrue: [			maxMinor max: attributeMessage arguments first]			ifFalse: [			maxMinor]]</body><body package="PDF Complex Objects">attributeIsRequired: anAttributePragma	^(self attributeIsRequiredIf: anAttributePragma) or: [	self attributeIsUnconditionallyRequired: anAttributePragma]</body><body package="PDF Complex Objects">attributeIsRequiredIf: anAttributePragma	"&lt;Boolean&gt;	true if the attribute argument is present"	| atributes |	atributes := anAttributePragma method attributeMessages select: [:attribute |		attribute selector = #requiredIf:].	^atributes anySatisfy: [:attribute | self hasKey: attribute arguments first]</body><body package="PDF Complex Objects">attributeIsUnconditionallyRequired: anAttributePragma	anAttributePragma method attributeAt: #required ifAbsent: [		^false].	^true</body><body package="PDF Complex Objects">attributeVersion: anAttributePragma	| minor |	minor := self attributeHighestConditionalVersion: anAttributePragma.	minor := minor max: (anAttributePragma method attributeAt: #version ifAbsent: [0]).	minor := minor max: self class version.	^Version major: 1 minor: minor</body><body package="PDF Complex Objects">attributesRequired	"&lt;Collection of: Pragma&gt;"	^self sortedAttributePragmas select: [:pragma | self attributeIsRequired: pragma]</body><body package="PDF Complex Objects">sortedAttributePragmas	"&lt;SequenceableCollection of: Pragma&gt;"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.PDFObject</class-id> <category>typing</category><body package="PDF Complex Objects">typed: listOfTypes	"&lt;PDFObject&gt;	if the receiver can be of any of the listOfTypes, a specialized copy is returned,	otherwise the receiver is returned unchanged"	(listOfTypes anySatisfy: #isIndirect) ifTrue: [		^self errorWrongTypes: listOfTypes].	(listOfTypes isEmpty or: [	listOfTypes anySatisfy: [:type | self isType: type]]) ifTrue: [			^self].	listOfTypes do: [:type |		(self asType: type) ifNotNil: [:specialized |			^specialized]].	^self errorWrongTypes: listOfTypes</body><body package="PDF Complex Objects">typesAt: anAttributeSymbol	"&lt;Array of: Type&gt;	the declared types"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.PDFObject class</class-id> <category>instance creation</category><body package="PDF Complex Objects">classFor: anArrayOrDictionary	^(self subclassFor: anArrayOrDictionary) ifNil: [self]</body><body package="PDF Basic Objects">content: anObject	"&lt;PDF.Object&gt;	A new PDF object on anObject"	| inst |	inst := self new.	inst initializeContent: anObject.	^inst</body><body package="PDF Complex Objects">isTypeFor: anObject	"&lt;Boolean&gt;"	^false</body><body package="PDF Basic Objects">on: anObject	"&lt;PDF.Object&gt;	A new PDF object on anObject"	^self content: anObject</body><body package="PDF Complex Objects">subclassFor: anArrayOrDictionary	"&lt;Dictionary class | nil&gt;"	self subclasses do: [:subclass |		(subclass subclassFor: anArrayOrDictionary) ifNotNil: [:sc |			^sc]].	^(self isTypeFor: anArrayOrDictionary)		ifTrue: [self]		ifFalse: [nil]</body></methods><methods><class-id>Graphics.PDF.PDFObject class</class-id> <category>accessing</category><body package="PDF Complex Objects">pragmasForDocumentation	^#(#attribute:documentation:)</body><body package="PDF Complex Objects">pragmasForRequired	^#(#required #requiredIf: #inheritable)</body><body package="PDF Complex Objects">pragmasForType	^Type pragmaKeywords asArray</body><body package="PDF Complex Objects">pragmasForVersion	^#(#version: #version:ifValue:)</body><body package="PDF Complex Objects">specialized: aPDFObject	"&lt;PDFObject | nil&gt;"	(self inheritsFrom: aPDFObject class) ifTrue: [		^self on: aPDFObject content].	^nil</body><body package="PDF Basic Objects">version	"&lt;Integer&gt;	PDF minor version"	^0</body></methods><methods><class-id>Graphics.PDF.PDFObject class</class-id> <category>testing</category><body package="PDF Complex Objects">isSuperTypeOf: aPDFObject	^(aPDFObject isKindOf: self) or: [	self == PDFObject and: [	PDFValue isSuperTypeOf: aPDFObject]]</body></methods><methods><class-id>Graphics.PDF.Dictionary</class-id> <category>testing</category><body package="PDF Complex Objects">hasKey: aSymbol	^self keys asSet includes: aSymbol</body><body package="PDF Complex Objects">hasRequiredAttributes	| keys |	keys := self keys asSet.	^self attributesRequired allSatisfy: [:pragma | keys includes: pragma selector]</body><body package="PDF Complex Objects">isType: aType	^aType subsumesDictionary: self</body></methods><methods><class-id>Graphics.PDF.Dictionary</class-id> <category>accessing</category><body package="PDF Complex Objects">at: aSymbol	"&lt;PDFObject&gt;	returns the object stored in a slot (PDF.Object or Reference).	A value of null is treated as non existant entry"	^self content at: aSymbol</body><body package="PDF Complex Objects">at: aSymbol ifAbsent: aBlock	"&lt;PDF.Object&gt;	it is not possible to return a null, since null erases the entry"	^self content at: aSymbol ifAbsent: aBlock</body><body package="PDF Complex Objects">at: aSymbol ifAbsentPut: valueBlock	"&lt;PDFObject&gt;	Answer the value at aSymbol.  If aSymbol is not found, create a new	entry for aSymbol, set its value to be the result of evaluating	valueBlock, and answer that value."	^self at: aSymbol ifAbsent: [self at: aSymbol put: valueBlock value]</body><body package="PDF Complex Objects">at: aSymbol put: anObject	"&lt;PDFObject&gt;	A null removes any existant entry at aSymbol.	anObject is added as its most specific version"	| pdf |	aSymbol isSymbol ifFalse: [		^Error raiseSignal: 'PDF dictionaries use only symbols as keys'].	pdf := anObject asPDF.	pdf isNull ifTrue: [		self content removeKey: aSymbol ifAbsent: [nil].		^pdf].	^self content at: aSymbol put: (pdf typed: (self typesAt: aSymbol))</body><body package="PDF Complex Objects">classesForAttributes	"&lt;SequenceableCollection of: Dictionary class&gt;	all super classes which may have attributes from the top to self"	^(self class allSuperclasses allButLast: self topClassLevel) reverse , (Array with: self class)</body><body package="PDF Complex Objects">content	^content ifNil: [content := OrderedDictionary new]</body><body package="PDF Complex Objects">contentWithoutCycles	"&lt;OrderedDictionary&gt;	a copy of content with entries removed which create a circular structure"	^self content copy</body><body package="PDF Complex Objects">keys	"&lt;Array of: Symbol&gt;"	^self content keys</body><body package="PDF Complex Objects">objectAt: aSymbol ifAbsent: aBlock	"&lt;PDF.Object&gt;	returns the object stored in a slot or the value of a Reference"	| pdf |	pdf := self content at: aSymbol ifAbsent: [		^aBlock value].	^pdf object</body><body package="PDF Complex Objects">pdfVersion	"&lt;PDF.Version&gt;	the highest version of the class and its attributes.	Does not follow the objects contained as values of attributes."	| minor |	minor := self attributesPresent inject: self class version into: [:max :pragma |		| conditional maxCond attributes |		attributes := pragma method attributeMessages select: [:attribute |			attribute selector = #version:ifValue:].		conditional := attributes isEmpty			ifTrue: [#()]			ifFalse: [attributes].		maxCond := conditional inject: max into: [:max1 :pragma1 |			pragma1 arguments last = (self perform: pragma selector) content				ifTrue: [				max1 max: pragma1 arguments first]				ifFalse: [				max1]].		max max: ((pragma method attributeAt: #version ifAbsent: [0]) max: maxCond)].	^Version major: 1 minor: minor</body><body package="PDF Complex Objects">size	"&lt;Integer&gt;"	^self content size</body><body package="PDF Complex Objects">topClassLevel	"&lt;Integer&gt;	the level of the receiver's topmost relevant superclass in the class hierarchy"	^3</body><body package="PDF Complex Objects">tracedVersion	"&lt;PDF.Version&gt;	the highest version of the receiver and all transitively referenced objects"	| lowestMinor |	lowestMinor := self pdfVersion minor.	self tracedReferences: OrderedCollection new do: [:reference |		lowestMinor := lowestMinor max: reference referent pdfVersion minor].	^Version major: 1 minor: lowestMinor</body><body package="PDF Complex Objects">values	"&lt;Array of: PDF.Object&gt;"	^self content values</body></methods><methods><class-id>Graphics.PDF.Dictionary</class-id> <category>converting</category><body package="PDF Complex Objects">asSmalltalkValue	| dict |	dict := OrderedDictionary new.	self content keysAndValuesDo: [:key :aValue | dict at: key put: aValue asSmalltalkValue].	^dict</body><body package="PDF Complex Objects">asType: aType	^aType specializedDictionary: self</body></methods><methods><class-id>Graphics.PDF.Dictionary</class-id> <category>enumerating</category><body package="PDF Complex Objects">keysAndValuesDo: aBlockClosure	self content keysAndValuesDo: aBlockClosure</body></methods><methods><class-id>Graphics.PDF.Dictionary</class-id> <category>tracing</category><body package="PDF Complex Objects">tracedReferences: visitedReferences do: oneArgumentBlock	self values do: [:pdfObject | pdfObject tracedReferences: visitedReferences do: oneArgumentBlock]</body></methods><methods><class-id>Graphics.PDF.Dictionary</class-id> <category>initialize-release</category><body package="PDF Complex Objects">initializeContent: aDictionary	"we need to use the official #at:put: to convert all non-PDF objects to PDFs"	content := OrderedDictionary new: aDictionary size.	aDictionary associations do: [:assoc | self at: assoc key put: assoc value]</body></methods><methods><class-id>Graphics.PDF.Dictionary</class-id> <category>accessing attributes</category><body package="PDF Complex Objects">attributeHasValue: anAttributePragma	"&lt;Boolean&gt;"	^self keys includes: anAttributePragma selector</body><body package="PDF Complex Objects">attributesPresent	"&lt;Collection of: Pragma&gt;"	| keys |	keys := self keys asSet.	^self sortedAttributePragmas select: [:pragma | keys includes: pragma selector]</body><body package="PDF Complex Objects">sort: aAttributePragma before: bAttributePragma	"&lt;Boolean&gt;"	| aClass bClass aRequired bRequired aValue bValue aVersion bVersion |	aRequired := self attributeIsRequired: aAttributePragma.	bRequired := self attributeIsRequired: bAttributePragma.	(aRequired and: [	bRequired not]) ifTrue: [			^true].	(aRequired not and: [	bRequired]) ifTrue: [			^false].	aValue := self attributeHasValue: aAttributePragma.	bValue := self attributeHasValue: bAttributePragma.	(aValue and: [	bValue not]) ifTrue: [			^true].	(aValue not and: [	bValue]) ifTrue: [			^false].	aClass := aAttributePragma methodClass.	bClass := bAttributePragma methodClass.	(aClass inheritsFrom: bClass) ifTrue: [		^false].	(bClass inheritsFrom: aClass) ifTrue: [		^true].	"same class"	aVersion := self attributeVersion: aAttributePragma.	bVersion := self attributeVersion: bAttributePragma.	aVersion = bVersion ifTrue: [		^aAttributePragma arguments first &lt; bAttributePragma arguments first].	^aVersion &lt; bVersion</body><body package="PDF Complex Objects">sortedAttributePragmas	"If there are attributes with the same selector, the most specific is returned.	The order is from the specific class up the hierarchy"	| dict |	dict := OrderedDictionary new.	self classesForAttributes do: [:class |		(Pragma allNamed: #attribute:documentation: in: class sortedByArgument: 1) do: [:pragma |			dict at: pragma selector put: pragma]].	^dict values asArray</body><body package="PDF Complex Objects">unspecifiedAttributes	"&lt;Association key: Symbol value: PDF.Object&gt;"	| keys |	keys := self keys asOrderedCollection.	self sortedAttributePragmas do: [:pragma | keys remove: pragma selector ifAbsent: []].	^keys collect: [:key | key -&gt; (self at: key)]</body></methods><methods><class-id>Graphics.PDF.Dictionary</class-id> <category>typing</category><body package="PDF Complex Objects">typed: listOfTypes	"&lt;PDF.Dictionary&gt;	a copy of the receiver with the values specialized according to the listOfTypes"	| types |	types := listOfTypes select: [:type | type isForDictionary].	types isEmpty ifTrue: [		^super typed: listOfTypes].	types size &gt; 1 ifTrue: [		Error raiseSignal: 'Only one #typeDictionaryOf: or #typeNameTreeOf: pragma is allowed'.		^super typed: listOfTypes].	^types first typedDictionary: self</body><body package="PDF Complex Objects">typesAt: anAttributeSymbol	| classAndMethod pragmas keywords typePragmas |	classAndMethod := (self class findSelector: anAttributeSymbol) ifNil: [		^#()].	pragmas := Pragma allInMethod: classAndMethod last.	keywords := Type pragmaKeywords.	typePragmas := pragmas select: [:pragma | keywords includes: pragma keyword].	^typePragmas collect: [:pragma |		| typeSymbol |		typeSymbol := pragma arguments first.		(PDF objecttypeAt: typeSymbol)			ifNotNil: [:class |			(Type typeClassAt: pragma keyword) on: class]			ifNil: [			UndefinedType on: typeSymbol]]</body></methods><methods><class-id>Graphics.PDF.Dictionary</class-id> <category>writing</category><body package="PDF Complex Objects">writeOn: aStream indent: integer	aStream nextPutAll: '&lt;&lt;'.	(integer &gt; 0 and: [	self size &gt; 1]) ifTrue: [			aStream cr].	self content associations		do: [:assoc |		integer + 1 timesRepeat: [aStream tab].		aStream			nextPutAll: assoc key asPDF pdfSource;			space.		assoc value writeOn: aStream indent: integer + 1]		separatedBy: [		aStream cr].	aStream		tab;		nextPutAll: '&gt;&gt;'</body></methods><methods><class-id>Graphics.PDF.Dictionary class</class-id> <category>instance creation</category><body package="PDF Complex Objects">empty	^self new</body><body package="PDF Complex Objects">isTypeFor: anOrderedDictionary	"&lt;Boolean&gt;"	| typeEntry |	typeEntry := anOrderedDictionary at: #Type ifAbsent: [		^false].	^self type asPDF = typeEntry asPDF</body><body package="PDF Complex Objects">on: aDictionary	"&lt;PDF.Dictionary&gt;"	^(self classFor: aDictionary) content: aDictionary</body><body package="PDF Complex Objects">with: aPDFObject	^self on: (OrderedDictionary with: aPDFObject)</body><body package="PDF Complex Objects">with: firstPDFObject with: secondPDFObject	^self on: (OrderedDictionary		with: firstPDFObject		with: secondPDFObject)</body><body package="PDF Complex Objects">with: firstPDFObject with: secondPDFObject with: thirdPDFObject	^self on: (OrderedDictionary		with: firstPDFObject		with: secondPDFObject		with: thirdPDFObject)</body><body package="PDF Complex Objects">with: firstPDFObject with: secondPDFObject with: thirdPDFObject with: fourthPDFObject	^self on: (OrderedDictionary		with: firstPDFObject		with: secondPDFObject		with: thirdPDFObject		with: fourthPDFObject)</body></methods><methods><class-id>Graphics.PDF.Dictionary class</class-id> <category>accessing</category><body package="PDF Complex Objects">documentationPlace	^#(7 3 7)</body><body package="PDF Complex Objects">type	"&lt;Symbol&gt;	type entry"	^self name</body></methods><methods><class-id>Graphics.PDF.Dictionary class</class-id> <category>reading</category><body package="PDF Files">readWith: aFile from: aParser	"&lt;PDF.Dictionary&gt;"	^self on: (aParser readOrderedDictionaryWith: aFile)</body></methods><methods><class-id>Graphics.PDF.TypedDictionary</class-id> <category>accessing</category><body package="PDF Complex Objects">attributesRequired	^self sortedAttributePragmas select: [:pragma |		pragma selector == #Type or: [		self attributeIsRequired: pragma]]</body><body package="PDF Complex Objects">topClassLevel	^4</body></methods><methods><class-id>Graphics.PDF.TypedDictionary class</class-id> <category>instance creation</category><body package="PDF Complex Objects">empty	| inst |	inst := super empty.	inst at: #Type put: self type.	^inst</body></methods><methods><class-id>Graphics.PDF.Annot class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 2)</body><body package="PDF Interactive Features">subtype	"&lt;Symbol&gt;	subtype entry"	^Symbol new</body><body package="PDF Interactive Features">type	^#Annot</body></methods><methods><class-id>Graphics.PDF.Annot class</class-id> <category>instance creation</category><body package="PDF Interactive Features">empty	| inst |	inst := super empty.	inst at: #Subtype put: self subtype.	^inst</body><body package="PDF Interactive Features">isTypeFor: anOrderedDictionary	| subtypeEntry |	self == Annot ifTrue: [		^super isTypeFor: anOrderedDictionary].	subtypeEntry := anOrderedDictionary at: #Subtype ifAbsent: [		^false].	^self subtype asPDF = subtypeEntry asPDF</body></methods><methods><class-id>Graphics.PDF.Markup</class-id> <category>accessing</category><body package="PDF Interactive Features">listText	| text |	text := self subtypeText.	(self hasKey: #Subj) ifTrue: [		text := text , ' (' asText , self Subj asSmalltalkValue asText , ')' asText].	(self hasKey: #Contents) ifTrue: [		text := text , ': ' asText , self Contents asSmalltalkValue asText allBold].	^text</body></methods><methods><class-id>Graphics.PDF.Markup class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 2)</body></methods><methods><class-id>Graphics.PDF.RedactAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 23)</body><body package="PDF Interactive Features">subtype	^#Redact</body><body package="PDF Interactive Features">version	^7</body></methods><methods><class-id>Graphics.PDF.Type</class-id> <category>testing</category><body package="PDF Complex Objects">appliesToReference	"is the type applicable to references?"	^true</body><body package="PDF Complex Objects">isDirect	^false</body><body package="PDF Complex Objects">isForArray	^false</body><body package="PDF Complex Objects">isForDictionary	^false</body><body package="PDF Complex Objects">isIndirect	^false</body><body package="PDF Complex Objects">subsumesArray: aPDFArray	"&lt;Boolean&gt;	true, if the argument is compatible with the receiver"	^false</body><body package="PDF Complex Objects">subsumesDictionary: aPDFDictionary	"&lt;Boolean&gt;	true, if the argument is compatible with the receiver"	^false</body><body package="PDF Complex Objects">subsumesObject: aPDFObject	"&lt;Boolean&gt;	true, if the argument is compatible with the receiver"	^false</body><body package="PDF Complex Objects">subsumesReference: aPDFReference	"&lt;Boolean&gt;	true, if the argument is compatible with the receiver"	^false</body></methods><methods><class-id>Graphics.PDF.Type</class-id> <category>accessing</category><body package="PDF Complex Objects">name	"&lt;String&gt;"	^self subclassResponsibility</body><body package="PDF Complex Objects">pdfType	"&lt;Objecttype class | PDF.Object class | PdfValue class&gt;	the subject class of this type"	^pdfType</body><body package="PDF Complex Objects">specializedArray: aPDFArray	"&lt;PDFObject | nil&gt;	instance of #pdfClass with the content of aPDFArray	or nil, if #pdfClass is no subclass of aPDFArray class"	^self specializedObject: aPDFArray</body><body package="PDF Complex Objects">specializedDictionary: aPDFDictionary	"&lt;PDFObject | nil&gt;	instance of #pdfClass with the content of aPDFDictionary	or nil, if #pdfClass is no subclass of aPDFDictionary class"	^self specializedObject: aPDFDictionary</body><body package="PDF Complex Objects">specializedObject: aPDFObject	"&lt;PDFObject | nil&gt;	instance of #pdfClass with the content of aPDFObject	or nil, if #pdfClass is no subclass of aPDFObject class"	^nil</body><body package="PDF Complex Objects">specializedReference: aReference	"&lt;Reference | nil&gt;"	^nil</body></methods><methods><class-id>Graphics.PDF.Type</class-id> <category>printing</category><body package="PDF Complex Objects">printOn: stream	stream nextPutAll: self class name asString, ' on: ', self pdfType name asString</body></methods><methods><class-id>Graphics.PDF.Type</class-id> <category>initialize-release</category><body package="PDF Complex Objects">initializePdfType: aPDFClass	pdfType := aPDFClass</body></methods><methods><class-id>Graphics.PDF.Type</class-id> <category>converting</category><body package="PDF Complex Objects">asClassType	"&lt;Type&gt;	derived type suitable for direct and indirect values"	^ClassType on: self pdfType</body><body package="PDF Complex Objects">asDirectType	"&lt;Type&gt;	derived type suitable for the value of a reference"	^self</body><body package="PDF Complex Objects">asIndirectType	"&lt;Type&gt;	derived type suitable for the value of a reference"	^IndirectType on: self pdfType</body></methods><methods><class-id>Graphics.PDF.Type class</class-id> <category>dynamic references</category><body package="PDF Complex Objects">dynamicallyReferencedClasses	^Type allSubclasses collect: [:cl | cl fullName asSymbol]</body></methods><methods><class-id>Graphics.PDF.Type class</class-id> <category>instance creation</category><body package="PDF Complex Objects">on: aPDFClass	^self pdfType: aPDFClass</body><body package="PDF Complex Objects">pdfType: aPDFClass	| inst |	inst := self new.	inst initializePdfType: aPDFClass.	^inst</body></methods><methods><class-id>Graphics.PDF.Type class</class-id> <category>accessing</category><body package="PDF Complex Objects">pragmaKeywords	"&lt;Set of: Symbol&gt;"	^self typeClassesAtKey keys</body><body package="PDF Complex Objects">typeClassAt: aPragmaKeywod	"the Type class corresponding to the pragma keyword"	^self typeClassesAtKey at: aPragmaKeywod ifAbsent: [UndefinedType]</body><body package="PDF Complex Objects">typeClassesAtKey	"the key is the pragma keyword used in attributes. The value is the specific Type class"	^TypeClasses ifNil: [		| dict |		dict := IdentityDictionary new.		dict at: #type: put: ClassType.		dict at: #typeArrayOf: put: ArrayType.		dict at: #typeDictionaryOf: put: DictionaryType.		dict at: #typeNameTreeOf: put: NameTreeType.		dict at: #typeIndirect: put: IndirectType.		dict at: #typeDirect: put: DirectType.		TypeClasses := dict]</body></methods><methods><class-id>Graphics.PDF.DictionaryType</class-id> <category>testing</category><body package="PDF Complex Objects">isForDictionary	^true</body><body package="PDF Complex Objects">subsumesDictionary: aPDFDictionary	"elements can be direct or indirect"	| elementType |	elementType := self asClassType.	^aPDFDictionary values allSatisfy: [:element | element isType: elementType]</body><body package="PDF Complex Objects">subsumesReference: aPDFReference	^aPDFReference referent isType: self</body></methods><methods><class-id>Graphics.PDF.DictionaryType</class-id> <category>accessing</category><body package="PDF Complex Objects">name	^'&lt;&lt;' , self pdfType name asString , '&gt;&gt;'</body><body package="PDF Complex Objects">specializedDictionary: aPDFDictionary	| elementType dict |	elementType := self asClassType.	dict := Dictionary new.	aPDFDictionary keys do: [:key |		dict			at: key			put: (((aPDFDictionary at: key) asType: elementType) ifNil: [				^nil])].	^dict</body><body package="PDF Complex Objects">typedDictionary: aPDFDictionary	"&lt;PDF.Dictionary&gt;	a copy of aPDFDictionary with the values specialized according to the pdfType"	| contentCopy |	contentCopy := OrderedDictionary new: aPDFDictionary size.	aPDFDictionary content keysAndValuesDo: [:key :value |		contentCopy at: key put: (value typed: (Array with: self asClassType))].	^aPDFDictionary class on: contentCopy</body></methods><methods><class-id>Graphics.PDF.ShadingDictionary class</class-id> <category>accessing</category><body package="PDF Shading">isTypeFor: anOrderedDictionary	| typeEntry |	typeEntry := anOrderedDictionary at: #ShadingType ifAbsent: [		^false].	^self shadingType asPDF = typeEntry asPDF</body><body package="PDF Shading">resourcePrefix	^'Sh'</body><body package="PDF Shading">resourceType	"&lt;Symbol&gt;	the name of a /Resources key"	^#Shading</body><body package="PDF Shading">shadingType	"&lt;Integer&gt;	-1 never matches"	^-1</body><body package="PDF Shading">version	^3</body></methods><methods><class-id>Graphics.PDF.ShadingDictionary class</class-id> <category>instance creation</category><body package="PDF Shading">empty	| inst |	inst := self new.	inst at: #ShadingType put: self shadingType.	^inst</body></methods><methods><class-id>Graphics.PDF.AxialShading class</class-id> <category>accessing</category><body package="PDF Shading">shadingType	^2</body></methods><methods><class-id>Graphics.PDF.Operation</class-id> <category>accessing</category><body package="PDF Graphics Operations">operands	"&lt;SequenceableCollection of: PDF.Object&gt;"	^operands ifNil: [#()]</body><body package="PDF Graphics Operations">operatorName	"&lt;Symbol&gt;"	^self class operatorName</body><body package="PDF Graphics Operations">pdfVersion	^self class pdfVersion</body><body package="PDF Graphics Operations">resource	^nil</body><body package="PDF Graphics Operations">resourceIn: aPageGraphics	"&lt;PDFObject | nil&gt;	the resolved resource from the page resourcse"		^nil</body><body package="PDF Graphics Operations">typeAttributesText	| wst |	wst := TextStream on: ByteString new.	self class operandTypes do: 			[:nameType |			wst				nextPutAllText: nameType first asText allBold;				nextPutAll: ': ';				nextPutAll: nameType last printString;				space].	wst nextPutAllText: self operatorName asString asText allBold.	^wst contents</body></methods><methods><class-id>Graphics.PDF.Operation</class-id> <category>copying</category><body package="PDF Graphics Operations">operands: someOperands	^self class operands: someOperands</body><body package="PDF Graphics Operations">with: operand1	^self operands: (Array with: operand1)</body><body package="PDF Graphics Operations">with: operand1 with: operand2	^self operands: (Array		with: operand1		with: operand2)</body><body package="PDF Graphics Operations">with: operand1 with: operand2 with: operand3	^self operands: (Array		with: operand1		with: operand2		with: operand3)</body><body package="PDF Graphics Operations">with: operand1 with: operand2 with: operand3 with: operand4	^self operands: (Array		with: operand1		with: operand2		with: operand3		with: operand4)</body></methods><methods><class-id>Graphics.PDF.Operation</class-id> <category>writing</category><body package="PDF Graphics Operations">pdfSource	"&lt;String&gt;	the object as PDF source"	| wst |	wst := Writer on: ByteString new.	self writeOn: wst indent: 0.	^wst contents</body><body package="PDF Graphics Operations">writeOn: aStream indent: integer	self operands do: [:operand |		operand writeOn: aStream indent: integer.		aStream space].	aStream nextPutAll: self operatorName</body></methods><methods><class-id>Graphics.PDF.Operation</class-id> <category>printing</category><body package="PDF Graphics Operations">printOn: aWriteStream	self operands do: [:operand |		aWriteStream			nextPutAll: operand printString;			space].	aWriteStream nextPutAll: self operatorName</body><body package="PDF Graphics Operations">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'operands' value: self operands).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.PDF.Operation</class-id> <category>initialize-release</category><body package="PDF Graphics Operations">initializeOperands: operandsArray	(operandsArray notNil and: [operandsArray notEmpty])		ifTrue: [operands := (Array withAll: operandsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>Graphics.PDF.Operation</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	"modify aPageGraphics (graphics state, graphics state stack, etc.).	indexInteger is the position of the receiver in the operations"	aPageGraphics addObject: (self newOperationObjectFor: aPageGraphics)</body><body package="PDF Graphics Operations">newOperationObjectFor: aPageGraphics	^OperationObject		operations: (Array with: self)		state: aPageGraphics graphicsState copy		resource: (self resourceIn: aPageGraphics)</body></methods><methods><class-id>Graphics.PDF.Operation</class-id> <category>comparing</category><body package="PDF Graphics Operations">= anObject	^self class == anObject class and: [	self operands = anObject operands]</body><body package="PDF Graphics Operations">hash	^self operands hash</body></methods><methods><class-id>Graphics.PDF.Operation</class-id> <category>testing</category><body package="PDF Graphics Operations">isOperator	^true</body></methods><methods><class-id>Graphics.PDF.Operation class</class-id> <category>accessing</category><body package="PDF Graphics Operations">classesAtNames	"&lt;Dictionary key: Symbol value: Operator class&gt;"	^ClassesAtNames ifNil: [		| dict |		dict := Core.Dictionary new.		Operation allSubclassesDo: [:subclass |			subclass subclasses isEmpty ifTrue: [				dict at: subclass operatorName put: subclass]].		ClassesAtNames := dict]</body><body package="PDF Graphics Operations">documentation	"&lt;String&gt;"	^self subclassResponsibility</body><body package="PDF Graphics Operations">end	"&lt;Operator class | nil&gt;	the corresponding end operator"	^nil</body><body package="PDF Graphics Operations">named: aSymbol	"&lt;Operator class | nil&gt;"	^self classesAtNames at: aSymbol ifAbsent: nil</body><body package="PDF Graphics Operations">on: aSymbol	"&lt;Operator&gt;"	(Operation named: aSymbol) ifNotNil: [:class |		^class empty].	self error: 'unknown operator'</body><body package="PDF Graphics Operations">operandTypes	"&lt;Array of: (Array with: String with: Symbol)&gt;	The names and types of the operands"	^#()</body><body package="PDF Graphics Operations">operatorName	"&lt;Symbol&gt;	Equals to the printed name of the operator.	Subclasses overwrite this method if the class name is not the same as the operator name"	^self subclassResponsibility</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_0</body></methods><methods><class-id>Graphics.PDF.Operation class</class-id> <category>instance creation</category><body package="PDF Graphics Operations">operands: operandsArray	| inst |	inst := self new.	inst initializeOperands: operandsArray asPDF.	^inst</body></methods><methods><class-id>Graphics.PDF.Operation class</class-id> <category>instance creation optional</category><body package="PDF Graphics Operations">empty	^self new</body><body package="PDF Graphics Operations">with: operand1	^self operands: (Array with: operand1)</body><body package="PDF Graphics Operations">with: operand1 with: operand2	^self operands: (Array		with: operand1		with: operand2)</body><body package="PDF Graphics Operations">with: operand1 with: operand2 with: operand3	^self operands: (Array		with: operand1		with: operand2		with: operand3)</body><body package="PDF Graphics Operations">with: operand1 with: operand2 with: operand3 with: operand4	^self operands: (Array		with: operand1		with: operand2		with: operand3		with: operand4)</body></methods><methods><class-id>Graphics.PDF.EndText</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	aPageGraphics graphicsState at: #textMatrix put: nil.	aPageGraphics graphicsState at: #textLineMatrix put: nil.	aPageGraphics addObject: aPageGraphics popCollector</body></methods><methods><class-id>Graphics.PDF.EndText class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'End a text object, discarding the text matrix'</body><body package="PDF Graphics Operations">operatorName	^#ET</body></methods><methods><class-id>Graphics.PDF.TextStateOperation</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	self subclassResponsibility</body><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	| object |	object := self newOperationObjectFor: aPageGraphics.	self applyTo: aPageGraphics.	object redundant: object state = aPageGraphics graphicsState.	aPageGraphics addObject: object</body></methods><methods><class-id>Graphics.PDF.TextFont</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #textFont put: self operands first.	aPageGraphics graphicsState at: #textFontSize put: self operands last</body></methods><methods><class-id>Graphics.PDF.TextFont</class-id> <category>accessing</category><body package="PDF Graphics Operations">resourceIn: aPageGraphics	^aPageGraphics resources Font objectAt: self operands first content</body></methods><methods><class-id>Graphics.PDF.TextFont class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the text font, Tf, to font and the text font size, Tfs, to size. font shall be the name of a font resource in the Font subdictionary of the current resource dictionary; size shall be a number representing a scale factor. There is no initial value for either font or size; they shall be specified explicitly by using Tf before any text is shown'</body><body package="PDF Graphics Operations">operandTypes	^#(#('font' Name) #('size' Number))</body><body package="PDF Graphics Operations">operatorName	^#Tf</body></methods><methods><class-id>Graphics.PDF.TextPositioningOperation</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	self subclassResponsibility</body><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	| object |	object := self newOperationObjectFor: aPageGraphics.	self applyTo: aPageGraphics.	aPageGraphics addObject: object</body></methods><methods><class-id>Graphics.PDF.SetTextMatrix</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #textMatrix put: (Matrix on: self operands).	aPageGraphics graphicsState at: #textLineMatrix put: aPageGraphics graphicsState textMatrix</body></methods><methods><class-id>Graphics.PDF.SetTextMatrix class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the text matrix, Tm, and the text line matrix, Tlm.                        [ a b 0 ]Tm := Tlm := [ c d 0 ]                         [ e f 1 ]The operands shall all be numbers, and the initial value for Tm and Tlm shall be the identity matrix, [1 0 0 1 0 0]. Although the operands specify a matrix, they shall be passed to Tm as six separate numbers, not as an array.The matrix specified by the operands shall not be concatenated onto the current text matrix, but shall replace it'</body><body package="PDF Graphics Operations">operandTypes	^#(#('a' Number) #('b' Number) #('c' Number) #('d' Number) #('e' Number) #('f' Number))</body><body package="PDF Graphics Operations">operatorName	^#Tm</body></methods><methods><class-id>Graphics.PDF.PathPaintingOperation</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	aPageGraphics currentPath addPainting: self.	aPageGraphics currentPath state: aPageGraphics graphicsState copy.	aPageGraphics addObject: aPageGraphics currentPath.	aPageGraphics currentPath clipping ifNotNil: [		aPageGraphics setClippingPathIntersecting: aPageGraphics currentPath].	aPageGraphics resetCurrentPath</body></methods><methods><class-id>Graphics.PDF.FillEvenOdd class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Fill the path, using the even-odd rule to determine the region to fill'</body><body package="PDF Graphics Operations">operatorName	^#'f*'</body></methods><methods><class-id>Graphics.PDF.TextShowingOperation</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	self subclassResponsibility</body><body package="PDF Graphics Operations">applyTo: aPageGraphics at: index	| object |	object := TextSegment operations: (Array with: self)				state: aPageGraphics graphicsState copy.	self applyTo: aPageGraphics.	aPageGraphics addObject: object</body></methods><methods><class-id>Graphics.PDF.ShowTextOnNextLine</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState nextLineBy: 0 @ aPageGraphics graphicsState leading content negated.	aPageGraphics graphicsState		at: #textMatrix		put: (aPageGraphics graphicsState textMatrix translatedBy: (aPageGraphics stringWidth: self operands first) @ 0)</body></methods><methods><class-id>Graphics.PDF.ShowTextOnNextLine class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Move to the next line and show a text string. This operator shall have the same effect as the code	T*	string Tj'</body><body package="PDF Graphics Operations">operandTypes	^#(#('string' String))</body><body package="PDF Graphics Operations">operatorName	^#''''</body></methods><methods><class-id>Graphics.PDF.PDFValue</class-id> <category>testing</category><body package="PDF Basic Objects">isArray	^false</body><body package="PDF Basic Objects">isDirect	^true</body><body package="PDF Basic Objects">isName	^false</body><body package="PDF Basic Objects">isNull	^false</body><body package="PDF Basic Objects">isOperator	^false</body><body package="PDF Basic Objects">isPDF	^true</body><body package="PDF Basic Objects">isReferencedBy: aCrossReference	^false</body><body package="PDF Basic Objects">isSameReference: anObject	^false</body><body package="PDF Complex Objects">isType: aType	^aType subsumesObject: self</body><body package="PDF Basic Objects">refersTo: aPDFReference	^false</body></methods><methods><class-id>Graphics.PDF.PDFValue</class-id> <category>accessing</category><body package="PDF Basic Objects">content	^self</body><body package="PDF Basic Objects">object	"&lt;PDF.Object&gt;	the direct object"	^self</body><body package="PDF Complex Objects">pdfType	^self class</body><body package="PDF Basic Objects">pdfVersion	"&lt;PDFVersion&gt;	the minimal version for this object with its features"	^Version pdf1_0</body><body package="PDF Basic Objects">unspecifiedAttributes	"&lt;Array of: Association&gt;"	^#()</body></methods><methods><class-id>Graphics.PDF.PDFValue</class-id> <category>printing</category><body package="PDF Basic Objects">printOn: aStream	aStream nextPutAll: self pdfSource</body></methods><methods><class-id>Graphics.PDF.PDFValue</class-id> <category>writing</category><body package="PDF Basic Objects">asPdfString	"&lt;String&gt;	the PDF source for tests with cr instead of lf"	^self pdfSource</body><body package="PDF Basic Objects">pdfSource	"&lt;String&gt;	the object as PDF source"	| wst |	wst := Writer on: ByteString new.	self writeOn: wst indent: 0.	^wst contents</body><body package="PDF Basic Objects">writeOn: aStream indent: integer	"write the receiver to the PDF stream"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.PDFValue</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	"&lt;PDF.PdfValue&gt;"	^self</body><body package="PDF Basic Objects">asSmalltalkValue	^self content</body><body package="PDF Complex Objects">asType: aType	"&lt;PDFObject | nil&gt;"	^aType specializedObject: self</body><body package="PDF Basic Objects">newReference	"&lt;Reference on: PDFValue&gt;"	^Reference referent: self</body></methods><methods><class-id>Graphics.PDF.PDFValue</class-id> <category>tracing</category><body package="PDF Basic Objects">tracedReferences: visitedReferences do: oneArgumentBlock	"executes oneArgumentBlock with a new unique reference"	"direct object. No references here"</body></methods><methods><class-id>Graphics.PDF.PDFValue</class-id> <category>typing</category><body package="PDF Complex Objects">errorWrongTypes: someTypes	"&lt;TypeMismatch&gt;"	^TypeMismatch for: self expected: someTypes</body><body package="PDF Complex Objects">typed: listOfTypes	"&lt;PDFObject&gt;	if the receiver can be of any of the listOfTypes, a specialized copy is returned,	otherwise the receiver is returned unchanged"	(listOfTypes anySatisfy: #isIndirect) ifTrue: [		^self errorWrongTypes: listOfTypes].	(listOfTypes isEmpty or: [	listOfTypes anySatisfy: [:type | self isType: type]]) ifTrue: [			^self].	listOfTypes do: [:type |		(self asType: type) ifNotNil: [:specialized |			^specialized]].	^self errorWrongTypes: listOfTypes</body></methods><methods><class-id>Graphics.PDF.PDFValue class</class-id> <category>instance creation</category><body package="PDF Basic Objects">empty	^self new</body></methods><methods><class-id>Graphics.PDF.PDFValue class</class-id> <category>accessing</category><body package="PDF Basic Objects">type	"&lt;Symbol&gt;	type entry"	^self name</body></methods><methods><class-id>Graphics.PDF.PDFValue class</class-id> <category>testing</category><body package="PDF Complex Objects">isSuperTypeOf: aPDFObject	^aPDFObject isKindOf: self</body></methods><methods><class-id>Graphics.PDF.NativeValue</class-id> <category>printing</category><body package="PDF Basic Objects">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'content' value: self content).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.PDF.NativeValue</class-id> <category>accessing</category><body package="PDF Basic Objects">content	"&lt;Value&gt;	the Smalltalk object for the value I represent"	^content</body></methods><methods><class-id>Graphics.PDF.NativeValue</class-id> <category>initialize-release</category><body package="PDF Basic Objects">initializeContent: contentValue	content := contentValue.	self beImmutable</body></methods><methods><class-id>Graphics.PDF.NativeValue</class-id> <category>copying</category><body package="PDF Basic Objects">copy	^self class on: self content</body></methods><methods><class-id>Graphics.PDF.NativeValue class</class-id> <category>instance creation</category><body package="PDF Basic Objects">content: contentValue	| inst |	inst := self new.	inst initializeContent: contentValue.	^inst</body><body package="PDF Basic Objects">on: anObject	"&lt;PDF.NativeValue&gt;	A new PDF object on anObject"	^self content: anObject</body></methods><methods><class-id>Graphics.PDF.NativeValue class</class-id> <category>accessing</category><body package="PDF Complex Objects">specialized: aPDFObject	"&lt;PDFObject | nil&gt;"	(self inheritsFrom: aPDFObject class) ifTrue: [		^self on: aPDFObject content].	^nil</body><body package="PDF Basic Objects">version	"&lt;Integer&gt;	PDF minor version"	^0</body></methods><methods><class-id>Graphics.PDF.Number</class-id> <category>testing</category><body package="PDF Basic Objects">isPositiveInteger	^self asSmalltalkValue isInteger and: [	self asSmalltalkValue strictlyPositive]</body><body package="PDF Basic Objects">nonNegativeInteger	^self asSmalltalkValue isInteger and: [	self asSmalltalkValue positive]</body></methods><methods><class-id>Graphics.PDF.Number</class-id> <category>writing</category><body package="PDF Basic Objects">writeOn: aStream indent: integer	aStream nextPutAll: self asSmalltalkValue printString</body></methods><methods><class-id>Graphics.PDF.Number class</class-id> <category>instance creation</category><body package="PDF Basic Objects">on: anInteger	"&lt;PDF.Integer | PDF.Real&gt;"	((anInteger between: Integer minValue and: Integer maxValue) and: [	anInteger isInteger]) ifTrue: [			^Integer content: anInteger].	^Real on: anInteger</body><body package="PDF Basic Objects">onInteger: anInteger	"&lt;PDF.Integer | PDF.Real&gt;"	^[Integer on: anInteger] on: Error do: [:ex | ex return: (Real on: anInteger)]</body><body package="PDF Basic Objects">zero	^Integer content: 0</body></methods><methods><class-id>Graphics.PDF.Real</class-id> <category>writing</category><body package="PDF Basic Objects">writeOn: aStream indent: integer	self asSmalltalkValue abs &lt; self vwMInPrintWithoutExponent ifTrue: [		^aStream nextPut: $0].	aStream nextPutAll: self asSmalltalkValue printString</body></methods><methods><class-id>Graphics.PDF.Real</class-id> <category>accessing</category><body package="PDF Basic Objects">vwMInPrintWithoutExponent	"&lt;Float&gt;	the smallest numer VisualWorks prints without exponent (9.999e-4).	0.001	0.0009999	Temporary workaround until we have a proper number writer"	^0.001</body></methods><methods><class-id>Graphics.PDF.Real class</class-id> <category>implementation limits</category><body package="PDF Basic Objects">epsilon	"Nonzero real values closest to 0 (approximate).Values closer than these are automatically converted to 0."	"Float fmin is 1.4013e-45" 	^1.175d-38</body><body package="PDF Basic Objects">maxValue	"Largest and smallest real values (approximate)."	^Float fmax</body><body package="PDF Basic Objects">minValue	"Largest and smallest real values (approximate)."	^Float fmax negated</body><body package="PDF Basic Objects">significantDecimals	"Number of significant decimal digits of precision in fractional part (approximate)."	^5</body></methods><methods><class-id>Graphics.PDF.Real class</class-id> <category>instance creation</category><body package="PDF Basic Objects">on: aLimitedPrecisionReal	(aLimitedPrecisionReal between: self minValue and: self maxValue) ifFalse: [		^Error raiseSignal: 'the number ' , aLimitedPrecisionReal printString , ' is too big for PDF reals'].	(aLimitedPrecisionReal between: self epsilon negated and: self epsilon) ifTrue: [		^Integer on: 0].	^self content: aLimitedPrecisionReal asFloat</body></methods><methods><class-id>Graphics.PDF.GraphicsObject</class-id> <category>accessing</category><body package="PDF Graphics">allOperations	^self operations</body><body package="PDF Graphics">asPdfString	^self pdfSource</body><body package="PDF Graphics">object	^self</body><body package="PDF Graphics">operations	"&lt;SequenceableCollection of: Operation&gt;	the sequence of operations which make up the receiver"	^operations ifNil: [operations := OrderedCollection new]</body><body package="PDF Graphics">pdfVersion	"&lt;PDFVersion&gt;	the minimal version for this object with its features"	^self operations inject: Version pdf1_0 into: [:max :op | max max: op pdfVersion]</body><body package="PDF Graphics">resource	^nil</body><body package="PDF Graphics">state	"&lt;GraphicsState&gt;	the state before the object is rendered"	^state ifNil: [GraphicsState new]</body><body package="PDF Graphics">state: aGraphicsState	state := aGraphicsState</body></methods><methods><class-id>Graphics.PDF.GraphicsObject</class-id> <category>converting</category><body package="PDF Graphics">asPDF	^self</body></methods><methods><class-id>Graphics.PDF.GraphicsObject</class-id> <category>testing</category><body package="PDF Graphics">isNull	^false</body></methods><methods><class-id>Graphics.PDF.GraphicsObject</class-id> <category>typing</category><body package="PDF Graphics">typed: listOfTypes	^self</body></methods><methods><class-id>Graphics.PDF.GraphicsObject</class-id> <category>initialize-release</category><body package="PDF Graphics">initializeOperations: someOperations state: aGraphicsState	operations := someOperations.	state := aGraphicsState copy beImmutable</body></methods><methods><class-id>Graphics.PDF.GraphicsObject</class-id> <category>writing</category><body package="PDF Graphics">pdfSource	"&lt;String&gt;"	| wst |	wst := WriteStream on: Core.String new.	self allOperations do: [:object | wst nextPutAll: object pdfSource]		separatedBy: [wst cr].	^wst contents</body></methods><methods><class-id>Graphics.PDF.GraphicsObject class</class-id> <category>instance creation</category><body package="PDF Graphics">operations: someOperations state: aGraphicsState	| inst |	inst := self new.	inst initializeOperations: someOperations state: aGraphicsState.	^inst</body></methods><methods><class-id>Graphics.PDF.Reference</class-id> <category>testing</category><body package="PDF Basic Objects">hasNumber	^number notNil</body><body package="PDF Basic Objects">isArray	^false</body><body package="PDF Basic Objects">isDirect	^false</body><body package="PDF Basic Objects">isNull	^false</body><body package="PDF Basic Objects">isReferencedBy: aCrossReference	^aCrossReference refersTo: self</body><body package="PDF Basic Objects">isResolved	"&lt;Boolean&gt;	the object has been read from the file"	^referent isPDF</body><body package="PDF Basic Objects">isSameReference: anObject	^self = anObject or: [	anObject refersTo: self]</body><body package="PDF Basic Objects">isSameReferent: aReferent	^referent = aReferent</body><body package="PDF Complex Objects">isType: aType	^aType subsumesReference: self</body></methods><methods><class-id>Graphics.PDF.Reference</class-id> <category>accessing</category><body package="PDF Basic Objects">assignNewNumber: anInteger	"set the object number with generation 0 for writing"	number := anInteger.	generation := 0</body><body package="PDF Basic Objects">content	^self referent</body><body package="PDF Basic Objects">generation	"&lt;Integer&gt;	A non-negative integer generation number. In a newly created file, all indirect objects shall have generation	numbers of 0. Nonzero generation numbers may be introduced when the file is later updated; see sub-	clauses 7.5.4, ""Cross-Reference Table"" and 7.5.6, ""Incremental Updates."""	^generation ifNil: [0]</body><body package="PDF Basic Objects">number	"&lt;Integer&gt;	A positive integer object number. Indirect objects may be numbered sequentially within a PDF file, but this	is not required; object numbers may be assigned in any arbitrary order."	^number ifNil: [0]</body><body package="PDF Basic Objects">object	^self referent ifNil: [self]</body><body package="PDF Basic Objects">pdfType	self isResolved ifFalse: [		^self error: 'this method should only be called for resolved references'].	^self referent pdfType</body><body package="PDF Basic Objects">referent	"&lt;PDF.Object&gt;	lazy reading the object from the file.	Initially, value stores a block which reads the object"	self isResolved ifFalse: [		referent := referent value].	^referent</body><body package="PDF Basic Objects">referent: aPDFObject	referent := aPDFObject</body></methods><methods><class-id>Graphics.PDF.Reference</class-id> <category>writing</category><body package="PDF Basic Objects">writeIndirectObjectOn: aStream indent: integer	aStream		nextPutAll: self number printString;		space;		nextPutAll: self generation printString;		space;		nextPutAll: 'obj';		cr.	self referent writeOn: aStream indent: 0.	aStream		cr;		nextPutAll: 'endobj'</body><body package="PDF Basic Objects">writeOn: aStream indent: integer	aStream		nextPutAll: self number printString;		space;		nextPutAll: self generation printString;		space;		nextPut: $R</body></methods><methods><class-id>Graphics.PDF.Reference</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	"&lt;PDF.Object&gt;"	^self</body><body package="PDF Basic Objects">asSmalltalkValue	^self referent asSmalltalkValue</body><body package="PDF Complex Objects">asType: aType	"&lt;Reference | nil&gt;"	^aType specializedReference: self</body></methods><methods><class-id>Graphics.PDF.Reference</class-id> <category>initialize-release</category><body package="PDF Basic Objects">initializeNumber: objectNumber generation: generationNumber referent: aPDFObject	number := objectNumber.	generation := generationNumber.	referent := aPDFObject</body><body package="PDF Files">with: aFile	"setup the virgin receiver to resolve the object from the file	see #referent for the lazy initializer"	referent := [aFile readObjectFor: self]</body></methods><methods><class-id>Graphics.PDF.Reference</class-id> <category>printing</category><body package="PDF Basic Objects">printOn: aStream	super printOn: aStream.	self isResolved ifFalse: [		aStream nextPut: $*]</body></methods><methods><class-id>Graphics.PDF.Reference</class-id> <category>tracing</category><body package="PDF Basic Objects">tracedReferences: visitedReferences do: oneArgumentBlock	"&lt;SequenceableCollection of: Reference&gt;"	(visitedReferences anySatisfy: [:ref | ref == self]) ifTrue: [		^self].	visitedReferences add: self.	oneArgumentBlock value: self.	self referent tracedReferences: visitedReferences do: oneArgumentBlock</body></methods><methods><class-id>Graphics.PDF.Reference</class-id> <category>copying</category><body package="PDF Basic Objects">copyWithReferent: aPDFObject	^self class number: self number generation: self generation referent: aPDFObject</body></methods><methods><class-id>Graphics.PDF.Reference</class-id> <category>comparing</category><body package="PDF Basic Objects">= anObject	^self class == anObject class and: [	self isResolved = anObject isResolved and: [	self number = anObject number and: [	self generation = anObject generation and: [	(self isResolved and: [	self referent == anObject referent]) or: [		self isResolved not]]]]]</body><body package="PDF Basic Objects">hash	| hash |	hash := self number hash bitXor: self generation hash.	(self hasNumber not and: [	self isResolved]) ifTrue: [			^self referent hash bitXor: hash].	^hash</body></methods><methods><class-id>Graphics.PDF.Reference</class-id> <category>typing</category><body package="PDF Complex Objects">typed: listOfTypes	"&lt;PDFObject&gt;	a more specialized version copy of the receiver or the receiver itself.	Dont resolve an object if it is not resolved yet (this would read in all referenced objects),	instead, wrap the object reading block in another block to convert the object after it was read.	This casting will globally effect the file, so that each holder of the receiver sees the new object.	Beware of multiple users of the object!!"	| specialized referentTypes |	(listOfTypes anySatisfy: [:type |		((type isKindOf: ClassType) or: [		type isKindOf: DirectType]) and: [			type pdfType == Reference]]) ifTrue: [			^self].	(listOfTypes anySatisfy: #isDirect) ifTrue: [		^self errorWrongTypes: listOfTypes].	referentTypes := (listOfTypes select: [:type | type appliesToReference]) collect: [:type |		type asDirectType].	self isResolved ifFalse: [		| originalBlock |		referent ifNil: [			^FileError raiseSignal: 'Illegal reference - References must be created by a PDF.File'].		originalBlock := referent.		referent := [originalBlock value typed: referentTypes].		^self].	specialized := self referent typed: referentTypes.	self referent == specialized ifFalse: [		self referent: specialized].	^self</body></methods><methods><class-id>Graphics.PDF.Reference class</class-id> <category>instance creation</category><body package="PDF Basic Objects">number: objectNumber generation: generationNumber	| inst |	inst := self new.	inst initializeNumber: objectNumber generation: generationNumber referent: nil.	^inst</body><body package="PDF Basic Objects">number: objectNumber generation: generationNumber referent: aPDFObject	| inst |	inst := self new.	inst initializeNumber: objectNumber generation: generationNumber referent: aPDFObject.	^inst</body><body package="PDF Basic Objects">referent: aPDFObject	^self number: nil generation: nil referent: aPDFObject</body></methods><methods><class-id>Graphics.PDF.LinkAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 5)</body><body package="PDF Interactive Features">subtype	^#Link</body></methods><methods><class-id>Graphics.PDF.XObjectOperation</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	| object |	object := ExternalGraphicsObject				operations: (Array with: self)				state: aPageGraphics graphicsState copy				resource: (self resourceIn: aPageGraphics).	aPageGraphics addObject: object</body></methods><methods><class-id>Graphics.PDF.Stream</class-id> <category>accessing</category><body package="PDF Streams">addFilter: aSymbol	"Filters are added in front as the outer filter.		aStream addFilter: #FlateDecode.		aStream addFilter: #ASCIIHexDecode.	result in [/ASCIIHexDecode /FlateDecode].	This encodes the internal contents first with /FlateDecode followed by /ASCIIHexDecode to produce the external representation.	Decoding first applies /ASCIIHexDecode and on the result /FlateDecode to yield the unfiltered internal contents."	| oldFilter |	(self hasKey: #Filter) ifFalse: [		^self filter: aSymbol].	oldFilter := (self at: #Filter) asSmalltalkValue.	oldFilter isSymbol ifTrue: [		^self filter: (Array			with: aSymbol			with: oldFilter)].	self filter: (Array with: aSymbol) , oldFilter</body><body package="PDF Streams">contents: internalByteString	internal := internalByteString.	self resetExternal</body><body package="PDF Streams">encrypted	"&lt;Boolean&gt;	true, iff the string is encrypted"	^encrypted ifNil: [false]</body><body package="PDF Streams">external	"&lt;ByteString&gt;	the internal decoded contents"	^external ifNil: [internal ifNotNil: [external := self externalValue]]</body><body package="PDF Streams">externalValue	"&lt;ByteString&gt;"	self filter isEmpty ifTrue: [		^self internal].	^self filter first external</body><body package="PDF Streams">filter	"&lt;SequenceableCollection of: Filter&gt;"	^filter ifNil: [		filter := internal ifNil: [self newFiltersFromExternal] ifNotNil: [			self newFiltersFromInternal]]</body><body package="PDF Streams">filter: aSymbolOrArrayOfSymbol	self at: #Filter put: aSymbolOrArrayOfSymbol.	internal ifNotNil: [self resetExternal]</body><body package="PDF Streams">filterClasses	^self filterNames collect: [:filterName | Filter subclassNamed: filterName asSmalltalkValue]</body><body package="PDF Streams">filterNames	"&lt;Array of: PDF.Name&gt;"	| filterAttr |	filterAttr := self Filter.	filterAttr isName ifTrue: [		^Array with: filterAttr].	^filterAttr content</body><body package="PDF Streams">internal	"&lt;ByteString&gt;	the internal decoded contents"	^internal ifNil: [external ifNotNil: [internal := self internalValue]]</body><body package="PDF Streams">internalValue	"&lt;ByteString | PDF.Error&gt;"	self encrypted ifTrue: [		^'*** Encrypted ***'].	self filter isEmpty ifTrue: [		^self external].	^self filter last internal</body><body package="PDF Streams">newFiltersFromExternal	| filterClasses decodeParams decodeParamsReadStream filters |	filterClasses := self filterClasses.	filterClasses isEmpty ifTrue: [		^#()].	filterClasses size = 1 ifTrue: [		^Array with: (filterClasses first external: self external with: self DecodeParms)].	decodeParams := self objectAt: #DecodeParms ifAbsent: [		(Array new: filterClasses size withAll: nil) asPDF].	decodeParamsReadStream := (decodeParams content collect: #object) readStream.	filters := OrderedCollection new.	filterClasses inject: self external into: [:input :filterClass |		| aFilter |		aFilter := filterClass external: input with: decodeParamsReadStream next.		filters add: aFilter.		aFilter internal].	^filters</body><body package="PDF Streams">newFiltersFromInternal	| filters |	filters := OrderedCollection new.	self filterClasses reverse inject: self internal into: [:input :filterClass |		| aFilter |		aFilter := filterClass internal: input with: self DecodeParms.		filters add: aFilter.		[aFilter external] on: Error do: [:ex |			^filters reverse]].	^filters reverse</body><body package="PDF Streams">readStream	"&lt;ReadStream on: Byte&gt;"	^self asByteArray readStream</body><body package="PDF Streams">topClassLevel	^4</body></methods><methods><class-id>Graphics.PDF.Stream</class-id> <category>writing</category><body package="PDF Streams">writeOn: aStream indent: integer	super writeOn: aStream indent: integer.	aStream		cr;		nextPutAll: 'stream';		cr;		nextPutAll: (self external ifNil: [ByteString new]);		cr;		nextPutAll: 'endstream'</body></methods><methods><class-id>Graphics.PDF.Stream</class-id> <category>copying</category><body package="PDF Streams">copy	^self class on: self content internal: self internal</body></methods><methods><class-id>Graphics.PDF.Stream</class-id> <category>comparing</category><body package="PDF Streams">= anObject	^super = anObject and: [	self internal = anObject internal and: [	self external = anObject external]]</body><body package="PDF Streams">hash	^super hash bitXor: (self internal hash bitXor: self external hash)</body></methods><methods><class-id>Graphics.PDF.Stream</class-id> <category>initialize-release</category><body package="PDF Streams">initializeContent: anOrderedDictionary internal: internalByteString external: externalByteString encrypted: encryptedBoolean	((internalByteString isNil and: [	externalByteString isNil]) or: [		internalByteString notNil and: [		externalByteString notNil]]) ifTrue: [			^Error raiseSignal: 'A stream can only be created with EITHER the internal OR the external bytes'].	self initializeContent: anOrderedDictionary.	internal := internalByteString.	external := externalByteString.	encrypted := encryptedBoolean.	self at: #Length put: self external size</body><body package="PDF Streams">resetExternal	"internal has changed. Force external to be recomputed"	external := nil.	filter := nil.	self at: #Length put: self external size</body></methods><methods><class-id>Graphics.PDF.Stream</class-id> <category>converting</category><body package="PDF Streams">asByteArray	"&lt;ByteArray&gt;"	^self internal asByteArray</body></methods><methods><class-id>Graphics.PDF.Stream class</class-id> <category>instance creation</category><body package="PDF Streams">on: anOrderedDictionary external: externalByteString	^self on: anOrderedDictionary external: externalByteString encrypted: false</body><body package="PDF Streams">on: anOrderedDictionary external: externalByteString encrypted: encryptedBoolean	| inst |	inst := (self classFor: anOrderedDictionary) new.	inst		initializeContent: anOrderedDictionary		internal: nil		external: externalByteString		encrypted: encryptedBoolean.	^inst</body><body package="PDF Streams">on: anOrderedDictionary internal: internalByteString	^self on: anOrderedDictionary internal: internalByteString encrypted: false</body><body package="PDF Streams">on: anOrderedDictionary internal: internalByteString encrypted: encryptedBoolean	| inst |	inst := (self classFor: anOrderedDictionary) new.	inst		initializeContent: anOrderedDictionary		internal: internalByteString		external: nil		encrypted: encryptedBoolean.	^inst</body></methods><methods><class-id>Graphics.PDF.Stream class</class-id> <category>accessing</category><body package="PDF Streams">specialized: aPDFStream	(self inheritsFrom: aPDFStream class) ifTrue: [		^self on: aPDFStream content external: aPDFStream external encrypted: aPDFStream encrypted].	^nil</body></methods><methods><class-id>Graphics.PDF.ICCProfileStream class</class-id> <category>accessing</category><body package="PDF Colour">version	^3</body></methods><methods><class-id>Graphics.PDF.TIFFPredictor</class-id> <category>filtering</category><body package="PDF Filter">predicted: aByteString	^Unsupported newSignal: 'TIFF prediction is not supported'</body><body package="PDF Filter">unpredicted: aByteString	^Unsupported newSignal: 'TIFF prediction is not supported'</body></methods><methods><class-id>Graphics.PDF.TIFFPredictor</class-id> <category>initialize-release</category><body package="PDF Filter">initializeFrom: aZipFilter	"do nothing for now"</body></methods><methods><class-id>Graphics.PDF.TIFFPredictor class</class-id> <category>instance creation</category><body package="PDF Filter">newFor: aZipFilter	| inst |	inst := self new.	inst initializeFrom: aZipFilter.	^inst</body></methods><methods><class-id>Graphics.PDF.GroupAttributes class</class-id> <category>accessing</category><body package="PDF XObjects">type	^#Group</body><body package="PDF XObjects">version	^4</body></methods><methods><class-id>Graphics.PDF.TextMarkup class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 10)</body><body package="PDF Interactive Features">version	^3</body></methods><methods><class-id>Graphics.PDF.StrikeOutAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">subtype	^#StrikeOut</body></methods><methods><class-id>Graphics.PDF.HorizontalScaling</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #horizontalScaling put: self operands first</body></methods><methods><class-id>Graphics.PDF.HorizontalScaling class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the horizontal scaling, Th, to (scale ÷ 100). scale shall be a number specifying the percentage of the normal width. Initial value: 100 (normal width)'</body><body package="PDF Graphics Operations">operandTypes	^#(#('scale' Number))</body><body package="PDF Graphics Operations">operatorName	^#Tz</body></methods><methods><class-id>Graphics.PDF.Font</class-id> <category>accessing</category><body package="PDF Fonts">stringWidth: aContentString	"&lt;Integer&gt; in glyph space	aContentString can be a multibyte string"	^self subclassResponsibility</body><body package="PDF Fonts">widthAt: aCodeOrIndexInteger	"&lt;Integer&gt; in glyph space"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.Font class</class-id> <category>accessing</category><body package="PDF Fonts">resourcePrefix	^'F'</body><body package="PDF Fonts">resourceType	"&lt;Symbol&gt;	the name of a /Resources key"	^#Font</body><body package="PDF Fonts">subtype	"&lt;Symbol&gt;	subtype entry"	^self name</body><body package="PDF Fonts">type	^#Font</body></methods><methods><class-id>Graphics.PDF.Font class</class-id> <category>instance creation</category><body package="PDF Fonts">empty	| inst |	inst := super empty.	inst at: #Subtype put: self subtype.	^inst</body><body package="PDF Fonts">isTypeFor: anOrderedDictionary	| subtypeEntry |	subtypeEntry := anOrderedDictionary at: #Subtype ifAbsent: [		^false].	^self subtype asPDF = subtypeEntry asPDF</body></methods><methods><class-id>Graphics.PDF.Parser</class-id> <category>reading objects</category><body package="PDF Parsing">readHexString	"&lt;PDF.String&gt;"	^(HexStringEncoder readStreamOn: (self upTo: $&gt;) readStream) contents asByteString asPDF</body><body package="PDF Parsing">readName	"&lt;PDF.Name&gt;"	^self nextNameSymbol asPDF</body><body package="PDF Parsing">readNumber: token	| numstr |	numstr := token.	numstr first == $+ ifTrue: [		numstr := token allButFirst: 1].	^numstr asNumber asPDF</body><body package="PDF Parsing">readString	"&lt;PDF.String&gt;"	^self readStringCharacters asPDF</body><body package="PDF Parsing">readStringCharacters	"&lt;Core.String&gt;"	^(StringEncoder readStreamOn: self nextEncodedString readStream) contents</body></methods><methods><class-id>Graphics.PDF.Parser</class-id> <category>reading</category><body package="PDF Parsing">expectInteger: anInteger	"read a token off the aStream.	Throw error if the token is not as expected"	| int pos |	pos := self position.	int := self nextInteger.	int = anInteger ifTrue: [		^self].	self errors add: (ReadError		newWith: pos		message: 'Read "' , int printString , '". "' , anInteger printString , '" expected').	self position: pos</body><body package="PDF Parsing">expectToken: aStringOrSymbol	"read a token off the aStream.	Throw error if the token is not as expected"	| token pos |	pos := self position.	token := self nextToken.	token = aStringOrSymbol ifTrue: [		^self].	self errors add: (ReadError		newWith: pos		message: 'Read "' , token , '". "' , aStringOrSymbol , '" expected').	self position: pos</body><body package="PDF Parsing">nextEncodedName	"&lt;String&gt;"	| wst |	wst := ByteString new writeStream.	[self atEnd] whileFalse: [		| char |		char := self peek.		(char isPdfRegular and: [		char asInteger between: 16r21 and: 16r7E])				ifTrue: [				wst nextPut: self next]				ifFalse: [				^wst contents]].	^wst contents</body><body package="PDF Parsing">nextEncodedString	"&lt;String&gt;	The position is just after the first opening parenthesis.	aStream is read up to and including the closing balanced parenthesis"	| wst count c |	count := 0.	wst := ByteString new writeStream.	[self atEnd] whileFalse: [		c := self next.		wst nextPut: c.		c == $\			ifTrue: [wst nextPut: self next]			ifFalse: [			c == $( ifTrue: [				count := count + 1].			c == $) ifTrue: [				count := count - 1.				count negative ifTrue: [					wst skip: -1.					^wst contents]]]].	^wst contents</body><body package="PDF Parsing">nextInteger	"&lt;Integer&gt;"	| wst |	self skipWhitespace.	wst := ByteString new writeStream.	[self atEnd] whileFalse: [		self peek isDigit			ifTrue: [wst nextPut: self next]			ifFalse: [			^wst contents asNumber]].	^wst contents asNumber</body><body package="PDF Parsing">nextNameSymbol	"&lt;Symbol&gt;"	^(NameEncoder readStreamOn: self nextEncodedName readStream) contents asByteString asSymbol</body><body package="PDF Parsing">nextNumberToken	"&lt;String&gt;"	| wst char hadPeriod |	wst := ByteString new writeStream.	char := self peek.	char == $+ ifTrue: [		self next].	char == $- ifTrue: [		wst nextPut: self next].	hadPeriod := false.	self peek == $. ifTrue: [wst nextPut: $0].	[self atEnd] whileFalse: [		char := self peek.		char == $.			ifTrue: [			hadPeriod				ifTrue: [				^wst contents]				ifFalse: [				wst nextPut: self next.				hadPeriod := true]]			ifFalse: [			char isDigit				ifTrue: [wst nextPut: self next]				ifFalse: [				^wst contents]]].	^wst contents</body><body package="PDF Parsing">nextToken	"&lt;String | Symbol | nil&gt;	read a token off the aStream.	Answer the token string"	| char |	self skipWhitespace.	char := self peek ifNil: [		^nil].	char isPdfDelimiter ifTrue: [		self next.		char == $&lt; ifTrue: [			self peek == $&lt; ifTrue: [				self next.				^'&lt;&lt;']].		^ByteString with: char].	char isPdfNumeric ifTrue: [		^self nextNumberToken].	char isPdfRegular ifTrue: [		^self nextNameSymbol].	ReadError raiseSignal: 'No token found for: ' , char printString</body><body package="PDF Parsing">skipWhitespace	[self atEnd] whileFalse: [		| char |		char := self peek.		char isPdfWhitespace			ifTrue: [self next]			ifFalse: [			char = $%				ifTrue: [self skipToEol]				ifFalse: [				^self]]]</body><body package="PDF Parsing">whenNext: aCharacter do: trueZeroArgumentBlock ifNot: falseOneArgumentBlock	"read aCharacter as next from the aStream.	If aCharacter is the next one, leave the position after aCharacter.	If aCharacter is not the next, leave the position before aCharacter"	| char |	char := self next.	^char == aCharacter		ifTrue: [trueZeroArgumentBlock value]		ifFalse: [		self skip: -1.		falseOneArgumentBlock value: char]</body></methods><methods><class-id>Graphics.PDF.Parser</class-id> <category>initialize-release</category><body package="PDF Parsing">initializeStream: aBinaryStream	stream := aBinaryStream</body><body package="PDF Parsing">release	self stream ifNotNil: [:aStream |		aStream close.		stream := nil].	super release</body></methods><methods><class-id>Graphics.PDF.Parser</class-id> <category>stream access</category><body package="PDF Parsing">atEnd	^self stream atEnd</body><body package="PDF Parsing">next	"&lt;Character&gt;"	^self stream next ifNotNil: [:int | int asCharacter]</body><body package="PDF Parsing">next: count	^(self stream next: count) asByteString</body><body package="PDF Parsing">peek	"&lt;Character&gt;"	^self stream peek ifNotNil: [:int | int asCharacter]</body><body package="PDF Parsing">position	^self stream position</body><body package="PDF Parsing">position: anInteger	^self stream position: anInteger</body><body package="PDF Parsing">skip: anInteger	^self stream skip: anInteger</body><body package="PDF Parsing">skipToEol	"skip all characters up to and including EndOfLine"	[self atEnd] whileFalse: [		| int |		int := self stream next.		(#(10 13) includes: int) ifTrue: [			(int == 13 and: [			self stream peek = 10]) ifTrue: [					self stream next].			^self]]</body><body package="PDF Parsing">upTo: aCharacter	^(self stream upTo: aCharacter asInteger) asByteString</body></methods><methods><class-id>Graphics.PDF.Parser</class-id> <category>accessing</category><body package="PDF Parsing">errors	"&lt;SequenceableCollection of: Error&gt;	skipped errors during reading"	^errors ifNil: [errors := OrderedCollection new]</body><body package="PDF Parsing">initialTokenActions	"&lt;Core.Dictionary key: (String | Symbol) value: Block&gt;"	^self subclassResponsibility</body><body package="PDF Parsing">stream	"&lt;Stream&gt;	a byte read stream"	^stream</body><body package="PDF Parsing">tokenActions	"blocks to read a PDF object with a reader.	true, false and null answer the identical object (for each file)"	^tokenActions ifNil: [tokenActions := self initialTokenActions]</body></methods><methods><class-id>Graphics.PDF.Parser</class-id> <category>testing</category><body package="PDF Parsing">isForEncrypted	^false</body></methods><methods><class-id>Graphics.PDF.Parser class</class-id> <category>instance creation</category><body package="PDF Parsing">onStream: aBinaryStream	| inst |	inst := self new.	inst initializeStream: aBinaryStream.	^inst</body><body package="PDF Parsing">onString: aString	^self onStream: aString asByteArray readStream</body></methods><methods><class-id>Graphics.PDF.ContentParser</class-id> <category>reading objects</category><body package="PDF Parsing">readArray	"&lt;PDFArray of: PDFObject&gt;"	| objects done |	done := false.	objects := OrderedCollection new.	[done] whileFalse: [		self skipWhitespace.		self atEnd			ifTrue: [			ReadError raiseSignal: 'End of Array (]) expected'.			done := true]			ifFalse: [			self peek == $]				ifTrue: [				self next.				done := true]				ifFalse: [				objects add: self readObject]]].	^objects asPDF</body><body package="PDF Parsing">readDictionary	"&lt;PDF.Dictionary&gt;"	^Dictionary on: self readOrderedDictionary</body><body package="PDF Parsing">readObject	"&lt;PDFObject | nil&gt;	read a PDF object off the aStream.	Answer the PDF object"	| token action |	token := self nextToken ifNil: [		^nil].	action := self tokenActions at: token ifAbsent: [		token first isPdfNumeric ifTrue: [			^self readNumber: token].		^Operation on: token].	^action value</body><body package="PDF Parsing">readOperations	| operators operands |	self stream reset.	operators := OrderedCollection new.	operands := OrderedCollection new.	[self atEnd] whileFalse: [		| object |		object := self readObject.		(object isNil and: [		self atEnd]) ifTrue: [				^operators].		object isOperator			ifTrue: [			operators add: (object class operands: operands).			operands := OrderedCollection new]			ifFalse: [			operands add: object]].	^operators</body><body package="PDF Parsing">readOrderedDictionary	| done dict |	done := false.	dict := OrderedDictionary new.	[done] whileFalse: [		self skipWhitespace.		self whenNext: $/ do: [dict at: self nextNameSymbol put: self readObject] ifNot: [:char |			char == $&gt;				ifTrue: [				self next.				self whenNext: $&gt; do: [done := true] ifNot: [:char1 |					ReadError raiseSignal: 'Read ' , char1 printString , ' but end of Dictionary (&gt;&gt;) expected']]				ifFalse: [				ReadError raiseSignal: 'Read ' , char printString , ' but ' , $/ printString , ' or ' , $&gt; printString , ' expected']]].	^dict</body><body package="PDF Parsing">readString	^ContentString content: (String asPDFEndOfLines: self readStringCharacters) asByteArray</body></methods><methods><class-id>Graphics.PDF.ContentParser</class-id> <category>accessing</category><body package="PDF Parsing">initialTokenActions	^(Core.Dictionary new)		at: #true put: [true asPDF];		at: #false put: [false asPDF];		at: #null put: [nil asPDF];		at: '(' put: [self readString];		at: '&lt;' put: [self readHexString];		at: '/' put: [self readName];		at: '[' put: [self readArray];		at: '&lt;&lt;' put: [self readDictionary];		yourself</body></methods><methods><class-id>Graphics.PDF.OptionalContentGroup class</class-id> <category>accessing</category><body package="PDF Data Structures">resourcePrefix	^'MC'</body><body package="PDF Data Structures">resourceType	"&lt;Symbol&gt;	the name of a /Resources key"	^#Properties</body><body package="PDF Data Structures">type	^#OCG</body><body package="PDF Data Structures">version	^5</body></methods><methods><class-id>Graphics.PDF.NameTree</class-id> <category>accessing</category><body package="PDF Data Structures">elements	"&lt;SequenceableCollection of: (Association key: String value: PDFObject)&gt;"	^#()</body></methods><methods><class-id>Graphics.PDF.NameTree class</class-id> <category>instance creation</category><body package="PDF Data Structures">on: aDictionary	aDictionary at: #Names ifAbsent: [		^NameTreeNode content: aDictionary].	^NameTreeLeaf content: aDictionary</body></methods><methods><class-id>Graphics.PDF.NameTreeNode</class-id> <category>accessing</category><body package="PDF Data Structures">elements	| wst |	wst := Array new writeStream.	self Kids do: [:nameTree | wst nextPutAll: nameTree elements].	^wst contents</body></methods><methods><class-id>Graphics.PDF.BeginInlineImage class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Begin an inline image object'</body><body package="PDF Graphics Operations">end	^EndInlineImage</body><body package="PDF Graphics Operations">operatorName	^#BI</body></methods><methods><class-id>Graphics.PDF.ColourOperation</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	self subclassResponsibility</body><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	| object |	object := self newOperationObjectFor: aPageGraphics.	self applyTo: aPageGraphics.	object redundant: object state = aPageGraphics graphicsState.	aPageGraphics addObject: object</body></methods><methods><class-id>Graphics.PDF.SetStrokingRGB</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #colorSpaceStroking put: DeviceRGB new.	aPageGraphics graphicsState at: #colorStroking put: self operands</body></methods><methods><class-id>Graphics.PDF.SetStrokingRGB class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the stroking colour space to DeviceRGB (or the DefaultRGB colour space) and set the colour to use for stroking operations. Each operand shall be a number between 0.0 (minimum intensity) and 1.0 (maximum intensity)'</body><body package="PDF Graphics Operations">operandTypes	^#(#('r' Number) #('g' Number) #('b' Number))</body><body package="PDF Graphics Operations">operatorName	^#RG</body></methods><methods><class-id>Graphics.PDF.PDFArray</class-id> <category>testing</category><body package="PDF Complex Objects">hasKey: anInteger	^anInteger between: 1 and: self size</body><body package="PDF Complex Objects">hasRequiredAttributes	^self attributesRequired allSatisfy: [:pragma |		pragma arguments first between: 1 and: self size]</body><body package="PDF Complex Objects">isArray	^true</body><body package="PDF Complex Objects">isType: aType	^aType subsumesArray: self</body></methods><methods><class-id>Graphics.PDF.PDFArray</class-id> <category>copying</category><body package="PDF Complex Objects">, anArray	^self class on: self content , anArray content</body><body package="PDF Complex Objects">with: aPDFObject	^(self content, (Array with: aPDFObject)) asPDF</body></methods><methods><class-id>Graphics.PDF.PDFArray</class-id> <category>typing</category><body package="PDF Complex Objects">typed: listOfTypes	"&lt;PDFArray&gt;	a copy of the receiver with the values specialized according to the listOfTypes"	| types elementTypes contentCopy |	types := listOfTypes select: [:type | type isForArray].	types isEmpty ifTrue: [		^super typed: listOfTypes].	types size &gt; 1 ifTrue: [		Error raiseSignal: 'Only one #typeArrayOf: pragma is allowed'.		^super typed: listOfTypes].	elementTypes := Array with: types first asClassType.	contentCopy := self content collect: [:value | value typed: elementTypes].	^self class on: contentCopy</body><body package="PDF Complex Objects">typesAt: index	| indexPragmas pragmaForSlot pragmas keywords typePragmas |	indexPragmas := Pragma allNamed: #attribute:documentation: in: self class.	indexPragmas isEmpty ifTrue: [		^#()].	pragmaForSlot := indexPragmas detect: [:pragma | pragma arguments first = index] ifNone: [		^#()].	pragmas := Pragma allInMethod: pragmaForSlot method.	keywords := Type pragmaKeywords.	typePragmas := pragmas select: [:pragma | keywords includes: pragma keyword].	^typePragmas collect: [:pragma |		| typeSymbol |		typeSymbol := pragma arguments first.		(PDF objecttypeAt: typeSymbol)			ifNotNil: [:class |			(Type typeClassAt: pragma keyword) on: class]			ifNil: [			UndefinedType on: typeSymbol]]</body></methods><methods><class-id>Graphics.PDF.PDFArray</class-id> <category>accessing</category><body package="PDF Complex Objects">at: index	^self content at: index</body><body package="PDF Complex Objects">at: index put: anObject	"&lt;PDFObject&gt;	anObject is added as its most specific version"	index isInteger ifFalse: [		^Error raiseSignal: 'PDF arrays have integers as keys'].	^self content at: index put: (anObject asPDF typed: (self typesAt: index))</body><body package="PDF Complex Objects">content	"&lt;Array of: PDF.Object&gt;"	^super content ifNil: [#()]</body><body package="PDF Complex Objects">first	^self content first object</body><body package="PDF Complex Objects">last	^self content last object</body><body package="PDF Complex Objects">objectAt: index ifNil: aBlock	"&lt;PDF.Object&gt;	returns the object stored in a slot or the value of a Reference"	| pdf |	(self content keys includes: index) ifFalse: [		^aBlock value].	pdf := self content at: index.	pdf isNull ifTrue: [		^aBlock value].	^pdf object</body><body package="PDF Complex Objects">objects	"&lt;Core.Array of: PDF.Object&gt;	resolved objects"	^self content collect: [:objectOrReference | objectOrReference object]</body><body package="PDF Complex Objects">size	^self content size</body></methods><methods><class-id>Graphics.PDF.PDFArray</class-id> <category>converting</category><body package="PDF Complex Objects">asSmalltalkValue	^self content collect: [:pdf | pdf asSmalltalkValue]</body><body package="PDF Complex Objects">asType: aType	^aType specializedArray: self</body></methods><methods><class-id>Graphics.PDF.PDFArray</class-id> <category>tracing</category><body package="PDF Complex Objects">tracedReferences: visitedReferences do: oneArgumentBlock	self do: [:pdfObject | pdfObject tracedReferences: visitedReferences do: oneArgumentBlock]</body></methods><methods><class-id>Graphics.PDF.PDFArray</class-id> <category>writing</category><body package="PDF Complex Objects">writeOn: aStream indent: integer	aStream nextPut: $[.	self content do: [:element | element writeOn: aStream indent: integer] separatedBy: [		aStream space].	aStream nextPut: $]</body></methods><methods><class-id>Graphics.PDF.PDFArray</class-id> <category>enumerating</category><body package="PDF Complex Objects">do: aBlockClosure	self content do: aBlockClosure</body></methods><methods><class-id>Graphics.PDF.PDFArray</class-id> <category>accessing attributes</category><body package="PDF Complex Objects">sortedAttributePragmas	^(Pragma		allNamed: #attribute:documentation:		from: self class		to: PDFArray		sortedByArgument: 1) first: self size</body></methods><methods><class-id>Graphics.PDF.PDFArray class</class-id> <category>instance creation</category><body package="PDF Complex Objects">empty	self class == PDFArray ifTrue: [		^self new].	^self new: self maxNumberOfAttributes</body><body package="PDF Complex Objects">new: numberOfElements	^self content: (Array new: numberOfElements withAll: nil asPDF)</body><body package="PDF Complex Objects">on: anArray	| inst |	self == PDFArray ifFalse: [		self validateSize: anArray].	inst := self new: anArray size.	anArray doWithIndex: [:element :index | inst at: index put: element].	^inst</body><body package="PDF Complex Objects">validateSize: anArray	"throws a TypeError if the size of the argument does not match the required number (or interval)"	| numString |	(anArray size between: self numberOfAttributes and: self maxNumberOfAttributes) ifTrue: [		^self].	numString := self numberOfAttributes printString.	self numberOfAttributes = self maxNumberOfAttributes ifFalse: [		numString := numString , '-' , self maxNumberOfAttributes printString].	TypeError raiseSignal: 'the size of the argument (' , anArray size printString , ') does not match the required number of attributes (' , numString , ')'</body><body package="PDF Complex Objects">with: aPDFObject	^self on: (Array with: aPDFObject)</body><body package="PDF Complex Objects">with: firstPDFObject with: secondPDFObject	^self on: (Array		with: firstPDFObject		with: secondPDFObject)</body><body package="PDF Complex Objects">with: firstPDFObject with: secondPDFObject with: thirdPDFObject	^self on: (Array		with: firstPDFObject		with: secondPDFObject		with: thirdPDFObject)</body><body package="PDF Complex Objects">with: firstPDFObject with: secondPDFObject with: thirdPDFObject with: fourthPDFObject	^self on: (Array		with: firstPDFObject		with: secondPDFObject		with: thirdPDFObject		with: fourthPDFObject)</body><body package="PDF Complex Objects">withAll: somePDFObjects	^self on: (Array withAll: somePDFObjects)</body></methods><methods><class-id>Graphics.PDF.PDFArray class</class-id> <category>accessing</category><body package="PDF Complex Objects">maxNumberOfAttributes	^self numberOfAttributes</body><body package="PDF Complex Objects">numberOfAttributes	"&lt;Integer&gt;	the fixed number of attributes in specialized subclasses"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.SpecialColourSpace</class-id> <category>accessing</category><body package="PDF Colour">defaultDecodeArray	"&lt;PDFArray of: Number&gt;"	^self subclassResponsibility</body><body package="PDF Colour">initialColourValues	"&lt;Array of Number&gt;	the initial colour when the current colour space is set"	^#()</body><body package="PDF Colour">numberOfComponents	"&lt;Integer&gt;"	^self subclassResponsibility</body><body package="PDF Colour">procSet	^#ImageC</body></methods><methods><class-id>Graphics.PDF.SpecialColourSpace class</class-id> <category>accessing</category><body package="PDF Colour">resourcePrefix	^'CS'</body><body package="PDF Colour">resourceType	"&lt;Symbol&gt;	the name of a /Resources key"	^#ColorSpace</body><body package="PDF Colour">specialized: aPDFObject	^(self subclasses detect: [:class | class isTypeFor: aPDFObject] ifNone: [		^nil]) on: aPDFObject content</body><body package="PDF Colour">type	^self name</body><body package="PDF Colour">version	^1</body></methods><methods><class-id>Graphics.PDF.SpecialColourSpace class</class-id> <category>instance creation</category><body package="PDF Colour">empty	| empty |	empty := super empty.	empty at: 1 put: self type.	^empty</body><body package="PDF Colour">isTypeFor: anArray	^anArray isArray and: [	anArray isEmpty not and: [	anArray first asPDF = self type asPDF and: [	anArray size between: self numberOfAttributes and: self maxNumberOfAttributes]]]</body></methods><methods><class-id>Graphics.PDF.Separation</class-id> <category>accessing</category><body package="PDF Colour">defaultDecodeArray	^#(0.0 1.0) asPDF</body><body package="PDF Colour">initialColourValues	^#(0.0)</body><body package="PDF Colour">numberOfComponents	^1</body></methods><methods><class-id>Graphics.PDF.Separation class</class-id> <category>accessing</category><body package="PDF Colour">numberOfAttributes	^4</body><body package="PDF Colour">version	^2</body></methods><methods><class-id>Graphics.PDF.MovieActivation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(13 4)</body><body package="PDF Interactive Features">version	^2</body></methods><methods><class-id>Graphics.PDF.Name</class-id> <category>accessing</category><body package="PDF Basic Objects">pdfVersion	(self pdfSource includes: $#) ifTrue: [		^Version pdf1_2].	^super pdfVersion</body></methods><methods><class-id>Graphics.PDF.Name</class-id> <category>writing</category><body package="PDF Basic Objects">writeOn: aStream indent: integer	aStream nextPutName: self</body></methods><methods><class-id>Graphics.PDF.Name</class-id> <category>testing</category><body package="PDF Basic Objects">isName	^true</body></methods><methods><class-id>Graphics.PDF.Name class</class-id> <category>instance creation</category><body package="PDF Basic Objects">on: aSymbol	(aSymbol size &lt;= self maxSize) ifTrue: [		^super on: aSymbol].	^Error raiseSignal: 'the symbol ' , aSymbol printString , ' is too big for PDF names'</body></methods><methods><class-id>Graphics.PDF.Name class</class-id> <category>implementation limits</category><body package="PDF Basic Objects">maxSize	"Maximum length of a name, in bytes."	^127</body></methods><methods><class-id>Graphics.PDF.Identity class</class-id> <category>instance creation</category><body package="PDF Data Structures">isTypeFor: aName	^aName content = self type</body></methods><methods><class-id>Graphics.PDF.PathConstructionOperation</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	aPageGraphics currentPath addToPath: self</body></methods><methods><class-id>Graphics.PDF.Move class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Begin a new subpath by moving the current point to coordinates (x, y), omitting any connecting line segment. If the previous path construction operator in the current path was also m, the new m overrides it; no vestige of the previous m operation remains in the path'</body><body package="PDF Graphics Operations">operandTypes	^#(#('x' Number) #('y' Number))</body><body package="PDF Graphics Operations">operatorName	^#m</body></methods><methods><class-id>Graphics.PDF.Document</class-id> <category>accessing</category><body package="PDF Document">info	"&lt;DocumentInformation&gt;"	^info ifNil: [info := DocumentInformation empty]</body><body package="PDF Document">info: aDocumentInformation	info := aDocumentInformation</body><body package="PDF Document">previousId	"&lt;FileIdentifier | nil&gt;	the /ID of the PDF from which the receiver is derrived from.	When the receiver is independently created, this is nil"	^previousId</body><body package="PDF Document">previousId: aFileIdentifierOrNil	previousId := aFileIdentifierOrNil</body><body package="PDF Document">root	"&lt;Catalog&gt;"	^root ifNil: [root := Catalog empty]</body><body package="PDF Document">root: aCatalog	root := aCatalog</body><body package="PDF Document">version	"&lt;PDF.Version&gt;"	^version ifNil: [self root tracedVersion]</body></methods><methods><class-id>Graphics.PDF.Document</class-id> <category>writing</category><body package="PDF Document">assignObjectNumbersTo: someReferences	"Assign numbers to the References"	someReferences doWithIndex: [:reference :id | reference assignNewNumber: id]</body><body package="PDF Document">saveAs: aFilename	| wst fst |	wst := Writer on: ByteString new.	self writeFile: aFilename on: wst.	fst := (aFilename withEncoding: #binary) writeStream.	[fst nextPutAll: wst contents asByteArray] ensure: [fst close]</body><body package="PDF Document">writeFile: aFilename on: wst	| trailer refs xrefs startxref |	trailer := Trailer new.	trailer at: #Info put: self info newReference.	trailer at: #Root put: self root newReference.	refs := trailer tracedReferences.	trailer at: #Size put: refs size + 1.	self assignObjectNumbersTo: refs.	self writeHeaderOn: wst.	xrefs := self writeObjects: refs on: wst.	startxref := wst position.	wst cr.	xrefs writeOn: wst indent: 0.	trailer addFileIdentifierWithFile: aFilename andSize: wst position id: self previousId.	wst cr.	trailer writeOn: wst indent: 0.	self writeStartxref: startxref on: wst</body><body package="PDF Document">writeHeaderOn: wst	wst nextPut: $%.	self version writeOn: wst indent: 0.	wst		cr;		nextPutAll: '%âãÏÓ';		cr</body><body package="PDF Document">writeObjects: someReferences on: wst	"&lt;CrossReferenceSection&gt;	Write someReferences to the stream.	The references must have numbers assigned"	| xrefs |	xrefs := someReferences collect: [:reference |		| pos |		pos := wst position.		reference writeIndirectObjectOn: wst indent: 0.		wst cr.		UsedReference value: pos number: reference number generation: reference generation].	^CrossReferenceSection initialOn: xrefs</body><body package="PDF Document">writeStartxref: positionInteger on: wst	wst		cr;		nextPutAll: 'startxref';		cr;		nextPutAll: positionInteger printString;		cr;		nextPutAll: '%%EOF'</body></methods><methods><class-id>Graphics.PDF.Document</class-id> <category>initialize-release</category><body package="PDF Document">initializeVersion: aPDFVersion	version := aPDFVersion</body></methods><methods><class-id>Graphics.PDF.Document class</class-id> <category>instance creation</category><body package="PDF Document">version: aPDFVersion	| inst |	inst := self new.	inst initializeVersion: aPDFVersion.	^inst</body></methods><methods><class-id>Graphics.PDF.MarkedContentPoint class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Designate a marked-content point. tag shall be a name object indicating the role or significance of the point'</body><body package="PDF Graphics Operations">operandTypes	^#(#('tag' Name))</body><body package="PDF Graphics Operations">operatorName	^#MP</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_2</body></methods><methods><class-id>Graphics.PDF.Renderer</class-id> <category>rendering</category><body package="PDF Rendering">add: anOperator	self contentOperators add: anOperator</body><body package="PDF Rendering">addArcCenter: centerPoint radius: radiusPoint from: angle for: deltaAngle do: aBlock	"copied from vw 7.3.1, since the implementation of dots changed in vw 7.4"	| ang1rad sin0 cos0 p0 adiff tanrad ang2rad cx cy ang1 delta rx ry |	ang1 := angle.	adiff := deltaAngle.	adiff &lt; 0 ifTrue: [		adiff := adiff negated.		ang1 := ang1 - adiff].	adiff &gt; 360 ifTrue: [		adiff := 360].	delta := adiff.	ang1rad := ang1 degreesToRadians.	sin0 := ang1rad sin.	cos0 := ang1rad cos.	cx := centerPoint x.	cy := centerPoint y.	rx := radiusPoint x.	ry := radiusPoint y.	p0 := (cos0 * rx + cx) @ (sin0 * ry + cy).	self moveTo: p0.	[adiff &gt; 90] whileTrue: [		| w p3 |		w := cos0.		cos0 := sin0 negated.		sin0 := w.		p3 := (cos0 * rx + cx) @ (sin0 * ry + cy).		self addArcFrom: p0 via: (p0 x + (cos0 * rx)) @ (p0 y + (sin0 * ry)) to: p3 do: aBlock.		p0 := p3.		adiff := adiff - 90].	adiff &gt; 0 ifFalse: [		^self].	"Compute the intersection of	the tangents, for addArcFrom:...."	tanrad := (adiff degreesToRadians / 2) tan.	ang2rad := (ang1 + delta) degreesToRadians.	self		addArcFrom: p0		via: (p0 x - (tanrad * sin0 * rx)) @ (p0 y + (tanrad * cos0 * ry))		to: (cx + (radiusPoint x * ang2rad cos)) @ (cy + (radiusPoint y * ang2rad sin))		do: aBlock</body><body package="PDF Rendering">addArcFrom: p0 via: p1 to: p2 do: aBlock	"copied from vw 7.3.1, since the implementation of dots changed in vw 7.4"	" p0 and p2 are tangent points.	p1 is the intersection of the tangent lines."	| magic |	"The following is a magic value that causes	Bezier curves to approximate arcs with better	than 0.0003 accuracy."	magic := 0.5522847.	aBlock value: (p1 - p0) * magic + p0		value: (p1 - p2) * magic + p2		value: p2</body><body package="PDF Rendering">addRectangleLeft: leftNumber bottom: bottomNumber width: widthNumber height: heightNumber	self add: (AppendRectangle		with: leftNumber		with: bottomNumber		with: widthNumber		with: heightNumber)</body><body package="PDF Rendering">addRoundedRectanglePath: box radius: radius	"Add a rectangular path with rounded corners	c1-p1---p2-c2	p8            p3	 |               |	p7            p4	c4-p6---p5-c3"	| kappa l left right bottom top p1 p2 p3 p4 p5 p6 p7 p8 |	kappa := 0.552285.	l := radius * kappa.	left := box left.	right := box right.	bottom := box top.	top := box bottom.	p1 := (left + radius) @ top.	p2 := (right - radius) @ top.	p3 := right @ (top - radius).	p4 := right @ (bottom + radius).	p5 := (right - radius) @ bottom.	p6 := (left + radius) @ bottom.	p7 := left @ (bottom + radius).	p8 := left @ (top - radius).	self moveTo: p1.	self lineTo: p2.	self curveTo: p3 controlPoint1: (p2 x + l) @ p2 y controlPoint2: p3 x @ (p3 y + l).	self lineTo: p4.	self curveTo: p5 controlPoint1: p4 x @ (p4 y - l) controlPoint2: (p5 x + l) @ p5 y.	self lineTo: p6.	self curveTo: p7 controlPoint1: (p6 x - l) @ p6 y controlPoint2: p7 x @ (p7 y - l).	self lineTo: p8.	self curveTo: p1 controlPoint1: p8 x @ (p8 y + l) controlPoint2: (p1 x - l) @ p1 y</body><body package="PDF Rendering">addTransparencyPageAttributesWithColorspace: aColorspace	"add the transparency related information to the page"	self subclassResponsibility</body><body package="PDF Rendering">capStyle: anInteger	self add: (SetCap with: anInteger - 1)</body><body package="PDF Rendering">characterSpacing: aNumber	self add: (CharacterSpacing with: aNumber)</body><body package="PDF Rendering">clip	self add: Clip empty</body><body package="PDF Rendering">closeAndStroke	self add: StrokeClosed empty</body><body package="PDF Rendering">closepath	self add: ClosePath empty</body><body package="PDF Rendering">concat: anArray6OfNumber	self add: (ConcatenateMatrix operands: anArray6OfNumber)</body><body package="PDF Rendering">curveTo: aPoint controlPoint1: controlPoint1 controlPoint2: controlPoint2	self add: (AppendCurve operands: controlPoint1 asPDFArray , controlPoint2 asPDFArray , aPoint asPDFArray)</body><body package="PDF Rendering">dash: aDash	self add: (SetDash		with: aDash array		with: aDash offset)</body><body package="PDF Rendering">displayArcBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle	| center start sweep |	start := startAngle.	sweep := sweepAngle.	sweep &lt; 0 ifTrue: [		sweep := sweep negated.		start := start - sweep].	sweep := 360 min: sweep.	center := originPoint + (extentPoint / 2.0).	self addArcCenter: center radius: extentPoint / 2.0 from: start for: sweep do: [:p2 :p3 :p4 |		self curveTo: p4 controlPoint1: p2 controlPoint2: p3]</body><body package="PDF Rendering">displayWedgeBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle	| center start sweep |	start := startAngle.	sweep := sweepAngle.	sweep &lt; 0 ifTrue: [		sweep := sweep negated.		start := start - sweep].	sweep := 360 min: sweep.	center := originPoint + (extentPoint / 2.0).	self addArcCenter: center radius: extentPoint / 2.0 from: start for: sweep do: [:p2 :p3 :p4 |		self curveTo: p4 controlPoint1: p2 controlPoint2: p3].	sweep = 360 ifFalse: [		self lineTo: center]</body><body package="PDF Rendering">endpath	self add: EndPath empty</body><body package="PDF Rendering">fill	self add: Fill empty</body><body package="PDF Rendering">fillColor: aColor	self add: aColor fillColourSetter</body><body package="PDF Rendering">horizontalScaling: aNumber	self add: (HorizontalScaling with: aNumber)</body><body package="PDF Rendering">inCompatibilitySectionDo: zeroArgumentBlock	self add: BeginCompatibility empty.	[zeroArgumentBlock value] ensure: [self add: EndCompatibility empty]</body><body package="PDF Rendering">isolatedDo: zeroArgumentBlock	"do zeroArgumentBlock with a copy of the graphics state.	Any changes to the graphics state done in the block will be undone when the block finishes"	self add: SaveState empty.	[zeroArgumentBlock value] ensure: [self add: RestoreState empty]</body><body package="PDF Rendering">joinStyle: anInteger	self add: (SetJoin with: anInteger - 1)</body><body package="PDF Rendering">lineTo: aPoint	self add: (AppendLine operands: aPoint asPDFArray)</body><body package="PDF Rendering">linewidth: aNumber	self add: (SetLineWidth with: aNumber)</body><body package="PDF Rendering">miterLimit: aNumber	self add: (SetMiterLimit with: aNumber)</body><body package="PDF Rendering">moveTo: aPoint	self add: (Move operands: aPoint asPDFArray)</body><body package="PDF Rendering">paintShading: aShading	self add: (PaintShading with: (self resources idFor: aShading))</body><body package="PDF Rendering">paintXObject: anXObject	self add: (PaintXObject with: (self resources idFor: anXObject)).	anXObject addProcSetTo: self</body><body package="PDF Rendering">setClippingPath	self closepath.	self clip.	self endpath</body><body package="PDF Rendering">setExtGState: anExtGState	self add: (SetGraphicsState with: (self resources idFor: anExtGState))</body><body package="PDF Rendering">setFont: aFontnameSymbol size: aSizeNumber	self add: (TextFont		with: (self idForFontNamed: aFontnameSymbol)		with: aSizeNumber)</body><body package="PDF Rendering">showString: aString	self add: (ShowText with: aString)</body><body package="PDF Rendering">stroke	self add: Stroke empty</body><body package="PDF Rendering">strokeColor: aColor	self add: aColor strokeColourSetter</body><body package="PDF Rendering">textMatrix: anArray6OfNumber	self add: (SetTextMatrix operands: anArray6OfNumber)</body><body package="PDF Rendering">textObjectDo: zeroArgumentBlock	self add: BeginText empty.	[zeroArgumentBlock value] ensure: [self add: EndText empty]</body><body package="PDF Rendering">textRenderingMode: anInteger	self add: (TextRenderingMode with: anInteger)</body></methods><methods><class-id>Graphics.PDF.Renderer</class-id> <category>actions</category><body package="PDF Rendering">addContents	"adds the contents to the container (Page or Form)"	^self subclassResponsibility</body><body package="PDF Rendering">addProcSet: aSymbol	"preserving the order"	| procSets newProcSet |	procSets := self resources ProcSet asSmalltalkValue asSet.	(procSets includes: aSymbol) ifTrue: [		^self].	procSets add: aSymbol.	newProcSet := #(#PDF #Text #ImageB #ImageC #ImageI) select: [:procset |		procSets includes: procset].	self resources at: #ProcSet put: newProcSet</body><body package="PDF Rendering">finishProduct	self idsAtFonts keysAndValuesDo: [:font :id |		(self pdfFontAt: id) addWinAnsiEncodingWith: font]</body><body package="PDF Rendering">render: oneArgumentBlock	"adds everything to the page or form.	The rendering process.	oneArgumentBlock takes the renderer as parameter"	self setupBounds.	oneArgumentBlock value: self.	self addContents.	self finishProduct</body><body package="PDF Rendering">setupBounds	"set the bounding box in the document"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.Renderer</class-id> <category>accessing</category><body package="PDF Rendering">bounds	"&lt;Rectangle&gt;"	^bounds</body><body package="PDF Rendering">colorspace	"&lt;ColourSpace&gt;	we render in this colorspace"	^colorspace</body><body package="PDF Rendering">contentOperators	"&lt;SequenceableCollection of: Operator&gt;"	^contentOperators ifNil: [contentOperators := OrderedCollection new]</body><body package="PDF Rendering">contentSource	"&lt;ByteString&gt;"	| wst |	wst := Writer on: ByteString new.	self contentOperators do: [:operator |		operator writeOn: wst indent: 0.		wst cr].	^wst contents</body><body package="PDF Rendering">globalState	"&lt;Dictionary key: Symbol value: PDF.Object&gt;	PDF objects which can be referenced anywhere in the rendering process of a page"	^self subclassResponsibility</body><body package="PDF Rendering">globalStateAt: aSymbol ifAbsentPut: zeroArgumentBlock	"&lt;PDF.Object&gt;	remember the value of zeroArgumentBlock as aSymbol globally in the scope of this page"	^self globalState at: aSymbol ifAbsentPut: zeroArgumentBlock</body><body package="PDF Rendering">idForFont: loadedFont	"&lt;Symbol&gt;	add loadedFont with new ID if not there"	^self idsAtFonts at: loadedFont ifAbsentPut: [		self resources idFor: loadedFont pdfFont]</body><body package="PDF Rendering">idForFontNamed: aFontnameSymbol	"&lt;Symbol&gt;	the Resources font id"	^self idForFont: (Graphics.Fonts.Font fontAt: aFontnameSymbol)</body><body package="PDF Rendering">idsAtFonts	"&lt;Dictionary key: Graphics.Fonts.Font value: Symbol&gt;"	^idsAtfonts ifNil: [idsAtfonts := OrderedDictionary new]</body><body package="PDF Rendering">newCodeForGlyph: aGlyph inFont: opentype	"&lt;Integer&gt;	answer a newly assigned code for aGlyph which is not in the WinAnsi encoding.	these codes are collected and added as encoding difference to the PDF"	| font |	font := self pdfFontAt: (self idsAtFonts at: opentype).	^font usedExtraGlyphs at: aGlyph ifAbsentPut: [font newCodeForExtraGlyph]</body><body package="PDF Rendering">pageRenderer	"&lt;PageRenderer&gt;	the top renderer for the page"	^self subclassResponsibility</body><body package="PDF Rendering">pdfFontAt: fontId	"&lt;Font&gt;"	^self resources fonts objectAt: fontId</body><body package="PDF Rendering">pdfStringWithTabularCharacters: aString inFont: opentype	"&lt;String&gt;	string with WinAnsiEncoding where tabular glyphs are specially encoded.	Dont use collect for TwoByteString"	| newString |	newString := Core.String new.	aString do: [:char |		| maybeNewChar |		maybeNewChar := self tabularCharacterFor: char in: opentype.		newString := newString copyWith: maybeNewChar].	^newString</body><body package="PDF Rendering">product	"&lt;Page | Form&gt;"	^product</body><body package="PDF Rendering">resources	"&lt;Resources&gt;	the current resources.	Always add #ProcSet for backward compatibility (i.e. Quark)"	^self product at: #Resources ifAbsentPut: [		| dict |		dict := Resources empty.		dict at: #ProcSet put: #(#PDF #Text).		dict]</body><body package="PDF Rendering">tabularCharacterFor: aCharacter in: anOpenTypeFont	"&lt;Character&gt;	with new assigned code for the tabular glyph"	(anOpenTypeFont tabularVariantOf: (anOpenTypeFont glyphAtUnicode: aCharacter asInteger)) ifNotNil: [:tabularGlyph |		^(self newCodeForGlyph: tabularGlyph inFont: anOpenTypeFont) asCharacter].	^aCharacter</body></methods><methods><class-id>Graphics.PDF.Renderer</class-id> <category>initialize-release</category><body package="PDF Rendering">initializeProduct: initialProduct bounds: aRectangle colorspace: aColourSpace	bounds := aRectangle.	product := initialProduct.	colorspace := aColourSpace</body></methods><methods><class-id>Graphics.PDF.Renderer class</class-id> <category>instance creation</category><body package="PDF Rendering">newOn: aPage bounds: aRectangle colorspace: aColourSpace	| inst |	inst := self new.	inst initializeProduct: aPage bounds: aRectangle colorspace: aColourSpace.	^inst</body></methods><methods><class-id>Graphics.PDF.FormRenderer</class-id> <category>accessing</category><body package="PDF Rendering">globalState	^self parent globalState</body><body package="PDF Rendering">idForFont: loadedFont	"the pdf font of the parent is used - with the same ID"	^self idsAtFonts at: loadedFont ifAbsentPut: [		| idInParent |		idInParent := self parent idForFont: loadedFont.		self resources fonts at: idInParent put: (self parent resources fonts at: idInParent).		idInParent]</body><body package="PDF Rendering">pageRenderer	^self parent pageRenderer</body><body package="PDF Rendering">parent	"&lt;Renderer&gt;"	^parent</body></methods><methods><class-id>Graphics.PDF.FormRenderer</class-id> <category>actions</category><body package="PDF Rendering">addContents	self product contents: self contentSource</body><body package="PDF Rendering">setupBounds	self product at: #BBox put: self bounds</body></methods><methods><class-id>Graphics.PDF.FormRenderer</class-id> <category>initialize-release</category><body package="PDF Rendering">initializeGroup: aGroup bounds: aRectangle colorspace: aColourSpace parent: aPageRenderer	self initializeProduct: aGroup bounds: aRectangle colorspace: aColourSpace.	parent := aPageRenderer</body></methods><methods><class-id>Graphics.PDF.FormRenderer</class-id> <category>rendering</category><body package="PDF Rendering">addTransparencyPageAttributesWithColorspace: aColorspace	self parent addTransparencyPageAttributesWithColorspace: aColorspace</body></methods><methods><class-id>Graphics.PDF.FormRenderer class</class-id> <category>instance creation</category><body package="PDF Rendering">newOn: aGroup bounds: aRectangle colorspace: aColourSpace in: aPageRenderer	| inst |	inst := self new.	inst		initializeGroup: aGroup		bounds: aRectangle		colorspace: aColourSpace		parent: aPageRenderer.	^inst</body></methods><methods><class-id>Graphics.PDF.EndMarkedContent</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	aPageGraphics addObject: aPageGraphics popCollector</body></methods><methods><class-id>Graphics.PDF.EndMarkedContent class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'End a marked-content sequence begun by a BMC or BDC operator'</body><body package="PDF Graphics Operations">operatorName	^#EMC</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_2</body></methods><methods><class-id>Graphics.PDF.NumberTree class</class-id> <category>instance creation</category><body package="PDF Data Structures">on: aDictionary	aDictionary at: #Nums ifAbsent: [		^NumberTreeNode content: aDictionary].	^NumberTreeLeaf content: aDictionary</body></methods><methods><class-id>Graphics.PDF.CharacterSpacing</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #characterSpacing put: self operands first</body></methods><methods><class-id>Graphics.PDF.CharacterSpacing class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the character spacing, Tc, to charSpace, which shall be a number expressed in unscaled text space units. Character spacing shall be used by the Tj, TJ, and '' operators. Initial value: 0'</body><body package="PDF Graphics Operations">operandTypes	^#(#('charSpace' Number))</body><body package="PDF Graphics Operations">operatorName	^#Tc</body></methods><methods><class-id>Graphics.PDF.ShowTextPositioned</class-id> <category>testing</category><body package="PDF Graphics Operations">isPDFString: aPDFObject	^aPDFObject content isSequenceable</body></methods><methods><class-id>Graphics.PDF.ShowTextPositioned</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	| matrix string rst |	matrix := aPageGraphics graphicsState textMatrix.	string := ''.	rst := self operands first content readStream.	[rst atEnd] whileFalse: [		| pdfStringOrNumber |		pdfStringOrNumber := rst next.		string := (self isPDFString: pdfStringOrNumber)			ifTrue: [			string , pdfStringOrNumber asString]			ifFalse: [			matrix := matrix translatedBy: (aPageGraphics stringWidth: string asPDF adjustedBy: pdfStringOrNumber content) @ 0.			'']].	string notEmpty ifTrue: [		matrix := matrix translatedBy: (aPageGraphics stringWidth: string asPDF) @ 0].	aPageGraphics graphicsState at: #textMatrix put: matrix</body></methods><methods><class-id>Graphics.PDF.ShowTextPositioned class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Show one or more text strings, allowing individual glyph positioning. Each element of array shall be either a string or a number. If the element is a string, this operator shall show the string. If it is a number, the operator shall adjust the text position by that amount; that is, it shall translate the text matrix, Tm. The number shall be expressed in thousandths of a unit of text space. This amount shall be subtracted from the current horizontal or vertical coordinate, depending on the writing mode. In the default coordinate system, a positive adjustment has the effect of moving the next glyph painted either to the left or down by the given amount'</body><body package="PDF Graphics Operations">operandTypes	^#(#('array' PDFArray))</body><body package="PDF Graphics Operations">operatorName	^#TJ</body></methods><methods><class-id>Graphics.PDF.FillAndStrokeClosed class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Close, fill, and then stroke the path, using the nonzero winding number rule to determine the region to fill. This operator shall have the same effect as the sequence h B'</body><body package="PDF Graphics Operations">operatorName	^#b</body></methods><methods><class-id>Graphics.PDF.CIEColourSpace</class-id> <category>accessing</category><body package="PDF Colour">defaultDecodeArray	"&lt;PDFArray of: Number&gt;"	^self subclassResponsibility</body><body package="PDF Colour">initialColourValues	"&lt;Array of Number&gt;	the initial colour when the current colour space is set"	^self subclassResponsibility</body><body package="PDF Colour">numberOfComponents	"&lt;Integer&gt;"	^self subclassResponsibility</body><body package="PDF Colour">procSet	^#ImageC</body></methods><methods><class-id>Graphics.PDF.CIEColourSpace class</class-id> <category>accessing</category><body package="PDF Colour">numberOfAttributes	^2</body><body package="PDF Colour">resourcePrefix	^'CS'</body><body package="PDF Colour">resourceType	"&lt;Symbol&gt;	the name of a /Resources key"	^#ColorSpace</body><body package="PDF Colour">specialized: aPDFObject	^(self subclasses detect: [:class | class isTypeFor: aPDFObject] ifNone: [		^nil]) on: aPDFObject content</body><body package="PDF Colour">type	^self name</body><body package="PDF Colour">version	^1</body></methods><methods><class-id>Graphics.PDF.CIEColourSpace class</class-id> <category>instance creation</category><body package="PDF Colour">isTypeFor: anArray	^anArray isArray and: [	anArray isEmpty not and: [	anArray first asPDF = self type asPDF]]</body></methods><methods><class-id>Graphics.PDF.TypedStream</class-id> <category>accessing</category><body package="PDF Streams">attributesRequired	^self sortedAttributePragmas select: [:pragma |		pragma selector == #Type or: [		self attributeIsRequired: pragma]]</body></methods><methods><class-id>Graphics.PDF.TypedStream class</class-id> <category>instance creation</category><body package="PDF Streams">empty	| inst |	inst := self new.	inst at: #Type put: self type.	^inst</body></methods><methods><class-id>Graphics.PDF.XObject</class-id> <category>actions</category><body package="PDF XObjects">addProcSetTo: aRenderer	"do nothing"</body></methods><methods><class-id>Graphics.PDF.XObject class</class-id> <category>instance creation</category><body package="PDF XObjects">empty	| inst |	inst := self new.	inst at: #Subtype put: self subtype.	^inst</body><body package="PDF XObjects">isTypeFor: anOrderedDictionary	| subtypeEntry |	self == XObject ifTrue: [		^super isTypeFor: anOrderedDictionary].	subtypeEntry := anOrderedDictionary at: #Subtype ifAbsent: [		^false].	^self subtype asPDF = subtypeEntry asPDF</body></methods><methods><class-id>Graphics.PDF.XObject class</class-id> <category>accessing</category><body package="PDF XObjects">resourcePrefix	"&lt;String&gt;	the prefix for ids in /Resources"	^self subclassResponsibility</body><body package="PDF XObjects">resourceType	"&lt;Symbol&gt;	the name of a /Resources key"	^#XObject</body><body package="PDF XObjects">subtype	"&lt;Symbol&gt;	subtype entry"	^self name</body><body package="PDF XObjects">type	^#XObject</body></methods><methods><class-id>Graphics.PDF.FormXObject</class-id> <category>accessing</category><body package="PDF XObjects">contentString	"&lt;String&gt;	all decoded content"	^self internal</body><body package="PDF XObjects">graphicsInterpreter	"&lt;GraphicsInterpreter&gt;"	^GraphicsInterpreter on: self</body></methods><methods><class-id>Graphics.PDF.FormXObject class</class-id> <category>accessing</category><body package="PDF XObjects">resourcePrefix	^'Fm'</body><body package="PDF XObjects">subtype	^#Form</body></methods><methods><class-id>Graphics.PDF.DeviceColourSpace</class-id> <category>accessing</category><body package="PDF Colour">black	^self initialColourValues asPDF</body><body package="PDF Colour">content	^self class name</body><body package="PDF Colour">defaultDecodeArray	"&lt;PDFArray of: Number&gt;"	^self subclassResponsibility</body><body package="PDF Colour">initialColour	"&lt;ColorValue | CmykColor&gt;	the initial colour when the current colour space is set.	This is not relevant for device colour spaces, since the colour space is set implicitly when setting a colour.	Implemented for documentation only"	^ColorValue black</body><body package="PDF Colour">initialColourValues	"&lt;Array of Number&gt;	the initial colour when the current colour space is set"	^self subclassResponsibility</body><body package="PDF Colour">numberOfComponents	"&lt;Integer&gt;"	^self subclassResponsibility</body><body package="PDF Colour">procSet	^#ImageC</body></methods><methods><class-id>Graphics.PDF.DeviceColourSpace class</class-id> <category>accessing</category><body package="PDF Colour">specialized: aPDFObject	^(self subclasses detect: [:class | class isTypeFor: aPDFObject] ifNone: [		^nil]) on: aPDFObject content</body><body package="PDF Colour">version	^1</body></methods><methods><class-id>Graphics.PDF.DeviceColourSpace class</class-id> <category>instance creation</category><body package="PDF Colour">isTypeFor: aName	^aName asSmalltalkValue = self type</body></methods><methods><class-id>Graphics.PDF.DeviceRGB</class-id> <category>accessing</category><body package="PDF Images">bitsFor: aColorValue withSizes: bitsPerComponents	"&lt;Integer&gt;	the bits stored in the pixel array"	| maxBits nativeBitsPerComponent scales redBits greenBits blueBits |	maxBits := bitsPerComponents inject: 0 into: [:max :number | max max: number].	nativeBitsPerComponent := ImageXObject nativeBitsPerComponentFor: maxBits.	scales := bitsPerComponents collect: [:bits | (1 bitShift: bits) - 1].	redBits := (aColorValue red * scales first) rounded.	greenBits := (aColorValue green * (scales at: 2)) rounded.	blueBits := (aColorValue blue * scales last) rounded.	^(redBits bitShift: nativeBitsPerComponent * 2) + (greenBits bitShift: nativeBitsPerComponent) + blueBits</body><body package="PDF Images">bytesFromMappedPalette: aMappedPalette	| byteArray |	byteArray := ByteArray new: aMappedPalette elementData size.	1 to: byteArray size do: [:index |		byteArray at: index put: ((aMappedPalette elementData at: index) bitShift: -5)].	^byteArray</body><body package="PDF Images">colorAt: someBits withSizes: bitsPerComponents decodeWith: anArray	"&lt;ColorValue&gt;"	| maxBits nativeBitsPerComponent componentMask components values scale |	maxBits := bitsPerComponents inject: 0 into: [:max :number | max max: number].	nativeBitsPerComponent := ImageXObject nativeBitsPerComponentFor: maxBits.	componentMask := (1 bitShift: nativeBitsPerComponent) - 1.	components := (bitsPerComponents size to: 1 by: -1) collect: [:index |		(someBits bitShift: ((index - 1) * nativeBitsPerComponent) negated) bitAnd: componentMask].	values := OrderedCollection new: components size.	scale := ColorValue scalingValue.	components doWithIndex: [:value :index |		| dMin dMax |		dMin := anArray at: index * 2 - 1.		dMax := anArray at: index * 2.		values add: (((dMax - dMin) * value / componentMask + dMin) * scale) truncated].	^ColorValue scaledRed: values first scaledGreen: (values at: 2) scaledBlue: values last</body><body package="PDF Images">colorByteArrayFor: aColorValue	"&lt;ByteArray[3]&gt;"	^aColorValue asByteArray</body><body package="PDF Images">colorFromByteStream: aByteReadStream	"&lt;ColorValue&gt;"	^ColorValue fromBytes: (aByteReadStream next: 3)</body><body package="PDF Images">defaultDecodeArray	^#(0.0 1.0 0.0 1.0 0.0 1.0) asPDF</body><body package="PDF Colour">initialColourValues	^#(0.0 0.0 0.0)</body><body package="PDF Colour">numberOfComponents	^3</body><body package="PDF Images">paletteFor: anImageXObject	| colors |	(anImageXObject hasDecode or: [	anImageXObject bitsPerComponent = 8]) ifTrue: [		^FixedPalette newForDepths: anImageXObject depthsPerComponent].	colors := anImageXObject uniqueColorValues.	(colors size &gt; ((1 bitShift: 16) - 1) or: [	colors size * 6 &gt; (anImageXObject bytesPerImage - anImageXObject numberOfPixel)]) ifTrue: [			^FixedPalette newForDepths: anImageXObject depthsPerComponent].	^MappedPalette withColors: colors</body><body package="PDF Images">rgbBytesFrom: aByteArray	"&lt;ByteArray&gt;"	^aByteArray</body></methods><methods><class-id>Graphics.PDF.Header</class-id> <category>comparing</category><body package="PDF Files">= anObject	^self class = anObject class and: [	self version = anObject version]</body><body package="PDF Files">hash	^self version hash</body></methods><methods><class-id>Graphics.PDF.Header</class-id> <category>initialize-release</category><body package="PDF Files">initializeVersion: aVersion	version := aVersion</body></methods><methods><class-id>Graphics.PDF.Header</class-id> <category>accessing</category><body package="PDF Files">pdfVersion	^self version</body><body package="PDF Files">version	"&lt;Version&gt;"	^version</body></methods><methods><class-id>Graphics.PDF.Header</class-id> <category>writing</category><body package="PDF Files">writeOn: aStream indent: integer	aStream		nextPut: $%;		nextPutAll: self version pdfSource</body></methods><methods><class-id>Graphics.PDF.Header class</class-id> <category>instance creation</category><body package="PDF Files">version: aVersion	| inst |	inst := self new.	inst initializeVersion: aVersion.	^inst</body></methods><methods><class-id>Graphics.PDF.ObjectRead</class-id> <category>accessing</category><body package="PDF Files">object	"&lt;PDFObject&gt;"	^object</body><body package="PDF Files">reference	"&lt;Reference&gt;"	^reference</body></methods><methods><class-id>Graphics.PDF.ObjectRead</class-id> <category>initialize-release</category><body package="PDF Files">initializeReference: aReference object: aPDFObject	reference := aReference.	object := aPDFObject</body></methods><methods><class-id>Graphics.PDF.ObjectRead class</class-id> <category>instance creation</category><body package="PDF Files">reference: aReference object: aPDFObject	| inst |	inst := self new.	inst initializeReference: aReference object: aPDFObject.	^inst</body></methods><methods><class-id>Graphics.CmykColor</class-id> <category>printing</category><body package="PDF Colour">printOn: stream	stream		nextPutAll: self class name asString;		space;		nextPutAll: self asPsComment</body><body package="PDF Colour">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer optional: 'name' value: name).	args add: (printer constant: 'cyan' value: self cyan).	args add: (printer constant: 'magenta' value: self magenta).	args add: (printer constant: 'yellow' value: self yellow).	args add: (printer constant: 'black' value: self black).	args add: (printer optional: 'rgb' value: rgb).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.CmykColor</class-id> <category>converting</category><body package="PDF Colour">asArray	"&lt;Array4 of: Number&gt;	Array of 4 numbers between 0.0 (zero concentration) and 1.0 (maximum concentration) suitable for PDF DeviceCMYK"	^Array		with: self cyan		with: self magenta		with: self yellow		with: self black</body><body package="PDF Colour">asCMY	"&lt;Array3 of: Number [0..1]&gt;"	| c blackInv m y |	blackInv := 1 - self black.	self isMonochrome ifTrue: [		^Array			with: blackInv			with: blackInv			with: blackInv].	self black = 1.0 ifTrue: [		^#(0 0 0)].	c := self cyan * blackInv.	m := self magenta * blackInv.	y := self yellow * blackInv.	^Array		with: c + self black		with: m + self black		with: y + self black</body><body package="PDF Colour">asCmykColor	"&lt;CmykColor&gt;"	^self</body><body package="PDF Colour">asColorRef	"&lt;Integer&gt;"	^self asColorValue asColorRef</body><body package="PDF Colour">asColorValue	"&lt;ColorValue&gt;"	| cmy |	rgb ifNotNil: [:rgbBytes |		^ColorValue red: (rgbBytes at: 1) green: (rgbBytes at: 2) blue: (rgbBytes at: 3) range: 255].	self cyan + self magenta + self yellow = 0 ifTrue: [		^ColorValue brightness: 1 - self black].	self black = 1.0 ifTrue: [		^ColorValue black].	cmy := self asCMY.	^ColorValue cyan: (cmy at: 1) magenta: (cmy at: 2) yellow: (cmy at: 3)</body><body package="PDF Colour">asGrayValue	"&lt;Number&gt;	between 0.0 (Black) and 1.0 (White) suitable for PDF DeviceGray"	self isMonochrome ifFalse: [		^self error: 'no grayscale color'].	^1.0 - self black</body><body package="PDF Colour">asPDFArray	"&lt;Array4 of: Number&gt;	Array of 4 numbers between 0.0 (zero concentration) and 1.0 (maximum concentration) suitable for PDF DeviceCMYK"	^Array		with: self cyan		with: self magenta		with: self yellow		with: self black</body><body package="PDF Colour">asPsComment	"&lt;String&gt;	a string suitable for eps header"	| wst |	wst := WriteStream on: (String new: 20).	wst		nextPutAll: (self asPsNumber: self cyan);		space;		nextPutAll: (self asPsNumber: self magenta);		space;		nextPutAll: (self asPsNumber: self yellow);		space;		nextPutAll: (self asPsNumber: self black);		space;		nextPutAll: self psName.	^wst contents</body><body package="PDF Colour">asPsNumber: aNumber	"&lt;String&gt;	a string suitable for eps header"	^(aNumber isInteger		ifTrue: [aNumber]		ifFalse: [aNumber asFloat]) printString</body><body package="PDF Colour">blendWith: aCmykColor	"DOES NOT WORK - need to study CMYK math"	"Answer a new CmykColor which is a 50% blend of the receiver and the	supplied CmykColor."	"Simply interpolates in CMYK space."	^self class		cyan: (self cyan + aCmykColor cyan) / 2		magenta: (self magenta + aCmykColor magenta) / 2		yellow: (self yellow + aCmykColor yellow) / 2		black: (self black + aCmykColor black) / 2</body><body package="PDF Colour">computedRGB	"&lt;ByteArray3 of: Number [0..255]&gt;"	^self asColorValue asByteArray</body><body package="PDF Colour">psName	"&lt;String&gt;	a string suitable for PostScript sources"	| wst |	wst := WriteStream on: (String new: 10).	wst		nextPut: $(;		nextPutAll: self nameForPostScript;		nextPut: $).	^wst contents</body></methods><methods><class-id>Graphics.CmykColor</class-id> <category>testing</category><body package="PDF Colour">isMonochrome	^self cyan isZero and: [	self magenta isZero and: [	self yellow isZero]]</body></methods><methods><class-id>Graphics.CmykColor</class-id> <category>accessing</category><body package="PDF Colour">black	"&lt;Number[0..1]&gt;"	^black</body><body package="PDF Colour">cyan	"&lt;Number[0..1]&gt;"	^cyan</body><body package="PDF Colour">fillColourSetter	self isMonochrome ifTrue: [		^PDF.SetNonStrokingGray with: self asGrayValue].	^PDF.SetNonStrokingCMYK operands: self asPDFArray</body><body package="PDF Colour">magenta	"&lt;Number[0..1]&gt;"	^magenta</body><body package="PDF Colour">name	"&lt;String&gt;"	^name ifNil: [String new]</body><body package="PDF Colour">nameForPostScript	"&lt;String&gt;"	self name isEmpty ifTrue: [		^self syntheticName].	^self name</body><body package="PDF Colour">rgb	"&lt;ByteArray3&gt;	optional - can have a custom RGB color attached"	^rgb ifNil: [self computedRGB]</body><body package="PDF Colour">strokeColourSetter	self isMonochrome ifTrue: [		^PDF.SetStrokingGray with: self asGrayValue].	^PDF.SetStrokingCMYK operands: self asPDFArray</body><body package="PDF Colour">syntheticName	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 10).	wst		nextPutAll: (self cyan * 100) rounded printString;		nextPut: $c;		nextPutAll: (self magenta * 100) rounded printString;		nextPut: $m;		nextPutAll: (self yellow * 100) rounded printString;		nextPut: $y;		nextPutAll: (self black * 100) rounded printString;		nextPut: $k.	^wst contents</body><body package="PDF Colour">yellow	"&lt;Number[0..1]&gt;"	^yellow</body></methods><methods><class-id>Graphics.CmykColor</class-id> <category>initialize-release</category><body package="PDF Colour">initializeName: nameString cyan: cyanNumber magenta: magentaNumber yellow: yellowNumber black: blackNumber rgb: rgbByteArray	(nameString notNil and: [	self name ~= nameString]) ifTrue: [			name := nameString].	cyan := cyanNumber.	magenta := magentaNumber.	yellow := yellowNumber.	black := blackNumber.	(rgbByteArray notNil and: [	self rgb ~= rgbByteArray]) ifTrue: [			rgb := rgbByteArray].	self beImmutable</body></methods><methods><class-id>Graphics.CmykColor class</class-id> <category>instance creation optional</category><body package="PDF Colour">cyan: cyanNumber magenta: magentaNumber yellow: yellowNumber black: blackNumber	| inst |	inst := self new.	inst		initializeName: nil		cyan: cyanNumber		magenta: magentaNumber		yellow: yellowNumber		black: blackNumber		rgb: nil.	^inst</body><body package="PDF Colour">cyan: cyanNumber magenta: magentaNumber yellow: yellowNumber black: blackNumber rgb: rgbByteArray	| inst |	inst := self new.	inst		initializeName: nil		cyan: cyanNumber		magenta: magentaNumber		yellow: yellowNumber		black: blackNumber		rgb: rgbByteArray.	^inst</body><body package="PDF Colour">name: nameString cyan: cyanNumber magenta: magentaNumber yellow: yellowNumber black: blackNumber	| inst |	inst := self new.	inst		initializeName: nameString		cyan: cyanNumber		magenta: magentaNumber		yellow: yellowNumber		black: blackNumber		rgb: nil.	^inst</body></methods><methods><class-id>Graphics.CmykColor class</class-id> <category>instance creation</category><body package="PDF Colour">fromColorValue: aColorValue	aColorValue = ColorValue black ifTrue: [		^self black].	aColorValue isGray ifTrue: [		^self gray: 1 - aColorValue brightness].	^self		cyan: aColorValue cyan		magenta: aColorValue magenta		yellow: aColorValue yellow		black: 1 - aColorValue brightness		rgb: aColorValue asByteArray</body><body package="PDF Colour">gray: colorValueBrightness	colorValueBrightness &lt;= 0 ifTrue: [		^self white].	colorValueBrightness &gt;= 1 ifTrue: [		^self black].	^self cyan: 0 magenta: 0 yellow: 0 black: colorValueBrightness</body><body package="PDF Colour">name: nameString cyan: cyanNumber magenta: magentaNumber yellow: yellowNumber black: blackNumber rgb: rgbByteArray	| inst |	inst := self new.	inst		initializeName: nameString		cyan: cyanNumber		magenta: magentaNumber		yellow: yellowNumber		black: blackNumber		rgb: rgbByteArray.	^inst</body></methods><methods><class-id>Graphics.CmykColor class</class-id> <category>named instances</category><body package="PDF Colour">black	^self name: 'Black' cyan: 0 magenta: 0 yellow: 0 black: 1</body><body package="PDF Colour">white	^self name: 'White' cyan: 0 magenta: 0 yellow: 0 black: 0</body></methods><methods><class-id>Graphics.PDF.PaintShading</class-id> <category>accessing</category><body package="PDF Graphics Operations">resourceIn: aPageGraphics	^aPageGraphics resources Shading objectAt: self operands first content</body></methods><methods><class-id>Graphics.PDF.PaintShading class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Paint the shape and colour shading described by a shading dictionary, subject to the current clipping path. The current colour in the graphics state is neither used nor altered. The effect is different from that of painting a path using a shading pattern as the current colour.name is the name of a shading dictionary resource in the Shading subdictionary of the current resource dictionary. All coordinates in the shading dictionary are interpreted relative to the current user space. (By contrast, when a shading dictionary is used in a type 2 pattern, the coordinates are expressed in pattern space.) All colours are interpreted in the colour space identified by the shading dictionary’s ColorSpace entry. The Background entry, if present, is ignored.This operator should be applied only to bounded or geometrically defined shadings. If applied to an unbounded shading, it paints the shading’s gradient fill across the entire clipping region, which may be time-consuming'</body><body package="PDF Graphics Operations">operandTypes	^#(#('name' Name))</body><body package="PDF Graphics Operations">operatorName	^#sh</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_3</body></methods><methods><class-id>Graphics.PDF.LineJoin</class-id> <category>printing</category><body package="PDF Graphics">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.PDF.LineJoin</class-id> <category>accessing</category><body package="PDF Graphics">value	"&lt;Integer&gt;"	^value</body></methods><methods><class-id>Graphics.PDF.LineJoin</class-id> <category>initialize-release</category><body package="PDF Graphics">initializeValue: valueInteger	value := valueInteger.	self beImmutable</body></methods><methods><class-id>Graphics.PDF.LineJoin class</class-id> <category>instances</category><body package="PDF Graphics">bevel	^self value: 2</body><body package="PDF Graphics">miter	^self value: 0</body><body package="PDF Graphics">round	^self value: 1</body></methods><methods><class-id>Graphics.PDF.LineJoin class</class-id> <category>instance creation</category><body package="PDF Graphics">value: valueInteger	| inst |	inst := self new.	inst initializeValue: valueInteger.	^inst</body></methods><methods><class-id>Graphics.PDF.Type3</class-id> <category>accessing</category><body package="PDF Fonts">numberOfCharacters: aContentString	"&lt;Integer&gt;	aContentString can be a multibyte string"	^aContentString size</body><body package="PDF Fonts">stringWidth: aContentString	"&lt;Integer&gt; in glyph space	aContentString can be a multibyte string"	^aContentString content inject: 0		into: [:width :characterCode | width + (self widthAt: characterCode)]</body><body package="PDF Fonts">widthAt: aCharacterCode	| index |	index := aCharacterCode - self FirstChar asSmalltalkValue + 1.	(index between: 1 and: self Widths size) ifFalse: [		"illegal character"		^0].	^(self Widths at: index) asSmalltalkValue</body></methods><methods><class-id>Graphics.PDF.GraphicsStateOperation</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics</body><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	| object |	object := self newOperationObjectFor: aPageGraphics.	self applyTo: aPageGraphics.	object redundant: object state = aPageGraphics graphicsState.	aPageGraphics addObject: object</body></methods><methods><class-id>Graphics.PDF.SaveState</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	aPageGraphics pushCollector: IsolatedObject new.	aPageGraphics graphicsStateStack addLast: aPageGraphics graphicsState copy -&gt; indexInteger</body></methods><methods><class-id>Graphics.PDF.SaveState class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Save the current graphics state on the graphics state stack'</body><body package="PDF Graphics Operations">end	^RestoreState</body><body package="PDF Graphics Operations">operatorName	^#q</body></methods><methods><class-id>Graphics.PDF.CrossReference</class-id> <category>accessing</category><body package="PDF Files">generation	"&lt;Integer&gt;	generation number. 5-digit number in PDF"	^generation</body><body package="PDF Files">generationString	"&lt;String&gt;	5 digits padded with $0 at the beginning"	| numberString |	numberString := self generation printString.	^(ByteString new: 5 - numberString size withAll: $0) , numberString</body><body package="PDF Files">keyword	"&lt;String&gt;"	^self subclassResponsibility</body><body package="PDF Files">number	"&lt;Integer&gt;	the object number"	^number</body><body package="PDF Files">type	^self class type</body><body package="PDF Files">value	"&lt;Integer&gt;	offset or object number. 10-digit number in PDF"	^value</body><body package="PDF Files">valueString	"&lt;String&gt;	10 digits padded with $0 at the beginning"	| numberString |	numberString := self value printString.	^(ByteString new: 10 - numberString size withAll: $0) , numberString</body></methods><methods><class-id>Graphics.PDF.CrossReference</class-id> <category>writing</category><body package="PDF Files">asPdfString	"&lt;String&gt;	the PDF source for tests with cr instead of lf"	| wst |	wst := ByteString new writeStream.	self writeOn: wst indent: 0.	^wst contents</body><body package="PDF Files">pdfSource	"&lt;String&gt;	the object as PDF source"	| wst |	wst := Writer on: ByteString new.	self writeOn: wst indent: 0.	^wst contents</body><body package="PDF Files">writeOn: aPDFWritestream indent: integer	aPDFWritestream		nextPutAll: self valueString;		space;		nextPutAll: self generationString;		space;		nextPutAll: self keyword;		space;		cr</body></methods><methods><class-id>Graphics.PDF.CrossReference</class-id> <category>initialize-release</category><body package="PDF Files">initializeValue: valueInteger number: numberInteger generation: generationInteger	value := valueInteger.	number := numberInteger.	generation := generationInteger.	self beImmutable</body></methods><methods><class-id>Graphics.PDF.CrossReference</class-id> <category>printing</category><body package="PDF Files">printOn: aStream	aStream		nextPutAll: self valueString;		space;		nextPutAll: self generationString;		space;		nextPutAll: self keyword</body><body package="PDF Files">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'value' value: self value).	args add: (printer constant: 'number' value: self number).	args add: (printer constant: 'generation' value: self generation).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.PDF.CrossReference</class-id> <category>comparing</category><body package="PDF Files">matches: aPDFReference	^self number = aPDFReference number</body></methods><methods><class-id>Graphics.PDF.CrossReference</class-id> <category>reading</category><body package="PDF Files">readObjectWith: aFile	"&lt;PDF.Object&gt;"	^nil asPDF</body></methods><methods><class-id>Graphics.PDF.CrossReference class</class-id> <category>accessing</category><body package="PDF Files">type	"&lt;Integer&gt;	Each entry in a cross-reference stream shall have one or more fields, the first of which designates the entry’s type.	In PDF 1.5 through PDF 1.7, only types 0, 1, and 2 are allowed. Any other value shall be interpreted as a reference to the null object, thus permitting new entry types to be defined in the future."	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.CrossReference class</class-id> <category>instance creation</category><body package="PDF Files">asInteger: aByteArray	"&lt;Integer&gt;"	^aByteArray inject: 0 into: [:int :byte | int * 256 + byte]</body><body package="PDF Files">number: numberInteger field1: field1ByteArray field2: field2ByteArray field3: field3ByteArray	"this is called when creating an instance from a cross-reference stream"	| aType subclass |	aType := self asInteger: field1ByteArray.	subclass := self allSubclasses detect: [:aSubclass | aSubclass type = aType].	^subclass		value: (self asInteger: field2ByteArray)		number: numberInteger		generation: (self asInteger: field3ByteArray)</body><body package="PDF Files">subclassFor: aCharacter	"&lt;CrossReference class&gt;"	aCharacter == $n ifTrue: [		^UsedReference].	aCharacter == $f ifTrue: [		^FreeReference].	FileError raiseSignal: 'Wrong format of cross-reference'</body><body package="PDF Files">value: valueInteger number: numberInteger generation: generationInteger	| inst |	inst := self new.	inst initializeValue: valueInteger number: numberInteger generation: generationInteger.	^inst</body></methods><methods><class-id>Graphics.PDF.CrossReference class</class-id> <category>reading</category><body package="PDF Files">permittedLineEnds	"&lt;Collection of: String&gt;"	^Set		with: (ByteString			with: Character space			with: Character cr)		with: (ByteString			with: Character space			with: Character lf)		with: (ByteString			with: Character cr			with: Character lf)</body><body package="PDF Files">read: number from: aParser	"&lt;CrossReference&gt;"	| value generation subclass |	value := (aParser next: 10) asNumber.	aParser next = Character space ifFalse: [		ReadError raiseSignal: 'Wrong format of cross-reference'].	generation := (aParser next: 5) asNumber.	aParser next = Character space ifFalse: [		ReadError raiseSignal: 'Wrong format of cross-reference'].	subclass := self subclassFor: aParser next.	value isZero ifTrue: [		subclass := FreeReference].	(self permittedLineEnds includes: (aParser next: 2)) ifFalse: [		ReadError raiseSignal: 'Wrong format of cross-reference'].	^subclass value: value number: number generation: generation</body></methods><methods><class-id>Graphics.PDF.UsedReference</class-id> <category>testing</category><body package="PDF Files">isSameReference: anObject	^anObject isReferencedBy: self</body><body package="PDF Files">refersTo: aPDFReference	^self matches: aPDFReference</body></methods><methods><class-id>Graphics.PDF.UsedReference</class-id> <category>reading</category><body package="PDF Files">readObjectWith: aFile	"&lt;PDFObject&gt;"	^aFile parser pickObjectFor: self with: aFile</body></methods><methods><class-id>Graphics.PDF.UsedReference</class-id> <category>accessing</category><body package="PDF Files">keyword	^'n'</body></methods><methods><class-id>Graphics.PDF.UsedReference</class-id> <category>comparing</category><body package="PDF Files">matches: aPDFReference	^(super matches: aPDFReference) and: [	self generation = aPDFReference generation]</body></methods><methods><class-id>Graphics.PDF.UsedReference class</class-id> <category>accessing</category><body package="PDF Files">type	"Type 1 entries define objects that are in use but are not compressed (corresponding to n entries in a cross-reference table).	Field 2: The byte offset of the object, starting from the beginning of the file.	Field 3: The generation number of the object. Default value: 0."	^1</body></methods><methods><class-id>Graphics.PDF.StreamReference</class-id> <category>reading</category><body package="PDF Files">readObjectWith: aFile	"&lt;PDF.Object&gt;"	| objectStream |	objectStream := (aFile referenceAt: self value) referent.	^objectStream readAt: self indexInObjectStream with: aFile</body></methods><methods><class-id>Graphics.PDF.StreamReference</class-id> <category>accessing</category><body package="PDF Files">generation	^0</body><body package="PDF Files">indexInObjectStream	^generation</body></methods><methods><class-id>Graphics.PDF.StreamReference</class-id> <category>printing</category><body package="PDF Files">printOn: aStream	aStream		nextPutAll: self value printString;		nextPutAll: ' 0 R @ ';		nextPutAll: self indexInObjectStream printString</body></methods><methods><class-id>Graphics.PDF.StreamReference class</class-id> <category>accessing</category><body package="PDF Files">type	"Type 2 entries define compressed objects.	Field 2: The object number of the object stream in which this object is stored. (The generation number of the object stream shall be implicitly 0.)	Field 3: The index of this object within the object stream."	^2</body></methods><methods><class-id>Graphics.PDF.ClosePath class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Close the current subpath by appending a straight line segment from the current point to the starting point of the subpath. If the current subpath is already closed, h shall do nothing.This operator terminates the current subpath. Appending another segment to the current path shall begin a new subpath, even if the new segment begins at the endpoint reached by the h operation'</body><body package="PDF Graphics Operations">operatorName	^#h</body></methods><methods><class-id>Graphics.PDF.SoundAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 16)</body><body package="PDF Interactive Features">subtype	^#Sound</body><body package="PDF Interactive Features">version	^2</body></methods><methods><class-id>Graphics.PDF.FlateEncodeStream</class-id> <category>private</category><body package="PDF Filter">finishOutput	"do nothing - the library does it all for us"</body><body package="PDF Filter">setupBufferAndLimits	"copied down to set #windowBits to a non-negative value to let the library write the zlib header and checksum.	The original implementation uses an undocumented feature of zlib to suppress the header and checksum generation"	| result |	interface := ZLibInterface newUsingEngineAllocator.	outputBuffer := ByteArray newInFixedSpace: BufferSize.	collection := ByteArray newInFixedSpace: BufferSize.	result := true		ifTrue: [interface					cDeflateInit2: interface zstream					level: self compressionLevel					method: interface Z_DEFLATED					windowBits: interface MAX_WBITS					memLevel: interface DEF_MEM_LEVEL					strategy: interface Z_DEFAULT_STRATEGY					version: interface version					streamSize: interface z_stream dataSize]		ifFalse:			[interface deflateInit: self compressionLevel].	 result ~= interface Z_OK ifTrue:		[self error: 'zlib deflateInit: initialization failed'].	interface next_out: outputBuffer fixedHeapAddress; avail_out: BufferSize.	position := 0.	readLimit := -1.	writeLimit  := BufferSize</body><body package="PDF Filter">writeHeader	"do nothing - the library does it all for us"</body></methods><methods><class-id>Graphics.PDF.Trailer</class-id> <category>accessing</category><body package="PDF Files">firstPage	"&lt;Page&gt;"	^self Root firstPage</body></methods><methods><class-id>Graphics.PDF.Trailer</class-id> <category>tracing</category><body package="PDF Files">allReferencesDo: oneArgumentBlock	"executes oneArgumentBlock with all unique reachable references"	self tracedReferences: OrderedCollection new do: oneArgumentBlock</body></methods><methods><class-id>Graphics.PDF.Trailer</class-id> <category>writing</category><body package="PDF Files">addFileIdentifierWithFile: aFilename andSize: anInteger id: previousFileIdentifierOrNil	(self hashForFilename: aFilename andSize: anInteger) ifNotNil: [:hashString |		| previousID |		previousID := previousFileIdentifierOrNil ifNotNil: #permanentID.		self			at: #ID			put: (FileIdentifier on: (Array				with: (previousID ifNil: [					hashString])				with: hashString))]</body><body package="PDF Files">hashForFilename: aFilename andSize: filesizeSoFar	"&lt;PDF.String | nil&gt;"	| wst |	self Info CreationDate ifNil: [		^nil].	wst := Writer on: ByteString new.	self Info CreationDate writeOn: wst indent: 0.	wst		cr;		nextPutAll: aFilename asString asPDF asPdfString;		cr;		nextPutAll: filesizeSoFar printString;		cr.	self Info writeOn: wst indent: 0.	^String content: (Security.MD5 hash: wst contents)</body><body package="PDF Files">writeOn: aStream indent: integer	aStream		nextPutAll: 'trailer';		cr.	super writeOn: aStream indent: integer</body></methods><methods><class-id>Graphics.PDF.Trailer</class-id> <category>printing</category><body package="PDF Files">printOn: aStream	aStream		nextPutAll: self class name asString;		nextPutAll: ' &lt;&lt; ';		nextPutAll: self size printString;		nextPutAll: ' &gt;&gt;'</body></methods><methods><class-id>Graphics.PDF.Trailer class</class-id> <category>instance creation</category><body package="PDF Files">readWith: aFile from: aParser	"&lt;Trailer&gt;"	aParser expectToken: #trailer.	aParser expectToken: '&lt;&lt;'.	^super readWith: aFile from: aParser</body></methods><methods><class-id>Graphics.PDF.Trailer class</class-id> <category>accessing</category><body package="PDF Files">keys	"&lt;SequenceableCollection of: String&gt;	possible keys of the Trailer dictionary"	^#(#Size #Prev #Root #Encrypt #Info #ID #XRefStm)</body></methods><methods><class-id>Graphics.PDF.FillEvenOddAndStroke class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Fill and then stroke the path, using the even-odd rule to determine the region to fill. This operator shall produce the same result as B, except that the path is filled as if with f* instead of f'</body><body package="PDF Graphics Operations">operatorName	^#'B*'</body></methods><methods><class-id>Graphics.PDF.Type1</class-id> <category>accessing</category><body package="PDF Fonts">addWinAnsiEncodingWith: aFont	| attributes |	attributes := aFont pdfWinAnsiEncodingAttributesWith: self usedExtraGlyphs.	attributes keysAndValuesDo: [:key :value | self at: key put: value]</body><body package="PDF Fonts">newCodeForExtraGlyph	"&lt;Integer&gt;"	| usedCodes |	usedCodes := self usedExtraGlyphs values asSet.	^#(31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 8 7 6 5 4 3 2 1) detect: [:code |		(usedCodes includes: code) not]</body><body package="PDF Fonts">numberOfCharacters: aContentString	"&lt;Integer&gt;	aContentString can be a multibyte string"	^aContentString size</body><body package="PDF Fonts">postScriptName	| string |	string := self BaseFont content.	(((string first: 6) allSatisfy: #isUppercase) and: [	(string at: 7) = $+]) ifTrue: [			^string copyFrom: 8 to: string size].	^string</body><body package="PDF Fonts">stringWidth: aContentString	"&lt;Integer&gt; in glyph space	aContentString can be a multibyte string"	^aContentString content inject: 0		into: [:width :characterCode | width + (self widthAt: characterCode)]</body><body package="PDF Fonts">usedExtraGlyphs	"&lt;OrderedDictionary key: Glyph value: Integer&gt;"	^usedExtraGlyphs ifNil: [usedExtraGlyphs := OrderedDictionary new]</body><body package="PDF Fonts">widthAt: aCharacterCode	| index |	index := aCharacterCode - self FirstChar asSmalltalkValue + 1.	(index between: 1 and: self Widths size) ifFalse: [		"illegal character"		^0].	^(self Widths at: index) asSmalltalkValue</body></methods><methods><class-id>Graphics.PDF.GraphicsCollector</class-id> <category>accessing</category><body package="PDF Graphics">allOperations	^self operations</body><body package="PDF Graphics">asPdfString	^self pdfSource</body><body package="PDF Graphics">object	^self</body><body package="PDF Graphics">objects	"&lt;SequenceableCollection of: GraphicsObject&gt;"	^objects ifNil: [objects := OrderedCollection new]</body><body package="PDF Graphics">operations	"&lt;SequenceableCollection of: Operation&gt;"	| operations |	operations := OrderedCollection new.	self objects do: [:object | operations addAll: object allOperations].	^operations</body><body package="PDF Graphics">pdfVersion	"&lt;PDFVersion&gt;	the minimal version for this object with its features"	^self operations inject: Version pdf1_0 into: [:max :op | max max: op pdfVersion]</body><body package="PDF Graphics">resource	^nil</body></methods><methods><class-id>Graphics.PDF.GraphicsCollector</class-id> <category>writing</category><body package="PDF Graphics">pdfSource	"&lt;String&gt;"	| wst |	wst := WriteStream on: Core.String new.	self pdfSourceOn: wst.	^wst contents</body><body package="PDF Graphics">pdfSourceOn: aStream	aStream		nextPutAll: self prefix;		cr.	self objects do: [:object | aStream nextPutAll: object pdfSource]		separatedBy: [aStream cr].	aStream		cr;		nextPutAll: self postfix</body><body package="PDF Graphics">postfix	"&lt;String&gt;"	^''</body><body package="PDF Graphics">prefix	"&lt;String&gt;"	^''</body></methods><methods><class-id>Graphics.PDF.GraphicsCollector</class-id> <category>actions</category><body package="PDF Graphics">addObject: aGraphicsObjectOrCollector	self objects add: aGraphicsObjectOrCollector</body></methods><methods><class-id>Graphics.PDF.MarkedObject</class-id> <category>accessing</category><body package="PDF Graphics">properties	^properties</body><body package="PDF Graphics">tag	^tag</body></methods><methods><class-id>Graphics.PDF.MarkedObject</class-id> <category>writing</category><body package="PDF Graphics">postfix	^'EMC'</body><body package="PDF Graphics">prefix	self properties ifNil: [^self tag pdfSource , ' BMC'].	^self tag pdfSource , ' ' , self properties pdfSource , ' BDC'</body></methods><methods><class-id>Graphics.PDF.MarkedObject</class-id> <category>initialize-release</category><body package="PDF Graphics">initializeTag: aName properties: aDictionary	tag := aName.	properties := aDictionary</body></methods><methods><class-id>Graphics.PDF.MarkedObject class</class-id> <category>instance creation</category><body package="PDF Graphics">tag: aName	| inst |	inst := self new.	inst initializeTag: aName properties: nil.	^inst</body><body package="PDF Graphics">tag: aName properties: aDictionary	| inst |	inst := self new.	inst initializeTag: aName properties: aDictionary.	^inst</body></methods><methods><class-id>Graphics.PDF.Fill class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Fill the path, using the nonzero winding number rule to determine the region to fill. Any subpaths that are open shall be implicitly closed before being filled'</body><body package="PDF Graphics Operations">operatorName	^#f</body></methods><methods><class-id>Graphics.PDF.ShadingStream class</class-id> <category>instance creation</category><body package="PDF Shading">empty	| inst |	inst := self new.	inst at: #ShadingType put: self shadingType.	^inst</body></methods><methods><class-id>Graphics.PDF.ShadingStream class</class-id> <category>accessing</category><body package="PDF Shading">isTypeFor: anOrderedDictionary	| typeEntry |	typeEntry := anOrderedDictionary at: #ShadingType ifAbsent: [		^false].	^self shadingType asPDF = typeEntry asPDF</body><body package="PDF Shading">resourcePrefix	^'Sh'</body><body package="PDF Shading">resourceType	"&lt;Symbol&gt;	the name of a /Resources key"	^#Shading</body><body package="PDF Shading">shadingType	"&lt;Integer&gt;	-1 never matches"	^-1</body><body package="PDF Shading">version	^3</body></methods><methods><class-id>Graphics.PDF.FreeFormGouraudShadedMesh class</class-id> <category>accessing</category><body package="PDF Shading">shadingType	^4</body></methods><methods><class-id>Graphics.PDF.SetStrokingGray</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #colorSpaceStroking put: DeviceGray new.	aPageGraphics graphicsState at: #colorStroking put: self operands</body></methods><methods><class-id>Graphics.PDF.SetStrokingGray class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the stroking colour space to DeviceGray (or the DefaultGray colour space) and set the gray level to use for stroking operations. gray shall be a number between 0.0 (black) and 1.0 (white)'</body><body package="PDF Graphics Operations">operandTypes	^#(#('gray' Number))</body><body package="PDF Graphics Operations">operatorName	^#G</body></methods><methods><class-id>Graphics.PDF.UndefinedType</class-id> <category>testing</category><body package="PDF Complex Objects">subsumesObject: aPDFObject	^true</body><body package="PDF Complex Objects">subsumesReference: aPDFReference	^true</body></methods><methods><class-id>Graphics.PDF.UndefinedType</class-id> <category>accessing</category><body package="PDF Complex Objects">name	^self pdfType printString</body><body package="PDF Complex Objects">pdfType	"&lt;Symbol&gt;	the name of an undefined class"	^super pdfType</body></methods><methods><class-id>Graphics.PDF.TrapNetAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 21)</body><body package="PDF Interactive Features">subtype	^#TrapNet</body><body package="PDF Interactive Features">version	^3</body></methods><methods><class-id>Graphics.PDF.FunctionDictionary class</class-id> <category>instance creation</category><body package="PDF Data Structures">empty	| inst |	inst := self new.	inst at: #FunctionType put: self functionType.	^inst</body></methods><methods><class-id>Graphics.PDF.FunctionDictionary class</class-id> <category>accessing</category><body package="PDF Data Structures">functionType	"&lt;Integer&gt;	-1 never matches"	^-1</body><body package="PDF Data Structures">isTypeFor: anOrderedDictionary	| typeEntry |	typeEntry := anOrderedDictionary at: #FunctionType ifAbsent: [		^false].	^self functionType asPDF = typeEntry</body><body package="PDF Data Structures">version	^3</body></methods><methods><class-id>Graphics.PDF.NextLineRelative</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState		nextLineBy: self operands first content @ self operands last content</body></methods><methods><class-id>Graphics.PDF.NextLineRelative class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Move to the start of the next line, offset from the start of the current line by (tx, ty). tx and ty shall denote numbers expressed in unscaled text space units. More precisely, this operator shall perform these assignments                    [ 1  0  0 ]Tm := Tlm := [  0  1  0 ] * Tlm                    [ tx ty 1 ]'</body><body package="PDF Graphics Operations">operandTypes	^#(#('x' Number) #('y' Number))</body><body package="PDF Graphics Operations">operatorName	^#Td</body></methods><methods><class-id>Graphics.PDF.Catalog</class-id> <category>accessing</category><body package="PDF Document">firstPage	"&lt;Page&gt;"	^self Pages firstPage</body><body package="PDF Document">pageAt: anInteger	"&lt;Page&gt;	throws exception when out of bounds"		^self Pages pageAt: anInteger</body></methods><methods><class-id>Graphics.PDF.Catalog</class-id> <category>actions</category><body package="PDF Document">addPage: aPage	"add aPage as last element of the top Pages.	Convenience method. The use of #addPageTree: is preferred"	self addPageTree: aPage</body><body package="PDF Document">addPageTree: aPageTree	"add aPageTree (a Page or a Pages) as last element of the top Pages"	self Pages addPageTree: aPageTree withParent: (self at: #Pages)</body></methods><methods><class-id>Graphics.PDF.Catalog</class-id> <category>enumerating</category><body package="PDF Document">pagesDo: oneArgumentBlock	self Pages pagesDo: oneArgumentBlock</body></methods><methods><class-id>Graphics.PDF.Catalog class</class-id> <category>instance creation</category><body package="PDF Document">empty	| inst |	inst := super empty.	inst at: #Pages put: Pages empty newReference.	^inst</body></methods><methods><class-id>Graphics.PDF.Encryption class</class-id> <category>accessing</category><body package="PDF Files">version	^1</body></methods><methods><class-id>Graphics.PDF.Encryption class</class-id> <category>instance creation</category><body package="PDF Files">on: aDictionary	(aDictionary at: #Filter) = #Standard asPDF ifTrue: [		^StandardEncryption content: aDictionary].	^self content: aDictionary</body></methods><methods><class-id>Graphics.PDF.PolygonPolyline class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 9)</body><body package="PDF Interactive Features">version	^5</body></methods><methods><class-id>Graphics.PDF.PolyLineAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">subtype	^#PolyLine</body></methods><methods><class-id>Graphics.PDF.ExplicitDestination class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 3 2 2)</body><body package="PDF Interactive Features">maxNumberOfAttributes	^6</body><body package="PDF Interactive Features">numberOfAttributes	^2</body></methods><methods><class-id>Graphics.PDF.GraphicsObjectWithResource</class-id> <category>accessing</category><body package="PDF Graphics">documentationText	^self operation documentationText</body><body package="PDF Graphics">listIcon	^self operation class toolListIcon</body><body package="PDF Graphics">operation	^self operations first</body><body package="PDF Graphics">resource	^resource</body><body package="PDF Graphics">resource: anObject	resource := anObject</body><body package="PDF Graphics">treeChildren	^#()</body></methods><methods><class-id>Graphics.PDF.GraphicsObjectWithResource</class-id> <category>testing</category><body package="PDF Graphics">hasTreeChildren	^false</body></methods><methods><class-id>Graphics.PDF.GraphicsObjectWithResource</class-id> <category>initialize-release</category><body package="PDF Graphics">initializeOperations: someOperations state: aGraphicsState resource: aPDFObject	self initializeOperations: someOperations state: aGraphicsState.	resource := aPDFObject</body></methods><methods><class-id>Graphics.PDF.GraphicsObjectWithResource class</class-id> <category>instance creation</category><body package="PDF Graphics">operations: someOperations state: aGraphicsState resource: aPDFObject	| inst |	inst := self new.	inst		initializeOperations: someOperations		state: aGraphicsState		resource: aPDFObject.	^inst</body></methods><methods><class-id>Graphics.PDF.OperationObject</class-id> <category>accessing</category><body package="PDF Graphics">redundant	"&lt;Boolean&gt;"	^redundant ifNil: [false]</body><body package="PDF Graphics">redundant: aBoolean	redundant := aBoolean</body></methods><methods><class-id>Graphics.PDF.Indexed</class-id> <category>accessing</category><body package="PDF Images">bitsFor: aColorValue withSizes: bitsPerComponents	"&lt;Integer&gt;	the bits stored in the pixel array.	If aColorValue is not found, it is added"	| colorBytes hival bytes numberOfComponents |	colorBytes := self base colorByteArrayFor: aColorValue.	hival := self hival asSmalltalkValue.	bytes := self lookup content.	numberOfComponents := self base numberOfComponents.	0 to: hival do: [:index |		| byteIndex paletteBytes |		byteIndex := index * numberOfComponents + 1.		paletteBytes := bytes copyFrom: byteIndex to: byteIndex + numberOfComponents - 1.		paletteBytes = colorBytes ifTrue: [			^index]].	hival &gt;= 255 ifTrue: [		"This error should be cought on a higher level to select an image format with more colors"		^SubscriptOutOfBoundsError raiseSignal: 'The color cannot be added: the indexed colour space is full.'].	self at: 3 put: hival + 1.	self at: 4 put: (self lookup class content: bytes , colorBytes).	^self hival asSmalltalkValue</body><body package="PDF Images">bytesAt: zeroBasedIndex	"&lt;ByteArray&gt;"	| numberOfComponents |	numberOfComponents := self base numberOfComponents.	^self lookup content		copyFrom: zeroBasedIndex * numberOfComponents + 1		to: (zeroBasedIndex + 1) * numberOfComponents</body><body package="PDF Images">bytesFromMappedPalette: aMappedPalette	^self base bytesFromMappedPalette: aMappedPalette</body><body package="PDF Images">colorAt: zeroBasedIndex withSizes: bitsPerComponents decodeWith: anArray	"&lt;ColorValue&gt;"	(#(#DeviceRGB #DeviceGray) includes: self base asSmalltalkValue) ifFalse: [		^self error: 'only /DeviceRGB and /DeviceGray are supported as base colour space'].	self base asSmalltalkValue = #DeviceGray ifTrue: [		^ColorValue fromByte: (self bytesAt: zeroBasedIndex) first].	^ColorValue fromBytes: (self bytesAt: zeroBasedIndex)</body><body package="PDF Images">defaultDecodeArray	^(Array with: 0 with: self hival) asPDF</body><body package="PDF Colour">initialColourValues	^#(0)</body><body package="PDF Colour">numberOfColors	"&lt;Integer&gt;"	^self hival asSmalltalkValue + 1</body><body package="PDF Colour">numberOfComponents	^1</body><body package="PDF Images">paletteFor: anImageXObject	| colors rst |	colors := OrderedCollection new: self numberOfColors.	rst := self lookup asByteArray readStream.	[rst atEnd] whileFalse: [colors add: (self base colorFromByteStream: rst)].	^MappedPalette withColors: colors</body><body package="PDF Images">procSet	^#ImageI</body><body package="PDF Images">rgbBytes	"&lt;ByteArray&gt;	uses 3 bytes per color"	^self base rgbBytesFrom: self lookup asByteArray</body></methods><methods><class-id>Graphics.PDF.Indexed</class-id> <category>initialize-release</category><body package="PDF Images">initializeColorsFrom: aMappedPalette	self at: 3 put: aMappedPalette size - 1.	"need to create the PDF string directly. Otherwise, CR(13) will be replaced by LF (10)!"	self at: 4 put: (EncodedString string: (self bytesFromMappedPalette: aMappedPalette) asByteString)</body><body package="PDF Images">initializeForColorspace: aColorspace	self at: 2 put: aColorspace.	self at: 3 put: -1.	self at: 4 put: (EncodedString string: ByteString new)</body><body package="PDF Colour">initializeWithColors: someColors	| wst |	self at: 2 put: someColors first colorspace.	self at: 3 put: someColors size - 1.	wst := (ByteArray new: someColors size * self base numberOfComponents) writeStream.	someColors do: [:colorValue | wst nextPutAll: colorValue asByteArray].	self at: 4 put: wst contents asByteString</body></methods><methods><class-id>Graphics.PDF.Indexed class</class-id> <category>accessing</category><body package="PDF Colour">numberOfAttributes	^4</body></methods><methods><class-id>Graphics.PDF.Indexed class</class-id> <category>instance creation</category><body package="PDF Colour">newForColors: someColors	| inst |	inst := self empty.	inst initializeWithColors: someColors.	^inst</body><body package="PDF Images">newForColorspace: aColorspace	| inst |	inst := self empty.	inst initializeForColorspace: aColorspace.	^inst</body></methods><methods><class-id>Graphics.PDF.ZipFilter</class-id> <category>accessing</category><body package="PDF Filter">bitsPerComponent	"&lt;Integer&gt;	(May be used only if Predictor is greater than 1)	The number of bits used to represent each colour component in a sample.	Valid values are 1, 2, 4, 8, and (PDF 1.5) 16.	Default value: 8."	^bitsPerComponent ifNil: [8]</body><body package="PDF Filter">colors	"&lt;Integer&gt;	(May be used only if Predictor is greater than 1)	The number of interleaved colour components per sample.	Valid values are 1 to 4 (PDF 1.0) and 1 or greater (PDF 1.3).	Default value: 1."	^colors ifNil: [1]</body><body package="PDF Filter">columns	"&lt;Integer&gt;	(May be used only if Predictor is greater than 1)	The number of samples in each row.	Default value: 1."	^columns ifNil: [1]</body><body package="PDF Filter">decoded	self external isSignalledException ifTrue: [		^self external].	^self unpredicted: self predicted</body><body package="PDF Filter">encoded	self internal isSignalledException ifTrue: [		^self internal].	^self compressed: self predicted</body><body package="PDF Filter">minPdfVersion	^Version pdf1_0</body><body package="PDF Filter">pdfVersion	self predictor = 1 ifTrue: [		^self minPdfVersion].	self bitsPerComponent = 16 ifTrue: [		^Version pdf1_5].	self colors &gt; 4 ifTrue: [		^Version pdf1_3].	^self minPdfVersion</body><body package="PDF Filter">pixelDistance	"&lt;Integer&gt;	the horizontal distance in bytes between corresponding bytes of adjacent pixels"	self bitsPerComponent &lt; 8 ifTrue: [		^1].	^self colors * self bitsPerComponent // 8</body><body package="PDF Filter">predicted	"&lt;ByteString&gt;	Buffer for prediction"	^predicted ifNil: [		predicted := internal ifNotNil: [self predicted: self internal] ifNil: [			self decompressed: self external]]</body><body package="PDF Filter">predictor	"&lt;Integer&gt;	A code that selects the predictor algorithm, if any.	If the value of this entry is 1, the filter shall assume that the normal algorithm was used to encode the data, without prediction.	If the value is greater than 1, the filter shall assume that the data was differenced before being encoded, and Predictor selects the predictor algorithm.	Default value: 1."	^predictor ifNil: [1]</body><body package="PDF Filter">predictorAt: anInteger	"&lt;PNGPredictor&gt;"	^self predictors at: anInteger ifAbsentPut: [		(PNGPredictor subclassFor: anInteger) offsetLeft: self pixelDistance]</body><body package="PDF Filter">predictors	"&lt;Dictionary key: Integer value: PNGPredictor&gt;	Cache for row predictors. The key can be between 0 and 4"	^predictors ifNil: [predictors := IdentityDictionary new]</body></methods><methods><class-id>Graphics.PDF.ZipFilter</class-id> <category>filtering</category><body package="PDF Filter">compressed: aByteString	"&lt;ByteString&gt;"	^self subclassResponsibility</body><body package="PDF Filter">decompressed: aByteString	"&lt;ByteString&gt;"	^self subclassResponsibility</body><body package="PDF Filter">predicted: aByteString	"&lt;ByteString&gt;"	| bytesPerRow rows rst wst |	self predictor = 1 ifTrue: [		^aByteString].	self predictor = 2 ifTrue: [		^(TIFFPredictor newFor: self) predicted: aByteString].	"we deal only with PNG predictors"	bytesPerRow := self colors * self bitsPerComponent * self columns // 8.	rows := OrderedCollection new: aByteString size // bytesPerRow.	rst := aByteString asByteArray readStream.	[rst atEnd] whileFalse: [rows add: (rst next: bytesPerRow)].	wst := (ByteArray new: aByteString size + rows size) writeStream.	rows inject: (ByteArray new: bytesPerRow + 1 withAll: 0) into: [:upperRow :row |		| rowPredictor predictedRow predictorType |		predictorType := self predictor - 10.		predictorType = 5 ifTrue: [			predictorType := 0].		rowPredictor := self predictorAt: predictorType.		wst nextPut: rowPredictor type.		predictedRow := rowPredictor predict: row withUpperRow: upperRow.		wst nextPutAll: predictedRow.		row].	^wst contents asByteString</body><body package="PDF Filter">unpredicted: aByteString	"&lt;ByteString&gt;"	| bytesPerRow rows rst wst |	self predictor = 1 ifTrue: [		^aByteString].	self predictor = 2 ifTrue: [		^(TIFFPredictor newFor: self) unpredicted: aByteString].	"we deal only with PNG predictors"	bytesPerRow := self colors * self bitsPerComponent * self columns // 8 + 1.	rows := OrderedCollection new: aByteString size // bytesPerRow.	rst := aByteString asByteArray readStream.	[rst atEnd] whileFalse: [rows add: (rst next: bytesPerRow)].	wst := (ByteArray new: aByteString size - rows size) writeStream.	rows inject: (ByteArray new: bytesPerRow - 1 withAll: 0) into: [:upperRow :row |		| rowPredictor unpredicted |		rowPredictor := self predictorAt: row first.		unpredicted := rowPredictor unpredict: (row allButFirst: 1) withUpperRow: upperRow.		wst nextPutAll: unpredicted.		unpredicted].	^wst contents asByteString</body></methods><methods><class-id>Graphics.PDF.ZipFilter</class-id> <category>initialize-release</category><body package="PDF Filter">initializeParameters: aDecodeParms	predictor := (aDecodeParms at: #Predictor ifAbsent: [		^self]) content.	colors := (aDecodeParms at: #Colors ifAbsent: [nil asPDF]) content.	bitsPerComponent := (aDecodeParms at: #BitsPerComponent ifAbsent: [nil asPDF]) content.	columns := (aDecodeParms at: #Columns ifAbsent: [nil asPDF]) content</body></methods><methods><class-id>Graphics.PDF.FlateDecode</class-id> <category>filtering</category><body package="PDF Filter">compressed: aByteString	| wst integerArray |	integerArray := aByteString asIntegerArray.	wst := (integerArray class new: aByteString size * 3) writeStream.	(FlateEncodeStream bestCompressionOn: wst)		nextPutAll: integerArray;		close.	^wst contents asByteString</body><body package="PDF Filter">decompressed: aByteString	^(FlateDecodeStream on: aByteString asByteArray) contents asByteString</body></methods><methods><class-id>Graphics.PDF.FlateDecode</class-id> <category>accessing</category><body package="PDF Filter">minPdfVersion	^Version pdf1_2</body></methods><methods><class-id>Graphics.PDF.Stroke class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Stroke the path'</body><body package="PDF Graphics Operations">operatorName	^#S</body></methods><methods><class-id>Graphics.PDF.SetStrokingColorSpace</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	| colorspace |	colorspace := (#(#DeviceGray #DeviceRGB #DeviceCMYK #Pattern)				includes: self operands first content)					ifTrue: [self operands first asType: (DirectType on: ColourSpace)]					ifFalse: [self resourceIn: aPageGraphics].	aPageGraphics graphicsState at: #colorSpaceStroking put: colorspace</body></methods><methods><class-id>Graphics.PDF.SetStrokingColorSpace</class-id> <category>accessing</category><body package="PDF Graphics Operations">resourceIn: aPageGraphics	(#(#DeviceGray #DeviceRGB #DeviceCMYK #Pattern)		includes: self operands first content)			ifFalse: 				[^aPageGraphics resources ColorSpace objectAt: self operands first content].	^nil</body></methods><methods><class-id>Graphics.PDF.SetStrokingColorSpace class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the current colour space to use for stroking operations. The operand name shall be a name object. If the colour space is one that can be specified by a name and no additional parameters (DeviceGray, DeviceRGB, DeviceCMYK, and certain cases of Pattern), the name may be specified directly. Otherwise, it shall be a name defined in the ColorSpace subdictionary of the current resource dictionary; the associated value shall be an array describing the colour space.The names DeviceGray, DeviceRGB, DeviceCMYK, and Pattern always identify the corresponding colour spaces directly; they never refer to resources in the ColorSpace subdictionary.The CS operator shall also set the current stroking colour to its initial value, which depends on the colour space:In a DeviceGray, DeviceRGB, CalGray, or CalRGB colour space, the initial colour shall have all components equal to 0.0.In a DeviceCMYK colour space, the initial colour shall be [0.0 0.0 0.0 1.0].In a Lab or ICCBased colour space, the initial colour shall have all components equal to 0.0 unless that falls outside the intervals specified by the space’s Range entry, in which case the nearest valid value shall be substituted.In an Indexed colour space, the initial colour value shall be 0.In a Separation or DeviceN colour space, the initial tint value shall be 1.0 for all colorants.In a Pattern colour space, the initial colour shall be a pattern object that causes nothing to be painted.'</body><body package="PDF Graphics Operations">operandTypes	^#(#('name' #Name))</body><body package="PDF Graphics Operations">operatorName	^#CS</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_1</body></methods><methods><class-id>Graphics.PDF.Textstream</class-id> <category>converting</category><body package="PDF Streams">asString	"&lt;Core.String&gt;	the value as a Smalltalk String; properly encoded to be displayed to humans.	Textstring takes care of the encoding"	^(Textstring on: self internal) asString</body></methods><methods><class-id>Graphics.PDF.Textstream class</class-id> <category>accessing</category><body package="PDF Streams">version	^5</body></methods><methods><class-id>Graphics.PDF.PageTree</class-id> <category>accessing</category><body package="PDF Document">contentWithoutCycles	| copy |	copy := super contentWithoutCycles.	copy removeKey: #Parent ifAbsent: nil.	^copy</body><body package="PDF Document">count	"&lt;Integer&gt;"	^self subclassResponsibility</body><body package="PDF Document">firstPage	"&lt;Page&gt;"	^self subclassResponsibility</body><body package="PDF Document">inherited: aSymbol	"&lt;PDF.Object&gt;	returns the object which MUST be present in the Parent chain.	If the attribute is absent, look for it in the parents.	Throw error if not found"	| pdf unique |	unique := 'unique'.	pdf := self content at: aSymbol ifAbsent: [unique].	pdf == unique ifFalse: [		^pdf object].	^(self Parent inherited: aSymbol) object</body><body package="PDF Document">numberOfPages	"&lt;Integer&gt;"	^self subclassResponsibility</body><body package="PDF Document">objectAt: aSymbol inheritOr: aBlock	"&lt;PDF.Object&gt;	returns the object.	If the attribute is absent, look for it in the parents.	If not found, answer the block value"	| pdf unique |	unique := 'unique'.	pdf := self content at: aSymbol ifAbsent: [unique].	pdf == unique ifFalse: [		^pdf object].	pdf := self Parent objectAt: aSymbol inheritOr: [		^aBlock value].	^pdf object</body><body package="PDF Document">pageAt: anInteger	"&lt;Page&gt;	throws exception when out of bounds"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.PageTree</class-id> <category>enumerating</category><body package="PDF Document">pagesDo: oneArgumentBlock	self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.PageTree</class-id> <category>comparing</category><body package="PDF Document">= anObject	^self class == anObject class and: [	self contentWithoutCycles = anObject contentWithoutCycles]</body><body package="PDF Document">hash	^self contentWithoutCycles hash</body></methods><methods><class-id>Graphics.PDF.Page</class-id> <category>accessing</category><body package="PDF Document">contentString	"&lt;String&gt;	all decoded content of Contents"	self Contents isNull ifTrue: [		^''].	self Contents isArray ifTrue: [		| wst |		wst := WriteStream on: Core.String new.		self Contents objects do: [:contents |			wst nextPutAll: (contents encrypted				ifTrue: ['']				ifFalse: [				contents internal])].		^wst contents].	self Contents encrypted ifTrue: [		^''].	^self Contents internal</body><body package="PDF Document">count	^1</body><body package="PDF Document">firstContents	"&lt;Contents&gt;"	self Contents isArray ifTrue: [^self Contents first].	^self Contents</body><body package="PDF Document">firstPage	^self</body><body package="PDF Document">graphicsInterpreter	"&lt;GraphicsInterpreter&gt;"	^GraphicsInterpreter on: self</body><body package="PDF Document">numberOfPages	^1</body><body package="PDF Document">pageAt: anInteger	anInteger = 1 ifFalse: [		^SubscriptOutOfBoundsError signalWith: anInteger].	^self</body></methods><methods><class-id>Graphics.PDF.Page</class-id> <category>enumerating</category><body package="PDF Document">pagesDo: oneArgumentBlock	oneArgumentBlock value: self</body></methods><methods><class-id>Graphics.PDF.Page</class-id> <category>testing</category><body package="PDF Document">isEncrypted	| firstContents |	firstContents := self firstContents.	^firstContents isNull not and: [	firstContents encrypted]</body></methods><methods><class-id>Graphics.PDF.Page class</class-id> <category>instance creation</category><body package="PDF Rendering">newInBounds: aRectangle colorspace: aColourSpace render: oneArgumentBlock	| renderer |	renderer := PageRenderer newOn: self empty bounds: aRectangle colorspace: aColourSpace.	renderer render: oneArgumentBlock.	^renderer product</body></methods><methods><class-id>Graphics.PDF.ThreeDActivation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(13 6 2)</body><body package="PDF Interactive Features">version	^6</body></methods><methods><class-id>Graphics.PDF.SetStrokingCMYK</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #colorSpaceStroking put: DeviceCMYK new.	aPageGraphics graphicsState at: #colorStroking put: self operands</body></methods><methods><class-id>Graphics.PDF.SetStrokingCMYK class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the stroking colour space to DeviceCMYK (or the DefaultCMYK colour space) and set the colour to use for stroking operations. Each operand shall be a number between 0.0 (zero concentration) and 1.0 (maximum concentration). The behaviour of this operator is affected by the overprint mode'</body><body package="PDF Graphics Operations">operandTypes	^#(#('c' #Number) #('m' #Number) #('y' #Number) #('k' #Number))</body><body package="PDF Graphics Operations">operatorName	^#K</body></methods><methods><class-id>Graphics.PDF.SetRenderingIntent</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #renderingIntent put: self operands first</body></methods><methods><class-id>Graphics.PDF.SetRenderingIntent class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the colour rendering intent in the graphics state'</body><body package="PDF Graphics Operations">operandTypes	^#(#('intent' Name))</body><body package="PDF Graphics Operations">operatorName	^#ri</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_1</body></methods><methods><class-id>Graphics.PDF.DirectType</class-id> <category>testing</category><body package="PDF Complex Objects">appliesToReference	^false</body><body package="PDF Complex Objects">isDirect	^true</body><body package="PDF Complex Objects">subsumesArray: aPDFArray	^self pdfType == PDFArray or: [	self subsumesObject: aPDFArray]</body><body package="PDF Complex Objects">subsumesDictionary: aPDFDictionary	^self pdfType == Dictionary or: [	self subsumesObject: aPDFDictionary]</body><body package="PDF Complex Objects">subsumesObject: aPDFObject	^self pdfType isSuperTypeOf: aPDFObject</body></methods><methods><class-id>Graphics.PDF.DirectType</class-id> <category>accessing</category><body package="PDF Complex Objects">name	^'!', self pdfType name asString</body><body package="PDF Complex Objects">specializedObject: aPDFObject	^self pdfType specialized: aPDFObject</body></methods><methods><class-id>Graphics.PDF.TextRise</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #textRise put: self operands first</body></methods><methods><class-id>Graphics.PDF.TextRise class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the text rise, Trise, to rise, which shall be a number expressed in unscaled text space units. Initial value: 0'</body><body package="PDF Graphics Operations">operandTypes	^#(#('rise' Number))</body><body package="PDF Graphics Operations">operatorName	^#Ts</body></methods><methods><class-id>Graphics.PDF.DeviceGray</class-id> <category>accessing</category><body package="PDF Images">bitsFor: aSimplePaint withSizes: bitsPerComponents	"&lt;Integer&gt;	the bits stored in the pixel array"	^(aSimplePaint asGrayValue * ((1 bitShift: bitsPerComponents first) - 1)) rounded</body><body package="PDF Images">bytesFromMappedPalette: aMappedPalette	| byteArray |	byteArray := ByteArray new: aMappedPalette size.	1 to: byteArray size do: [:index |		byteArray at: index put: ((aMappedPalette elementData at: index - 1 * 3 + 1) bitShift: -5)].	^byteArray</body><body package="PDF Images">colorAt: someBits withSizes: bitsPerComponents decodeWith: anArray	"&lt;ColorValue&gt;"	| mask dMin dMax brightness |	mask := (1 bitShift: bitsPerComponents first) - 1.	dMin := anArray first.	dMax := anArray last.	brightness := (((dMax - dMin) * someBits / mask + dMin) * ColorValue scalingValue) truncated.	^ColorValue scaledRed: brightness scaledGreen: brightness scaledBlue: brightness</body><body package="PDF Images">colorByteArrayFor: aColorValue	"&lt;ByteArray[1]&gt;"	^aColorValue asByteArray first: 1</body><body package="PDF Images">colorFromByteStream: aByteReadStream	"&lt;ColorValue&gt;"	^ColorValue fromBytes: (Array new: 3 withAll: aByteReadStream next)</body><body package="PDF Images">coverageAt: someBits withSizes: bitsPerComponents decodeWith: anArray	"&lt;CoverageValue&gt;	applies to masks.	The meaning of transparent and opaque is opposite in Smalltalk and PDF:	0 means 'transparent' (the background is painted) in Smalltalk and 'opaque' in PDF	1 means 'opaque' (the image is painted) in Smalltalk and 'transparent' in PDF"	| mask dMin dMax brightness |	mask := (1 bitShift: bitsPerComponents first) - 1.	dMin := anArray first.	dMax := anArray last.	brightness := (dMax - dMin) * someBits / mask + dMin.	^CoverageValue coverage: 1 - brightness</body><body package="PDF Images">defaultDecodeArray	^#(0.0 1.0) asPDF</body><body package="PDF Colour">initialColourValues	^#(0.0)</body><body package="PDF Colour">numberOfComponents	^1</body><body package="PDF Images">paletteFor: anImageXObject	anImageXObject bitsPerComponent = 1 ifTrue: [		^anImageXObject oneBitPalette].	anImageXObject bitsPerComponent = 8 ifTrue: [		^FixedPalette newForDepths: #(8 8 8)].	^MappedPalette withColors: anImageXObject uniqueColorValues</body><body package="PDF Images">procSet	^#ImageB</body><body package="PDF Images">rgbBytesFrom: aByteArray	"&lt;ByteArray&gt;"	| wst rst |	wst := (ByteArray new: aByteArray size * 3) writeStream.	rst := aByteArray readStream.	[rst atEnd] whileFalse: [		| byte |		byte := rst next.		wst nextPut: byte.		wst nextPut: byte.		wst nextPut: byte].	^wst contents</body></methods><methods><class-id>Graphics.PDF.CaretAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 11)</body><body package="PDF Interactive Features">subtype	^#Caret</body><body package="PDF Interactive Features">version	^5</body></methods><methods><class-id>Graphics.PDF.CIDFont</class-id> <category>accessing</category><body package="PDF Fonts">stringWidth: aContentString	"&lt;Integer&gt; in glyph space"	| cids rst |	cids := OrderedCollection new.	rst := aContentString content readStream.	[rst atEnd] whileFalse: [cids add: rst next * 256 + (rst next ifNil: [0])].	^cids inject: 0 into: [:width :cid | width + (self widthAt: cid)]</body><body package="PDF Fonts">widthAt: aCID	| widths rst |	widths := self objectAt: #W ifAbsent: [^self DW asSmalltalkValue].	rst := widths asSmalltalkValue readStream.	[rst atEnd] whileFalse: 			[| cid arrayOrCID |			cid := rst next.			arrayOrCID := rst next.			arrayOrCID isSequenceable				ifTrue: 					[((cid to: cid + arrayOrCID size - 1) includes: aCID)						ifTrue: [^arrayOrCID at: aCID - cid + 1]]				ifFalse: 					[| width |					width := rst next.					((cid to: arrayOrCID) includes: aCID) ifTrue: [^width]]].	^self DW asSmalltalkValue</body></methods><methods><class-id>Graphics.PDF.Error class</class-id> <category>instance creation</category><body package="PDF basics">newSignal: aString	^(self new)		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		messageText: aString;		yourself</body></methods><methods><class-id>Graphics.PDF.Error class</class-id> <category>testing</category><body package="PDF basics">mayResume	^true</body></methods><methods><class-id>Graphics.PDF.SquareCircle class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 8)</body><body package="PDF Interactive Features">version	^3</body></methods><methods><class-id>Graphics.PDF.SquareAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">subtype	^#Square</body></methods><methods><class-id>Graphics.PDF.BeginCompatibility class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Begin a compatibility section. Unrecognized operators (along with their operands) shall be ignored without error until the balancing EX operator is encountered'</body><body package="PDF Graphics Operations">end	^EndCompatibility</body><body package="PDF Graphics Operations">operatorName	^#BX</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_1</body></methods><methods><class-id>Graphics.PDF.BorderStyle class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 4)</body><body package="PDF Interactive Features">type	^#Border</body><body package="PDF Interactive Features">version	^2</body></methods><methods><class-id>Graphics.PDF.SetDash</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #dashPattern		put: (Dash array: self operands first offset: self operands last)</body></methods><methods><class-id>Graphics.PDF.SetDash class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the line dash pattern in the graphics state'</body><body package="PDF Graphics Operations">operandTypes	^#(#('dashArray' PDFArray) #('dashPhase' Number))</body><body package="PDF Graphics Operations">operatorName	^#d</body></methods><methods><class-id>Graphics.PDF.JBIG2Decode</class-id> <category>accessing</category><body package="PDF Filter">pdfVersion	^Version pdf1_4</body></methods><methods><class-id>Graphics.PDF.Pattern</class-id> <category>accessing</category><body package="PDF Colour">content	^self class name</body><body package="PDF Colour">decodeArrayMax: aNumber	TypeError raiseSignal: 'Not permitted with images'.	^nil</body><body package="PDF Colour">defaultDecodeArray	TypeError raiseSignal: 'Not permitted with images'.	^#() asPDF</body><body package="PDF Colour">initialColourValues	^#()</body><body package="PDF Colour">numberOfComponents	^0</body><body package="PDF Colour">procSet	^#ImageC</body></methods><methods><class-id>Graphics.PDF.Pattern class</class-id> <category>accessing</category><body package="PDF Colour">specialized: aPDFObject	aPDFObject content = self name ifTrue: [		^self on: aPDFObject content].	^nil</body><body package="PDF Colour">version	^2</body></methods><methods><class-id>Graphics.PDF.Outlines class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 3 3)</body></methods><methods><class-id>Graphics.PDF.AppendCurve class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Append a cubic Bézier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using (x1, y1) and (x2, y2) as the Bézier control points. The new current point shall be (x3, y3)'</body><body package="PDF Graphics Operations">operandTypes	^#(#('x1' Number) #('y1' Number) #('x2' Number) #('y2' Number) #('x3' Number) #('y3' Number))</body><body package="PDF Graphics Operations">operatorName	^#c</body></methods><methods><class-id>Graphics.PDF.BeginMarkedContent</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	aPageGraphics pushCollector: (MarkedObject tag: self operands first)</body></methods><methods><class-id>Graphics.PDF.BeginMarkedContent class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Begin a marked-content sequence terminated by a balancing EMC operator. tag shall be a name object indicating the role or significance of the sequence'</body><body package="PDF Graphics Operations">end	^EndMarkedContent</body><body package="PDF Graphics Operations">operandTypes	^#(#('tag' Name))</body><body package="PDF Graphics Operations">operatorName	^#BMC</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_2</body></methods><methods><class-id>Graphics.PDF.CrossReferences</class-id> <category>writing</category><body package="PDF Files">writeOn: aPDFWritestream indent: integer	self crossReferenceSection writeOn: aPDFWritestream indent: integer.	aPDFWritestream cr.	self trailer writeOn: aPDFWritestream indent: integer</body></methods><methods><class-id>Graphics.PDF.CrossReferences</class-id> <category>enumerating</category><body package="PDF Files">referencesDo: oneArgumentBlock	self crossReferenceSection referencesDo: oneArgumentBlock.	self stream ifNotNil: [self stream referencesDo: oneArgumentBlock].	self previous ifNotNil: [self previous referencesDo: oneArgumentBlock]</body></methods><methods><class-id>Graphics.PDF.CrossReferences</class-id> <category>accessing</category><body package="PDF Files">atNumber: anInteger	"&lt;CrossReference&gt;"	^self atNumber: anInteger ifAbsent: [		FileError raiseSignal: 'Reference with number ' , anInteger printString , ' not found']</body><body package="PDF Files">atNumber: anInteger ifAbsent: zeroArgumentBlock	"&lt;CrossReference&gt;"	^self crossReferenceSection atNumber: anInteger ifAbsent: [		self stream			ifNotNil: [			self stream atNumber: anInteger ifAbsent: [				self previous					ifNotNil: [					self previous atNumber: anInteger ifAbsent: zeroArgumentBlock]					ifNil: [					zeroArgumentBlock value]]]			ifNil: [			self previous				ifNotNil: [				self previous atNumber: anInteger ifAbsent: zeroArgumentBlock]				ifNil: [				zeroArgumentBlock value]]]</body><body package="PDF Files">crossReferenceAt: aPDFReference	"&lt;CrossReference&gt;"	^self crossReferenceAt: aPDFReference ifAbsent: [		FileError raiseSignal: 'Reference ' , aPDFReference printString , ' not found']</body><body package="PDF Files">crossReferenceAt: aPDFReference ifAbsent: zeroArgumentBlock	"&lt;CrossReference&gt;"	| unique1 cr unique2 |	unique1 := 'unique1'.	cr := self crossReferenceSection crossReferenceAt: aPDFReference ifAbsent: [unique1].	cr == unique1 ifFalse: [		^cr].	unique2 := 'unique2'.	cr := self streamCrossReferenceAt: aPDFReference ifAbsent: [unique2].	cr == unique2 ifFalse: [		^cr].	^self previousCrossReferenceAt: aPDFReference ifAbsent: zeroArgumentBlock</body><body package="PDF Files">crossReferenceSection	"&lt;CrossReferenceSection&gt;"	^crossReferenceSection</body><body package="PDF Files">freeReferences	| ref freeReferences |	ref := self atNumber: 0.	freeReferences := OrderedCollection with: ref.	[ref value isZero] whileFalse: [		ref := self atNumber: ref value.		freeReferences add: ref].	^freeReferences</body><body package="PDF Files">previous	"&lt;CrossReferences | CrossReferenceStream | nil&gt;	can be a CrossReferenceStream in a hybid file (see PDF 32000_2008.pdf pp. 51)"	^previous</body><body package="PDF Files">previousCrossReferenceAt: aPDFReference ifAbsent: zeroArgumentBlock	self previous ifNil: [		^zeroArgumentBlock value].	^self previous crossReferenceAt: aPDFReference ifAbsent: zeroArgumentBlock</body><body package="PDF Files">references	"&lt;SequenceableCollection of: CrossReference&gt;"	| list |	list := OrderedCollection new.	self referencesDo: [:ref | list add: ref].	^list</body><body package="PDF Files">stream	"&lt;CrossReferenceStream | nil&gt;	a CrossReferenceStream in a hybid file (see PDF 32000_2008.pdf pp. 51)"	^stream</body><body package="PDF Files">streamCrossReferenceAt: aPDFReference ifAbsent: zeroArgumentBlock	self stream ifNil: [		^zeroArgumentBlock value].	^self stream crossReferenceAt: aPDFReference ifAbsent: zeroArgumentBlock</body><body package="PDF Files">trailer	"&lt;Trailer&gt;"	^trailer</body><body package="PDF Files">usedReferences	"&lt;SequenceableCollection of: UsedReference&gt;"	| list |	list := OrderedCollection new.	self referencesDo: [:ref |		(ref isKindOf: UsedReference) ifTrue: [			list add: ref]].	^list</body></methods><methods><class-id>Graphics.PDF.CrossReferences</class-id> <category>comparing</category><body package="PDF Files">= anObject	^self class == anObject class and: [	self crossReferenceSection = anObject crossReferenceSection and: [	self trailer = anObject trailer and: [	self previous = anObject previous and: [	self stream = anObject stream]]]]</body><body package="PDF Files">hash	^self crossReferenceSection bitXor: (self trailer hash bitXor: (self previous hash bitXor: self stream hash))</body></methods><methods><class-id>Graphics.PDF.CrossReferences</class-id> <category>initialize-release</category><body package="PDF Files">initializeCrossReferenceSection: aCrossReferenceSection trailer: aTrailer previous: previousCrossReferences stream: aCrossReferenceStream	crossReferenceSection := aCrossReferenceSection.	trailer := aTrailer.	previous := previousCrossReferences.	stream := aCrossReferenceStream</body></methods><methods><class-id>Graphics.PDF.CrossReferences class</class-id> <category>instance creation</category><body package="PDF Files">crossReferenceSection: aCrossReferenceSection trailer: aTrailer	^self		crossReferenceSection: aCrossReferenceSection		trailer: aTrailer		previous: nil		stream: nil</body><body package="PDF Files">crossReferenceSection: aCrossReferenceSection trailer: aTrailer previous: previousCrossReferences	^self		crossReferenceSection: aCrossReferenceSection		trailer: aTrailer		previous: previousCrossReferences		stream: nil</body><body package="PDF Files">crossReferenceSection: aCrossReferenceSection trailer: aTrailer previous: previousCrossReferences stream: aCrossReferenceStream	| inst |	inst := self new.	inst		initializeCrossReferenceSection: aCrossReferenceSection		trailer: aTrailer		previous: previousCrossReferences		stream: aCrossReferenceStream.	^inst</body></methods><methods><class-id>Graphics.PDF.CrossReferences class</class-id> <category>reading</category><body package="PDF Files">readWith: aFile	| crossReferenceSection trailer previous stream |	crossReferenceSection := CrossReferenceSection readFrom: aFile parser.	trailer := Trailer readWith: aFile from: aFile parser.	previous := trailer Prev asSmalltalkValue ifNotNil: [:prevNumber |		aFile parser position: prevNumber.		self readWith: aFile].	stream := trailer XRefStm asSmalltalkValue ifNotNil: [:xRefStmNumber |		aFile parser position: xRefStmNumber.		XRefStream readWith: aFile].	^self		crossReferenceSection: crossReferenceSection		trailer: trailer		previous: previous		stream: stream</body></methods><methods><class-id>Graphics.PDF.PNGPredictor</class-id> <category>accessing</category><body package="PDF Filter">offsetLeft	"&lt;Integer&gt;	the distance to the left pixel in number of bytes"	^offsetLeft ifNil: [1]</body><body package="PDF Filter">type	^self class type</body></methods><methods><class-id>Graphics.PDF.PNGPredictor</class-id> <category>filtering</category><body package="PDF Filter">predict: aByteArray withUpperRow: upperByteArray	"&lt;ByteArray&gt;"	^self subclassResponsibility</body><body package="PDF Filter">unpredict: filteredByteArray withUpperRow: upperReconstructedByteArray	"&lt;ByteArray&gt;"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.PNGPredictor</class-id> <category>initialize-release</category><body package="PDF Filter">initializeOffsetLeft: anInteger	offsetLeft := anInteger</body></methods><methods><class-id>Graphics.PDF.PNGPredictor class</class-id> <category>instance creation</category><body package="PDF Filter">offsetLeft: anInteger	"implemented this way for easier testing"	| inst |	inst := self new.	inst initializeOffsetLeft: anInteger.	^inst</body><body package="PDF Filter">subclassFor: anInteger	^self subclasses detect: [:subclass | subclass type = anInteger]</body></methods><methods><class-id>Graphics.PDF.PNGPredictor class</class-id> <category>accessing</category><body package="PDF Filter">type	"&lt;Integer&gt;"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.PDF.NoPredictor</class-id> <category>filtering</category><body package="PDF Filter">predict: aByteArray withUpperRow: upperByteArray	^aByteArray copy</body><body package="PDF Filter">unpredict: filteredByteArray withUpperRow: upperReconstructedByteArray	^filteredByteArray copy</body></methods><methods><class-id>Graphics.PDF.NoPredictor class</class-id> <category>accessing</category><body package="PDF Filter">type	^0</body></methods><methods><class-id>Graphics.PDF.HexStringEncoder</class-id> <category>reading</category><body package="PDF basics">nextFrom: aStream	"&lt;Character&gt;	read a string character from aStream.	Answer the equivalent PDF character"	| hex1 hex2 |	hex1 := (self nextHexFrom: aStream) ifNil: [		^nil].	hex2 := (self nextHexFrom: aStream) ifNil: [$0].	^(Core.Number		readIntegerFrom: (ByteString			with: hex1			with: hex2) readStream		radix: 16) asCharacter</body><body package="PDF basics">nextHexFrom: aStream	"&lt;Character | nil&gt;	read until we find a valid hexadecimal character.	nil iff at the end of the stream"	| character |	character := aStream next.	character ifNil: [		^nil].	(#(8 9 10 12 13 32) includes: character asInteger) ifTrue: [		^self nextHexFrom: aStream].	(character isDigit or: [	'abcdef' includes: character asLowercase]) ifTrue: [			^character].	^self unknownHexCharacter: character</body><body package="PDF basics">unknownHexCharacter: aCharacter	(UnsupportedCharacterError new)		messageText: aCharacter printString, ' is not a hexadecimal character';		parameter: aCharacter;		raiseSignal.	^Character illegalCode asCharacter</body></methods><methods><class-id>Graphics.PDF.HexStringEncoder</class-id> <category>querying</category><body package="PDF basics">characterSize: aCharacter	"&lt;Integer&gt;	the number of bytes in the encoded output"	^2</body></methods><methods><class-id>Graphics.PDF.HexStringEncoder</class-id> <category>writing</category><body package="PDF basics">nextPut: aCharacter on: aStream	"put the character equivalent to the PDF aCharacter onto aStream"	| string |	(aStream position &gt; 63 and: [	(aStream position rem: 64) &lt;= 1]) ifTrue: [			aStream nextPut: Character lf asInteger].	string := aCharacter asInteger printStringRadix: 16.	string size = 1 ifTrue: [		string := '0' , string].	aStream nextPutAll: string asByteArray</body></methods><methods><class-id>Graphics.PDF.HexStringEncoder class</class-id> <category>accessing</category><body package="PDF basics">readStreamOn: aReadStream	"&lt;EncodedStream&gt;"	^EncodedStream on: aReadStream encodedBy: self asEncoder</body><body package="PDF basics">streamEncodingType	"Don't register this encoder"	^nil</body><body package="PDF basics">writeStream	"&lt;EncodedStream&gt;"	^EncodedStream on: ByteArray new writeStream encodedBy: self asEncoder</body></methods><methods><class-id>Graphics.PDF.AppendCurveWithoutC2 class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Append a cubic Bézier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using (x1, y1) and (x3, y3) as the Bézier control points. The new current point shall be (x3, y3)'</body><body package="PDF Graphics Operations">operandTypes	^#(#('x1' Number) #('y1' Number) #('x3' Number) #('y3' Number))</body><body package="PDF Graphics Operations">operatorName	^#y</body></methods><methods><class-id>Graphics.PDF.ObjectParser</class-id> <category>actions</category><body package="PDF Parsing">keepPositionAfter: zeroArgumentBlock	self savePosition.	^accessLock critical: [zeroArgumentBlock ensure: [self restorePosition]]</body><body package="PDF Parsing">restorePosition	"throws Error when the stack is empty"	self position: self peekPositions removeLast</body><body package="PDF Parsing">savePosition	"push the current position onto the stack"	self peekPositions addLast: self position</body></methods><methods><class-id>Graphics.PDF.ObjectParser</class-id> <category>accessing</category><body package="PDF Parsing">initialTokenActions	^(Core.Dictionary new)		at: #true put: [:aFile | aFile theTrue];		at: #false put: [:aFile | aFile theFalse];		at: #null put: [:aFile | aFile theNull];		at: '(' put: [:aFile | self readString];		at: '&lt;' put: [:aFile | self readHexString];		at: '/' put: [:aFile | self readName];		at: '[' put: [:aFile | self readArrayWith: aFile];		at: '&lt;&lt;' put: [:aFile | self readDictionaryOrStreamWith: aFile];		yourself</body><body package="PDF Parsing">peekPositions	"&lt;SequenceableCollection of: Integer&gt;	the stack for the peek positions"	^peekPositions ifNil: [peekPositions := OrderedCollection new]</body></methods><methods><class-id>Graphics.PDF.ObjectParser</class-id> <category>initialize-release</category><body package="PDF Parsing">initializeStream: aBinaryStream	super initializeStream: aBinaryStream.	accessLock := RecursionLock new</body></methods><methods><class-id>Graphics.PDF.ObjectParser</class-id> <category>reading objects</category><body package="PDF Parsing">readArrayWith: aFile	"&lt;PDF.Array of: PDFObject&gt;"	| objects done |	done := false.	objects := OrderedCollection new.	[done] whileFalse: [		self skipWhitespace.		self atEnd			ifTrue: [			ReadError raiseSignal: 'End of Array (]) expected'.			done := true]			ifFalse: [			self peek == $]				ifTrue: [				self next.				done := true]				ifFalse: [				objects add: (self readObjectWith: aFile)]]].	^objects asPDF</body><body package="PDF Parsing">readDictionaryOrStreamWith: aFile	"&lt;PDF.Dictionary&gt;	no streams allowed in object or contents streams"	^Dictionary on: (self readOrderedDictionaryWith: aFile)</body><body package="PDF Parsing">readObjectWith: aFile	"&lt;PDFObject | nil&gt;	read a PDF object off the aStream.	Answer the PDF object"	| token action |	token := self nextToken ifNil: [		^nil].	action := self tokenActions at: token ifAbsent: [		token first isPdfNumeric ifTrue: [			^self readNumberOrReference: token with: aFile].		ReadError raiseSignal: 'Token "' , token asString , '" not recognized'.		^token asPDF].	^action value: aFile</body><body package="PDF Parsing">readOrderedDictionaryWith: aFile	| done dict |	done := false.	dict := OrderedDictionary new.	[done] whileFalse: [		self skipWhitespace.		self			whenNext: $/			do: [			dict at: self nextNameSymbol put: (self readObjectWith: aFile)]			ifNot: [:char |			char == $&gt;				ifTrue: [				self next.				self whenNext: $&gt; do: [done := true] ifNot: [:char1 |					ReadError raiseSignal: 'Read ' , char1 printString , ' but end of Dictionary (&gt;&gt;) expected']]				ifFalse: [				ReadError raiseSignal: 'Read ' , char printString , ' but ' , $/ printString , ' or ' , $&gt; printString , ' expected']]].	^dict</body></methods><methods><class-id>Graphics.PDF.ObjectParser</class-id> <category>reading</category><body package="PDF Parsing">readNumberOrReference: numericToken with: aFile	| aNumber pos |	aNumber := self readNumber: numericToken.	pos := self position.	^(self readReferenceOrNilStartingWith: aNumber with: aFile) ifNil: [		self position: pos.		aNumber]</body><body package="PDF Parsing">readReferenceOrNilStartingWith: aNumber with: aFile	"&lt;Reference | nil&gt;"	| number2 nextToken |	aNumber isPositiveInteger ifFalse: [		^nil].	nextToken := self nextToken ifNil: [		^nil].	nextToken first isPdfNumeric ifFalse: [		^nil].	number2 := self readNumber: nextToken.	number2 nonNegativeInteger ifFalse: [		^nil].	self nextToken = #R ifTrue: [		^aFile referenceAt: aNumber asSmalltalkValue generation: number2 asSmalltalkValue].	^nil</body></methods><methods><class-id>Graphics.PDF.FileParser</class-id> <category>stream access</category><body package="PDF Parsing">prev	"&lt;Character&gt;	Reads the character before the current position.	Leaves the position before the read character."	self skip: -1.	^self peek asCharacter</body><body package="PDF Parsing">prev: count	"&lt;String&gt;	Reads the characters before the current position.	Leaves the position before the read characters.	Throughs an PositionOutOfBoundsError when there are not enought characters available"	| target |	target := self position - count.	self position: target.	^[(self next: count) asByteString] ensure: [self position: target]</body><body package="PDF Parsing">reset	^self stream reset</body><body package="PDF Parsing">skipBackAfterAll: aString	"search back from here for aString and leave the position after the occurence.	If aString was not found, the position is at the beginning"	| pattern size search |	pattern := aString reverse.	size := pattern size.	search := (self prev: size) reverse.	[pattern = search] whileFalse: [		search := (search allButFirst: 1) copyWith: self prev].	pattern = search ifTrue: [		self skip: size]</body></methods><methods><class-id>Graphics.PDF.FileParser</class-id> <category>converting</category><body package="PDF Parsing">forEncryption	"&lt;EncryptedFileParser&gt;	answer a new parser on the same stream without closing it"	| newParser |	newParser := EncryptedFileParser onStream: self stream.	stream := nil.	^newParser</body></methods><methods><class-id>Graphics.PDF.FileParser</class-id> <category>initialize-release</category><body package="PDF Parsing">setPositionToXRef	"set the stream to the begin of the last cross-reference section"	self stream setToEnd.	self skipBackAfterAll: 'startxref'.	self position: self nextInteger</body></methods><methods><class-id>Graphics.PDF.FileParser</class-id> <category>reading</category><body package="PDF Parsing">peekToken	"&lt;String | Symbol | nil&gt;	read a token off the aStream.	Answer the token string.	Reset the stream to where we found it"	^self keepPositionAfter: [self nextToken]</body><body package="PDF Parsing">readHeaderVersion	| first7 |	self reset.	first7 := self next: 7.	first7 = '%PDF-1.' ifFalse: [		ReadError raiseSignal: '"' , first7 , '" is no PDF header! "%PDF-1." expected.'].	^Version major: 1 minor: self nextInteger</body></methods><methods><class-id>Graphics.PDF.FileParser</class-id> <category>reading objects</category><body package="PDF Parsing">pickObjectFor: reference with: aFile	"read an object at top level from the file.	Set the position and reset it to the original after reading, so that calls can be nested."	^self keepPositionAfter: [		| result |		self position: reference value.		self expectInteger: reference number.		self expectInteger: reference generation.		self expectToken: #obj.		result := aFile indirectObjectFrom: self.		self expectToken: #endobj.		result]</body><body package="PDF Parsing">readCrossReferenceStreamWith: aFile	| object |	self nextInteger.	self nextInteger.	self expectToken: #obj.	object := self readObjectWith: aFile.	self expectToken: #endobj.	^object</body><body package="PDF Parsing">readDictionaryOrStreamWith: aFile	"&lt;PDF.Dictionary | PDF.Stream&gt;"	| dict |	dict := self readOrderedDictionaryWith: aFile.	self peekToken == #stream ifTrue: [		^self readStreamWith: dict].	^Dictionary on: dict</body><body package="PDF Parsing">readStreamContents: numberOfBytes	"&lt;ByteString&gt;"	| contents |	self expectToken: #stream.	self peek == Character cr ifTrue: [		self next].	self next == Character lf ifFalse: [		ReadError raiseSignal: 'Newline as start of the stream expected'.		self skip: -1].	contents := self next: numberOfBytes.	self expectToken: #endstream.	^contents</body><body package="PDF Parsing">readStreamWith: anOrderedDictionary	| length |	length := anOrderedDictionary at: #Length ifAbsent: [		^ReadError raiseSignal: 'The stream dictonary has no Length entry'].	^Stream on: anOrderedDictionary external: (self readStreamContents: length object asSmalltalkValue)</body></methods><methods><class-id>Graphics.PDF.Objecttype class</class-id> <category>accessing</category><body package="PDF Complex Objects">specialized: aPDFObject	"&lt;PDFObject | nil&gt;"	self topClasses do: [:class |		(class specialized: aPDFObject) ifNotNil: [:specialized |			^specialized]].	^nil</body><body package="PDF Complex Objects">topClasses	"&lt;Collection of: Class&gt;	The superclasses of all subsumed class hierarchies.	Any subclass of these top classes is of the type of the receiver"	^#()</body></methods><methods><class-id>Graphics.PDF.Objecttype class</class-id> <category>testing</category><body package="PDF Complex Objects">isSuperTypeOf: aPDFObject	^self topClasses anySatisfy: [:class | class isSuperTypeOf: aPDFObject]</body></methods><methods><class-id>Graphics.PDF.Destination class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 3 2)</body><body package="PDF Interactive Features">topClasses	^Array		with: ExplicitDestination		with: Dest</body></methods><methods><class-id>Graphics.PDF.Version</class-id> <category>comparing</category><body package="PDF basics">&lt; aVersion	self major = aVersion major ifTrue: [		^self minor &lt; aVersion minor].	^self major &lt; aVersion major</body><body package="PDF basics">= aVersion	^self class == aVersion class and: [	self major = aVersion major and: [	self minor = aVersion minor]]</body><body package="PDF basics">hash	^(self major bitShift: 10) bitXor: self minor</body></methods><methods><class-id>Graphics.PDF.Version</class-id> <category>writing</category><body package="PDF basics">numberString	"&lt;String&gt;"	^self major printString , '.' , self minor printString</body><body package="PDF basics">pdfSource	"&lt;String&gt;	the object as PDF source"	| wst |	wst := Writer on: ByteString new.	self writeOn: wst indent: 0.	^wst contents</body><body package="PDF basics">writeOn: aStream indent: integer	aStream nextPutAll: 'PDF-' , self numberString</body></methods><methods><class-id>Graphics.PDF.Version</class-id> <category>accessing</category><body package="PDF basics">major	"&lt;Integer&gt;"	^major</body><body package="PDF basics">minor	"&lt;Integer&gt;"	^minor</body></methods><methods><class-id>Graphics.PDF.Version</class-id> <category>printing</category><body package="PDF basics">printOn: stream	stream		nextPutAll: self class name asString;		nextPutAll: ' major: ';		nextPutAll: self major printString;		nextPutAll: ' minor: ';		nextPutAll: self minor printString</body></methods><methods><class-id>Graphics.PDF.Version</class-id> <category>initialize-release</category><body package="PDF basics">initializeMajor: majorInteger minor: minorInteger	major := majorInteger.	minor := minorInteger.	self beImmutable</body></methods><methods><class-id>Graphics.PDF.Version class</class-id> <category>instance creation</category><body package="PDF basics">major: majorInteger minor: minorInteger	| inst |	inst := self new.	inst initializeMajor: majorInteger minor: minorInteger.	^inst</body></methods><methods><class-id>Graphics.PDF.Version class</class-id> <category>instances</category><body package="PDF basics">pdf1_0	^self major: 1 minor: 0</body><body package="PDF basics">pdf1_1	^self major: 1 minor: 1</body><body package="PDF basics">pdf1_2	^self major: 1 minor: 2</body><body package="PDF basics">pdf1_3	^self major: 1 minor: 3</body><body package="PDF basics">pdf1_4	^self major: 1 minor: 4</body><body package="PDF basics">pdf1_5	^self major: 1 minor: 5</body><body package="PDF basics">pdf1_6	^self major: 1 minor: 6</body><body package="PDF basics">pdf1_7	^self major: 1 minor: 7</body><body package="PDF basics">pdf1_8	^self major: 1 minor: 8</body></methods><methods><class-id>Graphics.PDF.SquigglyAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">subtype	^#Squiggly</body><body package="PDF Interactive Features">version	^4</body></methods><methods><class-id>Graphics.PDF.IsolatedObject</class-id> <category>writing</category><body package="PDF Graphics">postfix	^'Q'</body><body package="PDF Graphics">prefix	^'q'</body></methods><methods><class-id>Graphics.PDF.NameTreeType</class-id> <category>testing</category><body package="PDF Complex Objects">subsumesDictionary: aPDFDictionary	| elementType |	elementType := self asClassType.	^(aPDFDictionary elements collect: [:element | element value]) allSatisfy: [:element | element isType: elementType]</body></methods><methods><class-id>Graphics.PDF.NameTreeType</class-id> <category>accessing</category><body package="PDF Complex Objects">name	^'NameTree(' , self pdfType name asString , ')'</body><body package="PDF Complex Objects">typedDictionary: aPDFDictionary	| contentCopy isValue |	contentCopy := aPDFDictionary content copy.	(aPDFDictionary hasKey: #Kids) ifTrue: [		contentCopy			at: #Kids			put: ((aPDFDictionary at: #Kids) content collect: [:element |				element typed: (Array with: self)]).		^NameTreeNode on: contentCopy].	isValue := false.	contentCopy		at: #Names		put: ((aPDFDictionary at: #Names) content collect: [:element |			| e |			e := isValue				ifTrue: [element typed: (Array with: self asClassType)]				ifFalse: [element].			isValue := isValue not.			e]).	^NameTreeLeaf on: contentCopy</body></methods><methods><class-id>Graphics.PDF.StrokeClosed class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Close and stroke the path. This operator shall have the same effect as the sequence h S'</body><body package="PDF Graphics Operations">operatorName	^#s</body></methods><methods><class-id>Graphics.PDF.XRefStream</class-id> <category>initialize-release</category><body package="PDF Files">createSubsections	| ssections ssrst contentsStream wBytes |	ssections := OrderedCollection new.	ssrst := self Index asSmalltalkValue readStream.	contentsStream := self internal asByteArray readStream.	wBytes := self W content collect: [:number | number asSmalltalkValue].	[ssrst atEnd] whileFalse: [		| firstNumber count entries |		firstNumber := ssrst next asSmalltalkValue.		count := ssrst next asSmalltalkValue.		entries := (1 to: count) collect: [:i |			CrossReference				number: firstNumber + i - 1				field1: (contentsStream next: wBytes first)				field2: (contentsStream next: (wBytes at: 2))				field3: (contentsStream next: wBytes last)].		ssections add: (CrossReferenceSubsection firstNumber: firstNumber entries: entries)].	^ssections</body></methods><methods><class-id>Graphics.PDF.XRefStream</class-id> <category>accessing</category><body package="PDF Files">atNumber: anInteger	"&lt;CrossReference&gt;"	^self atNumber: anInteger ifAbsent: [		FileError raiseSignal: 'Reference with number ' , anInteger printString , ' not found']</body><body package="PDF Files">atNumber: anInteger ifAbsent: zeroArgumentBlock	"&lt;CrossReference&gt;"	self subsections do: [:subsection |		(subsection atNumber: anInteger ifAbsent: [nil]) ifNotNil: [:ref |			^ref]].	self previous ifNotNil: [		^self previous atNumber: anInteger ifAbsent: zeroArgumentBlock].	^zeroArgumentBlock value</body><body package="PDF Files">crossReferenceAt: aPDFReference	"&lt;CrossReference&gt;"	^self crossReferenceAt: aPDFReference ifAbsent: [		FileError raiseSignal: 'Reference ' , aPDFReference printString , ' not found']</body><body package="PDF Files">crossReferenceAt: aPDFReference ifAbsent: zeroArgumentBlock	"&lt;CrossReference&gt;"	| uniqueObject |	uniqueObject := 'unique'.	self subsections do: [:subsection |		| cr |		cr := subsection crossReferenceAt: aPDFReference ifAbsent: [uniqueObject].		cr == uniqueObject ifFalse: [			^cr]].	self previous ifNotNil: [		^self previous crossReferenceAt: aPDFReference ifAbsent: zeroArgumentBlock].	^zeroArgumentBlock value</body><body package="PDF Files">freeReferences	| ref freeReferences |	ref := self atNumber: 0.	freeReferences := OrderedCollection with: ref.	[ref value isZero] whileFalse: [		ref := self atNumber: ref value.		freeReferences add: ref].	^freeReferences</body><body package="PDF Files">previous	"&lt;CrossReferenceStream | nil&gt;"	^previous</body><body package="PDF Files">previous: aCrossReferenceStream	previous := aCrossReferenceStream</body><body package="PDF Files">subsections	"&lt;SequenceableCollection of: CrossReferenceSubsection&gt;"	^subsections ifNil: [subsections := self createSubsections]</body><body package="PDF Files">trailer	"&lt;Trailer&gt;"	| newDict |	newDict := OrderedDictionary new.	Trailer keys do: [:key |		(self content at: key ifAbsent: [nil]) ifNotNil: [:aValue | newDict at: key put: aValue]].	^Trailer on: newDict</body><body package="PDF Files">usedReferences	"&lt;SequenceableCollection of: UsedReference&gt;"	| list |	list := OrderedCollection new.	self referencesDo: [:ref |		(ref isKindOf: UsedReference) ifTrue: [			list add: ref]].	^list</body></methods><methods><class-id>Graphics.PDF.XRefStream</class-id> <category>enumerating</category><body package="PDF Files">referencesDo: oneArgumentBlock	self subsections do: [:subsection | subsection referencesDo: oneArgumentBlock].	self previous ifNotNil: [self previous referencesDo: oneArgumentBlock]</body></methods><methods><class-id>Graphics.PDF.XRefStream class</class-id> <category>accessing</category><body package="PDF Files">type	^#XRef</body><body package="PDF Files">version	^5</body></methods><methods><class-id>Graphics.PDF.XRefStream class</class-id> <category>reading</category><body package="PDF Files">readWith: aFile	"&lt;CrossReferenceStream&gt;"	| inst |	inst := aFile parser readCrossReferenceStreamWith: aFile.	inst class == self ifFalse: [		"something is wrong - ignore it"		^nil].	(inst at: #Prev ifAbsent: [nil]) ifNotNil: [:previousPosition |		aFile parser position: previousPosition asSmalltalkValue.		inst previous: (self readWith: aFile)].	^inst</body></methods><methods><class-id>Graphics.PDF.String</class-id> <category>writing</category><body package="PDF Basic Objects">pdfHexSource	"&lt;String&gt;	the object as PDF source"	| wst |	wst := Writer on: ByteString new.	wst nextPutHexString: self.	^wst contents</body><body package="PDF Basic Objects">writeOn: aStream indent: integer	aStream nextPutString: self</body></methods><methods><class-id>Graphics.PDF.String</class-id> <category>converting</category><body package="PDF Basic Objects">asByteArray	"&lt;ByteArray&gt;"	^self content</body><body package="PDF Basic Objects">asSmalltalkValue	^self asString</body><body package="PDF Basic Objects">asString	"&lt;ByteString&gt;	the equivalent Smalltalk string"	^self content asByteString</body></methods><methods><class-id>Graphics.PDF.String</class-id> <category>testing</category><body package="PDF Basic Objects">isEmpty	^super isEmpty or: [	self content isEmpty]</body></methods><methods><class-id>Graphics.PDF.String</class-id> <category>accessing</category><body package="PDF Basic Objects">encrypted	"&lt;Boolean&gt;	true, iff the string is encrypted"	^encrypted ifNil: [false]</body><body package="PDF Basic Objects">size	^self content size</body></methods><methods><class-id>Graphics.PDF.String</class-id> <category>printing</category><body package="PDF Basic Objects">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'content' value: self content).	args add: (printer optional: 'encrypted' value: encrypted).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.PDF.String</class-id> <category>initialize-release</category><body package="PDF Basic Objects">initializeContent: contentValue encrypted: encryptedBoolean	content := contentValue.	(encryptedBoolean notNil and: [	self encrypted ~= encryptedBoolean]) ifTrue: [			encrypted := encryptedBoolean].	self beImmutable</body></methods><methods><class-id>Graphics.PDF.String class</class-id> <category>accessing</category><body package="PDF Complex Objects">specialized: aPDFObject	(self inheritsFrom: aPDFObject class) ifTrue: [		^self content: aPDFObject content encrypted: aPDFObject encrypted].	^nil</body><body package="PDF Basic Objects">utf16Header	^ByteString		with: 254 asCharacter		with: 255 asCharacter</body></methods><methods><class-id>Graphics.PDF.String class</class-id> <category>implementation limits</category><body package="PDF Basic Objects">maxSize	"Maximum length of a string, in bytes.This restriction applies only to strings in content streams.There is no effective restriction on other strings in PDF files."	^nil</body></methods><methods><class-id>Graphics.PDF.String class</class-id> <category>instance creation</category><body package="PDF Basic Objects">asPDFEndOfLines: aByteString	"&lt;PDF.String&gt;	replace EOL to LF"	| rst wst |	rst := aByteString readStream.	wst := ByteString new writeStream.	[rst atEnd] whileFalse: [		| char |		char := rst next.		char == Character cr ifTrue: [			char := rst peek == Character lf				ifTrue: [rst next]				ifFalse: [Character lf]].		wst nextPut: char].	^wst contents</body><body package="PDF Basic Objects">content: contentValue encrypted: encryptedBoolean	| inst |	inst := self new.	inst initializeContent: contentValue encrypted: encryptedBoolean.	^inst</body><body package="PDF Basic Objects">fromEncryptedPdf: aByteString	"&lt;PDF.String&gt;	aByteString is an uninterpreted encrypted string of bytes"	^String content: aByteString asByteArray encrypted: true</body><body package="PDF Basic Objects">fromPdf: aByteString	"&lt;PDF.String | PDF.Date&gt;	called from the parser after escaped octals are converted to bytes.	aByteString is an uninterpreted string of bytes"	| string |	(self isDateString: aByteString) ifTrue: [		^Date fromPdf: aByteString].	(aByteString first: 2) = self utf16Header ifTrue: [		| text |		text := UTF16Textstring fromPdf: aByteString.		^(self isDateString: text asString)			ifTrue: [Date fromPdf: text asString]			ifFalse: [text]].	string := self asPDFEndOfLines: aByteString.	(string allSatisfy: #isAscii) ifTrue: [		^AsciiString content: string asByteArray].	^EncodedString string: string</body></methods><methods><class-id>Graphics.PDF.String class</class-id> <category>instance creation optional</category><body package="PDF Basic Objects">content: contentValue	^self content: contentValue encrypted: nil</body></methods><methods><class-id>Graphics.PDF.String class</class-id> <category>testing</category><body package="PDF Basic Objects">isDateString: aSmalltalkString	"&lt;Boolean&gt;"	^(aSmalltalkString first: 2) = 'D:' and: [	aSmalltalkString size &gt;= 6 and: [	(aSmalltalkString copyFrom: 3 to: 6) allSatisfy: #isDigit]]</body></methods><methods><class-id>Graphics.PDF.EncodedString</class-id> <category>converting</category><body package="PDF Basic Objects">asString	| wst encoder |	wst := ByteString new writeStream.	encoder := Fonts.Font winAnsiEncoder.	self content do: [:code | wst nextPut: (encoder decode: code)].	^wst contents</body></methods><methods><class-id>Graphics.PDF.EncodedString class</class-id> <category>instance creation</category><body package="PDF Basic Objects">string: aString	| wst encoder |	wst := ByteArray new writeStream.	encoder := Fonts.Font winAnsiEncoder.	aString do: [:char |		| code |		code := encoder encode: char.		code = Character illegalCode			ifTrue: [			char asInteger &lt; 256 ifTrue: [				wst nextPut: char asInteger]]			ifFalse: [			wst nextPut: code]].	^self content: wst contents</body></methods><methods><class-id>Graphics.PDF.LineCap</class-id> <category>printing</category><body package="PDF Graphics">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.PDF.LineCap</class-id> <category>accessing</category><body package="PDF Graphics">value	"&lt;Integer&gt;"	^value</body></methods><methods><class-id>Graphics.PDF.LineCap</class-id> <category>initialize-release</category><body package="PDF Graphics">initializeValue: valueInteger	value := valueInteger.	self beImmutable</body></methods><methods><class-id>Graphics.PDF.LineCap class</class-id> <category>instances</category><body package="PDF Graphics">butt	^self value: 0</body><body package="PDF Graphics">projectingSquare	^self value: 2</body><body package="PDF Graphics">round	^self value: 1</body></methods><methods><class-id>Graphics.PDF.LineCap class</class-id> <category>instance creation</category><body package="PDF Graphics">value: valueInteger	| inst |	inst := self new.	inst initializeValue: valueInteger.	^inst</body></methods><methods><class-id>Graphics.PDF.StringEncoder</class-id> <category>testing</category><body package="PDF basics">shouldQuote: aCharacter	^aCharacter = $\ or: [	self quoteParenthesis and: [	'()' includes: aCharacter]]</body></methods><methods><class-id>Graphics.PDF.StringEncoder</class-id> <category>writing</category><body package="PDF basics">nextPut: aCharacter on: aStream	"put the character equivalent to the PDF aCharacter onto aStream"	| i |	i := aCharacter asInteger.	(i between: 32 and: 127) ifTrue: [		(self shouldQuote: aCharacter) ifTrue: [			aStream nextPut: $\ asInteger].		^aStream nextPut: i].	(#(8 9 10 12) includes: i) ifTrue: [		^aStream nextPut: i].	i = 13 ifTrue: [		^aStream nextPut: 10].	self putOctal: i on: aStream</body><body package="PDF basics">putOctal: integer on: aStream	| numberString |	(integer between: 0 and: 255) ifFalse: [		^self noEncodingFor: integer asCharacter in: aStream].	numberString := integer printStringRadix: 8.	aStream nextPut: $\ asInteger.	3 - numberString size timesRepeat: [aStream nextPut: $0 asInteger].	aStream nextPutAll: numberString asByteArray</body></methods><methods><class-id>Graphics.PDF.StringEncoder</class-id> <category>reading</category><body package="PDF basics">characterFormOctal: octalString	"&lt;Character&gt;"	^(Core.Number readIntegerFrom: octalString readStream radix: 8) asCharacter</body><body package="PDF basics">nextFrom: aStream	"&lt;Character&gt;	read a string character from aStream.	Answer the equivalent PDF character"	| character |	character := aStream next.	character ifNil: [		^nil].	character == $\ ifTrue: [		^self nextQuotedCharacterFrom: aStream].	^character</body><body package="PDF basics">nextOctalCharacterWith: firstDigit from: aStream	| secondDigit |	(aStream peek ifNil: [false] ifNotNil: [:c | c isDigit]) ifFalse: [		^self characterFormOctal: (ByteString with: firstDigit)].	secondDigit := aStream next.	(aStream peek ifNil: [false] ifNotNil: [:c | c isDigit]) ifFalse: [		^self characterFormOctal: (ByteString			with: firstDigit			with: secondDigit)].	^self characterFormOctal: (ByteString		with: firstDigit		with: secondDigit		with: aStream next)</body><body package="PDF basics">nextQuotedCharacterFrom: aStream	"we just read a quote (\). Decifer the following"	| character |	character := aStream next.	character == Character cr ifTrue: [		^nil].	character == Character lf ifTrue: [		^nil].	character == $n ifTrue: [		^Character lf].	character == $r ifTrue: [		^Character lf].	character == $t ifTrue: [		^Character tab].	character == $b ifTrue: [		^Character backspace].	character == $f ifTrue: [		^Character newPage].	('()\' includes: character) ifTrue: [		^character].	character isDigit ifTrue: [		^self nextOctalCharacterWith: character from: aStream].	"ignore backslash without known directive"	aStream skip: -1.	^nil</body></methods><methods><class-id>Graphics.PDF.StringEncoder</class-id> <category>accessing</category><body package="PDF basics">quoteParenthesis	^quoteParenthesis ifNil: [false]</body><body package="PDF basics">quoteParenthesis: aBoolean	quoteParenthesis := aBoolean</body></methods><methods><class-id>Graphics.PDF.StringEncoder</class-id> <category>querying</category><body package="PDF basics">characterSize: aCharacter	"&lt;Integer&gt;	the number of bytes in the encoded output"	| i |	i := aCharacter asInteger.	(i between: 32 and: 127) ifTrue: [		(self shouldQuote: aCharacter) ifTrue: [			^2].		^1].	(#(8 9 10 12 13) includes: i) ifTrue: [		^1].	^4</body></methods><methods><class-id>Graphics.PDF.StringEncoder class</class-id> <category>accessing</category><body package="PDF basics">readStreamOn: aReadStream	"&lt;EncodedStream&gt;"	^EncodedStream on: aReadStream encodedBy: self asEncoder</body><body package="PDF basics">streamEncodingType	"Don't register this encoder"	^nil</body><body package="PDF basics">writeStream	"&lt;EncodedStream&gt;"	^EncodedStream on: ByteArray new writeStream encodedBy: self asEncoder</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingColorSpecial</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #colorNonstroking put: self operands</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingColorSpecial class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Same as SCN but used for nonstroking operations'</body><body package="PDF Graphics Operations">operandTypes	^#(#('cn' Number) #('name' Number))</body><body package="PDF Graphics Operations">operatorName	^#scn</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_2</body></methods><methods><class-id>Graphics.PDF.Leading</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #leading put: self operands first</body></methods><methods><class-id>Graphics.PDF.Leading class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the text leading, Tl, to leading, which shall be a number expressed in unscaled text space units. Text leading shall be used only by the T*, '', and " operators. Initial value: 0'</body><body package="PDF Graphics Operations">operandTypes	^#(#('leading' Number))</body><body package="PDF Graphics Operations">operatorName	^#TL</body></methods><methods><class-id>Graphics.PDF.Null</class-id> <category>writing</category><body package="PDF Basic Objects">writeOn: aStream indent: integer	aStream nextPutAll: 'null'</body></methods><methods><class-id>Graphics.PDF.Null</class-id> <category>testing</category><body package="PDF Basic Objects">isNil	"Null should be like nil"	^true</body><body package="PDF Basic Objects">isNull	^true</body><body package="PDF Basic Objects">notNil	"Null should be like nil"	^false</body></methods><methods><class-id>Graphics.PDF.Null</class-id> <category>accessing</category><body package="PDF Basic Objects">content	^nil</body><body package="PDF Basic Objects">value	"Allow this object to act as a ValueHolder on itself."	^self</body></methods><methods><class-id>Graphics.PDF.Null</class-id> <category>controlling</category><body package="PDF Basic Objects">ifNil: aBlock	"Evaluate aBlock if the receiver is nil, and since it is, return aBlock's value."	^aBlock value</body><body package="PDF Basic Objects">ifNil: nilBlock ifNotNil: notNilBlock	"If the receiver is nil, answer the evaluation of nilBlock, otherwise answer	 the evaluation of notNilBlock with the receiver as its argument.	 Since the receiver is nil, answer the evaluation of nilBlock."	^nilBlock value</body><body package="PDF Basic Objects">ifNotNil: aBlock	"If the receiver is not nil, answer the evaluation of aBlock (with the receiver as	 its argument if it takes one), otherwise answer nil. Since the receiver is nil, aBlock	 is not evaluated and nil is returned. All other objects respond to this	 by evaluating aBlock (with themself as an argument if it takes one)."	^self</body><body package="PDF Basic Objects">ifNotNil: notNilBlock ifNil: nilBlock	"If the receiver is not nil, answer the evaluation of notNilBlock (with the	 receiver as its argument if it takes one), otherwise answer the evaluation	of nilBlock.  Since the receiver is nil, answer the evaluation of nilBlock."	^nilBlock value</body></methods><methods><class-id>Graphics.PDF.Null class</class-id> <category>instances</category><body package="PDF Basic Objects">null	^self new</body></methods><methods><class-id>Graphics.PDF.Null class</class-id> <category>specification</category><body package="PDF Basic Objects">localSpecification</body></methods><methods><class-id>Graphics.PDF.OptionalContentUsageCreatorInfo class</class-id> <category>accessing</category><body package="PDF Data Structures">version	^5</body></methods><methods><class-id>Graphics.PDF.ShowText</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState		at: #textMatrix		put: (aPageGraphics graphicsState textMatrix translatedBy: (aPageGraphics stringWidth: self operands first) @ 0)</body></methods><methods><class-id>Graphics.PDF.ShowText class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Show a text string'</body><body package="PDF Graphics Operations">operandTypes	^#(#('string' String))</body><body package="PDF Graphics Operations">operatorName	^#Tj</body></methods><methods><class-id>Graphics.PDF.SetMiterLimit</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #miterLimit put: self operands first</body></methods><methods><class-id>Graphics.PDF.SetMiterLimit class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the miter limit in the graphics state'</body><body package="PDF Graphics Operations">operandTypes	^#(#('miterLimit' Number))</body><body package="PDF Graphics Operations">operatorName	^#M</body></methods><methods><class-id>Graphics.PDF.GraphicsInterpreter</class-id> <category>accessing</category><body package="PDF Graphics">beginTextIndex	"&lt;Integer | nil&gt;"	^beginTextIndex</body><body package="PDF Graphics">beginTextIndex: anInteger	beginTextIndex := anInteger</body><body package="PDF Graphics">container	"&lt;Page | FormXObject&gt;	including contents and resources"	^container</body><body package="PDF Graphics">currentObject	"&lt;GraphicsObject&gt;	the graphical object interpreting the operators"	^self currentObjectStack last</body><body package="PDF Graphics">currentObjectStack	"&lt;OrderedCollection of: GraphicsCollector&gt;	Stack of incomplete graphics objects. The current Object is on top"	^currentObjectStack ifNil: [		currentObjectStack := OrderedCollection with: GraphicsCollector new]</body><body package="PDF Graphics">currentPath	"&lt;SeqenceableCollection of: PathConstructionOperator&gt;"	^currentPath ifNil: [currentPath := PathObject new]</body><body package="PDF Graphics">graphicsState	"&lt;GraphicsState&gt;"	^graphicsState ifNil: [graphicsState := GraphicsState new]</body><body package="PDF Graphics">graphicsState: aGraphicsState	graphicsState := aGraphicsState</body><body package="PDF Graphics">graphicsStateStack	"&lt;SequenceableCollection of: GraphicsState&gt;"	^graphicsStateStack ifNil: [graphicsStateStack := OrderedCollection new]</body><body package="PDF Graphics">objects	"&lt;SequenceableCollection of: GraphicsObject&gt;	list of graphics objects"	^objects ifNil: [objects := OrderedCollection new]</body><body package="PDF Graphics">operations	^operations ifNil: [		operations := (ContentParser onString: self container contentString) readOperations]</body><body package="PDF Graphics">pdfVersion	"&lt;PDFVersion&gt;	the minimal version for this object with its features"	^Version pdf1_0</body><body package="PDF Graphics">resetBeginTextIndex	beginTextIndex := nil</body><body package="PDF Graphics">resetCurrentPath	currentPath := nil</body><body package="PDF Graphics">resources	"&lt;Resources&gt;"	^self container Resources</body><body package="PDF Graphics">stringWidth: aString	"&lt;Number&gt;"	^self stringWidth: aString adjustedBy: 0</body><body package="PDF Graphics">stringWidth: aString adjustedBy: aNumber	"&lt;Number&gt;"	| font fontSize charSpacing wordSpacing horizontalScaling stringWidth numberOfCharacters numberOfSpaces cWidth cfWidth charsSpacing wordsSpacing spacing cfsWidth |	font := self resources Font objectAt: self graphicsState textFont asSmalltalkValue.	fontSize := self graphicsState textFontSize asSmalltalkValue.	charSpacing := self graphicsState characterSpacing asSmalltalkValue.	wordSpacing := self graphicsState wordSpacing asSmalltalkValue.	horizontalScaling := self graphicsState horizontalScaling asSmalltalkValue / 100.	stringWidth := font stringWidth: aString.	numberOfCharacters := font numberOfCharacters: aString.	numberOfSpaces := (aString asString select: [:c | c codePoint = 32]) size.	cWidth := (stringWidth - aNumber) / 1000.	cfWidth := cWidth * fontSize.	charsSpacing := charSpacing * numberOfCharacters.	wordsSpacing := wordSpacing * numberOfSpaces.	spacing := charsSpacing + wordsSpacing.	cfsWidth := cfWidth + spacing.	^cfsWidth * horizontalScaling</body></methods><methods><class-id>Graphics.PDF.GraphicsInterpreter</class-id> <category>actions</category><body package="PDF Graphics">addObject: aGraphicsObject	self currentObject addObject: aGraphicsObject</body><body package="PDF Graphics">popCollector	"&lt;GraphicsCollector&gt;"		^self currentObjectStack removeLast</body><body package="PDF Graphics">pushCollector: aGraphicsCollector	self currentObjectStack addLast: aGraphicsCollector</body><body package="PDF Graphics">saveState	self graphicsStateStack addLast: self graphicsState copy</body><body package="PDF Graphics">setClippingPathIntersecting: aPath	| newClippingPath |	newClippingPath := self graphicsState clippingPath				ifNotNil: [:clippingPath | clippingPath intersectedBy: aPath]				ifNil: [aPath].	self graphicsState at: #clippingPath put: newClippingPath</body></methods><methods><class-id>Graphics.PDF.GraphicsInterpreter</class-id> <category>initialize-release</category><body package="PDF Graphics">initializeContainer: aPage	container := aPage.	self operations doWithIndex: [:operation :index | operation applyTo: self at: index]</body></methods><methods><class-id>Graphics.PDF.GraphicsInterpreter</class-id> <category>writing</category><body package="PDF Graphics">asPdfString	"&lt;String&gt;"	| wst |	wst := WriteStream on: Core.String new.	self currentObject objects		do: [:object | wst nextPutAll: object pdfSource]		separatedBy: [wst cr].	^wst contents</body></methods><methods><class-id>Graphics.PDF.GraphicsInterpreter class</class-id> <category>instance creation</category><body package="PDF Graphics">on: aPageOrForm	| inst |	inst := self new.	inst initializeContainer: aPageOrForm.	^inst</body></methods><methods><class-id>Graphics.PDF.ScreenAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 18)</body><body package="PDF Interactive Features">subtype	^#Screen</body><body package="PDF Interactive Features">version	^5</body></methods><methods><class-id>Graphics.PDF.Pathsegment</class-id> <category>accessing</category><body package="PDF Graphics">operator	"&lt;Operator&gt;"	^operator</body></methods><methods><class-id>Graphics.PDF.Pathsegment</class-id> <category>initialize-release</category><body package="PDF Graphics">initializeOperator: operatorOperator	operator := operatorOperator.	self beImmutable</body></methods><methods><class-id>Graphics.PDF.Pathsegment</class-id> <category>printing</category><body package="PDF Graphics">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'operator' value: self operator).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.PDF.Pathsegment class</class-id> <category>instance creation</category><body package="PDF Graphics">operator: operatorOperator	| inst |	inst := self new.	inst initializeOperator: operatorOperator.	^inst</body></methods><methods><class-id>Graphics.PDF.Textstring</class-id> <category>converting</category><body package="PDF Basic Objects">asString	| encoder wst |	wst := ByteString new writeStream.	encoder := Graphics.Fonts.Font pdfDocEncoder.	self content do: [:code | wst nextPut: (encoder decode: code)].	^wst contents asByteString</body></methods><methods><class-id>Graphics.PDF.Textstring class</class-id> <category>instance creation</category><body package="PDF Basic Objects">fromString: aByteString	| encoder wst |	wst := ByteArray new writeStream.	encoder := Graphics.Fonts.Font pdfDocEncoder.	aByteString do: [:char | wst nextPut: (encoder encode: char)].	^self content: wst contents</body></methods><methods><class-id>Graphics.PDF.Textstring class</class-id> <category>accessing</category><body package="PDF Complex Objects">specialized: aPDFObject	((self inheritsFrom: aPDFObject class) or: [	aPDFObject isKindOf: String]) ifTrue: [			^self content: aPDFObject content encrypted: aPDFObject encrypted].	^nil</body></methods><methods><class-id>Graphics.PDF.DeviceCMYK</class-id> <category>accessing</category><body package="PDF Colour">defaultDecodeArray	^#(0.0 1.0 0.0 1.0 0.0 1.0 0.0 1.0) asPDF</body><body package="PDF Colour">initialColour	^CmykColor black</body><body package="PDF Colour">initialColourValues	^#(0.0 0.0 0.0 1.0)</body><body package="PDF Colour">numberOfComponents	^4</body></methods><methods><class-id>Graphics.PDF.OptionalContentProperties class</class-id> <category>accessing</category><body package="PDF Data Structures">version	^5</body></methods><methods><class-id>Graphics.PDF.InkAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 13)</body><body package="PDF Interactive Features">subtype	^#Ink</body><body package="PDF Interactive Features">version	^3</body></methods><methods><class-id>Graphics.PDF.SetLineWidth</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #lineWidth put: self operands first</body></methods><methods><class-id>Graphics.PDF.SetLineWidth class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the line width in the graphics state'</body><body package="PDF Graphics Operations">operandTypes	^#(#('lineWidth' Number))</body><body package="PDF Graphics Operations">operatorName	^#w</body></methods><methods><class-id>Graphics.PDF.GraphicsState</class-id> <category>accessing</category><body package="PDF Graphics">classesForAttributes	^Array with: self class</body><body package="PDF Graphics">defaultAt: aSymbol	^[self class new perform: aSymbol] on: Error do: [:ex | ex return: nil]</body></methods><methods><class-id>Graphics.PDF.GraphicsState</class-id> <category>actions</category><body package="PDF Graphics">nextLineBy: aPoint	self at: #textLineMatrix put: (self textLineMatrix translatedBy: aPoint).	self at: #textMatrix put: self textLineMatrix</body></methods><methods><class-id>Graphics.PDF.FunctionStream class</class-id> <category>instance creation</category><body package="PDF Data Structures">empty	| inst |	inst := self new.	inst at: #FunctionType put: self functionType.	^inst</body></methods><methods><class-id>Graphics.PDF.FunctionStream class</class-id> <category>accessing</category><body package="PDF Data Structures">functionType	"&lt;Integer&gt;	-1 never matches"	^-1</body><body package="PDF Data Structures">isTypeFor: anOrderedDictionary	| typeEntry |	typeEntry := anOrderedDictionary at: #FunctionType ifAbsent: [		^false].	^self functionType asPDF = typeEntry</body><body package="PDF Data Structures">version	^2</body></methods><methods><class-id>Graphics.PDF.PostScriptCalculatorFunction class</class-id> <category>accessing</category><body package="PDF Data Structures">allowedOperators	| arithmetic relationalBooleanBitwise conditional stack |	arithmetic := #(#abs #add #atan #ceiling #cos #cvi #cvr #div #exp #floor #idiv #ln #log #mod #mul #neg #round #sin #sqrt #sub #truncate).	relationalBooleanBitwise := #(#and #bitshift #eq false #ge #gt #le #lt #ne #not #or true #xor).	conditional := #(#if #ifelse).	stack := #(#copy #dup #exch #index #pop #roll).	^arithmetic , relationalBooleanBitwise , conditional , stack</body><body package="PDF Data Structures">functionType	^4</body></methods><methods><class-id>Graphics.PDF.Action class</class-id> <category>accessing</category><body package="PDF Interactive Features">subtype	"&lt;Symbol&gt;	subtype entry"	^self name</body><body package="PDF Interactive Features">type	^#Action</body><body package="PDF Interactive Features">version	^1</body></methods><methods><class-id>Graphics.PDF.Action class</class-id> <category>instance creation</category><body package="PDF Interactive Features">empty	| inst |	inst := super empty.	inst at: #S put: self subtype.	^inst</body><body package="PDF Interactive Features">isTypeFor: anOrderedDictionary	| subtypeEntry |	self == Action ifTrue: [		^super isTypeFor: anOrderedDictionary].	subtypeEntry := anOrderedDictionary at: #S ifAbsent: [		^false].	^self subtype asPDF = subtypeEntry asPDF</body></methods><methods><class-id>Graphics.PDF.Sound class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(13 3)</body><body package="PDF Interactive Features">version	^2</body></methods><methods><class-id>Graphics.PDF.ZipFilterParameter class</class-id> <category>accessing</category><body package="PDF Filter">documentationPlace	^#(7 4 4 3)</body></methods><methods><class-id>Graphics.PDF.LZWDecode</class-id> <category>filtering</category><body package="PDF Filter">compressed: aByteString	^self notYetImplemented</body><body package="PDF Filter">decompressed: aByteString	^self notYetImplemented</body></methods><methods><class-id>Graphics.PDF.LZWDecode</class-id> <category>accessing</category><body package="PDF Filter">earlyChange	"&lt;Integer&gt;	An indication of when to increase the code length.	If the value of this entry is 0, code length increases shall be postponed as long as possible.	If the value is 1, code length increases shall occur one code early.	This parameter is included because LZW sample code distributed by some vendors increases the code length one code earlier than necessary.	Default value: 1."	^earlyChange ifNil: [1]</body></methods><methods><class-id>Graphics.PDF.LZWDecode</class-id> <category>initialize-release</category><body package="PDF Filter">initializeParameters: aDecodeParms	super initializeParameters: aDecodeParms.	earlyChange := (aDecodeParms at: #EarlyChange ifAbsent: [nil]) value</body></methods><methods><class-id>Graphics.PDF.PDF class</class-id> <category>instance creation</category><body package="PDF basics">new	self shouldNotImplement</body></methods><methods><class-id>Graphics.PDF.PDF class</class-id> <category>accessing</category><body package="PDF basics">libraryVersionString	"&lt;String&gt;	the version of the PDF4Smalltalk library.	This corresponds to the version in the public store.	The version consists of 3 parts:		major: 		'1' for the time being. May be increased with a major rewrite.		minor: 		gets increased with new features or incompatible changes.		release: 	increases every time when a version is released as part of a smallCharts release.	The store version has a 4th component, which denotes a build when changes are published"	^'1.4.4'</body><body package="PDF Complex Objects">objecttypeAt: aSymbol	"&lt;Objecttype class | PDFObject class | PDFValue class | Reference | nil&gt;"	^self objecttypes at: aSymbol ifAbsent: nil</body><body package="PDF Complex Objects">objecttypes	"&lt;IdentityDictionary key: Symbol value: Class&gt;	all classes representing a type of pdf object"	^objecttypes ifNil: [		| dict |		dict := IdentityDictionary new.		Objecttype allSubclasses , PDFObject allSubclasses , PDFValue allSubclasses , (Array with: Reference) do: [:class |			dict at: class name put: class].		objecttypes := dict]</body><body package="PDF basics">producerText	"&lt;Textstring&gt;	default text used as /Producer in the /Trailer/Info"	^Textstring fromString: 'PDF4Smalltalk ' , self libraryVersionString</body><body package="PDF Complex Objects">resetObjecttypes	"reset when classes where added or removed"	"self resetObjecttypes"	objecttypes := nil</body></methods><methods><class-id>Graphics.PDF.Group class</class-id> <category>accessing</category><body package="PDF XObjects">version	^4</body></methods><methods><class-id>Graphics.PDF.Group class</class-id> <category>instance creation</category><body package="PDF XObjects">isTypeFor: anOrderedDictionary	^(super isTypeFor: anOrderedDictionary) and: [	anOrderedDictionary includesKey: #Group]</body></methods><methods><class-id>Graphics.PDF.Path</class-id> <category>accessing</category><body package="PDF Graphics">clippingingOperator	"&lt;ClippingPathOperator&gt;"	^clippingingOperator</body><body package="PDF Graphics">paintingOperator	"&lt;PathPaintingOperator&gt;"	^paintingOperator</body><body package="PDF Graphics">subpaths	"&lt;Array&gt;"	^subpaths ifNil: [#()]</body></methods><methods><class-id>Graphics.PDF.Path</class-id> <category>printing</category><body package="PDF Graphics">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'subpaths' value: self subpaths).	args add: (printer constant: 'clippingingOperator' value: self clippingingOperator).	args add: (printer constant: 'paintingOperator' value: self paintingOperator).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.PDF.Path</class-id> <category>initialize-release</category><body package="PDF Graphics">initializeSubpaths: subpathsArray clippingingOperator: clippingingOperatorClippingPathOperator paintingOperator: paintingOperatorPathPaintingOperator	(subpathsArray notNil and: [	subpathsArray notEmpty]) ifTrue: [			subpaths := (Array withAll: subpathsArray) beImmutable].	clippingingOperator := clippingingOperatorClippingPathOperator.	paintingOperator := paintingOperatorPathPaintingOperator.	self beImmutable</body></methods><methods><class-id>Graphics.PDF.Path class</class-id> <category>instance creation</category><body package="PDF Graphics">subpaths: subpathsArray clippingingOperator: clippingingOperatorClippingPathOperator paintingOperator: paintingOperatorPathPaintingOperator	| inst |	inst := self new.	inst		initializeSubpaths: subpathsArray		clippingingOperator: clippingingOperatorClippingPathOperator		paintingOperator: paintingOperatorPathPaintingOperator.	^inst</body></methods><methods><class-id>Graphics.PDF.Path class</class-id> <category>instance creation optional</category><body package="PDF Graphics">clippingingOperator: clippingingOperatorClippingPathOperator paintingOperator: paintingOperatorPathPaintingOperator	| inst |	inst := self new.	inst		initializeSubpaths: nil		clippingingOperator: clippingingOperatorClippingPathOperator		paintingOperator: paintingOperatorPathPaintingOperator.	^inst</body></methods><methods><class-id>Graphics.PDF.ClippingPathOperation</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	aPageGraphics currentPath addClipping: self</body></methods><methods><class-id>Graphics.PDF.Clip class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Modify the current clipping path by intersecting it with the current path, using the nonzero winding number rule to determine which regions lie inside the clipping path'</body><body package="PDF Graphics Operations">operatorName	^#W</body></methods><methods><class-id>Graphics.PDF.StampAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 12)</body><body package="PDF Interactive Features">subtype	^#Stamp</body><body package="PDF Interactive Features">version	^3</body></methods><methods><class-id>Graphics.PDF.WidgetAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 19)</body><body package="PDF Interactive Features">subtype	^#Widget</body></methods><methods><class-id>Graphics.PDF.Pages</class-id> <category>enumerating</category><body package="PDF Document">pagesDo: oneArgumentBlock	self Kids objects do: [:pageTree | pageTree pagesDo: oneArgumentBlock]</body></methods><methods><class-id>Graphics.PDF.Pages</class-id> <category>actions</category><body package="PDF Document">addPageTree: aPageTree	"add aPageTree (a Page or a Pages) as last element"	self addPageTree: aPageTree withParent: self reference</body><body package="PDF Document">addPageTree: aPageTree withParent: aReferenceToSelf	aPageTree at: #Parent put: aReferenceToSelf.	self at: #Kids put: (self Kids with: aPageTree newReference).	self at: #Count put: self count.	self Parent notEmpty ifTrue: [		self Parent updateCount]</body><body package="PDF Document">updateCount	self at: #Count put: self count</body></methods><methods><class-id>Graphics.PDF.Pages</class-id> <category>accessing</category><body package="PDF Document">count	^self Kids content inject: 0 into: [:sum :kid | sum + kid referent count]</body><body package="PDF Document">firstPage	^self Kids first firstPage</body><body package="PDF Document">numberOfPages	^self Count content</body><body package="PDF Document">pageAt: anInteger	| pageNumber |	(anInteger between: 0 and: self numberOfPages) ifFalse: [		^SubscriptOutOfBoundsError signalWith: anInteger].	pageNumber := anInteger.	self Kids objects do: [:pageTree |		pageTree numberOfPages &lt; pageNumber			ifTrue: [			pageNumber := pageNumber - pageTree numberOfPages]			ifFalse: [			^pageTree pageAt: pageNumber]]</body><body package="PDF Document">reference	^self Kids isEmpty		ifTrue: [		self Parent isEmpty			ifTrue: [self newReference]			ifFalse: [			self Parent referenceTo: self]]		ifFalse: [		self Kids first at: #Parent]</body><body package="PDF Document">referenceTo: aPages	self Kids do: [:kidRef |		kidRef content == aPages ifTrue: [			^kidRef]].	^nil</body></methods><methods><class-id>Graphics.PDF.Pages class</class-id> <category>instance creation</category><body package="PDF Document">empty	| inst |	inst := super empty.	inst at: #Kids put: #() asPDF.	inst at: #Count put: 0.	^inst</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingColor</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #colorNonstroking put: self operands</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingColor class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Same as SC but used for nonstroking operations'</body><body package="PDF Graphics Operations">operandTypes	^#(#('cn' Number))</body><body package="PDF Graphics Operations">operatorName	^#sc</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_1</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingColorSpace</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	| colorspace |	colorspace := (#(#DeviceGray #DeviceRGB #DeviceCMYK #Pattern)				includes: self operands first content)					ifTrue: [self operands first asType: (DirectType on: ColourSpace)]					ifFalse: [self resourceIn: aPageGraphics].	aPageGraphics graphicsState at: #colorSpaceNonstroking put: colorspace</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingColorSpace</class-id> <category>accessing</category><body package="PDF Graphics Operations">resourceIn: aPageGraphics	(#(#DeviceGray #DeviceRGB #DeviceCMYK #Pattern) includes: self operands first asSmalltalkValue) ifFalse: [		^aPageGraphics resources ColorSpace objectAt: self operands first asSmalltalkValue].	^nil</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingColorSpace class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Same as CS but used for nonstroking operations'</body><body package="PDF Graphics Operations">operandTypes	^#(#('name' #Name))</body><body package="PDF Graphics Operations">operatorName	^#cs</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_1</body></methods><methods><class-id>Graphics.PDF.Boolean</class-id> <category>writing</category><body package="PDF Basic Objects">writeOn: aStream indent: integer	aStream nextPutAll: self asSmalltalkValue printString</body></methods><methods><class-id>Graphics.PDF.Boolean class</class-id> <category>instances</category><body package="PDF Basic Objects">false	^self on: false</body><body package="PDF Basic Objects">true	^self on: true</body></methods><methods><class-id>Graphics.PDF.CircleAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">subtype	^#Circle</body></methods><methods><class-id>Graphics.PDF.RadialShading class</class-id> <category>accessing</category><body package="PDF Shading">shadingType	^3</body></methods><methods><class-id>Graphics.PDF.UpPredictor</class-id> <category>filtering</category><body package="PDF Filter">predict: aByteArray withUpperRow: upperByteArray	"&lt;ByteArray&gt;"	| filtered |	filtered := ByteArray new: aByteArray size.	1 to: aByteArray size do: [:index |		| output |		output := (aByteArray at: index) - (upperByteArray at: index).		filtered at: index put: output \\ 256].	^filtered</body><body package="PDF Filter">unpredict: filteredByteArray withUpperRow: upperReconstructedByteArray	| reconstructed |	reconstructed := ByteArray new: filteredByteArray size.	1 to: filteredByteArray size do: [:index |		| output |		output := (filteredByteArray at: index) + (upperReconstructedByteArray at: index).		reconstructed at: index put: output \\ 256].	^reconstructed</body></methods><methods><class-id>Graphics.PDF.UpPredictor class</class-id> <category>accessing</category><body package="PDF Filter">type	^2</body></methods><methods><class-id>Graphics.PDF.ObjectStreamParser</class-id> <category>reading objects</category><body package="PDF Parsing">pickObjectAt: position with: aFile	"read an object at top level from the object stream.	Set the position and reset it to the original after reading, so that calls can be nested."	^self keepPositionAfter: [		self position: position.		aFile indirectObjectFrom: self]</body></methods><methods><class-id>Graphics.PDF.TextRenderingMode</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #textRenderingMode put: self operands first</body></methods><methods><class-id>Graphics.PDF.TextRenderingMode class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the text rendering mode, Tmode, to render. Initial value: 0'</body><body package="PDF Graphics Operations">operandTypes	^#(#('render' Integer))</body><body package="PDF Graphics Operations">operatorName	^#Tr</body></methods><methods><class-id>Graphics.PDF.ClassType</class-id> <category>testing</category><body package="PDF Complex Objects">subsumesArray: aPDFArray	^aPDFArray isType: self asDirectType</body><body package="PDF Complex Objects">subsumesDictionary: aPDFDictionary	^aPDFDictionary isType: self asDirectType</body><body package="PDF Complex Objects">subsumesObject: aPDFObject	^aPDFObject isType: self asDirectType</body><body package="PDF Complex Objects">subsumesReference: aPDFReference	^aPDFReference referent isType: self asDirectType</body></methods><methods><class-id>Graphics.PDF.ClassType</class-id> <category>accessing</category><body package="PDF Complex Objects">name	^self pdfType name asString</body><body package="PDF Complex Objects">specializedObject: aPDFObject	^aPDFObject asType: self asDirectType</body></methods><methods><class-id>Graphics.PDF.ClassType</class-id> <category>comparing</category><body package="PDF Complex Objects">= anObject	^self class == anObject class and: [	self pdfType == anObject pdfType]</body><body package="PDF Complex Objects">hash	^self pdfType hash</body></methods><methods><class-id>Graphics.PDF.ClassType</class-id> <category>converting</category><body package="PDF Complex Objects">asDirectType	^DirectType on: self pdfType</body></methods><methods><class-id>Graphics.PDF.AppearanceCharacteristics class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 19)</body></methods><methods><class-id>Graphics.PDF.Resources</class-id> <category>accessing</category><body package="PDF Document">fonts	"&lt;Dictionary of: Fonts&gt;"	^self at: #Font ifAbsentPut: [Dictionary empty]</body><body package="PDF Document">idFor: aResourceObject	"&lt;Symbol&gt;	find the resource ID for aResourceObject.	If it is not there, add a reference to aResourceObject with a new ID.	aResourceObject knows which resource directory to use and how to name the IDs"	| resourceDictionary newId |	resourceDictionary := self resourceDictionaryFor: aResourceObject.	resourceDictionary keysAndValuesDo: [:key :value |		value object = aResourceObject ifTrue: [			^key]].	newId := self newIdFor: aResourceObject in: resourceDictionary.	resourceDictionary at: newId put: aResourceObject newReference.	^newId</body><body package="PDF Document">newIdFor: aResourceObject in: aResourceDictionary	"&lt;Symbol&gt;	our IDs start with 1 (not with 0 like Illustrator)"	| prefix existingObjects |	prefix := aResourceObject class resourcePrefix.	existingObjects := aResourceDictionary keys select: [:key |		prefix , '*' match: key ignoreCase: false].	^(prefix , (existingObjects size + 1) printString) asSymbol</body><body package="PDF Document">resourceDictionaryFor: aResourceObject	"&lt;Dictionary&gt;"	^self at: aResourceObject class resourceType ifAbsentPut: [Dictionary empty]</body></methods><methods><class-id>Graphics.PDF.NextLineRelativeSetLeading</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #leading		put: self operands last content negated.	aPageGraphics graphicsState		nextLineBy: self operands first content @ self operands last content</body></methods><methods><class-id>Graphics.PDF.NextLineRelativeSetLeading class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Move to the start of the next line, offset from the start of the current line by (tx, ty). As a side effect, this operator shall set the leading parameter in the text state. This operator shall have the same effect as this code:	-ty TL	tx ty Td'</body><body package="PDF Graphics Operations">operandTypes	^#(#('x' Number) #('y' Number))</body><body package="PDF Graphics Operations">operatorName	^#TD</body></methods><methods><class-id>Graphics.PDF.OutputIntent class</class-id> <category>accessing</category><body package="PDF Document">version	^4</body></methods><methods><class-id>Graphics.PDF.FileAttachmentAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 15)</body><body package="PDF Interactive Features">subtype	^#FileAttachment</body><body package="PDF Interactive Features">version	^3</body></methods><methods><class-id>Graphics.PDF.FillEvenOddAndStrokeClosed class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Close, fill, and then stroke the path, using the even-odd rule to determine the region to fill. This operator shall have the same effect as the sequence h B*'</body><body package="PDF Graphics Operations">operatorName	^#'b*'</body></methods><methods><class-id>Graphics.PDF.ImageXObject</class-id> <category>accessing</category><body package="PDF Images">bitsFromBytes: numberOfBytes at: byteIndex	"&lt;Integer&gt;	the bits (numberOfBytes * 8) from the pixel array"	^(self internal copyFrom: byteIndex + 1 to: byteIndex + numberOfBytes) asByteArray inject: 0 into: [:num :byte |		(num bitShift: 8) + byte]</body><body package="PDF Images">bitsPerComponent	"&lt;Integer&gt;"	^self BitsPerComponent asSmalltalkValue</body><body package="PDF Images">bitsPerComponent: anInteger	self at: #BitsPerComponent put: (self class nativeBitsPerComponentFor: anInteger)</body><body package="PDF Images">bitsPerPixel	"&lt;Integer&gt;"	self isMask ifTrue: [		^1].	^self numberOfComponents * self bitsPerComponent</body><body package="PDF Images">bitsPerRow	"&lt;Integer&gt;"	^self bitsPerPixel * self width</body><body package="PDF Images">byteArrayFor: anInteger size: numberOfBytes	"&lt;ByteArray&gt;	the bits of anInteger are converted to numberOfBytes bytes.	Leading bits are ignored"	| bytes toConvert |	bytes := ByteArray new: numberOfBytes.	toConvert := anInteger.	numberOfBytes to: 1 by: -1 do: [:index |		bytes at: index put: (toConvert bitAnd: 255).		toConvert := toConvert bitShift: -8].	^bytes</body><body package="PDF Images">bytesPerImage	^self height * self bytesPerRow</body><body package="PDF Images">bytesPerRow	"&lt;Integer&gt;"	^(self bitsPerRow / 8) ceiling</body><body package="PDF Images">clearMaskForBytes: numberOfBytes shiftedRigthBy: bitsRight	| fullMask pixelMask |	fullMask := (1 bitShift: numberOfBytes * 8) - 1.	pixelMask := self pixelMask bitShift: bitsRight.	^fullMask bitXor: pixelMask</body><body package="PDF Images">combined: newInteger size: numberOfBytes shiftedRightBy: bitsRight at: bytesStart	^(self maskedBitsForBytes: numberOfBytes shiftedRightBy: bitsRight at: bytesStart) + (newInteger bitShift: bitsRight)</body><body package="PDF Images">conversionColorspace	"masks do not have a color space"	self isMask ifTrue: [		^DeviceGray new].	^self ColorSpace</body><body package="PDF Images">defaultDecodeArray	self isMask ifTrue: [		^#(0 1) asPDF].	^self ColorSpace defaultDecodeArray</body><body package="PDF Images">depth	"&lt;Integer&gt;	the significant number of bits per pixel.	Must be the same or lower than #bitsPerPixel"	| maxComponent depth rst |	self hasDecode ifFalse: [		^self bitsPerPixel].	maxComponent := self maxComponent.	depth := 0.	rst := self Decode asSmalltalkValue readStream.	[rst atEnd] whileFalse: [		| dMin dMax maxValue |		dMin := rst next.		dMax := rst next.		maxValue := maxComponent / (dMax - dMin).		depth := depth + maxValue rounded abs highBit].	^depth</body><body package="PDF Images">depthsPerComponent	"&lt;Array of: Integer&gt;	the significant number of bits per component.	Only relevant with a #Decode array.	Provisorial: assumes that min is 0 and that min is smaller than max"	| maxComponent depths rst |	self isMask ifTrue: [		^#(1)].	self hasDecode ifFalse: [		^Array new: self numberOfComponents withAll: self bitsPerComponent].	maxComponent := self maxComponent.	depths := OrderedCollection new.	rst := self Decode asSmalltalkValue readStream.	[rst atEnd] whileFalse: [		depths add: (maxComponent / (rst next max: rst next)) rounded highBit].	^depths</body><body package="PDF Images">extent	^self width @ self height</body><body package="PDF Images">height	^self Height asSmalltalkValue</body><body package="PDF Images">maskedBitsForBytes: numberOfBytes shiftedRightBy: bitsRight at: bytesStart	| clearMask oldInteger |	oldInteger := self bitsFromBytes: numberOfBytes at: bytesStart.	clearMask := self clearMaskForBytes: numberOfBytes shiftedRigthBy: bitsRight.	^oldInteger bitAnd: clearMask</body><body package="PDF Images">maxComponent	^(1 bitShift: self bitsPerComponent) - 1</body><body package="PDF Images">numberOfComponents	self isMask ifTrue: [		^1].	^self ColorSpace numberOfComponents</body><body package="PDF Images">numberOfPixel	^self width * self height</body><body package="PDF Images">oneBitPalette	self isMask ifTrue: [		^CoveragePalette monoMaskPalette].	^MonoMappedPalette blackWhite</body><body package="PDF Images">pixelBitsForPaint: aPaint	"&lt;Integer&gt;"	^self conversionColorspace bitsFor: aPaint withSizes: self depthsPerComponent</body><body package="PDF Images">pixelMask	^(1 bitShift: self bitsPerPixel) - 1</body><body package="PDF Images">pixelPaintForBits: anInteger	"&lt;ColorValue | CoverageValue&gt;"	self isMask ifTrue: [		^self conversionColorspace			coverageAt: anInteger			withSizes: self depthsPerComponent			decodeWith: self Decode asSmalltalkValue].	^self conversionColorspace		colorAt: anInteger		withSizes: self depthsPerComponent		decodeWith: self Decode asSmalltalkValue</body><body package="PDF Images">procSet	self isMask ifTrue: [		^#ImageB].	^self ColorSpace procSet</body><body package="PDF Images">setBytes: aByteArray at: indexInteger	self internal		replaceBytesFrom: indexInteger + 1		to: indexInteger + aByteArray size		with: aByteArray asByteString		startingAt: 1.	self resetExternal</body><body package="PDF Images">startBitIndexAt: aPoint	"&lt;Integer&gt;	start bit position of the pixel bits"	^(aPoint y * self bytesPerRow bitShift: 3) + (aPoint x * self bitsPerPixel)</body><body package="PDF Images">uniqueColorValues	"&lt;Collection of: ColorValue&gt;"	| colors |	colors := Set new: self height * self width // 10.	self pixelsDo: [:x :y | colors add: (self valueAtPoint: x @ y)].	^colors</body><body package="PDF Images">valueAtPoint: aPoint	"&lt;Paint&gt;	The paint at pixel location aPoint (zero based)"	| bitsStart bytesStart bitsLeft numberOfBytes bitsRight bits rightAlignedBits maskedBits |	bitsStart := self startBitIndexAt: aPoint.	bytesStart := bitsStart bitShift: -3.	bitsLeft := bitsStart bitAnd: 7.	numberOfBytes := ((bitsLeft + self bitsPerPixel) / 8) ceiling.	bitsRight := numberOfBytes * 8 - bitsLeft - self bitsPerPixel.	bits := self bitsFromBytes: numberOfBytes at: bytesStart.	rightAlignedBits := bits bitShift: bitsRight negated.	maskedBits := rightAlignedBits bitAnd: self pixelMask.	^self pixelPaintForBits: maskedBits</body><body package="PDF Images">valueAtPoint: aPoint put: aPaint	"&lt;Paint&gt;	Put aPaint at pixel location aPoint (zero based)"	| newBits bitsStart bytesStart bitsLeft numberOfBytes bitsRight bitsToWrite bytes |	newBits := self pixelBitsForPaint: aPaint.	bitsStart := self startBitIndexAt: aPoint.	bytesStart := bitsStart bitShift: -3.	bitsLeft := bitsStart bitAnd: 7.	numberOfBytes := ((bitsLeft + self bitsPerPixel) / 8) ceiling.	bitsRight := numberOfBytes * 8 - bitsLeft - self bitsPerPixel.	bitsToWrite := (bitsLeft + bitsRight) isZero		ifTrue: [newBits]		ifFalse: [		self combined: newBits size: numberOfBytes shiftedRightBy: bitsRight at: bytesStart].	bytes := self byteArrayFor: bitsToWrite size: numberOfBytes.	self setBytes: bytes at: bytesStart.	^aPaint</body><body package="PDF Images">width	^self Width asSmalltalkValue</body></methods><methods><class-id>Graphics.PDF.ImageXObject</class-id> <category>testing</category><body package="PDF Images">hasDecode	^self hasKey: #Decode</body><body package="PDF Images">isIndexed	^self isMask not and: [	self ColorSpace isKindOf: Indexed]</body><body package="PDF Images">isMask	^self ImageMask asSmalltalkValue</body><body package="PDF Images">isStandard1BitBWOrMask	"&lt;Boolean&gt;	if true, the optimized image conversion can be used"	self bitsPerComponent = 1 ifFalse: [		^false].	self isMask ifTrue: [		^self Decode asSmalltalkValue = #(1 0)].	^self Decode = self defaultDecodeArray and: [	self ColorSpace asSmalltalkValue = #DeviceGray]</body><body package="PDF Images">isStandard8BitGray	^self bitsPerComponent = 8 and: [	self Decode = self defaultDecodeArray and: [	self ColorSpace asSmalltalkValue = #DeviceGray]]</body><body package="PDF Images">isStandard8BitRGB	^self bitsPerComponent = 8 and: [	self Decode = self defaultDecodeArray and: [	self ColorSpace asSmalltalkValue = #DeviceRGB]]</body></methods><methods><class-id>Graphics.PDF.ImageXObject</class-id> <category>converting</category><body package="PDF Images">addDecodeIfNeededFor: sourceBitsPerComponent	"If the source image bitsPerComponent is smaller than the bitsPerComponent of the receiver,	add a /Decode array to scale the values"	| decodeArray |	(sourceBitsPerComponent allSatisfy: [:bits | bits = self bitsPerComponent]) ifTrue: [		^self].	decodeArray := sourceBitsPerComponent inject: Array new into: [:decode :bits |		decode , (Array			with: 0			with: self maxComponent / ((1 bitShift: bits) - 1))].	self at: #Decode put: decodeArray</body><body package="PDF Images">addSoftMaskWithBytes: aByteArray	| softMask |	softMask := SoftMaskImage empty.	softMask at: #Width put: self width.	softMask at: #Height put: self height.	softMask at: #BitsPerComponent put: self bitsPerComponent.	softMask at: #ColorSpace put: #DeviceGray.	softMask contents: aByteArray asByteString.	self at: #SMask put: softMask newReference</body><body package="PDF Images">asSmalltalkValue	"&lt;Image&gt;	create an Smalltalk image with RGB or coverage colors"	| image palette |	(self hasKey: #SMask) ifTrue: [		image := Image extent: self width @ self height depth: 32 palette: FixedPalette bgr8Bit.		image readPixelsFrom: self.		^AlphaCompositedImage image: image].	palette := self palette.	image := Image extent: self width @ self height depth: palette depth palette: palette.	image readPixelsFrom: self.	(self hasKey: #Mask) ifTrue: [		^OpaqueImage			figure: (CachedImage on: image)			shape: (CachedImage on: self Mask asSmalltalkValue)].	^image</body><body package="PDF Images">palette	"&lt;Palette&gt;	new palette suitable for a converted Smalltalk image"	self isMask ifTrue: [		^CoveragePalette monoMaskPalette].	^self ColorSpace paletteFor: self</body></methods><methods><class-id>Graphics.PDF.ImageXObject</class-id> <category>actions</category><body package="PDF Images">addProcSetTo: aRenderer	aRenderer addProcSet: self procSet</body><body package="PDF Images">setDecodeExplicitly	"trick to force a FixedPalette when converting to a Smalltalk image"	self at: #Decode put: self Decode</body></methods><methods><class-id>Graphics.PDF.ImageXObject</class-id> <category>printing</category><body package="PDF Images">colorTypeName	"&lt;String&gt;	for the printString"	self isMask ifTrue: [		^'Mask'].	^self ColorSpace class name asString</body><body package="PDF Images">printOn: stream	stream		nextPutAll: self class name asString;		nextPutAll: '(';		nextPutAll: self width printString;		nextPutAll: ' @ ';		nextPutAll: self height printString;		nextPutAll: ' ';		nextPutAll: self colorTypeName;		nextPutAll: ' ';		nextPutAll: self bitsPerComponent printString;		nextPut: $)</body></methods><methods><class-id>Graphics.PDF.ImageXObject</class-id> <category>enumerating</category><body package="PDF Images">pixelsDo: aBlock	0 to: self height - 1 do: [:rowIndex |		0 to: self width - 1 do: [:columnIndex | aBlock value: columnIndex value: rowIndex]]</body></methods><methods><class-id>Graphics.PDF.ImageXObject</class-id> <category>initialize-release</category><body package="PDF Images">initializeFrom: anImage	self at: #Width put: anImage width.	self at: #Height put: anImage height.	anImage palette setImagePropertiesOf: self.	anImage writePixelsTo: self.	self filter: #FlateDecode</body><body package="PDF Images">initializeImageBits	self contents: (ByteString new: self bytesPerImage)</body><body package="PDF Images">resetImageProperties	"undo any potential change made by #setImagePropertiesOf:"	self at: #BitsPerComponent put: nil.	self at: #ColorSpace put: nil.	self at: #ImageMask put: nil.	self at: #Decode put: nil</body></methods><methods><class-id>Graphics.PDF.ImageXObject class</class-id> <category>accessing</category><body package="PDF Images">nativeBitsPerComponentFor: numberOfBits	numberOfBits &gt; 8 ifTrue: [		^16].	numberOfBits &gt; 4 ifTrue: [		^8].	numberOfBits &gt; 2 ifTrue: [		^4].	numberOfBits &gt; 1 ifTrue: [		^2].	^1</body><body package="PDF Images">resourcePrefix	^'Im'</body><body package="PDF Images">subtype	^#Image</body></methods><methods><class-id>Graphics.PDF.ImageXObject class</class-id> <category>instance creation</category><body package="PDF Images">empty	| inst |	inst := super empty.	inst at: #Type put: self type.	^inst</body><body package="PDF Images">from: anImage	| inst |	inst := self empty.	inst initializeFrom: anImage.	^inst</body></methods><methods><class-id>Graphics.PDF.SoftMaskImage class</class-id> <category>accessing</category><body package="PDF Images">documentationPlace	^#(11 6 5 3)</body><body package="PDF Images">subtype	^self name</body></methods><methods><class-id>Graphics.PDF.Dest class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 3 2 3)</body></methods><methods><class-id>Graphics.PDF.SetFlatness</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #flatness put: self operands first</body></methods><methods><class-id>Graphics.PDF.SetFlatness class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the flatness tolerance in the graphics state. flatness is a number in the range 0 to 100; a value of 0 shall specify the output device’s default flatness tolerance'</body><body package="PDF Graphics Operations">operandTypes	^#(#('flatness' Integer))</body><body package="PDF Graphics Operations">operatorName	^#i</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSubsection</class-id> <category>comparing</category><body package="PDF Files">= anObject	^self class == anObject class and: [	self firstNumber = anObject firstNumber and: [	self entries isSameSequenceAs: anObject entries]]</body><body package="PDF Files">entriesHash	^self entries inject: 0 into: [:hash :entry | hash bitXor: entry hash]</body><body package="PDF Files">hash	^self firstNumber hash bitXor: self entriesHash</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSubsection</class-id> <category>enumerating</category><body package="PDF Files">referencesDo: oneArgumentBlock	self entries do: [:entry | oneArgumentBlock value: entry]</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSubsection</class-id> <category>accessing</category><body package="PDF Files">atNumber: anInteger ifAbsent: zeroArgumentBlock	"&lt;CrossReference&gt;"	(anInteger between: self firstNumber and: self lastNumber) ifFalse: [		^zeroArgumentBlock value].	^self entries at: anInteger - self firstNumber + 1</body><body package="PDF Files">crossReferenceAt: aPDFReference ifAbsent: zeroArgumentBlock	"&lt;CrossReference&gt;"	| entry |	(aPDFReference number between: self firstNumber and: self lastNumber) ifFalse: [		^zeroArgumentBlock value].	entry := self entries at: aPDFReference number - self firstNumber + 1.	(entry matches: aPDFReference) ifTrue: [		^entry].	^zeroArgumentBlock value</body><body package="PDF Files">entries	"&lt;SequenceableCollection of: CrossReference&gt;"	^entries ifNil: [entries := OrderedCollection new]</body><body package="PDF Files">firstNumber	"&lt;Integer&gt;	the object number of the first object in this subsection"	^firstNumber</body><body package="PDF Files">lastNumber	^self firstNumber + self entries size - 1</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSubsection</class-id> <category>writing</category><body package="PDF Files">writeOn: aPDFWritestream indent: integer	aPDFWritestream		nextPutAll: self firstNumber printString;		space;		nextPutAll: self entries size printString;		cr.	self entries do: [:entry | entry writeOn: aPDFWritestream indent: integer]</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSubsection</class-id> <category>printing</category><body package="PDF Files">printOn: aStream	aStream		nextPutAll: self class name asString;		nextPut: $(;		nextPutAll: self firstNumber printString;		space;		nextPutAll: self entries size printString;		nextPut: $)</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSubsection</class-id> <category>initialize-release</category><body package="PDF Files">initializeFirstNumber: firstNumberInteger entries: entriesArray	firstNumber := firstNumberInteger.	entries := entriesArray</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSubsection class</class-id> <category>reading</category><body package="PDF Files">readFrom: aParser	"&lt;CrossReferenceSubsection&gt;"	| firstObjectNumber count |	firstObjectNumber := aParser nextInteger.	count := aParser nextInteger.	aParser skipWhitespace.	^self		firstNumber: firstObjectNumber		entries: ((1 to: count) collect: [:i |			CrossReference read: firstObjectNumber + i - 1 from: aParser]) asArray</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSubsection class</class-id> <category>instance creation</category><body package="PDF Files">firstNumber: firstNumberInteger entries: entriesArray	| inst |	inst := self new.	inst initializeFirstNumber: firstNumberInteger entries: entriesArray.	^inst</body><body package="PDF Files">initialOn: someCrossReferences	"&lt;CrossReferenceSubsection&gt;	For a PDF that holds all references in only one CrossReferenceSection in only one CrossReferenceSubsection"	^self		firstNumber: 0		entries: (Array with: FreeReference initial) , someCrossReferences</body></methods><methods><class-id>Graphics.PDF.SetGraphicsState</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	| state |	state := self resourceIn: aPageGraphics.	state setStateIn: aPageGraphics</body></methods><methods><class-id>Graphics.PDF.SetGraphicsState</class-id> <category>accessing</category><body package="PDF Graphics Operations">resourceIn: aPageGraphics	^aPageGraphics resources ExtGState objectAt: self operands first content</body></methods><methods><class-id>Graphics.PDF.SetGraphicsState class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the specified parameters in the graphics state. dictName shall be the name of a graphics state parameter dictionary in the ExtGState subdictionary of the current resource dictionary'</body><body package="PDF Graphics Operations">operandTypes	^#(#('dictName' Name))</body><body package="PDF Graphics Operations">operatorName	^#gs</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_2</body></methods><methods><class-id>Graphics.PDF.JPXDecode</class-id> <category>accessing</category><body package="PDF Filter">pdfVersion	^Version pdf1_5</body></methods><methods><class-id>Graphics.PDF.SampledFunction class</class-id> <category>accessing</category><body package="PDF Data Structures">functionType	^0</body></methods><methods><class-id>Graphics.PDF.SetJoin</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #lineJoin put: self operands first</body></methods><methods><class-id>Graphics.PDF.SetJoin class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the line join style in the graphics state'</body><body package="PDF Graphics Operations">operandTypes	^#(#('lineJoin' Number))</body><body package="PDF Graphics Operations">operatorName	^#j</body></methods><methods><class-id>Graphics.PDF.LatticeFormGouraudShadedMesh class</class-id> <category>accessing</category><body package="PDF Shading">shadingType	^5</body></methods><methods><class-id>Graphics.PDF.ExponentialInterpolationFunction class</class-id> <category>accessing</category><body package="PDF Data Structures">functionType	^2</body></methods><methods><class-id>Graphics.PDF.Rectangle</class-id> <category>converting</category><body package="PDF Data Structures">normalized	"&lt;Rectangle&gt;	where llx @ lly is the lower left corner and urx @ ury is the upper right corner"	| new |	new := self class empty.	self llx asSmalltalkValue &lt;= self urx asSmalltalkValue		ifTrue: [		new at: 1 put: (self at: 1).		new at: 3 put: (self at: 3)]		ifFalse: [		new at: 1 put: (self at: 3).		new at: 3 put: (self at: 1)].	self lly asSmalltalkValue &lt;= self ury asSmalltalkValue		ifTrue: [		new at: 2 put: (self at: 2).		new at: 4 put: (self at: 4)]		ifFalse: [		new at: 2 put: (self at: 4).		new at: 4 put: (self at: 2)].	^new</body></methods><methods><class-id>Graphics.PDF.Rectangle class</class-id> <category>instance creation</category><body package="PDF Data Structures">fromRectangle: aRectangle	^self		with: aRectangle left		with: aRectangle origin y		with: aRectangle right		with: aRectangle corner y</body></methods><methods><class-id>Graphics.PDF.Rectangle class</class-id> <category>accessing</category><body package="PDF Data Structures">numberOfAttributes	^4</body></methods><methods><class-id>Graphics.PDF.ReadError class</class-id> <category>signalling</category><body package="PDF basics">newWith: positionInteger message: aString	"Create an exception without raising it"	^(self new)		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		messageText: aString;		parameter: positionInteger;		yourself</body></methods><methods><class-id>Graphics.PDF.LineAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 7)</body><body package="PDF Interactive Features">subtype	^#Line</body><body package="PDF Interactive Features">version	^3</body></methods><methods><class-id>Graphics.PDF.SoftMask class</class-id> <category>accessing</category><body package="PDF XObjects">documentationPlace	^#(11 6 5 2)</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingGray</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #colorSpaceNonstroking put: DeviceGray new.	aPageGraphics graphicsState at: #colorNonstroking put: self operands</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingGray class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Same as G but used for nonstroking operations'</body><body package="PDF Graphics Operations">operandTypes	^#(#('gray' Number))</body><body package="PDF Graphics Operations">operatorName	^#g</body></methods><methods><class-id>Graphics.PDF.ConcatenateMatrix</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #CTM		put: (aPageGraphics graphicsState CTM				concatinatedWith: (Matrix on: self operands))</body></methods><methods><class-id>Graphics.PDF.ConcatenateMatrix class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Modify the current transformation matrix (CTM) by concatenating the specified matrix. Although the operands specify a matrix, they shall be written as six separate numbers, not as an array'</body><body package="PDF Graphics Operations">operandTypes	^#(#('a' Number) #('b' Number) #('c' Number) #('d' Number) #('e' Number) #('f' Number))</body><body package="PDF Graphics Operations">operatorName	^#cm</body></methods><methods><class-id>Graphics.PDF.ShowTextOnNextLineWithSpacing</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #wordSpacing put: self operands first.	aPageGraphics graphicsState at: #characterSpacing put: (self operands at: 2).	aPageGraphics graphicsState nextLineBy: 0 @ aPageGraphics graphicsState leading content negated.	aPageGraphics graphicsState		at: #textMatrix		put: (aPageGraphics graphicsState textMatrix translatedBy: (aPageGraphics stringWidth: self operands last) @ 0)</body></methods><methods><class-id>Graphics.PDF.ShowTextOnNextLineWithSpacing class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Move to the next line and show a text string, using aw as the word spacing and ac as the character spacing (setting the corresponding parameters in the text state). aw and ac shall be numbers expressed in unscaled text space units. This operator shall have the same effect as this code:	aw Tw	ac Tc	string '''</body><body package="PDF Graphics Operations">operandTypes	^#(#('aw' Number) #('ac' Number) #('string' String))</body><body package="PDF Graphics Operations">operatorName	^#'"'</body></methods><methods><class-id>Graphics.PDF.Dash</class-id> <category>copying</category><body package="PDF Graphics">scaled: aNumber	^self class		array: (self array content collect: [:elem | elem * aNumber])		offset: self offset content * aNumber</body></methods><methods><class-id>Graphics.PDF.Dash</class-id> <category>accessing</category><body package="PDF Graphics">string	"&lt;String&gt;	the PostScript source arguments for setdash. Default: '[] 0' "	^self pdfSource</body></methods><methods><class-id>Graphics.PDF.Dash</class-id> <category>initialize-release</category><body package="PDF Graphics">initializeArray: arrayArray offset: offsetNumber	self at: 1 put: (Array withAll: (arrayArray ifNil: [#()])).	self at: 2 put: (offsetNumber ifNil: [0])</body></methods><methods><class-id>Graphics.PDF.Dash</class-id> <category>printing</category><body package="PDF Graphics">printvalueWith: printer	| wst |	wst := ByteString new writeStream.	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' array: ';		nextPutAll: self array asSmalltalkValue printString;		nextPutAll: ' offset: ';		nextPutAll: self offset asSmalltalkValue printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Graphics.PDF.Dash class</class-id> <category>instance creation</category><body package="PDF Graphics">array: arrayArray	^self array: arrayArray offset: 0</body><body package="PDF Graphics">array: arrayArray offset: offsetNumber	| inst |	inst := self empty.	inst initializeArray: arrayArray offset: offsetNumber.	^inst</body><body package="PDF Graphics">empty	| empty |	empty := super empty.	empty at: 1 put: #().	empty at: 2 put: 0.	^empty</body><body package="PDF Graphics">offset: offsetNumber	^self array: #() offset: offsetNumber</body></methods><methods><class-id>Graphics.PDF.Dash class</class-id> <category>accessing</category><body package="PDF Graphics">numberOfAttributes	^2</body></methods><methods><class-id>Graphics.PDF.OptionalContentConfiguration class</class-id> <category>accessing</category><body package="PDF Data Structures">version	^5</body></methods><methods><class-id>Graphics.PDF.Matrix</class-id> <category>operations</category><body package="PDF Graphics">concatinatedWith: otherMatrix	"&lt;Matrix&gt;"	| a b c d e f a2 b2 c2 d2 e2 f2 new |	a := self a asSmalltalkValue. b := self b asSmalltalkValue.	c := self c asSmalltalkValue. d := self d asSmalltalkValue.	e := self e asSmalltalkValue. f := self f asSmalltalkValue.	a2 := otherMatrix a asSmalltalkValue. b2 := otherMatrix b asSmalltalkValue.	c2 := otherMatrix c asSmalltalkValue. d2 := otherMatrix d asSmalltalkValue.	e2 := otherMatrix e asSmalltalkValue. f2 := otherMatrix f asSmalltalkValue.	new := Array new: 6.	new at: 1 put: a * a2 + (b * c2).	new at: 2 put: a * b2 + (b * d2).	new at: 3 put: c * a2 + (d * c2).	new at: 4 put: c * b2 + (d * d2).	new at: 5 put: e * a2 + (f * c2) + e2.	new at: 6 put: e * b2 + (f * d2) + f2.	^self class on: new</body><body package="PDF Graphics">rotatedBy: radian	^self concatinatedWith: (self class rotation: radian)</body><body package="PDF Graphics">rotatedByDegrees: degrees	^self concatinatedWith: (self class rotationDegrees: degrees)</body><body package="PDF Graphics">scaledBy: aPoint	^self concatinatedWith: (self class scaling: aPoint)</body><body package="PDF Graphics">translatedBy: aPoint	"&lt;Matrix&gt;	new matrix translated by aPoint"	^self concatinatedWith: (self class translation: aPoint)</body></methods><methods><class-id>Graphics.PDF.Matrix class</class-id> <category>instance creation</category><body package="PDF Graphics">empty	^self identity</body><body package="PDF Graphics">identity	^self on: #(1 0 0 1 0 0)</body><body package="PDF Graphics">rotation: radians	"&lt;Matrix&gt;	rotate counter-clock wise.	0 is to the right"	| cos sin matrix |	cos := radians cos.	sin := radians sin.	matrix := self identity.	matrix at: 1 put: cos.	matrix at: 2 put: sin.	matrix at: 3 put: sin negated.	matrix at: 4 put: cos.	^matrix</body><body package="PDF Graphics">rotationDegrees: degrees	"&lt;Matrix&gt;	rotate counter-clock wise.	0 is to the right"	^self rotation: degrees degreesToRadians</body><body package="PDF Graphics">scaling: aPoint	| m |	m := self identity.	m at: 1 put: aPoint x.	m at: 4 put: aPoint y.	^m</body><body package="PDF Graphics">translation: aPoint	| m |	m := self identity.	m at: 5 put: aPoint x.	m at: 6 put: aPoint y.	^m</body><body package="PDF Graphics">xFrom: fromPoint to: toPoint	"&lt;Matrix&gt;	a coordinate system defined by two points.	The x-axis starts at fromPoint progresses towards toPoint"	| diff dist |	diff := toPoint - fromPoint.	dist := diff r.	^((self rotation: diff theta) scaledBy: dist @ dist) translatedBy: fromPoint</body></methods><methods><class-id>Graphics.PDF.Matrix class</class-id> <category>accessing</category><body package="PDF Graphics">numberOfAttributes	^6</body></methods><methods><class-id>Graphics.PDF.EndPath class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'End the path object without filling or stroking it. This operator shall be a path-painting no-op, used primarily for the side effect of changing the current clipping path'</body><body package="PDF Graphics Operations">operatorName	^#n</body></methods><methods><class-id>Graphics.PDF.BeginText</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	aPageGraphics pushCollector: TextObject new.	aPageGraphics graphicsState at: #textMatrix put: nil.	aPageGraphics graphicsState at: #textLineMatrix put: nil</body></methods><methods><class-id>Graphics.PDF.BeginText class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Begin a text object, initializing the text matrix, Tm, and the text line matrix, Tlm, to the identity matrix. Text objects shall not be nested; a second BT shall not appear before an ET'</body><body package="PDF Graphics Operations">end	^EndText</body><body package="PDF Graphics Operations">operatorName	^#BT</body></methods><methods><class-id>Graphics.PDF.TextObject</class-id> <category>writing</category><body package="PDF Graphics">postfix	^'ET'</body><body package="PDF Graphics">prefix	^'BT'</body></methods><methods><class-id>Graphics.PDF.OptionalContentUsage class</class-id> <category>accessing</category><body package="PDF Data Structures">version	^5</body></methods><methods><class-id>Graphics.PDF.PrinterMarkAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 20)</body><body package="PDF Interactive Features">subtype	^#PrinterMark</body><body package="PDF Interactive Features">version	^4</body></methods><methods><class-id>Graphics.PDF.ASCIIHexDecode</class-id> <category>accessing</category><body package="PDF Filter">decoded	self external isSignalledException ifTrue: [		^self external].	^(HexStringEncoder readStreamOn: (self external readStream upTo: $&gt;) readStream) contents</body><body package="PDF Filter">encoded	| stream |	self internal isSignalledException ifTrue: [		^self internal].	stream := HexStringEncoder writeStream.	stream lineEndLF.	stream nextPutAll: self internal.	stream close.	stream stream nextPut: $&gt; asInteger.	^stream stream contents asByteString</body></methods><methods><class-id>Graphics.PDF.PaintXObject</class-id> <category>accessing</category><body package="PDF Graphics Operations">resourceIn: aPageGraphics	^aPageGraphics resources XObject objectAt: self operands first content</body></methods><methods><class-id>Graphics.PDF.PaintXObject class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Paint the specified XObject. The operand name shall appear as a key in the XObject subdictionary of the current resource dictionary. The associated value shall be a stream whose Type entry, if present, is XObject. The effect of Do depends on the value of the XObject’s Subtype entry, which may be Image, Form, or PS'</body><body package="PDF Graphics Operations">operandTypes	^#(#('name' Name))</body><body package="PDF Graphics Operations">operatorName	^#Do</body></methods><methods><class-id>Graphics.PDF.PathObject</class-id> <category>accessing</category><body package="PDF Graphics">allOperations	| list |	list := self operations asOrderedCollection.	self clipping ifNotNil: [:operator | list add: operator].	list add: self painting.	^list</body><body package="PDF Graphics">clipping	"&lt;ClippingPathOperator | nil&gt;	modifies the clipping path of the graphics state AFTER the path has been painted"	^clipping</body><body package="PDF Graphics">intersections	"&lt;SequenceableCollection of: PathObject&gt;	the receiver is clipped by the paths in #intersections starting with the first (oldest). 	Used for the clipping path of the graphics state"	^intersections ifNil: [intersections := OrderedCollection new]</body><body package="PDF Graphics">painting	"&lt;PathPaintingOperator&gt;"	^painting</body></methods><methods><class-id>Graphics.PDF.PathObject</class-id> <category>actions</category><body package="PDF Graphics">addClipping: aClippingPathOperator	clipping := aClippingPathOperator</body><body package="PDF Graphics">addPainting: aPathPaintingOperator	painting := aPathPaintingOperator</body><body package="PDF Graphics">addToPath: aPathConstructionOperator	self operations add: aPathConstructionOperator</body></methods><methods><class-id>Graphics.PDF.PathObject</class-id> <category>copying</category><body package="PDF Graphics">intersectedBy: aPath	"&lt;PathObject&gt;"		| copy |	copy := self copy.	copy intersections add: aPath.	^copy</body></methods><methods><class-id>Graphics.PDF.UnderlineAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">subtype	^#Underline</body></methods><methods><class-id>Graphics.PDF.FileIdentifier</class-id> <category>writing</category><body package="PDF Files">writeOn: aStream indent: integer	aStream		nextPut: $[;		tab.	self content do: [:element | aStream nextPutHexString: element] separatedBy: [		aStream cr.		integer + 1 timesRepeat: [aStream tab]].	aStream nextPut: $]</body></methods><methods><class-id>Graphics.PDF.FileIdentifier class</class-id> <category>accessing</category><body package="PDF Files">numberOfAttributes	^2</body><body package="PDF Files">version	^1</body></methods><methods><class-id>Graphics.PDF.WatermarkAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 22)</body><body package="PDF Interactive Features">subtype	^#Watermark</body><body package="PDF Interactive Features">version	^6</body></methods><methods><class-id>Graphics.PDF.NameTreeLeaf</class-id> <category>accessing</category><body package="PDF Data Structures">elements	| elements rst |	elements := OrderedCollection new.	rst := self Names content readStream.	[rst atEnd] whileFalse: [elements add: rst next -&gt; rst next].	^elements</body></methods><methods><class-id>Graphics.PDF.DocumentInformation class</class-id> <category>instance creation</category><body package="PDF Files">empty	"&lt;DocumentInformation&gt;	basic infos of a generated PDF.	The following information should be added by the application:		#Title a Textstring with the document’s title.		#Author a Textstring with the name of the person who created the document.		#Creator a Textstring with the name of the application that created the document.	Also, #Subject and #Keywords may be useful"	| inst timestamp |	inst := super empty.	timestamp := Timestamp now.	inst at: #CreationDate put: timestamp.	inst at: #ModDate put: timestamp.	inst at: #Producer put: PDF producerText.	^inst</body></methods><methods><class-id>Graphics.PDF.DocumentInformation class</class-id> <category>accessing</category><body package="PDF Files">documentationPlace	^#(14 3 3)</body></methods><methods><class-id>Graphics.PDF.FileSpecification class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(7 11 3)</body><body package="PDF Interactive Features">type	^#Filespec</body></methods><methods><class-id>Graphics.PDF.Writer</class-id> <category>writing</category><body package="PDF basics">nextPutHexString: aPDFString	| stream |	stream := HexStringEncoder writeStream.	stream lineEndLF.	stream nextPutAll: aPDFString content asByteString.	stream close.	self nextPut: $&lt;.	self nextPutAll: stream stream contents asByteString.	self nextPut: $&gt;</body><body package="PDF basics">nextPutName: aPDFName	self nextPut: $/.	self nextPutNameWithoutSolidus: aPDFName</body><body package="PDF basics">nextPutNameWithoutSolidus: aPDFName	| stream |	(aPDFName content isNil or: [	aPDFName content isEmpty]) ifTrue: [		^self].	stream := NameEncoder writeStream.	stream nextPutAll: aPDFName content asString.	stream close.	self nextPutAll: stream stream contents asByteString</body><body package="PDF basics">nextPutString: aPDFString	self nextPut: $(.	aPDFString isEmpty ifFalse: [		| stream |		stream := StringEncoder writeStream.		stream encoder quoteParenthesis: (self hasUnbalancedParenthesis: aPDFString).		stream lineEndLF.		stream nextPutAll: aPDFString content asByteString.		stream close.		self nextPutAll: stream stream contents asByteString].	self nextPut: $)</body></methods><methods><class-id>Graphics.PDF.Writer</class-id> <category>testing</category><body package="PDF basics">hasUnbalancedParenthesis: aPDFString	| count rst |	count := 0.	rst := aPDFString content asByteString readStream.	[rst atEnd] whileFalse: [		| char |		char := rst next.		char = $( ifTrue: [			count := count + 1].		char = $) ifTrue: [			count := count - 1.			count negative ifTrue: [				^true]]].	^count isZero not</body></methods><methods><class-id>Graphics.PDF.Writer</class-id> <category>character writing</category><body package="PDF basics">cr	self nextPut: Character lf</body></methods><methods><class-id>Graphics.PDF.ExtGState</class-id> <category>adding</category><body package="PDF Graphics">addTransparencyAttributes	self at: #BM put: #Normal.	self at: #SMask put: #None.	self at: #AIS put: false.	self at: #CA put: 1.0.	self at: #ca put: 1.0</body></methods><methods><class-id>Graphics.PDF.ExtGState</class-id> <category>accessing</category><body package="PDF Graphics">gsStateAttributeFor: keySymbol	"&lt;Symbol&gt;	the attribute symbol of the graphics state which corresponds to keySymbol"	| dict |	dict := OrderedDictionary new.	dict at: #Type put: nil.	"special"	dict at: #LW put: #lineWidth.	dict at: #LC put: #lineCap.	dict at: #LJ put: #lineJoin.	dict at: #ML put: #miterLimit.	dict at: #D put: #dashPattern.	dict at: #RI put: #renderingIntent.	dict at: #OP put: nil.	"special"	dict at: #op put: #overprintNonstroking.	dict at: #OPM put: #overprintMode.	dict at: #Font put: nil.	"special"	dict at: #BG put: #blackGeneration.	dict at: #BG2 put: nil.	"special"	dict at: #UCR put: #undercolorRemoval.	dict at: #UCR2 put: nil.	"special"	dict at: #TR put: #transfer.	dict at: #TR2 put: nil.	"special"	dict at: #HT put: #halftone.	dict at: #FL put: #flatness.	dict at: #SM put: #smoothness.	dict at: #SA put: #strokeAdjustment.	dict at: #BM put: #blendMode.	dict at: #SMask put: #softMask.	dict at: #CA put: #alphaConstantStroking.	dict at: #ca put: #alphaConstantNonstroking.	dict at: #AIS put: #alphaSource.	dict at: #TK put: #textKnockout.	^dict at: keySymbol ifAbsent: [keySymbol]</body></methods><methods><class-id>Graphics.PDF.ExtGState</class-id> <category>actions</category><body package="PDF Graphics">setStateIn: aPageGraphics	| specialBehaviors |	specialBehaviors := Core.Dictionary new.	specialBehaviors at: #Type put: [:gs :value | ].	specialBehaviors at: #OP put: [:gs :value |		gs at: #overprintStroking put: value.		(self content includesKey: #op) ifFalse: [gs at: #overprintNonstroking put: value]].	specialBehaviors at: #Font put: [:gs :value |		gs at: #textFont put: (aPageGraphics resources Font keyAtValue: value first).		gs at: #textFontSize put: value last].	specialBehaviors at: #BG2 put: [:gs :value |		gs at: #blackGeneration put: (value = #Default			ifTrue: [GraphicsState new blackGeneration]			ifFalse: [value])].	specialBehaviors at: #UCR2 put: [:gs :value |		gs at: #undercolorRemoval put: (value = #Default			ifTrue: [GraphicsState new undercolorRemoval]			ifFalse: [value])].	specialBehaviors at: #TR2 put: [:gs :value |		gs at: #transfer put: (value = #Default ifTrue: [GraphicsState new transfer] ifFalse: [value])].	self keysAndValuesDo: [:key :value |		(self gsStateAttributeFor: key)			ifNotNil: [:gsKey | aPageGraphics graphicsState at: gsKey put: value]			ifNil: [(specialBehaviors at: key) value: aPageGraphics graphicsState value: value]]</body></methods><methods><class-id>Graphics.PDF.ExtGState class</class-id> <category>constants</category><body package="PDF Graphics">blendModes	^self separableBlendModes , self nonSeparableBlendModes</body><body package="PDF Graphics">nonSeparableBlendModes	^#(#Hue #Saturation #Color #Luminosity)</body><body package="PDF Graphics">separableBlendModes	^#(#Normal #Compatible #Multiply #Screen #Overlay #Darken #Lighten #ColorDodge #ColorBurn #HardLight #SoftLight #Difference #Exclusion)</body></methods><methods><class-id>Graphics.PDF.ExtGState class</class-id> <category>instance creation</category><body package="PDF Graphics">default	| inst |	inst := self empty.	inst at: #SA put: true.	inst at: #OP put: false.	inst at: #op put: false.	inst at: #OPM put: 1.	inst at: #FL put: 0.	inst at: #RI put: #RelativeColorimetric.	^inst</body><body package="PDF Graphics">forTransparency	"&lt;ExtGState&gt;	a graphics state with (default) transparency attributes"	| inst |	inst := self default.	inst addTransparencyAttributes.	^inst</body></methods><methods><class-id>Graphics.PDF.ExtGState class</class-id> <category>accessing</category><body package="PDF Graphics">resourcePrefix	^'GS'</body><body package="PDF Graphics">resourceType	"&lt;Symbol&gt;	the name of a /Resources key"	^#ExtGState</body></methods><methods><class-id>Graphics.PDF.PageRenderer</class-id> <category>actions</category><body package="PDF Rendering">addAnnotation: anAnnot	self product at: #Annots put: (self product Annots with: anAnnot)</body><body package="PDF Rendering">addContents	| contents |	contents := Contents on: OrderedDictionary new internal: self contentSource.	contents filter: #FlateDecode.	self product at: #Contents put: contents newReference</body><body package="PDF Rendering">setupBounds	self product at: #MediaBox put: self bounds.	self product at: #TrimBox put: self bounds</body></methods><methods><class-id>Graphics.PDF.PageRenderer</class-id> <category>rendering</category><body package="PDF Rendering">addTransparencyPageAttributesWithColorspace: aColorspace	"one may want to add /I (isolated) or /K (knock out) attributes"	self product at: #Group ifAbsentPut: [		| attr |		attr := TransparencyGroupAttributes empty.		attr at: #CS put: aColorspace.		attr]</body></methods><methods><class-id>Graphics.PDF.PageRenderer</class-id> <category>accessing</category><body package="PDF Rendering">globalState	^globalState ifNil: [globalState := Dictionary new]</body><body package="PDF Rendering">pageRenderer	^self</body></methods><methods><class-id>Graphics.PDF.EndCompatibility class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'End a compatibility section begun by a balancing BX operator. Ignore any unrecognized operands and operators from previous matching BX onward'</body><body package="PDF Graphics Operations">operatorName	^#EX</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_1</body></methods><methods><class-id>Graphics.PDF.SubPredictor</class-id> <category>filtering</category><body package="PDF Filter">predict: aByteArray withUpperRow: upperByteArray	"&lt;ByteArray&gt;"	| filtered |	filtered := ByteArray new: aByteArray size.	1 to: aByteArray size do: [:index |		| indexLeft a output |		indexLeft := index - self offsetLeft.		a := indexLeft strictlyPositive			ifTrue: [aByteArray at: indexLeft]			ifFalse: [0].		output := (aByteArray at: index) - a.		filtered at: index put: output \\ 256].	^filtered</body><body package="PDF Filter">unpredict: filteredByteArray withUpperRow: upperReconstructedByteArray	"&lt;ByteArray&gt;"	| reconstructed |	reconstructed := ByteArray new: filteredByteArray size.	1 to: filteredByteArray size do: [:index |		| indexLeft a output |		indexLeft := index - self offsetLeft.		a := indexLeft strictlyPositive			ifTrue: [reconstructed at: indexLeft]			ifFalse: [0].		output := (filteredByteArray at: index) + a.		reconstructed at: index put: output \\ 256].	^reconstructed</body></methods><methods><class-id>Graphics.PDF.SubPredictor class</class-id> <category>accessing</category><body package="PDF Filter">type	^1</body></methods><methods><class-id>Graphics.PDF.RestoreState</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	aPageGraphics graphicsState: aPageGraphics graphicsStateStack removeLast key.	aPageGraphics addObject: aPageGraphics popCollector</body></methods><methods><class-id>Graphics.PDF.RestoreState class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Restore the graphics state by removing the most recently saved state from the stack and making it the current state'</body><body package="PDF Graphics Operations">operatorName	^#Q</body></methods><methods><class-id>Graphics.PDF.Movie class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(13 4)</body><body package="PDF Interactive Features">version	^2</body></methods><methods><class-id>Graphics.PDF.ICCBased</class-id> <category>accessing</category><body package="PDF Colour">black	"preliminary implementation"		^self stream Alternate black</body><body package="PDF Colour">colorAt: someBits withSizes: bitsPerComponents decodeWith: anArray	"&lt;ColorValue&gt;"	self stream Alternate asSmalltalkValue = #DeviceRGB ifFalse: [		^self error: 'only /DeviceRGB is supported as base colour space'].	^self stream Alternate colorAt: someBits withSizes: bitsPerComponents decodeWith: anArray</body><body package="PDF Colour">defaultDecodeArray	^self stream Range</body><body package="PDF Colour">initialColourValues	"the initial colour shall have all components equal to 0.0 unless that falls outside the intervals specified by the space’s Range entry, in which case the nearest valid value shall be substituted."	^#(0.0)</body><body package="PDF Colour">numberOfComponents	"given by the #N parameter in the ICC Profile stream"	^self stream N asSmalltalkValue</body></methods><methods><class-id>Graphics.PDF.ICCBased class</class-id> <category>accessing</category><body package="PDF Colour">version	^3</body></methods><methods><class-id>Graphics.PDF.FixedPrint class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 22)</body><body package="PDF Interactive Features">version	^6</body></methods><methods><class-id>Graphics.PDF.FreeReference</class-id> <category>comparing</category><body package="PDF Files">matches: aPDFReference	^(super matches: aPDFReference) and: [	self generation - 1 = aPDFReference generation]</body></methods><methods><class-id>Graphics.PDF.FreeReference</class-id> <category>accessing</category><body package="PDF Files">keyword	^'f'</body></methods><methods><class-id>Graphics.PDF.FreeReference class</class-id> <category>instances</category><body package="PDF Files">initial	^self value: 0 number: 0 generation: 65535</body></methods><methods><class-id>Graphics.PDF.FreeReference class</class-id> <category>accessing</category><body package="PDF Files">type	"Type 0 entries define the linked list of free objects (corresponding to f entries in a cross-reference table).	Field 2: The object number of the next free object.	Field 3: The generation number to use if this object number is used again."	^0</body></methods><methods><class-id>Graphics.PDF.StandardFont</class-id> <category>accessing</category><body package="PDF Fonts">standardWidths	^standardWidths ifNil: [standardWidths := (Graphics.Fonts.Font fontAt: self BaseFont content) metrics widths256				asPDF]</body></methods><methods><class-id>Graphics.PDF.StandardFont class</class-id> <category>accessing</category><body package="PDF Fonts">fontNames	^#(#'Times-Roman' #Helvetica #Courier #Symbol #'Times-Bold' #'Helvetica-Bold' #'Courier-Bold' #ZapfDingbats #'Times-Italic' #'Helvetica-Oblique' #'Courier-Oblique' #'Times-BoldItalic' #'Helvetica-BoldOblique' #'Courier-BoldOblique')</body><body package="PDF Fonts">subtype	^#Type1</body></methods><methods><class-id>Graphics.PDF.StandardFont class</class-id> <category>instance creation</category><body package="PDF Fonts">isTypeFor: anOrderedDictionary	^(super isTypeFor: anOrderedDictionary) and: [	(anOrderedDictionary includesKey: #BaseFont) and: [	self fontNames includes: (anOrderedDictionary at: #BaseFont) asSmalltalkValue]]</body></methods><methods><class-id>Graphics.PDF.FillOld class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Equivalent to f; included only for compatibility. Although PDF reader applications shall be able to accept this operator, PDF writer applications should use f instead'</body><body package="PDF Graphics Operations">operatorName	^#F</body></methods><methods><class-id>Graphics.PDF.CalGray</class-id> <category>accessing</category><body package="PDF Colour">defaultDecodeArray	^#(0.0 1.0) asPDF</body><body package="PDF Colour">initialColourValues	^#(0.0)</body><body package="PDF Colour">numberOfComponents	^1</body><body package="PDF Colour">procSet	^#ImageB</body></methods><methods><class-id>Graphics.PDF.Appearance class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 5)</body><body package="PDF Interactive Features">version	^2</body></methods><methods><class-id>Graphics.PDF.Function class</class-id> <category>accessing</category><body package="PDF Data Structures">topClasses	^Array		with: FunctionDictionary		with: FunctionStream		with: Identity</body></methods><methods><class-id>Graphics.PDF.PostScriptXObject class</class-id> <category>accessing</category><body package="PDF XObjects">resourcePrefix	^'Po'</body><body package="PDF XObjects">subtype	^#PS</body><body package="PDF XObjects">version	^1</body></methods><methods><class-id>Graphics.PDF.UncolouredPattern</class-id> <category>accessing</category><body package="PDF Colour">decodeArrayMax: aNumber	TypeError raiseSignal: 'Not permitted with images'.	^nil</body><body package="PDF Colour">defaultDecodeArray	TypeError raiseSignal: 'Not permitted with images'.	^#() asPDF</body><body package="PDF Colour">numberOfComponents	^0</body></methods><methods><class-id>Graphics.PDF.UncolouredPattern class</class-id> <category>accessing</category><body package="PDF Colour">numberOfAttributes	^2</body><body package="PDF Colour">type	^#Pattern</body><body package="PDF Colour">version	^2</body></methods><methods><class-id>Graphics.PDF.ContentString class</class-id> <category>implementation limits</category><body package="PDF Complex Objects">maxSize	"Maximum length of a string, in bytes.This restriction applies only to strings in content streams.There is no effective restriction on other strings in PDF files."	^32767</body></methods><methods><class-id>Graphics.PDF.ContentString class</class-id> <category>instance creation</category><body package="PDF Complex Objects">content: aByteArray encrypted: encryptedBoolean	aByteArray size &lt;= self maxSize ifTrue: [		^super content: aByteArray encrypted: encryptedBoolean].	^Error raiseSignal: 'the string is too big for PDF strings in content streams'</body></methods><methods><class-id>Graphics.PDF.TextAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 4)</body><body package="PDF Interactive Features">subtype	^#Text</body></methods><methods><class-id>Graphics.PDF.FillAndStroke class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Fill and then stroke the path, using the nonzero winding number rule to determine the region to fill. This operator shall produce the same result as constructing two identical path objects, painting the first with f and the second with S.NOTEThe filling and stroking portions of the operation consult different values of several graphics state parameters, such as the current colour'</body><body package="PDF Graphics Operations">operatorName	^#B</body></methods><methods><class-id>Graphics.PDF.OutlineItem class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 3 3)</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingRGB</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #colorSpaceNonstroking put: DeviceRGB new.	aPageGraphics graphicsState at: #colorNonstroking put: self operands</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingRGB class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Same as RG but used for nonstroking operations'</body><body package="PDF Graphics Operations">operandTypes	^#(#('r' Number) #('g' Number) #('b' Number))</body><body package="PDF Graphics Operations">operatorName	^#rg</body></methods><methods><class-id>Graphics.PDF.MarkedContentPointWithProperties class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Designate a marked-content point with an associated property list. tag shall be a name object indicating the role or significance of the point. properties shall be either an inline dictionary containing the property list or a name object associated with it in the Properties subdictionary of the current resource dictionary'</body><body package="PDF Graphics Operations">operandTypes	^#(#('tag' Name) #('properties' Dictionary))</body><body package="PDF Graphics Operations">operatorName	^#DP</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_2</body></methods><methods><class-id>Graphics.PDF.NameEncoder</class-id> <category>writing</category><body package="PDF basics">nextPut: aCharacter on: aStream	"put the character equivalent to the PDF aCharacter onto aStream"	| i |	i := aCharacter asInteger.	(aCharacter isPdfRegular and: [	(i between: 16r21 and: 16r7E) and: [	(aCharacter == $#) not]]) ifTrue: [			^aStream nextPut: i].	aStream nextPut: $# asInteger.	aStream nextPutAll: (aCharacter asInteger printStringRadix: 16) asByteArray</body></methods><methods><class-id>Graphics.PDF.NameEncoder</class-id> <category>querying</category><body package="PDF basics">characterSize: aCharacter	"&lt;Integer&gt;	the number of bytes in the encoded output"	| i |	i := aCharacter asInteger.	(i between: 16r21 and: 16r7E) ifTrue: [		aCharacter == $# ifTrue: [			^3].		^1].	^3</body></methods><methods><class-id>Graphics.PDF.NameEncoder</class-id> <category>reading</category><body package="PDF basics">nextFrom: aStream	"&lt;Character&gt;	read a string character from aStream.	Answer the equivalent PDF character"	| char |	char := aStream next.	char == $# ifFalse: [		^char].	^(Core.Number		readIntegerFrom: (ByteString			with: aStream next			with: aStream next) readStream		radix: 16) asCharacter</body></methods><methods><class-id>Graphics.PDF.NameEncoder class</class-id> <category>accessing</category><body package="PDF basics">readStreamOn: aReadStream	"&lt;EncodedStream&gt;"	^EncodedStream on: aReadStream encodedBy: self asEncoder</body><body package="PDF basics">streamEncodingType	"Don't register this encoder"	^nil</body><body package="PDF basics">writeStream	"&lt;EncodedStream&gt;"	^EncodedStream on: ByteArray new writeStream encodedBy: self asEncoder</body></methods><methods><class-id>Graphics.PDF.Lab</class-id> <category>accessing</category><body package="PDF Colour">defaultDecodeArray	^#(0 100) asPDF , self dictionary Range</body><body package="PDF Colour">initialColourValues	"the initial colour shall have all components equal to 0.0 unless that falls outside the intervals specified by the space’s Range entry, in which case the nearest valid value shall be substituted."	^#(0.0 0.0 0.0)</body><body package="PDF Colour">numberOfComponents	^3</body></methods><methods><class-id>Graphics.PDF.Integer class</class-id> <category>instance creation</category><body package="PDF Basic Objects">on: anInteger	(anInteger between: self minValue and: self maxValue) ifTrue: [		^super on: anInteger].	^Error raiseSignal: 'the number ' , anInteger printString , ' is too big for PDF integers'</body></methods><methods><class-id>Graphics.PDF.Integer class</class-id> <category>implementation limits</category><body package="PDF Basic Objects">maxValue	"Largest integer value; equal to 2^31 - 1."	^2 ** 31 - 1</body><body package="PDF Basic Objects">minValue	"Smallest integer value; equal to -2^31."	^-2 ** 31</body></methods><methods><class-id>Graphics.PDF.BeginMarkedContentWithProperties</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics at: indexInteger	aPageGraphics pushCollector: (MarkedObject tag: self operands first				properties: self operands last)</body></methods><methods><class-id>Graphics.PDF.BeginMarkedContentWithProperties class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Begin a marked-content sequence with an associated property list, terminated by a balancing EMC operator. tag shall be a name object indicating the role or significance of the sequence. properties shall be either an inline dictionary containing the property list or a name object associated with it in the Properties subdictionary of the current resource dictionary'</body><body package="PDF Graphics Operations">end	^EndMarkedContent</body><body package="PDF Graphics Operations">operandTypes	^#(#('tag' Name) #('properties' Dictionary))</body><body package="PDF Graphics Operations">operatorName	^#BDC</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_2</body></methods><methods><class-id>Graphics.PDF.NextLine</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState		nextLineBy: 0 @ aPageGraphics graphicsState leading content negated</body></methods><methods><class-id>Graphics.PDF.NextLine class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Move to the start of the next line. This operator has the same effect as the code	0 -Tl Tdwhere Tl denotes the current leading parameter in the text state. The negative of Tl is used here because Tl is the text leading expressed as a positive number. Going to the next line entails decreasing the y coordinate'</body><body package="PDF Graphics Operations">operatorName	^#'T*'</body></methods><methods><class-id>Graphics.PDF.Subpath</class-id> <category>initialize-release</category><body package="PDF Graphics">initializeSegments: segmentsArray	(segmentsArray notNil and: [	segmentsArray notEmpty]) ifTrue: [			segments := (Array withAll: segmentsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>Graphics.PDF.Subpath</class-id> <category>accessing</category><body package="PDF Graphics">segments	"&lt;Array&gt;"	^segments ifNil: [#()]</body></methods><methods><class-id>Graphics.PDF.Subpath</class-id> <category>printing</category><body package="PDF Graphics">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'segments' value: self segments).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.PDF.Subpath class</class-id> <category>instance creation</category><body package="PDF Graphics">segments: segmentsArray	| inst |	inst := self new.	inst initializeSegments: segmentsArray.	^inst</body></methods><methods><class-id>Graphics.PDF.Crypt</class-id> <category>accessing</category><body package="PDF Filter">pdfVersion	^Version pdf1_5</body></methods><methods><class-id>Graphics.PDF.PaethPredictor</class-id> <category>filtering</category><body package="PDF Filter">a: a b: b c: c	| p pa pb pc |	p := a + b - c.	pa := (p - a) abs.	pb := (p - b) abs.	pc := (p - c) abs.	(pa &lt;= pb and: [	pa &lt;= pc]) ifTrue: [			^a].	pb &lt;= pc ifTrue: [		^b].	^c</body><body package="PDF Filter">predict: aByteArray withUpperRow: upperByteArray	"&lt;ByteArray&gt;"	| filtered |	filtered := ByteArray new: aByteArray size.	1 to: aByteArray size do: [:index |		| indexLeft a b c output |		b := upperByteArray at: index.		indexLeft := index - self offsetLeft.		indexLeft strictlyPositive			ifTrue: [			a := aByteArray at: indexLeft.			c := upperByteArray at: indexLeft]			ifFalse: [			a := c := 0].		output := (aByteArray at: index) - (self a: a b: b c: c).		filtered at: index put: output \\ 256].	^filtered</body><body package="PDF Filter">unpredict: filteredByteArray withUpperRow: upperReconstructedByteArray	"&lt;ByteArray&gt;"	| reconstructed |	reconstructed := ByteArray new: filteredByteArray size.	1 to: filteredByteArray size do: [:index |		| indexLeft a b c output |		b := upperReconstructedByteArray at: index.		indexLeft := index - self offsetLeft.		indexLeft strictlyPositive			ifTrue: [			a := reconstructed at: indexLeft.			c := upperReconstructedByteArray at: indexLeft]			ifFalse: [			a := c := 0].		output := (filteredByteArray at: index) + (self a: a b: b c: c).		reconstructed at: index put: output \\ 256].	^reconstructed</body></methods><methods><class-id>Graphics.PDF.PaethPredictor class</class-id> <category>accessing</category><body package="PDF Filter">type	^4</body></methods><methods><class-id>Graphics.PDF.ArrayType</class-id> <category>testing</category><body package="PDF Complex Objects">isForArray	^true</body><body package="PDF Complex Objects">subsumesArray: aPDFArray	"elements can be direct or indirect"	| elementType |	elementType := self asClassType.	^aPDFArray content allSatisfy: [:element | element isType: elementType]</body><body package="PDF Complex Objects">subsumesReference: aPDFReference	^aPDFReference referent isType: self</body></methods><methods><class-id>Graphics.PDF.ArrayType</class-id> <category>accessing</category><body package="PDF Complex Objects">name	^'[' , self pdfType name asString , ']'</body><body package="PDF Complex Objects">specializedArray: aPDFArray	| elementType |	elementType := self asClassType.	^(aPDFArray content collect: [:element |		(element asType: elementType) ifNil: [			^nil]]) asPDF</body></methods><methods><class-id>Graphics.PDF.StichingFunction class</class-id> <category>accessing</category><body package="PDF Data Structures">functionType	^3</body></methods><methods><class-id>Graphics.PDF.ThreeDAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(13 6 2)</body><body package="PDF Interactive Features">subtype	^#'3D'</body><body package="PDF Interactive Features">version	^6</body></methods><methods><class-id>Graphics.PDF.Metadata class</class-id> <category>accessing</category><body package="PDF Document">version	^4</body></methods><methods><class-id>Graphics.PDF.Unsupported</class-id> <category>printing</category><body package="PDF basics">printOn: stream	stream nextPutAll: self description</body></methods><methods><class-id>Graphics.PDF.SetType3GlyphWidth class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set width information for the glyph and declare that the glyph description specifies both its shape and its colour.NOTE	This operator name ends in the digit 0.wx denotes the horizontal displacement in the glyph coordinate system; it shall be consistent with the corresponding width in the font’s Widths array. wy shall be 0.This operator shall only be permitted in a content stream appearing in a Type 3 font’s CharProcs dictionary. It is typically used only if the glyph description executes operators to set the colour explicitly.'</body><body package="PDF Graphics Operations">operandTypes	^#(#('wx' Number) #('wy' Number))</body><body package="PDF Graphics Operations">operatorName	^#d0</body></methods><methods><class-id>Graphics.PDF.HighlightAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">subtype	^#Highlight</body></methods><methods><class-id>Graphics.PDF.ObjectStream</class-id> <category>reading</category><body package="PDF Files">readAt: zeroBasedIndex with: aFile	"&lt;PDFObject&gt;"	self encrypted ifTrue: [		^nil asPDF].	^self parser pickObjectAt: (self offsetAt: zeroBasedIndex) with: aFile</body><body package="PDF Files">readOffsets	| dict first |	dict := OrderedDictionary new.	first := self First asSmalltalkValue.	self N asSmalltalkValue timesRepeat: [		| objectNumber offset |		objectNumber := self parser nextInteger.		offset := self parser nextInteger.		dict at: objectNumber put: first + offset].	^dict</body></methods><methods><class-id>Graphics.PDF.ObjectStream</class-id> <category>accessing</category><body package="PDF Files">offsetAt: zeroBasedIndex	"&lt;Integer&gt;"	^(self offsets atIndex: zeroBasedIndex + 1) value</body><body package="PDF Files">offsets	"&lt;OrderedDictionary key: Integer value: Integer&gt;	The key is the object number n refered by 'n 0 R'	The value is the offset from the beginning of the internal stream"	^offsets ifNil: [		parser := nil.		offsets := self readOffsets]</body><body package="PDF Files">parser	^parser ifNil: [parser := ObjectStreamParser onString: self internal]</body></methods><methods><class-id>Graphics.PDF.ObjectStream class</class-id> <category>accessing</category><body package="PDF Files">type	^#ObjStm</body><body package="PDF Files">version	^5</body></methods><methods><class-id>Graphics.PDF.SetCap</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #lineCap put: self operands first</body></methods><methods><class-id>Graphics.PDF.SetCap class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the line cap style in the graphics state'</body><body package="PDF Graphics Operations">operandTypes	^#(#('lineCap' Number))</body><body package="PDF Graphics Operations">operatorName	^#J</body></methods><methods><class-id>Graphics.PDF.CalRGB</class-id> <category>accessing</category><body package="PDF Colour">defaultDecodeArray	^#(0.0 1.0 0.0 1.0 0.0 1.0) asPDF</body><body package="PDF Colour">initialColourValues	^#(0.0 0.0 0.0)</body><body package="PDF Colour">numberOfComponents	^3</body></methods><methods><class-id>Graphics.PDF.EndInlineImage class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'End an inline image object'</body><body package="PDF Graphics Operations">operatorName	^#EI</body></methods><methods><class-id>Graphics.PDF.SetStrokingColorSpecial</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	(aPageGraphics graphicsState colorSpaceStroking isKindOf: Pattern)		ifTrue: 			[^aPageGraphics graphicsState at: #colorStroking				put: (self operands content allButLast: 1)].	aPageGraphics graphicsState at: #colorStroking put: self operands</body></methods><methods><class-id>Graphics.PDF.SetStrokingColorSpecial</class-id> <category>accessing</category><body package="PDF Graphics Operations">resourceIn: aPageGraphics	(aPageGraphics graphicsState colorSpaceStroking isKindOf: Pattern)		ifTrue: 			[^aPageGraphics resources Pattern objectAt: self operands last content].	^nil</body></methods><methods><class-id>Graphics.PDF.SetStrokingColorSpecial class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Same as SC but also supports Pattern, Separation, DeviceN and ICCBased colour spaces.If the current stroking colour space is a Separation, DeviceN, or ICCBased colour space, the operands c1…cn shall be numbers. The number of operands and their interpretation depends on the colour space.If the current stroking colour space is a Pattern colour space, name shall be the name of an entry in the Pattern subdictionary of the current resource dictionary. For an uncoloured tiling pattern (PatternType = 1 and PaintType = 2), c1…cn shall be component values specifying a colour in the pattern’s underlying colour space. For other types of patterns, these operands shall not be specified.'</body><body package="PDF Graphics Operations">operandTypes	^#(#('cn' Number) #('name' Number))</body><body package="PDF Graphics Operations">operatorName	^#SCN</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_2</body></methods><methods><class-id>Graphics.PDF.PopupAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 14)</body><body package="PDF Interactive Features">subtype	^#Popup</body><body package="PDF Interactive Features">version	^3</body></methods><methods><class-id>Graphics.PDF.UTF16Textstring</class-id> <category>writing</category><body package="PDF Basic Objects">writeOn: aStream indent: integer	aStream		nextPut: $(;		nextPutAll: self class utf16Header;		nextPutAll: self content asByteString;		nextPut: $)</body></methods><methods><class-id>Graphics.PDF.UTF16Textstring</class-id> <category>converting</category><body package="PDF Basic Objects">asString	| encoder |	encoder := UTF16StreamEncoder new.	encoder bigEndian: true.	^(EncodedStream on: self content readStream encodedBy: encoder) contents asByteString</body></methods><methods><class-id>Graphics.PDF.UTF16Textstring class</class-id> <category>instance creation</category><body package="PDF Basic Objects">fromPdf: aByteString	"aByteString has the 2 UTF16 header bytes - strip them"	^self content: (aByteString allButFirst: 2) asByteArray</body></methods><methods><class-id>Graphics.PDF.IndirectType</class-id> <category>testing</category><body package="PDF Complex Objects">isIndirect	^true</body><body package="PDF Complex Objects">subsumesReference: aPDFReference	^aPDFReference referent isType: self asDirectType</body></methods><methods><class-id>Graphics.PDF.IndirectType</class-id> <category>accessing</category><body package="PDF Complex Objects">name	^'»', self pdfType name asString</body><body package="PDF Complex Objects">specializedReference: aReference	^(aReference referent asType: self asDirectType) ifNotNil: [:specialized |		aReference copyWithReferent: specialized]</body></methods><methods><class-id>Graphics.PDF.IndirectType</class-id> <category>converting</category><body package="PDF Complex Objects">asDirectType	^DirectType on: self pdfType</body><body package="PDF Complex Objects">asIndirectType	^self</body></methods><methods><class-id>Graphics.PDF.BorderEffect class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 4)</body><body package="PDF Interactive Features">version	^5</body></methods><methods><class-id>Graphics.PDF.Shading class</class-id> <category>accessing</category><body package="PDF Shading">topClasses	^Array		with: ShadingDictionary		with: ShadingStream</body></methods><methods><class-id>Graphics.PDF.CoonsPatchMesh class</class-id> <category>accessing</category><body package="PDF Shading">shadingType	^6</body></methods><methods><class-id>Graphics.PDF.AppendLine class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Append a straight line segment from the current point to the point (x, y). The new current point shall be (x, y)'</body><body package="PDF Graphics Operations">operandTypes	^#(#('x' Number) #('y' Number))</body><body package="PDF Graphics Operations">operatorName	^#l</body></methods><methods><class-id>Graphics.PDF.Names class</class-id> <category>accessing</category><body package="PDF Document">version	^2</body></methods><methods><class-id>Graphics.PDF.FlateDecodeStream</class-id> <category>private</category><body package="PDF Filter">checkHeader	"do nothing - the library does it all for us"</body><body package="PDF Filter">setupBufferAndLimits	"copied down to set #windowBits to a non-negative value to let the library check the zlib header and checksum.	The original implementation uses an undocumented feature of zlib to suppress the header and checksum generation"	interface := ZLibInterface newUsingEngineAllocator.	inputBuffer := ByteArray newInFixedSpace: BufferSize.	collection := ByteArray newInFixedSpace: BufferSize.	(interface		cInflateInit2: interface zstream		windowBits: interface MAX_WBITS		version: interface version		streamSize: interface z_stream dataSize) ~= interface Z_OK ifTrue: [			self error: #ZlibInflateInit2Failed &lt;&lt; #dialogs &gt;&gt; 'zlib inflateInit2 initialization failed'].	position := superPosition := 0.	readLimit := 0.	writeLimit := -1.	eof := false</body></methods><methods><class-id>Graphics.PDF.FunctionBasedShading class</class-id> <category>accessing</category><body package="PDF Shading">shadingType	^1</body></methods><methods><class-id>Graphics.PDF.PolygonAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">subtype	^#Polygon</body></methods><methods><class-id>Graphics.PDF.ViewerPreferences class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 2)</body><body package="PDF Interactive Features">version	^2</body></methods><methods><class-id>Graphics.PDF.WordSpacing</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #wordSpacing put: self operands first</body></methods><methods><class-id>Graphics.PDF.WordSpacing class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the word spacing, Tw, to wordSpace, which shall be a number expressed in unscaled text space units. Word spacing shall be used by the Tj, TJ, and '' operators. Initial value: 0'</body><body package="PDF Graphics Operations">operandTypes	^#(#('wordSpace' Number))</body><body package="PDF Graphics Operations">operatorName	^#Tw</body></methods><methods><class-id>Graphics.PDF.Type0</class-id> <category>accessing</category><body package="PDF Fonts">numberOfCharacters: aContentString	"&lt;Integer&gt;	aContentString can be a multibyte string"	^aContentString size</body><body package="PDF Fonts">stringWidth: aContentString	"&lt;Integer&gt; in glyph space	aContentString can be a multibyte string"	self Encoding asSmalltalkValue = #'Identity-H'		ifFalse: [^self error: 'not implemented yet'].	^self DescendantFonts first stringWidth: aContentString</body><body package="PDF Fonts">widthAt: aCharacterCode	^self notYetImplemented</body></methods><methods><class-id>Graphics.PDF.ClipEvenOdd class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Modify the current clipping path by intersecting it with the current path, using the even-odd rule to determine which regions lie inside the clipping path'</body><body package="PDF Graphics Operations">operatorName	^#'W*'</body></methods><methods><class-id>Graphics.PDF.Date</class-id> <category>writing</category><body package="PDF Basic Objects">asUTC	"&lt;String&gt;	in the form 20080701000000+02"	| timestamp wst secondsDiference diffTime |	timestamp := self asSmalltalkValue.	wst := ByteString new writeStream.	timestamp year printOn: wst paddedWith: $0 to: 4 base: 10.	timestamp month printOn: wst paddedWith: $0 to: 2 base: 10.	timestamp day printOn: wst paddedWith: $0 to: 2 base: 10.	timestamp hour printOn: wst paddedWith: $0 to: 2 base: 10.	timestamp minute printOn: wst paddedWith: $0 to: 2 base: 10.	timestamp second printOn: wst paddedWith: $0 to: 2 base: 10.	secondsDiference := TimeZone default secondsFromUniversalAtLocal: timestamp.	wst nextPut: (secondsDiference negative		ifTrue: [$-]		ifFalse: [$+]).	diffTime := Time fromSeconds: secondsDiference.	diffTime hours printOn: wst paddedWith: $0 to: 2 base: 10.	wst nextPut: $'.	diffTime minutes isZero ifFalse: [		diffTime minutes printOn: wst paddedWith: $0 to: 2 base: 10].	^wst contents</body><body package="PDF Basic Objects">writeOn: aStream indent: integer	self encrypted ifTrue: [		^aStream nextPutString: self].	aStream		nextPutAll: '(D:';		nextPutAll: self asUTC;		nextPut: $)</body></methods><methods><class-id>Graphics.PDF.Date</class-id> <category>converting</category><body package="PDF Basic Objects">asSmalltalkValue	^self content</body><body package="PDF Basic Objects">asString	^self pdfSource</body></methods><methods><class-id>Graphics.PDF.Date</class-id> <category>testing</category><body package="PDF Basic Objects">isEmpty	^self = self class new</body></methods><methods><class-id>Graphics.PDF.Date class</class-id> <category>instance creation</category><body package="PDF Basic Objects">dateFrom: rst	"&lt;Date&gt;"	| month day year |	year := (rst next: 4) asNumber.	month := (rst next: 2) asNumber.	day := (rst next: 2) asNumber.	^Core.Date newDay: day monthNumber: month year: year</body><body package="PDF Basic Objects">fromPdf: aByteString	| timestamp rst date time |	rst := (aByteString allButFirst: 2) readStream.	date := self dateFrom: rst.	time := self timeFrom: rst.	timestamp := (rst atEnd or: [	('Z+-' includes: rst peek) not])			ifTrue: [			Timestamp fromDate: date andTime: time]			ifFalse: [			| timezoneMinutesOffset seconds |			timezoneMinutesOffset := self timezoneOffsetMinutesFor: rst next from: rst.			seconds := date asSeconds + time asSeconds - (timezoneMinutesOffset * 60).			TimeZone default universalToLocal: (Timestamp fromSeconds: seconds)].	^self content: timestamp</body><body package="PDF Basic Objects">timeFrom: rst	"&lt;Time&gt;"	| hours minutes seconds |	hours := (rst atEnd not and: [	rst peek isDigit])			ifTrue: [(rst next: 2) asNumber]			ifFalse: [			0].	minutes := (rst atEnd not and: [	rst peek isDigit])			ifTrue: [(rst next: 2) asNumber]			ifFalse: [			0].	seconds := (rst atEnd not and: [	rst peek isDigit])			ifTrue: [(rst next: 2) asNumber]			ifFalse: [			0].	^Time new hours: hours minutes: minutes seconds: seconds</body><body package="PDF Basic Objects">timezoneOffsetMinutesFor: char from: rst	| offset |	char = $Z ifTrue: [		^0].	offset := (rst next: 2) asNumber * 60.	(rst atEnd not and: [	rst peek isDigit]) ifTrue: [			offset := offset + (rst next: 2) asNumber].	^char = $-		ifTrue: [offset negated]		ifFalse: [offset]</body></methods><methods><class-id>Graphics.PDF.CalGrayColourSpaceDictionary class</class-id> <category>accessing</category><body package="PDF Colour">version	^1</body></methods><methods><class-id>Graphics.PDF.EncryptedFileParser</class-id> <category>testing</category><body package="PDF Parsing">isForEncrypted	^true</body></methods><methods><class-id>Graphics.PDF.EncryptedFileParser</class-id> <category>reading objects</category><body package="PDF Parsing">readStreamWith: anOrderedDictionary	| length |	length := anOrderedDictionary at: #Length ifAbsent: [		^ReadError raiseSignal: 'The stream dictonary has no Length entry'].	^Stream		on: anOrderedDictionary		external: (self readStreamContents: length object asSmalltalkValue)		encrypted: true</body><body package="PDF Parsing">readString	^PDF.String fromEncryptedPdf: self readStringCharacters</body></methods><methods><class-id>Graphics.PDF.EncryptedFileParser</class-id> <category>accessing</category><body package="PDF Parsing">initialTokenActions	"no HexStrings"	| dict |	dict := super initialTokenActions.	dict removeKey: '&lt;'.	^dict</body></methods><methods><class-id>Graphics.PDF.TensorProductPatchMesh class</class-id> <category>accessing</category><body package="PDF Shading">shadingType	^7</body></methods><methods><class-id>Graphics.PDF.AveragePredictor</class-id> <category>filtering</category><body package="PDF Filter">predict: aByteArray withUpperRow: upperByteArray	"&lt;ByteArray&gt;"	| filtered |	filtered := ByteArray new: aByteArray size.	1 to: aByteArray size do: [:index |		| indexLeft a b output |		indexLeft := index - self offsetLeft.		a := indexLeft strictlyPositive			ifTrue: [aByteArray at: indexLeft]			ifFalse: [0].		b := upperByteArray at: index.		output := (aByteArray at: index) - ((a + b) // 2).		filtered at: index put: output \\ 256].	^filtered</body><body package="PDF Filter">unpredict: filteredByteArray withUpperRow: upperReconstructedByteArray	"&lt;ByteArray&gt;"	| reconstructed |	reconstructed := ByteArray new: filteredByteArray size.	1 to: filteredByteArray size do: [:index |		| indexLeft a b output |		indexLeft := index - self offsetLeft.		a := indexLeft strictlyPositive			ifTrue: [reconstructed at: indexLeft]			ifFalse: [0].		b := upperReconstructedByteArray at: index.		output := (filteredByteArray at: index) + ((a + b) // 2).		reconstructed at: index put: output \\ 256].	^reconstructed</body></methods><methods><class-id>Graphics.PDF.AveragePredictor class</class-id> <category>accessing</category><body package="PDF Filter">type	^3</body></methods><methods><class-id>Graphics.PDF.FreeTextAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 6)</body><body package="PDF Interactive Features">subtype	^#FreeText</body><body package="PDF Interactive Features">version	^3</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingCMYK</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #colorSpaceNonstroking put: DeviceCMYK new.	aPageGraphics graphicsState at: #colorNonstroking put: self operands</body></methods><methods><class-id>Graphics.PDF.SetNonStrokingCMYK class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Same as K but used for nonstroking operations'</body><body package="PDF Graphics Operations">operandTypes	^#(#('c' #Number) #('m' #Number) #('y' #Number) #('k' #Number))</body><body package="PDF Graphics Operations">operatorName	^#k</body></methods><methods><class-id>Graphics.PDF.File</class-id> <category>accessing</category><body package="PDF Files">crossReferences	"&lt;CrossReferences | CrossReferenceStream&gt;"	^crossReferences</body><body package="PDF Files">firstPage	"&lt;Page&gt;"	^self trailer firstPage</body><body package="PDF Files">header	"&lt;PDFHeader&gt;"	^header</body><body package="PDF Files">objects	"&lt;Dictionary key: Point value: Reference&gt;"	^objects ifNil: [objects := Core.Dictionary new]</body><body package="PDF Files">parser	"&lt;Parser&gt;"	^parser</body><body package="PDF Document">pdfVersion	"&lt;PDFVersion&gt;	the declared version of the file"	| versionName numbers |	versionName := self root Version content ifNil: [		^self header pdfVersion].	numbers := (versionName content tokensBasedOn: $.) collect: [:string | string asNumber].	^self header pdfVersion max: (Version major: numbers first minor: numbers last)</body><body package="PDF Files">referenceAt: number	"&lt;Reference&gt;"	^self referenceAt: number generation: 0</body><body package="PDF Files">referenceAt: number generation: generation	"&lt;Reference&gt;	used when reading"	^self objects at: number @ generation ifAbsentPut: [		| reference |		reference := Reference number: number generation: generation.		reference referent: [self readObjectFor: reference]]</body><body package="PDF Files">root	"&lt;Catalog&gt;"	^self trailer Root</body><body package="PDF Files">theFalse	"&lt;PDF.Boolean&gt;	unique instance per file"	^theFalse ifNil: [theFalse := false asPDF]</body><body package="PDF Files">theNull	"&lt;Null&gt;	unique instance per file.	Need to test explicitly on nil, since null implements #ifNil:"	theNull = nil ifTrue: [		^theNull := nil asPDF].	^theNull</body><body package="PDF Files">theTrue	"&lt;PDF.Boolean&gt;	unique instance per file"	^theTrue ifNil: [theTrue := true asPDF]</body><body package="PDF Files">trailer	"&lt;Trailer&gt;"	^trailer</body><body package="PDF Files">usedReferences	"&lt;SequenceableCollection of: UsedReference&gt;"	^self crossReferences usedReferences</body><body package="PDF Files">version	"&lt;PDFVersion&gt;"	^self header value</body></methods><methods><class-id>Graphics.PDF.File</class-id> <category>reading</category><body package="PDF Files">indirectObjectFrom: aParser	"&lt;PDFObject | nil&gt;	read a PDF object off the aStream.	Answer the PDF object.	The top level call to read an indirect object.	A Reference only is not allowed"	| object |	object := aParser readObjectWith: self.	object isDirect ifFalse: [		TypeError raiseSignal: 'References to References are not permitted.'].	^object</body><body package="PDF Files">readCrossReferences	self parser setPositionToXRef.	self parser peek isDigit ifTrue: [		^XRefStream readWith: self].	^CrossReferences readWith: self</body><body package="PDF Files">readObject	"&lt;PDFObject | nil&gt;	read a PDF object off the aStream.	Answer the PDF object"	^self parser readObjectWith: self</body><body package="PDF Files">readObjectFor: aReference	"&lt;PDF.Object&gt;"	| object |	object := (self crossReferences crossReferenceAt: aReference) readObjectWith: self.	self announce: (ObjectRead reference: aReference object: object).	^object</body></methods><methods><class-id>Graphics.PDF.File</class-id> <category>initialize-release</category><body package="PDF Files">initializeFrom: aBinaryReadStream	parser := FileParser onStream: aBinaryReadStream.	header := Header version: self parser readHeaderVersion.	crossReferences := self readCrossReferences.	trailer := self crossReferences trailer.	self trailer Encrypt notEmpty ifTrue: [		parser := self parser forEncryption]</body><body package="PDF Files">release	subscriptionRegistry release.	subscriptionRegistry := nil.	self parser ifNotNil: [:aParser |		aParser release.		parser := nil].	super release</body></methods><methods><class-id>Graphics.PDF.File</class-id> <category>private</category><body package="PDF Files">postCopy	super postCopy.	subscriptionRegistry := nil</body><body package="PDF Files">subscriptionRegistry: aSubscriptionRegistry	subscriptionRegistry := aSubscriptionRegistry</body></methods><methods><class-id>Graphics.PDF.File</class-id> <category>writing</category><body package="PDF Files">writeOn: aPDFWritestream indent: integer</body></methods><methods><class-id>Graphics.PDF.File</class-id> <category>printing</category><body package="PDF Files">printOn: aStream	aStream		nextPutAll: self header printString;		nextPut: $[;		nextPutAll: self trailer Size printString;		nextPut: $]</body></methods><methods><class-id>Graphics.PDF.File</class-id> <category>announcements</category><body package="PDF Files">subscriptionRegistryOrNil	^subscriptionRegistry</body></methods><methods><class-id>Graphics.PDF.File</class-id> <category>testing</category><body package="PDF Files">isEncrypted	^self parser isForEncrypted</body></methods><methods><class-id>Graphics.PDF.File</class-id> <category>converting</category><body package="PDF Files">asDocument	"&lt;Document&gt;	a new document with the same contents as the receiver for writing out the PDF later"	| newDocument info |	newDocument := Document new.	newDocument root: self root.	info := self trailer Info.	info at: #ModDate put: Timestamp now.	info at: #Producer put: PDF producerText.	newDocument info: info.	newDocument previousId: self trailer ID.	^newDocument</body></methods><methods><class-id>Graphics.PDF.File class</class-id> <category>implementation limits</category><body package="PDF Files">defaultMillimetersForUserSpaceUnit	"The minimum page size should be 3 by 3 units in default user space; the maximum should be 14,400 by 14,400 units. In versions of PDF earlier than 1.6, the size of the default user space unit was fixed at 1.72 inch, yielding a minimum of approximately 0.04 by 0.04 inch and a maximum of 200 by 200 inches. Beginning with PDF 1.6, the size of the unit may be set on a page-by-page basis; the default remains at 1/72 inch."	^25.4 / 72</body><body package="PDF Files">defaultThumbnailScale	"Thumbnail images should be no larger than 106 by 106 samples, and should be created at one-eighth scale for 8.5-by-11-inch and A4-size pages."	^1 / 8</body><body package="PDF Files">maxCID	"Maximum value of a CID (character identifier)."	^65535</body><body package="PDF Files">maxDeviceNComponents	"Maximum number of colorants or tint components in a DeviceNcolour space."	^32</body><body package="PDF Files">maxMagnificationPercent	"The magnification factor of a view should be constrained to be between approximately 8 percent and 6400 percent."	^6400</body><body package="PDF Files">maxObjects	"Maximum number of indirect objects in a PDF file."	^8388607</body><body package="PDF Files">maxPageExtent	"The minimum page size should be 3 by 3 units in default user space; the maximum should be 14,400 by 14,400 units. In versions of PDF earlier than 1.6, the size of the default user space unit was fixed at 1.72 inch, yielding a minimum of approximately 0.04 by 0.04 inch and a maximum of 200 by 200 inches. Beginning with PDF 1.6, the size of the unit may be set on a page-by-page basis; the default remains at 1/72 inch."	^14400 @ 14400</body><body package="PDF Files">maxThumbnailExtent	"Thumbnail images should be no larger than 106 by 106 samples, and should be created at one-eighth scale for 8.5-by-11-inch and A4-size pages."	^106 @ 106</body><body package="PDF Files">minMagnificationPercent	"The magnification factor of a view should be constrained to be between approximately 8 percent and 6400 percent."	^8</body><body package="PDF Files">minPageExtent	"The minimum page size should be 3 by 3 units in default user space; the maximum should be 14,400 by 14,400 units. In versions of PDF earlier than 1.6, the size of the default user space unit was fixed at 1.72 inch, yielding a minimum of approximately 0.04 by 0.04 inch and a maximum of 200 by 200 inches. Beginning with PDF 1.6, the size of the unit may be set on a page-by-page basis; the default remains at 1/72 inch."	^3 @ 3</body><body package="PDF Files">qNestingLimit	"NOTEMaximum depth of graphics state nesting by q and Q operators.This is not a limit as such, but arises from the fact that q and Q are implemented by the PostScript gsave and grestore operators when generating PostScript output."	^28</body></methods><methods><class-id>Graphics.PDF.File class</class-id> <category>reading</category><body package="PDF Files">read: aFilename	"&lt;File&gt;"	^self readFrom: (aFilename withEncoding: #binary) readStream</body><body package="PDF Files">readFrom: aBinaryReadStream	"&lt;File&gt;"	| inst |	inst := self new.	inst initializeFrom: aBinaryReadStream.	^inst</body></methods><methods><class-id>Graphics.PDF.BeginImageData class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Begin the image data for an inline image object'</body><body package="PDF Graphics Operations">operatorName	^#ID</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSection</class-id> <category>accessing</category><body package="PDF Files">atNumber: anInteger ifAbsent: zeroArgumentBlock	"&lt;CrossReference&gt;"	self subsections do: [:subsection |		(subsection atNumber: anInteger ifAbsent: [nil]) ifNotNil: [:ref |			^ref]].	^zeroArgumentBlock value</body><body package="PDF Files">crossReferenceAt: aPDFReference ifAbsent: zeroArgumentBlock	"&lt;CrossReference&gt;"	| uniqueObject |	uniqueObject := 'unique'.	self subsections do: [:subsection |		| cr |		cr := subsection crossReferenceAt: aPDFReference ifAbsent: [uniqueObject].		cr == uniqueObject ifFalse: [			^cr]].	^zeroArgumentBlock value</body><body package="PDF Files">subsections	"&lt;SequenceableCollection of: CrossReferenceSubsection&gt;"	^subsections ifNil: [subsections := OrderedCollection new]</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSection</class-id> <category>comparing</category><body package="PDF Files">= anObject	^self class == anObject class and: [	self subsections isSameSequenceAs: anObject subsections]</body><body package="PDF Files">hash	^self subsections inject: 0 into: [:hash :subsection | hash bitXor: subsection hash]</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSection</class-id> <category>writing</category><body package="PDF Files">writeOn: aPDFWritestream indent: integer	aPDFWritestream		nextPutAll: 'xref';		cr.	self subsections do: [:subsection | subsection writeOn: aPDFWritestream indent: integer]</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSection</class-id> <category>printing</category><body package="PDF Files">printOn: aStream	aStream		nextPutAll: self class name asString;		nextPut: $(;		nextPutAll: self subsections size printString;		nextPut: $)</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSection</class-id> <category>initialize-release</category><body package="PDF Files">initializeSubsections: subsectionsArray	subsections := subsectionsArray</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSection</class-id> <category>enumerating</category><body package="PDF Files">referencesDo: oneArgumentBlock	self subsections do: [:subsection | subsection referencesDo: oneArgumentBlock]</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSection class</class-id> <category>reading</category><body package="PDF Files">readFrom: aParser	"&lt;CrossReferenceSection&gt;"	| subsections |	subsections := OrderedCollection new.	aParser expectToken: #xref.	aParser skipWhitespace.	[	| char |	char := aParser peek.	char notNil and: [	char isDigit]] whileTrue: [			subsections add: (CrossReferenceSubsection readFrom: aParser)].	^self subsections: subsections asArray</body></methods><methods><class-id>Graphics.PDF.CrossReferenceSection class</class-id> <category>instance creation</category><body package="PDF Files">initialOn: someCrossReferences	"&lt;CrossReferenceSection&gt;	For a PDF that holds all references in only one CrossReferenceSection in only one CrossReferenceSubsection"	^self subsections: (Array with: (CrossReferenceSubsection initialOn: someCrossReferences))</body><body package="PDF Files">subsections: subsectionsArray	| inst |	inst := self new.	inst initializeSubsections: subsectionsArray.	^inst</body></methods><methods><class-id>Graphics.PDF.TransparencyGroupAttributes class</class-id> <category>instance creation</category><body package="PDF XObjects">empty	| inst |	inst := self new.	inst at: #S put: #Transparency.	^inst</body><body package="PDF XObjects">isTypeFor: anOrderedDictionary	^(anOrderedDictionary includesKey: #S) and: [	(anOrderedDictionary at: #S) asPDF = #Transparency asPDF]</body></methods><methods><class-id>Graphics.PDF.TypeMismatch</class-id> <category>accessing</category><body package="PDF Complex Objects">object	^self</body><body package="PDF Complex Objects">pdfVersion	^myObject pdfVersion</body><body package="PDF Complex Objects">types	^types</body></methods><methods><class-id>Graphics.PDF.TypeMismatch</class-id> <category>printing</category><body package="PDF Complex Objects">description	| wst |	wst := ByteString new writeStream.	wst		nextPutAll: 'The object ';		nextPutAll: myObject printString;		nextPutAll: ' (';		nextPutAll: myObject class name asString;		nextPutAll: ') is not compatible with '.	self types do: [:type | wst nextPutAll: type name] separatedBy: [		wst nextPutAll: ' or '].	^wst contents</body></methods><methods><class-id>Graphics.PDF.TypeMismatch</class-id> <category>error handling</category><body package="PDF Complex Objects">doesNotUnderstand: aMessage	(myObject respondsTo: aMessage selector) ifTrue: [		^myObject perform: aMessage selector withArguments: aMessage arguments].	^super doesNotUnderstand: aMessage</body></methods><methods><class-id>Graphics.PDF.TypeMismatch</class-id> <category>writing</category><body package="PDF Complex Objects">asPdfString	^myObject asPdfString</body><body package="PDF Complex Objects">writeOn: aGraphicsPDFWriter indent: aSmallInteger	myObject writeOn: aGraphicsPDFWriter indent: aSmallInteger</body></methods><methods><class-id>Graphics.PDF.TypeMismatch</class-id> <category>initialize-release</category><body package="PDF Complex Objects">initializeObject: aPDFObject types: someTypes	myObject := aPDFObject.	types := someTypes</body></methods><methods><class-id>Graphics.PDF.TypeMismatch</class-id> <category>testing</category><body package="PDF Complex Objects">isPDF	^myObject isPDF</body><body package="PDF Complex Objects">isTypeMismatch	^true</body></methods><methods><class-id>Graphics.PDF.TypeMismatch class</class-id> <category>instance creation</category><body package="PDF Complex Objects">for: aPDFObject expected: someTypes	| inst |	inst := self new.	inst initializeObject: aPDFObject types: someTypes.	^inst</body></methods><methods><class-id>Graphics.PDF.TransparencyGroup class</class-id> <category>instance creation</category><body package="PDF XObjects">isTypeFor: anOrderedDictionary	^(super isTypeFor: anOrderedDictionary) and: [	((anOrderedDictionary at: #Group) content at: #S) asPDF = #Transparency asPDF]</body><body package="PDF Rendering">newInBounds: aRectangle colorspace: aColourSpace in: aRenderer render: oneArgumentBlock	| renderer |	aRenderer addTransparencyPageAttributesWithColorspace: aColourSpace.	renderer := FormRenderer		newOn: self empty		bounds: aRectangle		colorspace: aColourSpace		in: aRenderer.	renderer product at: #Group put: TransparencyGroupAttributes empty.	renderer render: oneArgumentBlock.	^renderer product</body></methods><methods><class-id>Graphics.PDF.AppendCurveWithoutC1 class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Append a cubic Bézier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using the current point and (x2, y2) as the Bézier control points. The new current point shall be (x3, y3)'</body><body package="PDF Graphics Operations">operandTypes	^#(#('x2' Number) #('y2' Number) #('x3' Number) #('y3' Number))</body><body package="PDF Graphics Operations">operatorName	^#v</body></methods><methods><class-id>Graphics.PDF.SetStrokingColor</class-id> <category>actions</category><body package="PDF Graphics Operations">applyTo: aPageGraphics	aPageGraphics graphicsState at: #colorStroking put: self operands</body></methods><methods><class-id>Graphics.PDF.SetStrokingColor class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set the colour to use for stroking operations in a device, CIE-based (other than ICCBased), or Indexed colour space. The number of operands required and their interpretation depends on the current stroking colour space:For DeviceGray, CalGray, and Indexed colour spaces, one operand shall be required (n = 1).For DeviceRGB, CalRGB, and Lab colour spaces, three operands shall be required (n = 3).For DeviceCMYK, four operands shall be required (n = 4)'</body><body package="PDF Graphics Operations">operandTypes	^#(#('cn' Number))</body><body package="PDF Graphics Operations">operatorName	^#SC</body><body package="PDF Graphics Operations">pdfVersion	^Version pdf1_1</body></methods><methods><class-id>Graphics.PDF.AppendRectangle class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Append a rectangle to the current path as a complete subpath, with lower-left corner (x, y) and dimensions width and height in user space. The operation	x y width height reis equivalent to	x y m	(x + width) y l	(x + width) (y + height) l	x (y + height) l	h'</body><body package="PDF Graphics Operations">operandTypes	^#(#('x' Number) #('y' Number) #('width' Number) #('height' Number))</body><body package="PDF Graphics Operations">operatorName	^#re</body></methods><methods><class-id>Graphics.PDF.ColourSpace</class-id> <category>accessing</category><body package="PDF Colour">defaultDecodeArray	"&lt;PDFArray of: Number&gt;"	^self shouldNotImplement</body><body package="PDF Colour">initialColourValues	"&lt;Array of Number&gt;	the initial colour when the current colour space is set"	^#()</body><body package="PDF Colour">numberOfComponents	"&lt;Integer&gt;"	^self shouldNotImplement</body></methods><methods><class-id>Graphics.PDF.ColourSpace class</class-id> <category>accessing</category><body package="PDF Colour">topClasses	^Array		with: DeviceColourSpace		with: CIEColourSpace		with: SpecialColourSpace		with: Pattern</body><body package="PDF Colour">version	^1</body></methods><methods><class-id>Graphics.PDF.MovieAnnotation class</class-id> <category>accessing</category><body package="PDF Interactive Features">documentationPlace	^#(12 5 6 17)</body><body package="PDF Interactive Features">subtype	^#Movie</body><body package="PDF Interactive Features">version	^2</body></methods><methods><class-id>Graphics.PDF.SetType3GlyphWidthAndBoundingBox class</class-id> <category>accessing</category><body package="PDF Graphics Operations">documentation	^'Set width and bounding box information for the glyph and declare that the glyph description specifies only shape, not colour.NOTE	This operator name ends in the digit 1.wx denotes the horizontal displacement in the glyph coordinate system; it shall be consistent with the corresponding width in the font’s Widths array. wy shall be 0.llx and lly denote the coordinates of the lower-left corner, and urx and ury denote the upper-right corner, of the glyph bounding box. The glyph bounding box is the smallest rectangle, oriented with the axes of the glyph coordinate system, that completely encloses all marks placed on the page as a result of executing the glyph’s description. The declared bounding box shall be correct—in other words, sufficiently large to enclose the entire glyph. If any marks fall outside this bounding box, the result is unpredictable.A glyph description that begins with the d1 operator should not execute any operators that set the colour (or other colour-related parameters) in the graphics state; any use of such operators shall be ignored. The glyph description is executed solely to determine the glyph’s shape. Its colour shall be determined by the graphics state in effect each time this glyph is painted by a text-showing operator. For the same reason, the glyph description shall not include an image; however, an image mask is acceptable, since it merely defines a region of the page to be painted with the current colour.This operator shall be used only in a content stream appearing in a Type 3 font’s CharProcs dictionary'</body><body package="PDF Graphics Operations">operandTypes	^#(#('wx' Number) #('wy' Number) #('llx' Number) #('lly' Number) #('urx' Number) #('ury' Number))</body><body package="PDF Graphics Operations">operatorName	^#d1</body></methods><methods><class-id>Graphics.PDF.DeviceN</class-id> <category>accessing</category><body package="PDF Colour">defaultDecodeArray	| list |	list := OrderedCollection new.	self numberOfComponents timesRepeat: [list addAll: #(0.0 1.0)].	^list asPDF</body><body package="PDF Colour">initialColourValues	^#(0.0)</body><body package="PDF Colour">numberOfComponents	^self names size</body></methods><methods><class-id>Graphics.PDF.DeviceN class</class-id> <category>accessing</category><body package="PDF Colour">maxNumberOfAttributes	^5</body><body package="PDF Colour">numberOfAttributes	^4</body><body package="PDF Colour">version	^3</body></methods><methods><class-id>Core.Character class</class-id> <category>PDF</category><body package="PDF basics">pdfDelimiters	"&lt;SequenceableCollection of Character&gt;"	^'()&lt;&gt;[]{}/%'</body><body package="PDF basics">pdfNumeric	"&lt;SequenceableCollection of Character&gt;"	^'+-.0123456789'</body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="PDF basics">isAscii	^self asInteger &lt; 128</body><body package="PDF basics">isPdfDelimiter	^self class pdfDelimiters includes: self</body><body package="PDF basics">isPdfNumeric	^self class pdfNumeric includes: self</body><body package="PDF basics">isPdfRegular	^self isPdfDelimiter not and: [	self isPdfWhitespace not]</body><body package="PDF basics">isPdfWhitespace	^#(0 9 10 12 13 32) includes: self asInteger</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	^PDF.Real on: self asFloat</body></methods><methods><class-id>Core.Integer</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	^PDF.Number on: self</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	^PDF.String fromPdf: self</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	^PDF.Real on: self asFloat</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	^PDF.Null null</body></methods><methods><class-id>Core.Fraction</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	^PDF.Real on: self asFloat</body></methods><methods><class-id>Core.Boolean</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	^PDF.Boolean on: self</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	^PDF.Integer on: self</body></methods><methods><class-id>Core.Timestamp</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	^PDF.Date on: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	"&lt;PDF.Object&gt;	throws PDF.Error if the receiver can not converted to a valid PDF object"	^PDF.Error raiseSignal: 'receiver can not be represented as a PDF Object'</body><body package="PDF Basic Objects">asSmalltalkValue	^self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="PDF Basic Objects">isPDF	"&lt;Boolean&gt;	true if the receiver is a PDF.Object"	^false</body></methods><methods><class-id>Core.Symbol</class-id> <category>converting</category><body package="PDF Basic Objects">asPDF	^PDF.Name on: self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="PDF Complex Objects">asPDF	^PDF.PDFArray on: self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="PDF Complex Objects">isTypeMismatch	^false</body></methods><methods><class-id>Core.OrderedDictionary</class-id> <category>converting</category><body package="PDF Complex Objects">asPDF	^PDF.Dictionary on: self</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>converting</category><body package="PDF Data Structures">asPDF	^PDF.Rectangle fromRectangle: self</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="PDF Colour">asByteArray	^ByteArray		with: (self scaledRed bitShift: -5)		with: (self scaledGreen bitShift: -5)		with: (self scaledBlue bitShift: -5)</body><body package="PDF Colour">asCmykColor	"&lt;CmykColor&gt;"	^CmykColor fromColorValue: self</body><body package="PDF Colour">asGrayValue	"&lt;Number&gt;	between 0.0 (Black) and 1.0 (White) suitable for PDF DeviceGray"	^self brightness</body><body package="PDF Colour">asPDFArray	"&lt;Array3 of: Number&gt;	Array of 3 numbers between 0.0 (zero intensity) and 1.0 (maximum intensity) suitable for PDF DeviceRGB"	^Array		with: self red		with: self green		with: self blue</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>accessing</category><body package="PDF Colour">fillColourSetter	self isGray ifTrue: [		^PDF.SetNonStrokingGray with: self asGrayValue].	^PDF.SetNonStrokingRGB operands: self asPDFArray</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="PDF Colour">rgbIndex	"&lt;Integer&gt;	Three 8 bit RGB numbers interpreted as number for ordering"	^self asByteArray inject: 0 into: [:num :byte | (num bitShift: 8) + byte]</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>accessing</category><body package="PDF Colour">strokeColourSetter	self isGray ifTrue: [		^PDF.SetStrokingGray with: self asGrayValue].	^PDF.SetStrokingRGB operands: self asPDFArray</body></methods><methods><class-id>Graphics.SimplePaint</class-id> <category>converting</category><body package="PDF Colour">asGrayValue	"&lt;Number&gt;	between 0.0 and 1.0 suitable for PDF DeviceGray"	^self subclassResponsibility</body></methods><methods><class-id>Graphics.CoverageValue</class-id> <category>converting</category><body package="PDF Colour">asGrayValue	"&lt;Number&gt;	between 0.0 (transparent) and 1.0 (opaque) suitable for PDF DeviceGray"	^self coverage</body></methods><methods><class-id>Graphics.CachedImage</class-id> <category>converting</category><body package="PDF Images">asPDF	"&lt;ImageXObject"	^self image asPDF</body></methods><methods><class-id>Graphics.PixelArray</class-id> <category>converting</category><body package="PDF Images">asPDF	"&lt;ImageXObject"	^self subclassResponsibility</body></methods><methods><class-id>UI.Icon class</class-id> <category>instance creation</category><body package="PDF Images">fromPDF: anImageXObject	| opaqueImage |	opaqueImage := anImageXObject asSmalltalkValue.	^self figure: opaqueImage figure shape: opaqueImage shape</body></methods><methods><class-id>UI.Icon</class-id> <category>converting</category><body package="PDF Images">asPDF	"&lt;ImageXObject&gt;"	| image |	image := figure asPDF.	image at: #Mask put: shape asPDF newReference.	^image</body></methods><methods><class-id>Graphics.OpaqueImage</class-id> <category>converting</category><body package="PDF Images">asPDF	"&lt;ImageXObject&gt;"	| image |	image := self figure asPDF.	image at: #Mask put: self shape asPDF newReference.	^image</body></methods><methods><class-id>Graphics.AlphaCompositedImage</class-id> <category>converting</category><body package="PDF Images">asPDF	"&lt;ImageXObject&gt;"	^self image asPDF</body></methods><methods><class-id>Graphics.CoveragePalette</class-id> <category>accessing</category><body package="PDF Images">bitsPerComponent	^self maxIndex highBit</body><body package="PDF Images">colorspace	^#DeviceGray</body><body package="PDF Images">setImagePropertiesOf: anImageXObject	super setImagePropertiesOf: anImageXObject.	anImageXObject bitsPerComponent = 1		ifTrue: [		anImageXObject at: #ImageMask put: true]		ifFalse: [		anImageXObject at: #ColorSpace put: self colorspace].	anImageXObject at: #Decode put: #(1 0)	"encoding of transparency is reversed in PDF"</body></methods><methods><class-id>Graphics.MappedPalette class</class-id> <category>instance creation</category><body package="PDF Images">newFromIndexedColorspace: anIndexedColorspace	"Answer a mapped palette, whose colors are stored in the same order 	as the colors in anIndexedColorspace"	| inst |	inst := self new.	inst initializeFromIndexedColorspace: anIndexedColorspace.	^inst</body></methods><methods><class-id>Graphics.MappedPalette</class-id> <category>accessing</category><body package="PDF Images">baseColorspace	self hasColor ifTrue: [		^Graphics.PDF.DeviceRGB new].	^Graphics.PDF.DeviceGray new</body><body package="PDF Images">bitsPerComponent	^(self size - 1) highBit min: 8</body><body package="PDF Images">colorspace	self size &lt;= 256 ifTrue: [		^self indexedColorspace].	^self baseColorspace</body><body package="PDF Images">emptyIndexedColorspace	"&lt;Indexed&gt;	the list of colors is empty.	the colors are filled in as they are written - resulting in different indices for the colors"	^PDF.Indexed newForColorspace: self baseColorspace</body></methods><methods><class-id>Graphics.MappedPalette</class-id> <category>testing</category><body package="PDF Images">hasColorComputed	"Answer whether there are any entries which are not gray tones."	^self hasOnlyGrayComputed not</body><body package="PDF Images">hasOnlyGrayComputed	"Answer whether all entries are gray tones."	^(1 to: palette size by: 3) allSatisfy: [:index |		| scaledRed |		scaledRed := palette at: index.		scaledRed = (palette at: index + 1) and: [		scaledRed = (palette at: index + 2)]]</body></methods><methods><class-id>Graphics.MappedPalette</class-id> <category>accessing</category><body package="PDF Images">indexedColorspace	"&lt;Indexed&gt;"	"^self copiedIndexedColorspace"	^self emptyIndexedColorspace</body></methods><methods><class-id>Graphics.MappedPalette</class-id> <category>initialize-release</category><body package="PDF Images">initializeFromIndexedColorspace: anIndexedColorspace	| bytes |	size := anIndexedColorspace numberOfColors.	palette := WordArray new: self size * 3.	bytes := anIndexedColorspace rgbBytes.	1 to: palette size do: [:index | palette at: index put: ((bytes at: index) bitShift: 5)].	hasColor := self hasColorComputed.	self mapResolution: self class defaultMapResolution</body></methods><methods><class-id>Graphics.MappedPalette</class-id> <category>accessing</category><body package="PDF Images">setImagePropertiesOf: anImageXObject	super setImagePropertiesOf: anImageXObject.	anImageXObject at: #ColorSpace put: self colorspace</body></methods><methods><class-id>Graphics.FixedPalette class</class-id> <category>instance creation</category><body package="PDF Images">bgr8Bit	"An 8 bit per color channel palette, in blue-green-red order from higher bits to lower"	^self 		redShift: 0 redMask: 255 		greenShift: 8 greenMask: 255 		blueShift: 16 blueMask: 255</body><body package="PDF Images">newForDepths: array3OfDepthsIntegers	| depthRed depthGreen depthBlue |	depthRed := array3OfDepthsIntegers first.	depthGreen := array3OfDepthsIntegers at: 2.	depthBlue := array3OfDepthsIntegers last.	^self		redShift: depthGreen + depthBlue		redMask: (1 bitShift: depthRed) - 1		greenShift: depthBlue		greenMask: (1 bitShift: depthGreen) - 1		blueShift: 0		blueMask: (1 bitShift: depthBlue) - 1</body></methods><methods><class-id>Graphics.FixedPalette</class-id> <category>accessing</category><body package="PDF Images">bitsPerComponent	^(redMask bitOr: (greenMask bitOr: blueMask)) highBit</body><body package="PDF Images">bitsPerComponents	"&lt;Array of: Integer&gt;	the number of bits of the base components"	^Array		with: redMask highBit		with: greenMask highBit		with: blueMask highBit</body></methods><methods><class-id>Graphics.FixedPalette</class-id> <category>testing</category><body package="PDF Images">isDepth24RGBOrBGR	^self = FixedPalette bgr8Bit or: [	self = FixedPalette rgb8Bit]</body></methods><methods><class-id>Graphics.FixedPalette</class-id> <category>accessing</category><body package="PDF Images">setImagePropertiesOf: anImageXObject	super setImagePropertiesOf: anImageXObject.	anImageXObject at: #ColorSpace put: self colorspace.	anImageXObject addDecodeIfNeededFor: self bitsPerComponents</body></methods><methods><class-id>Graphics.Depth4Image</class-id> <category>converting</category><body package="PDF Images">readPixelsFrom: anImageXObject	anImageXObject isIndexed ifFalse: [		^super readPixelsFrom: anImageXObject].	self readMappedPixelsFrom: anImageXObject</body><body package="PDF Images">writePixelsTo: anImageXObject	anImageXObject isIndexed ifFalse: [		^super writePixelsTo: anImageXObject].	self writeMappedPixelsTo: anImageXObject</body></methods><methods><class-id>Graphics.Palette</class-id> <category>accessing</category><body package="PDF Images">bitsPerComponent	^self depth</body><body package="PDF Images">colorspace	^#DeviceRGB</body><body package="PDF Images">maxComponent	"&lt;Integer&gt;	the maximal value of a single component"	^(1 bitShift: self bitsPerComponent) - 1</body><body package="PDF Images">setImagePropertiesOf: anImageXObject	anImageXObject bitsPerComponent: self bitsPerComponent</body></methods><methods><class-id>Graphics.MonoMappedPalette</class-id> <category>accessing</category><body package="PDF Images">bitsPerComponent	^1</body><body package="PDF Images">colorspace	^#DeviceGray</body></methods><methods><class-id>Graphics.MonoMappedPalette</class-id> <category>testing</category><body package="PDF Images">hasColorComputed	"Answer whether there are any entries which are not gray tones."	^false</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>instance creation</category><body package="PDF Images">fromByte: anInteger	^self fromBytes: (ByteArray new: 3 withAll: anInteger)</body><body package="PDF Images">fromBytes: threeBytes	^self fromBytesRed: threeBytes first green: (threeBytes at: 2) blue: threeBytes last</body><body package="PDF Images">fromBytesRed: redByte green: greenByte blue: blueByte	| scale |	scale := ColorValue scalingValue.	^ColorValue		scaledRed: redByte * scale // 255		scaledGreen: greenByte * scale // 255		scaledBlue: blueByte * scale // 255</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>accessing</category><body package="PDF Images">colorspace	^#DeviceRGB</body></methods><methods><class-id>Graphics.Depth1Image</class-id> <category>converting</category><body package="PDF Images">readPixelsFrom: anImageXObject	| pdfBytesPerRow padding bytes |	anImageXObject isStandard1BitBWOrMask ifFalse: [		^super readPixelsFrom: anImageXObject].	pdfBytesPerRow := anImageXObject bytesPerRow.	padding := rowByteSize - pdfBytesPerRow.	bytes := anImageXObject internal asByteArray.	0 to: self height - 1 do: [:rowIndex |		bits			replaceFrom: rowIndex * rowByteSize + 1			to: (rowIndex + 1) * rowByteSize - padding			with: bytes			startingAt: rowIndex * pdfBytesPerRow + 1]</body><body package="PDF Images">writePixelsTo: anImageXObject	| pdfBytesPerRow bytes |	anImageXObject isStandard1BitBWOrMask ifFalse: [		^super writePixelsTo: anImageXObject].	pdfBytesPerRow := anImageXObject bytesPerRow.	bytes := ByteArray new: anImageXObject bytesPerImage.	0 to: self height - 1 do: [:rowIndex |		bytes			replaceFrom: rowIndex * pdfBytesPerRow + 1			to: (rowIndex + 1) * pdfBytesPerRow			with: bits			startingAt: rowIndex * rowByteSize + 1].	anImageXObject contents: bytes asByteString</body></methods><methods><class-id>Graphics.Depth32Image</class-id> <category>converting</category><body package="PDF Images">readAlphaPixelsFrom: anImageXObject	| readBlock wst rstMask rst |	readBlock := [:bytes | bytes].	self palette = FixedPalette bgr8Bit ifTrue: [		readBlock := [:bytes | bytes reverse]].	rst := anImageXObject internal asByteArray readStream.	rstMask := anImageXObject SMask internal asByteArray readStream.	wst := bits writeStream.	[rst atEnd] whileFalse: [		wst nextPut: rstMask next.		wst nextPutAll: (readBlock value: (rst next: 3))]</body><body package="PDF Images">readPixelsFrom: anImageXObject	anImageXObject isStandard8BitRGB ifFalse: [		^super readPixelsFrom: anImageXObject].	self palette isDepth24RGBOrBGR ifTrue: [		^self readAlphaPixelsFrom: anImageXObject].	super readPixelsFrom: anImageXObject</body><body package="PDF Images">writeDepth24PixelsTo: anImageXObject	"3 8-bit components in x-R-G-B or x-B-G-R order - the first byte is ignored"	| readBlock rst wst |	readBlock := [:bytes | bytes].	self palette = FixedPalette bgr8Bit ifTrue: [		readBlock := [:bytes | bytes reverse]].	rst := bits readStream.	wst := (ByteArray new: anImageXObject bytesPerImage) writeStream.	[rst atEnd] whileFalse: [		rst next.		wst nextPutAll: (readBlock value: (rst next: 3))].	anImageXObject contents: wst contents asByteString</body><body package="PDF Images">writeDepth32PixelsTo: anImageXObject	"4 8-bit components in A-R-G-B or A-B-G-R order.	The alpha byte is collected into a SoftMask image"	| readBlock rst wst wstMask maskBytes |	readBlock := [:bytes | bytes].	self palette = FixedPalette bgr8Bit ifTrue: [		readBlock := [:bytes | bytes reverse]].	rst := bits readStream.	wst := (ByteArray new: anImageXObject bytesPerImage) writeStream.	wstMask := (ByteArray new: anImageXObject numberOfPixel) writeStream.	[rst atEnd] whileFalse: [		wstMask nextPut: rst next.		wst nextPutAll: (readBlock value: (rst next: 3))].	anImageXObject contents: wst contents asByteString.	maskBytes := wstMask contents.	(maskBytes allSatisfy: #isZero) ifTrue: [		^self].	anImageXObject addSoftMaskWithBytes: maskBytes</body><body package="PDF Images">writePixelsTo: anImageXObject	anImageXObject isStandard8BitRGB ifFalse: [		^super writePixelsTo: anImageXObject].	self palette isDepth24RGBOrBGR ifFalse: [		^super writePixelsTo: anImageXObject].	self depth = 24 ifTrue: [		^self writeDepth24PixelsTo: anImageXObject].	self depth = 32 ifTrue: [		^self writeDepth32PixelsTo: anImageXObject].	^super writePixelsTo: anImageXObject</body></methods><methods><class-id>Graphics.Image</class-id> <category>converting</category><body package="PDF Images">asPDF	"&lt;ImageXObject&gt;	a PDF object ready to be added to a page with a renderer"	^Graphics.PDF.ImageXObject from: self</body><body package="PDF Images">readMappedPixelsFrom: anImageXObject	| pdfBytesPerRow padding bytes |	palette := MappedPalette newFromIndexedColorspace: anImageXObject ColorSpace.	pdfBytesPerRow := anImageXObject bytesPerRow.	padding := rowByteSize - pdfBytesPerRow.	bytes := anImageXObject internal asByteArray.	0 to: self height - 1 do: [:rowIndex |		bits			replaceFrom: rowIndex * rowByteSize + 1			to: (rowIndex + 1) * rowByteSize - padding			with: bytes			startingAt: rowIndex * pdfBytesPerRow + 1]</body><body package="PDF Images">readPixelsByPixelFrom: anImageXObject	"default inefficient implementation.	Should be reimplemented more efficiently in subclasses"	anImageXObject pixelsDo: [:columnIndex :rowIndex |		| paint |		paint := anImageXObject valueAtPoint: columnIndex @ rowIndex.		self valueAtPoint: columnIndex @ rowIndex put: paint]</body><body package="PDF Images">readPixelsFrom: anImageXObject	"default inefficient implementation.	Should be reimplemented more efficiently in subclasses"	self readPixelsByPixelFrom: anImageXObject</body><body package="PDF Images">writeMappedPixelsTo: anImageXObject	| pdfBytesPerRow bytes |	anImageXObject ColorSpace initializeColorsFrom: self palette.	pdfBytesPerRow := anImageXObject bytesPerRow.	bytes := ByteArray new: anImageXObject bytesPerImage.	0 to: self height - 1 do: [:rowIndex |		bytes			replaceFrom: rowIndex * pdfBytesPerRow + 1			to: (rowIndex + 1) * pdfBytesPerRow			with: bits			startingAt: rowIndex * rowByteSize + 1].	anImageXObject contents: bytes asByteString</body><body package="PDF Images">writePixelsTo: anImageXObject	"set the pixels of anImageXObject to the pixel colors of the receiver.	Default fall back implementation: convert to screen representation, then use the efficient conversion.	Drawback: the image may be large.	Should be reimplemented by subclasses"	| screenImage |	anImageXObject resetImageProperties.	screenImage := self convertForGraphicsDevice: Screen default.	screenImage palette setImagePropertiesOf: anImageXObject.	screenImage writePixelsTo: anImageXObject</body></methods><methods><class-id>Graphics.Depth2Image</class-id> <category>converting</category><body package="PDF Images">readPixelsFrom: anImageXObject	anImageXObject isIndexed ifFalse: [		^super readPixelsFrom: anImageXObject].	self readMappedPixelsFrom: anImageXObject</body><body package="PDF Images">writePixelsTo: anImageXObject	anImageXObject isIndexed ifFalse: [		^super writePixelsTo: anImageXObject].	self writeMappedPixelsTo: anImageXObject</body></methods><methods><class-id>Graphics.Depth8Image</class-id> <category>converting</category><body package="PDF Images">readPixelsFrom: anImageXObject	anImageXObject isIndexed ifFalse: [		^super readPixelsFrom: anImageXObject].	self readMappedPixelsFrom: anImageXObject</body><body package="PDF Images">writePixelsTo: anImageXObject	anImageXObject isIndexed ifFalse: [		^super writePixelsTo: anImageXObject].	self writeMappedPixelsTo: anImageXObject</body></methods><methods><class-id>Graphics.Depth24Image</class-id> <category>converting</category><body package="PDF Images">copyPixelBytesFrom: anImageXObject	| padding pdfBytesPerRow bytes |	pdfBytesPerRow := anImageXObject bytesPerRow.	padding := rowByteSize - pdfBytesPerRow.	bytes := anImageXObject internal asByteArray.	0 to: self height - 1 do: [:rowIndex |		bits			replaceFrom: rowIndex * rowByteSize + 1			to: (rowIndex + 1) * rowByteSize - padding			with: bytes			startingAt: rowIndex * pdfBytesPerRow + 1]</body><body package="PDF Images">copyPixelBytesTo: anImageXObject	| bytes pdfBytesPerRow |	pdfBytesPerRow := anImageXObject bytesPerRow.	bytes := ByteArray new: anImageXObject bytesPerImage.	0 to: self height - 1 do: [:rowIndex |		bytes			replaceFrom: rowIndex * pdfBytesPerRow + 1			to: (rowIndex + 1) * pdfBytesPerRow			with: bits			startingAt: rowIndex * rowByteSize + 1].	anImageXObject contents: bytes asByteString</body><body package="PDF Images">readGrayPixelBytesFrom: anImageXObject	| pdfBytesPerRow bytes |	pdfBytesPerRow := anImageXObject bytesPerRow.	bytes := anImageXObject internal asByteArray.	0 to: self height - 1 do: [:rowIndex |		| startOfPDFRow startOfRow |		startOfPDFRow := rowIndex * pdfBytesPerRow + 1.		startOfRow := rowIndex * rowByteSize + 1.		0 to: self width - 1 do: [:columnIndex |			| gray startOfPixel |			gray := bytes at: startOfPDFRow + columnIndex.			startOfPixel := startOfRow + (columnIndex * 3).			bits at: startOfPixel put: gray.			bits at: startOfPixel + 1 put: gray.			bits at: startOfPixel + 2 put: gray]]</body><body package="PDF Images">readPixelsFrom: anImageXObject	anImageXObject isStandard8BitRGB ifTrue: [		^self copyPixelBytesFrom: anImageXObject].	anImageXObject isStandard8BitGray ifTrue: [		^self readGrayPixelBytesFrom: anImageXObject].	(self palette isKindOf: FixedPalette) ifFalse: [		^super readPixelsFrom: anImageXObject].	super readPixelsFrom: anImageXObject</body><body package="PDF Images">writePixelsTo: anImageXObject	anImageXObject isStandard8BitRGB ifTrue: [		^self copyPixelBytesTo: anImageXObject].	super writePixelsTo: anImageXObject</body></methods><methods><class-id>Graphics.Fonts.CustomFont</class-id> <category>converting</category><body package="PDF Fonts">addPDFFontFileTo: aFontDescriptor	aFontDescriptor at: #FontFile put: self program pdfFontFile newReference</body></methods><methods><class-id>Graphics.Fonts.FontProgram</class-id> <category>converting</category><body package="PDF Fonts">pdfFontFile	| headerBytes binaryBytes trailerBytes headerSize binarySize trailerSize wst |	headerBytes := self header contents asByteString.	headerSize := headerBytes size.	binaryBytes := self binaryContents asByteString.	binarySize := binaryBytes size.	trailerBytes := self trailerByteString.	trailerSize := trailerBytes size.	wst := WriteStream on: (ByteString new: headerSize + binarySize + trailerSize).	wst		nextPutAll: headerBytes;		nextPutAll: binaryBytes;		nextPutAll: trailerBytes.	^PDF.Stream		on: (OrderedDictionary			with: #Length1 -&gt; headerSize			with: #Length2 -&gt; binarySize			with: #Length3 -&gt; trailerSize			with: #Filter -&gt; #FlateDecode)		internal: wst contents</body></methods><methods><class-id>Graphics.Fonts.OpenType.Cff</class-id> <category>converting</category><body package="PDF Fonts">pdfFontFile	^PDF.Stream		on: (OrderedDictionary			with: #Subtype -&gt; #Type1C			with: #Filter -&gt; #FlateDecode)		internal: self contents asByteString</body></methods><methods><class-id>Graphics.Fonts.OpenType.Font</class-id> <category>converting</category><body package="PDF Fonts">addPDFFontFileTo: aFontDescriptor	aFontDescriptor at: #FontFile3 put: self cff pdfFontFile newReference</body></methods><methods><class-id>Graphics.Fonts.OpenType.Font</class-id> <category>accessing</category><body package="PDF Fonts">pdfStringWithTabularCharacters: aString for: aPDFRenderer	"&lt;String&gt;	string with WinAnsiEncoding where tabular glyphs are specially encoded"	^aPDFRenderer pdfStringWithTabularCharacters: aString inFont: self</body></methods><methods><class-id>Graphics.Fonts.Font</class-id> <category>converting</category><body package="PDF Fonts">addPDFFontFileTo: aFontDescriptor	"do nothing"</body><body package="PDF Fonts">newPDFEncodingWith: extraGlyphs	"&lt;Symbol | Encoding&gt;"	| encoding runs diffs |	extraGlyphs isEmpty ifTrue: [		^#WinAnsiEncoding].	runs := extraGlyphs values asSortedCollection piecesCutWhere: [:code1 :code2 |		code1 + 1 ~= code2].	diffs := OrderedCollection new.	runs do: [:run |		diffs add: run first.		run do: [:code |			| glyph |			glyph := extraGlyphs keyAtValue: code.			diffs add: glyph name asSymbol]].	encoding := PDF.Encoding empty.	encoding at: #BaseEncoding put: #WinAnsiEncoding.	encoding at: #Differences put: diffs.	^encoding</body><body package="PDF Fonts">pdfFont	"&lt;PDF.Font&gt;	PDF structure to be embedded into a PDF Document"	| pdfFont fontDescriptor |	pdfFont := Graphics.PDF.Type1 empty.	fontDescriptor := self pdfFontDescriptor.	pdfFont at: #BaseFont put: fontDescriptor FontName.	pdfFont at: #FontDescriptor put: fontDescriptor newReference.	^pdfFont</body><body package="PDF Fonts">pdfFontDescriptor	| fontDescriptor |	fontDescriptor := PDF.FontDescriptor empty.	fontDescriptor at: #FontName put: self postScriptName asSymbol.	fontDescriptor at: #Flags put: self pdfFlags.	fontDescriptor at: #FontBBox put: self fontBBoxInStandardGlyphSpace.	fontDescriptor at: #ItalicAngle put: self italicAngle.	fontDescriptor at: #Ascent put: (self inStandardGlyphSpace: self ascender).	fontDescriptor at: #Descent put: (self inStandardGlyphSpace: self descender).	fontDescriptor at: #CapHeight put: (self inStandardGlyphSpace: self capHeight).	fontDescriptor at: #StemV put: (self inStandardGlyphSpace: self stemV).	self addPDFFontFileTo: fontDescriptor.	^fontDescriptor</body></methods><methods><class-id>Graphics.Fonts.Font</class-id> <category>accessing</category><body package="PDF Fonts">pdfStringWithTabularCharacters: aString for: aPDFRenderer	"&lt;String&gt;	string with WinAnsiEncoding where tabular glyphs are specially encoded.	Tabular glyphs are not supported in PostScript Type-1 fonts"	^aString</body></methods><methods><class-id>Graphics.Fonts.Font</class-id> <category>converting</category><body package="PDF Fonts">pdfWinAnsiEncodingAttributesWith: extraGlyphs	| lastCharIndex lastChar firstCharIndex w firstChar widths dict |	widths := self class winAnsiEncoder decoder asArray collect: [:char |		(self glyphAtUnicode: char asInteger) ifNotNil: #width].	extraGlyphs keysAndValuesDo: [:glyph :code | widths at: code + 1 put: glyph width].	firstChar := nil.	firstCharIndex := 1.	[firstChar isNil] whileTrue: [		(widths at: firstCharIndex) ifNil: [firstCharIndex := firstCharIndex + 1] ifNotNil: [			firstChar := firstCharIndex]].	lastChar := nil.	lastCharIndex := 256.	[lastChar isNil] whileTrue: [		(widths at: lastCharIndex) ifNil: [lastCharIndex := lastCharIndex - 1] ifNotNil: [			lastChar := lastCharIndex]].	w := widths copyFrom: firstChar to: lastChar.	w replaceAll: nil with: self glyphs first width.	dict := OrderedDictionary new.	dict at: #Widths put: (w collect: [:width | self inStandardGlyphSpace: width]).	dict at: #FirstChar put: firstChar - 1.	dict at: #LastChar put: lastChar - 1.	dict at: #Encoding put: (self newPDFEncodingWith: extraGlyphs).	^dict</body></methods><methods><class-id>Graphics.Fonts.StandardFont</class-id> <category>converting</category><body package="PDF Fonts">pdfFont	| pdfFont |	pdfFont := Graphics.PDF.Type1 empty.	pdfFont at: #BaseFont put: self postScriptName asSymbol.	^pdfFont</body><body package="PDF Fonts">pdfWinAnsiEncodingAttributesWith: extraGlyphs	"from PDF 1.5, this special treatment is deprecated:	Also standard fonts should have a proper description (without a FontFile though)"	| dict |	dict := OrderedDictionary new.	dict at: #Encoding put: (self newPDFEncodingWith: extraGlyphs).	^dict</body></methods><methods><class-id>Core.Point</class-id> <category>converting</category><body package="PDF Rendering">asPDFArray	^Array with: self x with: self y</body></methods><methods><class-id>Graphics.PDF.PDFObject class</class-id> <category>accessing</category><body package="PDF Complex Objects">pragmas	&lt;pragmas: #instance&gt;	^self pragmasForType , self pragmasForRequired , self pragmasForVersion , self pragmasForDocumentation</body></methods><methods><class-id>Graphics.PDF.TypedDictionary</class-id> <category>accessing entries</category><body package="PDF Complex Objects">Type	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The type of PDF object that this dictionary describes.The value of the Type entry can almost always be inferred from context.The value of an entry in a page''s font resource dictionary, for example, shall be a font object;therefore, the Type entry in a font dictionary serves primarily as documentation and as information for error checking.The Type entry shall not be required unless so stated in its description; however, if the entry is present, it shall have the correct value.In addition, the value of the Type entry in any dictionary, even in private data, shall be either a name defined in this standard or a registered name.'&gt;	^self objectAt: #Type</body></methods><methods><class-id>Graphics.PDF.Annot</class-id> <category>accessing entries</category><body package="PDF Interactive Features">AP	&lt;type: #Appearance&gt;	&lt;version: 2&gt;	&lt;attribute: 9 documentation: 'An appearance dictionary specifying how the annotation shall be presented visually on the page.Individual annotation handlers may ignore this entry and provide their own appearances'&gt;	^self objectAt: #AP ifAbsent: [Appearance empty]</body><body package="PDF Interactive Features">AS	&lt;type: #Name&gt;	&lt;version: 2&gt;	&lt;attribute: 10 documentation: '(Required if the appearance dictionary AP contains one or more subdictionaries)The annotation’s appearance state, which selects the applicable appearance stream from an appearance subdictionary'&gt;	^self objectAt: #AS ifAbsent: [Name empty]</body><body package="PDF Interactive Features">Border	&lt;type: #PDFArray&gt;	&lt;attribute: 11 documentation: 'An array specifying the characteristics of the annotation’s border, which shall be drawn as a rounded rectangle.(PDF 1.0)The array consists of three numbers defining the horizontal corner radius, vertical corner radius, and border width, all in default user space units.If the corner radii are 0, the border has square (not rounded) corners; if the border width is 0, no border is drawn.(PDF 1.1)The array may have a fourth element, an optional dash array defining a pattern of dashes and gaps that shall be used in drawing the border.The dash array shall be specified in the same format as in the line dash pattern parameter of the graphics state.EXAMPLEA Border value of [0 0 1 [3 2]] specifies a border 1 unit wide, with square corners, drawn with 3-unit dashes alternating with 2-unit gaps.NOTE (PDF 1.2)The dictionaries for some annotation types (such as free text and polygon annotations) can include the BS entry.That entry specifies a border style dictionary that has more settings than the array specified for the Border entry.If an annotation dictionary includes the BS entry, then the Border entry is ignored.'&gt;	^self objectAt: #Border ifAbsent: [#(0 0 1) asPDF]</body><body package="PDF Interactive Features">C	&lt;typeArrayOf: #Number&gt;	&lt;version: 1&gt;	&lt;attribute: 12 documentation: 'An array of numbers in the range 0.0 to 1.0, representing a colour used for the following purposes:The background of the annotation’s icon when closedThe title bar of the annotation’s pop-up windowThe border of a link annotationThe number of array elements determines the colour space in which the colour shall be defined:0 No colour; transparent1 DeviceGray3 DeviceRGB4 DeviceCMYK'&gt;	^self objectAt: #C ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">Contents	&lt;type: #Textstring&gt;	&lt;attribute: 4 documentation: 'Text that shall be displayed for the annotation or, if this type of annotation does not display text, an alternate description of the annotation’s contents in human-readable form.In either case, this text is useful when extracting the document’s contents in support of accessibility to users with disabilities or for other purposes'&gt;	^self objectAt: #Contents ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">F	&lt;type: #Integer&gt;	&lt;version: 1&gt;	&lt;attribute: 8 documentation: 'A set of flags specifying various characteristics of the annotation.The value is an integer interpreted as one-bit flags specifying various characteristics of the annotation.Bit positions within the flag word shall be numbered from low-order to high-order, with the lowest-order bit numbered 1.All other bits of the integer shall be set to 0.Bit position		Name				Meaning	1			Invisible			If set, do not display the annotation if it does not belong to one of the standard annotation types and no annotation handler is available.									If clear, display such an unknown annotation using an appearance stream specified by its appearance dictionary, if any.	2			Hidden 			(PDF 1.2) If set, do not display or print the annotation or allow it to interact with the user, regardless of its annotation type or whether an annotation handler is available.									NOTE In cases where screen space is limited, the ability to hide and show annotations selectively can be used in combination with appearance streams to display auxiliary pop-up information similar in function to online help systems.	3			Print 				(PDF 1.2) If set, print the annotation when the page is printed.									If clear, never print the annotation, regardless of whether it is displayed on the screen.									NOTE This can be useful for annotations representing interactive pushbuttons, which would serve no meaningful purpose on the printed page.	4			NoZoom 			(PDF 1.3) If set, do not scale the annotation’s appearance to match the magnification of the page.									The location of the annotation on the page (defined by the upper-left corner of its annotation rectangle) shall remain fixed, regardless of the page magnification.	5			NoRotate 			(PDF 1.3) If set, do not rotate the annotation’s appearance to match the rotation of the page.									The upper-left corner of the annotation rectangle shall remain in a fixed location on the page, regardless of the page rotation.	6			NoView 			(PDF 1.3) If set, do not display the annotation on the screen or allow it to interact with the user.									The annotation may be printed (depending on the setting of the Print flag) but should be considered hidden for purposes of on-screen display and user interaction.	7			ReadOnly 			(PDF 1.3) If set, do not allow the annotation to interact with the user.									The annotation may be displayed or printed (depending on the settings of the NoView and Print flags) but should not respond to mouse clicks or change its appearance in response to mouse motions.									This flag shall be ignored for widget annotations; its function is subsumed by the ReadOnly flag of the associated form field.	8			Locked 			(PDF 1.4) If set, do not allow the annotation to be deleted or its properties (including position and size) to be modified by the user.									However, this flag does not restrict changes to the annotation’s contents, such as the value of a form field.	9			ToggleNoView 	(PDF 1.5) If set, invert the interpretation of the NoView flag for certain events.									NOTE A typical use is to have an annotation that appears only when a mouse cursor is held over it.	10			LockedContents 	(PDF 1.7) If set, do not allow the contents of the annotation to be modified by the user.									This flag does not restrict deletion of the annotation or changes to other annotation properties, such as position and size.'&gt;	^self objectAt: #F ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">M	&lt;type: #Date&gt;	&lt;type: #Textstring&gt;	&lt;version: 1&gt;	&lt;attribute: 7 documentation: 'The date and time when the annotation was most recently modified.The format should be a date string, “Dates,” but conforming readers shall accept and display a string in any format'&gt;	^self objectAt: #M ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">NM	&lt;type: #Textstring&gt;	&lt;version: 4&gt;	&lt;attribute: 6 documentation: 'The annotation name, a text string uniquely identifying it among all the annotations on its page'&gt;	^self objectAt: #NM ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">OC	&lt;type: #Dictionary&gt;	&lt;version: 5&gt;	&lt;attribute: 14 documentation: 'An optional content group or optional content membership dictionary specifying the optional content properties for the annotation.Before the annotation is drawn, its visibility shall be determined based on this entry as well as the annotation flags specified in the F entry.If it is determined to be invisible, the annotation shall be skipped, as if it were not in the document'&gt;	^self objectAt: #OC ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">P	&lt;typeIndirect: #Page&gt;	&lt;version: 3&gt;	&lt;attribute: 5 documentation: '(Optional except as noted below; not used in FDF files)An indirect reference to the page object with which this annotation is associated.This entry shall be present in screen annotations associated with rendition actions (PDF 1.5).'&gt;	^self objectAt: #P ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">Rect	&lt;type: #Rectangle&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'The annotation rectangle, defining the location of the annotation on the page in default user space units.The annotation’s position shall be determined by the coordinates of the upper-left corner of its annotation rectangle.When the default user space is scaled or rotated, the positions of the other three corners of the annotation rectangle are different in the altered user space than they were in the original user space.The conforming reader shall perform this alteration automatically.However, it shall not actually change the annotation’s Rect entry, which continues to describe the annotation’s relationship with the unscaled, unrotated user space.'&gt;	^self objectAt: #Rect</body><body package="PDF Interactive Features">StructParent	&lt;type: #Integer&gt;	&lt;version: 3&gt;	&lt;attribute: 13 documentation: '(Required if the annotation is a structural content item; PDF 1.3)The integer key of the annotation’s entry in the structural parent tree'&gt;	^self objectAt: #StructParent ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">Subtype	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The type of annotation that this dictionary describes'&gt;	^self objectAt: #Subtype</body><body package="PDF Interactive Features">Type	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The type of PDF object that this dictionary describes.'&gt;	^self objectAt: #Type ifAbsent: [#Annot asPDF]</body></methods><methods><class-id>Graphics.PDF.Markup</class-id> <category>accessing entries</category><body package="PDF Interactive Features">CA	&lt;type: #Number&gt;	&lt;version: 4&gt;	&lt;attribute: 3 documentation: 'The constant opacity value that shall be used in painting the annotation.This value shall apply to all visible elements of the annotation in its closed state (including its background and border) but not to the pop-up window that appears when the annotation is opened.The specified value shall not used if the annotation has an appearance stream; in that case, the appearance stream shall specify any transparency.(However, if the compliant viewer regenerates the annotation’s appearance stream, it may incorporate the CA value into the stream’s content.)The implicit blend mode is Normal.If no explicit appearance stream is defined for the annotation, it may bepainted by implementation-dependent means that do not necessarily conform to the PDF imaging model; in this case, the effect of this entry is implementation-dependent as well.'&gt;	^self objectAt: #CA ifAbsent: [1.0 asPDF]</body><body package="PDF Interactive Features">CreationDate	&lt;type: #Date&gt;	&lt;version: 5&gt;	&lt;attribute: 5 documentation: 'The date and time when the annotation was created.'&gt;	^self objectAt: #CreationDate ifAbsent: [nil asPDF]</body><body package="PDF Interactive Features">ExData	&lt;type: #Dictionary&gt;	&lt;version: 7&gt;	&lt;attribute: 10 documentation: 'An external data dictionary specifying data that shall be associated with the annotation.This dictionary contains the following entries:	Type 		(optional) If present, shall be ExData.	Subtype 	(required) a name specifying the type of data that the markup annotation shall be associated with.				The only defined value is Markup3D.'&gt;	^self objectAt: #ExData ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">IRT	&lt;type: #Dictionary&gt;	&lt;version: 5&gt;	&lt;attribute: 6 documentation: '(Required if an RT entry is present, otherwise optional)A reference to the annotation that this annotation is “in reply to.”Both annotations shall be on the same page of the document.The relationship between the two annotations shall be specified by the RT entry.If this entry is present in an FDF file, its type shall not be a dictionary but a text string containing the contents of the NM entry of the annotation being replied to, to allow for a situation where the annotation being replied to is not in the same FDF file.'&gt;	^self objectAt: #IRT ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">IT	&lt;type: #Name&gt;	&lt;version: 6&gt;	&lt;attribute: 9 documentation: 'A name describing the intent of the markup annotation.Intents allow conforming readers to distinguish between different uses and behaviors of a single markup annotation type.If this entry is not present or its value is the same as the annotation type, the annotation shall have no explicit intent and should behave in a generic manner in a conforming reader.Free text annotations, line annotations, polygon annotations, and polyline annotations have defined intents, whose values are enumerated in the corresponding tables.'&gt;	^self objectAt: #IT ifAbsent: [nil asPDF]</body><body package="PDF Interactive Features">Popup	&lt;typeIndirect: #PopupAnnotation&gt;	&lt;version: 3&gt;	&lt;attribute: 2 documentation: 'An indirect reference to a pop-up annotation for entering or editing the text associated with this annotation.'&gt;	^self objectAt: #Popup ifAbsent: [PopupAnnotation empty]</body><body package="PDF Interactive Features">RC	&lt;type: #Textstring&gt;	&lt;type: #Textstream&gt;	&lt;version: 5&gt;	&lt;attribute: 4 documentation: 'A rich text string that shall be displayed in the pop-up window when the annotation is opened.'&gt;	^self objectAt: #RC ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">RT	&lt;type: #Name&gt;	&lt;version: 6&gt;	&lt;attribute: 8 documentation: '(meaningful only if IRT is present)A name specifying the relationship (the “reply type”) between this annotation and one specified by IRT.Valid values are:	R		The annotation shall be considered a reply to the annotation specified by IRT.			Conforming readers shall not display replies to an annotation individually but together in the form of threaded comments.	Group	The annotation shall be grouped with the annotation specified by IRT.'&gt;	^self objectAt: #RT ifAbsent: [#R asPDF]</body><body package="PDF Interactive Features">Subj	&lt;type: #Textstring&gt;	&lt;version: 5&gt;	&lt;attribute: 7 documentation: 'Text representing a short description of the subject being addressed by the annotation.'&gt;	^self objectAt: #Subj ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">T	&lt;type: #Textstring&gt;	&lt;version: 1&gt;	&lt;attribute: 1 documentation: 'The text label that shall be displayed in the title bar of the annotation’s pop-up window when open and active.This entry shall identify the user who added the annotation.'&gt;	^self objectAt: #T ifAbsent: [Textstring empty]</body></methods><methods><class-id>Graphics.PDF.RedactAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">DA	&lt;type: #String&gt;	&lt;attribute: 6 documentation: '(Required if OverlayText is present, ignored otherwise)The appearance string to be used in formatting the overlay text when it is drawn after the affected content has been removed.This entry is ignored if the RO entry is present.'&gt;	^self objectAt: #DA ifAbsent: [String empty]</body><body package="PDF Interactive Features">IC	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 2 documentation: 'An array of three numbers in the range 0.0 to 1.0 specifying the components, in the DeviceRGB colour space, of the interior colour with which to fill the redacted region after the affected content has been removed.If this entry is absent, the interior of the redaction region is left transparent.This entry is ignored if the RO entry is present.'&gt;	^self objectAt: #IC ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">OverlayText	&lt;type: #Textstring&gt;	&lt;attribute: 4 documentation: 'A text string specifying the overlay text that should be drawn over the redacted region after the affected content has been removed.This entry is ignored if the RO entry is present.'&gt;	^self objectAt: #OverlayText ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">Q	&lt;type: #Integer&gt;	&lt;attribute: 7 documentation: 'A code specifying the form of quadding (justification) to be used in laying out the overlay text:	0	Left-justified	1	Centered	2	Right-justifiedThis entry is ignored if the RO entry is present.'&gt;	^self objectAt: #Q ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">QuadPoints	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 1 documentation: 'An array of 8 x n numbers specifying the coordinates of n quadrilaterals in default user space.If present, these quadrilaterals denote the content region that is intended to be removed.If this entry is not present, the Rect entry denotes the content region that is intended to be removed.'&gt;	^self objectAt: #QuadPoints ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">RO	&lt;type: #FormXObject&gt;	&lt;attribute: 3 documentation: 'A form XObject specifying the overlay appearance for this redaction annotation.After this redaction is applied and the affected content has been removed, the overlay appearance should be drawn such that its origin lines up with the lower-left corner of the annotation rectangle.This form XObject is not necessarily related to other annotation appearances, and may or may not be present in the AP dictionary.This entry takes precedence over the IC, OverlayText, DA, and Q entries.'&gt;	^self objectAt: #RO ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">Repeat	&lt;type: #Boolean&gt;	&lt;attribute: 5 documentation: 'If true, then the text specified by OverlayText should be repeated to fill the redacted region after the affected content has been removed.This entry is ignored if the RO entry is present.'&gt;	^self objectAt: #Repeat ifAbsent: [false asPDF]</body></methods><methods><class-id>Graphics.PDF.ShadingDictionary</class-id> <category>accessing entries</category><body package="PDF Shading">AntiAlias	&lt;type: #Boolean&gt;	&lt;attribute: 5 documentation: 'A flag indicating whether to filter the shading function to prevent aliasing artifacts.NOTE	The shading operators sample shading functions at a rate determined by the resolution of the output device.Aliasing can occur if the function is not smooth—that is, if it has a high spatial frequency relative to the sampling rate.Anti-aliasing can be computationally expensive and is usually unnecessary, since most shading functions are smooth enough or are sampled at a high enough frequency to avoid aliasing effects.Anti-aliasing may not be implemented on some output devices, in which case this flag is ignored.'&gt;	^self objectAt: #AntiAlias ifAbsent: [false asPDF]</body><body package="PDF Shading">BBox	&lt;type: #Rectangle&gt;	&lt;attribute: 4 documentation: 'An array of four numbers giving the left, bottom, right, and top coordinates, respectively, of the shading’s bounding box.The coordinates shall be interpreted in the shading’s target coordinate space.If present, this bounding box shall be applied as a temporary clipping boundary when the shading is painted, in addition to the current clipping path and any other clipping boundaries in effect at that time.'&gt;	^self objectAt: #BBox ifAbsent: [Rectangle new]</body><body package="PDF Shading">Background	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 3 documentation: 'An array of colour components appropriate to the colour space, specifying a single background colour value.If present, this colour shall be used, before any painting operation involving the shading, to fill those portions of the area to be painted that lie outside the bounds of the shading object.NOTE	In the opaque imaging model, the effect is as if the painting operation were performed twice: first with the background colour and then with the shading.NOTE	The background colour is applied only when the shading is used as part of a shading pattern, not when it is painted directly with the sh operator.'&gt;	^self objectAt: #Background ifAbsent: [#() asPDF]</body><body package="PDF Shading">ColorSpace	&lt;type: #ColourSpace&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The colour space in which colour values shall be expressed. This may be any device, CIE-based, or special colour space except a Pattern space.'&gt;	^self objectAt: #ColorSpace</body><body package="PDF Shading">ShadingType	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The shading type:1 Function-based shading2 Axial shading3 Radial shading4 Free-form Gouraud-shaded triangle mesh5 Lattice-form Gouraud-shaded triangle mesh6 Coons patch mesh7 Tensor-product patch mesh'&gt;	^self objectAt: #ShadingType</body></methods><methods><class-id>Graphics.PDF.AxialShading</class-id> <category>accessing entries</category><body package="PDF Shading">Coords	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of four numbers [x0 y0 x1 y1] specifying the starting and ending coordinates of the axis, expressed in the shading’s target coordinate space.'&gt;	^self objectAt: #Coords</body><body package="PDF Shading">Domain	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 2 documentation: 'An array of two numbers [t0 t1] specifying the limiting values of a parametric variable t.The variable is considered to vary linearly between these two values as the colour gradient varies between the starting and ending points of the axis.The variable t becomes the input argument to the colour function(s).'&gt;	^self objectAt: #Domain ifAbsent: [#(0.0 1.0) asPDF]</body><body package="PDF Shading">Extend	&lt;typeArrayOf: #Boolean&gt;	&lt;attribute: 4 documentation: 'An array of two boolean values specifying whether to extend the shading beyond the starting and ending points of the axis, respectively.'&gt;	^self objectAt: #Extend ifAbsent: [#(false false) asPDF]</body><body package="PDF Shading">Function	&lt;type: #Function&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'A 1-in, n-out function or an array of n 1-in, 1-out functions (where n is the number of colour components in the shading dictionary’s colour space).The function(s) shall be called with values of the parametric variable t in the domain defined by the Domain entry.Each function’s domain shall be a superset of that of the shading dictionary.If the value returned by the function for a given colour component is out of range, it shall be adjusted to the nearest valid value.'&gt;	^self objectAt: #Function</body></methods><methods><class-id>Graphics.PDF.Operation class</class-id> <category>specification</category><body package="PDF Graphics Operations">localSpecification	&lt;sequence: #operands&gt;</body></methods><methods><class-id>Graphics.PDF.NativeValue class</class-id> <category>specification</category><body package="PDF Basic Objects">localSpecification	&lt;constant: #content class: #{Value} comment: 'the Smalltalk object for the value I represent'&gt;</body></methods><methods><class-id>Graphics.PDF.CalRGBColourSpaceDictionary</class-id> <category>accessing entries</category><body package="PDF Colour">BlackPoint	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 2 documentation: 'An array of three numbers [XB YB ZB] specifying the tristimulus value, in the CIE 1931 XYZ space, of the diffuse black point.All three of these numbers shall be non-negative'&gt;	^self objectAt: #BlackPoint ifAbsent: [#(0.0 0.0 0.0) asPDF]</body><body package="PDF Colour">Gamma	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 3 documentation: 'An array of three numbers [GR GG GB] specifying the gamma for the red, green, and blue (A, B, and C) components of the colour space'&gt;	^self objectAt: #Gamma ifAbsent: [#(1.0 1.0 1.0) asPDF]</body><body package="PDF Colour">Matrix	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 4 documentation: 'An array of nine numbers [XA YA ZA XB YB ZB XC YC ZC] specifying the linear interpretation of the decoded A, B, and C components of the colour space with respect to the final XYZ representation.Default value: the identity matrix [1 0 0 0 1 0 0 0 1].'&gt;	^self objectAt: #Matrix ifAbsent: [#(1 0 0 0 1 0 0 0 1) asPDF]</body><body package="PDF Colour">WhitePoint	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of three numbers [XW YW ZW] specifying the tristimulus value, in the CIE 1931 XYZ space, of the diffuse white point.The numbers XW and ZW shall be positive, and YW shall be equal to 1.0'&gt;	^self objectAt: #WhitePoint</body></methods><methods><class-id>Graphics.PDF.LinkAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">A	&lt;type: #Action&gt;	&lt;version: 1&gt;	&lt;attribute: 1 documentation: 'An action that shall be performed when the link annotation is activated'&gt;	^self objectAt: #A ifAbsent: [Action empty]</body><body package="PDF Interactive Features">BS	&lt;type: #BorderStyle&gt;	&lt;version: 6&gt;	&lt;attribute: 6 documentation: 'A border style dictionary specifying the line width and dash pattern to be used in drawing the annotation’s border.The annotation dictionary’s AP entry, if present, takes precedence over the BS entry'&gt;	^self objectAt: #BS ifAbsent: [BorderStyle empty]</body><body package="PDF Interactive Features">Dest	&lt;type: #PDFArray&gt;	&lt;type: #Name&gt;	&lt;type: #String&gt;	&lt;attribute: 2 documentation: '(not permitted if an A entry is present)A destination that shall be displayed when the annotation is activated'&gt;	^self objectAt: #Dest ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">H	&lt;type: #Name&gt;	&lt;version: 2&gt;	&lt;attribute: 3 documentation: 'The annotation’s highlighting mode, the visual effect that shall be used when the mouse button is pressed or held down inside its active area:	N 	(None) 		No highlighting.	I 	(Invert) 	Invert the contents of the annotation rectangle.	OI 	(Outline) 	Invert the annotation’s border.	P 	(Push) 		Display the annotation as if it were being pushed below the surface of the page'&gt;	^self objectAt: #H ifAbsent: [#I asPDF]</body><body package="PDF Interactive Features">PA	&lt;type: #Dictionary&gt;	&lt;version: 3&gt;	&lt;attribute: 4 documentation: 'A URI action formerly associated with this annotation.When Web Capture changes an annotation from a URI to a go-to action, it uses this entry to save the data from the original URI action so that it can be changed back in case the target page for the go-to action is subsequently deleted'&gt;	^self objectAt: #PA ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">QuadPoints	&lt;typeArrayOf: #Number&gt;	&lt;version: 6&gt;	&lt;attribute: 5 documentation: 'An array of 8 × n numbers specifying the coordinates of n quadrilaterals in default user space that comprise the region in which the link should be activated.The coordinates for each quadrilateral are given in the order	x1 y1 x2 y2 x3 y3 x4 y4specifying the four vertices of the quadrilateral in counterclockwise order.For orientation purposes, such as when applying an underline border style, the bottom of a quadrilateral is the line formed by (x1, y1)and (x2, y2).If this entry is not present or the conforming reader does not recognize it, the region specified by the Rect entry should be used.QuadPoints shall be ignored if any coordinate in the array lies outside the region specified by Rect'&gt;	^self objectAt: #QuadPoints ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.Stream</class-id> <category>accessing entries</category><body package="PDF Streams">DL	&lt;type: #Integer&gt;	&lt;version: 5&gt;	&lt;attribute: 7 documentation: 'A non-negative integer representing the number of bytes in the decoded (defiltered) stream.It can be used to determine, for example, whether enough disk space is available to write a stream to a file.This value shall be considered a hint only; for some stream filters, it may not be possible to determine this value precisely.'&gt;	^self objectAt: #DL ifAbsent: [nil asPDF]</body><body package="PDF Streams">DecodeParms	&lt;type: #Dictionary&gt;	&lt;type: #PDFArray&gt;	&lt;attribute: 3 documentation: 'A parameter dictionary or an array of such dictionaries, used by the filters specified by Filter.If there is only one filter and that filter has parameters, DecodeParms shall be set to the filter’s parameter dictionary unless all the filter’s parameters have their default values, in which case the DecodeParms entry may be omitted.If there are multiple filters and any of the filters has parameters set to nondefault values, DecodeParms shall be an array with one entry for each filter: either the parameter dictionary for that filter, or the null object if that filter has no parameters (or if all of its parameters have their default values).If none of the filters have parameters, or if all their parameters have default values, the DecodeParms entry may be omitted.'&gt;	^self objectAt: #DecodeParms ifAbsent: [Dictionary empty]</body><body package="PDF Streams">F	"&lt;#fileSpecification | nil&gt;"	&lt;type: #String&gt;	&lt;type: #Dictionary&gt;	&lt;version: 2&gt;	&lt;attribute: 4 documentation: 'The file containing the stream data.If this entry is present, the bytes between stream and endstreamshall be ignored.However, the Length entry should still specify the number of those bytes (usually, there are no bytes and Length is 0).The filters that are applied to the file data shall be specified by FFilter and the filter parameters shall be specified by FDecodeParms.'&gt;	^self objectAt: #F ifAbsent: ['' asPDF]</body><body package="PDF Streams">FDecodeParms	&lt;type: #Dictionary&gt;	&lt;typeArrayOf: #Dictionary&gt;	&lt;version: 2&gt;	&lt;attribute: 6 documentation: 'A parameter dictionary, or an array of such dictionaries, used by the filters specified by FFilter.The same rules apply as for DecodeParms.'&gt;	^self objectAt: #FDecodeParms ifAbsent: [Dictionary empty]</body><body package="PDF Streams">FFilter	&lt;type: #Name&gt;	&lt;typeArrayOf: #Name&gt;	&lt;version: 2&gt;	&lt;attribute: 5 documentation: 'The name of a filter to be applied in processing the data found in the stream’s external file, or an array of zero, one or several such names.The same rules apply as for Filter.'&gt;	^self objectAt: #FFilter ifAbsent: [nil asPDF]</body><body package="PDF Streams">Filter	&lt;type: #Name&gt;	&lt;typeArrayOf: #Name&gt;	&lt;attribute: 2 documentation: 'The name of a filter that shall be applied in processing the stream data found between the keywords stream and endstream, or an array of zero, one or several names.Multiple filters shall be specified in the order in which they are to be applied.'&gt;	^self objectAt: #Filter ifAbsent: [#() asPDF]</body><body package="PDF Streams">Length	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The number of bytes from the beginning of the line following the keyword stream to the last byte just before the keyword endstream.(There may be an additional EOL marker, preceding endstream, that is not included in the count and is not logically part of the stream data.)'&gt;	^self objectAt: #Length</body></methods><methods><class-id>Graphics.PDF.ICCProfileStream</class-id> <category>accessing entries</category><body package="PDF Colour">Alternate	&lt;type: #ColourSpace&gt;	&lt;attribute: 2 documentation: 'An alternate colour space that shall be used in case the one specified in the stream data is not supported.Non-conforming readers may use this colour space.The alternate space may be any valid colour space (except a Pattern colour space) that has the number of components specified by N.If this entry is omitted and the conforming reader does not understand the ICC profile data, the colour space that shall be used is DeviceGray, DeviceRGB, or DeviceCMYK, depending on whether the value of N is 1, 3, or 4, respectively.There shall not be conversion of source colour values, such as a tint transformation, when using the alternate colour space.Colour values within the range of the ICCBased colour space might not be within the range of the alternate colour space.In this case, the nearest values within the range of the alternate space shall be substituted.'&gt;	^self objectAt: #Alternate ifAbsent: [		self N asSmalltalkValue = 1 ifTrue: [			^DeviceGray empty].		self N asSmalltalkValue = 3 ifTrue: [			^DeviceRGB empty].		^DeviceCMYK empty]</body><body package="PDF Colour">Metadata	&lt;type: #Stream&gt;	&lt;version: 4&gt;	&lt;attribute: 4 documentation: 'A metadata stream that shall contain metadata for the colour space'&gt;	^self objectAt: #Metadata ifAbsent: [Stream empty]</body><body package="PDF Colour">N	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The number of colour components in the colour space described by the ICC profile data.This number shall match the number of components actually in the ICC profile. N shall be 1, 3, or 4.'&gt;	^self objectAt: #N</body><body package="PDF Colour">Range	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 3 documentation: 'An array of 2 × N numbers [min0 max0 min1 max1 …] that shall specify the minimum and maximum valid values of the corresponding colour components.These values shall match the information in the ICC profile. Default value: [0.0 1.0 0.0 1.0 …].'&gt;	^self objectAt: #Range ifAbsent: [		| array |		array := Array new: self N asSmalltalkValue * 2.		0 to: self N asSmalltalkValue - 1 do: [:i |			array at: i * 2 + 1 put: 0.0.			array at: i * 2 + 2 put: 1.0].		array asPDF]</body></methods><methods><class-id>Graphics.PDF.GroupAttributes</class-id> <category>accessing entries</category><body package="PDF XObjects">S	&lt;type: #Name&gt;	&lt;attribute: 2 documentation: 'The group subtype, which identifies the type of group whose attributes this dictionary describes and determines the format and meaning of the dictionary’s remaining entries. The only group subtype defined is Transparency'&gt;	&lt;required&gt;	^self objectAt: #S</body><body package="PDF XObjects">Type	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The type of PDF object that this dictionary describes.'&gt;	^self objectAt: #Type ifAbsent: [#Group asPDF]</body></methods><methods><class-id>Graphics.PDF.TextMarkup</class-id> <category>accessing entries</category><body package="PDF Interactive Features">QuadPoints	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of 8 × n numbers specifying the coordinates of nquadrilaterals in default user space.Each quadrilateral shall encompasses a word or group of contiguous words in the text underlying the annotation.The coordinates for each quadrilateral shall be given in the order	x1 y1 x2 y2 x3 y3 x4 y4specifying the quadrilateral’s four vertices in counterclockwise order.The text shall be oriented with respect to the edge connecting points (x1, y1) and (x2, y2).The annotation dictionary’s AP entry, if present, shall take precedence over QuadPoints.'&gt;	^self objectAt: #QuadPoints ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.Font</class-id> <category>accessing entries</category><body package="PDF Fonts">Subtype	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The type of font'&gt;	^self objectAt: #Subtype</body></methods><methods><class-id>Graphics.PDF.OptionalContentGroup</class-id> <category>accessing entries</category><body package="PDF Data Structures">Intent	&lt;type: #Name&gt;	&lt;typeArrayOf: #Name&gt;	&lt;attribute: 2 documentation: 'A single intent name or an array containing any combination of names.PDF defines two names, View and Design, that may indicate the intended use of the graphics in the group.A conforming reader may choose to use only groups that have a specific intent and ignore others'&gt;	^self objectAt: #Intent ifAbsent: [#View asPDF]</body><body package="PDF Data Structures">Name	&lt;type: #Textstring&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The name of the optional content group, suitable for presentation in a reader’s user interface'&gt;	^self objectAt: #Name</body><body package="PDF Data Structures">Usage	&lt;type: #OptionalContentUsage&gt;	&lt;attribute: 3 documentation: 'A usage dictionary describing the nature of the content controlled by the group.It may be used by features that automatically control the state of the group based on outside factors'&gt;	^self objectAt: #Usage ifAbsent: [Dictionary empty]</body></methods><methods><class-id>Graphics.PDF.NameTree</class-id> <category>accessing entries</category><body package="PDF Data Structures">Limits	&lt;typeArrayOf: #String&gt;	&lt;attribute: 1 documentation: 'Shall be an array of two strings, that shall specify the (lexically) least and greatest keys included in the Names array of a leaf node or in the Names arrays of any leaf nodes that are descendants of an intermediate node.'&gt;	^self objectAt: #Limits ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.NameTreeNode</class-id> <category>accessing entries</category><body package="PDF Data Structures">Kids	&lt;typeArrayOf: #NameTree&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: '(Root and intermediate nodes only; present in the root node if and only if Names is not present)Shall be an array of indirect references to the immediate children of this node. The children may be intermediate or leaf nodes.'&gt;	^self objectAt: #Kids</body></methods><methods><class-id>Graphics.PDF.SpecialColourSpace</class-id> <category>accessing entries</category><body package="PDF Colour">name	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The name of the colour space type.'&gt;	^self objectAt: 1</body></methods><methods><class-id>Graphics.PDF.Separation</class-id> <category>accessing entries</category><body package="PDF Colour">alternateSpace	&lt;type: #DeviceColourSpace&gt;	&lt;type: #CIEColourSpace&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'The alternateSpace parameter shall be an array or name object that identifies the alternate colour space, which may be any device or CIE-based colour space but may not be another special colour space (Pattern, Indexed, Separation, or DeviceN)'&gt;	^self objectAt: 3</body><body package="PDF Colour">tintName	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The name parameter is a name object that shall specify the name of the colorant that this Separation colour space is intended to represent (or one of the special names All or None).Such colorant names are arbitrary, and there may be any number of them, subject to implementation limits.'&gt;	^self objectAt: 2</body><body package="PDF Colour">tintTransform	&lt;type: #Function&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'The tintTransform parameter shall be a function.During subsequent painting operations, a conforming reader calls this function to transform a tint value into colour component values in the alternate colour space.The function shall be called with the tint value and shall return the corresponding colour component values.That is, the number of components and the interpretation of their values shall depend on the alternate colour space'&gt;	^self objectAt: 4</body></methods><methods><class-id>Graphics.PDF.MovieActivation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">Duration	&lt;type: #Integer&gt;	&lt;type: #String&gt;	&lt;type: #PDFArray&gt;	&lt;attribute: 2 documentation: 'The duration of the movie segment to be played, that shall be specified in the same form as Start.If this entry is omitted, the movie shall be played to the end.'&gt;	^self objectAt: #Duration ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">FWPosition	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 9 documentation: 'For floating play windows, the relative position of the window on the screen.The value shall be an array of two numbers	[horiz vert]each in the range 0.0 to 1.0, denoting the relative horizontal and vertical position of the movie window with respect to the screen.	EXAMPLE	The value [0.5 0.5] centers the window on the screen.'&gt;	^self objectAt: #FWPosition ifAbsent: [#(0.5 0.5) asPDF]</body><body package="PDF Interactive Features">FWScale	&lt;typeArrayOf: #Integer&gt;	&lt;attribute: 8 documentation: 'The magnification (zoom) factor at which the movie shall be played.The presence of this entry implies that the movie shall be played in a floating window.If the entry is absent, the movie shall be played in the annotation rectangle.The value of the entry shall be an array of two positive integers, [numerator denominator], denoting a rational magnification factor for the movie.The final window size, in pixels, shall be	(numerator ÷ denominator) × Aspectwhere the value of Aspect shall be taken from the movie dictionary.'&gt;	^self objectAt: #FWScale ifAbsent: [#(1 1) asPDF]</body><body package="PDF Interactive Features">Mode	&lt;type: #Name&gt;	&lt;attribute: 6 documentation: 'The play mode for playing the movie:	Once			Play once and stop.	Open			Play and leave the movie controller bar open.	Repeat			Play repeatedly from beginning to end until stopped.	Palindrome	Play continuously forward and backward until stopped.'&gt;	^self objectAt: #Mode ifAbsent: [#Once asPDF]</body><body package="PDF Interactive Features">Rate	&lt;type: #Number&gt;	&lt;attribute: 3 documentation: 'The initial speed at which to play the movie.If the value of this entry is negative, the movie shall be played backward with respect to Start and Duration.'&gt;	^self objectAt: #Rate ifAbsent: [1.0 asPDF]</body><body package="PDF Interactive Features">ShowControls	&lt;type: #Boolean&gt;	&lt;attribute: 5 documentation: 'A flag specifying whether to display a movie controller bar while playing the movie.'&gt;	^self objectAt: #ShowControls ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">Start	&lt;type: #Integer&gt;	&lt;type: #String&gt;	&lt;type: #PDFArray&gt;	&lt;attribute: 1 documentation: 'The starting time of the movie segment to be played.Movie time values shall be expressed in units of time based on a time scale, which defines the number of units per second.The default time scale shall be defined in the movie data.The starting time shall be nominally a non-negative 64-bit integer, specified as follows:	•	If it is representable as an integer (subject to the implementation limit for integers, as described in Annex C), it shall be specified as such.	•	If it is not representable as an integer, it shall be specified as an 8-byte string representing a 64-bit twos-complement integer, most significant byte first.	•	If it is expressed in a time scale different from that of the movie itself, it shall be represented as an array of two values: an integer or byte string denoting the starting time, followed by an integer specifying the time scale in units per second.If this entry is omitted, the movie shall be played from the beginning.'&gt;	^self objectAt: #Start ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">Synchronous	&lt;type: #Boolean&gt;	&lt;attribute: 7 documentation: 'A flag specifying whether to play the movie synchronously or asynchronously.If this value is true, the movie player shall retain control until the movie is completed or dismissed by the user.If the value is false, the player shall return control to the conforming reader immediately after starting the movie.'&gt;	^self objectAt: #Synchronous ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">Volume	&lt;type: #Number&gt;	&lt;attribute: 4 documentation: 'The initial sound volume at which to play the movie, in the range −1.0 to 1.0.Higher values shall denote greater volume; negative values shall mute the sound. Default value: 1.0.'&gt;	^self objectAt: #Volume ifAbsent: [1.0 asPDF]</body></methods><methods><class-id>Graphics.PDF.NumberTree</class-id> <category>accessing entries</category><body package="PDF Data Structures">Limits	&lt;typeArrayOf: #Integer&gt;	&lt;attribute: 1 documentation: '(Shall be present in Intermediate and leaf nodes only)Shall be an array of two integers, that shall specify the (numerically) least and greatest keys included in the Nums array of a leaf node or in the Nums arrays of any leaf nodes that are descendants of an intermediate node.'&gt;	^self objectAt: #Limits ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.CIEColourSpace</class-id> <category>accessing entries</category><body package="PDF Colour">name	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The name of the colour space type.'&gt;	^self objectAt: 1</body></methods><methods><class-id>Graphics.PDF.TypedStream</class-id> <category>accessing entries</category><body package="PDF Streams">Type	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The type of PDF object that this dictionary describes.The value of the Type entry can almost always be inferred from context.The value of an entry in a page''s font resource dictionary, for example, shall be a font object;therefore, the Type entry in a font dictionary serves primarily as documentation and as information for error checking.The Type entry shall not be required unless so stated in its description; however, if the entry is present, it shall have the correct value.In addition, the value of the Type entry in any dictionary, even in private data, shall be either a name defined in this standard or a registered name.'&gt;	^self objectAt: #Type</body></methods><methods><class-id>Graphics.PDF.XObject</class-id> <category>accessing entries</category><body package="PDF XObjects">Subtype	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The type of XObject that this dictionary describes.'&gt;	^self objectAt: #Subtype ifAbsent: [nil]</body></methods><methods><class-id>Graphics.PDF.FormXObject</class-id> <category>accessing entries</category><body package="PDF XObjects">BBox	&lt;type: #Rectangle&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'An array of four numbers in the form coordinate system, giving the coordinates of the left, bottom, right, and top edges, respectively, of the form XObject’s bounding box. These boundaries shall be used to clip the form XObject and to determine its size for caching.'&gt;	^self objectAt: #BBox</body><body package="PDF XObjects">FormType	&lt;type: #Integer&gt;	&lt;attribute: 1 documentation: 'A code identifying the type of form XObject that this dictionary describes. The only valid value is 1.'&gt;	^self objectAt: #FormType ifAbsent: [1 asPDF]</body><body package="PDF XObjects">Group	&lt;type: #GroupAttributes&gt;	&lt;version: 4&gt;	&lt;attribute: 5 documentation: 'A group attributes dictionary indicating that the contents of the form XObject shall be treated as a group and specifying the attributes of that group.If a Ref entry is present, the group attributes shall also apply to the external page imported by that entry, which allows such an imported page to be treated as a group without further modification.'&gt;	^self objectAt: #Group</body><body package="PDF XObjects">LastModified	&lt;type: #Date&gt;	&lt;requiredIf: #PieceInfo&gt;	&lt;version: 3&gt;	&lt;attribute: 9 documentation: 'The date and time when the form XObject’s contents were most recently modified. If a page-piece dictionary (PieceInfo) is present, the modification date shall be used to ascertain which of the application data dictionaries it contains correspond to the current content of the form.'&gt;	^self objectAt: #LastModified ifAbsent: [nil asPDF]</body><body package="PDF XObjects">Matrix	&lt;type: #Matrix&gt;	&lt;attribute: 3 documentation: 'An array of six numbers specifying the form matrix, which maps form space into user space.'&gt;	^self objectAt: #Matrix ifAbsent: [Matrix identity]</body><body package="PDF XObjects">Metadata	&lt;type: #Stream&gt;	&lt;version: 4&gt;	&lt;attribute: 7 documentation: 'A metadata stream containing metadata for the form XObject.'&gt;	^self objectAt: #Metadata</body><body package="PDF XObjects">Name	&lt;type: #Name&gt;	&lt;attribute: 14 documentation: '(Required in PDF 1.0; optional otherwise) The name by which this form XObject is referenced in the XObject subdictionary of the current resource dictionary.NOTE	This entry is obsolescent and its use is no longer recommended.'&gt;	^self objectAt: #Name</body><body package="PDF XObjects">OC	&lt;type: #Dictionary&gt;	&lt;version: 5&gt;	&lt;attribute: 13 documentation: 'An optional content group or optional content membership dictionary specifying the optional content properties for the form XObject. Before the form is processed, its visibility shall be determined based on this entry. If it is determined to be invisible, the entire form shall be skipped, as if there were no Do operator to invoke it.'&gt;	^self objectAt: #OC ifAbsent: [Dictionary empty]</body><body package="PDF XObjects">OPI	&lt;type: #Dictionary&gt;	&lt;version: 2&gt;	&lt;attribute: 12 documentation: 'An OPI version dictionary for the form XObject.'&gt;	^self objectAt: #OPI ifAbsent: [Dictionary empty]</body><body package="PDF XObjects">PieceInfo	&lt;typeDictionaryOf: #PieceInfo&gt;	&lt;version: 3&gt;	&lt;attribute: 8 documentation: 'A page-piece dictionary associated with the form XObject.'&gt;	^self objectAt: #PieceInfo</body><body package="PDF XObjects">Ref	&lt;type: #Dictionary&gt;	&lt;version: 4&gt;	&lt;attribute: 6 documentation: 'A reference dictionary identifying a page to be imported from another PDF file, and for which the form XObject serves as a proxy.'&gt;	^self objectAt: #Ref ifAbsent: [Dictionary empty]</body><body package="PDF XObjects">Resources	&lt;type: #Resources&gt;	&lt;version: 2&gt;	&lt;attribute: 4 documentation: '(Optional but strongly recommended) A dictionary specifying any resources (such as fonts and images) required by the form XObject.In a PDF whose version is 1.1 and earlier, all named resources used in the form XObject shall be included in the resource dictionary of each page object on which the form XObject appears, regardless of whether they also appear in the resource dictionary of the form XObject. These resources should also be specified in the form XObject’s resource dictionary as well, to determine which resources are used inside the form XObject. If a resource is included in both dictionaries, it shall have the same name in both locations.In PDF 1.2 and later versions, form XObjects may be independent of the content streams in which they appear, and this is strongly recommended although not required. In an independent form XObject, the resource dictionary of the form XObject is required and shall contain all named resources used by the form XObject. These resources shall not be promoted to the outer content stream’s resource dictionary, although that stream’s resource dictionary refers to the form XObject.'&gt;	^self objectAt: #Resources ifAbsent: [Resources new]</body><body package="PDF XObjects">StructParent	&lt;type: #Integer&gt;	&lt;version: 3&gt;	&lt;attribute: 10 documentation: '(Required if the form XObject is a structural content item)The integer key of the form XObject’s entry in the structural parent tree.'&gt;	^self objectAt: #StructParent</body><body package="PDF XObjects">StructParents	&lt;type: #Integer&gt;	&lt;version: 3&gt;	&lt;attribute: 11 documentation: '(Required if the form XObject contains marked-content sequences that are structural content items) The integer key of the form XObject’s entry in the structural parent tree.At most one of the entries StructParent or StructParents shall bepresent. A form XObject shall be either a content item in its entirety or a container for marked-content sequences that are content items, but not both.'&gt;	^self objectAt: #StructParents</body></methods><methods><class-id>Graphics.PDF.PieceInfo</class-id> <category>accessing entries</category><body package="PDF Document">LastModified	&lt;type: #Date&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The date and time when the contents of the document, page, or form were most recently modified by this conforming product.'&gt;	^self objectAt: #LastModified</body><body package="PDF Document">Private	&lt;type: #Dictionary&gt;	&lt;attribute: 2 documentation: 'Any private data appropriate to the conforming product, typically in the form of a dictionary.'&gt;	^self objectAt: #Private ifAbsent: [Dictionary empty]</body></methods><methods><class-id>Graphics.CmykColor class</class-id> <category>specification</category><body package="PDF Colour">localSpecification	&lt;optional: #name class: #{String} default: 'String new'&gt;	&lt;constant: #cyan class: #{Number}&gt;	&lt;constant: #magenta class: #{Number}&gt;	&lt;constant: #yellow class: #{Number}&gt;	&lt;constant: #black class: #{Number}&gt;	&lt;optional: #rgb class: #{ByteArray} default: 'self computedRGB'&gt;</body></methods><methods><class-id>Graphics.PDF.LineJoin class</class-id> <category>specification</category><body package="PDF Graphics">localSpecification	&lt;constant: #value class: #{Core.Integer}&gt;</body></methods><methods><class-id>Graphics.PDF.CIDSystemInfo</class-id> <category>accessing entries</category><body package="PDF Fonts">Ordering	&lt;type: #AsciiString&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A string that uniquely names the character collection within the specified registry'&gt;	^self objectAt: #Ordering</body><body package="PDF Fonts">Registry	&lt;type: #AsciiString&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'A string identifying the issuer of the character collection.For information about assigning a registry identifier, contact the Adobe Solutions Network or consult the ASN Web site.'&gt;	^self objectAt: #Registry</body><body package="PDF Fonts">Supplement	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'The supplement number of the character collection. An original character collection has a supplement number of 0. Whenever additional CIDs are assigned in a character collection, the supplement number shall be increased. Supplements shall not alter the ordering of existing CIDs in the character collection. This value shall not be used in determining compatibility between character collections'&gt;	^self objectAt: #Supplement</body></methods><methods><class-id>Graphics.PDF.Type3</class-id> <category>accessing entries</category><body package="PDF Fonts">CharProcs	&lt;type: #Dictionary&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'A dictionary in which each key shall be a glyph name and the value associated with that key shall be a content stream that constructs and paints the glyph for that character.The stream shallinclude as its first operator either d0 or d1, followed by operators describing one or more graphics objects, which may include path, text, or image objects.'&gt;	^self objectAt: #CharProcs</body><body package="PDF Fonts">Encoding	&lt;type: #Name&gt;	&lt;type: #Dictionary&gt;	&lt;required&gt;	&lt;attribute: 5 documentation: 'An encoding dictionary whose Differences array shall specify the complete character encoding for this font.'&gt;	^self objectAt: #Encoding</body><body package="PDF Fonts">FirstChar	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 6 documentation: 'The first character code defined in the font’s Widths array.'&gt;	^self objectAt: #FirstChar</body><body package="PDF Fonts">FontBBox	&lt;type: #Rectangle&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A rectangle expressed in the glyph coordinate system, specifying the font bounding box.This is the smallest rectangle enclosing the shape that would result if all of the glyphs of the font were placed with their origins coincident and then filled.If all four elements of the rectangle are zero, a conforming reader shall make no assumptions about glyph sizes based on the font bounding box.If any element is nonzero, the font bounding box shall be accurate.If any glyph’s marks fall outside this bounding box, incorrect behavior may result.'&gt;	^self objectAt: #FontBBox</body><body package="PDF Fonts">FontDescriptor	&lt;typeIndirect: #FontDescriptor&gt;	&lt;attribute: 9 documentation: '(Required in Tagged PDF documents; shall be an indirect reference)A font descriptor describing the font’s default metrics other than its glyph widths.'&gt;	^self objectAt: #FontDescriptor</body><body package="PDF Fonts">FontMatrix	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'An array of six numbers specifying the font matrix, mapping glyph space to text space.NOTE	A common practice is to define glyphs in terms of a 1000-unit glyph coordinate system, in which case the font matrix is [0.001 0 0 0.001 0 0].'&gt;	^self objectAt: #FontMatrix</body><body package="PDF Fonts">LastChar	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 7 documentation: 'The last character code defined in the font’s Widths array.'&gt;	^self objectAt: #LastChar</body><body package="PDF Fonts">Name	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: '(Required in PDF 1.0; optional otherwise)The name by which this font is referenced in the Font subdictionary of the current resource dictionary.This entry is obsolete and should not be used.'&gt;	^self objectAt: #Name</body><body package="PDF Fonts">Resources	&lt;type: #Resources&gt;	&lt;version: 2&gt;	&lt;attribute: 10 documentation: '(Optional but should be used)A list of the named resources, such as fonts and images, required by the glyph descriptions in this font.If any glyph descriptions refer to named resources but this dictionary is absent, the names shall be looked up in the resource dictionary of the page on which the font is used.'&gt;	^self objectAt: #Resources ifAbsent: [Resources new]</body><body package="PDF Fonts">ToUnicode	&lt;type: #Stream&gt;	&lt;version: 2&gt;	&lt;attribute: 11 documentation: 'A stream containing a CMap file that maps character codes to Unicode values.'&gt;	^self objectAt: #ToUnicode</body><body package="PDF Fonts">Widths	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 8 documentation: '(should be an indirect reference)An array of (LastChar − FirstChar + 1) widths, each element being the glyph width for the character code that equals FirstChar plus the array index.For character codes outside the range FirstChar to LastChar, the width shall be 0.These widths shall be interpreted in glyph space as specified by FontMatrix (unlike the widths of a Type 1 font, which are in thousandths of a unit of text space).If FontMatrix specifies a rotation, only the horizontal component of the transformed width shall be used.That is, the resulting displacement shall be horizontal in text space, as is the case for all simple fonts.'&gt;	^self objectAt: #Widths</body></methods><methods><class-id>Graphics.PDF.CrossReference class</class-id> <category>specification</category><body package="PDF Files">localSpecification	&lt;constant: #value class: #{Core.Integer} comment: 'offset or object number. 10-digit number in PDF'&gt;	&lt;constant: #number class: #{Core.Integer} comment: 'the object number'&gt;	&lt;constant: #generation class: #{Core.Integer} comment: 'generation number. 5-digit number in PDF'&gt;</body></methods><methods><class-id>Graphics.PDF.SoundAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">Name	&lt;type: #Name&gt;	&lt;attribute: 2 documentation: 'The name of an icon that shall be used in displaying the annotation.Conforming readers shall provide predefined icon appearances for at least the standard names Speaker and Mic.Additional names may be supported as well.The annotation dictionary’s AP entry, if present, shall take precedence over the Name entry.'&gt;	^self objectAt: #Name ifAbsent: [#Speaker asPDF]</body><body package="PDF Interactive Features">Sound	&lt;type: #Sound&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'A sound object defining the sound that shall be played when the annotation is activated.'&gt;	^self objectAt: #Sound</body></methods><methods><class-id>Graphics.PDF.Trailer</class-id> <category>accessing entries</category><body package="PDF Files">Encrypt	&lt;type: #Encryption&gt;	&lt;version: 1&gt;	&lt;attribute: 4 documentation: '(Required if document is encrypted)The document’s encryption dictionary.'&gt;	^self objectAt: #Encrypt ifAbsent: [Dictionary new]</body><body package="PDF Files">ID	&lt;type: #FileIdentifier&gt;	&lt;requiredIf: #Encrypt&gt;	&lt;version: 1&gt;	&lt;attribute: 6 documentation: 'An array of two byte-strings constituting a file identifier for the file.If there is an Encrypt entry this array and the two byte-strings shall be direct objects and shall be unencrypted.NOTE 1	Because the ID entries are not encrypted it is possible to check the ID key to assure that the correct file is being accessed without decrypting the file.	The restrictions that the string be a direct object and not be encrypted assure that this is possible.NOTE 2	Although this entry is optional, its absence might prevent the file from functioning in some workflows that depend on files being uniquely identified.NOTE 3	The values of the ID strings are used as input to the encryption algorithm.	If these strings were indirect, or if the ID array were indirect, these strings would be encrypted when written.	This would result in a circular condition for a reader: the ID strings must be decrypted in order to use them to decrypt strings, including the ID strings themselves.	The preceding restriction prevents this circular condition.'&gt;	^self objectAt: #ID ifAbsent: [#() asPDF]</body><body package="PDF Files">Info	&lt;typeIndirect: #DocumentInformation&gt;	&lt;attribute: 5 documentation: 'The document’s information dictionary.'&gt;	^self objectAt: #Info ifAbsent: [Dictionary new]</body><body package="PDF Files">Prev	&lt;typeDirect: #Integer&gt;	&lt;attribute: 2 documentation: '(Present only if the file has more than one cross-reference section)The byte offset in the decoded stream from the beginning of the file to the beginning of the previous cross-reference section.*** there is a typo in the spec, I think: according to the spec the value should be indirect ***'&gt;	^self objectAt: #Prev ifAbsent: [nil asPDF]</body><body package="PDF Files">Root	&lt;typeIndirect: #Catalog&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'The catalog dictionary for the PDF document contained in the file.'&gt;	^self objectAt: #Root</body><body package="PDF Files">Size	&lt;typeDirect: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The total number of entries in the file’s cross-reference table, as defined by the combination of the original section and all update sections.Equivalently, this value shall be 1 greater than the highest object number defined in the file.Any object in a cross-reference section whose number is greater than this value shall be ignored and defined to be missing by a conforming reader.'&gt;	^self objectAt: #Size</body><body package="PDF Files">XRefStm	&lt;type: #Integer&gt;	&lt;attribute: 7 documentation: 'The byte offset in the decoded stream from the beginning of the file of a cross-reference stream.'&gt;	&lt;version: 5&gt;	^self objectAt: #XRefStm ifAbsent: [nil asPDF]</body></methods><methods><class-id>Graphics.PDF.Type1</class-id> <category>accessing entries</category><body package="PDF Fonts">BaseFont	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The PostScript name of the font.For Type 1 fonts, this is always the value of the FontName entry in the font program.The PostScript name of the font may be used to find the font program in the conforming reader or its environment.It is also the name that is used when printing to a PostScript output device.'&gt;	^self objectAt: #BaseFont</body><body package="PDF Fonts">Encoding	&lt;type: #Name&gt;	&lt;type: #Encoding&gt;	&lt;attribute: 7 documentation: 'A specification of the font’s character encoding if different from its built-in encoding.The value of Encoding shall be either the name of a predefined encoding (	MacRomanEncoding, 	MacExpertEncoding, or 	WinAnsiEncoding) or an encoding dictionary that shall specify differences from the font’s built-in encoding or from a specified predefined encoding.'&gt;	^self objectAt: #Encoding</body><body package="PDF Fonts">FirstChar	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'The first character code defined in the font’s Widths array.Beginning with PDF 1.5, the special treatment given to the standard 14 fonts is deprecated.Conforming writers should represent all fonts using a complete font descriptor.For backwards capability, conforming readers shall still provide the special treatment identified for the standard 14 fonts.'&gt;	^self objectAt: #FirstChar</body><body package="PDF Fonts">FontDescriptor	&lt;typeIndirect: #FontDescriptor&gt;	&lt;required&gt;	&lt;attribute: 6 documentation: 'A font descriptor describing the font’s metrics other than its glyph widths (see 9.8, "Font Descriptors"”\).For the standard 14 fonts, the entries FirstChar, LastChar, Widths, and FontDescriptor shall either all be present or all be absent.Ordinarily, these dictionary keys may be absent; specifying them enables a standard font to be overridden.Beginning with PDF 1.5, the special treatment given to the standard 14 fonts is deprecated.Conforming writers should represent all fonts using a complete font descriptor.For backwards capability, conforming readers shall still provide the special treatment identified for the standard 14 fonts.'&gt;	^self objectAt: #FontDescriptor</body><body package="PDF Fonts">LastChar	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'The last character code defined in the font’s Widths array.Beginning with PDF 1.5, the special treatment given to the standard 14 fonts is deprecated.Conforming writers should represent all fonts using a complete font descriptor.For backwards capability, conforming readers shall still provide the special treatment identified for the standard 14 fonts.'&gt;	^self objectAt: #LastChar</body><body package="PDF Fonts">Name	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: '(Required in PDF 1.0; optional otherwise)The name by which this font is referenced in the Font subdictionary of the current resource dictionary.This entry is obsolete and should not be used.'&gt;	^self objectAt: #Name</body><body package="PDF Fonts">ToUnicode	&lt;type: #Stream&gt;	&lt;version: 2&gt;	&lt;attribute: 8 documentation: 'A stream containing a CMap file that maps character codes to Unicode values.'&gt;	^self objectAt: #ToUnicode</body><body package="PDF Fonts">Widths	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 5 documentation: '(indirect reference preferred)An array of (LastChar - FirstChar + 1) widths, each element being the glyph width for the character code that equals FirstChar plus the array index.For character codes outside the range FirstChar to LastChar, the value of MissingWidth from the FontDescriptor entry for this font shall be used.The glyph widths shall be measured in units in which 1000 units correspond to 1 unit in text space.These widths shall be consistent with the actual widths given in the font program.Beginning with PDF 1.5, the special treatment given to the standard 14 fonts is deprecated.Conforming writers should represent all fonts using a complete font descriptor.For backwards capability, conforming readers shall still provide the special treatment identified for the standard 14 fonts.'&gt;	^self objectAt: #Widths</body></methods><methods><class-id>Graphics.PDF.ShadingStream</class-id> <category>accessing entries</category><body package="PDF Shading">AntiAlias	&lt;type: #Boolean&gt;	&lt;attribute: 5 documentation: 'A flag indicating whether to filter the shading function to prevent aliasing artifacts.NOTE	The shading operators sample shading functions at a rate determined by the resolution of the output device.Aliasing can occur if the function is not smooth—that is, if it has a high spatial frequency relative to the sampling rate.Anti-aliasing can be computationally expensive and is usually unnecessary, since most shading functions are smooth enough or are sampled at a high enough frequency to avoid aliasing effects.Anti-aliasing may not be implemented on some output devices, in which case this flag is ignored.'&gt;	^self objectAt: #AntiAlias ifAbsent: [false asPDF]</body><body package="PDF Shading">BBox	&lt;type: #Rectangle&gt;	&lt;attribute: 4 documentation: 'An array of four numbers giving the left, bottom, right, and top coordinates, respectively, of the shading’s bounding box.The coordinates shall be interpreted in the shading’s target coordinate space.If present, this bounding box shall be applied as a temporary clipping boundary when the shading is painted, in addition to the current clipping path and any other clipping boundaries in effect at that time.'&gt;	^self objectAt: #BBox ifAbsent: [Rectangle new]</body><body package="PDF Shading">Background	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 3 documentation: 'An array of colour components appropriate to the colour space, specifying a single background colour value.If present, this colour shall be used, before any painting operation involving the shading, to fill those portions of the area to be painted that lie outside the bounds of the shading object.NOTE	In the opaque imaging model, the effect is as if the painting operation were performed twice: first with the background colour and then with the shading.NOTE	The background colour is applied only when the shading is used as part of a shading pattern, not when it is painted directly with the sh operator.'&gt;	^self objectAt: #Background ifAbsent: [#() asPDF]</body><body package="PDF Shading">BitsPerComponent	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 7 documentation: 'The number of bits used to represent each colour component. The value shall be 1, 2, 4, 8, 12, or 16.'&gt;	^self objectAt: #BitsPerComponent</body><body package="PDF Shading">BitsPerCoordinate	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 6 documentation: 'The number of bits used to represent each vertex coordinate. The value shall be 1, 2, 4, 8, 12, 16, 24, or 32.'&gt;	^self objectAt: #BitsPerCoordinate</body><body package="PDF Shading">ColorSpace	&lt;type: #ColorSpace&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The colour space in which colour values shall be expressed. This may be any device, CIE-based, or special colour space except a Pattern space.'&gt;	^self objectAt: #ColorSpace</body><body package="PDF Shading">Decode	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 8 documentation: 'An array of numbers specifying how to map vertex coordinates and colour components into the appropriate ranges of values.The decoding method is similar to that used in image dictionaries.The ranges shall bespecified as follows:	[xmin xmax ymin ymax c1,min c1,max … cn,min cn,max]Only one pair of c values shall be specified if a Function entry is present.'&gt;	^self objectAt: #Decode</body><body package="PDF Shading">Function	&lt;type: #Function&gt;	&lt;attribute: 9 documentation: 'A 1-in, n-out function or an array of n 1-in, 1-out functions (where n is the number of colour components in the shading dictionary’s colour space).If this entry is present, the colour data for each vertex shall be specified by a single parametric variable rather than by n separate colour components.The designated function(s) shall be called with each interpolated value of the parametric variable to determine the actual colour at each point.Each input value shall be forced into the range interval specified for the corresponding colour component in the shading dictionary’s Decode array.Each function’s domain shall be a superset of that interval.If the value returned by the function for a given colour component is out of range, it shall be adjusted to the nearest valid value.This entry shall not be used with an Indexed colour space.'&gt;	^self objectAt: #Function ifAbsent: [nil asPDF]</body><body package="PDF Shading">ShadingType	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The shading type:1 Function-based shading2 Axial shading3 Radial shading4 Free-form Gouraud-shaded triangle mesh5 Lattice-form Gouraud-shaded triangle mesh6 Coons patch mesh7 Tensor-product patch mesh'&gt;	^self objectAt: #ShadingType</body></methods><methods><class-id>Graphics.PDF.FreeFormGouraudShadedMesh</class-id> <category>accessing entries</category><body package="PDF Shading">BitsPerFlag	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The number of bits used to represent the edge flag for each vertex.The value of BitsPerFlag shall be 2, 4, or 8, but only the least significant 2 bits in each flag value shall beused.The value for the edge flag shall be 0, 1, or 2.'&gt;	^self objectAt: #BitsPerFlag</body></methods><methods><class-id>Graphics.PDF.TrapNetAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">AnnotStates	&lt;typeArrayOf: #Name&gt;	&lt;attribute: 3 documentation: '(Required if Version is present; shall be absent if LastModified is present)An array of name objects representing the appearance states (value of the AS entry) for annotations associated with the page.The appearance states shall be listed in the same order as the annotations in the page’s Annots array.For an annotation with no AS entry, the corresponding array element should be null.No appearance state shall be included for the trap network annotation itself.'&gt;	^self objectAt: #AnnotStates ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">FontFauxing	&lt;typeArrayOf: #Font&gt;	&lt;attribute: 4 documentation: 'An array of font dictionaries representing fonts that were fauxed (replaced by substitute fonts) during the generation of trap networks for the page.'&gt;	^self objectAt: #FontFauxing ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">LastModified	&lt;type: #Date&gt;	&lt;version: 4&gt;	&lt;attribute: 1 documentation: '(Required if Version and AnnotStates are absent; shall be absent if Version and AnnotStates are present)The date and time when the trap network was most recently modified.'&gt;	^self objectAt: #LastModified ifAbsent: [nil asPDF]</body><body package="PDF Interactive Features">Version	&lt;type: #PDFArray&gt;	&lt;attribute: 2 documentation: '(Required if AnnotStates is present; shall be absent if LastModifiedis present)An unordered array of all objects present in the page description at the time the trap networks were generated and that, if changed, could affect the appearance of the page. If present, the array shall include the following objects:	•	All content streams identified in the page object’s Contents entry	•	All resource objects (other than procedure sets) in the page’s resource dictionary	•	All resource objects (other than procedure sets) in the resource dictionaries of any form XObjects on the page	•	All OPI dictionaries associated with XObjects on the page'&gt;	^self objectAt: #Version ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.FunctionDictionary</class-id> <category>accessing entries</category><body package="PDF Data Structures">Domain	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'An array of 2 x m numbers, where m shall be the number of input values.For each i from 0 to m-1, Domain2i shall be less than or equal to Domain2i+1, and the ith input value, xi, shall lie in the interval Domain2i &lt;= xi &lt;= Domain2i+1.Input values outside the declared domain shall be clipped to the nearest boundary value.'&gt;	^self objectAt: #Domain</body><body package="PDF Data Structures">FunctionType	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The function type:	0 Sampled function	2 Exponential interpolation function	3 Stitching function	4 PostScript calculator function'&gt;	^self objectAt: #FunctionType</body><body package="PDF Data Structures">Range	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 3 documentation: '(Required for type 0 and type 4 functions, optional otherwise)An array of 2 x n numbers, where n shall be the number of output values.For each j from 0 to n-1, Range2j shall be less than or equal to Range2j+1, and the jth output value, yj , shall lie in the interval Range2j &lt;= yj &lt;= Range2j+1.Output values outside the declared range shall be clipped to the nearest boundary value.If this entry is absent, no clipping shall be done.'&gt;	^self objectAt: #Range ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.Catalog</class-id> <category>accessing entries</category><body package="PDF Document">AA	&lt;type: #Dictionary&gt;	&lt;version: 4&gt;	&lt;attribute: 14 documentation: 'An additional-actions dictionary defining the actions that shall be taken in response to various trigger events affecting the document as a whole.'&gt;	^self objectAt: #AA ifAbsent: [Dictionary empty]</body><body package="PDF Document">AcroForm	&lt;type: #Dictionary&gt;	&lt;version: 2&gt;	&lt;attribute: 16 documentation: 'The document’s interactive form (AcroForm) dictionary.'&gt;	^self objectAt: #AcroForm ifAbsent: [Dictionary empty]</body><body package="PDF Document">Collection	&lt;type: #Dictionary&gt;	&lt;version: 7&gt;	&lt;attribute: 28 documentation: 'A collection dictionary that a conforming reader shall use to enhance the presentation of file attachments stored in the PDF document.'&gt;	^self objectAt: #Collection ifAbsent: [Dictionary empty]</body><body package="PDF Document">Dests	&lt;typeIndirect: #Dictionary&gt;	&lt;version: 1&gt;	&lt;attribute: 7 documentation: 'A dictionary of names and corresponding destinations.'&gt;	^self objectAt: #Dests ifAbsent: [Dictionary empty]</body><body package="PDF Document">Extensions	&lt;type: #Dictionary&gt;	&lt;version: 7&gt;	&lt;attribute: 3 documentation: '(ISO 32000)An extensions dictionary containing developer prefix identification and version numbers for developer extensions that occur in this document.'&gt;	^self objectAt: #Extensions ifAbsent: [Dictionary empty]</body><body package="PDF Document">Lang	&lt;type: #Textstring&gt;	&lt;version: 4&gt;	&lt;attribute: 20 documentation: 'A language identifier that shall specify the natural language for all text in the documentexcept where overridden by language specifications for structure elements or marked content. If this entry is absent, the language shall be considered unknown.'&gt;	^self objectAt: #Lang ifAbsent: [Textstring empty]</body><body package="PDF Document">Legal	&lt;type: #Dictionary&gt;	&lt;version: 5&gt;	&lt;attribute: 26 documentation: 'A dictionary that shall contain attestations regarding the content of a PDF document, as it relates to the legality of digital signatures.'&gt;	^self objectAt: #Legal ifAbsent: [Dictionary empty]</body><body package="PDF Document">MarkInfo	&lt;type: #Dictionary&gt;	&lt;version: 4&gt;	&lt;attribute: 19 documentation: 'A mark information dictionary that shall contain information about the document’s usage of Tagged PDF conventions.'&gt;	^self objectAt: #MarkInfo ifAbsent: [Dictionary empty]</body><body package="PDF Document">Metadata	&lt;typeIndirect: #Metadata&gt;	&lt;version: 4&gt;	&lt;attribute: 17 documentation: 'A metadata stream that shall contain metadata for the document.'&gt;	^self objectAt: #Metadata ifAbsent: [nil asPDF]</body><body package="PDF Document">Names	&lt;type: #Names&gt;	&lt;version: 2&gt;	&lt;attribute: 6 documentation: 'The document’s name dictionary (see Name).'&gt;	^self objectAt: #Names ifAbsent: [Dictionary new]</body><body package="PDF Document">NeedsRendering	&lt;type: #Boolean&gt;	&lt;version: 7&gt;	&lt;attribute: 29 documentation: 'A flag used to expedite the display of PDF documents containing XFA forms.It specifies whether the document shall be regenerated when the document is first opened.See the XML Forms Architecture (XFA) Specification.Default value: false.'&gt;	^self objectAt: #NeedsRendering ifAbsent: [false asPDF]</body><body package="PDF Document">OCProperties	&lt;type: #OptionalContentProperties&gt;	&lt;version: 5&gt;	&lt;attribute: 24 documentation: '(required if a document contains optional content)The document’s optional content properties dictionary.'&gt;	^self objectAt: #OCProperties ifAbsent: [Dictionary new]</body><body package="PDF Document">OpenAction	&lt;type: #PDFArray&gt;	&lt;type: #Dictionary&gt;	&lt;version: 1&gt;	&lt;attribute: 13 documentation: 'A value specifying a destination that shall be displayed or an action that shall be performed when the document is opened.The value shall be either an array defining a destination or an action dictionary representing an action.If this entry is absent, the document shall be opened to the top of the first page at the default magnification factor.'&gt;	^self objectAt: #OpenAction ifAbsent: [#() asPDF]</body><body package="PDF Document">Outlines	&lt;typeIndirect: #Outlines&gt;	&lt;attribute: 11 documentation: 'The outline dictionary that shall be the root of the document’s outline hierarchy.'&gt;	^self objectAt: #Outlines ifAbsent: [Dictionary empty]</body><body package="PDF Document">OutputIntents	&lt;typeArrayOf: #OutputIntent&gt;	&lt;version: 4&gt;	&lt;attribute: 22 documentation: 'An array of output intent dictionaries that shall specify the colour characteristics of output devices on which the document might be rendered.'&gt;	^self objectAt: #OutputIntents ifAbsent: [#() asPDF]</body><body package="PDF Document">PageLabels	&lt;type: #NumberTree&gt;	&lt;version: 3&gt;	&lt;attribute: 5 documentation: 'A number tree (see NumberTree) defining the page labelling for the document.The keys in this tree shall be page indices; the corresponding values shall be page label dictionaries.Each page index shall denote the first page in a labelling range to which the specified page label dictionary applies.The tree shall include a value for page index 0.'&gt;	^self objectAt: #PageLabels ifAbsent: [nil asPDF]</body><body package="PDF Document">PageLayout	&lt;type: #Name&gt;	&lt;version: 5 ifValue: #TwoPageLeft&gt;	&lt;version: 5 ifValue: #TwoPageRight&gt;	&lt;attribute: 9 documentation: 'A name object specifying the page layout shall be used when the document is opened:	SinglePage			Display one page at a time	OneColumn			Display the pages in one column	TwoColumnLeft		Display the pages in two columns, with odd-numbered pages on the left	TwoColumnRight	Display the pages in two columns, with odd-numbered pages on the right	TwoPageLeft		Display the pages two at a time, with odd-numbered pages on the left	TwoPageRight		Display the pages two at a time, with odd-numbered pages on the rightDefault value: SinglePage.'&gt;	^self objectAt: #PageLayout ifAbsent: [#SinglePage asPDF]</body><body package="PDF Document">PageMode	&lt;type: #Name&gt;	&lt;version: 5 ifValue: #UseOC&gt;	&lt;version: 6 ifValue: #UseAttachments&gt;	&lt;attribute: 10 documentation: 'A name object specifying how the document shall be displayed when opened:	UseNone			Neither document outline nor thumbnail images visible	UseOutlines			Document outline visible	UseThumbs			Thumbnail images visible	FullScreen			Full-screen mode, with no menu bar, window controls, or any other window visible	UseOC				Optional content group panel visible	UseAttachments	Attachments panel visibleDefault value: UseNone.'&gt;	^self objectAt: #PageMode ifAbsent: [#UseNone asPDF]</body><body package="PDF Document">Pages	&lt;typeIndirect: #Pages&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'The page tree node that shall be the root of the document’s page tree.'&gt;	^self objectAt: #Pages</body><body package="PDF Document">Perms	&lt;type: #Dictionary&gt;	&lt;version: 5&gt;	&lt;attribute: 25 documentation: 'A permissions dictionary that shall specify user access permissions for the document.'&gt;	^self objectAt: #Perms ifAbsent: [Dictionary empty]</body><body package="PDF Document">PieceInfo	&lt;typeDictionaryOf: #PieceInfo&gt;	&lt;version: 4&gt;	&lt;attribute: 23 documentation: 'A page-piece dictionary associated with the document.'&gt;	^self objectAt: #PieceInfo ifAbsent: [Dictionary new]</body><body package="PDF Document">Requirements	&lt;typeArrayOf: #Dictionary&gt;	&lt;version: 7&gt;	&lt;attribute: 27 documentation: 'An array of requirement dictionaries that shall represent requirements for the document.'&gt;	^self objectAt: #Requirements ifAbsent: [#() asPDF]</body><body package="PDF Document">SpiderInfo	&lt;type: #Dictionary&gt;	&lt;version: 3&gt;	&lt;attribute: 21 documentation: 'A Web Capture information dictionary that shall contain state information used by any Web Capture extension.'&gt;	^self objectAt: #SpiderInfo ifAbsent: [Dictionary empty]</body><body package="PDF Document">StructTreeRoot	&lt;type: #Dictionary&gt;	&lt;version: 3&gt;	&lt;attribute: 18 documentation: 'The document’s structure tree root dictionary.'&gt;	^self objectAt: #StructTreeRoot ifAbsent: [Dictionary empty]</body><body package="PDF Document">Threads	&lt;typeArrayOf: #Dictionary&gt;	&lt;version: 1&gt;	&lt;attribute: 12 documentation: 'An array of thread dictionaries that shall represent the document’s article threads.'&gt;	^self objectAt: #Threads ifAbsent: [#() asPDF]</body><body package="PDF Document">URI	&lt;type: #Dictionary&gt;	&lt;version: 1&gt;	&lt;attribute: 15 documentation: 'A URI dictionary containing document-level information for URI (uniform resource identifier) actions.'&gt;	^self objectAt: #URI ifAbsent: [Dictionary empty]</body><body package="PDF Document">Version	&lt;type: #Name&gt;	&lt;version: 4&gt;	&lt;attribute: 2 documentation: 'The version of the PDF specification to which the document conforms (for example, 1.4) if later than the version specified in the file’s header (see Header).If the header specifies a later version, or if this entry is absent, the document shall conform to the version specified in the header.This entry enables a conforming writer to update the version using an incremental update.The value of this entry shall be a name object, not a number, and therefore shall be preceded by a SOLIDUS (2Fh) character (/) when written in the PDF file (for example, /1.4).'&gt;	^self objectAt: #Version ifAbsent: [nil asPDF]</body><body package="PDF Document">ViewerPreferences	&lt;type: #ViewerPreferences&gt;	&lt;version: 2&gt;	&lt;attribute: 8 documentation: 'A viewer preferences dictionary specifying the way the document shall be displayed on the screen.If this entry is absent, conforming readers shall use their own current user preference settings.'&gt;	^self objectAt: #ViewerPreferences ifAbsent: [Dictionary empty]</body></methods><methods><class-id>Graphics.PDF.Encryption</class-id> <category>accessing entries</category><body package="PDF Files">CF	&lt;type: #Dictionary&gt;	&lt;version: 5&gt;	&lt;attribute: 5 documentation: '(meaningful only when the value of V is 4)A dictionary whose keys shall be crypt filter names and whose values shall be the corresponding crypt filter dictionaries.Every crypt filter used in the document shall have an entry in this dictionary, except for the standard crypt filter names.The conforming reader shall ignore entries in CF dictionary with the keys equal to those listed in Table 26 and use properties of the respective standard crypt filters.'&gt;	^self objectAt: #CF ifAbsent: [Dictionary empty]</body><body package="PDF Files">EFF	&lt;type: #Name&gt;	&lt;version: 6&gt;	&lt;attribute: 8 documentation: '(meaningful only when the value of V is 4)The name of the crypt filter that shall be used when encrypting embedded file streams that do not have their own crypt filter specifier; it shall correspond to a key in the CFdictionary or a standard crypt filter name.This entry shall be provided by the security handler.Conforming writers shall respect this value when encrypting embedded files, except for embedded file streams that have their own crypt filter specifier.If this entry is not present, and the embedded file stream does not contain a crypt filter specifier, the stream shall be encrypted using the default stream crypt filter specified by StmF.'&gt;	^self objectAt: #EFF ifAbsent: [#Identity asPDF]</body><body package="PDF Files">Filter	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The name of the preferred security handler for this document.It shall be the name of the security handler that was used to encrypt the document.If SubFilter is not present, only this security handler shall be used when opening the document.If it is present, a conforming reader can use any security handler that implements the format specified by SubFilter.Standard shall be the name of the built-in password-based security handler.Names for other security handlers may be registered.'&gt;	^self objectAt: #Filter</body><body package="PDF Files">Length	&lt;type: #Integer&gt;	&lt;version: 4&gt;	&lt;attribute: 4 documentation: 'The length of the encryption key, in bits.The value shall be a multiple of 8, in the range 40 to 128.Default value: 40.'&gt;	^self objectAt: #Length ifAbsent: [40 asPDF]</body><body package="PDF Files">StmF	&lt;type: #Name&gt;	&lt;version: 5&gt;	&lt;attribute: 6 documentation: '(meaningful only when the value of V is 4)The name of the crypt filter that shall be used by default when decrypting streams.The name shall be a key in the CF dictionary or a standard crypt filter name.All streams in the document, except for cross-reference streams or streams that have a Crypt entry in their Filterarray, shall be decrypted by the security handler, using this crypt filter.Default value: Identity.'&gt;	^self objectAt: #StmF ifAbsent: [#Identity asPDF]</body><body package="PDF Files">StrF	&lt;type: #Name&gt;	&lt;version: 5&gt;	&lt;attribute: 7 documentation: '(meaningful only when the value of V is 4)The name of the crypt filter that shall be used when decrypting all strings in the document.The name shall be a key in the CF dictionary or a standard crypt filter name.Default value: Identity.'&gt;	^self objectAt: #StrF ifAbsent: [#Identity asPDF]</body><body package="PDF Files">SubFilter	&lt;type: #Name&gt;	&lt;version: 3&gt;	&lt;attribute: 2 documentation: 'A name that completely specifies the format and interpretation of the contents of the encryption dictionary.It allows security handlers other than the one specified by Filter to decrypt the document.If this entry is absent, other security handlers shall not decrypt the document.NOTEThis entry was introduced in PDF 1.3 to support the use of public-key cryptography in PDF files;however, it was not incorporated into the PDF Reference until the fourth edition (PDF 1.5).'&gt;	^self objectAt: #SubFilter ifAbsent: [nil asPDF]</body><body package="PDF Files">V	&lt;type: #Integer&gt;	&lt;version: 4 ifValue: 2&gt;	&lt;version: 4 ifValue: 3&gt;	&lt;version: 5 ifValue: 4&gt;	&lt;attribute: 3 documentation: 'A code specifying the algorithm to be used in encrypting and decrypting the document:	0	An algorithm that is undocumented. This value shall not be used.	1	"Algorithm 1: Encryption of data using the RC4 or AES algorithms" in 7.6.2, "General Encryption Algorithm," with an encryption key length of 40 bits.	2	(PDF 1.4) "Algorithm 1: Encryption of data using the RC4 or AES algorithms"in 7.6.2, "General Encryption Algorithm," but permitting encryption key lengths greater than 40 bits.	3	(PDF 1.4) An unpublished algorithm that permits encryption key lengths ranging from 40 to 128 bits. This value shall not appear in a conforming PDF file.	4	(PDF 1.5) The security handler defines the use of encryption and decryption in the document, using the rules specified by the CF, StmF, and StrF entries.The default value if this entry is omitted shall be 0, but when present should be a value of 1 or greater.'&gt;	^self objectAt: #V ifAbsent: [0 asPDF]</body></methods><methods><class-id>Graphics.PDF.PolygonPolyline</class-id> <category>accessing entries</category><body package="PDF Interactive Features">BS	&lt;type: #BorderStyle&gt;	&lt;attribute: 2 documentation: 'A border style dictionary specifying the width and dash pattern that shall be used in drawing the line.The annotation dictionary’s AP entry, if present, shall take precedence over the Vertices and BS entries.'&gt;	^self objectAt: #BS ifAbsent: [BorderStyle empty]</body><body package="PDF Interactive Features">IC	&lt;typeArrayOf: #Number&gt;	&lt;version: 4&gt;	&lt;attribute: 3 documentation: 'An array of numbers that shall be in the range 0.0 to 1.0 and shall specify the interior color with which to fill the annotation’s line endings.The number of array elements determines the colour space in which the colour shall be defined:	0	No colour; transparent	1	DeviceGray	3	DeviceRGB	4	DeviceCMYK'&gt;	^self objectAt: #IC ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">IT	&lt;type: #Name&gt;	&lt;version: 6&gt;	&lt;attribute: 4 documentation: 'A name that shall describe the intent of the polygon or polyline annotation.The following values shall bevalid:	PolygonCloud						The annotation is intended to function as a cloud object.	PolyLineDimension 	(PDF 1.7) 	The polyline annotation is intended to function as a dimension.	PolygonDimension 	(PDF 1.7) 	The polygon annotation is intended to function as a dimension.'&gt;	^self objectAt: #IT ifAbsent: [nil asPDF]</body><body package="PDF Interactive Features">Measure	&lt;type: #Dictionary&gt;	&lt;version: 7&gt;	&lt;attribute: 5 documentation: 'A measure dictionary that shall specify the scale and units that apply to the annotation.'&gt;	^self objectAt: #Measure ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">Vertices	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of numbers specifying the width and dash pattern that shall represent the alternating horizontal and vertical coordinates, respectively, of each vertex, in default user space.'&gt;	^self objectAt: #Vertices ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.PolyLineAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">LE	&lt;typeArrayOf: #Name&gt;	&lt;attribute: 1 documentation: 'An array of two names that shall specify the line ending styles.The first and second elements of the array shall specify the line ending styles for the endpoints defined, respectively, by the first and last pairs of coordinates in the Vertices array.The possible values are:	/Square /Circle /Diamond /OpenArrow /ClosedArrow /None /Butt /ROpenArrow /RClosedArrow /Slash.'&gt;	^self objectAt: #LE ifAbsent: [#(#None #None) asPDF]</body></methods><methods><class-id>Graphics.PDF.ExplicitDestination</class-id> <category>accessing entries</category><body package="PDF Interactive Features">page	&lt;typeIndirect: #Page&gt;	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'a page object (except in a remote go-to action where it is a page number)'&gt;	^self objectAt: 1</body><body package="PDF Interactive Features">parameter1	&lt;type: #Number&gt;	&lt;type: #Null&gt;	&lt;attribute: 3 documentation: 'the first parameter (meaning depends on style)'&gt;	^self objectAt: 3</body><body package="PDF Interactive Features">parameter2	&lt;type: #Number&gt;	&lt;type: #Null&gt;	&lt;attribute: 4 documentation: 'the second parameter (meaning depends on style)'&gt;	^self objectAt: 4</body><body package="PDF Interactive Features">parameter3	&lt;type: #Number&gt;	&lt;type: #Null&gt;	&lt;attribute: 5 documentation: 'the third parameter (meaning depends on style)'&gt;	^self objectAt: 5</body><body package="PDF Interactive Features">parameter4	&lt;type: #Number&gt;	&lt;type: #Null&gt;	&lt;attribute: 6 documentation: 'the fourth parameter (meaning depends on style)'&gt;	^self objectAt: 6</body><body package="PDF Interactive Features">style	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'the style in which the destination will be displayed.One of /XYZ /Fit /FitH /FitV /FitR /FitB /FitBH or /FitBV'&gt;	^self objectAt: 2</body></methods><methods><class-id>Graphics.PDF.Indexed</class-id> <category>accessing entries</category><body package="PDF Colour">base	&lt;type: #ColourSpace&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The base parameter shall be an array or name that identifies the base colour space in which the values in the colour table are to be interpreted.It shall be any device or CIE-based colour space or (PDF 1.3) a Separation or DeviceN space, but shall not be a Pattern space or another Indexed space.If the base colour space is DeviceRGB, the values in the colour table shall be interpreted as red, green, and blue components; if the base colour space is a CIE-based ABC space such as a CalRGB or Lab space, the values shall be interpreted as A, B, and C components.'&gt;	^self objectAt: 2</body><body package="PDF Colour">hival	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'The hival parameter shall be an integer that specifies the maximum valid index value.The colour table shall be indexed by integers in the range 0 to hival.hival shall be no greater than 255, which is the integer required to index a table with 8-bit index values.'&gt;	^self objectAt: 3</body><body package="PDF Colour">lookup	&lt;type: #Stream&gt;	&lt;type: #EncodedString&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'The colour table shall be defined by the lookup parameter, which may be either a stream or (PDF 1.2) a byte string.It shall provide the mapping between index values and the corresponding colours in the base colour space.'&gt;	^self objectAt: 4</body></methods><methods><class-id>Graphics.PDF.PageTree</class-id> <category>accessing entries</category><body package="PDF Document">CropBox	&lt;type: #Rectangle&gt;	&lt;inheritable&gt;	&lt;attribute: 4 documentation: 'A rectangle, expressed in default user space units,that shall define the visible region of default user space.When the page is displayed or printed, its contents shall be clipped (cropped) to this rectangleand then shall be imposed on the output medium in some implementation-defined manner.Default value: the value of MediaBox.'&gt;	^self objectAt: #CropBox inheritOr: [self MediaBox]</body><body package="PDF Document">MediaBox	&lt;type: #Rectangle&gt;	&lt;inheritable&gt;	&lt;attribute: 3 documentation: 'A rectangle, expressed in default user space units,that shall define the boundaries of the physical medium on which the page shall be displayed or printed.'&gt;	^self inherited: #MediaBox</body><body package="PDF Document">Parent	&lt;typeIndirect: #Pages&gt;	&lt;attribute: 1 documentation: '(Required except in root node; prohibited in the root node)	The page tree node that is the immediate parent of this one.'&gt;	^self objectAt: #Parent ifAbsent: [Dictionary empty]</body><body package="PDF Document">Resources	&lt;type: #Dictionary&gt;	&lt;inheritable&gt;	&lt;attribute: 2 documentation: 'A dictionary containing any resources required by the page.If the page requires no resources, the value of this entry shall be an empty dictionary.Omitting the entry entirely indicates that the resources shall be inherited from an ancestor node in the page tree.'&gt;	^self inherited: #Resources</body><body package="PDF Document">Rotate	&lt;type: #Integer&gt;	&lt;inheritable&gt;	&lt;attribute: 5 documentation: 'The number of degrees by which the page shall be rotated clockwise when displayed or printed.The value shall be a multiple of 90.'&gt;	^self objectAt: #Rotate inheritOr: [0 asPDF]</body></methods><methods><class-id>Graphics.PDF.Page</class-id> <category>accessing entries</category><body package="PDF Document">AA	&lt;type: #Dictionary&gt;	&lt;version: 2&gt;	&lt;attribute: 18 documentation: 'An additional-actions dictionary that shall define actions to be performed when the page is opened or closed.(PDF 1.3) additional-actions dictionaries are not inheritable.'&gt;	^self objectAt: #AA ifAbsent: [Dictionary empty]</body><body package="PDF Document">Annots	&lt;typeArrayOf: #Annot&gt;	&lt;attribute: 17 documentation: 'An array of annotation dictionaries that shall contain indirect references to all annotations associated with the page.'&gt;	^self objectAt: #Annots ifAbsent: [#() asPDF]</body><body package="PDF Document">ArtBox	&lt;type: #Rectangle&gt;	&lt;version: 3&gt;	&lt;attribute: 8 documentation: 'A rectangle, expressed in default user space units,that shall define the extent of the page’s meaningful content (including potential white space) as intended by the page’s creator.'&gt;	^self objectAt: #ArtBox ifAbsent: [self CropBox]</body><body package="PDF Document">B	&lt;typeArrayOf: #Reference&gt;	&lt;version: 1&gt;	&lt;attribute: 14 documentation: '(recommended if the page contains article beads)An array that shall contain indirect references to all article beads appearing on the page.The beads shall be listed in the array in natural reading order.NOTEThe information in this entry can be created or recreated from the information obtained from the Threads key in the Catalog.'&gt;	^self objectAt: #B ifAbsent: [#() asPDF]</body><body package="PDF Document">BleedBox	&lt;type: #Rectangle&gt;	&lt;version: 3&gt;	&lt;attribute: 6 documentation: 'A rectangle, expressed in default user space units,that shall define the region to which the contents of the page shall be clipped when output in a production environment.'&gt;	^self objectAt: #BleedBox ifAbsent: [self CropBox]</body><body package="PDF Document">BoxColorInfo	&lt;type: #Dictionary&gt;	&lt;version: 4&gt;	&lt;attribute: 9 documentation: 'A box colour information dictionary that shall specify the colours and other visual characteristics that should be used in displaying guidelines on the screen for the various page boundaries.If this entry is absent, the application shall use its own current default settings.'&gt;	^self objectAt: #BoxColorInfo ifAbsent: [Dictionary empty]</body><body package="PDF Document">Contents	&lt;type: #Contents&gt;	&lt;typeArrayOf: #Contents&gt;	&lt;attribute: 10 documentation: 'A content stream that shall describe the contents of this page.If this entry is absent, the page shall be empty.The value shall be either a single stream or an array of streams.If the value is an array, the effect shall be as if all of the streams in the array were concatenated, in order, to form a single stream.Conforming writers can create image objects and other resources as they occur, even though they interrupt the content stream. The division between streams may occur only at the boundaries between lexical tokens (see 7.2, "Lexical Conventions") but shall be unrelated to the page’s logical content or organization. Applications that consume or produce PDF files need not preserve the existing structure of the Contents array. Conforming writers shall not create a Contents array containing no elements.'&gt;	^self objectAt: #Contents ifAbsent: [nil asPDF]</body><body package="PDF Document">Dur	&lt;type: #Number&gt;	&lt;version: 1&gt;	&lt;attribute: 15 documentation: 'The page’s display duration (also called its advance timing):the maximum length of time, in seconds, that the page shall be displayed during presentations before the viewer application shall automatically advance to the next page.By default, the viewer shall not advance automatically.'&gt;	^self objectAt: #Dur ifAbsent: [nil asPDF]</body><body package="PDF Document">Group	&lt;type: #GroupAttributes&gt;	&lt;version: 4&gt;	&lt;attribute: 12 documentation: 'A group attributes dictionary that shall specify the attributes of the page’s page group for use in the transparent imaging model'&gt;	^self objectAt: #Group ifAbsent: [Dictionary new]</body><body package="PDF Document">ID	&lt;type: #String&gt;	&lt;version: 3&gt;	&lt;attribute: 22 documentation: '(indirect reference preferred)The digital identifier of the page’s parent Web Capture content set.'&gt;	^self objectAt: #ID ifAbsent: [nil asPDF]</body><body package="PDF Document">LastModified	&lt;type: #Date&gt;	&lt;requiredIf: #PieceInfo&gt;	&lt;version: 3&gt;	&lt;attribute: 2 documentation: 'The date and time when the page’s contents were most recently modified.If a page-piece dictionary (PieceInfo) is present, the modification date shall be used to ascertain which of the application data dictionaries that it contains correspond to the current content of the page.'&gt;	^self objectAt: #LastModified ifAbsent: [nil asPDF]</body><body package="PDF Document">MediaBox	&lt;type: #Rectangle&gt;	&lt;required&gt;	&lt;inheritable&gt;	&lt;attribute: 4 documentation: 'A rectangle, expressed in default user space units,that shall define the boundaries of the physical medium on which the page shall be displayed or printed.'&gt;	^self inherited: #MediaBox</body><body package="PDF Document">Metadata	&lt;type: #Metadata&gt;	&lt;version: 4&gt;	&lt;attribute: 19 documentation: 'A metadata stream that shall contain metadata for the page.'&gt;	^self objectAt: #Metadata ifAbsent: [nil asPDF]</body><body package="PDF Document">PZ	&lt;type: #Integer&gt;	&lt;version: 3&gt;	&lt;attribute: 23 documentation: 'The page’s preferred zoom (magnification) factor:the factor by which it shall be scaled to achieve the natural display magnification.'&gt;	^self objectAt: #PZ ifAbsent: [nil asPDF]</body><body package="PDF Document">Parent	&lt;typeIndirect: #Pages&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The page tree node that is the immediate parent of this page object.'&gt;	^self objectAt: #Parent</body><body package="PDF Document">PieceInfo	&lt;typeDictionaryOf: #PieceInfo&gt;	&lt;version: 3&gt;	&lt;attribute: 20 documentation: 'A page-piece dictionary associated with the page.'&gt;	^self objectAt: #PieceInfo ifAbsent: [Dictionary new]</body><body package="PDF Document">PresSteps	&lt;type: #Dictionary&gt;	&lt;version: 5&gt;	&lt;attribute: 27 documentation: 'A navigation node dictionary that shall represent the first node on the page.'&gt;	^self objectAt: #PresSteps ifAbsent: [Dictionary empty]</body><body package="PDF Document">Resources	&lt;type: #Resources&gt;	&lt;required&gt;	&lt;inheritable&gt;	&lt;attribute: 3 documentation: 'A dictionary containing any resources required by the page.If the page requires no resources, the value of this entry shall be an empty dictionary.Omitting the entry entirely indicates that the resources shall be inherited from an ancestor node in the page tree.'&gt;	^self inherited: #Resources</body><body package="PDF Document">SeparationInfo	&lt;type: #Dictionary&gt;	&lt;version: 3&gt;	&lt;attribute: 24 documentation: 'A separation dictionary that shall contain information needed to generate colour separations for the page.'&gt;	^self objectAt: #SeparationInfo ifAbsent: [Dictionary empty]</body><body package="PDF Document">StructParents	&lt;type: #Integer&gt;	&lt;version: 3&gt;	&lt;attribute: 21 documentation: 'The integer key of the page’s entry in the structural parent tree.'&gt;	^self objectAt: #StructParents ifAbsent: [nil asPDF]</body><body package="PDF Document">Tabs	&lt;type: #Name&gt;	&lt;version: 5&gt;	&lt;attribute: 25 documentation: 'A name specifying the tab order that shall be used for annotations on the page. The possible values shall be R (row order), C (column order), and S (structure order).'&gt;	^self objectAt: #Tabs ifAbsent: [nil asPDF]</body><body package="PDF Document">TemplateInstantiated	&lt;type: #Name&gt;	&lt;version: 5&gt;	&lt;attribute: 26 documentation: '(Required if this page was created from a named page object)The name of the originating page object.'&gt;	^self objectAt: #TemplateInstantiated ifAbsent: [nil asPDF]</body><body package="PDF Document">Thumb	&lt;type: #ImageXObject&gt;	&lt;attribute: 13 documentation: 'A stream object that shall define the page’s thumbnail image'&gt;	^self objectAt: #Thumb ifAbsent: [nil asPDF]</body><body package="PDF Document">Trans	&lt;type: #Dictionary&gt;	&lt;version: 1&gt;	&lt;attribute: 16 documentation: 'A transition dictionary describing the transition effect that shall be used when displaying the page during presentations.'&gt;	^self objectAt: #Trans ifAbsent: [Dictionary empty]</body><body package="PDF Document">TrimBox	&lt;type: #Rectangle&gt;	&lt;version: 3&gt;	&lt;attribute: 7 documentation: 'A rectangle, expressed in default user space units,that shall define the intended dimensions of the finished page after trimming.'&gt;	^self objectAt: #TrimBox ifAbsent: [self CropBox]</body><body package="PDF Document">UserUnit	&lt;type: #Number&gt;	&lt;version: 6&gt;	&lt;attribute: 28 documentation: 'A positive number that shall give the size of default user space units, in multiples of 1/72 inch.The range of supported values shall be implementation-dependent.Default value: 1.0 (user space unit is 1/72 inch).'&gt;	^self objectAt: #UserUnit ifAbsent: [1.0 asPDF]</body><body package="PDF Document">VP	&lt;type: #Dictionary&gt;	&lt;version: 6&gt;	&lt;attribute: 29 documentation: 'An array of viewport dictionaries that shall specify rectangular regions of the page.'&gt;	^self objectAt: #VP ifAbsent: [Dictionary empty]</body></methods><methods><class-id>Graphics.PDF.ThreeDActivation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">A	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'A name specifying the circumstances under which the annotation shall be activated.Valid values are:	PO	The annotation shall be activated as soon as the page containing the annotation is opened.	PV	The annotation shall be activated as soon as any part of the page containing the annotation becomes visible.	XA	The annotation shall remain inactive until explicitly activated by a script or user action.	NOTE 	At any one time, only a single page shall be considered open in a conforming reader, even though more than one page may be visible, depending on the page layout.Default value: XA.	NOTE 	For performance reasons, documents intended for viewing in a web browser should use explicit activation (XA).In non-interactive applications, such as printing systems or aggregating conforming reader, PO and PV indicate that the annotation shall be activated when the page is printed or placed; XA indicates that the annotation shall never be activated and the normal appearance shall be used.'&gt;	^self objectAt: #A ifAbsent: [#XA asPDF]</body><body package="PDF Interactive Features">AIS	&lt;type: #Name&gt;	&lt;attribute: 2 documentation: 'A name specifying the state of the artwork instance upon activation of the annotation.Valid values are:	I	The artwork shall be instantiated, but real-time script-driven animations shall be disabled.	L	Real-time script-driven animations shall be enabled if present; if not, the artwork shall be instantiated.	NOTE	In non-interactive conforming readers, the artwork shall be instantiated and scripts shall be disabled.'&gt;	^self objectAt: #AIS ifAbsent: [#L asPDF]</body><body package="PDF Interactive Features">D	&lt;type: #Name&gt;	&lt;attribute: 3 documentation: 'A name specifying the circumstances under which the annotation shall be deactivated.Valid values are:	PC	The annotation shall be deactivated as soon as the page is closed.	PI	The annotation shall be deactivated as soon as the page containing the annotation becomes invisible.	XD	The annotation shall remain active until explicitly deactivated by a script or user action.	NOTE	At any one time, only a single page shall be considered open in the conforming reader, even though more than one page may be visible, depending on the page layout.'&gt;	^self objectAt: #D ifAbsent: [#PI asPDF]</body><body package="PDF Interactive Features">DIS	&lt;type: #Name&gt;	&lt;attribute: 4 documentation: 'A name specifying the state of the artwork instance upon deactivation of the annotation.Valid values are U (uninstantiated), I(instantiated), and L (live).	NOTE	If the value of this entry is L, uninstantiation of instantiated artwork is necessary unless it has been modified. 			Uninstantiation is never required in non-interactive conforming readers.'&gt;	^self objectAt: #DIS ifAbsent: [#U asPDF]</body><body package="PDF Interactive Features">NP	&lt;type: #Boolean&gt;	&lt;version: 7&gt;	&lt;attribute: 6 documentation: 'A flag indicating the default behavior of the user interface for viewing or managing information about the 3D artwork.Such user interfaces can enable navigation to different views or can depict the hierarchy of the objects in the artwork (the model tree).If true, the user interface should be made visible when the annotation is activated.If false, the user interface should not be made visible by default.'&gt;	^self objectAt: #NP ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">TB	&lt;type: #Boolean&gt;	&lt;version: 7&gt;	&lt;attribute: 5 documentation: 'A flag indicating the default behavior of an interactive toolbar associated with this annotation.If true, a toolbar shall be displayed by default when the annotation is activated and given focus.If false, a toolbar shall not be displayed by default.	NOTE	Typically, a toolbar is positioned in proximity to the 3D annotation.'&gt;	^self objectAt: #TB ifAbsent: [true asPDF]</body></methods><methods><class-id>Graphics.PDF.DeviceNMixingHints</class-id> <category>accessing entries</category><body package="PDF Colour">DotGain	&lt;typeDictionaryOf: #Function&gt;	&lt;attribute: 3 documentation: 'A dictionary specifying the dot gain of inks that shall be used in blending calculations when used as an alternative to the tint transformation function.Dot gain (or loss) represents the amount by which a printer’s halftone dots change as the ink spreads and is absorbed by paper.For each entry, the key shall be a colorant name, and the value shall be a function that maps values in the range 0 to 1 to values in the range 0 to 1.The dictionary may list colorants unused by this specific DeviceNinstance and need not list all colorants.An entry with a key of Default shall specify a function to be used by all colorants for which a dot gain function is not explicitly specified.Conforming readers may ignore values in this dictionary when other sources of dot gain information are available, such as ICC profiles associated with the process colour space or tint transformation functions associated with individual colorants.'&gt;	^self objectAt: #DotGain ifAbsent: [Dictionary empty]</body><body package="PDF Colour">PrintingOrder	&lt;typeArrayOf: #Name&gt;	&lt;requiredIf: #Solidities&gt;	&lt;attribute: 2 documentation: 'An array of colorant names, specifying the order in which inks shall be laid down.Each component in the names array of the DeviceN colour space shall appear in this array (although the order is unrelated to the order specified in the namesarray).This entry may also list colorants unused by this specific DeviceN instance.'&gt;	^self objectAt: #PrintingOrder ifAbsent: [#() asPDF]</body><body package="PDF Colour">Solidities	&lt;typeDictionaryOf: #Number&gt;	&lt;attribute: 1 documentation: 'A dictionary specifying the solidity of inks that shall be used in blending calculations when used as an alternative to the tint transformation function. For each entry, the key shall be a colorantname, and the value shall be a number between 0.0 and 1.0.This dictionary need not contain entries for all colorants used in this colour space; it may also include additional colorants not used by this colour space.A value of 1.0 simulates an ink that completely covers the inks beneath; a value of 0.0 simulates a transparent ink that completely reveals the inks beneath.An entry with a key of Default specifies a value that shall be used by all components in the associated DeviceN colour space for which a solidity value is not explicitly provided.If Default is not present, the default value for unspecified colorants shall be 0.0; conforming readers may choose to use other values.If this entry is present, PrintingOrder shall also be present.'&gt;	^self objectAt: #Solidities ifAbsent: [Dictionary empty]</body></methods><methods><class-id>Graphics.PDF.CaretAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">RD	&lt;type: #Rectangle&gt;	&lt;attribute: 1 documentation: 'A set of four numbers that shall describe the numerical differences between two rectangles: the Rect entry of the annotation and the actual boundaries of the underlying caret.Such a difference can occur.When a paragraph symbol specified by Sy is displayed along with the caret.The four numbers shall correspond to the differences in default user space between the left, top, right, and bottom coordinates of Rect and those of the caret, respectively.Each value shall be greater than or equal to 0.The sum of the top and bottom differences shall be less than the height of Rect, and the sum of the left and right differences shall be less than the width of Rect.'&gt;	^self objectAt: #RD ifAbsent: [Rectangle new]</body><body package="PDF Interactive Features">Sy	&lt;type: #Name&gt;	&lt;attribute: 2 documentation: 'A name specifying a symbol that shall be associated with the caret:	P		A new paragraph symbol (¶) should be associated with the caret.	None	No symbol should be associated with the caret.'&gt;	^self objectAt: #Sy ifAbsent: [#None asPDF]</body></methods><methods><class-id>Graphics.PDF.CIDFont</class-id> <category>accessing entries</category><body package="PDF Fonts">BaseFont	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The PostScript name of the CIDFont.For Type 0 CIDFonts, this shall be the value of the CIDFontName entry in the CIDFont program.For Type 2 CIDFonts, it shall be derived the same way as for a simple TrueType font.In either case, the name may have a subset prefix if appropriate'&gt;	^self objectAt: #BaseFont</body><body package="PDF Fonts">CIDSystemInfo	&lt;type: #CIDSystemInfo&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A dictionary containing entries that define the character collection of the CIDFont'&gt;	^self objectAt: #CIDSystemInfo</body><body package="PDF Fonts">DW	&lt;type: #Integer&gt;	&lt;attribute: 4 documentation: 'The default width for glyphs in the CIDFont'&gt;	^self objectAt: #DW ifAbsent: [1000 asPDF]</body><body package="PDF Fonts">DW2	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 6 documentation: '(Optional; applies only to CIDFonts used for vertical writing)An array of two numbers specifying the default metrics for vertical writing'&gt;	^self objectAt: #DW2 ifAbsent: [#(880 -1000) asPDF]</body><body package="PDF Fonts">FontDescriptor	&lt;typeIndirect: #FontDescriptor&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'A font descriptor describing the CIDFont’s default metrics other than its glyph widths'&gt;	^self objectAt: #FontDescriptor</body><body package="PDF Fonts">W	&lt;type: #PDFArray&gt;	&lt;attribute: 5 documentation: 'A description of the widths for the glyphs in the CIDFont.NOTE	The array’s elements have a variable format that can specify individual widths for consecutive CIDs or one width for a range of CIDs.Default value: none (the DW value shall be used for all glyphs)'&gt;	^self objectAt: #W ifAbsent: [nil asPDF]</body><body package="PDF Fonts">W2	&lt;type: #PDFArray&gt;	&lt;attribute: 7 documentation: '(Optional; applies only to CIDFonts used for vertical writing)A description of the metrics for vertical writing for the glyphs in the CIDFont.Default value: none (the DW2 value shall be used for all glyphs)'&gt;	^self objectAt: #W2 ifAbsent: [nil asPDF]</body></methods><methods><class-id>Graphics.PDF.SquareCircle</class-id> <category>accessing entries</category><body package="PDF Interactive Features">BE	&lt;type: #BorderEffect&gt;	&lt;version: 5&gt;	&lt;attribute: 3 documentation: 'A border effect dictionary describing an effect applied to the border described by the BS entry.'&gt;	^self objectAt: #BE ifAbsent: [BorderEffect empty]</body><body package="PDF Interactive Features">BS	&lt;type: #BorderStyle&gt;	&lt;attribute: 1 documentation: 'A border style dictionary specifying the line width and dash pattern that shall be used in drawing the rectangle or ellipse.The annotation dictionary’s AP entry, if present, takes precedence over the Rect and BS entries.'&gt;	^self objectAt: #BS ifAbsent: [BorderStyle empty]</body><body package="PDF Interactive Features">IC	&lt;typeArrayOf: #Number&gt;	&lt;version: 4&gt;	&lt;attribute: 2 documentation: 'An array of numbers that shall be in the range 0.0 to 1.0 and shall specify the interior color with which to fill the annotation’s rectangle or ellipse.The number of array elements determines the colour space in which the colour shall be defined:	0	No colour; transparent	1	DeviceGray	3	DeviceRGB	4	DeviceCMYK'&gt;	^self objectAt: #IC ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">RD	&lt;type: #Rectangle&gt;	&lt;version: 5&gt;	&lt;attribute: 4 documentation: 'A set of four numbers that shall describe the numerical differences between two rectangles: the Rect entry of the annotation and the actual boundaries of the underlying square or circle.Such a difference may occur in situations where a border effect (described by BE) causes the size of the Rect to increase beyond that of the square or circle.The four numbers shall correspond to the differences in default user space between the left, top, right, and bottom coordinates of Rect and those of the square or circle, respectively.Each value shall be greater than or equal to 0.The sum of the top and bottom differences shall be less than the height of Rect, and the sum of the left and right differences shall be less than the width of Rect.'&gt;	^self objectAt: #RD ifAbsent: [Rectangle new]</body></methods><methods><class-id>Graphics.PDF.BorderStyle</class-id> <category>accessing entries</category><body package="PDF Interactive Features">D	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 4 documentation: 'A dash array defining a pattern of dashes and gaps that shall be used in drawing a dashed border (border style D in the S entry).The dash array shall be specified in the same format as in the line dash pattern parameter of the graphics state.The dash phase is not specified and shall be assumed to be 0.EXAMPLE A D entry of [3 2] specifies a border drawn with 3-point dashes alternating with 2-point gaps.'&gt;	^self objectAt: #D ifAbsent: [#(3) asPDF]</body><body package="PDF Interactive Features">S	&lt;type: #Name&gt;	&lt;attribute: 3 documentation: 'The border style:	S 	(Solid) A solid rectangle surrounding the annotation.	D 	(Dashed) A dashed rectangle surrounding the annotation. The dash pattern may be specified by the D entry.	B 	(Beveled) A simulated embossed rectangle that appears to be raised above the surface of the page.	I 	(Inset) A simulated engraved rectangle that appears to be recessed below the surface of the page.	U 	(Underline) A single line along the bottom of the annotation rectangle.A conforming reader shall tolerate other border styles that it does not recognize and shall use the default value.'&gt;	^self objectAt: #S ifAbsent: [#S asPDF]</body><body package="PDF Interactive Features">Type	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The type of PDF object that this dictionary describes.'&gt;	^self objectAt: #Type ifAbsent: [#Border asPDF]</body><body package="PDF Interactive Features">W	&lt;type: #Number&gt;	&lt;attribute: 2 documentation: 'The border width in points. If this value is 0, no border shall drawn.'&gt;	^self objectAt: #W ifAbsent: [1 asPDF]</body></methods><methods><class-id>Graphics.PDF.Outlines</class-id> <category>accessing entries</category><body package="PDF Interactive Features">Count	&lt;type: #Integer&gt;	&lt;attribute: 4 documentation: '(Required if the document has any open outline entries)Total number of visible outline items at all levels of the outline.The value cannot be negative.This entry shall be omitted if there are no open outline items.'&gt;	^self objectAt: #Count</body><body package="PDF Interactive Features">First	&lt;typeIndirect: #OutlineItem&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: '(Required if there are any open or closed outline entries)An outline item dictionary representing the first top-level item in the outline.'&gt;	^self objectAt: #First</body><body package="PDF Interactive Features">Last	&lt;typeIndirect: #OutlineItem&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: '(Required if there are any open or closed outline entries)An outline item dictionary representing the last top-level item in the outline.'&gt;	^self objectAt: #Last</body><body package="PDF Interactive Features">Type	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The type of PDF object that this dictionary describes.'&gt;	^self objectAt: #Type ifAbsent: [#Outlines asPDF]</body></methods><methods><class-id>Graphics.PDF.DeviceNColourSpaceAttributes</class-id> <category>accessing entries</category><body package="PDF Colour">Colorants	&lt;typeDictionaryOf: #Separation&gt;	&lt;attribute: 2 documentation: '(Required if Subtype is NChannel and the colour space includes spot colorants; otherwise optional)A dictionary describing the individual colorants that shall be used in the DeviceN colour space.For each entry in this dictionary, the key shall be a colorant name and the value shall be an array defining a Separation colour space for that colorant.The key shall match the colorant name given in that colour space.This dictionary provides information about the individual colorants that may be useful to some conforming readers.In particular, the alternate colour space and tint transformation function of a Separation colour space describe the appearance of that colorant alone, whereas those of a DeviceN colour space describe only the appearance of its colorants in combination.If Subtype is NChannel, this dictionary shall have entries for all spot colorants in this colour space.This dictionary may also include additional colorants not used by this colour space.'&gt;	^self objectAt: #Colorants ifAbsent: [Dictionary empty]</body><body package="PDF Colour">MixingHints	&lt;type: #Dictionary&gt;	&lt;version: 6&gt;	&lt;attribute: 3 documentation: 'A dictionary that specifies optional attributes of the inks that shall be used in blending calculations when used as an alternative to the tint transformation function.'&gt;	^self objectAt: #MixingHints ifAbsent: [Dictionary empty]</body><body package="PDF Colour">Process	&lt;type: #DeviceNProcessDictionary&gt;	&lt;version: 6&gt;	&lt;attribute: 3 documentation: '(Required if Subtype is NChannel and the colour space includes components of a process colour space, otherwise optional; PDF 1.6)A dictionary that describes the process colour space whose components are included in this colour space.'&gt;	^self objectAt: #Process ifAbsent: [Dictionary empty]</body><body package="PDF Colour">Subtype	&lt;type: #Name&gt;	&lt;version: 6&gt;	&lt;attribute: 1 documentation: 'A name specifying the preferred treatment for the colour space. Values shall be DeviceN or NChannel'&gt;	^self objectAt: #Subtype ifAbsent: [#DeviceN asPDF]</body></methods><methods><class-id>Graphics.PDF.XRefStream</class-id> <category>accessing entries</category><body package="PDF Files">ID	&lt;typeDirect: #FileIdentifier&gt;	&lt;version: 1&gt;	&lt;attribute: 7 documentation: 'An array of two byte-strings constituting a file identifier for the file.If there is an Encrypt entry this array and the two byte-strings shall be direct objects and shall be unencrypted.NOTE 1	Because the ID entries are not encrypted it is possible to check the ID key to assure that the correct file is being accessed without decrypting the file.	The restrictions that the string be a direct object and not be encrypted assure that this is possible.NOTE 2	Although this entry is optional, its absence might prevent the file from functioning in some workflows that depend on files being uniquely identified.NOTE 3	The values of the ID strings are used as input to the encryption algorithm.	If these strings were indirect, or if the ID array were indirect, these strings would be encrypted when written.	This would result in a circular condition for a reader: the ID strings must be decrypted in order to use them to decrypt strings, including the ID strings themselves.	The preceding restriction prevents this circular condition.'&gt;	^self objectAt: #ID ifAbsent: [#() asPDF]</body><body package="PDF Files">Index	&lt;typeArrayOf: #Integer&gt;	&lt;attribute: 2 documentation: 'An array containing a pair of integers for each subsection in this section.The first integer shall be the first object number in the subsection; the second integer shall be the number of entries in the subsectionThe array shall be sorted in ascending order by object number. Subsections cannot overlap; an object number may have at most one entry in a section.Default value: [0 Size].'&gt;	^self objectAt: #Index ifAbsent: [		(Array			with: 0			with: self Size) asPDF]</body><body package="PDF Files">Info	&lt;typeIndirect: #Dictionary&gt;	&lt;attribute: 6 documentation: 'The document’s information dictionary.'&gt;	^self objectAt: #Info ifAbsent: [Dictionary empty]</body><body package="PDF Files">Prev	&lt;type: #Integer&gt;	&lt;attribute: 3 documentation: '(Present only if the file has more than one cross-reference stream; not meaningful in hybrid-reference files)The byte offset in the decoded stream from the beginning of the file to the beginning of the previous cross-reference stream.This entry has the same function as the Prev entry in the trailer dictionary.'&gt;	^self objectAt: #Prev ifAbsent: [nil asPDF]</body><body package="PDF Files">Root	&lt;typeIndirect: #Catalog&gt;	&lt;required&gt;	&lt;attribute: 5 documentation: 'The catalog dictionary for the PDF document contained in the file.'&gt;	^self objectAt: #Root</body><body package="PDF Files">Size	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The number one greater than the highest object number used in this section or in any section for which this shall be an update.It shall be equivalent to the Size entry in a trailer dictionary.'&gt;	^self objectAt: #Size</body><body package="PDF Files">W	&lt;typeArrayOf: #Integer&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'An array of integers representing the size of the fields in a single cross-reference entry.For PDF 1.5, W always contains three integers; the value of each integer shall be the number of bytes (in the decoded stream) of the corresponding field.	EXAMPLE[1 2 1] means that the fields are one byte, two bytes, and one byte, respectively.A value of zero for an element in the W array indicates that the corresponding field shall not be present in the stream, and the default value shall be used, if there is one.If the first element is zero, the type field shall not be present, and shall default to type 1.The sum of the items shall be the total length of each entry; it can be used with the Index array to determine the starting position of each subsection.Different cross-reference streams in a PDF file may use different values for W.'&gt;	^self objectAt: #W</body></methods><methods><class-id>Graphics.PDF.String class</class-id> <category>specification</category><body package="PDF Basic Objects">localSpecification	&lt;optional: #encrypted class: #{Boolean} default: 'false' comment: 'true, iff the string is encrypted'&gt;</body></methods><methods><class-id>Graphics.PDF.LineCap class</class-id> <category>specification</category><body package="PDF Graphics">localSpecification	&lt;constant: #value class: #{Core.Integer}&gt;</body></methods><methods><class-id>Graphics.PDF.OptionalContentUsageCreatorInfo</class-id> <category>accessing entries</category><body package="PDF Data Structures">Creator	&lt;type: #Textstring&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'A text string specifying the application that created the group'&gt;	^self objectAt: #Creator</body><body package="PDF Data Structures">Subtype	&lt;type: #Name&gt;	&lt;attribute: 2 documentation: 'A name defining the type of content controlled by the group.Suggested values include but shall not be limited to Artwork, for graphic-design or publishing applications, and Technical, for technical designs such as building plans or schematics'&gt;	^self objectAt: #Subtype</body></methods><methods><class-id>Graphics.PDF.ScreenAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">A	&lt;type: #Action&gt;	&lt;attribute: 3 documentation: 'An action that shall be performed when the annotation is activated.'&gt;	^self objectAt: #A ifAbsent: [Action empty]</body><body package="PDF Interactive Features">AA	&lt;type: #Dictionary&gt;	&lt;attribute: 4 documentation: 'An additional-actions dictionary defining the screen annotation’s behaviour in response to various trigger events.'&gt;	^self objectAt: #AA ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">MK	&lt;type: #AppearanceCharacteristics&gt;	&lt;attribute: 2 documentation: 'An appearance characteristics dictionary.The I entry of this dictionary provides the icon used in generating the appearance referred to by the screen annotation’s AP entry.'&gt;	^self objectAt: #MK ifAbsent: [AppearanceCharacteristics empty]</body><body package="PDF Interactive Features">T	&lt;type: #Textstring&gt;	&lt;attribute: 1 documentation: 'The title of the screen annotation.'&gt;	^self objectAt: #T ifAbsent: [Textstring empty]</body></methods><methods><class-id>Graphics.PDF.Pathsegment class</class-id> <category>specification</category><body package="PDF Graphics">localSpecification	&lt;constant: #operator class: #{PathConstructionOperation}&gt;</body></methods><methods><class-id>Graphics.PDF.OptionalContentProperties</class-id> <category>accessing entries</category><body package="PDF Data Structures">Configs	&lt;typeArrayOf: #OptionalContentConfiguration&gt;	&lt;attribute: 3 documentation: 'An array of alternate optional content configuration dictionaries'&gt;	^self objectAt: #Configs ifAbsent: [#() asPDF]</body><body package="PDF Data Structures">D	&lt;type: #OptionalContentConfiguration&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The default viewing optional content configuration dictionary'&gt;	^self objectAt: #D</body><body package="PDF Data Structures">OCGs	&lt;typeArrayOf: #Reference&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of indirect references to all the optional content groups in the document, in any order.Every optional content group shall be included in this array'&gt;	^self objectAt: #OCGs</body></methods><methods><class-id>Graphics.PDF.InkAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">BS	&lt;type: #BorderStyle&gt;	&lt;attribute: 2 documentation: 'A border style dictionary specifying the line width and dash pattern that shall be used in drawing the paths.The annotation dictionary’s AP entry, if present, shall take precedence over the InkList and BS entries.'&gt;	^self objectAt: #BS ifAbsent: [BorderStyle empty]</body><body package="PDF Interactive Features">InkList	&lt;typeArrayOf: #PDFArray&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of n arrays, each representing a stroked path.Each array shall be a series of alternating horizontal and vertical coordinates in default user space, specifying points along the path.When drawn, the points shall be connected by straight lines or curves in an implementation-dependent way.'&gt;	^self objectAt: #InkList ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.GraphicsState</class-id> <category>accessing entries</category><body package="PDF Graphics">CTM	&lt;type: #Matrix&gt;	&lt;modifiedBy: #(#cm)&gt;	&lt;attribute: 1 documentation: 'The current transformation matrix, which maps positions from user coordinates to device coordinates. This matrix is modified by each application of the coordinate transformation operator, cm.'&gt;	^self objectAt: #CTM ifAbsent: [Matrix identity]</body><body package="PDF Graphics">alphaConstantNonstroking	&lt;type: #Number&gt;	&lt;version: 4&gt;	&lt;attribute: 26 documentation: 'The constant shape or constant opacity value to be used in the transparent imaging model. There are two separate alpha constant parameters: one for stroking and one for all other painting operations. A conforming reader shall implicitly reset this parameter to its initial value at the beginning of execution of a transparency group XObject.'&gt;	^self objectAt: #alphaConstantNonstroking ifAbsent: [1.0 asPDF]</body><body package="PDF Graphics">alphaConstantStroking	&lt;type: #Number&gt;	&lt;version: 4&gt;	&lt;attribute: 25 documentation: 'The constant shape or constant opacity value to be used in the transparent imaging model. There are two separate alpha constant parameters: one for stroking and one for all other painting operations. A conforming reader shall implicitly reset this parameter to its initial value at the beginning of execution of a transparency group XObject.'&gt;	^self objectAt: #alphaConstantStroking ifAbsent: [1.0 asPDF]</body><body package="PDF Graphics">alphaSource	&lt;type: #Boolean&gt;	&lt;version: 4&gt;	&lt;attribute: 27 documentation: 'A flag specifying whether the current soft mask and alpha constant parameters shall be interpreted as shape values (true) or opacity values (false). This flag also governs the interpretation of the SMask entry, if any, in an image dictionary.'&gt;	^self objectAt: #alphaSource ifAbsent: [false asPDF]</body><body package="PDF Graphics">blackGeneration	&lt;type: #Function&gt;	&lt;type: #Name&gt;	&lt;deviceDependent&gt;	&lt;version: 2&gt;	&lt;attribute: 31 documentation: 'A function that calculates the level of the black colour component to use when converting RGB colours to CMYK. Initial value: a conforming reader shall initialize this to a suitable device dependent value.'&gt;	^self objectAt: #blackGeneration ifAbsent: nil</body><body package="PDF Graphics">blendMode	&lt;type: #Name&gt;	&lt;typeArrayOf: #Name&gt;	&lt;version: 4&gt;	&lt;attribute: 23 documentation: 'The current blend mode to be used in the transparent imaging model. A conforming reader shall implicitly reset this parameter to its initial value at the beginning of execution of a transparency group XObject.'&gt;	^self objectAt: #blendMode ifAbsent: [#Normal asPDF]</body><body package="PDF Graphics">characterSpacing	&lt;type: #Number&gt;	&lt;attribute: 7 documentation: 'Set the character spacing, Tc, to charSpace, which shall be a number expressed in unscaled text space units.Character spacing shall be used by the Tj, TJ, and '' operators'&gt;	^self objectAt: #characterSpacing ifAbsent: [0 asPDF]</body><body package="PDF Graphics">clippingPath	&lt;attribute: 2 documentation: 'The current clipping path, which defines the boundary against which all output shall be cropped. Initial value: the boundary of the entire imageable portion of the output page.'&gt;	^self objectAt: #clippingPath ifAbsent: nil</body><body package="PDF Graphics">colorNonstroking	"&lt;type: #Color&gt;"	&lt;attribute: 6 documentation: 'The current colour to be used during painting operations. The type and interpretation of this parameter depend on the current colour space; for most colour spaces, a colour value consists of one to four numbers.'&gt;	^self objectAt: #colorNonstroking ifAbsent: [self colorSpaceNonstroking black]</body><body package="PDF Graphics">colorSpaceNonstroking	&lt;type: #Name&gt;	&lt;type: #PDFArray&gt;	&lt;attribute: 4 documentation: 'The current colour space in which colour values shall beinterpreted.'&gt;	^self objectAt: #colorSpaceNonstroking ifAbsent: [DeviceGray new]</body><body package="PDF Graphics">colorSpaceStroking	&lt;type: #Name&gt;	&lt;type: #PDFArray&gt;	&lt;attribute: 3 documentation: 'The current colour space in which colour values shall beinterpreted.'&gt;	^self objectAt: #colorSpaceStroking ifAbsent: [DeviceGray new]</body><body package="PDF Graphics">colorStroking	"&lt;type: #Color&gt;"	&lt;attribute: 5 documentation: 'The current colour to be used during painting operations. The type and interpretation of this parameter depend on the current colour space; for most colour spaces, a colour value consists of one to four numbers.'&gt;	^self objectAt: #colorStroking ifAbsent: [self colorSpaceStroking black]</body><body package="PDF Graphics">dashPattern	&lt;type: #Dash&gt;	&lt;modifiedBy: #(#d)&gt;	&lt;attribute: 20 documentation: 'A description of the dash pattern to be used when paths are stroked'&gt;	^self objectAt: #dashPattern ifAbsent: [Dash empty]</body><body package="PDF Graphics">flatness	&lt;type: #Number&gt;	&lt;deviceDependent&gt;	&lt;attribute: 35 documentation: 'The precision with which curves shall be rendered on the output device. The value of this parameter (positive number) gives the maximum error tolerance, measured in output device pixels; smaller numbers give smoother curves at the expense of more computation and memory use.'&gt;	^self objectAt: #flatness ifAbsent: [1.0 asPDF]</body><body package="PDF Graphics">halftone	&lt;type: #Dictionary&gt;	&lt;type: #Stream&gt;	&lt;type: #Name&gt;	&lt;deviceDependent&gt;	&lt;version: 2&gt;	&lt;attribute: 34 documentation: 'A halftone screen for gray and colour rendering, specified as a halftone dictionary or stream. Initial value: a conforming reader shall initialize this to a suitable device dependent value.'&gt;	^self objectAt: #halftone ifAbsent: nil</body><body package="PDF Graphics">horizontalScaling	&lt;type: #Number&gt;	&lt;attribute: 9 documentation: 'Set the horizontal scaling, Th, to (scale ÷ 100).scale shall be a number specifying the percentage of the normal width'&gt;	^self objectAt: #horizontalScaling ifAbsent: [100 asPDF]</body><body package="PDF Graphics">leading	&lt;type: #Number&gt;	&lt;attribute: 10 documentation: 'Set the text leading, Tl, to leading, which shall be a number expressed in unscaled text space units.Text leading shall be used only by the T*, '', and " operators'&gt;	^self objectAt: #leading ifAbsent: [0 asPDF]</body><body package="PDF Graphics">lineCap	&lt;type: #Integer&gt;	&lt;attribute: 17 documentation: 'A code specifying the shape of the endpoints for any open path that is stroked.'&gt;	^self objectAt: #lineCap ifAbsent: [LineCap butt value asPDF]</body><body package="PDF Graphics">lineJoin	&lt;type: #Integer&gt;	&lt;attribute: 18 documentation: 'A code specifying the shape of joints between connected segments of a stroked path.'&gt;	^self objectAt: #lineJoin ifAbsent: [LineJoin miter value asPDF]</body><body package="PDF Graphics">lineWidth	&lt;type: #Number&gt;	&lt;modifiedBy: #(#w)&gt;	&lt;attribute: 16 documentation: 'The thickness, in user space units, of paths to be stroked.'&gt;	^self objectAt: #lineWidth ifAbsent: [1.0 asPDF]</body><body package="PDF Graphics">miterLimit	&lt;type: #Number&gt;	&lt;attribute: 19 documentation: 'The maximum length of mitered line joins for stroked paths. This parameter limits the length of “spikes” produced when line segments join at sharp angles. Initial value: 10.0, for a miter cutoff below approximately 11.5 degrees.'&gt;	^self objectAt: #miterLimit ifAbsent: [10.0 asPDF]</body><body package="PDF Graphics">overprintMode	&lt;type: #Number&gt;	&lt;deviceDependent&gt;	&lt;version: 3&gt;	&lt;attribute: 30 documentation: 'A code specifying whether a colour component value of 0 in a DeviceCMYK colour space should erase that component (0) or leave it unchanged (1) when overprinting.'&gt;	^self objectAt: #overprintMode ifAbsent: [0 asPDF]</body><body package="PDF Graphics">overprintNonstroking	&lt;type: #Boolean&gt;	&lt;deviceDependent&gt;	&lt;version: 3&gt;	&lt;attribute: 29 documentation: 'A flag specifying (on output devices that support the overprint control feature) whether painting in one set of colorants should cause the corresponding areas of other colorants to be erased (false) or left unchanged (true).'&gt;	^self objectAt: #overprintNonstroking ifAbsent: [false asPDF]</body><body package="PDF Graphics">overprintStroking	&lt;type: #Boolean&gt;	&lt;deviceDependent&gt;	&lt;version: 3&gt;	&lt;attribute: 28 documentation: 'A flag specifying (on output devices that support the overprint control feature) whether painting in one set of colorants should cause the corresponding areas of other colorants to be erased (false) or left unchanged (true).'&gt;	^self objectAt: #overprintStroking ifAbsent: [false asPDF]</body><body package="PDF Graphics">renderingIntent	&lt;type: #Name&gt;	&lt;attribute: 21 documentation: 'The rendering intent to be used when converting CIE-based colours to device colours. Initial value: RelativeColorimetric.'&gt;	^self objectAt: #renderingIntent ifAbsent: [#RelativeColorimetric asPDF]</body><body package="PDF Graphics">smoothness	&lt;type: #Number&gt;	&lt;deviceDependent&gt;	&lt;version: 3&gt;	&lt;attribute: 36 documentation: 'The precision with which colour gradients are to be rendered on the output device. The value of this parameter (0 to 1.0) gives the maximum error tolerance, expressed as a fraction of the range of each colour component; smaller numbers give smoother colour transitions at the expense of more computation and memory use. Initial value: a conforming reader shall initialize this to a suitable device dependent value.'&gt;	^self objectAt: #smoothness ifAbsent: nil</body><body package="PDF Graphics">softMask	&lt;type: #Name&gt;	&lt;type: #Dictionary&gt;	&lt;version: 4&gt;	&lt;attribute: 24 documentation: 'A soft-mask dictionary specifying the mask shape or mask opacity values to be used in the transparent imaging model, or the name None if no such mask is specified. A conforming reader shall implicitly reset this parameter to its initial value at the beginning of execution of a transparency group XObject.'&gt;	^self objectAt: #softMask ifAbsent: [#None asPDF]</body><body package="PDF Graphics">strokeAdjustment	&lt;type: #Boolean&gt;	&lt;version: 2&gt;	&lt;attribute: 22 documentation: 'A flag specifying whether to compensate for possible rasterization effects when stroking a path with a line width that is small relative to the pixel resolution of the output device.NOTEThis is considered a device-independent parameter, even though the details of its effects are device-dependent.'&gt;	^self objectAt: #strokeAdjustment ifAbsent: [false asPDF]</body><body package="PDF Graphics">textFont	&lt;type: #Name&gt;	&lt;attribute: 11 documentation: 'Set the text font, Tf, to font.font shall be the name of a font resource in the Font subdictionary of the current resource dictionary.There is no initial value for font; it shall be specified explicitly by using Tf before any text is shown'&gt;	^self objectAt: #textFont ifAbsent: nil</body><body package="PDF Graphics">textFontSize	&lt;type: #Number&gt;	&lt;attribute: 12 documentation: 'Set the text font size, Tfs, to size.size shall be a number representing a scale factor.There is no initial value for size; it shall be specified explicitly by using Tf before any text is shown'&gt;	^self objectAt: #textFontSize ifAbsent: nil</body><body package="PDF Graphics">textKnockout	&lt;type: #Boolean&gt;	&lt;version: 4&gt;	&lt;attribute: 15 documentation: 'The text knockout flag, shall determine the behaviour of overlapping glyphs within a text object in the transparent imaging model.'&gt;	^self objectAt: #textKnockout ifAbsent: [true asPDF]</body><body package="PDF Graphics">textLineMatrix	&lt;type: #Matrix&gt;	&lt;attribute: 38 documentation: 'The text line matrix'&gt;	^self objectAt: #textLineMatrix ifAbsent: [Matrix identity]</body><body package="PDF Graphics">textMatrix	&lt;type: #Matrix&gt;	&lt;attribute: 37 documentation: 'The text matrix'&gt;	^self objectAt: #textMatrix ifAbsent: [Matrix identity]</body><body package="PDF Graphics">textRenderingMode	&lt;type: #Integer&gt;	&lt;attribute: 13 documentation: 'Set the text rendering mode, Tmode, to render, which shall be an integer'&gt;	^self objectAt: #textRenderingMode ifAbsent: [0 asPDF]</body><body package="PDF Graphics">textRise	&lt;type: #Number&gt;	&lt;attribute: 14 documentation: 'Set the text rise, Trise, to rise, which shall be a number expressed in unscaled text space units'&gt;	^self objectAt: #textRise ifAbsent: [0 asPDF]</body><body package="PDF Graphics">transfer	&lt;type: #Function&gt;	&lt;typeArrayOf: #Name&gt;	&lt;type: #Name&gt;	&lt;deviceDependent&gt;	&lt;version: 2&gt;	&lt;attribute: 33 documentation: 'A function that adjusts device gray or colour component levels to compensate for nonlinear response in a particular output device. Initial value: a conforming reader shall initialize this to a suitable device dependent value.'&gt;	^self objectAt: #transfer ifAbsent: nil</body><body package="PDF Graphics">undercolorRemoval	&lt;type: #Function&gt;	&lt;type: #Name&gt;	&lt;deviceDependent&gt;	&lt;version: 2&gt;	&lt;attribute: 32 documentation: 'A function that calculates the reduction in the levels of the cyan, magenta, and yellow colour components to compensate for the amount of black added by black generation. Initial value: a conforming reader shall initialize this to a suitable device dependent value.'&gt;	^self objectAt: #undercolorRemoval ifAbsent: nil</body><body package="PDF Graphics">wordSpacing	&lt;type: #Number&gt;	&lt;attribute: 8 documentation: 'Set the word spacing, Tw, to wordSpace, which shall be a number expressed in unscaled text space units.Word spacing shall be used by the Tj, TJ, and '' operators'&gt;	^self objectAt: #wordSpacing ifAbsent: [0 asPDF]</body></methods><methods><class-id>Graphics.PDF.GraphicsState class</class-id> <category>pragmas</category><body package="PDF Graphics">pragmas	&lt;pragmas: #instance&gt;	^#(#type: #typeArrayOf: #deviceDependent #modifiedBy: #version: #attribute:documentation:)</body></methods><methods><class-id>Graphics.PDF.FunctionStream</class-id> <category>accessing entries</category><body package="PDF Data Structures">Domain	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'An array of 2 x m numbers, where m shall be the number of input values.For each i from 0 to m-1, Domain2i shall be less than or equal to Domain2i+1, and the ith input value, xi, shall lie in the interval Domain2i &lt;= xi &lt;= Domain2i+1.Input values outside the declared domain shall be clipped to the nearest boundary value.'&gt;	^self objectAt: #Domain</body><body package="PDF Data Structures">FunctionType	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The function type:	0 Sampled function	2 Exponential interpolation function	3 Stitching function	4 PostScript calculator function'&gt;	^self objectAt: #FunctionType</body><body package="PDF Data Structures">Range	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'An array of 2 x n numbers, where n shall be the number of output values.For each j from 0 to n-1, Range2j shall be less than or equal to Range2j+1, and the jth output value, yj , shall lie in the interval Range2j &lt;= yj &lt;= Range2j+1.Output values outside the declared range shall be clipped to the nearest boundary value.If this entry is absent, no clipping shall be done.'&gt;	^self objectAt: #Range</body></methods><methods><class-id>Graphics.PDF.Action</class-id> <category>accessing entries</category><body package="PDF Interactive Features">Next	&lt;type: #Action&gt;	&lt;typeDictionaryOf: #Action&gt;	&lt;version: 2&gt;	&lt;attribute: 3 documentation: 'The next action or sequence of actions that shall be performed after the action represented by this dictionary.The value is either a single action dictionary or an array of action dictionaries that shall be performed in order'&gt;	^self objectAt: #Next ifAbsent: [nil asPDF]</body><body package="PDF Interactive Features">S	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The type of action that this dictionary describes'&gt;	^self objectAt: #S</body><body package="PDF Interactive Features">Type	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The type of PDF object that this dictionary describes.'&gt;	^self objectAt: #Type ifAbsent: [#Action asPDF]</body></methods><methods><class-id>Graphics.PDF.Sound</class-id> <category>accessing entries</category><body package="PDF Interactive Features">B	&lt;type: #Integer&gt;	&lt;attribute: 4 documentation: 'The number of bits per sample value per channel.'&gt;	^self objectAt: #B ifAbsent: [8 asPDF]</body><body package="PDF Interactive Features">C	&lt;type: #Integer&gt;	&lt;attribute: 3 documentation: 'The number of sound channels.'&gt;	^self objectAt: #C ifAbsent: [1 asPDF]</body><body package="PDF Interactive Features">CO	&lt;type: #Name&gt;	&lt;attribute: 6 documentation: 'The sound compression format used on the sample data.(This is separate from any stream compression specified by the sound object’s Filter entry)If this entry is absent, sound compression shall not be used; the data contains sampled waveforms that shall be played at R samples per second per channel.'&gt;	^self objectAt: #CO ifAbsent: [nil asPDF]</body><body package="PDF Interactive Features">CP	&lt;type: #PDFObject&gt;	&lt;attribute: 7 documentation: 'Optional parameters specific to the sound compression format used.No standard values have been defined for the CO and CP entries.'&gt;	^self objectAt: #CP ifAbsent: [nil asPDF]</body><body package="PDF Interactive Features">E	&lt;type: #Name&gt;	&lt;attribute: 5 documentation: 'The encoding format for the sample data:	Raw		Unspecified or unsigned values in the range 0 to 2B − 1	Signed		Twos-complement values	muLaw		m-law–encoded samples	ALaw		A-law–encoded samples'&gt;	^self objectAt: #E ifAbsent: [#Raw asPDF]</body><body package="PDF Interactive Features">R	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The sampling rate, in samples per second.'&gt;	^self objectAt: #R</body><body package="PDF Interactive Features">Type	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The type of PDF object that this dictionary describes.'&gt;	^self objectAt: #Type ifAbsent: [#Sound asPDF]</body></methods><methods><class-id>Graphics.PDF.ZipFilterParameter</class-id> <category>accessing entries</category><body package="PDF Filter">BitsPerComponent	&lt;type: #Integer&gt;	&lt;attribute: 3 documentation: '(May be used only if Predictor is greater than 1)The number of bits used to represent each colour component in a sample.Valid values are 1, 2, 4, 8, and (PDF 1.5) 16'&gt;	^self objectAt: #BitsPerComponent ifAbsent: [8 asPDF]</body><body package="PDF Filter">Colors	&lt;type: #Integer&gt;	&lt;attribute: 2 documentation: '(May be used only if Predictor is greater than 1)The number of interleaved colour components per sample.Valid values are 1 to 4 (PDF 1.0) and 1 or greater (PDF 1.3)'&gt;	^self objectAt: #Colors ifAbsent: [1 asPDF]</body><body package="PDF Filter">Columns	&lt;type: #Integer&gt;	&lt;attribute: 4 documentation: '(May be used only if Predictor is greater than 1)The number of samples in each row'&gt;	^self objectAt: #Columns ifAbsent: [1 asPDF]</body><body package="PDF Filter">Predictor	&lt;type: #Integer&gt;	&lt;attribute: 1 documentation: 'A code that selects the predictor algorithm, if any.If the value of this entry is 1, the filter shall assume that the normal algorithm was used to encode the data, without prediction.If the value is greater than 1, the filter shall assume that the data was differenced before being encoded, and Predictor selects the predictor algorithm'&gt;	^self objectAt: #Predictor ifAbsent: [1 asPDF]</body></methods><methods><class-id>Graphics.PDF.LZWFilterParameter</class-id> <category>accessing entries</category><body package="PDF Filter">EarlyChange	&lt;type: #Integer&gt;	&lt;attribute: 1 documentation: 'An indication of when to increase the code length.If the value of this entry is 0, code length increases shall be postponed as long as possible.If the value is 1, code length increases shall occur one code early.This parameter is included because LZW sample code distributed by some vendors increases the code length one code earlier than necessary'&gt;	^self objectAt: #EarlyChange ifAbsent: [1 asPDF]</body></methods><methods><class-id>Graphics.PDF.Group</class-id> <category>accessing entries</category><body package="PDF XObjects">Group	&lt;type: #GroupAttributes&gt;	&lt;required&gt;	&lt;version: 4&gt;	&lt;attribute: 1 documentation: 'A group attributes dictionary indicating that the contents of the form XObject shall be treated as a group and specifying the attributes of that group.If a Ref entry is present, the group attributes shall also apply to the external page imported by that entry, which allows such an imported page to be treated as a group without further modification.'&gt;	^self objectAt: #Group</body></methods><methods><class-id>Graphics.PDF.Path class</class-id> <category>specification</category><body package="PDF Graphics">localSpecification	&lt;sequence: #subpaths&gt;	&lt;constant: #clippingingOperator class: #{ClippingPathOperation}&gt;	&lt;constant: #paintingOperator class: #{PathPaintingOperation}&gt;</body></methods><methods><class-id>Graphics.PDF.StampAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">Name	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The name of an icon that shall be used in displaying the annotation.Conforming readers shall provide predefined icon appearances for at least the following standard names:	Approved, Experimental, NotApproved, AsIs, Expired, 	NotForPublicRelease, Confidential, Final, Sold, Departmental, 	ForComment, TopSecret, Draft, ForPublicReleaseAdditional names may be supported as well.The annotation dictionary’s AP entry, if present, shall take precedence over the Name entry.'&gt;	^self objectAt: #Name ifAbsent: [#Draft asPDF]</body></methods><methods><class-id>Graphics.PDF.WidgetAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">A	&lt;type: #Action&gt;	&lt;version: 1&gt;	&lt;attribute: 3 documentation: 'An action that shall be performed when the annotation is activated.'&gt;	^self objectAt: #A ifAbsent: [Action empty]</body><body package="PDF Interactive Features">AA	&lt;type: #Dictionary&gt;	&lt;version: 2&gt;	&lt;attribute: 4 documentation: 'An additional-actions dictionary defining the screen annotation’s behaviour in response to various trigger events.'&gt;	^self objectAt: #AA ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">BS	&lt;type: #BorderStyle&gt;	&lt;version: 2&gt;	&lt;attribute: 5 documentation: 'A border style dictionary specifying the width and dash pattern that shall be used in drawing the annotation’s border.The annotation dictionary’s AP entry, if present, shall take precedence over the L and BS entries.'&gt;	^self objectAt: #BS ifAbsent: [BorderStyle empty]</body><body package="PDF Interactive Features">H	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The annotation’s highlighting mode, the visual effect that shall be used when the mouse button is pressed or held down inside its active area:	N 	(None) No highlighting.	I 	(Invert) Invert the contents of the annotation rectangle.	O 	(Outline) Invert the annotation’s border.	P 	(Push) Display the annotation’s down appearance, if any.		If no down appearance is defined, the contents of the annotation rectangle shall be offset to appear as if it were being pushed below the surface of the page.	T 	(Toggle) Same as P (which is preferred).A highlighting mode other than P shall override any down appearance defined for the annotation.'&gt;	^self objectAt: #H ifAbsent: [#I asPDF]</body><body package="PDF Interactive Features">MK	&lt;type: #AppearanceCharacteristics&gt;	&lt;attribute: 2 documentation: 'An appearance characteristics dictionary that shall be used in constructing a dynamic appearance stream specifying the annotation’s visual presentation on the page.The name MK for this entry is of historical significance only and has no direct meaning.'&gt;	^self objectAt: #MK ifAbsent: [AppearanceCharacteristics empty]</body><body package="PDF Interactive Features">Parent	&lt;typeIndirect: #Dictionary&gt;	&lt;attribute: 6 documentation: '(Required if this widget annotation is one of multiple children in a field; absent otherwise)An indirect reference to the widget annotation’s parent field.A widget annotation may have at most one parent; that is, it can be included in the Kids array of at most one field.'&gt;	^self objectAt: #Parent ifAbsent: [Dictionary empty]</body></methods><methods><class-id>Graphics.PDF.Pages</class-id> <category>accessing entries</category><body package="PDF Document">Count	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The number of leaf nodes (page objects) that are descendants of this node within the page tree.'&gt;	^self objectAt: #Count</body><body package="PDF Document">Kids	&lt;typeArrayOf: #PageTree&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of indirect references to the immediate children of this node. The children shall only be page objects or other page tree nodes.'&gt;	^self objectAt: #Kids</body></methods><methods><class-id>Graphics.PDF.RadialShading</class-id> <category>accessing entries</category><body package="PDF Shading">Coords	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of six numbers [x0 y0 r0 x1 y1 r1] specifying the centres and radii of the starting and ending circles, expressed in the shading’s target coordinate space.The radii r0 and r1 shall both be greater than or equal to 0.If one radius is 0, the corresponding circle shall be treated as a point; if both are 0, nothing shall be painted.'&gt;	^self objectAt: #Coords</body><body package="PDF Shading">Domain	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 2 documentation: 'An array of two numbers [t0 t1] specifying the limiting values of a parametric variable t.The variable is considered to vary linearly between these two values as the colour gradient varies between the starting and ending circles.The variable t becomes the input argument to the colour function(s).'&gt;	^self objectAt: #Domain ifAbsent: [#(0.0 1.0) asPDF]</body><body package="PDF Shading">Extend	&lt;typeArrayOf: #Boolean&gt;	&lt;attribute: 4 documentation: 'An array of two boolean values specifying whether to extend the shading beyond the starting and ending circles, respectively.'&gt;	^self objectAt: #Extend ifAbsent: [#(false false) asPDF]</body><body package="PDF Shading">Function	&lt;type: #Function&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'A 1-in, n-out function or an array of n 1-in, 1-out functions (where n is the number of colour components in the shading dictionary’s colour space).The function(s) shall be called with values of the parametric variable t in the domain defined by the shading dictionary’s Domain entry.Each function’s domain shall be a superset of that of the shading dictionary.If the value returned by the function for a given colour component is out of range, it shall be adjusted to the nearest valid value.'&gt;	^self objectAt: #Function</body></methods><methods><class-id>Graphics.PDF.AppearanceCharacteristics</class-id> <category>accessing entries</category><body package="PDF Interactive Features">AC	&lt;type: #Textstring&gt;	&lt;attribute: 6 documentation: '(pushbutton fields only)The widget annotation’s alternate (down) caption, which shall be displayed when the mouse button is pressed within its active area.'&gt;	^self objectAt: #AC ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">BC	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 2 documentation: 'An array of numbers that shall be in the range 0.0 to 1.0 specifying the colour of the widget annotation’s border.The number of array elements determines the colour space in which the colour shall bedefined:	0	No colour; transparent	1	DeviceGray	3	DeviceRGB	4	DeviceCMYK'&gt;	^self objectAt: #BC ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">BG	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 3 documentation: 'An array of numbers that shall be in the range 0.0 to 1.0 specifying the colour of the widget annotation’s background.The number of array elements shall determine the colour space, as described for BC.'&gt;	^self objectAt: #BG ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">CA	&lt;type: #Textstring&gt;	&lt;attribute: 4 documentation: '(button fields only)The widget annotation’s normal caption, which shall be displayed when it is not interacting with the user.Unlike the remaining entries listed in this Table, which apply only to widget annotations associated with pushbutton fields, the CA entry may be used with any type of button field, including check boxes and radio buttons.'&gt;	^self objectAt: #CA ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">I	&lt;typeIndirect: #FormXObject&gt;	&lt;attribute: 7 documentation: '(pushbutton fields only)A form XObject defining the widget annotation’s normal icon, which shall be displayed when it is not interacting with the user.'&gt;	^self objectAt: #I ifAbsent: [FormXObject empty]</body><body package="PDF Interactive Features">IF	&lt;type: #Dictionary&gt;	&lt;attribute: 10 documentation: '(pushbutton fields only)An icon fit dictionary specifying how the widget annotation’s icon shall be displayed within its annotation rectangle.If present, the icon fit dictionary shall apply to all of the annotation’s icons (normal, rollover, and alternate).'&gt;	^self objectAt: #IF ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">IX	&lt;typeIndirect: #FormXObject&gt;	&lt;attribute: 9 documentation: '(pushbutton fields only)A form XObject defining the widget annotation’s alternate (down) icon, which shall be displayed when the mouse button is pressed within its active area.'&gt;	^self objectAt: #IX ifAbsent: [FormXObject empty]</body><body package="PDF Interactive Features">R	&lt;type: #Integer&gt;	&lt;attribute: 1 documentation: 'The number of degrees by which the widget annotation shall be rotated counterclockwise relative to the page.The value shall be a multiple of 90.'&gt;	^self objectAt: #R ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">RC	&lt;type: #Textstring&gt;	&lt;attribute: 5 documentation: '(pushbutton fields only)The widget annotation’s rollover caption, which shall be displayed when the user rolls the cursor into its active area without pressing the mouse button.'&gt;	^self objectAt: #RC ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">RI	&lt;typeIndirect: #FormXObject&gt;	&lt;attribute: 8 documentation: '(pushbutton fields only)A form XObject defining the widget annotation’s rollover icon, which shall be displayed when the user rolls the cursor into its active area without pressing the mouse button.'&gt;	^self objectAt: #RI ifAbsent: [FormXObject empty]</body><body package="PDF Interactive Features">TP	&lt;type: #Integer&gt;	&lt;attribute: 11 documentation: '(pushbutton fields only)A code indicating where to position the text of the widget annotation’s caption relative to its icon:	0	No icon; caption only	1	No caption; icon only	2	Caption below the icon	3	Caption above the icon	4	Caption to the right of the icon	5	Caption to the left of the icon	6	Caption overlaid directly on the icon.'&gt;	^self objectAt: #TP ifAbsent: [0 asPDF]</body></methods><methods><class-id>Graphics.PDF.Resources</class-id> <category>accessing entries</category><body package="PDF Document">ColorSpace	&lt;typeDictionaryOf: #ColourSpace&gt;	&lt;attribute: 2 documentation: 'A dictionary that maps each resource name to either the name of a device-dependent colour space or an array describing a colour space.'&gt;	^self objectAt: #ColorSpace ifAbsent: [Dictionary new]</body><body package="PDF Document">ExtGState	&lt;typeDictionaryOf: #ExtGState&gt;	&lt;attribute: 1 documentation: 'A dictionary that maps resource names to graphics state parameter dictionaries.'&gt;	^self objectAt: #ExtGState ifAbsent: [Dictionary new]</body><body package="PDF Document">Font	&lt;typeDictionaryOf: #Font&gt;	&lt;attribute: 6 documentation: 'A dictionary that maps resource names to font dictionaries.'&gt;	^self objectAt: #Font ifAbsent: [Dictionary new]</body><body package="PDF Document">Pattern	&lt;type: #Dictionary&gt;	&lt;attribute: 3 documentation: 'A dictionary that maps resource names to pattern objects.'&gt;	^self objectAt: #Pattern ifAbsent: [Dictionary empty]</body><body package="PDF Document">ProcSet	&lt;typeArrayOf: #Name&gt;	&lt;attribute: 7 documentation: 'An array of predefined procedure set names.'&gt;	^self objectAt: #ProcSet ifAbsent: [#() asPDF]</body><body package="PDF Document">Properties	"&lt;typeDictionaryOf: #OptionalContentGroup&gt;"	&lt;type: #Dictionary&gt;	&lt;version: 2&gt;	&lt;attribute: 8 documentation: 'A dictionary that maps resource names to property list dictionaries for marked content.'&gt;	^self objectAt: #Properties ifAbsent: [Dictionary new]</body><body package="PDF Document">Shading	&lt;typeDictionaryOf: #Shading&gt;	&lt;version: 3&gt;	&lt;attribute: 4 documentation: 'A dictionary that maps resource names to shading dictionaries.'&gt;	^self objectAt: #Shading ifAbsent: [Dictionary new]</body><body package="PDF Document">XObject	&lt;typeDictionaryOf: #XObject&gt;	&lt;attribute: 5 documentation: 'A dictionary that maps resource names to external objects.'&gt;	^self objectAt: #XObject ifAbsent: [Dictionary new]</body></methods><methods><class-id>Graphics.PDF.LabColourSpaceDictionary</class-id> <category>accessing entries</category><body package="PDF Colour">BlackPoint	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 2 documentation: 'An array of three numbers [XB YB ZB] that shall specify the tristimulus value, in the CIE 1931 XYZ space, of the diffuse black point.All three of these numbers shall be non-negative'&gt;	^self objectAt: #BlackPoint ifAbsent: [#(0.0 0.0 0.0) asPDF]</body><body package="PDF Colour">Range	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 3 documentation: 'An array of four numbers [amin amax bmin bmax] that shall specify the range of valid values for the a* and b* (B and C) components of the colour space—that is,	amin &lt;= a* &lt;= amaxand	bmin &lt;= b* &lt;= bmaxComponent values falling outside the specified range shall be adjusted to the nearest valid value without error indication.'&gt;	^self objectAt: #Range ifAbsent: [#(-100 100 -100 100) asPDF]</body><body package="PDF Colour">WhitePoint	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of three numbers [XW YW ZW] that shall specify the tristimulus value, in the CIE 1931 XYZ space, of the diffuse white point.The numbers XW and ZW shall be positive, and YW shall be 1.0.'&gt;	^self objectAt: #WhitePoint</body></methods><methods><class-id>Graphics.PDF.OutputIntent</class-id> <category>accessing entries</category><body package="PDF Document">DestOutputProfile	&lt;type: #Stream&gt;	&lt;attribute: 6 documentation: '(Required if OutputConditionIdentifier does not specify a standard production condition; optional otherwise) An ICC profile stream defining the transformation from the PDF document’s source colours to output device colorants.The format of the profile stream is the same as that used in specifying an ICCBased colour space. The output transformation uses the profile’s “from CIE” information (BToA in ICC terminology); the “to CIE” (AToB) information may optionally be used to remap source colour values to some other destination colour space, such as for screen preview or hardcopy proofing.'&gt;	^self objectAt: #DestOutputProfile</body><body package="PDF Document">Info	&lt;type: #Textstring&gt;	&lt;attribute: 5 documentation: '(Required if OutputConditionIdentifier does not specify a standard production condition; optional otherwise) A human-readable text string containing additional information or comments about the intended target device or production condition.'&gt;	^self objectAt: #Info ifAbsent: [Textstring empty]</body><body package="PDF Document">OutputCondition	&lt;type: #Textstring&gt;	&lt;attribute: 2 documentation: 'A text string concisely identifying the intended output device or production condition in human-readable form. This is the preferred method of defining such a string for presentation to the user.'&gt;	^self objectAt: #OutputCondition ifAbsent: [Textstring empty]</body><body package="PDF Document">OutputConditionIdentifier	&lt;type: #Textstring&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'A text string identifying the intended output device or production condition in human- or machine-readable form. If human-readable, this string may be used in lieu of an OutputCondition string for presentation to the user.A typical value for this entry may be the name of a production condition maintained in an industry-standard registry such as the ICC Characterization Data Registry (see the Bibliography). If the designated condition matches that in effect at production time, the production software is responsible for providing the corresponding ICC profile as defined in the registry.If the intended production condition is not a recognized standard, the value of this entry may be Custom or an application-specific, machine-readable name. The DestOutputProfile entry defines the ICC profile, and the Info entry shall be used for further human-readable identification.'&gt;	^self objectAt: #OutputConditionIdentifier</body><body package="PDF Document">RegistryName	&lt;type: #Textstring&gt;	&lt;attribute: 4 documentation: 'An text string (conventionally a uniform resource identifier, or URI) identifying the registry in which the condition designated by OutputConditionIdentifier is defined.'&gt;	^self objectAt: #RegistryName ifAbsent: [Textstring empty]</body><body package="PDF Document">S	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The output intent subtype; shall be either one of GTS_PDFX, GTS_PDFA1, ISO_PDFE1 or a key defined by an ISO 32000 extension.'&gt;	^self objectAt: #S</body></methods><methods><class-id>Graphics.PDF.FileAttachmentAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">FS	&lt;type: #FileSpecification&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The file associated with this annotation.'&gt;	^self objectAt: #FS</body><body package="PDF Interactive Features">Name	&lt;type: #Name&gt;	&lt;attribute: 2 documentation: 'The name of an icon that shall be used in displaying the annotation.Conforming readers shall provide predefined icon appearances for at least the following standard names:	GraphPushPin	PaperclipTagAdditional names may be supported as well.The annotation dictionary’s AP entry, if present, shall take precedence over the Name entry.'&gt;	^self objectAt: #Name ifAbsent: [#PushPin asPDF]</body></methods><methods><class-id>Graphics.PDF.ImageXObject</class-id> <category>accessing entries</category><body package="PDF Images">Alternates	&lt;typeArrayOf: #Dictionary&gt;	&lt;version: 3&gt;	&lt;attribute: 10 documentation: 'An array of alternate image dictionaries for this image. The order of elements within the array shall have no significance. This entry shall not be present in an image XObject that is itself an alternate image.'&gt;	^self objectAt: #Alternates ifAbsent: [Dictionary empty]</body><body package="PDF Images">BitsPerComponent	&lt;type: #Integer&gt;	&lt;attribute: 4 documentation: '(Required except for image masks and images that use the JPXDecode filter) The number of bits used to represent each colour component. Only a single value shall be specified; the number of bits shall be the same for all colour components. The value shall be 1, 2, 4, 8, or (in PDF 1.5) 16. If ImageMask is true, this entry is optional, but if specified, its value shall be 1.If the image stream uses a filter, the value of BitsPerComponent shall be consistent with the size of the data samples that the filter delivers. In particular, a CCITTFaxDecode or JBIG2Decode filter shall always deliver 1-bit samples, a RunLengthDecode or DCTDecode filter shall always deliver 8-bit samples, and an LZWDecode or FlateDecode filter shall deliver samples of a specified size if a predictor function is used.If the image stream uses the JPXDecode filter, this entry is optional and shall be ignored if present. The bit depth is determined by the conforming reader in the process of decoding the JPEG2000 image.'&gt;	^self objectAt: #BitsPerComponent</body><body package="PDF Images">ColorSpace	&lt;type: #ColourSpace&gt;	&lt;attribute: 3 documentation: '(Required for images, except those that use the JPXDecode filter; not allowed forbidden for image masks) The colour space in which image samples shall be specified; it can be any type of colour space except Pattern.If the image uses the JPXDecode filter, this entry may be present:	•	If ColorSpace is present, any colour space specifications in the JPEG2000 data shall be ignored.	•	If ColorSpace is absent, the colour space specifications in the JPEG2000 data shall be used. 		The Decode array shall also be ignored unless ImageMask is true.'&gt;	^self objectAt: #ColorSpace</body><body package="PDF Images">Decode	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 8 documentation: 'An array of numbers describing how to map image samples into the range of values appropriate for the image’s colour space. If ImageMask is true, the array shall be either [0 1] or [1 0]; otherwise, its length shall be twice the number of colour components required by ColorSpace. If the image uses the JPXDecode filter and ImageMask is false, Decode shall be ignored by a conforming reader'&gt;	^self objectAt: #Decode ifAbsent: [self defaultDecodeArray]</body><body package="PDF Images">Height	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The height of the image, in samples.'&gt;	^self objectAt: #Height</body><body package="PDF Images">ID	&lt;type: #String&gt;	&lt;version: 3&gt;	&lt;attribute: 15 documentation: '(indirect reference preferred) The digital identifier of the image’s parent Web Capture content set.'&gt;	^self objectAt: #ID</body><body package="PDF Images">ImageMask	&lt;type: #Boolean&gt;	&lt;attribute: 6 documentation: 'A flag indicating whether the image shall be treated as an image mask. If this flag is true, the value of BitsPerComponent shall be 1 and Mask and ColorSpace shall not be specified; unmasked areas shall bepainted using the current nonstroking colour.'&gt;	^self objectAt: #ImageMask ifAbsent: [false asPDF]</body><body package="PDF Images">Intent	&lt;type: #Name&gt;	&lt;version: 1&gt;	&lt;attribute: 5 documentation: 'The name of a colour rendering intent to be used in rendering the image. Default value: the current rendering intent in the graphics state.'&gt;	^self objectAt: #Intent</body><body package="PDF Images">Interpolate	&lt;type: #Boolean&gt;	&lt;attribute: 9 documentation: 'A flag indicating whether image interpolation shall be performed by a conforming reader.'&gt;	^self objectAt: #Interpolate ifAbsent: [false asPDF]</body><body package="PDF Images">Mask	&lt;type: #ImageXObject&gt;	&lt;type: #PDFArray&gt;	&lt;version: 3&gt;	&lt;attribute: 7 documentation: '(Optional except for image masks; not allowed for image masks) An image XObject defining an image mask to be applied to this image, or an array specifying a range of colours to be applied to it as a colour key mask. If ImageMask is true, this entry shall not be present.'&gt;	^self objectAt: #Mask</body><body package="PDF Images">Metadata	&lt;type: #Stream&gt;	&lt;version: 4&gt;	&lt;attribute: 17 documentation: 'A metadata stream containing metadata for the image.'&gt;	^self objectAt: #Metadata</body><body package="PDF Images">Name	&lt;type: #Name&gt;	&lt;attribute: 13 documentation: '(Required in PDF 1.0; optional otherwise) The name by which this image XObject is referenced in the XObject subdictionary of the current resource dictionary.This entry is obsolescent and shall no longer be used.'&gt;	^self objectAt: #Name</body><body package="PDF Images">OC	&lt;type: #Dictionary&gt;	&lt;version: 5&gt;	&lt;attribute: 18 documentation: 'An optional content group or optional content membership dictionary, specifying the optional content properties for this image XObject. Before the image is processed by a conforming reader, its visibility shall be determined based on this entry. If it is determined to be invisible, the entire image shall be skipped, as if there were no Do operator to invoke it.'&gt;	^self objectAt: #OC ifAbsent: [Dictionary empty]</body><body package="PDF Images">OPI	&lt;type: #Dictionary&gt;	&lt;version: 2&gt;	&lt;attribute: 16 documentation: 'An OPI version dictionary for the image. If ImageMask is true, this entry shall be ignored.'&gt;	^self objectAt: #OPI ifAbsent: [Dictionary empty]</body><body package="PDF Images">SMask	&lt;type: #SoftMaskImage&gt;	&lt;version: 4&gt;	&lt;attribute: 11 documentation: 'A subsidiary image XObject defining a soft-mask image that shall be used as a source of mask shape or mask opacity values in the transparent imaging model. The alpha source parameter in the graphics state determines whether the mask values shall beinterpreted as shape or opacity.If present, this entry shall override the current soft mask in the graphics state, as well as the image’s Mask entry, if any. However, the other transparency-related graphics state parameters—blend mode and alpha constant—shall remain in effect. If SMask is absent, the image shall have no associated soft mask (although the current soft mask in the graphics state may still apply).'&gt;	^self objectAt: #SMask</body><body package="PDF Images">SMaskInData	&lt;type: #Integer&gt;	&lt;version: 5&gt;	&lt;attribute: 12 documentation: '(Optional for images that use the JPXDecode filter, meaningless otherwise) A code specifying how soft-mask information encoded with image samples shall be used:0	If present, encoded soft-mask image information shall be ignored.1 	The image’s data stream includes encoded soft-mask values. 	A conforming reader may create a soft-mask image from the information to be used as a source of mask shape or mask opacity in the transparency imaging model.2	The image’s data stream includes colour channels that have been preblended with a background; the image data also includes an opacity channel. 	A conforming reader may create a soft-mask image with a Matte entry from the opacity channel information to be used 	as a source of mask shape or mask opacity in the transparency model.If this entry has a nonzero value, SMask shall not be specified.'&gt;	^self objectAt: #SMaskInData ifAbsent: [0 asPDF]</body><body package="PDF Images">StructParent	&lt;type: #Integer&gt;	&lt;version: 3&gt;	&lt;attribute: 14 documentation: '(Required if the image is a structural content item) The integer key of the image’s entry in the structural parent tree.'&gt;	^self objectAt: #StructParent</body><body package="PDF Images">Width	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The width of the image, in samples.'&gt;	^self objectAt: #Width</body></methods><methods><class-id>Graphics.PDF.SoftMaskImage</class-id> <category>accessing entries</category><body package="PDF Images">Alternates	&lt;typeArrayOf: #Dictionary&gt;	&lt;version: 3&gt;	&lt;attribute: 10 documentation: 'Ignored.An array of alternate image dictionaries for this image. The order of elements within the array shall have no significance. This entry shall not be present in an image XObject that is itself an alternate image.'&gt;	^self objectAt: #Alternates ifAbsent: [Dictionary empty]</body><body package="PDF Images">BitsPerComponent	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'The number of bits used to represent each colour component. Only a single value shall be specified; the number of bits shall be the same for all colour components. The value shall be 1, 2, 4, 8, or (in PDF 1.5) 16. If the image stream uses a filter, the value of BitsPerComponentshall be consistent with the size of the data samples that the filter delivers. In particular, a CCITTFaxDecode or JBIG2Decode filter shall always deliver 1-bit samples, a RunLengthDecode or DCTDecode filter shall always deliver 8-bit samples, and an LZWDecode or FlateDecode filter shall deliver samples of a specified size if a predictor function is used.If the image stream uses the JPXDecode filter, this entry is optional and shall be ignored if present. The bit depth is determined by the conforming reader in the process of decoding the JPEG2000 image.'&gt;	^self objectAt: #BitsPerComponent</body><body package="PDF Images">ColorSpace	&lt;type: #ColourSpace&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'shall be DeviceGray'&gt;	^self objectAt: #ColorSpace</body><body package="PDF Images">Decode	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 8 documentation: 'An array of numbers describing how to map image samples into the range of values appropriate for the image’s colour space. If ImageMask is true, the array shall be either [0 1] or [1 0]; otherwise, its length shall be twice the number of colour components required by ColorSpace. If the image uses the JPXDecode filter and ImageMask is false, Decode shall be ignored by a conforming reader'&gt;	^self objectAt: #Decode ifAbsent: [#(0 1) asPDF]</body><body package="PDF Images">Height	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'Same considerations as for Width'&gt;	^self objectAt: #Height</body><body package="PDF Images">ID	&lt;type: #String&gt;	&lt;version: 3&gt;	&lt;attribute: 15 documentation: 'Ignored.(indirect reference preferred) The digital identifier of the image’s parent Web Capture content set.'&gt;	^self objectAt: #ID</body><body package="PDF Images">ImageMask	&lt;type: #Boolean&gt;	&lt;attribute: 6 documentation: 'Shall be false or absent.A flag indicating whether the image shall be treated as an image mask. If this flag is true, the value of BitsPerComponent shall be 1 and Mask and ColorSpace shall not be specified; unmasked areas shall be painted using the current nonstroking colour.'&gt;	^self objectAt: #ImageMask ifAbsent: [false asPDF]</body><body package="PDF Images">Intent	&lt;type: #Name&gt;	&lt;version: 1&gt;	&lt;attribute: 5 documentation: 'IgnoredThe name of a colour rendering intent to be used in rendering the image. Default value: the current rendering intent in the graphics state.'&gt;	^self objectAt: #Intent</body><body package="PDF Images">Mask	&lt;type: #Stream&gt;	&lt;type: #PDFArray&gt;	&lt;version: 3&gt;	&lt;attribute: 7 documentation: 'Shall be absent.An image XObject defining an image mask to be applied to this image, or an array specifying a range of colours to be applied to it as a colour key mask. If ImageMask is true, this entry shall not be present.'&gt;	^self objectAt: #Mask</body><body package="PDF Images">Matte	&lt;typeArrayOf: #Number&gt;	&lt;version: 4&gt;	&lt;attribute: 17 documentation: 'An array of component values specifying the matte colour with which the image data in the parent image shall have been preblended.The array shall consist of n numbers, where n is the number of components in the colour space specified by the ColorSpace entry in the parent image’s image dictionary; the numbers shall be valid colour components in that colour space.If this entry is absent, the image data shall not be preblended.'&gt;	^self objectAt: #Matte</body><body package="PDF Images">Name	&lt;type: #Name&gt;	&lt;attribute: 13 documentation: 'Ignored.(Required in PDF 1.0; optional otherwise) The name by which this image XObject is referenced in the XObject subdictionary of the current resource dictionary.This entry is obsolescent and shall no longer be used.'&gt;	^self objectAt: #Name</body><body package="PDF Images">OPI	&lt;type: #Dictionary&gt;	&lt;version: 2&gt;	&lt;attribute: 16 documentation: 'Ignored.An OPI version dictionary for the image. If ImageMask is true, this entry shall be ignored.'&gt;	^self objectAt: #OPI ifAbsent: [Dictionary empty]</body><body package="PDF Images">SMask	&lt;type: #XObject&gt;	&lt;version: 4&gt;	&lt;attribute: 11 documentation: 'Shall be absent.A subsidiary image XObject defining a soft-mask image that shall be used as a source of mask shape or mask opacity values in the transparent imaging model. The alpha source parameter in the graphics state determines whether the mask values shall beinterpreted as shape or opacity.If present, this entry shall override the current soft mask in the graphics state, as well as the image’s Mask entry, if any. However, the other transparency-related graphics state parameters—blend mode and alpha constant—shall remain in effect. If SMask is absent, the image shall have no associated soft mask (although the current soft mask in the graphics state may still apply).'&gt;	^self objectAt: #SMask</body><body package="PDF Images">StructParent	&lt;type: #Integer&gt;	&lt;version: 3&gt;	&lt;attribute: 14 documentation: 'Ignored.(Required if the image is a structural content item) The integer key of the image’s entry in the structural parent tree.'&gt;	^self objectAt: #StructParent</body><body package="PDF Images">Width	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'If a Matte entry is present, shall be the same as the Width value of the parent image; otherwise independent of it.Both images shall be mapped to the unit square in user space (as are all images), regardless of whether the samples coincide individually'&gt;	^self objectAt: #Width</body></methods><methods><class-id>Graphics.PDF.Dest</class-id> <category>accessing entries</category><body package="PDF Interactive Features">D	&lt;type: #ExplicitDestination&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An explicit destination array'&gt;	^self objectAt: #D</body></methods><methods><class-id>Graphics.PDF.FontDescriptor</class-id> <category>accessing entries</category><body package="PDF Fonts">Ascent	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 8 documentation: '(Required, except for Type 3 fonts) The maximum height above the baseline reached by glyphs in this font. The height of glyphs for accented characters shall be excluded.'&gt;	^self objectAt: #Ascent</body><body package="PDF Fonts">AvgWidth	&lt;type: #Number&gt;	&lt;attribute: 15 documentation: 'The average width of glyphs in the font.'&gt;	^self objectAt: #AvgWidth ifAbsent: [0 asPDF]</body><body package="PDF Fonts">CapHeight	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 11 documentation: '(Required for fonts that have Latin characters, except for Type 3 fonts)The vertical coordinate of the top of flat capital letters, measured from the baseline.'&gt;	^self objectAt: #CapHeight</body><body package="PDF Fonts">CharSet	&lt;type: #String&gt;	&lt;version: 1&gt;	&lt;attribute: 21 documentation: '(meaningful only in Type 1 fonts) A string listing the character names defined in a font subset. The names in this string shall be in PDF syntax—that is, each name preceded by a slash (/). The names may appear in any order. The name .notdef shall be omitted; it shall exist in the font subset. If this entry is absent, the only indication of a font subset shall be the subset tag in the FontName entry.'&gt;	^self objectAt: #CharSet ifAbsent: ['' asPDF]</body><body package="PDF Fonts">Descent	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 9 documentation: '(Required, except for Type 3 fonts) The maximum depth below the baseline reached by glyphs in this font. The value shall be a negative number.'&gt;	^self objectAt: #Descent</body><body package="PDF Fonts">Flags	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 5 documentation: 'A collection of flags defining various characteristics of the font.'&gt;	^self objectAt: #Flags</body><body package="PDF Fonts">FontBBox	&lt;type: #Rectangle&gt;	&lt;required&gt;	&lt;attribute: 6 documentation: '(Required, except for Type 3 fonts) A rectangle, expressed in the glyph coordinate system, that shall specify the font bounding box. This should be the smallest rectangle enclosing the shape that would result if all of the glyphs of the font were placed with their origins coincident and then filled.'&gt;	^self objectAt: #FontBBox</body><body package="PDF Fonts">FontFamily	&lt;type: #String&gt;	&lt;version: 5&gt;	&lt;attribute: 2 documentation: '(should be used for Type 3 fonts in Tagged PDF documents)A byte string specifying the preferred font family name.EXAMPLE 1For the font Times Bold Italic, the FontFamily is Times.'&gt;	^self objectAt: #FontFamily</body><body package="PDF Fonts">FontFile	&lt;type: #Stream&gt;	&lt;attribute: 18 documentation: 'A stream containing a Type 1 font program.'&gt;	^self objectAt: #FontFile ifAbsent: [nil asPDF]</body><body package="PDF Fonts">FontFile2	&lt;type: #Stream&gt;	&lt;version: 1&gt;	&lt;attribute: 19 documentation: 'A stream containing a TrueType font program.'&gt;	^self objectAt: #FontFile2 ifAbsent: [nil asPDF]</body><body package="PDF Fonts">FontFile3	&lt;type: #Stream&gt;	&lt;version: 2&gt;	&lt;attribute: 20 documentation: 'A stream containing a font program whose format is specified by the Subtype entry in the stream dictionary'&gt;	^self objectAt: #FontFile3 ifAbsent: [nil asPDF]</body><body package="PDF Fonts">FontName	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The PostScript name of the font.This name shall be the same as the value of BaseFont in the font or CIDFont dictionary that refers to this font descriptor.'&gt;	^self objectAt: #FontName</body><body package="PDF Fonts">FontStretch	&lt;type: #Name&gt;	&lt;version: 5&gt;	&lt;attribute: 3 documentation: '(should be used for Type 3 fonts in Tagged PDF documents) The font stretch value. It shall be one of these names (ordered from narrowest to widest): 	UltraCondensed, 	ExtraCondensed, 	Condensed, 	SemiCondensed, 	Normal, 	SemiExpanded, 	Expanded, 	ExtraExpanded or 	UltraExpanded.The specific interpretation of these values varies from font to font.EXAMPLE 2Condensed in one font may appear most similar to Normal in another.'&gt;	^self objectAt: #FontStretch</body><body package="PDF Fonts">FontWeight	&lt;type: #Number&gt;	&lt;version: 5&gt;	&lt;attribute: 4 documentation: '(should be used for Type 3 fonts in Tagged PDF documents) The weight (thickness) component of the fully-qualified font name or font specifier. The possible values shall be 100, 200, 300, 400, 500, 600, 700, 800, or 900, where each number indicates a weight that is at least as dark as its predecessor. A value of 400 shall indicate a normal weight; 700 shall indicate bold.The specific interpretation of these values varies from font to font.EXAMPLE 3300 in one font may appear most similar to 500 in another.'&gt;	^self objectAt: #FontWeight</body><body package="PDF Fonts">ItalicAngle	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 7 documentation: 'The angle, expressed in degrees counterclockwise from the vertical, of the dominant vertical strokes of the font.EXAMPLE 4The 9-o’clock position is 90 degrees, and the 3-o’clock position is –90 degrees.The value shall be negative for fonts that slope to the right, as almost all italic fonts do.'&gt;	^self objectAt: #ItalicAngle</body><body package="PDF Fonts">Leading	&lt;type: #Number&gt;	&lt;attribute: 10 documentation: 'The spacing between baselines of consecutive lines of text.'&gt;	^self objectAt: #Leading ifAbsent: [0 asPDF]</body><body package="PDF Fonts">MaxWidth	&lt;type: #Number&gt;	&lt;attribute: 16 documentation: 'The maximum width of glyphs in the font.'&gt;	^self objectAt: #MaxWidth ifAbsent: [0 asPDF]</body><body package="PDF Fonts">MissingWidth	&lt;type: #Number&gt;	&lt;attribute: 17 documentation: 'The width to use for character codes whose widths are not specified in a font dictionary’s Widths array.This shall have a predictable effect only if all such codes map to glyphs whose actual widths are the same as the value of the MissingWidth entry.'&gt;	^self objectAt: #MissingWidth ifAbsent: [0 asPDF]</body><body package="PDF Fonts">StemH	&lt;type: #Number&gt;	&lt;attribute: 14 documentation: 'The thickness, measured vertically, of the dominant horizontal stems of glyphs in the font.'&gt;	^self objectAt: #StemH ifAbsent: [0 asPDF]</body><body package="PDF Fonts">StemV	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 13 documentation: '(Required, except for Type 3 fonts) The thickness, measured horizontally, of the dominant vertical stems of glyphs in the font.'&gt;	^self objectAt: #StemV</body><body package="PDF Fonts">XHeight	&lt;type: #Number&gt;	&lt;attribute: 12 documentation: 'The font’s x height: the vertical coordinate of the top of flat nonascending lowercase letters (like the letter x), measured from the baseline, in fonts that have Latin characters.'&gt;	^self objectAt: #XHeight ifAbsent: [0 asPDF]</body></methods><methods><class-id>Graphics.PDF.DeviceNProcessDictionary</class-id> <category>accessing entries</category><body package="PDF Colour">ColorSpace	&lt;type: #DeviceColourSpace&gt;	&lt;type: #CIEColourSpace&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'If an ICCBased colour space is specified, it shall provide calibration information appropriate for the process colour components specified in the names array of the DeviceN colour space'&gt;	^self objectAt: #ColorSpace</body><body package="PDF Colour">Components	&lt;typeArrayOf: #Name&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'An array of component names that correspond, in order, to the components of the process colour space specified in ColorSpace.For example, an RGB colour space shall have three names corresponding to red, green, and blue.The names may be arbitrary (that is, not the same as the standard names for the colour space components) and shall match those specified in the names array of the DeviceN colour space, even if all components are not present in the names array'&gt;	^self objectAt: #Components</body></methods><methods><class-id>Graphics.PDF.SampledFunction</class-id> <category>accessing entries</category><body package="PDF Data Structures">BitsPerSample	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'The number of bits that shall represent each sample. (If the function has multiple output values, each one shall occupy BitsPerSample bits.)Valid values shall be 1, 2, 4, 8, 12, 16, 24, and 32.'&gt;	^self objectAt: #BitsPerSample</body><body package="PDF Data Structures">Decode	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 6 documentation: 'An array of 2 × n numbers specifying the linear mapping of sample values into the range appropriate for the function’s output values.Default value: same as the value of Range.'&gt;	^self objectAt: #Decode ifAbsent: [#() asPDF]</body><body package="PDF Data Structures">Encode	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 5 documentation: 'An array of 2 × m numbers specifying the linear mapping of input values into the domain of the function’s sample table.Default value: [0 (Size0 - 1) 0 (Size1 - 1) …].'&gt;	^self objectAt: #Encode ifAbsent: [		| list |		list := OrderedCollection new.		self Size asSmalltalkValue do: [:s |			list add: 0.			list add: s value - 1].		list asPDF]</body><body package="PDF Data Structures">Order	&lt;type: #Integer&gt;	&lt;attribute: 4 documentation: 'The order of interpolation between samples.Valid values shall be 1 and 3, specifying linear and cubic spline interpolation, respectively.Default value: 1.'&gt;	^self objectAt: #Order ifAbsent: [1 asPDF]</body><body package="PDF Data Structures">Size	&lt;typeArrayOf: #Integer&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'An array of m positive integers that shall specify the number of samples in each input dimension of the sample table.'&gt;	^self objectAt: #Size</body></methods><methods><class-id>Graphics.PDF.LatticeFormGouraudShadedMesh</class-id> <category>accessing entries</category><body package="PDF Shading">VerticesPerRow	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The number of vertices in each row of the lattice; the value shall be greater than or equal to 2.The number of rows need not be specified.'&gt;	^self objectAt: #VerticesPerRow</body></methods><methods><class-id>Graphics.PDF.URI</class-id> <category>accessing entries</category><body package="PDF Interactive Features">IsMap	&lt;type: #Boolean&gt;	&lt;attribute: 2 documentation: 'A flag specifying whether to track the mouse position when the URI is resolved.This entry applies only to actions triggered by the user’s clicking an annotation; it shall be ignored for actions associated with outline items or with a document’s OpenAction entry'&gt;	^self objectAt: #IsMap ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">URI	&lt;type: #AsciiString&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The uniform resource identifier to resolve, encoded in 7-bit ASCII'&gt;	^self objectAt: #URI</body></methods><methods><class-id>Graphics.PDF.ExponentialInterpolationFunction</class-id> <category>accessing entries</category><body package="PDF Data Structures">C0	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 1 documentation: 'An array of n numbers that shall define the function result when x = 0.0.Default value: [0.0].'&gt;	^self objectAt: #C0 ifAbsent: [#(0.0) asPDF]</body><body package="PDF Data Structures">C1	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 2 documentation: 'An array of n numbers that shall define the function result when x = 1.0.Default value: [1.0].'&gt;	^self objectAt: #C1 ifAbsent: [#(1.0) asPDF]</body><body package="PDF Data Structures">N	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'The interpolation exponent.Each input value x shall return n values, given by yj = C0j + xN x (C1j - C0j), for 0 &lt;= j &lt; n.'&gt;	^self objectAt: #N</body></methods><methods><class-id>Graphics.PDF.Rectangle</class-id> <category>accessing entries</category><body package="PDF Data Structures">llx	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'lower-left x'&gt;	^self objectAt: 1</body><body package="PDF Data Structures">lly	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'lower-left y'&gt;	^self objectAt: 2</body><body package="PDF Data Structures">urx	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'upper-right x'&gt;	^self objectAt: 3</body><body package="PDF Data Structures">ury	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'upper-right y'&gt;	^self objectAt: 4</body></methods><methods><class-id>Graphics.PDF.LineAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">BS	&lt;type: #BorderStyle&gt;	&lt;version: 6&gt;	&lt;attribute: 2 documentation: 'A border style dictionary specifying the line width and dash pattern that shall be used in drawing the line.The annotation dictionary’s AP entry, if present, takes precedence over the L and BS entries.'&gt;	^self objectAt: #BS ifAbsent: [BorderStyle empty]</body><body package="PDF Interactive Features">CO	&lt;typeArrayOf: #Number&gt;	&lt;version: 7&gt;	&lt;attribute: 12 documentation: '(meaningful only if Cap is true)An array of two numbers that shall specify the offset of the caption text from its normal position.The first value shall be the horizontal offset along the annotation line from its midpoint, with a positive value indicating offset to the right and a negative value indicating offset to the left.The second value shall be the vertical offset perpendicular to the annotation line, with a positive value indicating a shift up and a negative value indicating a shift down.'&gt;	^self objectAt: #CO ifAbsent: [#(0 0) asPDF]</body><body package="PDF Interactive Features">CP	&lt;type: #Name&gt;	&lt;version: 7&gt;	&lt;attribute: 10 documentation: 'A name describing the annotation’s caption positioning.Valid values are /Inline, meaning the caption shall be centered inside the line, and /Top, meaning the caption shall be on top of the line.'&gt;	^self objectAt: #CP ifAbsent: [#Inline asPDF]</body><body package="PDF Interactive Features">Cap	&lt;type: #Boolean&gt;	&lt;version: 6&gt;	&lt;attribute: 7 documentation: 'If true, the text specified by the Contents or RC entries shall be replicated as a caption in the appearance of the line.The text shall be rendered in a manner appropriate to the content, taking into account factors such as writing direction.'&gt;	^self objectAt: #Cap ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">IC	&lt;typeArrayOf: #Number&gt;	&lt;version: 4&gt;	&lt;attribute: 4 documentation: 'An array of numbers in the range 0.0 to 1.0 specifying the interior color that shall be used to fill the annotation’s line endings.The number of array elements shall determine the colour space in which the colour is defined:	0	No colour; transparent	1	DeviceGray	3	DeviceRGB	4	DeviceCMYK'&gt;	^self objectAt: #IC ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">IT	&lt;type: #Name&gt;	&lt;version: 6&gt;	&lt;attribute: 8 documentation: 'A name describing the intent of the line annotation.Valid values shall be LineArrow, which means that the annotation is intended to function as an arrow, and LineDimension, which means that the annotation is intended to function as a dimension line.'&gt;	^self objectAt: #IT ifAbsent: [nil asPDF]</body><body package="PDF Interactive Features">L	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of four numbers, [x1 y1 x2 y2], specifying the starting and ending coordinates of the line in default user space.If the LL entry is present, this value shall represent the endpoints of the leader lines rather than the endpoints of the line itself.'&gt;	^self objectAt: #L</body><body package="PDF Interactive Features">LE	&lt;typeArrayOf: #Name&gt;	&lt;version: 4&gt;	&lt;attribute: 3 documentation: 'An array of two names specifying the line ending styles that shall be used in drawing the line.The first and second elements of the array shall specify the line ending styles for the endpoints defined, respectively, by the first and second pairs of coordinates, (x1, y1)and (x2, y2), in the L array.The possible values are:	/Square /Circle /Diamond /OpenArrow /ClosedArrow /None /Butt /ROpenArrow /RClosedArrow /Slash.'&gt;	^self objectAt: #LE ifAbsent: [#(#None #None) asPDF]</body><body package="PDF Interactive Features">LL	&lt;type: #Number&gt;	&lt;version: 6&gt;	&lt;attribute: 5 documentation: '(Required if LLE is present, otherwise optional)The length of leader lines in default user space that extend from each endpoint of the line perpendicular to the line itself.A positive value shall mean that the leader lines appear in the direction that is clockwise when traversing the line from its starting point to its ending point (as specified by L); a negative value shall indicate the opposite direction.'&gt;	^self objectAt: #LL ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">LLE	&lt;type: #Number&gt;	&lt;version: 6&gt;	&lt;attribute: 6 documentation: 'A non-negative number that shall represents the length of leader line extensions that extend from the line proper 180 degrees from the leader lines.'&gt;	^self objectAt: #LLE ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">LLO	&lt;type: #Number&gt;	&lt;version: 7&gt;	&lt;attribute: 9 documentation: 'A non-negative number that shall represent the length of the leader line offset, which is the amount of empty space between the endpoints of the annotation and the beginning of the leader lines.'&gt;	^self objectAt: #LLO ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">Measure	&lt;type: #Dictionary&gt;	&lt;version: 7&gt;	&lt;attribute: 11 documentation: 'A measure dictionary that shall specify the scale and units that apply to the line annotation.'&gt;	^self objectAt: #Measure ifAbsent: [Dictionary empty]</body></methods><methods><class-id>Graphics.PDF.SoftMask</class-id> <category>accessing entries</category><body package="PDF XObjects">BC	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 4 documentation: 'An array of component values specifying the colour to be used as the backdrop against which to composite the transparency group XObject G.This entry shall be consulted only if the subtype S is Luminosity.The array shall consist of n numbers, where n is the number of components in the colour space specified by the CS entry in the group attributes dictionary. Default value: the colour space’s initial value, representing black'&gt;	^self objectAt: #BC ifAbsent: [self G Group CS initialColourValues]</body><body package="PDF XObjects">G	&lt;type: #TransparencyGroup&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'A transparency group XObject to be used as the source of alpha or colour values for deriving the mask.If the subtype S is Luminosity, the group attributes dictionary shall contain a CS entry defining the colour space in which the compositing computation is to be performed'&gt;	^self objectAt: #G</body><body package="PDF XObjects">S	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A subtype specifying the method to be used in deriving the mask values from the transparency group specified by the G entry:	Alpha		The group’s computed alpha shall be used, disregarding its colour	Luminosity	The group’s computed colour shall be converted to a single-component luminosity value'&gt;	^self objectAt: #S</body><body package="PDF XObjects">TR	&lt;type: #Function&gt;	&lt;type: #Name&gt;	&lt;attribute: 5 documentation: 'A function object specifying the transfer function to be used in deriving the mask values.The function shall accept one input, the computed group alpha or luminosity (depending on the value of the subtype S), and shall return one output, the resulting mask value.The input shall be in the range 0.0 to 1.0.The computed output shall be in the range 0.0 to 1.0; if it falls outside this range, it shall be forced to the nearest valid value.The name Identity may be specified in place of a function object to designate the identity function'&gt;	^self objectAt: #TR ifAbsent: [#Identity asPDF]</body><body package="PDF XObjects">Type	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The type of PDF object that this dictionary describes.'&gt;	^self objectAt: #Type ifAbsent: [#Mask asPDF]</body></methods><methods><class-id>Graphics.PDF.Dash</class-id> <category>accessing entries</category><body package="PDF Graphics">array	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The dash array’s elements shall be numbers that specify the lengths of alternating dashes and gaps; the numbers shall be nonnegative and not all zero'&gt;	^self objectAt: 1 ifNil: [#() asPDF]</body><body package="PDF Graphics">offset	&lt;type: #Number&gt;	&lt;attribute: 2 documentation: 'The dash array’s elements shall be numbers that specify the lengths of alternating dashes and gaps; the numbers shall be nonnegative and not all zero'&gt;	^self objectAt: 2 ifNil: [0 asPDF]</body></methods><methods><class-id>Graphics.PDF.OptionalContentConfiguration</class-id> <category>accessing entries</category><body package="PDF Data Structures">AS	&lt;typeArrayOf: #OptionalContentUsageApplication&gt;	&lt;attribute: 7 documentation: 'An array of usage application dictionaries specifying which usage dictionary categories shall be consulted by conforming readers to automatically set the states of optional content groups based on external factors, such as the current system language or viewing magnification, and when they shall be applied'&gt;	^self objectAt: #AS ifAbsent: [#() asPDF]</body><body package="PDF Data Structures">BaseState	&lt;type: #Name&gt;	&lt;attribute: 3 documentation: 'Used to initialize the states of all the optional content groups in a document when this configuration is applied.The value of this entry shall be one of the following names:	ON The states of all groups shall be turned ON.	OFF The states of all groups shall be turned OFF.	Unchanged The states of all groups shall be left unchanged.After this initialization, the contents of the ON and OFF arrays shall beprocessed, overriding the state of the groups included in the arrays.If BaseState is present in the document’s default configuration dictionary, its value shall be ON.'&gt;	^self objectAt: #BaseState ifAbsent: [#ON asPDF]</body><body package="PDF Data Structures">Creator	&lt;type: #Textstring&gt;	&lt;attribute: 2 documentation: 'Name of the application or feature that created this configuration dictionary'&gt;	^self objectAt: #Creator ifAbsent: [Textstring empty]</body><body package="PDF Data Structures">Intent	&lt;type: #Name&gt;	&lt;typeArrayOf: #Name&gt;	&lt;attribute: 6 documentation: 'A single intent name or an array containing any combination of names.It shall be used to determine which optional content groups’ states to consider and which to ignore in calculating the visibility of content.PDF defines two intent names, View and Design.In addition, the name All shall indicate the set of all intents, including those not yet defined.The value shall be View for the document’s default configuration'&gt;	^self objectAt: #Intent ifAbsent: [#View asPDF]</body><body package="PDF Data Structures">ListMode	&lt;type: #Name&gt;	&lt;attribute: 9 documentation: 'A name specifying which optional content groups in the Order array shall be displayed to the user.Valid values shall be:	AllPages 		Display all groups in the Order array.	VisiblePages 	Display only those groups in the Order array that are referenced by one or more visible pages'&gt;	^self objectAt: #ListMode ifAbsent: [#AllPages asPDF]</body><body package="PDF Data Structures">Locked	&lt;type: #PDFArray&gt;	&lt;version: 6&gt;	&lt;attribute: 11 documentation: 'An array of optional content groups that shall be locked when this configuration is applied.The state of a locked group cannot be changed through the user interface of a conforming reader.Conforming writers can use this entry to prevent the visibility of content that depends on these groups from being changed by users.A conforming reader may allow the states of optional content groups from being changed by means other than the user interface, such as JavaScript or items in the AS entry of a configuration dictionary'&gt;	^self objectAt: #Locked ifAbsent: [#() asPDF]</body><body package="PDF Data Structures">Name	&lt;type: #Textstring&gt;	&lt;attribute: 1 documentation: 'A name for the configuration, suitable for presentation in a user interface'&gt;	^self objectAt: #Name ifAbsent: [Textstring empty]</body><body package="PDF Data Structures">OFF	&lt;typeArrayOf: #OptionalContentGroup&gt;	&lt;attribute: 5 documentation: 'An array of optional content groups whose state shall beset to OFF when this configuration is applied.If the BaseState entry is OFF, this entry is redundant'&gt;	^self objectAt: #OFF ifAbsent: [#() asPDF]</body><body package="PDF Data Structures">ON	&lt;typeArrayOf: #OptionalContentGroup&gt;	&lt;attribute: 4 documentation: 'An array of optional content groups whose state shall beset to ON when this configuration is applied.If the BaseState entry is ON, this entry is redundant'&gt;	^self objectAt: #ON ifAbsent: [#() asPDF]</body><body package="PDF Data Structures">Order	&lt;type: #PDFArray&gt;	&lt;attribute: 8 documentation: 'An array specifying the order for presentation of optional content groups in a conforming reader’s user interface.The array elements may include the following objects:	Optional content group dictionaries, whose Name entry shall be displayed in the user interface by the conforming reader.	Arrays of optional content groups which may be displayed by a conforming reader in a tree or outline structure. Each nested array may optionally have as its first element a text string to be used as a non-selectable label in a conforming reader’s user interface.	Text labels in nested arrays shall be used to present collections of related optional content groups, and not to communicate actual nesting of content inside multiple layers of groups.To reflect actual nesting of groups in the content, such as for layers with sublayers, nested arrays of groups without a text label shall be used.	An empty array [] explicitly specifies that no groups shall be presented.In the default configuration dictionary, the default value shall be an empty array; in other configuration dictionaries, the default shall be the Order value from the default configuration dictionary.Any groups not listed in this array shall not be presented in any user interface that uses the configuration'&gt;	^self objectAt: #Order ifAbsent: [#() asPDF]</body><body package="PDF Data Structures">RBGroups	&lt;typeArrayOf: #PDFArray&gt;	&lt;attribute: 10 documentation: 'An array consisting of one or more arrays, each of which represents a collection of optional content groups whose states shall be intended to follow a radio button paradigm.That is, the state of at most one optional content group in each array shall be ON at a time.If one group is turned ON, all others shall be turned OFF.However, turning a group from ON to OFF does not force any other group to be turned ON.An empty array [] explicitly indicates that no such collections exist.In the default configuration dictionary, the default value shall be an empty array; in other configuration dictionaries, the default is the RBGroups value from the default configuration dictionary'&gt;	^self objectAt: #RBGroups ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.Matrix</class-id> <category>accessing entries</category><body package="PDF Graphics">a	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'Matrix element'&gt;	^self objectAt: 1 ifNil: [0 asPDF]</body><body package="PDF Graphics">b	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'Matrix element'&gt;	^self objectAt: 2 ifNil: [0 asPDF]</body><body package="PDF Graphics">c	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'Matrix element'&gt;	^self objectAt: 3 ifNil: [0 asPDF]</body><body package="PDF Graphics">d	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'Matrix element'&gt;	^self objectAt: 4 ifNil: [0 asPDF]</body><body package="PDF Graphics">e	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 5 documentation: 'Matrix element'&gt;	^self objectAt: 5 ifNil: [0 asPDF]</body><body package="PDF Graphics">f	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 6 documentation: 'Matrix element'&gt;	^self objectAt: 6 ifNil: [0 asPDF]</body></methods><methods><class-id>Graphics.PDF.OptionalContentUsage</class-id> <category>accessing entries</category><body package="PDF Data Structures">CreatorInfo	&lt;type: #OptionalContentUsageCreatorInfo&gt;	&lt;attribute: 1 documentation: 'A dictionary used by the creating application to store application-specific data associated with this optional content group.It shall contain two required entries:	Creator 	A text string specifying the application that created the group.	Subtype 	A name defining the type of content controlled by the group. Suggested values include but shall not be limited to Artwork, for graphic-design or publishing applications, and Technical, for technical designs such as building plans or schematics.Additional entries may be included to present information relevant to the creating application or related applications.Groups whose Intent entry contains Design typically include a CreatorInfo entry.'&gt;	^self objectAt: #CreatorInfo ifAbsent: [Dictionary empty]</body><body package="PDF Data Structures">Export	&lt;type: #Dictionary&gt;	&lt;attribute: 3 documentation: 'A dictionary containing one entry, ExportState, a name whose value shall be either ON or OFF.This value shall indicate the recommended state for content in this group when the document (or part of it) is saved by a conforming reader to a format that does not support optional content (for example, a raster image format).'&gt;	^self objectAt: #Export ifAbsent: [Dictionary empty]</body><body package="PDF Data Structures">Language	&lt;type: #OptionalContentUsageLanguage&gt;	&lt;attribute: 2 documentation: 'A dictionary specifying the language of the content controlled by this optional content group.It may contain the following two entries:	Lang (required) 		A text string that specifies a language and possibly a locale. For example, es-MX represents Mexican Spanish.	Preferred (optional) 	A name whose values shall be either ON or OFF. Default value: OFF. It shall be used by conforming readers when there is a partial match but no exact match between the system language and the language strings in all usage dictionaries'&gt;	^self objectAt: #Language ifAbsent: [Dictionary empty]</body><body package="PDF Data Structures">PageElement	&lt;type: #Dictionary&gt;	&lt;attribute: 8 documentation: 'A dictionary declaring that the group contains a pagination artifact.It shall contain one entry, Subtype, whose value shall be a name that is either	HF (header/footer), 	FG (foreground image or graphic), 	BG (background image or graphic), or 	L (logo)'&gt;	^self objectAt: #PageElement ifAbsent: [Dictionary empty]</body><body package="PDF Data Structures">Print	&lt;type: #Dictionary&gt;	&lt;attribute: 5 documentation: 'A dictionary specifying that the content in this group is shall be used when printing.It may contain the following optional entries:	Subtype 	A name object specifying the kind of content controlled by the group; for example, Trapping, PrintersMarks and Watermark.	PrintState 	A name that shall be either ON or OFF, indicating that the group shall be set to that state when the document is printed from a conforming reader'&gt;	^self objectAt: #Print ifAbsent: [Dictionary empty]</body><body package="PDF Data Structures">User	&lt;type: #Dictionary&gt;	&lt;attribute: 7 documentation: 'A dictionary specifying one or more users for whom this optional content group is primarily intended.Each dictionary shall have two required entries:	Type 	A name object that shall be either Ind (individual), Ttl (title), or Org (organization).	Name 	A text string or array of text strings representing the name(s) of the individual, position or organization'&gt;	^self objectAt: #User ifAbsent: [Dictionary empty]</body><body package="PDF Data Structures">View	&lt;type: #Dictionary&gt;	&lt;attribute: 6 documentation: 'A dictionary that shall have a single entry, ViewState, a name that shall have a value of either ON or OFF, indicating that the group shall be set to that state when the document is opened in a conforming reader.'&gt;	^self objectAt: #View ifAbsent: [Dictionary empty]</body><body package="PDF Data Structures">Zoom	&lt;type: #Dictionary&gt;	&lt;attribute: 4 documentation: 'A dictionary specifying a range of magnifications at which the content in this optional content group is best viewed.It shall contain one or both of the following entries:	min 	The minimum recommended magnification factor at which the group shall be ON. Default value: 0.	max 	The magnification factor below which the group shall be ON. Default value: infinity'&gt;	^self objectAt: #Zoom ifAbsent: [Dictionary empty]</body></methods><methods><class-id>Graphics.PDF.PrinterMarkAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">MN	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'An arbitrary name identifying the type of printer’s mark, such as ColorBar or RegistrationTarget.'&gt;	^self objectAt: #MN ifAbsent: [nil asPDF]</body></methods><methods><class-id>Graphics.PDF.Encoding</class-id> <category>accessing entries</category><body package="PDF Fonts">BaseEncoding	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The base encoding—that is, the encoding from which the Differences entry (if present) describes differences—specified as the name of a predefined encoding MacRomanEncoding, MacExpertEncoding, or WinAnsiEncoding.If this entry is absent, the Differences entry describes differences from an implicit base encoding. For a font program that is embedded in the PDF file, the implicit base encoding is the font program’s built-in encoding, as described above and further elaborated in the sections on specific font types below. Otherwise, for a nonsymbolic font, it is StandardEncoding, and for a symbolic font, it is the font’s built-in encoding.'&gt;	^self objectAt: #BaseEncoding ifAbsent: [nil asPDF]</body><body package="PDF Fonts">Differences	&lt;type: #PDFArray&gt;	&lt;attribute: 2 documentation: 'An array describing the differences from the encoding specified by BaseEncoding or, if BaseEncoding is absent, from an implicit base encoding.'&gt;	^self objectAt: #Differences ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.CIDFontType2</class-id> <category>accessing entries</category><body package="PDF Fonts">CIDToGIDMap	&lt;type: #Stream&gt;	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'A specification of the mapping from CIDs to glyph indices.If the value is a stream, the bytes in the stream shall contain the mapping from CIDs to glyph indices: the glyph index for a particular CID value c shall be a 2-byte value stored in bytes 2 × c and 2 × c + 1, where the first byte shall be the high-order byte.If the value of CIDToGIDMap is a name, it shall be Identity, indicating that the mapping between CIDs and glyph indices is the identity mapping.This entry may appear only in a Type 2 CIDFont whose associated TrueType font program is embedded in the PDF file'&gt;	^self objectAt: #CIDToGIDMap ifAbsent: [#Identity asPDF]</body></methods><methods><class-id>Graphics.PDF.FileIdentifier</class-id> <category>accessing entries</category><body package="PDF Files">changingID	&lt;type: #AsciiString&gt;	&lt;type: #EncodedString&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The second byte string shall be a changing identifier based on the file’s contents at the time it was last updated'&gt;	^self objectAt: 2</body><body package="PDF Files">permanentID	&lt;type: #AsciiString&gt;	&lt;type: #EncodedString&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The first byte string shall be a permanent identifier based on the contents of the file at the time it was originally created and shall not change when the file is incrementally updated'&gt;	^self objectAt: 1</body></methods><methods><class-id>Graphics.PDF.WatermarkAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">FixedPrint	&lt;type: #FixedPrint&gt;	&lt;attribute: 1 documentation: 'A fixed print dictionary that specifies how this annotation shall be drawn relative to the dimensions of the target media.If this entry is not present, the annotation shall be drawn without any special consideration for the dimensions of the target media.If the dimensions of the target media are not known at the time of drawing, drawing shall be done relative to the dimensions specified by the page’s MediaBox entry.'&gt;	^self objectAt: #FixedPrint ifAbsent: [FixedPrint empty]</body></methods><methods><class-id>Graphics.PDF.NameTreeLeaf</class-id> <category>accessing entries</category><body package="PDF Data Structures">Limits	&lt;typeArrayOf: #String&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'Shall be an array of two strings, that shall specify the (lexically) least and greatest keys included in the Names array of a leaf node or in the Names arrays of any leaf nodes that are descendants of an intermediate node.'&gt;	^self objectAt: #Limits</body><body package="PDF Data Structures">Names	&lt;type: #PDFArray&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'Shall be an array of the form	[key1 value1 key2 value2 … keyn valuen]where each key i shall be a string and the corresponding value i shall be the object associated with that key.The keys shall be sorted in lexical order.'&gt;	^self objectAt: #Names</body></methods><methods><class-id>Graphics.PDF.DocumentInformation</class-id> <category>accessing entries</category><body package="PDF Files">Author	&lt;type: #Textstring&gt;	&lt;attribute: 2 documentation: 'The name of the person who created the document.'&gt;	^self objectAt: #Author ifAbsent: [Textstring empty]</body><body package="PDF Files">CreationDate	&lt;type: #Date&gt;	&lt;attribute: 7 documentation: 'The date and time the document was created, in human-readable form.'&gt;	^self objectAt: #CreationDate ifAbsent: [nil asPDF]</body><body package="PDF Files">Creator	&lt;type: #Textstring&gt;	&lt;attribute: 5 documentation: 'If the document was converted to PDF from another format, the name of the conforming product that created the original document from which it was converted.'&gt;	^self objectAt: #Creator ifAbsent: [Textstring empty]</body><body package="PDF Files">GTS_PDFXVersion	&lt;type: #Textstring&gt;	&lt;version: 3&gt;	&lt;attribute: 10 documentation: 'PDF/X conformance level identifier	The value of the pdfxid:GTS_PDFXVersion property for PDF/X-4 files prepared in accordance with this part of ISO 15930 is PDF/X-4.'&gt;	^self objectAt: #GTS_PDFXVersion ifAbsent: [Textstring empty]</body><body package="PDF Files">Keywords	&lt;type: #Textstring&gt;	&lt;version: 1&gt;	&lt;attribute: 4 documentation: 'Keywords associated with the document.'&gt;	^self objectAt: #Keywords ifAbsent: [Textstring empty]</body><body package="PDF Files">ModDate	&lt;type: #Date&gt;	&lt;version: 1&gt;	&lt;attribute: 8 documentation: '(Required if PieceInfo is present in the document catalogue) The date and time the document was most recently modified, in human-readable form.'&gt;	^self objectAt: #ModDate ifAbsent: [nil asPDF]</body><body package="PDF Files">Producer	&lt;type: #Textstring&gt;	&lt;attribute: 6 documentation: 'If the document was converted to PDF from another format, the name of the conforming product that converted it to PDF.'&gt;	^self objectAt: #Producer ifAbsent: [Textstring empty]</body><body package="PDF Files">Subject	&lt;type: #Textstring&gt;	&lt;version: 1&gt;	&lt;attribute: 3 documentation: 'The subject of the document.'&gt;	^self objectAt: #Subject ifAbsent: [Textstring empty]</body><body package="PDF Files">Title	&lt;type: #Textstring&gt;	&lt;attribute: 1 documentation: 'The document’s title.'&gt;	^self objectAt: #Title ifAbsent: [Textstring empty]</body><body package="PDF Files">Trapped	&lt;type: #Name&gt;	&lt;version: 3&gt;	&lt;attribute: 9 documentation: 'A name object indicating whether the document has been modified to include trapping information:	True		The document has been fully trapped; no further trapping shall be needed. This shall be the name True, not the boolean value true.	False		The document has not yet been trapped. This shall be the name False, not the boolean value false.	Unknown	Either it is unknown whether the document has been trapped or it has been partly but not yet fully trapped; some additional trapping may still be needed.NOTEThe value of this entry may be set automatically by the software creating the document’s trapping information, or it may be known only to a human operator and entered manually.'&gt;	^self objectAt: #Trapped ifAbsent: [#Unknown asPDF]</body></methods><methods><class-id>Graphics.PDF.FileSpecification</class-id> <category>accessing entries</category><body package="PDF Interactive Features">CI	&lt;typeIndirect: #Dictionary&gt;	&lt;version: 7&gt;	&lt;attribute: 13 documentation: 'A collection item dictionary, which shall be used to create the user interface for portable collections.'&gt;	^self objectAt: #CI ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">DOS	&lt;type: #String&gt;	&lt;attribute: 5 documentation: 'A file specification string representing a DOS file name.This entry is obsolescent and should not be used by conforming writers.'&gt;	^self objectAt: #DOS ifAbsent: [String empty]</body><body package="PDF Interactive Features">Desc	&lt;type: #Textstring&gt;	&lt;version: 6&gt;	&lt;attribute: 12 documentation: 'Descriptive text associated with the file specification.It shall be used for files in the EmbeddedFiles name tree.'&gt;	^self objectAt: #Desc ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">EF	&lt;type: #Dictionary&gt;	&lt;version: 3&gt;	&lt;attribute: 10 documentation: '(Required if RF is present; amended to include the UF key in PDF 1.7)A dictionary containing a subset of the keys F, UF, DOS, Mac, and Unix, corresponding to the entries by those names in the file specification dictionary.The value of each such key shall be an embedded file stream containing the corresponding file.If this entry is present, the Type entry is required and the file specification dictionary shall be indirectly referenced.The F and UF entries should be used in place of the DOS, Mac, or Unix entries.'&gt;	^self objectAt: #EF ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">F	&lt;type: #String&gt;	&lt;attribute: 3 documentation: '(Required if the DOS, Mac, and Unix entries are all absent; amended with the UF entry for PDF 1.7)A file specification string, or (if the file system is URL) a uniform resource locator.The UF entry should be used in addition to the F entry.The UF entry provides cross-platform and cross-language compatibility and the F entry provides backwards compatibility.'&gt;	^self objectAt: #F ifAbsent: [String empty]</body><body package="PDF Interactive Features">FS	&lt;type: #Name&gt;	&lt;attribute: 2 documentation: 'The name of the file system that shall be used to interpret this file specification.If this entry is present, all other entries in the dictionary shall be interpreted by the designated file system.PDF shall define only one standard file system name, URL; an application can register other names.This entry shall be independent of the F, UF, DOS, Mac, and Unix entries.'&gt;	^self objectAt: #FS ifAbsent: [#URL asPDF]</body><body package="PDF Interactive Features">ID	&lt;type: #FileIdentifier&gt;	&lt;attribute: 8 documentation: 'An array of two byte strings constituting a file identifier that should be included in the referenced file.NOTE	The use of this entry improves an application’s chances of finding the intended file and allows it to warn the user if the file has changed since the link was made.'&gt;	^self objectAt: #ID ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">Mac	&lt;type: #String&gt;	&lt;attribute: 6 documentation: 'A file specification string representing a Mac OS file name.This entry is obsolescent and should not be used by conforming writers.'&gt;	^self objectAt: #Mac ifAbsent: [String empty]</body><body package="PDF Interactive Features">RF	&lt;type: #Dictionary&gt;	&lt;version: 3&gt;	&lt;attribute: 11 documentation: 'A dictionary with the same structure as the EF dictionary, which shall be present.Each key in the RF dictionary shall also be present in the EF dictionary.Each value shall be a related files array identifying files that are related to the corresponding file in the EF dictionary.If this entry is present, the Type entry is required and the file specification dictionary shall be indirectly referenced.'&gt;	^self objectAt: #RF ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">Type	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: '(Required if an EF or RF entry is present; recommended always)The type of PDF object that this dictionary describes; shall be Filespec for a file specification dictionary.'&gt;	^self objectAt: #Type ifAbsent: [#Filespec asPDF]</body><body package="PDF Interactive Features">UF	&lt;type: #Textstring&gt;	&lt;version: 7&gt;	&lt;attribute: 4 documentation: '(Optional, but recommended if the F entry exists in the dictionary)A Unicode text string that provides file specification.This is a text string encoded using PDFDocEncoding or UTF-16BE with a leading byte-order marker.The F entry should be included along with this entry for backwards compatibility reasons.'&gt;	^self objectAt: #UF ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">Unix	&lt;type: #String&gt;	&lt;attribute: 7 documentation: 'A file specification string representing a Unix file name.This entry is obsolescent and should not be used by conforming writers.'&gt;	^self objectAt: #Unix ifAbsent: [String empty]</body><body package="PDF Interactive Features">V	&lt;type: #Boolean&gt;	&lt;version: 2&gt;	&lt;attribute: 9 documentation: 'A flag indicating whether the file referenced by the file specification is volatile (changes frequently with time).If the value is true, applications shall not cache a copy of the file.For example, a movie annotation referencing a URL to a live video camera could set this flag to true to notify the conforming reader that it should re-acquire the movie each time it is played.'&gt;	^self objectAt: #V ifAbsent: [false asPDF]</body></methods><methods><class-id>Graphics.PDF.ExtGState</class-id> <category>accessing entries</category><body package="PDF Graphics">AIS	&lt;type: #Boolean&gt;	&lt;version: 4&gt;	&lt;attribute: 25 documentation: 'The alpha source flag (“alpha is shape”), specifying whether the current soft mask and alpha constant shall beinterpreted as shape values (true) or opacity values (false).'&gt;	^self objectAt: #AIS</body><body package="PDF Graphics">BG	&lt;type: #FunctionDictionary&gt;	&lt;type: #FunctionStream&gt;	&lt;attribute: 11 documentation: 'The black-generation function, which maps the interval [0.0 1.0] to the interval [0.0 1.0].'&gt;	^self objectAt: #BG</body><body package="PDF Graphics">BG2	&lt;type: #FunctionDictionary&gt;	&lt;type: #FunctionStream&gt;	&lt;type: #Name&gt;	&lt;version: 3&gt;	&lt;attribute: 12 documentation: 'Same as BG except that the value may also be the name Default, denoting the black-generation function that was in effect at the start of the page. If both BG and BG2 are present in the same graphics state parameter dictionary, BG2 shall take precedence.'&gt;	^self objectAt: #BG2</body><body package="PDF Graphics">BM	&lt;type: #Name&gt;	&lt;typeArrayOf: #Name&gt;	&lt;version: 4&gt;	&lt;attribute: 21 documentation: 'The current blend mode to be used in the transparent imaging model.'&gt;	^self objectAt: #BM</body><body package="PDF Graphics">CA	&lt;type: #Number&gt;	&lt;version: 4&gt;	&lt;attribute: 23 documentation: 'The current stroking alpha constant, specifying the constant shape or constant opacity value that shall be used for stroking operations in the transparent imaging model.'&gt;	^self objectAt: #CA</body><body package="PDF Graphics">D	&lt;type: #Dash&gt;	&lt;version: 3&gt;	&lt;attribute: 5 documentation: 'The line dash pattern, expressed as an array of the form [dashArray dashPhase], where dashArray shall be itself an array and dashPhase shall be an integer.'&gt;	^self objectAt: #D</body><body package="PDF Graphics">FL	&lt;type: #Number&gt;	&lt;version: 3&gt;	&lt;attribute: 18 documentation: 'The flatness tolerance.'&gt;	^self objectAt: #FL</body><body package="PDF Graphics">Font	&lt;type: #PDFArray&gt;	&lt;version: 3&gt;	&lt;attribute: 10 documentation: 'An array of the form [font size], where font shall be an indirect reference to a font dictionary and size shall be a number expressed in text space units. These two objects correspond to the operands of the Tf operator; however, the first operand shall be an indirect object reference instead of a resource name.'&gt;	^self objectAt: #Font</body><body package="PDF Graphics">HT	&lt;type: #Dictionary&gt;	&lt;type: #Stream&gt;	&lt;type: #Name&gt;	&lt;attribute: 17 documentation: 'The halftone dictionary or stream or the name Default, denoting the halftone that was in effect at the start of the page.'&gt;	^self objectAt: #HT ifAbsent: [#Default asPDF]</body><body package="PDF Graphics">LC	&lt;type: #Integer&gt;	&lt;version: 3&gt;	&lt;attribute: 2 documentation: 'The line cap style.'&gt;	^self objectAt: #LC</body><body package="PDF Graphics">LJ	&lt;type: #Integer&gt;	&lt;version: 3&gt;	&lt;attribute: 3 documentation: 'The line join style.'&gt;	^self objectAt: #LJ</body><body package="PDF Graphics">LW	&lt;type: #Number&gt;	&lt;version: 3&gt;	&lt;attribute: 1 documentation: 'The line width.'&gt;	^self objectAt: #LW</body><body package="PDF Graphics">ML	&lt;type: #Number&gt;	&lt;version: 3&gt;	&lt;attribute: 4 documentation: 'The miter limit.'&gt;	^self objectAt: #ML</body><body package="PDF Graphics">OP	&lt;type: #Boolean&gt;	&lt;version: 3&gt;	&lt;attribute: 7 documentation: 'A flag specifying whether to apply overprint. In PDF 1.2 and earlier, there is a single overprint parameter that applies to all painting operations. Beginning with PDF 1.3, there shall be two separate overprint parameters: one for stroking and one for all other painting operations. Specifying an OP entry shall set both parameters unless there is also an op entry in the same graphics state parameter dictionary, in which case the OP entry shall set only the overprint parameter for stroking.'&gt;	^self objectAt: #OP</body><body package="PDF Graphics">OPM	&lt;type: #Integer&gt;	&lt;version: 3&gt;	&lt;attribute: 9 documentation: 'The overprint mode.'&gt;	^self objectAt: #OPM</body><body package="PDF Graphics">RI	&lt;type: #Name&gt;	&lt;version: 3&gt;	&lt;attribute: 6 documentation: 'The name of the rendering intent.'&gt;	^self objectAt: #RI</body><body package="PDF Graphics">SA	&lt;type: #Boolean&gt;	&lt;attribute: 20 documentation: 'A flag specifying whether to apply automatic stroke adjustment.'&gt;	^self objectAt: #SA</body><body package="PDF Graphics">SM	&lt;type: #Number&gt;	&lt;version: 3&gt;	&lt;attribute: 19 documentation: 'The smoothness tolerance.'&gt;	^self objectAt: #SM</body><body package="PDF Graphics">SMask	&lt;type: #SoftMask&gt;	&lt;type: #Name&gt;	&lt;version: 4&gt;	&lt;attribute: 22 documentation: 'The current soft mask, specifying the mask shape or mask opacity values that shall be used in the transparent imaging model.Although the current soft mask is sometimes referred to as a “soft clip,” altering it with the gs operator completely replaces the old value with the new one, rather than intersecting the two as is done with the current clipping path parameter.'&gt;	^self objectAt: #SMask</body><body package="PDF Graphics">TK	&lt;type: #Boolean&gt;	&lt;version: 4&gt;	&lt;attribute: 26 documentation: 'The text knockout flag, shall determine the behaviour of overlapping glyphs within a text object in the transparent imaging model.'&gt;	^self objectAt: #TK</body><body package="PDF Graphics">TR	&lt;type: #Function&gt;	&lt;typeArrayOf: #Function&gt;	&lt;type: #Identity&gt;	&lt;attribute: 15 documentation: 'The transfer function, which maps the interval [0.0 1.0] to the interval [0.0 1.0]. The value shall be either a single function (which applies to all process colorants) or an array of four functions (which apply to the process colorants individually). The name Identity may be used to represent the identity function.'&gt;	^self objectAt: #TR</body><body package="PDF Graphics">TR2	&lt;type: #Function&gt;	&lt;typeArrayOf: #Function&gt;	&lt;type: #Identity&gt;	&lt;version: 3&gt;	&lt;attribute: 16 documentation: 'Same as TR except that the value may also be the name Default, denoting the transfer function that was in effect at the start of the page. If both TR and TR2 are present in the same graphics state parameter dictionary, TR2 shall take precedence.'&gt;	^self objectAt: #TR2</body><body package="PDF Graphics">Type	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'The type of PDF object that this dictionary describes; shall be ExtGState for a graphics state parameter dictionary.'&gt;	^self objectAt: #Type ifAbsent: [nil asPDF]</body><body package="PDF Graphics">UCR	&lt;type: #FunctionDictionary&gt;	&lt;type: #FunctionStream&gt;	&lt;attribute: 13 documentation: 'The undercolor-removal function, which maps the interval [0.0 1.0] to the interval [-1.0 1.0].'&gt;	^self objectAt: #UCR</body><body package="PDF Graphics">UCR2	&lt;type: #FunctionDictionary&gt;	&lt;type: #FunctionStream&gt;	&lt;type: #Name&gt;	&lt;version: 3&gt;	&lt;attribute: 14 documentation: 'Same as UCR except that the value may also be the name Default, denoting the undercolor-removal function that was in effect at the start of the page. If both UCR and UCR2 are present in the same graphics state parameter dictionary, UCR2 shall takeprecedence.'&gt;	^self objectAt: #UCR2</body><body package="PDF Graphics">ca	&lt;type: #Number&gt;	&lt;version: 4&gt;	&lt;attribute: 24 documentation: 'Same as CA, but for nonstroking operations.'&gt;	^self objectAt: #ca</body><body package="PDF Graphics">op	&lt;type: #Boolean&gt;	&lt;version: 3&gt;	&lt;attribute: 8 documentation: 'A flag specifying whether to apply overprint  for painting operations other than stroking. If this entry is absent, the OP entry, if any, shall also set this parameter.'&gt;	^self objectAt: #op</body></methods><methods><class-id>Graphics.PDF.NumberTreeLeaf</class-id> <category>accessing entries</category><body package="PDF Data Structures">Nums	&lt;type: #PDFArray&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'Shall be an array of the form	[key1 value1 key2 value2 … keyn valuen]where each key i is an integer and the corresponding value i shall be the object associated with that key.The keys shall be sorted in numerical order, analogously to the arrangement of keys in a name tree'&gt;	^self objectAt: #Nums</body></methods><methods><class-id>Graphics.PDF.Movie</class-id> <category>accessing entries</category><body package="PDF Interactive Features">Aspect	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 2 documentation: 'The width and height of the movie’s bounding box, in pixels, and shall be specified as [width height].This entry should be omitted for a movie consisting entirely of sound with no visible images.'&gt;	^self objectAt: #Aspect ifAbsent: [#(0 0) asPDF]</body><body package="PDF Interactive Features">F	&lt;type: #FileSpecification&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'A file specification identifying a self-describing movie file.NOTE	The format of a self-describing movie file shall be left unspecified, and there is no guarantee of portability.'&gt;	^self objectAt: #F</body><body package="PDF Interactive Features">Poster	&lt;type: #Boolean&gt;	&lt;type: #ImageXObject&gt;	&lt;attribute: 4 documentation: 'A flag or stream specifying whether and how a poster image representing the movie shall be displayed.If this value is a stream, it shall contain an image XObject to be displayed as the poster.If it is the boolean value true, the poster image shall be retrieved from the movie file; if it is false, no poster shall be displayed.'&gt;	^self objectAt: #Poster ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">Rotate	&lt;type: #Integer&gt;	&lt;attribute: 3 documentation: 'The number of degrees by which the movie shall be rotated clockwise relative to the page.The value shall be a multiple of 90.'&gt;	^self objectAt: #Rotate ifAbsent: [0 asPDF]</body></methods><methods><class-id>Graphics.PDF.ICCBased</class-id> <category>accessing entries</category><body package="PDF Colour">stream	&lt;type: #ICCProfileStream&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A dictionary containing parameters that further characterize the space. The entries in this dictionary have specific interpretations that depend on the colour space; some entries are required and some are optional.'&gt;	^self objectAt: 2</body></methods><methods><class-id>Graphics.PDF.FixedPrint</class-id> <category>accessing entries</category><body package="PDF Interactive Features">H	&lt;type: #Number&gt;	&lt;attribute: 2 documentation: 'The amount to translate the associated content horizontally, as a percentage of the width of the target media (or if unknown, the width of the page’s MediaBox).1.0 represents 100% and 0.0 represents 0%.Negative values should not be used, since they may cause content to be drawn off the page.'&gt;	^self objectAt: #H ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">Matrix	&lt;type: #Matrix&gt;	&lt;attribute: 1 documentation: 'The matrix used to transform the annotation’s rectangle before rendering.When positioning content near the edge of a page, this entry should be used to provide a reasonable offset to allow for nonburnable margins.'&gt;	^self objectAt: #Matrix ifAbsent: [Matrix identity]</body><body package="PDF Interactive Features">V	&lt;type: #Number&gt;	&lt;attribute: 3 documentation: 'The amount to translate the associated content vertically, as a percentage of the height of the target media (or if unknown, the height of the page’s MediaBox).1.0 represents 100% and 0.0 represents 0%.Negative values should not be used, since they may cause content to be drawn off the page.'&gt;	^self objectAt: #V ifAbsent: [0 asPDF]</body></methods><methods><class-id>Graphics.PDF.StandardFont</class-id> <category>accessing entries</category><body package="PDF Fonts">FirstChar	&lt;type: #Integer&gt;	&lt;attribute: 1 documentation: 'The first character code defined in the font’s Widths array.Beginning with PDF 1.5, the special treatment given to the standard 14 fonts is deprecated.Conforming writers should represent all fonts using a complete font descriptor.For backwards capability, conforming readers shall still provide the special treatment identified for the standard 14 fonts.'&gt;	^self objectAt: #FirstChar ifAbsent: [0 asPDF]</body><body package="PDF Fonts">FontDescriptor	&lt;typeIndirect: #FontDescriptor&gt;	&lt;attribute: 4 documentation: 'A font descriptor describing the font’s metrics other than its glyph widths (see 9.8, "Font Descriptors"”\).For the standard 14 fonts, the entries FirstChar, LastChar, Widths, and FontDescriptor shall either all be present or all be absent.Ordinarily, these dictionary keys may be absent; specifying them enables a standard font to be overridden.Beginning with PDF 1.5, the special treatment given to the standard 14 fonts is deprecated.Conforming writers should represent all fonts using a complete font descriptor.For backwards capability, conforming readers shall still provide the special treatment identified for the standard 14 fonts.'&gt;	^self objectAt: #FontDescriptor</body><body package="PDF Fonts">LastChar	&lt;type: #Integer&gt;	&lt;attribute: 2 documentation: 'The last character code defined in the font’s Widths array.Beginning with PDF 1.5, the special treatment given to the standard 14 fonts is deprecated.Conforming writers should represent all fonts using a complete font descriptor.For backwards capability, conforming readers shall still provide the special treatment identified for the standard 14 fonts.'&gt;	^self objectAt: #LastChar ifAbsent: [255 asPDF]</body><body package="PDF Fonts">Widths	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 3	documentation: '(indirect reference preferred)An array of (LastChar - FirstChar + 1) widths, each element being the glyph width for the character code that equals FirstChar plus the array index.For character codes outside the range FirstChar to LastChar, the value of MissingWidth from the FontDescriptor entry for this font shall be used.The glyph widths shall be measured in units in which 1000 units correspond to 1 unit in text space.These widths shall be consistent with the actual widths given in the font program.Beginning with PDF 1.5, the special treatment given to the standard 14 fonts is deprecated.Conforming writers should represent all fonts using a complete font descriptor.For backwards capability, conforming readers shall still provide the special treatment identified for the standard 14 fonts.'&gt;	^self objectAt: #Widths ifAbsent: [self standardWidths]</body></methods><methods><class-id>Graphics.PDF.CalGray</class-id> <category>accessing entries</category><body package="PDF Colour">dictionary	&lt;type: #CalGrayColourSpaceDictionary&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A dictionary containing parameters that further characterize the space. The entries in this dictionary have specific interpretations that depend on the colour space; some entries are required and some are optional.'&gt;	^self objectAt: 2</body></methods><methods><class-id>Graphics.PDF.Appearance</class-id> <category>accessing entries</category><body package="PDF Interactive Features">D	&lt;type: #FormXObject&gt;	&lt;type: #Dictionary&gt;	&lt;attribute: 3 documentation: 'The annotation’s down appearance.Default value: the value of the N entry.'&gt;	^self objectAt: #D ifAbsent: [nil asPDF]</body><body package="PDF Interactive Features">N	&lt;type: #FormXObject&gt;	&lt;type: #Dictionary&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The annotation’s normal appearance.'&gt;	^self objectAt: #N</body><body package="PDF Interactive Features">R	&lt;type: #FormXObject&gt;	&lt;type: #Dictionary&gt;	&lt;attribute: 2 documentation: 'The annotation’s rollover appearance.Default value: the value of the N entry.'&gt;	^self objectAt: #R ifAbsent: [nil asPDF]</body></methods><methods><class-id>Graphics.PDF.PostScriptXObject</class-id> <category>accessing entries</category><body package="PDF XObjects">Level1	&lt;type: #Stream&gt;	&lt;attribute: 1 documentation: 'A stream whose contents shall be used in place of the PostScript XObject’s stream when the target PostScript interpreter is known to support only LanguageLevel 1.'&gt;	^self objectAt: #Level1</body></methods><methods><class-id>Graphics.PDF.UncolouredPattern</class-id> <category>accessing entries</category><body package="PDF Colour">underlyingColourSpace	&lt;type: #ColourSpace&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A Pattern colour space representing an uncoloured tiling pattern shall have a parameter: an object identifying the underlying colour space in which the actual colour of the pattern shall be specified. The underlying colour space shall be given as the second element of the array that defines the Pattern colour space.'&gt;	^self objectAt: 2</body></methods><methods><class-id>Graphics.PDF.TextAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">Name	&lt;type: #Name&gt;	&lt;attribute: 2 documentation: 'The name of an icon that shall be used in displaying the annotation.Conforming readers shall provide predefined icon appearances for at least the following standard names:	Comment, Key, Note, Help, NewParagraph, Paragraph, InsertAdditional names may be supported as well.The annotation dictionary’s AP entry, if present, shall take precedence over the Name entry.'&gt;	^self objectAt: #Name ifAbsent: [#Note asPDF]</body><body package="PDF Interactive Features">Open	&lt;type: #Boolean&gt;	&lt;attribute: 1 documentation: 'A flag specifying whether the annotation shall initially be displayed open.'&gt;	^self objectAt: #Open ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">State	&lt;type: #Textstring&gt;	&lt;version: 5&gt;	&lt;attribute: 3 documentation: 'The state to which the original annotation shall be set.Default: (Unmarked) if StateModel is (Marked); (None) if StateModel is (Review).With StateModel (Marked) can be (Marked) or (Unmarked);with StateModel (Review) can be (Accepted), (Rejected), (Cancelled), (Completed) or (None).'&gt;	^self objectAt: #State ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">StateModel	&lt;type: #Textstring&gt;	&lt;version: 5&gt;	&lt;attribute: 4 documentation: '(Required if State is present, otherwise optional)The state model corresponding to State.Can be (Marked) or (Review)'&gt;	^self objectAt: #StateModel ifAbsent: [Textstring empty]</body></methods><methods><class-id>Graphics.PDF.OutlineItem</class-id> <category>accessing entries</category><body package="PDF Interactive Features">A	&lt;type: #Action&gt;	&lt;version: 1&gt;	&lt;attribute: 9 documentation: '(shall not be present if a Dest entry is present)The action that shall be performed when this item is activated.'&gt;	^self objectAt: #A ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">C	&lt;typeArrayOf: #Number&gt;	&lt;version: 4&gt;	&lt;attribute: 11 documentation: 'An array of three numbers in the range 0.0 to 1.0, representing the components in the DeviceRGB colour space of the colour that shall be used for the outline entry’s text.'&gt;	^self objectAt: #C ifAbsent: [#(0.0 0.0 0.0) asPDF]</body><body package="PDF Interactive Features">Count	&lt;type: #Integer&gt;	&lt;attribute: 7 documentation: '(Required if the item has any descendants)If the outline item is open, Count is the sum of the number of visible descendent outline items at all levels.The number of visible descendent outline items shall be determined by the following recursive process:	Step 1. Initialize Count to zero.	Step 2. Add to Count the number of immediate children. During repetitions of this step, update only the Count of the original outline item.	Step 3. For each of those immediate children whose Count is positive and non-zero, repeat steps 2 and 3.If the outline item is closed, Count is negative and its absolute value is the number of descendants that would be visible if the outline item were opened.'&gt;	^self objectAt: #Count</body><body package="PDF Interactive Features">Dest	&lt;type: #Name&gt;	&lt;type: #String&gt;	&lt;type: #Dest&gt;	&lt;attribute: 8 documentation: '(shall not be present if an A entry is present)The destination that shall be displayed when this item is activated.'&gt;	^self objectAt: #Dest ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">F	&lt;type: #Integer&gt;	&lt;version: 4&gt;	&lt;attribute: 12 documentation: 'A set of flags specifying style characteristics for displaying the outline item’s text.The value shall be an integer interpreted as one-bit flags specifying style characteristics for displaying the item.Bit positions within the flag word are numbered from low-order to high-order bits, with the lowest-order bit numbered 1.Bit position		Name		Meaning	1			Italic		If set to 1, display the item in italic.	2			Bold		If set to 1, display the item in bold.All other bits of the integer shall be 0.'&gt;	^self objectAt: #F ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">First	&lt;typeIndirect: #OutlineItem&gt;	&lt;attribute: 5 documentation: '(Required if the item has any descendants)The first of this item’s immediate children in the outline hierarchy.'&gt;	^self objectAt: #First</body><body package="PDF Interactive Features">Last	&lt;typeIndirect: #OutlineItem&gt;	&lt;attribute: 6 documentation: '(Required if the item has any descendants)The last of this item’s immediate children in the outline hierarchy.'&gt;	^self objectAt: #Last</body><body package="PDF Interactive Features">Next	&lt;typeIndirect: #OutlineItem&gt;	&lt;attribute: 4 documentation: '(Required for all but the last item at each level)The next item at this outline level.'&gt;	^self objectAt: #Next</body><body package="PDF Interactive Features">Parent	&lt;typeIndirect: #OutlineItem&gt;	&lt;typeIndirect: #Outlines&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The parent of this item in the outline hierarchy.The parent of a top-level item shall be the outline dictionary itself.'&gt;	^self objectAt: #Parent</body><body package="PDF Interactive Features">Prev	&lt;typeIndirect: #OutlineItem&gt;	&lt;attribute: 3 documentation: '(Required for all but the first item at each level)The previous item at this outline level.'&gt;	^self objectAt: #Prev</body><body package="PDF Interactive Features">SE	&lt;typeIndirect: #Dictionary&gt;	&lt;version: 3&gt;	&lt;attribute: 10 documentation: 'The structure element to which the item refers.'&gt;	^self objectAt: #SE ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">Title	&lt;type: #Textstring&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The text that shall be displayed on the screen for this item.'&gt;	^self objectAt: #Title</body></methods><methods><class-id>Graphics.PDF.Lab</class-id> <category>accessing entries</category><body package="PDF Colour">dictionary	&lt;type: #LabColourSpaceDictionary&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A dictionary containing parameters that further characterize the space. The entries in this dictionary have specific interpretations that depend on the colour space; some entries are required and some are optional.'&gt;	^self objectAt: 2</body></methods><methods><class-id>Graphics.PDF.Subpath class</class-id> <category>specification</category><body package="PDF Graphics">localSpecification	&lt;sequence: #segments&gt;</body></methods><methods><class-id>Graphics.PDF.StichingFunction</class-id> <category>accessing entries</category><body package="PDF Data Structures">Bounds	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'An array of k - 1 numbers that, in combination with Domain, shall define the intervals to which each function from the Functions array shall apply.Bounds elements shall be in order of increasing value, and each value shall be within the domain defined by Domain.'&gt;	^self objectAt: #Bounds</body><body package="PDF Data Structures">Encode	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'An array of 2 × k numbers that, taken in pairs, shall map each subset of the domain defined by Domain and the Bounds array to the domain of the corresponding function.'&gt;	^self objectAt: #Encode</body><body package="PDF Data Structures">Functions	&lt;typeArrayOf: #Function&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of k 1-input functions that shall make up the stitching function.The output dimensionality of all functions shall be the same, and compatible with the value of Range if Range is present.'&gt;	^self objectAt: #Functions</body></methods><methods><class-id>Graphics.PDF.ThreeDAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">ThreeDA	&lt;type: #ThreeDActivation&gt;	&lt;attribute: 3 documentation: 'An activation dictionary that defines the times at which the annotation shall be activated and deactivated and the state of the 3D artwork instance at those times.Default value: an activation dictionary containing default values for all its entries.'&gt;	^self objectAt: #'3DA' ifAbsent: [ThreeDActivation empty]</body><body package="PDF Interactive Features">ThreeDB	&lt;type: #Rectangle&gt;	&lt;attribute: 5 documentation: 'The 3D view box, which is the rectangular area in which the 3D artwork shall be drawn.It shall be within the rectangle specified by the annotation’s Rect entry and shall be expressed in the annotation’s target coordinate system.Default value: the annotation’s Rect entry, expressed in the target coordinate system.This value is [ -w/2 -h/2 w/2 h/2 ], where w and h are the width and height, respectively, of Rect.'&gt;	^self objectAt: #'3DB' ifAbsent: [Rectangle empty]</body><body package="PDF Interactive Features">ThreeDD	&lt;type: #Stream&gt;	&lt;type: #Dictionary&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'A 3D stream or 3D reference dictionary that specifies the 3D artwork to be shown.'&gt;	^self objectAt: #'3DD' ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">ThreeDI	&lt;type: #Boolean&gt;	&lt;attribute: 4 documentation: 'A flag indicating the primary use of the 3D annotation.If true, it is intended to be interactive; if false, it is intended to be manipulated programmatically, as with a JavaScript animation.Conforming readers may present different user interface controls for interactive 3D annotations (for example, to rotate, pan, or zoom the artwork) than for those managed by a script or other mechanism.'&gt;	^self objectAt: #'3DI' ifAbsent: [true asPDF]</body><body package="PDF Interactive Features">ThreeDV	&lt;type: #Dictionary&gt;	&lt;type: #Integer&gt;	&lt;type: #Textstring&gt;	&lt;type: #Name&gt;	&lt;attribute: 2 documentation: 'An object that specifies the default initial view of the 3D artwork that shall be used when the annotation is activated.It may be either a 3D view dictionary or one of the following types specifying an element in the VA array in the 3D stream:	•	An integer specifying an index into the VA array.	•	A text string matching the IN entry in one of the views in the VAarray.	•	A name that indicates the first (F), last (L), or default (D) entries in the VA array.Default value: the default view in the 3D stream object specified by 3DD.'&gt;	^self objectAt: #'3DV' ifAbsent: [Dictionary empty]</body></methods><methods><class-id>Graphics.PDF.Metadata</class-id> <category>accessing entries</category><body package="PDF Document">Subtype	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The type of metadata stream that this dictionary describes; shall be XML.'&gt;	^self objectAt: #Subtype</body></methods><methods><class-id>Graphics.PDF.ObjectStream</class-id> <category>accessing entries</category><body package="PDF Files">Extends	&lt;typeIndirect: #ObjectStream&gt;	&lt;attribute: 3 documentation: 'A reference to another object stream, of which the current object stream shall be considered an extension.Both streams are considered part of a collection of object streams.A given collection consists of a set of streams whose Extends links form a directed acyclic graph.'&gt;	^self objectAt: #Extends ifAbsent: [nil asPDF]</body><body package="PDF Files">First	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The byte offset in the decoded stream of the first compressed object.'&gt;	^self objectAt: #First</body><body package="PDF Files">N	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The number of indirect objects stored in the stream.'&gt;	^self objectAt: #N</body></methods><methods><class-id>Graphics.PDF.CalRGB</class-id> <category>accessing entries</category><body package="PDF Colour">dictionary	&lt;type: #CalRGBColourSpaceDictionary&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A dictionary containing parameters that further characterize the space. The entries in this dictionary have specific interpretations that depend on the colour space; some entries are required and some are optional.'&gt;	^self objectAt: 2</body></methods><methods><class-id>Graphics.PDF.PopupAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">Open	&lt;type: #Boolean&gt;	&lt;attribute: 2 documentation: 'A flag specifying whether the pop-up annotation shall initially be displayed open.'&gt;	^self objectAt: #Open ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">Parent	&lt;typeIndirect: #Annot&gt;	&lt;attribute: 1 documentation: 'The parent annotation with which this pop-up annotation shall be associated.If this entry is present, the parent annotation’s Contents, M, C, and T entries shall override those of the pop-up annotation itself.'&gt;	^self objectAt: #Parent ifAbsent: [Annot empty]</body></methods><methods><class-id>Graphics.PDF.BorderEffect</class-id> <category>accessing entries</category><body package="PDF Interactive Features">I	&lt;type: #Number&gt;	&lt;attribute: 2 documentation: '(valid only if the value of S is C)A number describing the intensity of the effect, in the range 0 to 2.'&gt;	^self objectAt: #I ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">S	&lt;type: #Name&gt;	&lt;attribute: 1 documentation: 'A name representing the border effect to apply.Possible values are:	S 	No effect: the border shall be as described by the annotation dictionary’s BS entry.	C 	The border should appear “cloudy”. The width and dash array specified by BS shall be honored.'&gt;	^self objectAt: #S ifAbsent: [#S asPDF]</body></methods><methods><class-id>Graphics.PDF.OptionalContentUsageApplication</class-id> <category>accessing entries</category><body package="PDF Data Structures">Category	&lt;typeArrayOf: #Name&gt;	&lt;attribute: 3 documentation: 'An array of names, each of which corresponds to a usage dictionary entry.When managing the states of the optional content groups in the OCGs array, each of the corresponding categories in the group’s usage dictionary shall be considered.'&gt;	^self objectAt: #Category ifAbsent: [#() asPDF]</body><body package="PDF Data Structures">Creator	&lt;type: #Textstring&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'A text string specifying the application that created the group'&gt;	^self objectAt: #Creator</body><body package="PDF Data Structures">Event	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'A name defining the situation in which this usage application dictionary should be used.Shall be one of View, Print, or Export'&gt;	^self objectAt: #Event</body><body package="PDF Data Structures">OCGs	&lt;typeArrayOf: #OptionalContentGroup&gt;	&lt;attribute: 2 documentation: 'An array listing the optional content groups that shall have their states automatically managed based on information in their usage dictionary'&gt;	^self objectAt: #OCGs ifAbsent: [#() asPDF]</body></methods><methods><class-id>Graphics.PDF.CoonsPatchMesh</class-id> <category>accessing entries</category><body package="PDF Shading">BitsPerFlag	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The number of bits used to represent the edge flag for each vertex.The value of BitsPerFlag shall be 2, 4, or 8, but only the least significant 2 bits in each flag value shall beused.The value for the edge flag shall be 0, 1, 2 and 3.'&gt;	^self objectAt: #BitsPerFlag</body></methods><methods><class-id>Graphics.PDF.Names</class-id> <category>accessing entries</category><body package="PDF Document">AP	&lt;type: #NameTree&gt;	&lt;version: 3&gt;	&lt;attribute: 2 documentation: 'A name tree mapping name strings to annotation appearance streams.'&gt;	^self objectAt: #AP ifAbsent: [NameTree empty]</body><body package="PDF Document">AlternatePresentations	&lt;type: #NameTree&gt;	&lt;version: 4&gt;	&lt;attribute: 9 documentation: 'A name tree mapping name strings to alternate presentations.'&gt;	^self objectAt: #AlternatePresentations ifAbsent: [NameTree empty]</body><body package="PDF Document">Dests	&lt;typeNameTreeOf: #Destination&gt;	&lt;version: 2&gt;	&lt;attribute: 1 documentation: 'A name tree mapping name strings to destinations.'&gt;	^self objectAt: #Dests ifAbsent: [NameTree empty]</body><body package="PDF Document">EmbeddedFiles	&lt;type: #NameTree&gt;	&lt;version: 4&gt;	&lt;attribute: 8 documentation: 'A name tree mapping name strings to file specifications for embedded file streams.'&gt;	^self objectAt: #EmbeddedFiles ifAbsent: [NameTree empty]</body><body package="PDF Document">IDS	&lt;type: #NameTree&gt;	&lt;version: 3&gt;	&lt;attribute: 6 documentation: 'A name tree mapping digital identifiers to Web Capture content sets.'&gt;	^self objectAt: #IDS ifAbsent: [NameTree empty]</body><body package="PDF Document">JavaScript	&lt;type: #NameTree&gt;	&lt;version: 3&gt;	&lt;attribute: 3 documentation: 'A name tree mapping name strings to document-level JavaScript actions.'&gt;	^self objectAt: #JavaScript ifAbsent: [NameTree empty]</body><body package="PDF Document">Pages	&lt;type: #NameTree&gt;	&lt;version: 3&gt;	&lt;attribute: 4 documentation: 'A name tree mapping name strings to visible pages for use in interactive forms.'&gt;	^self objectAt: #Pages ifAbsent: [NameTree empty]</body><body package="PDF Document">Renditions	&lt;type: #NameTree&gt;	&lt;version: 5&gt;	&lt;attribute: 10 documentation: 'A name tree mapping name strings (which shall have Unicode encoding) to rendition objects.'&gt;	^self objectAt: #Renditions ifAbsent: [NameTree empty]</body><body package="PDF Document">Templates	&lt;type: #NameTree&gt;	&lt;version: 3&gt;	&lt;attribute: 5 documentation: 'A name tree mapping name strings to invisible (template) pages for use in interactive forms.'&gt;	^self objectAt: #Templates ifAbsent: [NameTree empty]</body><body package="PDF Document">URLS	&lt;type: #NameTree&gt;	&lt;version: 3&gt;	&lt;attribute: 7 documentation: 'A name tree mapping uniform resource locators (URLs) to Web Capture content sets'&gt;	^self objectAt: #URLS ifAbsent: [NameTree empty]</body></methods><methods><class-id>Graphics.PDF.FunctionBasedShading</class-id> <category>accessing entries</category><body package="PDF Shading">Domain	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 1 documentation: 'An array of four numbers [xmin xmax ymin ymax] specifying the rectangular domain of coordinates over which the colour function(s) are defined.'&gt;	^self objectAt: #Domain ifAbsent: [#(0.0 1.0 0.0 1.0) asPDF]</body><body package="PDF Shading">Function	&lt;type: #Function&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'A 2-in, n-out function or an array of n 2-in, 1-out functions (where n is the number of colour components in the shading dictionary’s colour space).Each function’s domain shall be a superset of that of the shading dictionary.If the value returned by the function for a given colour component is out of range, it shall be adjusted to the nearest valid value.'&gt;	^self objectAt: #Function</body><body package="PDF Shading">Matrix	&lt;type: #Matrix&gt;	&lt;attribute: 2 documentation: 'An array of six numbers specifying a transformation matrix mapping the coordinate space specified by the Domain entry into the shading’s target coordinate space.NOTE	To map the domain rectangle [0.0 1.0 0.0 1.0] to a 1-inch square with lower-left corner at coordinates (100, 100) in default user space, the Matrix value would be [72 0 0 72 100 100].'&gt;	^self objectAt: #Matrix ifAbsent: [Matrix identity]</body></methods><methods><class-id>Graphics.PDF.PolygonAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">BE	&lt;type: #BorderEffect&gt;	&lt;attribute: 1 documentation: 'A border effect dictionary that shall describe an effect applied to the border described by the BS entry.'&gt;	^self objectAt: #BE ifAbsent: [BorderEffect empty]</body></methods><methods><class-id>Graphics.PDF.ViewerPreferences</class-id> <category>accessing entries</category><body package="PDF Interactive Features">CenterWindow	&lt;type: #Boolean&gt;	&lt;attribute: 5 documentation: 'A flag specifying whether to position the document’s window in the center of the screen.Default value: false.'&gt;	^self objectAt: #CenterWindow ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">Direction	&lt;type: #Name&gt;	&lt;version: 3&gt;	&lt;attribute: 8 documentation: 'The predominant reading order for text:	L2R	Left to right	R2L	Right to left (including vertical writing systems, such as Chinese, Japanese, and Korean)This entry has no direct effect on the document’s contents or page numbering but may be used to determine the relative positioning of pages when displayed side by side or printed n-up.Default value: L2R.'&gt;	^self objectAt: #Direction ifAbsent: [#L2R asPDF]</body><body package="PDF Interactive Features">DisplayDocTitle	&lt;type: #Boolean&gt;	&lt;version: 4&gt;	&lt;attribute: 6 documentation: 'A flag specifying whether the window’s title bar should display the document title taken from the Title entry of the document information dictionary.If false, the title bar should instead display the name of the PDF file containing the document.Default value: false.'&gt;	^self objectAt: #DisplayDocTitle ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">Duplex	&lt;type: #Name&gt;	&lt;version: 7&gt;	&lt;attribute: 14 documentation: 'The paper handling option that shall be used when printing the file from the print dialog.The following values are valid:	Simplex 				Print single-sided	DuplexFlipShortEdge 	Duplex and flip on the short edge of the sheet	DuplexFlipLongEdge 	Duplex and flip on the long edge of the sheetDefault value: none'&gt;	^self objectAt: #Duplex ifAbsent: [#none asPDF]</body><body package="PDF Interactive Features">FitWindow	&lt;type: #Boolean&gt;	&lt;attribute: 4 documentation: 'A flag specifying whether to resize the document’s window to fit the size of the first displayed page.Default value: false.'&gt;	^self objectAt: #FitWindow ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">HideMenubar	&lt;type: #Boolean&gt;	&lt;attribute: 2 documentation: 'A flag specifying whether to hide the conforming reader’s menu bar when the document is active.Default value: false.'&gt;	^self objectAt: #HideMenubar ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">HideToolbar	&lt;type: #Boolean&gt;	&lt;attribute: 1 documentation: 'A flag specifying whether to hide the conforming reader’s tool bars when the document is active.Default value: false.'&gt;	^self objectAt: #HideToolbar ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">HideWindowUI	&lt;type: #Boolean&gt;	&lt;attribute: 3 documentation: 'A flag specifying whether to hide user interface elements in the document’s window (such as scroll bars and navigation controls), leaving only the document’s contents displayed.Default value: false.'&gt;	^self objectAt: #HideWindowUI ifAbsent: [false asPDF]</body><body package="PDF Interactive Features">NonFullScreenPageMode	&lt;type: #Name&gt;	&lt;attribute: 7 documentation: 'The document’s page mode, specifying how to display the document on exiting full-screen mode:	UseNone	Neither document outline nor thumbnail images visible	UseOutlines	Document outline visible	UseThumbs	Thumbnail images visible	UseOC	Optional content group panel visibleThis entry is meaningful only if the value of the PageMode entry in the Catalog dictionary is FullScreen; it shall be ignored otherwise.Default value: UseNone.'&gt;	^self objectAt: #NonFullScreenPageMode ifAbsent: [#UseNone asPDF]</body><body package="PDF Interactive Features">NumCopies	&lt;type: #Integer&gt;	&lt;version: 7&gt;	&lt;attribute: 17 documentation: 'The number of copies that shall be printed when the print dialog is opened for this file.Values outside this range shall be ignored.Default value: as defined by the conforming reader, but typically 1'&gt;	^self objectAt: #NumCopies ifAbsent: [1 asPDF]</body><body package="PDF Interactive Features">PickTrayByPDFSize	&lt;type: #Boolean&gt;	&lt;version: 7&gt;	&lt;attribute: 15 documentation: 'A flag specifying whether the PDF page size shall be used to select the input paper tray.This setting influences only the preset values used to populate the print dialog presented by a conforming reader.If PickTrayByPDFSize is true, the check box in the print dialog associated with input paper tray shall be checked.This setting has no effect on operating systems that do not provide the ability to pick the input tray by size.Default value: as defined by the conforming reader'&gt;	^self objectAt: #PickTrayByPDFSize ifAbsent: [#false asPDF]</body><body package="PDF Interactive Features">PrintArea	&lt;type: #Name&gt;	&lt;version: 4&gt;	&lt;attribute: 11 documentation: 'The name of the page boundary representing the area of a page that shall be rendered when printing the document.If the specified page boundary is not defined in the page object, its default value shall be used.Default value: CropBox.This entry is intended primarily for use by prepress applications that interpret or manipulate the page boundaries.NOTE	Most conforming readers disregard it.'&gt;	^self objectAt: #PrintArea ifAbsent: [#CropBox asPDF]</body><body package="PDF Interactive Features">PrintClip	&lt;type: #Name&gt;	&lt;version: 4&gt;	&lt;attribute: 12 documentation: 'The name of the page boundary to which the contents of a page shall be clipped when printing the document.If the specified page boundary is not defined in the page object, its default value shall be used.Default value: CropBox.This entry is intended primarily for use by prepress applications that interpret or manipulate the page boundaries.NOTE	Most conforming readers disregard it.'&gt;	^self objectAt: #PrintClip ifAbsent: [#CropBox asPDF]</body><body package="PDF Interactive Features">PrintPageRange	&lt;typeArrayOf: #Integer&gt;	&lt;version: 7&gt;	&lt;attribute: 16 documentation: 'The page numbers used to initialize the print dialog box when the file is printed.The array shall contain an even number of integers to be interpreted in pairs, with each pair specifying the first and last pages in a sub-range of pages to be printed.The first page of the PDF file shall be denoted by 1.Default value: as defined by the conforming reader'&gt;	^self objectAt: #PrintPageRange ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">PrintScaling	&lt;type: #Name&gt;	&lt;version: 6&gt;	&lt;attribute: 13 documentation: 'The page scaling option that shall be selected when a print dialog is displayed for this document.Valid values are None, which indicates no page scaling, and AppDefault, which indicates the conforming reader’s default print scaling.If this entry has an unrecognized value, AppDefault shall be used.Default value: AppDefault.If the print dialog is suppressed and its parameters are provided from some other source, this entry nevertheless shall be honored.'&gt;	^self objectAt: #PrintScaling ifAbsent: [#AppDefault asPDF]</body><body package="PDF Interactive Features">ViewArea	&lt;type: #Name&gt;	&lt;version: 4&gt;	&lt;attribute: 9 documentation: 'The name of the page boundary representing the area of a page that shall be displayed when viewing the document on the screen.The value is the key designating the relevant page boundary in the page object.If the specified page boundary is not defined in the page object, its default value shall be used.Default value: CropBox.This entry is intended primarily for use by prepress applications that interpret or manipulate the page boundaries.NOTE	Most conforming readers disregard it.'&gt;	^self objectAt: #ViewArea ifAbsent: [#CropBox asPDF]</body><body package="PDF Interactive Features">ViewClip	&lt;type: #Name&gt;	&lt;version: 4&gt;	&lt;attribute: 10 documentation: 'The name of the page boundary to which the contents of a page shall be clipped when viewing the document on the screen. The value is the key designating the relevant page boundary in the page object.If the specified page boundary is not defined in the page object, its default value shall be used.Default value: CropBox.This entry is intended primarily for use by prepress applications that interpret or manipulate the page boundaries.NOTE	Most conforming readers disregard it.'&gt;	^self objectAt: #ViewClip ifAbsent: [#CropBox asPDF]</body></methods><methods><class-id>Graphics.PDF.Type0</class-id> <category>accessing entries</category><body package="PDF Fonts">BaseFont	&lt;type: #Name&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The name of the font.If the descendant is a Type 0 CIDFont, this name should be the concatenation of the CIDFont’s BaseFont name, a hyphen, and the CMap name given in the Encoding entry (or the CMapName entry in the CMap).If the descendant is a Type 2 CIDFont, this name should be the same as the CIDFont’s BaseFont name.NOTE	In principle, this is an arbitrary name, since there is no font program associated directly with a Type 0 font dictionary.		The conventions described here ensure maximum compatibility with existing readers'&gt;	^self objectAt: #BaseFont</body><body package="PDF Fonts">DescendantFonts	&lt;typeArrayOf: #CIDFont&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'A one-element array specifying the CIDFont dictionary that is the descendant of this Type 0 font'&gt;	^self objectAt: #DescendantFonts</body><body package="PDF Fonts">Encoding	&lt;type: #Name&gt;	&lt;type: #Stream&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The name of a predefined CMap, or a stream containing a CMap that maps character codes to font numbers and CIDs.If the descendant is a Type 2 CIDFont whose associated TrueType font program is not embedded in the PDF file, the Encoding entry shall be a predefined CMap name'&gt;	^self objectAt: #Encoding</body><body package="PDF Fonts">ToUnicode	&lt;type: #Stream&gt;	&lt;attribute: 4 documentation: 'A stream containing a CMap file that maps character codes to Unicode values'&gt;	^self objectAt: #ToUnicode</body></methods><methods><class-id>Graphics.PDF.StandardEncryption</class-id> <category>accessing entries</category><body package="PDF Files">EncryptMetadata	&lt;type: #Boolean&gt;	&lt;version: 5&gt;	&lt;attribute: 5 documentation: '(meaningful only when the value of V is 4)Indicates whether the document-level metadata stream shall be encrypted.Conforming products should respect this value.Default value: true.'&gt;	^self objectAt: #EncryptMetadata ifAbsent: [true asPDF]</body><body package="PDF Files">O	&lt;typeDirect: #String&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A 32-byte string, based on both the owner and user passwords, that shall be used in computing the encryption key and in determining whether a valid owner password was entered.'&gt;	^self objectAt: #O</body><body package="PDF Files">P	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'A set of flags specifying which operations shall be permitted when the document is opened with user access.'&gt;	^self objectAt: #P</body><body package="PDF Files">R	&lt;type: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'A number specifying which revision of the standard security handler shall be used to interpret this dictionary:	2	if the document is encrypted with a V value less than 2 and does not have any of the access permissions set to 0 (by means of the P entry, below) that are designated “Security handlers of revision 3 or greater”	3	if the document is encrypted with a V value of 2 or 3, or has any “Security handlers of revision 3 or greater” access permissions set to 0	4	if the document is encrypted with a V value of 4'&gt;	^self objectAt: #R</body><body package="PDF Files">U	&lt;typeDirect: #String&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'A 32-byte string, based on the user password, that shall be used in determining whether to prompt the user for a password and, if so, whether a valid user or owner password was entered.'&gt;	^self objectAt: #U</body></methods><methods><class-id>Graphics.PDF.CalGrayColourSpaceDictionary</class-id> <category>accessing entries</category><body package="PDF Colour">BlackPoint	&lt;typeArrayOf: #Number&gt;	&lt;attribute: 2 documentation: 'An array of three numbers [XB YB ZB] specifying the tristimulus value, in the CIE 1931 XYZ space, of the diffuse black point.All three of these numbers shall be non-negative'&gt;	^self objectAt: #BlackPoint ifAbsent: [#(0.0 0.0 0.0) asPDF]</body><body package="PDF Colour">Gamma	&lt;type: #Number&gt;	&lt;attribute: 3 documentation: 'A number G defining the gamma for the gray (A)component.G shall be positive and is generally greater than or equal to 1'&gt;	^self objectAt: #Gamma ifAbsent: [1 asPDF]</body><body package="PDF Colour">WhitePoint	&lt;typeArrayOf: #Number&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'An array of three numbers [XW YW ZW] specifying the tristimulus value, in the CIE 1931 XYZ space, of the diffuse white point.The numbers XW and ZW shall be positive, and YW shall be equal to 1.0.'&gt;	^self objectAt: #WhitePoint</body></methods><methods><class-id>Graphics.PDF.NumberTreeNode</class-id> <category>accessing entries</category><body package="PDF Data Structures">Kids	&lt;typeArrayOf: #NumberTree&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'Shall be an array of indirect references to the immediate children of this node.The children may be intermediate or leaf nodes.'&gt;	^self objectAt: #Kids</body></methods><methods><class-id>Graphics.PDF.TensorProductPatchMesh</class-id> <category>accessing entries</category><body package="PDF Shading">BitsPerFlag	&lt;type: #Integer&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The number of bits used to represent the edge flag for each vertex.The value of BitsPerFlag shall be 2, 4, or 8, but only the least significant 2 bits in each flag value shall beused.The value for the edge flag shall be 0, 1, 2 and 3.'&gt;	^self objectAt: #BitsPerFlag</body></methods><methods><class-id>Graphics.PDF.FreeTextAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">BE	&lt;type: #BorderEffect&gt;	&lt;version: 6&gt;	&lt;attribute: 7 documentation: 'A border effect dictionary used in conjunction with the border style dictionary specified by the BS entry.'&gt;	^self objectAt: #BE ifAbsent: [BorderEffect empty]</body><body package="PDF Interactive Features">BS	&lt;type: #BorderStyle&gt;	&lt;version: 6&gt;	&lt;attribute: 9 documentation: 'A border style dictionary specifying the line width and dash pattern that shall be used in drawing the annotation’s border.The annotation dictionary’s AP entry, if present, takes precedence over the BS entry'&gt;	^self objectAt: #BS ifAbsent: [BorderStyle empty]</body><body package="PDF Interactive Features">CL	&lt;typeArrayOf: #Number&gt;	&lt;version: 6&gt;	&lt;attribute: 5 documentation: '(meaningful only if IT is FreeTextCallout)An array of four or six numbers specifying a callout line attached to the free text annotation.Six numbers [ x1 y1 x2 y2 x3 y3 ] represent the starting, knee point, and ending coordinates of the line in default user space.Four numbers [ x1 y1 x2 y2 ] represent the starting and ending coordinates of the line.'&gt;	^self objectAt: #CL ifAbsent: [#() asPDF]</body><body package="PDF Interactive Features">DA	&lt;type: #String&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'The default appearance string that shall be used in formatting the text.The annotation dictionary’s AP entry, if present, shall take precedence over the DA entry'&gt;	^self objectAt: #DA ifAbsent: [String empty]</body><body package="PDF Interactive Features">DS	&lt;type: #Textstring&gt;	&lt;version: 5&gt;	&lt;attribute: 4 documentation: 'A default style string.'&gt;	^self objectAt: #DS ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">IT	&lt;type: #Name&gt;	&lt;version: 6&gt;	&lt;attribute: 6 documentation: 'A name describing the intent of the free text annotation.The following values shall be valid:	FreeText				The annotation is intended to function as a plain free-text annotation.							A plain free-text annotation is also known as a text box comment.	FreeTextCallout		The annotation is intended to function as a callout.							The callout is associated with an area on the page through the callout line specified in CL.	FreeTextTypeWriter	The annotation is intended to function as a click-to-type or typewriter object and no callout line is drawn.'&gt;	^self objectAt: #IT ifAbsent: [#FreeText asPDF]</body><body package="PDF Interactive Features">LE	&lt;type: #Name&gt;	&lt;version: 6&gt;	&lt;attribute: 10 documentation: '(Optional; meaningful only if CL is present)A name specifying the line ending style that shall be used in drawing the callout line specified in CL.The name shall specify the line ending style for the endpoint defined by the pairs of coordinates (x1, y1).'&gt;	^self objectAt: #LE ifAbsent: [#None asPDF]</body><body package="PDF Interactive Features">Q	&lt;type: #Integer&gt;	&lt;version: 4&gt;	&lt;attribute: 2 documentation: 'A code specifying the form of quadding (justification) that shall be used in displaying the annotation’s text:	0	Left-justified	1	Centered	2	Right-justified.'&gt;	^self objectAt: #Q ifAbsent: [0 asPDF]</body><body package="PDF Interactive Features">RC	&lt;type: #Textstring&gt;	&lt;type: #Textstream&gt;	&lt;version: 5&gt;	&lt;attribute: 3 documentation: 'A rich text string that shall be used to generate the appearance of the annotation.'&gt;	^self objectAt: #RC ifAbsent: [Textstring empty]</body><body package="PDF Interactive Features">RD	&lt;type: #Rectangle&gt;	&lt;version: 6&gt;	&lt;attribute: 8 documentation: 'A set of four numbers describing the numerical differences between two rectangles: the Rect entry of the annotation and a rectangle contained within that rectangle.The inner rectangle is where the annotation’s text should be displayed.Any border styles and/or border effects specified by BS and BE entries, respectively, shall be applied to the border of the inner rectangle.The four numbers correspond to the differences in default user space between the left, top, right, and bottom coordinates of Rect and those of the inner rectangle, respectively.Each value shall be greater than or equal to 0. The sum of the top and bottom differences shall be less than the height of Rect, and the sum of the left and right differences shall be less than the width of Rect.'&gt;	^self objectAt: #RD ifAbsent: [Rectangle new]</body></methods><methods><class-id>Graphics.PDF.OptionalContentUsageLanguage</class-id> <category>accessing entries</category><body package="PDF Data Structures">Lang	&lt;type: #Textstring&gt;	&lt;required&gt;	&lt;attribute: 1 documentation: 'A text string that specifies a language and possibly a locale.For example, es-MX represents Mexican Spanish'&gt;	^self objectAt: #Lang</body><body package="PDF Data Structures">Preferred	&lt;type: #Name&gt;	&lt;attribute: 2 documentation: 'A name whose values shall be either ON or OFF.It shall be used by conforming readers when there is a partial match but no exact match between the system language and the language strings in all usage dictionaries'&gt;	^self objectAt: #Preferred ifAbsent: [#OFF asPDF]</body></methods><methods><class-id>Graphics.PDF.TransparencyGroupAttributes</class-id> <category>accessing entries</category><body package="PDF XObjects">CS	&lt;type: #ColourSpace&gt;	&lt;attribute: 2 documentation: '(Sometimes required) The group colour space, which is used for the following purposes:• As the colour space into which colours shall be converted when painted into the group• As the blending colour space in which objects shall be composited within the group• As the colour space of the group as a whole when it in turn is painted as an object onto its backdropThe group colour space shall be any device or CIE-based colour space that treats its components as independent additive or subtractive values in the range 0.0 to 1.0, subject to the restrictions. These restrictions exclude Lab and lightness-chromaticity ICCBased colour spaces, as well as the special colour spaces Pattern, Indexed, Separation, and DeviceN. Device colour spaces shall be subject to remapping according to the DefaultGray, DefaultRGB, and DefaultCMYK entries in the ColorSpace subdictionary of the current resource dictionary.Ordinarily, the CS entry may be present only for isolated transparency groups (those for which I is true), and even then it is optional. However, this entry shall be present in the group attributes dictionary for any transparency group XObject that has no parent group or page from which to inherit—in particular, one that is the value of the G entry in a soft-mask dictionary of subtype Luminosity.Additionally, the CS entry may be present in the group attributes dictionary associated with a page object, even if I is false or absent. In the normal case in which the page is imposed directly on the output medium, the page group is effectively isolated regardless of the I value, and the specified CS value shall therefore be honoured. But if the page is in turn used as an element of some other page and if the group is non-isolated, CS shall be ignored and the colour space shall be inherited from the actual backdrop with which the page is composited.Default value: the colour space of the parent group or page into which this transparency group is painted. (The parent’s colour space in turn may be either explicitly specified or inherited.)For a transparency group XObject used as an annotation appearance, the default colour space shall be inherited from the page on which the annotation appears.'&gt;	^self objectAt: #CS</body><body package="PDF XObjects">I	&lt;type: #Boolean&gt;	&lt;attribute: 3 documentation: 'A flag specifying whether the transparency group is isolated. If this flag is true, objects within the group shall be composited against a fully transparent initial backdrop; if false, they shall be composited against the group’s backdrop.In the group attributes dictionary for a page, the interpretation of this entry shall be slightly altered. In the normal case in which the page is imposed directly on the output medium, the page group is effectively isolated and the specified I value shall be ignored. But if the page is in turn used as an element of some other page, it shall be treated as if it were a transparency group XObject; the I value shall be interpreted in the normal way to determine whether the page group is isolated.'&gt;	^self objectAt: #I ifAbsent: [false asPDF]</body><body package="PDF XObjects">K	&lt;type: #Boolean&gt;	&lt;attribute: 4 documentation: 'A flag specifying whether the transparency group is a knockout group. If this flag is false, later objects within the group shall be composited with earlier ones with which they overlap; if true, they shall be composited with the group’s initial backdrop and shall overwrite (“knock out”) any earlier overlapping objects.'&gt;	^self objectAt: #K ifAbsent: [false asPDF]</body></methods><methods><class-id>Graphics.PDF.MovieAnnotation</class-id> <category>accessing entries</category><body package="PDF Interactive Features">A	&lt;type: #Boolean&gt;	&lt;type: #Dictionary&gt;	&lt;attribute: 3 documentation: 'A flag or dictionary specifying whether and how to play the movie when the annotation is activated.If this value is a dictionary, it shall be a movie activation dictionary specifying how to play the movie.If the value is the boolean true, the movie shall be played using default activation parameters.If the value is false, the movie shall not be played.'&gt;	^self objectAt: #A ifAbsent: [true asPDF]</body><body package="PDF Interactive Features">Movie	&lt;type: #Movie&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'A movie dictionary that shall describe the movie’s static characteristics.'&gt;	^self objectAt: #Movie ifAbsent: [Dictionary empty]</body><body package="PDF Interactive Features">T	&lt;type: #Textstring&gt;	&lt;attribute: 1 documentation: 'The title of the movie annotation.Movie actions may use this title to reference the movie annotation.'&gt;	^self objectAt: #T ifAbsent: [Textstring empty]</body></methods><methods><class-id>Graphics.PDF.DeviceN</class-id> <category>accessing entries</category><body package="PDF Colour">alternateSpace	&lt;type: #DeviceColourSpace&gt;	&lt;type: #CIEColourSpace&gt;	&lt;required&gt;	&lt;attribute: 3 documentation: 'When the colour space is set to a DeviceN space, if any of the component names in the colour space do not correspond to a colorant available on the device, the conforming reader shall perform subsequent painting operations in the alternate colour space specified by this parameter.For NChannel colour spaces, the components shall be evaluated individually; that is, only the ones not present on the output device shall use the alternate colour space.'&gt;	^self objectAt: 3</body><body package="PDF Colour">attributes	&lt;type: #DeviceNColourSpaceAttributes&gt;	&lt;attribute: 5 documentation: 'The optional attributes parameter shall be a dictionary containing additional information about the components of colour space that conforming readers may use.Conforming readers need not use the alternateSpace and tintTransform parameters, and may instead use custom blending algorithms, along with other information provided in the attributes dictionary if present.(If the value of the Subtype entry in the attributes dictionary is NChannel, such information shall be present.)However, alternateSpace and tintTransform shall always be provided for conforming readers that want to use them or do not support PDF 1.6.'&gt;	^self objectAt: 5</body><body package="PDF Colour">names	&lt;typeArrayOf: #Name&gt;	&lt;required&gt;	&lt;attribute: 2 documentation: 'The names parameter shall be an array of name objects specifying the individual colour components.The length of the array shall determine the number of components in the DeviceN colour space, which is subject to an implementation limit.The component names shall all be different from one another, except for the name None, which may be repeated.The special name All, used by Separation colour spaces, shall not be used.'&gt;	^self objectAt: 2</body><body package="PDF Colour">tintTransform	&lt;type: #Function&gt;	&lt;required&gt;	&lt;attribute: 4 documentation: 'The tintTransform parameter shall specify a function that is used to transform the tint values into the alternate colour space.It shall be called with n tint values and returns m colour component values, where n is the number of components needed to specify a colour in the DeviceN colour space and m is the number required by the alternate colour space.'&gt;	^self objectAt: 4</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="PDF basics">pdf20x20	"UIMaskEditor new openOnClass: self andSelector: #pdf20x20"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 20@20 depth: 7 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7323 578 578)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7934 7934)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3693 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 1124 1124)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7901 6649 6649)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3372 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5492 5492 5492)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 7387 7387)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6038 6038 6038)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6745 6745 6745)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 8158 8158)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6681 96 96)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5878 5878 5878)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 2473 2473)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 1252 1252)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 6745 6745)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 3404 3404)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 5653 5653)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6006 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7837 7837 7837)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2023 2023 2023)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 1991 1991)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7002 353 353)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7677 7677)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 256 256)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6809 6809)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6103 6103 6103)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 4015 4015)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7163 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 5075 5075)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7355 7355 7355)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 2537 2537)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4368 4368 4368)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7901 7901 7901)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 4400 4400)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5621 5621 5621)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7034 7034 7034)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7066 417 417)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5717 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3597 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3276 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5460 5460)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 4753 4753)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7580 7580 7580)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7034 353 353)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 5492 5492)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7195 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 6135 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 5300 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7612 803 803)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7034 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 8126 8126)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 4978 4978)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5139 5139 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5846 5846 5846)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6231 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 5621 5621)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6392 6392 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5749 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5524 5524 5524)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7644 7644 7644)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5428 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 2923 2923)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 3983 3983)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6070 6070 6070)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(963 963 963)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 128 128)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5203 5203 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6424 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 6777 6777)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6263 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 5621 5621)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7869 7869 7869)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7163 7163 7163)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 5524 5524)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3661 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5589 5589 5589)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 6617 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7869 1027 1027)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1188 1188 1188)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4721 4721 4721)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6135 6135 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5139 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 3886 3886)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 6103 6103)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7387 7387 7387)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6938 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6777 32 32)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 8094 8094)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'Q4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]G@PDAGB\WPA]@PD@''TPDA@T]GQ4\A@PD]@U@ZF#A_V5EUJ@DAQ4]GQ6@_L3]!H30TJ$H5@UD.J@EGQ4]GXPPPU3X@LP5NWBPA@UE@HT]GQ4\?FR$)LQ-HSAQJN"P$K4$KQ4]GQ4,CUB,FK@\-V"5AW5D&gt;VP)GQ4]G@PDAV0EPTEA]AQ(ZF$DKN4]GQ4\A@PE[@PDA@QIV@RTZEQT''Q4]GQ0DA@U,A@PDAT5LA@RTA@TAGQ4]G@PDAV3 A@PERF@DA@PDAPD]GQ4\A@PE[NFI"BTL4C582DPE@Q4]GQ0DA@U,8X&amp;H^ST&lt;=NRYD@TAGQ4]G@PDAV3!M@!M"X&amp;I"@S 8PD]GQ4\A@PE[NBH C@0LC@0LQ4]@Q4]GQ0DA@U,8C@0LC@0LC@1GQ0!GQ4]G@PDAQQYXVE!XVE!XVDXVC$]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ0@a')))</body><body package="PDF basics">pdf20x20mask	"UIMaskEditor new openOnClass: self andSelector: #pdf20x20mask"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 7 254 0 0 7 255 0 0 63 255 128 0 63 255 192 0 63 255 192 0 63 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 0 0 0 0 0 0 0 0]))</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PixelArray</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Image</name><environment>Graphics</environment><super>Graphics.PixelArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bits width height depth bitsPerPixel palette maxPixelValue rowByteSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Depth32Image</name><environment>Graphics</environment><super>Graphics.Image</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Font</name><environment>Graphics.Fonts</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>useAlternativeFont printFontDescription </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Fonts Basics</package></attributes></class><class><name>CustomFont</name><environment>Graphics.Fonts</environment><super>Graphics.Fonts.Type1Font</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename program </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Type1</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Palette</name><environment>Graphics</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Palettes</category><attributes><package>Graphics-Palettes</package></attributes></class><class><name>StandardFont</name><environment>Graphics.Fonts</environment><super>Graphics.Fonts.Type1Font</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowsFaceName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Type1</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Font</name><environment>Graphics.Fonts.OpenType</environment><super>Graphics.Fonts.Font</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename sfntVersion numTables searchRange entrySelector rangeShift tables glyphs tabularGlyphIds header </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenType</package></attributes></class><class><name>Value</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Depth8Image</name><environment>Graphics</environment><super>Graphics.Image</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Cff</name><environment>Graphics.Fonts.OpenType</environment><super>Graphics.Fonts.OpenType.Table</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fontSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>OpenType</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Icon</name><environment>UI</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figure shape </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>CoveragePalette</name><environment>Graphics</environment><super>Graphics.Palette</super><private>false</private><indexed-type>none</indexed-type><inst-vars>maxPixelValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Palettes</category><attributes><package>Graphics-Palettes</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SimplePaint</name><environment>Graphics</environment><super>Graphics.Paint</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>CoverageValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>coverage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>MappedPalette</name><environment>Graphics</environment><super>Graphics.ColorPalette</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasColor palette inverseMap mapResolution size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Palettes</category><attributes><package>Graphics-Palettes</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Depth24Image</name><environment>Graphics</environment><super>Graphics.Image</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>InflateStream</name><environment>OS.ZLib</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputBuffer inputLimit interface sourceStream superPosition eof </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-ZLib</category><attributes><package>Compression-ZLib</package></attributes></class><class><name>Depth4Image</name><environment>Graphics</environment><super>Graphics.Image</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>OrderedDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>order </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>smallCharts basics</category><attributes><package>Values</package></attributes></class><class><name>Depth2Image</name><environment>Graphics</environment><super>Graphics.Image</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>MonoMappedPalette</name><environment>Graphics</environment><super>Graphics.MappedPalette</super><private>false</private><indexed-type>none</indexed-type><inst-vars>whitePixel blackPixel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Palettes</category><attributes><package>Graphics-Palettes</package></attributes></class><class><name>FixedPalette</name><environment>Graphics</environment><super>Graphics.ColorPalette</super><private>false</private><indexed-type>none</indexed-type><inst-vars>redShift redMask greenShift greenMask blueShift blueMask </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Palettes</category><attributes><package>Graphics-Palettes</package></attributes></class><class><name>FontProgram</name><environment>Graphics.Fonts</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>header contents glyphs trailerExtra </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Type1</package></attributes></class><class><name>AlphaCompositedImage</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composition image </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Graphics-Images</package></attributes></class><class><name>Depth1Image</name><environment>Graphics</environment><super>Graphics.Image</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>OpaqueImage</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figure shape </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>CachedImage</name><environment>Graphics</environment><super>Graphics.PixelArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>image retainedMedium conversionMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>DeflateStream</name><environment>OS.ZLib</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputBuffer interface destinationStream compressionLevel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-ZLib</category><attributes><package>Compression-ZLib</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>powersOfTwo </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>