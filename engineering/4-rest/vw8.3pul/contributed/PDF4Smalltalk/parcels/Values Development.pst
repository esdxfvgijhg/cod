<?xml version="1.0"?><st-source><!-- Name: Values DevelopmentNotice: The MIT LicenseCopyright © 2009-2014 Christian HaiderPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.BundleName: Values DevelopmentBundleStructure: a Store.BundleForParcelComment: Values are simple immutable literal objects.Package 'Values' contain the runtime code.Package 'Value Development' contains the generators to define Values in the development environment.Package 'Values Testing' contains tests for Values.For a comprehensive descriptions see the paper "Complex Values in Smalltalk" held at ESUG 2009 by Thomas Schrader and Christian Haider.Parcel: nilParcelName: Values DevelopmentPrerequisiteParcels: #(#('SUnitToo' ''))Version: 1.1.5.1Date: 8:47:59 AM March 10, 2016 --><time-stamp>From VisualWorks® Personal Use Edition, Pre-Release 8.2 (testVisualStudio2015) of March 4, 2016 on March 10, 2016 at 8:48:00 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ValueTestingNamespace</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>Values Testing</package></attributes></name-space><comment><name-space-id>ValueTestingNamespace</name-space-id><body>A Namespace for testing purposes.Used for testing Values in other namespaces named Array, Dictionary and OrderedDictionary</body></comment><class><name>Value</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>Value</class-id><body>Value is the abstract root object of values (literal objects).All Value classes which have subclasses are considered abstract. Only leaf classes can have instances!Literal objects are created immutable with constructors.The instance variables are object constants.Subclasses must implement the following messages:	class specification		localSpecification</body></comment><class><name>Printvalue</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>Printvalue</class-id><body>A Printvalue holds a representation of a Value to be printed.It consists of	- classname 	&lt;String&gt;										properly resolved against a target class (#name or #fullName)	- arguments 	&lt;SequenceableCollection of: Printargument&gt;		the list of arguments with constructor variable name and a PrintvaluePrintvalues are created when printing the source for a Value in the first pass. The second pass takes the Printvalue and produces a nicely indented soure string for the value.</body></comment><class><name>LiteralPrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>LiteralPrintvalue</class-id><body>LiteralPrintvalue is a Printvalue for literals.Instance Variables:	string	&lt;String&gt;	the representation as a string</body></comment><class><name>OrderedDictionaryInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.DictionaryInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Values Development</package></attributes></class><comment><class-id>Tools.Trippy.OrderedDictionaryInspector</class-id><body>OrderedDictionaryInspector leaves the keys in their proper order</body></comment><class><name>Array</name><environment>ValueTestingNamespace</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Testing</package></attributes></class><comment><class-id>ValueTestingNamespace.Array</class-id><body>redefinition of Array.Used to test the correct source string for classes which shadow the internally used system classes (Array, Dictionary, OrderedDictionary)</body></comment><class><name>BindingSpecification</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector comment </inst-vars><class-inst-vars></class-inst-vars><imports>			Refactory.Browser.*			</imports><category>My Classes</category><attributes><package>Values Development</package></attributes></class><comment><class-id>BindingSpecification</class-id><body>BindingSpecification describes one constant (slot, instvar) of a Value class.Subclasses exist for different types.Part of a ValueSpecification. Used for source generating.Subclasses must implement the following messages:	accessing		type	source generation		pragmaMessageString		printExpressionWithNewline:		printSelectorInstance Variables:	selector		&lt;Symbol&gt;	the instvar</body></comment><class><name>TypedConstantSpecification</name><environment>Smalltalk</environment><super>BindingSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Literal Objects Development</category><attributes><package>Values Development</package></attributes></class><comment><class-id>TypedConstantSpecification</class-id><body>TypedConstantSpecification specifies a simple constant with a type. Subclasses define mandatory and optional versions</body></comment><class><name>OptionalConstantSpecification</name><environment>Smalltalk</environment><super>TypedConstantSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>default </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Literal Objects Development</category><attributes><package>Values Development</package></attributes></class><comment><class-id>OptionalConstantSpecification</class-id><body>OptionalConstantSpecification specifies a simple optional constant with a type and a default</body></comment><class><name>ValuePrinter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>ValuePrinter</class-id><body>ValuePrinter creates the source for a Value.For each level, a new ValuePrinter is created.Instance Variables:	target	&lt;Value class&gt;	defines the scoping for the created source - how class names are printed	level	&lt;Integer&gt;		the indent level	stream	&lt;WriteStream&gt;	a writestream passed around to collect the sources</body></comment><class><name>Dictionary</name><environment>ValueTestingNamespace</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Testing</package></attributes></class><comment><class-id>ValueTestingNamespace.Dictionary</class-id><body>redefinition of Dictionary.Used to test the correct source string for classes which shadow the internally used system classes (Array, Dictionary, OrderedDictionary)</body></comment><class><name>ConstantSpecification</name><environment>Smalltalk</environment><super>TypedConstantSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Literal Objects Development</category><attributes><package>Values Development</package></attributes></class><comment><class-id>ConstantSpecification</class-id><body>ConstantSpecification specifies a simple mandatory constant with a type</body></comment><class><name>OrderedDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>order </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>smallCharts basics</category><attributes><package>Values</package></attributes></class><comment><class-id>Core.OrderedDictionary</class-id><body>OrderedDictionary preserves the order in which the entries were added.Instance Variables:	order	&lt;SequenceableCollection of: Object&gt;		the ordered keys</body></comment><class><name>OrderedDictionary</name><environment>ValueTestingNamespace</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Testing</package></attributes></class><comment><class-id>ValueTestingNamespace.OrderedDictionary</class-id><body>redefinition of OrderedDictionary.Used to test the correct source string for classes which shadow the internally used system classes (Array, Dictionary, OrderedDictionary)</body></comment><class><name>CollectionSpecification</name><environment>Smalltalk</environment><super>BindingSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Literal Objects Development</category><attributes><package>Values Development</package></attributes></class><comment><class-id>CollectionSpecification</class-id><body>CollectionSpecification specifies a collecion constant: Array or Dictionary</body></comment><class><name>ArraySpecification</name><environment>Smalltalk</environment><super>CollectionSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Literal Objects Development</category><attributes><package>Values Development</package></attributes></class><comment><class-id>ArraySpecification</class-id><body>ArraySpecification specifies an Array constant</body></comment><class><name>Testvalue</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constant optional array dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values Testing</category><attributes><package>Values Testing</package></attributes></class><comment><class-id>Testvalue</class-id><body>Testvalue is a resource class for testing values</body></comment><class><name>DictionarySpecification</name><environment>Smalltalk</environment><super>CollectionSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Literal Objects Development</category><attributes><package>Values Development</package></attributes></class><comment><class-id>DictionarySpecification</class-id><body>DictionarySpecification specifies a Dictionary constant</body></comment><class><name>Emitter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>printer stream level </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Values</package></attributes></class><comment><class-id>Emitter</class-id><body>Emitter outputs a Printvalue as formatted source code to a stream.Subclasses write source or text.This implements the second pass of the source generation for Values.Instance Variables	printer	&lt;ValuePrinter&gt;					the printer to resolve namespace names	level	&lt;Integer&gt;						the indention level	stream	&lt;WriteStream | TextStream&gt;		the output stream</body></comment><class><name>LiteralObject</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Literal Objects</category><attributes><package>Values Development</package></attributes></class><comment><class-id>LiteralObject</class-id><body>obsoletechange subclasses to subclass Value</body></comment><class><name>ValueSpecification</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constants </inst-vars><class-inst-vars></class-inst-vars><imports>			Refactory.Browser.*			</imports><category>My Classes</category><attributes><package>Values Development</package></attributes></class><comment><class-id>ValueSpecification</class-id><body>ValueSpecification describes the structure of a Value classInstance Variables:	constants	&lt;SequenceableCollection of: BindingSpecification&gt;	the constants (inst vars) of the Value class</body></comment><class><name>TextEmitter</name><environment>Smalltalk</environment><super>Emitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Values</package></attributes></class><comment><class-id>TextEmitter</class-id><body>TextEmitter outputs a descriptive text.</body></comment><class><name>TextBlockemitter</name><environment>Smalltalk</environment><super>TextEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>TextBlockemitter</class-id><body>TextBlockEmitter emits text as indented block</body></comment><class><name>TextLineemitter</name><environment>Smalltalk</environment><super>TextEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>TextLineemitter</class-id><body>TextLineEmitter emits text as one line</body></comment><class><name>DictionaryPrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments isOrdered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Values</package></attributes></class><comment><class-id>DictionaryPrintvalue</class-id><body>DictionaryPrintvalue is used for printing DictionariesInstance Variables:	arguments	&lt;SequenceableCollection of DictionaryPrintargument&gt;	the Printarguments for each entry</body></comment><class><name>SourceEmitter</name><environment>Smalltalk</environment><super>Emitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Values</package></attributes></class><comment><class-id>SourceEmitter</class-id><body>SourceEmitter outputs source code.</body></comment><class><name>ArrayPrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Values</package></attributes></class><comment><class-id>ArrayPrintvalue</class-id><body>ArrayPrintvalue is a special Printvalue for sequentiable collections of Values</body></comment><class><name>Printargument</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>Printargument</class-id><body>A Printargument holds the data to print one instance variable (constant) and its value.	- name 	&lt;String&gt; 		the name of the argument	- value 	&lt;Printvalue&gt;	the print value of the valueWith Printvalue it represents the source for a Value</body></comment><class><name>Lineemitter</name><environment>Smalltalk</environment><super>SourceEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>Lineemitter</class-id><body>Emits source as one line</body></comment><class><name>DictionaryPrintargument</name><environment>Smalltalk</environment><super>Printargument</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>DictionaryPrintargument</class-id><body>DictionaryPrintargument holds the Printvalues for key and value of an entry in a dictionary.Both key and value can be Values</body></comment><class><name>ValueGenerationTests</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Literal Objects Testing</category><attributes><package>Values Testing</package></attributes></class><comment><class-id>ValueGenerationTests</class-id><body>Tests for the various parts of the source code generation</body></comment><class><name>ValuePrinterTests</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Literal Objects Testing</category><attributes><package>Values Testing</package></attributes></class><comment><class-id>ValuePrinterTests</class-id><body>Tests for the source strings of Values</body></comment><class><name>Blockemitter</name><environment>Smalltalk</environment><super>SourceEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>Blockemitter</class-id><body>Emits source as indented block</body></comment><class><name>OrderedDictionaryTests</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>smallCharts ExternalData Testing</category><attributes><package>Values Testing</package></attributes></class><comment><class-id>OrderedDictionaryTests</class-id><body>Tests for the behavior of OrderedDictionary as Dictionary and as Value</body></comment><class><name>ValuePrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classname arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values</category><attributes><package>Values</package></attributes></class><comment><class-id>ValuePrintvalue</class-id><body>ValuePrintvalue holds the data to print a Value.Instance Variables:	arguments	&lt;SequenceableCollection of: (Printargument | EmptyArgument)&gt;	the arguments	classname	&lt;String&gt;														the namespace aware name of the class</body></comment><class><name>ScopeTests</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Values Testing</category><attributes><package>Values Testing</package></attributes></class><comment><class-id>ScopeTests</class-id><body>Tests for the scope or visibility between classes.Values write their source with or without namespaces, depending on the scope.</body></comment><methods><class-id>Value</class-id> <category>comparing</category><body package="Values">= anObject	"all instvars must be equal"	^self isEqualValue: anObject</body><body package="Values">hash	^(1 to: self class instSize) inject: 0 into: [:hash :i | hash bitXor: (self instVarAt: i) hash]</body><body package="Values">isEqualValue: anObject	self == anObject ifTrue: [		^true].	self class = anObject class ifFalse: [		^false].	1 to: self class instSize do: [:i |		((self instVarAt: i) isEqualValue: (anObject instVarAt: i)) ifFalse: [			^false]].	^true</body></methods><methods><class-id>Value</class-id> <category>testing</category><body package="Values">isEmpty	^self = self class new</body><body package="Values">notEmpty	^self isEmpty not</body></methods><methods><class-id>Value</class-id> <category>marshaling</category><body package="Values">passMode	"for OpenTalk StSt (Smalltalk to Smalltalk)"	^#value</body></methods><methods><class-id>Value</class-id> <category>copying</category><body package="Values">postCopy	super postCopy.	self beImmutable</body></methods><methods><class-id>Value</class-id> <category>printing</category><body package="Values">printOn: stream	stream nextPutAll: self asSource</body><body package="Values">printvalueWith: printer	^printer printvalue: self arguments: #()</body></methods><methods><class-id>Value</class-id> <category>source generation</category><body package="Values Development">addAsMethod	"&lt;(Association key: class value: Symbol) | nil&gt;	generate a method for the receiver"	^self addAsMethodNamed: self selectorString</body><body package="Values Development">addAsMethodNamed: initialName	"&lt;Symbol | nil&gt;	generate a method for the receiver"	| selectorString selector |	self isUsefulTestInstance ifFalse: [		^nil].	selectorString := Dialog		request: 'class method name in ' , self class name asString		initialAnswer: initialName.	selectorString isEmpty ifTrue: [		^nil].	selector := selectorString asSymbol.	(self class respondsTo: selector) ifTrue: [		Dialog warn: 'Method ' , selectorString , ' already exists. Please choose another name'.		^self addAsMethodNamed: selectorString].	(self		addMethodNamed: selector		for: self class class		in: self methodProtocol		package: (Store.Registry packageNamed: self class package name)) ifNotNil: #execute.	^self class class -&gt; selector</body><body package="Values Development">addAsTestInstanceIn: packageName	"generate a method for the receiver"	"Replace an existing instance when better"	| selector |	self isUsefulTestInstance ifFalse: [		^self].	selector := self selectorString asSymbol.	(self isBetterTestInstanceSelector: selector) ifFalse: [		^self].	(self		addMethodNamed: selector		for: self class class		in: self methodProtocol		package: (Store.Registry packageNamed: packageName)) ifNotNil: #execute</body><body package="Values Development">addMethod: source for: target in: protocol	"&lt;AddMethodChange | nil&gt;"	| pretty |	(target needs: source) ifFalse: [		^nil].	pretty := (Refactory.Browser.RBParser parseMethod: source) formattedCode.	^Refactory.Browser.AddMethodChange compile: pretty in: target classified: protocol</body><body package="Values Development">addMethod: source for: target in: protocol package: aPackageModel	"&lt;AddMethodChange | nil&gt;"	| pretty change |	(target needs: source) ifFalse: [		^nil].	pretty := (Refactory.Browser.RBParser parseMethod: source) formattedCode.	change := Refactory.Browser.AddMethodChange compile: pretty in: target classified: protocol.	change package: aPackageModel.	^change</body><body package="Values Development">addMethodNamed: selector for: target in: protocol	"&lt;AddMethodChange | nil&gt;"	^self addMethod: (self asMethodSourceNamed: selector) for: target in: protocol</body><body package="Values Development">addMethodNamed: selector for: aMetaClass in: protocol package: aPackageModel	"&lt;AddMethodChange | nil&gt;"	^self		addMethod: (self asMethodSourceFor: aMetaClass named: selector)		for: aMetaClass		in: protocol		package: aPackageModel</body><body package="Values Development">asMethodSourceFor: aMetaClass named: selector	| wst |	wst := WriteStream on: (String new: 200).	wst		nextPutAll: selector;		crtab;		nextPut: $^;		nextPutAll: (self asSourceFor: aMetaClass soleInstance).	^wst contents</body><body package="Values Development">asMethodSourceNamed: selector	| wst |	wst := WriteStream on: (String new: 200).	wst		nextPutAll: selector;		crtab;		nextPut: $^;		nextPutAll: self asSource.	^wst contents</body><body package="Values Development">betterTestInstanceThan: aValue	"&lt;Boolean&gt;	true, iff the receiver is better as a test instance than aValue"	^true</body><body package="Values Development">isBetterTestInstanceSelector: aSymbol	(self class respondsTo: aSymbol) ifFalse: [		^true].	^self betterTestInstanceThan: (self class perform: aSymbol)</body><body package="Values Development">isUsefulTestInstance	^self notEmpty</body><body package="Values Development">methodProtocol	^#'test instances'</body><body package="Values Development">newSelectorBasedOn: aString	"&lt;Symbol | nil&gt;	return a new selector by adding '_&lt;Integer&gt;' to the base selector"	| selector count |	selector := aString asSymbol.	count := 1.	[self class respondsTo: selector] whileTrue: [		selector := (aString , '_' , count printString) asSymbol.		count := count + 1].	^selector</body><body package="Values Development">selectorString	"&lt;String&gt;"	"if this object should be savable, implement this method to return a suitable unique string"	^'example', self class name asString</body></methods><methods><class-id>Value</class-id> <category>user interface</category><body package="Values Development">inspectorActions	^Array with: (Tools.Trippy.Action label: 'Save as method...' block: [		self addAsMethod			ifNotNil: [:assoc |			| md |			md := MethodDefinition class: assoc key selector: assoc value.			MethodCollector new				openListBrowserOn: (Array with: md)				label: 'Generated Method'				initialSelection: nil]			ifNil: [			self halt]])</body></methods><methods><class-id>Value class</class-id> <category>class initialization</category><body package="Values">obsolete	self allInstancesDo: [:instance | instance beMutable].	super obsolete</body></methods><methods><class-id>Value class</class-id> <category>pragmas</category><body package="Values Development">constant: aSymbol class: aLiteralBindingReference	^ConstantSpecification selector: aSymbol type: aLiteralBindingReference</body><body package="Values Development">constant: aSymbol class: aLiteralBindingReference comment: commentString	^ConstantSpecification		selector: aSymbol		comment: commentString		type: aLiteralBindingReference</body><body package="Values Development">map: aSymbol	^DictionarySpecification selector: aSymbol</body><body package="Values Development">map: aSymbol comment: commentString	^DictionarySpecification selector: aSymbol comment: commentString</body><body package="Values Development">optional: aSymbol class: aLiteralBindingReference default: aString	^OptionalConstantSpecification selector: aSymbol type: aLiteralBindingReference default: aString</body><body package="Values Development">optional: aSymbol class: aLiteralBindingReference default: aString comment: commentString	^OptionalConstantSpecification		selector: aSymbol		comment: commentString		type: aLiteralBindingReference		default: aString</body><body package="Values Development">sequence: aSymbol	^ArraySpecification selector: aSymbol</body><body package="Values Development">sequence: aSymbol comment: commentString	^ArraySpecification selector: aSymbol comment: commentString</body></methods><methods><class-id>Value class</class-id> <category>source generation</category><body package="Values Development">differentPrintMethods	"self differentPrintMethods"	"construct change objects for all printers with different source code than generated"	| change |	change := Refactory.Browser.CompositeRefactoryChange named: 'Different print methods in subclasses of ' , self name asString.	self subclassesWithConstants do: [:aClass |		(aClass specification sourcePrintvalueWithFor: aClass) ifNotNil: [:aRefactoryChangeOrNil |			change addChange: aRefactoryChangeOrNil]].	change changes isEmpty ifTrue: [		^Dialog warn: 'No changes'].	change inspect</body><body package="Values Development">generateMethods	"construct change objects and opens the list for the user to execute"	| change |	(self hasSpecification not and: [	self isLeafClass not]) ifTrue: [			^Dialog warn: 'no specification found and abstract'].	change := Refactory.Browser.CompositeRefactoryChange named: 'Create value methods for ' , self name asString.	self specification addMethodsFor: self to: change.	change changes isEmpty ifTrue: [		^Dialog warn: 'No changes'].	change inspect</body></methods><methods><class-id>Value class</class-id> <category>compiling</category><body package="Values Development">evaluate: source	^self compilerClass		evaluate: source		for: self		in: self environment		notifying: nil		logged: false</body></methods><methods><class-id>Value class</class-id> <category>test instances</category><body package="Values Development">example	"&lt;Value&gt;"	^self new</body><body package="Values Development">literalExample	^self example</body></methods><methods><class-id>Value class</class-id> <category>testing</category><body package="Values Development">hasSpecification	^self class includesSelector: #localSpecification</body></methods><methods><class-id>Value class</class-id> <category>testing class hierarchy</category><body package="Values Development">isLeafClass	^self subclasses isEmpty</body></methods><methods><class-id>Value class</class-id> <category>accessing class hierarchy</category><body package="Values Development">leafClasses	^self allSubclasses select: [:subclass | subclass isLeafClass]</body><body package="Values Development">subclassesWithConstants	^Value allSubclasses select: [:aClass | aClass instVarNames notEmpty]</body></methods><methods><class-id>Value class</class-id> <category>specification</category><body package="Values Development">localSpecification	"specification of the constants with pragmas.	Only for the instvars defined in this class - access the full specification with #specification"	^self subclassResponsibility</body><body package="Values Development">specification	"&lt;ValueSpecification&gt;"	"the comprehensive specification of the constants of this class"	| constants superclasses |	constants := OrderedCollection new.	superclasses := self withAllSuperclasses reverse.	"from superclasses to subclasses"	superclasses remove: Object.	superclasses remove: Value.	superclasses do: [:aSuperclass |		(aSuperclass class includesSelector: #localSpecification) ifTrue: [			| pragmas consts |			pragmas := Pragma allInMethod: (aSuperclass class compiledMethodAt: #localSpecification).			consts := pragmas collect: [:pragma | Value perform: pragma keyword withArguments: pragma arguments].			consts do: [:constant |				(constants detect: [:c | c name = constant name] ifNone: [nil]) ifNotNil: [:c |					constants remove: c	"subclasses overwrite superclass specifications"].				constants add: constant]]].	^ValueSpecification constants: constants</body></methods><methods><class-id>Value class</class-id> <category>accessing</category><body package="Values Development">toolListIcon	^ListIconLibrary visualFor: #value</body></methods><methods><class-id>Value class</class-id> <category>conformance testing</category><body package="Values Development">allLeafClassesHaveEmptyInstance	"tests that #asSource and #= are implemented"	"self allLeafClassesHaveEmptyInstance"	| nonConforming |	nonConforming := Value leafClasses reject: [:class |		class new asSource = (class name asString , ' new')].	nonConforming notEmpty ifTrue: [		^self error: 'some classes do not conform to the Value protocol'].	^true</body><body package="Values Development">allLeafClassesHaveWorkingExample	"tests that #example is implemented and works"	"self allLeafClassesHaveWorkingExample"	| nonConforming |	nonConforming := Value leafClasses reject: [:class |		(((class class includesSelector: #localSpecification) and: [		class class includesSelector: #example]) or: [			true]) and: [			class example asSource = (class evaluate: (class example asSourceFor: class)) asSource]].	nonConforming notEmpty ifTrue: [		^self error: 'some classes do not conform to the Value protocol'].	^true</body><body package="Values Development">allValuesHavePrinters	"tests that #printvalueWith: is implemented when there is state"	"self allValuesHavePrinters"	| nonConforming |	nonConforming := Value subclassesWithConstants reject: [:class |		class includesSelector: ValueSpecification printSelector].	nonConforming notEmpty ifTrue: [		^self error: 'some classes do not conform to the Value protocol'].	^true</body></methods><methods><class-id>Printvalue</class-id> <category>accessing</category><body package="Values">description	"&lt;Text&gt;"	| emitter |	emitter := self textemitterClass new.	self sourceWith: emitter.	^emitter stream contents</body><body package="Values">emitterClass	"&lt;SourceEmitter class&gt;"	^self isLine		ifTrue: [Lineemitter]		ifFalse: [Blockemitter]</body><body package="Values">sourceFor: outerEmitter	"&lt;String&gt;"	^self sourceWith: (outerEmitter emitterFor: self)</body><body package="Values">sourceWith: emitter	"write yourself with the emitter"	^self subclassResponsibility</body><body package="Values">sourceWithPrinter: aPrinter	"&lt;String&gt;"	| emitter |	emitter := self emitterClass for: aPrinter.	self sourceWith: emitter.	^emitter stream contents</body><body package="Values">textemitterClass	"&lt;SourceEmitter class&gt;"	^self isLine		ifTrue: [TextLineemitter]		ifFalse: [TextBlockemitter]</body></methods><methods><class-id>Printvalue</class-id> <category>testing</category><body package="Values">isLine	^false</body><body package="Values">isSimple	"does it have to be printed in brackets?	only literals are simple"	^false</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeString: stringString	string := stringString.	self beImmutable</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>testing</category><body package="Values">isLine	^true</body><body package="Values">isSimple	^(self string first = $() not</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'string' value: self string).	^printer printvalue: self arguments: args</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>accessing</category><body package="Values">sourceWith: emitter	emitter emitValue: self string</body><body package="Values">string	"&lt;String&gt;"	^string</body></methods><methods><class-id>LiteralPrintvalue class</class-id> <category>instance creation</category><body package="Values">string: stringString	| inst |	inst := self new.	inst initializeString: stringString.	^inst</body></methods><methods><class-id>LiteralPrintvalue class</class-id> <category>test instances</category><body package="Values Development">example	^LiteralPrintvalue string: '(Date d: 8 m: 7 y: 2007)'</body></methods><methods><class-id>Tools.Trippy.OrderedDictionaryInspector</class-id> <category>private</category><body package="Values Development">createInsertionUndo: partCollection before: anIndex	self shouldNotImplement</body><body package="Values Development">refresh	"Keys in a dictionary are unordered, but for presentation arrange them	in the increasing order of their displayStrings. Do not use #collect: to collect	pairs, because #collect: coalesces equal elements, which we need to avoid."	| pairs originalSelections |	pairs := OrderedCollection new: object size.	object keys do: 		[:each | pairs add: (Inspector safeDisplayStringOf: each) -&gt; each].	linearizedParts := pairs collect: [:each | KeyedElement of: object at: each value].	originalSelections := self selections.	driver := self driverClass for: self.	driver refresh.	self selectAll: originalSelections</body></methods><methods><class-id>ValueTestingNamespace.Array</class-id> <category>accessing</category><body package="Values Testing">value	"&lt;Array&gt;"	^value ifNil: [#()]</body></methods><methods><class-id>ValueTestingNamespace.Array</class-id> <category>printing</category><body package="Values Testing">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValueTestingNamespace.Array</class-id> <category>initialize-release</category><body package="Values Testing">initializeValue: valueArray	(valueArray notNil and: [	valueArray notEmpty]) ifTrue: [			value := (Core.Array withAll: valueArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ValueTestingNamespace.Array class</class-id> <category>test instances</category><body package="Values Testing">example	^Array value: #(1 #a $x 'name')</body></methods><methods><class-id>ValueTestingNamespace.Array class</class-id> <category>instance creation</category><body package="Values Testing">value: valueArray	| inst |	inst := self new.	inst initializeValue: valueArray.	^inst</body></methods><methods><class-id>BindingSpecification</class-id> <category>source generation</category><body package="Values Development">accessorExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPutAll: self name;		nextPutAll: ' ifNil: [';		nextPutAll: (self defaultFor: aTargetClass);		nextPut: $].	^wst contents</body><body package="Values Development">accessorFor: aTargetClass	| sourceAccessor |	sourceAccessor := self sourceAccessorFor: aTargetClass.	(aTargetClass needs: sourceAccessor) ifFalse: [		^nil].	^AddMethodChange compile: sourceAccessor in: aTargetClass classified: #accessing</body><body package="Values Development">argumentName	"&lt;String&gt;"	^self name , self typeName</body><body package="Values Development">argumentOrNilStringWhen: useArgument	"&lt;String&gt;"	useArgument ifFalse: [^nil printString].	^self argumentName</body><body package="Values Development">capitalizedName	"&lt;String&gt;"	^self name copyReplaceFrom: 1 to: 1 with: (String with: self name first asUppercase)</body><body package="Values Development">exampleParameterStringFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPutAll: self setterName;		space;		nextPutAll: (self exampleStringFor: aTargetClass).	^wst contents</body><body package="Values Development">exampleStringFor: aTargetClass	"&lt;String&gt;"	^self type value literalExample asSourceFor: aTargetClass</body><body package="Values Development">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: self name;		nextPutAll: ' := ';		nextPutAll: self argumentName.	^wst contents</body><body package="Values Development">parameterString	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPutAll: self setterName;		space;		nextPutAll: self argumentName.	^wst contents</body><body package="Values Development">pragmaMessageString	"&lt;String&gt;"	self subclassResponsibility</body><body package="Values Development">pragmaString	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPut: $&lt;;		nextPutAll: self pragmaMessageString;		nextPut: $&gt;.	^wst contents</body><body package="Values Development">printExpression	"&lt;String&gt;"	self subclassResponsibility</body><body package="Values Development">printSelector	"&lt;Symbol&gt;"	"the first part of the selector used by the print method to print its contents"	self subclassResponsibility</body><body package="Values Development">setterName	"&lt;String&gt;"	^self name copyWith: $:</body><body package="Values Development">sourceAccessorFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: self name;		crtab;		nextPutAll: '"&lt;';		nextPutAll: self typeName;		nextPut: $&gt;.	self comment notEmpty ifTrue: [		wst			crtab;			nextPutAll: self comment].	wst		nextPut: $";		cr;		crtab;		nextPut: $^;		nextPutAll: (self accessorExpressionFor: aTargetClass).	^wst contents</body><body package="Values Development">typeName	"&lt;String&gt;"	^self type name asString</body></methods><methods><class-id>BindingSpecification</class-id> <category>accessing</category><body package="Values Development">comment	"&lt;String&gt;"	^comment ifNil: [String new]</body><body package="Values Development">default	^self typeName, ' new beImmutable'</body><body package="Values Development">defaultFor: aTargetClass	^self default</body><body package="Values Development">name	"&lt;String&gt;"	^selector asString</body><body package="Values Development">passModeString	"for OpenTalk StSt #passInstVars"	^#default asString</body><body package="Values Development">selector	"&lt;Symbol&gt;	required"	^selector</body><body package="Values Development">type	"&lt;LiteralBindingReference&gt;	required"	"the class of the constant values"	^self subclassResponsibility</body></methods><methods><class-id>BindingSpecification</class-id> <category>initialize-release</category><body package="Values Development">initializeSelector: selectorSymbol comment: commentString	selector := selectorSymbol.	(commentString notNil and: [	self comment ~= commentString]) ifTrue: [			comment := commentString].	self beImmutable</body></methods><methods><class-id>BindingSpecification</class-id> <category>testing</category><body package="Values Development">isOptional	"&lt;Boolean&gt;"	^false</body></methods><methods><class-id>BindingSpecification</class-id> <category>printing</category><body package="Values Development">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'selector' value: self selector).	args add: (printer optional: 'comment' value: comment).	^printer printvalue: self arguments: args</body></methods><methods><class-id>BindingSpecification class</class-id> <category>instance creation optional</category><body package="Values Development">selector: selectorSymbol	| inst |	inst := self new.	inst initializeSelector: selectorSymbol comment: nil.	^inst</body></methods><methods><class-id>BindingSpecification class</class-id> <category>instance creation</category><body package="Values Development">selector: selectorSymbol comment: commentString	| inst |	inst := self new.	inst initializeSelector: selectorSymbol comment: commentString.	^inst</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>initialize-release</category><body package="Values Development">initializeSelector: selectorSymbol comment: commentString type: typeLiteralBindingReference	selector := selectorSymbol.	(commentString notNil and: [	self comment ~= commentString]) ifTrue: [			comment := commentString].	type := typeLiteralBindingReference.	self beImmutable</body><body package="Values Development">initializeSelector: selectorSymbol type: typeLiteralBindingReference	selector := selectorSymbol.	type := typeLiteralBindingReference.	self beImmutable</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>source generation</category><body package="Values Development">printSelector	^#writeValue:</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>printing</category><body package="Values Development">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'selector' value: self selector).	args add: (printer optional: 'comment' value: comment).	args add: (printer constant: 'type' value: self type).	^printer printvalue: self arguments: args</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>accessing</category><body package="Values Development">type	"&lt;LiteralBindingReference&gt;	required"	"the class of the constant values"	^type</body></methods><methods><class-id>TypedConstantSpecification class</class-id> <category>test instances</category><body package="Values Development">example	self error: 'This method was generated. Replace parameters with practical values.'.	^self selector: Symbol new type: LiteralBindingReference new</body></methods><methods><class-id>TypedConstantSpecification class</class-id> <category>instance creation</category><body package="Values Development">selector: selectorSymbol	"type is required!	#selector:type: must be used to create a non empty instance"	^self shouldNotImplement</body><body package="Values Development">selector: selectorSymbol comment: commentString type: typeLiteralBindingReference	| inst |	inst := self new.	inst		initializeSelector: selectorSymbol		comment: commentString		type: typeLiteralBindingReference.	^inst</body></methods><methods><class-id>TypedConstantSpecification class</class-id> <category>instance creation optional</category><body package="Values Development">selector: selectorSymbol type: typeLiteralBindingReference	| inst |	inst := self new.	inst initializeSelector: selectorSymbol comment: nil type: typeLiteralBindingReference.	^inst</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>accessing</category><body package="Values Development">default	^default ifNil: [super default]</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>initialize-release</category><body package="Values Development">initializeSelector: selectorSymbol comment: commentString type: typeLiteralBindingReference default: defaultString	selector := selectorSymbol.	(commentString notNil and: [	self comment ~= commentString]) ifTrue: [			comment := commentString].	type := typeLiteralBindingReference.	(defaultString notNil and: [	self default ~= defaultString]) ifTrue: [			default := defaultString].	self beImmutable</body><body package="Values Development">initializeSelector: selectorSymbol type: typeLiteralBindingReference default: defaultString	selector := selectorSymbol.	type := typeLiteralBindingReference.	(defaultString notNil and: [	self default ~= defaultString]) ifTrue: [			default := defaultString].	self beImmutable</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>testing</category><body package="Values Development">isOptional	^true</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>source generation</category><body package="Values Development">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPut: $(;		nextPutAll: self argumentName;		nextPutAll: ' notNil and: [';		cr;		tab;		nextPutAll: 'self ';		nextPutAll: self name;		nextPutAll: ' ~= ';		nextPutAll: self argumentName;		nextPutAll: ']) ifTrue: [';		cr;		tab;		tab;		nextPutAll: self name;		nextPutAll: ' := ';		nextPutAll: self argumentName;		nextPut: $].	^wst contents</body><body package="Values Development">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'constant: ';		nextPutAll: self selector printString;		nextPutAll: ' type: ';		nextPutAll: self type printString;		nextPutAll: ' default: ';		nextPutAll: (default ifNil: ['nil'] ifNotNil: [self default printString]).	^wst contents</body><body package="Values Development">printExpression	^'optional: ', self name printString, ' value: ', self name</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>printing</category><body package="Values Development">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'selector' value: self selector).	args add: (printer optional: 'comment' value: comment).	args add: (printer constant: 'type' value: self type).	args add: (printer optional: 'default' value: default).	^printer printvalue: self arguments: args</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>test instances</category><body package="Values Development">example	^OptionalConstantSpecification		selector: #default		comment: 'if nothing is said'		type: #{String}		default: 'String new'</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>instance creation optional</category><body package="Values Development">selector: selectorSymbol comment: commentString type: typeLiteralBindingReference	| inst |	inst := self new.	inst		initializeSelector: selectorSymbol		comment: commentString		type: typeLiteralBindingReference		default: nil.	^inst</body><body package="Values Development">selector: selectorSymbol type: typeLiteralBindingReference	| inst |	inst := self new.	inst		initializeSelector: selectorSymbol		comment: nil		type: typeLiteralBindingReference		default: nil.	^inst</body><body package="Values Development">selector: selectorSymbol type: typeLiteralBindingReference default: defaultString	| inst |	inst := self new.	inst		initializeSelector: selectorSymbol		comment: nil		type: typeLiteralBindingReference		default: defaultString.	^inst</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>instance creation</category><body package="Values Development">selector: selectorSymbol comment: commentString type: typeLiteralBindingReference default: defaultString	| inst |	inst := self new.	inst		initializeSelector: selectorSymbol		comment: commentString		type: typeLiteralBindingReference		default: defaultString.	^inst</body></methods><methods><class-id>ValuePrinter</class-id> <category>accessing</category><body package="Values">array: selectorname value: object	"&lt;Printargument | nil&gt;"	object isEmpty ifTrue: [		^nil].	^Printargument name: selectorname value: (object printvalueWith: self)</body><body package="Values">classnameOf: value	^value class nameRelativeTo: self target</body><body package="Values">constant: selectorname value: object	"&lt;Printargument&gt;"	^Printargument name: selectorname value: (object printvalueWith: self)</body><body package="Values">dictionary: selectorname value: object	"&lt;Printargument | nil&gt;"	object isEmpty ifTrue: [		^nil].	^Printargument name: selectorname value: (object printvalueWith: self)</body><body package="Values">optional: selectorname value: object	"&lt;Printargument | nil&gt;"	^object ifNotNil: [		Printargument name: selectorname value: (object printvalueWith: self)]</body><body package="Values">printvalue: aValue arguments: arguments	aValue class new = aValue ifTrue: [		^ValuePrintvalue classname: (self classnameOf: aValue)].	^ValuePrintvalue		classname: (self classnameOf: aValue)		arguments: (arguments select: [:arg |			arg notNil])</body><body package="Values">target	"&lt;Value class&gt;	the class for which the object is printed.	Takes the visibility of classes into account for short class name generation"	^target</body></methods><methods><class-id>ValuePrinter</class-id> <category>initialize-release</category><body package="Values">initializeTarget: targetClass	target := targetClass</body></methods><methods><class-id>ValuePrinter class</class-id> <category>instance creation</category><body package="Values">newFor: targetClass	| inst |	inst := self new.	inst initializeTarget: targetClass.	^inst</body></methods><methods><class-id>ValueTestingNamespace.Dictionary</class-id> <category>marshaling</category><body package="Values Testing">passInstVars	"for OpenTalk StSt"	^#(#value)</body></methods><methods><class-id>ValueTestingNamespace.Dictionary</class-id> <category>accessing</category><body package="Values Testing">value	"&lt;Dictionary&gt;"	^value ifNil: [Core.Dictionary new beImmutable]</body></methods><methods><class-id>ValueTestingNamespace.Dictionary</class-id> <category>printing</category><body package="Values Testing">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer dictionary: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValueTestingNamespace.Dictionary</class-id> <category>initialize-release</category><body package="Values Testing">initializeValue: valueDictionary	(valueDictionary notNil and: [	valueDictionary notEmpty]) ifTrue: [			value := (Core.OrderedDictionary withAll: valueDictionary) beImmutable].	self beImmutable</body></methods><methods><class-id>ValueTestingNamespace.Dictionary class</class-id> <category>test instances</category><body package="Values Testing">example	^Dictionary value: (Core.OrderedDictionary		with: 1 -&gt; #symbol		with: #key -&gt; 'string')</body></methods><methods><class-id>ValueTestingNamespace.Dictionary class</class-id> <category>instance creation</category><body package="Values Testing">value: valueDictionary	| inst |	inst := self new.	inst initializeValue: valueDictionary.	^inst</body></methods><methods><class-id>ConstantSpecification</class-id> <category>source generation</category><body package="Values Development">accessorExpressionFor: aTargetClass	"&lt;String&gt;"	^self name</body><body package="Values Development">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'constant: ';		nextPutAll: self selector printString;		nextPutAll: ' type: ';		nextPutAll: self type printString.	^wst contents</body><body package="Values Development">printExpression	^'constant: ', self name printString, ' value: self ', self name</body></methods><methods><class-id>ConstantSpecification class</class-id> <category>test instances</category><body package="Values Development">example	^ConstantSpecification selector: #name comment: 'first there were names' type: #{String}</body></methods><methods><class-id>Core.OrderedDictionary</class-id> <category>accessing</category><body package="Values">atIndex: index	"&lt;Association&gt;"	^self associationAt: (self order at: index)</body><body package="Values">first	"&lt;Association&gt;"	^self associationAt: self order first</body><body package="Values">indexOf: aKey	"&lt;Integer&gt;"	^self order indexOf: aKey</body><body package="Values">keys	"&lt;SequenceableCollection of: Object&gt;"	^self order copy</body><body package="Values">last	"&lt;Association&gt;"	^self associationAt: self order last</body><body package="Values">order	"&lt;SequenceableCollection of: Object&gt;	the order of the keys"	^order ifNil: [		order := OrderedCollection new]</body></methods><methods><class-id>Core.OrderedDictionary</class-id> <category>printing</category><body package="Values">describeOn: textStream	textStream nextPutAllText: self class name asString asText allBold.	textStream nextPutAll: ' new'.	self keysAndValuesDo: [:key :value |		textStream			cr;			tab;			nextPutAll: 'at: ' , key printString , ' put: '.		textStream nextPutAllText: value printString asText allBold.		textStream nextPut: $;].	textStream		cr;		tab;		nextPutAll: 'yourself'</body><body package="Values">descriptionText	"&lt;Text&gt;	nicely formated for the user"	| wst |	wst := TextStream on: (String new: 200).	self describeOn: wst.	^wst contents</body><body package="Values">keysForPrinting	^self keys</body><body package="Values">printvalueWith: printer	^DictionaryPrintvalue arguments: (self printargumentsWith: printer) isOrdered: true</body></methods><methods><class-id>Core.OrderedDictionary</class-id> <category>comparing</category><body package="Values">= otherOrderedDictionary	^self class == otherOrderedDictionary class and: [	self size = otherOrderedDictionary size and: [	(1 to: self size) allSatisfy: [:i |		(self atIndex: i) = (otherOrderedDictionary atIndex: i)]]]</body><body package="Values">hash	^(1 to: self size) inject: self class hash into: [:hash :index |		| assoc |		assoc := self atIndex: index.		hash bitXor: (assoc key hash bitXor: assoc value hash)]</body></methods><methods><class-id>Core.OrderedDictionary</class-id> <category>enumerating</category><body package="Values">collect: oneArgumentBlock	| newCollection |	newCollection := self species new: self size.	self keysAndValuesDo: [:eachKey :eachValue | 		newCollection at: eachKey put: (oneArgumentBlock value: eachValue)].	^newCollection</body><body package="Values">do: oneArgumentBlock	self order do: [:key |		oneArgumentBlock value: (self at: key)]</body><body package="Values">keysAndValuesDo: oneArgumentBlock	self order do: [:key |		oneArgumentBlock value: key value: (self at: key)]</body></methods><methods><class-id>Core.OrderedDictionary</class-id> <category>dictionary removing</category><body package="Values">removeKey: key ifAbsent: aBlock 	| index element |	index := self findKey: key ifAbsent: nil.  "avoid full block"	index isNil ifTrue: [^aBlock value].	element := self basicAt: index.	self order remove: element key.	self basicAt: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^element value</body></methods><methods><class-id>Core.OrderedDictionary</class-id> <category>private</category><body package="Values">atNewIndex: index put: anAssociation	self basicAt: index put: anAssociation.	tally := tally + 1.	self order addLast: anAssociation key.	self fullCheck</body><body package="Values">noCheckAdd: anAssociation	super noCheckAdd: anAssociation.	self order add: anAssociation key</body><body package="Values">setTally	super setTally.	order := nil</body></methods><methods><class-id>Core.OrderedDictionary</class-id> <category>copying</category><body package="Values">postCopy	super postCopy.	order := self order copy</body></methods><methods><class-id>Core.OrderedDictionary</class-id> <category>dictionary enumerating</category><body package="Values">associationsDo: aBlock	"Note: do not use the keys to access anything.	This method is used by #changeCapacityTo: and #rehash where key access is not working"	| assocs |	assocs := Array new: self order size.	super associationsDo: [:assoc | assocs at: (self order indexOf: assoc key) put: assoc].	assocs do: aBlock</body></methods><methods><class-id>Core.OrderedDictionary</class-id> <category>user interface</category><body package="Values Development">inspectorClasses	^Array		with: Tools.Trippy.OrderedDictionaryInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Core.OrderedDictionary class</class-id> <category>test instances</category><body package="Values Development">example	"self exampleFromInfobox"	| state |	state := OrderedDictionary new.	state at: #isinTitle put: 'ISIN'.	state at: #isinValue put: 'DE0009999991'.	state at: #börsenwertTitle put: 'Börsenwert'.	state at: #börsenwertValue put: '99,9 Mrd. €'.	state at: #hochTiefTitle put: 'Hoch/Tief'.	state at: #hochTiefValue put: '10,00/20,00'.	state at: #kgvTitle put: 'KGV'.	state at: #kgvValue put: '9,87'.	^state</body></methods><methods><class-id>ValueTestingNamespace.OrderedDictionary</class-id> <category>accessing</category><body package="Values Testing">value	"&lt;Dictionary&gt;"	^value ifNil: [Core.Dictionary new beImmutable]</body></methods><methods><class-id>ValueTestingNamespace.OrderedDictionary</class-id> <category>initialize-release</category><body package="Values Testing">initializeValue: valueDictionary	(valueDictionary notNil and: [	valueDictionary notEmpty]) ifTrue: [			value := (Core.OrderedDictionary withAll: valueDictionary) beImmutable].	self beImmutable</body></methods><methods><class-id>ValueTestingNamespace.OrderedDictionary</class-id> <category>printing</category><body package="Values Testing">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer dictionary: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValueTestingNamespace.OrderedDictionary</class-id> <category>marshaling</category><body package="Values Testing">passInstVars	"for OpenTalk StSt"	^#(#value)</body></methods><methods><class-id>ValueTestingNamespace.OrderedDictionary class</class-id> <category>test instances</category><body package="Values Testing">example	^OrderedDictionary value: (Core.OrderedDictionary		with: 1 -&gt; #symbol		with: #key -&gt; 'string')</body></methods><methods><class-id>ValueTestingNamespace.OrderedDictionary class</class-id> <category>instance creation</category><body package="Values Testing">value: valueDictionary	| inst |	inst := self new.	inst initializeValue: valueDictionary.	^inst</body></methods><methods><class-id>CollectionSpecification</class-id> <category>testing</category><body package="Values Development">isOptional	"empty collection is the default"	^true</body></methods><methods><class-id>ArraySpecification</class-id> <category>accessing</category><body package="Values Development">default	^'#()'</body><body package="Values Development">type	^#{Array}</body></methods><methods><class-id>ArraySpecification</class-id> <category>source generation</category><body package="Values Development">exampleStringFor: aTargetClass	"&lt;String&gt;"	^'#(1 #a $x ''name'')'</body><body package="Values Development">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPut: $(;		nextPutAll: self argumentName;		nextPutAll: ' notNil and: [';		cr;		tab;		nextPutAll: self argumentName;		nextPutAll: ' notEmpty]) ifTrue: [';		cr;		tab;		tab;		nextPutAll: self name;		nextPutAll: ' := (';		nextPutAll: (Array nameRelativeTo: aTargetClass);		nextPutAll: ' withAll: ';		nextPutAll: self argumentName;		nextPutAll: ') beImmutable]'.	^wst contents</body><body package="Values Development">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'arrayConstant: ';		nextPutAll: self selector printString.	^wst contents</body><body package="Values Development">printExpression	^'array: ', self name printString, ' value: self ', self name</body><body package="Values Development">printSelector	^#literalArraySourceFor:</body></methods><methods><class-id>ArraySpecification class</class-id> <category>test instances</category><body package="Values Development">example	^ArraySpecification selector: #list comment: 'a list of things'</body></methods><methods><class-id>Testvalue</class-id> <category>accessing</category><body package="Values Testing">array	"&lt;Array&gt;"	^array ifNil: [#()]</body><body package="Values Testing">constant	"&lt;Symbol&gt;"	^constant</body><body package="Values Testing">dictionary	"&lt;Dictionary&gt;"	^dictionary ifNil: [Dictionary new beImmutable]</body><body package="Values Testing">optional	"&lt;Symbol&gt;"	^optional ifNil: [#none]</body></methods><methods><class-id>Testvalue</class-id> <category>marshaling</category><body package="Values Testing">passInstVars	"for OpenTalk StSt"	^#(#default #default #default #value)</body></methods><methods><class-id>Testvalue</class-id> <category>printing</category><body package="Values Testing">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'constant' value: self constant).	args add: (printer optional: 'optional' value: optional).	args add: (printer array: 'array' value: self array).	args add: (printer dictionary: 'dictionary' value: self dictionary).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Testvalue</class-id> <category>initialize-release</category><body package="Values Testing">initializeConstant: constantSymbol optional: optionalSymbol array: arrayArray dictionary: dictionaryDictionary	constant := constantSymbol.	(optionalSymbol notNil and: [	self optional ~= optionalSymbol]) ifTrue: [			optional := optionalSymbol].	(arrayArray notNil and: [	arrayArray notEmpty]) ifTrue: [			array := (Array withAll: arrayArray) beImmutable].	(dictionaryDictionary notNil and: [	dictionaryDictionary notEmpty]) ifTrue: [			dictionary := (OrderedDictionary withAll: dictionaryDictionary) beImmutable].	self beImmutable</body></methods><methods><class-id>Testvalue class</class-id> <category>instance creation optional</category><body package="Values Testing">constant: constantSymbol	| inst |	inst := self new.	inst initializeConstant: constantSymbol optional: nil array: nil dictionary: nil.	^inst</body><body package="Values Testing">constant: constantSymbol array: arrayArray	| inst |	inst := self new.	inst initializeConstant: constantSymbol optional: nil array: arrayArray dictionary: nil.	^inst</body><body package="Values Testing">constant: constantSymbol array: arrayArray dictionary: dictionaryDictionary	| inst |	inst := self new.	inst		initializeConstant: constantSymbol		optional: nil		array: arrayArray		dictionary: dictionaryDictionary.	^inst</body><body package="Values Testing">constant: constantSymbol dictionary: dictionaryDictionary	| inst |	inst := self new.	inst		initializeConstant: constantSymbol		optional: nil		array: nil		dictionary: dictionaryDictionary.	^inst</body><body package="Values Testing">constant: constantSymbol optional: optionalSymbol	| inst |	inst := self new.	inst initializeConstant: constantSymbol optional: optionalSymbol array: nil dictionary: nil.	^inst</body><body package="Values Testing">constant: constantSymbol optional: optionalSymbol array: arrayArray	| inst |	inst := self new.	inst		initializeConstant: constantSymbol		optional: optionalSymbol		array: arrayArray		dictionary: nil.	^inst</body><body package="Values Testing">constant: constantSymbol optional: optionalSymbol dictionary: dictionaryDictionary	| inst |	inst := self new.	inst		initializeConstant: constantSymbol		optional: optionalSymbol		array: nil		dictionary: dictionaryDictionary.	^inst</body></methods><methods><class-id>Testvalue class</class-id> <category>instance creation</category><body package="Values Testing">constant: constantSymbol optional: optionalSymbol array: arrayArray dictionary: dictionaryDictionary	| inst |	inst := self new.	inst		initializeConstant: constantSymbol		optional: optionalSymbol		array: arrayArray		dictionary: dictionaryDictionary.	^inst</body></methods><methods><class-id>Testvalue class</class-id> <category>test instances</category><body package="Values Testing">example	^Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x 'name')		dictionary: (OrderedDictionary			with: 1 -&gt; #symbol			with: #key -&gt; 'string')</body></methods><methods><class-id>DictionarySpecification</class-id> <category>accessing</category><body package="Values Development">default	^self defaultFor: Object</body><body package="Values Development">defaultFor: aTargetClass	^(Dictionary nameRelativeTo: aTargetClass) , ' new beImmutable'</body><body package="Values Development">passModeString	^#value asString</body><body package="Values Development">type	^#{Dictionary}</body></methods><methods><class-id>DictionarySpecification</class-id> <category>source generation</category><body package="Values Development">exampleStringFor: aTargetClass	"&lt;String&gt;"	^'(' , (OrderedDictionary nameRelativeTo: aTargetClass) , ' with: 1 -&gt; #symbol with: #key -&gt; ''string'')'</body><body package="Values Development">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPut: $(;		nextPutAll: self argumentName;		nextPutAll: ' notNil and: [';		cr;		tab;		nextPutAll: self argumentName;		nextPutAll: ' notEmpty]) ifTrue: [';		cr;		tab;		tab;		nextPutAll: self name;		nextPutAll: ' := (';		nextPutAll: (OrderedDictionary nameRelativeTo: aTargetClass);		nextPutAll: ' withAll: ';		nextPutAll: self argumentName;		nextPutAll: ') beImmutable]'.	^wst contents</body><body package="Values Development">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'dictionaryConstant: ';		nextPutAll: self selector printString.	^wst contents</body><body package="Values Development">printExpression	^'dictionary: ', self name printString, ' value: self ', self name</body><body package="Values Development">printSelector	^#literalDictionarySourceFor:</body></methods><methods><class-id>DictionarySpecification class</class-id> <category>test instances</category><body package="Values Development">example	^DictionarySpecification selector: #properties comment: 'The Properties'</body></methods><methods><class-id>Emitter</class-id> <category>writing</category><body package="Values">emit: aString	self stream nextPutAll: aString</body><body package="Values">emitArgument: aPrintargument	self emit: aPrintargument name , ': '.	aPrintargument value sourceFor: self</body><body package="Values">emitArraySourceFor: anArray	self inBracketsDo: [		anArray size &gt; 4			ifTrue: [self emitLongCollection: anArray]			ifFalse: [			self emitSmallCollection: anArray]]</body><body package="Values">emitClass: aString	self emit: aString</body><body package="Values">emitDictionarySourceFor: aDictionaryPrintvalue	self inBracketsDo: [		aDictionaryPrintvalue arguments size &gt; 4			ifTrue: [			self emitLongDictionary: aDictionaryPrintvalue]			ifFalse: [			self emitSmallDictionary: aDictionaryPrintvalue]]</body><body package="Values">emitEmpty: aValuePrintvalue	"write the constructor for an empty instance"	self emitClass: aValuePrintvalue classname.	self emit: ' new'</body><body package="Values">emitLongCollection: aSequenceableCollection	self emit: '(', (OrderedCollection nameRelativeTo: self printer target) , ' new: ' , aSequenceableCollection size printString, ')'.	aSequenceableCollection do: [:value |		self emitSeparator.		self emit: 'add: '.		value sourceFor: self.		self stream nextPut: $;].	self emitSeparator.	self emit: 'yourself'</body><body package="Values">emitLongDictionary: aDictionaryPrintvalue	self emit: '(', (aDictionaryPrintvalue targetClass nameRelativeTo: self printer target), ' new: ' , aDictionaryPrintvalue arguments size printString, ')'.	aDictionaryPrintvalue arguments do: [:argument |		self emitSeparator.		self emit: 'add: '.		argument name sourceFor: self.		self emit: ' -&gt; '.		argument value sourceFor: self.		self stream nextPut: $;].	self emitSeparator.	self emit: 'yourself'</body><body package="Values">emitSeparator	self subclassResponsibility</body><body package="Values">emitSmallCollection: aSequenceableCollection	self emit: (Array nameRelativeTo: self printer target).	aSequenceableCollection do: [:value |		self emitSeparator.		self emit: 'with: '.		value sourceFor: self]</body><body package="Values">emitSmallDictionary: aDictionaryPrintvalue	self emit: (aDictionaryPrintvalue targetClass nameRelativeTo: self printer target).	aDictionaryPrintvalue arguments do: [:argument |		self emitSeparator.		self emit: 'with: '.		argument name sourceFor: self.		self emit: ' -&gt; '.		argument value sourceFor: self]</body><body package="Values">emitValue: aString	self emit: aString</body><body package="Values">inBracketsDo: aZeroArgumentBlock	self stream nextPut: $(.	aZeroArgumentBlock ensure: [self stream nextPut: $)]</body></methods><methods><class-id>Emitter</class-id> <category>accessing</category><body package="Values">emitterClassFor: printvalue	"&lt;Emitter class&gt;"	^self subclassResponsibility</body><body package="Values">emitterFor: printvalue	"&lt;Emitter&gt;"	^(self emitterClassFor: printvalue) for: self printer on: self stream at: self level</body><body package="Values">level	"&lt;Integer&gt;	the indent level"	^level ifNil: [0]</body><body package="Values">printer	"&lt;ValuePrinter&gt;"	^printer</body><body package="Values">stream	"&lt;WriteStream | TextStream&gt;	the output stream"	^stream ifNil: [stream := self streamClass on: (String new: 100)]</body><body package="Values">streamClass	"&lt;WriteStream class | TextStream class&gt;"	^self subclassResponsibility</body></methods><methods><class-id>Emitter</class-id> <category>initialize-release</category><body package="Values">initializePrinter: aPrinter stream: aWriteStream level: anInteger	printer := aPrinter.	stream := aWriteStream.	level := anInteger</body></methods><methods><class-id>Emitter class</class-id> <category>instance creation</category><body package="Values">for: aPrinter	| inst |	inst := self new.	inst initializePrinter: aPrinter stream: nil level: -1.	^inst</body><body package="Values">for: aPrinter on: aWriteStream at: anInteger	| inst |	inst := self new.	inst initializePrinter: aPrinter stream: aWriteStream level: anInteger.	^inst</body></methods><methods><class-id>ValueSpecification</class-id> <category>source generation private</category><body package="Values Development">addChange: aRefactoryChangeOrNil to: compositeChange	aRefactoryChangeOrNil ifNotNil: [compositeChange addChange: aRefactoryChangeOrNil]</body><body package="Values Development">combinationsOf: elements	"&lt;SequenceableCollection of: (SequenceableCollection of: BindingSpecification)&gt;"	"sorted, so that all parameters are first and no optional parameters are last"	| head tail tailcombinations withHead |	elements isEmpty ifTrue: [		^#(#())].	head := elements first.	tail := elements copyFrom: 2 to: elements size.	tailcombinations := self combinationsOf: tail.	withHead := tailcombinations collect: [:combo | (Array with: head) , combo].	^withHead , tailcombinations</body><body package="Values Development">exampleFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	| source |	aTargetClass isLeafClass ifFalse: [		^nil].	source := (aTargetClass class includesSelector: #example)		ifTrue: [			[	| example |				example := aTargetClass perform: #example.				example asMethodSourceNamed: 'example'			] on: Error do: [:ex |				self sourceExampleFor: aTargetClass]]		ifFalse: [self sourceExampleFor: aTargetClass].	^self addMethod: source for: aTargetClass class in: #'test instances'</body><body package="Values Development">initializerFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	self constants isEmpty ifTrue: [		^nil].	^self		addMethod: (self sourceInitializerFor: aTargetClass)		for: aTargetClass		in: #'initialize-release'</body><body package="Values Development">needsPassInstVars	"&lt;Boolean&gt;"	^self constants anySatisfy: [:constant | constant passModeString = #value asString]</body><body package="Values Development">parameterCombinations	"&lt;SequenceableCollection of: (SequenceableCollection of: BindingSpecification)&gt;"	"sorted, so that all parameters are first and no optional parameters are last"	"each combinations contains the right conatants in the original order"	| grouped required optional |	grouped := self constants groupedBy: [:c | c isOptional].	required := grouped at: false ifAbsent: [#()].	optional := grouped at: true ifAbsent: [#()].	^((self combinationsOf: optional) collect: [:optionals |		| selection |		selection := (required , optionals) asSet.		self constants select: [:c | selection includes: c]	]) reject: [:p |		p isEmpty]</body><body package="Values Development">passInstVarsFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	self needsPassInstVars ifFalse: [		^nil].	^self addMethod: (self sourcePassInstVarsOf: aTargetClass) for: aTargetClass in: #marshaling</body><body package="Values Development">printSelector	^self class printSelector</body><body package="Values Development">sourceConstructorFor: usedConstants	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	usedConstants do: [:constant | wst nextPutAll: constant parameterString] separatedBy: [		wst space].	wst		crtab;		nextPutAll: '| inst |';		crtab;		nextPutAll: 'inst := self new.';		crtab;		nextPutAll: 'inst initialize';		nextPutAll: self constants first capitalizedName;		nextPut: $:;		space;		nextPutAll: (self constants first argumentOrNilStringWhen: (usedConstants includes: self constants first)).	(self constants copyFrom: 2 to: self constants size) do: [:constant |		wst			space;			nextPutAll: constant setterName;			space;			nextPutAll: (constant argumentOrNilStringWhen: (usedConstants includes: constant))].	wst		nextPut: $.;		crtab;		nextPutAll: '^inst'.	^wst contents</body><body package="Values Development">sourceExampleFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst		nextPutAll: 'example';		crtab;		nextPut: $^;		nextPutAll: aTargetClass name.	self constants isEmpty		ifTrue: [wst nextPutAll: ' new']		ifFalse: [		self constants do: [:constant |			wst				crtab;				tab;				nextPutAll: (constant exampleParameterStringFor: aTargetClass)]].	^wst contents</body><body package="Values Development">sourceInitializeCallString	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst		nextPutAll: 'initialize';		nextPutAll: self constants first capitalizedName;		nextPut: $:;		space;		nextPutAll: self constants first argumentName.	(self constants copyFrom: 2 to: self constants size) do: [:constant |		wst			space;			nextPutAll: constant parameterString].	^wst contents</body><body package="Values Development">sourceInitializerFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst nextPutAll: self sourceInitializeCallString.	self constants do: [:constant |		wst			crtab;			nextPutAll: (constant initializeExpressionFor: aTargetClass);			nextPut: $.].	wst		crtab;		nextPutAll: 'self beImmutable'.	^wst contents</body><body package="Values Development">sourcePassInstVarsOf: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst		nextPutAll: #passInstVars asString;		crtab;		nextPut: $";		nextPutAll: 'for OpenTalk StSt';		nextPut: $";		cr;		crtab;		nextPutAll: '^#('.	aTargetClass allInstVarNames do: [:ivar |		| selector constant |		selector := ivar asSymbol.		constant := self constants detect: [:c | c selector = selector].		wst nextPutAll: constant passModeString] separatedBy: [		wst space].	wst nextPut: $).	^wst contents</body><body package="Values Development">sourcePrintvalueWith	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 100).	wst		nextPutAll: #printvalueWith: asString;		nextPutAll: ' printer';		crtab;		nextPutAll: '| args |';		crtab;		nextPutAll: 'args := OrderedCollection new.'.	self constants do: [:constant |		wst			crtab;			nextPutAll: 'args add: (printer ';			nextPutAll: constant printExpression;			nextPutAll: ').'].	wst		crtab;		nextPutAll: '^printer printvalue: self arguments: args'.	^wst contents</body><body package="Values Development">sourcePrintvalueWithFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	^self addMethod: self sourcePrintvalueWith for: aTargetClass in: #printing</body></methods><methods><class-id>ValueSpecification</class-id> <category>source generation</category><body package="Values Development">addMethodsFor: aTargetClass to: compositeChange	aTargetClass hasSpecification ifTrue: [		| parameterCombinations |		(self changesForInstvarsOf: aTargetClass) do: [:change |			self addChange: change to: compositeChange].		parameterCombinations := self parameterCombinations.		self			addChange: (self				addMethod: (self sourceConstructorFor: parameterCombinations first)				for: aTargetClass class				in: #'instance creation')			to: compositeChange.		(parameterCombinations copyFrom: 2 to: parameterCombinations size) do: [:parameters |			self				addChange: (self					addMethod: (self sourceConstructorFor: parameters)					for: aTargetClass class					in: #'instance creation optional')				to: compositeChange].		self addChange: (self initializerFor: aTargetClass) to: compositeChange.		self constants do: [:constantSpec |			self addChange: (constantSpec accessorFor: aTargetClass) to: compositeChange]].	aTargetClass == Value ifTrue: [		^self].	aTargetClass hasSpecification ifTrue: [		self addChange: (self passInstVarsFor: aTargetClass) to: compositeChange.		self addChange: (self sourcePrintvalueWithFor: aTargetClass) to: compositeChange].	aTargetClass isLeafClass ifTrue: [		"should go into the test resources package"		self addChange: (self exampleFor: aTargetClass) to: compositeChange]</body><body package="Values Development">changesForInstvarsOf: aTargetClass	"&lt;Collection of: Change&gt;"	| changes |	changes := OrderedCollection new.	changes addAll: (self changesForObsoleteInstVarsOf: aTargetClass).	changes addAll: (self classChangeForChangingInstVarsOf: aTargetClass).	^changes</body><body package="Values Development">changesForObsoleteInstVarsOf: aTargetClass	| changes constantNames obsoleteInstvars methodsReferencingOldInstVars obsoleteConstructors |	changes := OrderedCollection new.	constantNames := self constants collect: [:const | const name].	obsoleteInstvars := aTargetClass instVarNames reject: [:varName |		constantNames includes: varName].	obsoleteInstvars isEmpty ifTrue: [		^changes].	methodsReferencingOldInstVars := obsoleteInstvars inject: Set new into: [:set :varName |		set addAll: (aTargetClass whichSelectorsAccess: varName).		set].	(methodsReferencingOldInstVars detect: [:selector | 'initialize*' match: selector asString] ifNone: [nil]) ifNotNil: [:initializer |		obsoleteConstructors := aTargetClass class whichSelectorsReferTo: initializer.		obsoleteConstructors do: [:constructor |			changes add: (RemoveMethodChange remove: constructor from: aTargetClass class)]].	methodsReferencingOldInstVars do: [:selector |		changes add: (RemoveMethodChange remove: selector from: aTargetClass)].	^changes</body><body package="Values Development">classChangeForChangingInstVarsOf: aTargetClass	"&lt;SequenceableCollection of: AddClassChange&gt;"	| localConstants newInstvarString oldInstvarString change newDefinition |	localConstants := self constants reject: [:const | aTargetClass superclass allInstVarNames includes: const name].	newInstvarString := localConstants inject: String new into: [:string :const | string , const name , ' '].	oldInstvarString := aTargetClass instanceVariablesString.	newInstvarString = oldInstvarString ifTrue: [		^#()].	newDefinition := aTargetClass definition		copyReplaceAll: 'instanceVariableNames: ' , oldInstvarString printString		with: 'instanceVariableNames: ' , newInstvarString printString.	change := AddClassChange definition: newDefinition.	^Array with: change</body></methods><methods><class-id>ValueSpecification</class-id> <category>accessing</category><body package="Values Development">constants	^constants ifNil: [#()]</body></methods><methods><class-id>ValueSpecification</class-id> <category>initialize-release</category><body package="Values Development">initializeConstants: constantsArray	(constantsArray notNil and: [	constantsArray notEmpty]) ifTrue: [		constants := (Array withAll: constantsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ValueSpecification</class-id> <category>printing</category><body package="Values Development">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'constants' value: self constants).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValueSpecification class</class-id> <category>instance creation</category><body package="Values Development">constants: constantsArray	| inst |	inst := self new.	inst initializeConstants: constantsArray.	^inst</body></methods><methods><class-id>ValueSpecification class</class-id> <category>test instances</category><body package="Values Development">example	^ValueSpecification constants: (Array		with: (ConstantSpecification			selector: #name			comment: 'first there were names'			type: #{String})		with: (OptionalConstantSpecification			selector: #default			comment: 'if nothing is said'			type: #{String}			default: 'String new')		with: (ArraySpecification selector: #list comment: 'a list of things')		with: (DictionarySpecification selector: #properties comment: 'The Properties'))</body><body package="Values Development">exampleAllOptional	^ValueSpecification constants: (Array		with: (OptionalConstantSpecification			selector: #name			comment: 'first there were names'			type: #{String}			default: 'String new')		with: (OptionalConstantSpecification			selector: #default			comment: 'if nothing is said'			type: #{String}			default: 'String new')		with: (ArraySpecification selector: #list comment: 'a list of things')		with: (DictionarySpecification selector: #properties comment: 'The Properties'))</body><body package="Values Development">exampleNoOptional	^ValueSpecification constants: (Array		with: (ConstantSpecification selector: #name type: #{String})		with: (ConstantSpecification selector: #default type: #{String})		with: (ConstantSpecification selector: #list type: #{Array})		with: (ConstantSpecification selector: #properties type: #{Core.OrderedDictionary}))</body></methods><methods><class-id>ValueSpecification class</class-id> <category>accessing</category><body package="Values Development">printSelector	^#printvalueWith:</body></methods><methods><class-id>TextEmitter</class-id> <category>writing</category><body package="Values">emitArraySourceFor: anArray	self emitSmallCollection: anArray</body><body package="Values">emitBold: aString	self stream nextPutAllText: aString asText allBold</body><body package="Values">emitClass: aString	self emitBold: aString</body><body package="Values">emitDictionarySourceFor: aDictionaryPrintvalue	self emitSmallDictionary: aDictionaryPrintvalue</body><body package="Values">emitSmallCollection: aSequenceableCollection	aSequenceableCollection do: [:value |		self emitSeparator.		value sourceFor: self]</body><body package="Values">emitSmallDictionary: aDictionaryPrintvalue	aDictionaryPrintvalue arguments do: [:argument |		self emitSeparator.		argument name sourceFor: self.		self emit: ': '.		argument value sourceFor: self]</body><body package="Values">emitValue: aString	self emitBold: aString</body></methods><methods><class-id>TextEmitter</class-id> <category>accessing</category><body package="Values">emitterClassFor: printvalue	^printvalue isLine		ifTrue: [TextLineemitter]		ifFalse: [TextBlockemitter]</body><body package="Values">streamClass	^TextStream</body></methods><methods><class-id>TextBlockemitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream cr.	self level + 1 timesRepeat: [self stream tab]</body><body package="Values">inBracketsDo: aZeroArgumentBlock	aZeroArgumentBlock value</body></methods><methods><class-id>TextBlockemitter</class-id> <category>initialize-release</category><body package="Values">initializePrinter: aPrinter stream: aWriteStream level: anInteger	printer := aPrinter.	stream := aWriteStream.	level := anInteger + 1</body></methods><methods><class-id>TextLineemitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream space</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>accessing</category><body package="Values">arguments	"&lt;Array&gt;"	^arguments ifNil: [#()]</body><body package="Values">isOrdered	"&lt;Boolean&gt;"	^isOrdered ifNil: [false]</body><body package="Values">sourceWith: emitter	self isEmpty ifTrue: [		^emitter emit: self targetClassname , ' new'].	emitter emitDictionarySourceFor: self</body><body package="Values">targetClass	^self isOrdered		ifTrue: [OrderedDictionary]		ifFalse: [Dictionary]</body><body package="Values">targetClassname	^self targetClass name asString</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeArguments: argumentsArray	(argumentsArray notNil and: [	argumentsArray notEmpty]) ifTrue: [			arguments := (Array withAll: argumentsArray) beImmutable].	self beImmutable</body><body package="Values">initializeArguments: argumentsArray isOrdered: isOrderedBoolean	(argumentsArray notNil and: [	argumentsArray notEmpty]) ifTrue: [			arguments := (Array withAll: argumentsArray) beImmutable].	(isOrderedBoolean notNil and: [	self isOrdered ~= isOrderedBoolean]) ifTrue: [			isOrdered := isOrderedBoolean].	self beImmutable</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>testing</category><body package="Values">isEmpty	^self arguments isEmpty</body><body package="Values">isLine	^self isEmpty</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'arguments' value: self arguments).	args add: (printer optional: 'isOrdered' value: isOrdered).	^printer printvalue: self arguments: args</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>instance creation optional</category><body package="Values">arguments: argumentsArray	| inst |	inst := self new.	inst initializeArguments: argumentsArray isOrdered: nil.	^inst</body><body package="Values">isOrdered: isOrderedBoolean	| inst |	inst := self new.	inst initializeArguments: nil isOrdered: isOrderedBoolean.	^inst</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>instance creation</category><body package="Values">arguments: argumentsArray isOrdered: isOrderedBoolean	| inst |	inst := self new.	inst initializeArguments: argumentsArray isOrdered: isOrderedBoolean.	^inst</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>test instances</category><body package="Values Development">example	^DictionaryPrintvalue arguments: (Array		with: (DictionaryPrintargument			name: (LiteralPrintvalue string: '123')			value: (LiteralPrintvalue string: '#value'))		with: (DictionaryPrintargument			name: (LiteralPrintvalue string: '#other')			value: (LiteralPrintvalue string: '#{Number}')))</body></methods><methods><class-id>SourceEmitter</class-id> <category>accessing</category><body package="Values">emitterClassFor: printvalue	^printvalue isLine		ifTrue: [Lineemitter]		ifFalse: [Blockemitter]</body><body package="Values">streamClass	^WriteStream</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>accessing</category><body package="Values">arguments	"&lt;Array&gt;"	^arguments ifNil: [#()]</body><body package="Values">sourceWith: emitter	emitter emitArraySourceFor: self arguments</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeArguments: argumentsArray	(argumentsArray notNil and: [	argumentsArray notEmpty]) ifTrue: [			arguments := (Array withAll: argumentsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>testing</category><body package="Values">isLine	^self arguments size = 1 or: [	self arguments size &lt; 5 and: [	self arguments allSatisfy: [:arg | arg isSimple]]]</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'arguments' value: self arguments).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ArrayPrintvalue class</class-id> <category>instance creation</category><body package="Values">arguments: argumentsArray	| inst |	inst := self new.	inst initializeArguments: argumentsArray.	^inst</body></methods><methods><class-id>ArrayPrintvalue class</class-id> <category>test instances</category><body package="Values Development">example	^ArrayPrintvalue arguments: (Array		with: (Printargument name: 'selector' value: '#value')		with: (Printargument name: 'type' value: '#{Number}'))</body></methods><methods><class-id>Printargument</class-id> <category>initialize-release</category><body package="Values">initializeName: nameString value: valuePrintvalue	name := nameString.	value := valuePrintvalue.	self beImmutable</body></methods><methods><class-id>Printargument</class-id> <category>testing</category><body package="Values">isSimple	^self value isSimple</body></methods><methods><class-id>Printargument</class-id> <category>accessing</category><body package="Values">name	"&lt;String&gt;"	^name</body><body package="Values">sourceWith: emitter	emitter emitArgument: self</body><body package="Values">value	"&lt;Printvalue&gt;"	^value</body></methods><methods><class-id>Printargument</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'name' value: self name).	args add: (printer constant: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Printargument class</class-id> <category>instance creation</category><body package="Values">name: nameString value: valuePrintvalue	| inst |	inst := self new.	inst initializeName: nameString value: valuePrintvalue.	^inst</body></methods><methods><class-id>Printargument class</class-id> <category>test instances</category><body package="Values Development">example	^Printargument		name: 'constant'		value: (ValuePrintvalue			classname: 'ConstantSpecification'			arguments: (Array				with: (Printargument name: 'selector' value: '#value')				with: (Printargument name: 'type' value: '#{Number}')))</body></methods><methods><class-id>Lineemitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream space</body></methods><methods><class-id>DictionaryPrintargument class</class-id> <category>test instances</category><body package="Values Development">example	^DictionaryPrintargument name: Printvalue new value: Printvalue new</body></methods><methods><class-id>ValueGenerationTests</class-id> <category>Testing</category><body package="Values Testing">testAllOptionalParameterCombinations	| parameterCollections |	parameterCollections := ValueSpecification exampleAllOptional parameterCombinations.	self assert: (parameterCollections collect: [:parameters |		(parameters collect: [:p | p selector]) asArray]) asArray = #(#(#name #default #list #properties) #(#name #default #list) #(#name #default #properties) #(#name #default) #(#name #list #properties) #(#name #list) #(#name #properties) #(#name) #(#default #list #properties) #(#default #list) #(#default #properties) #(#default) #(#list #properties) #(#list) #(#properties))</body><body package="Values Testing">testArraySpecification	self assert: ArraySpecification example selector = #list.	self assert: ArraySpecification example name = 'list'.	self assert: ArraySpecification example comment = 'a list of things'.	self assert: ArraySpecification example capitalizedName = 'List'.	self assert: ArraySpecification example type printString = #{Array} printString.	self assert: ArraySpecification example typeName = 'Array'.	self assert: ArraySpecification example argumentName = 'listArray'.	self assert: (ArraySpecification example initializeExpressionFor: Testvalue) = '(listArray notNil and: [	listArray notEmpty]) ifTrue: [		list := (Array withAll: listArray) beImmutable]'.	self assert: (ArraySpecification example initializeExpressionFor: ValueTestingNamespace.Array) = '(listArray notNil and: [	listArray notEmpty]) ifTrue: [		list := (Core.Array withAll: listArray) beImmutable]'.	self assert: (ArraySpecification example sourceAccessorFor: Testvalue) = 'list	"&lt;Array&gt;	a list of things"	^list ifNil: [#()]'.	self assert: (ArraySpecification example sourceAccessorFor: ValueTestingNamespace.Array) = (ArraySpecification example sourceAccessorFor: Testvalue)</body><body package="Values Testing">testConstantSpecification	self assert: ConstantSpecification example name = 'name'.	self assert: ConstantSpecification example comment = 'first there were names'.	self assert: ConstantSpecification example capitalizedName = 'Name'.	self assert: ConstantSpecification example type printString = #{String} printString.	self assert: ConstantSpecification example typeName = 'String'.	self assert: ConstantSpecification example argumentName = 'nameString'.	self assert: (ConstantSpecification example initializeExpressionFor: Testvalue) = 'name := nameString'</body><body package="Values Testing">testConstantSpecificationArgumentName	self assert: ArraySpecification example argumentName = 'listArray'.	self assert: DictionarySpecification example argumentName = 'propertiesDictionary'.	self assert: ConstantSpecification example argumentName = 'nameString'.	self assert: OptionalConstantSpecification example argumentName = 'defaultString'.</body><body package="Values Testing">testConstantSpecificationExampleString	self assert: (ArraySpecification example exampleStringFor: Object) = '#(1 #a $x ''name'')'.	self assert: (DictionarySpecification example exampleStringFor: Object) = '(OrderedDictionary with: 1 -&gt; #symbol with: #key -&gt; ''string'')'.	self assert: (ConstantSpecification example exampleStringFor: Object) = '''a string'''.	self assert: (OptionalConstantSpecification example exampleStringFor: Object) = '''a string'''</body><body package="Values Testing">testConstantSpecificationInitializeExpression	self assert: (ArraySpecification example initializeExpressionFor: Testvalue) = '(listArray notNil and: [	listArray notEmpty]) ifTrue: [		list := (Array withAll: listArray) beImmutable]'.	self assert: (DictionarySpecification example initializeExpressionFor: Testvalue) = '(propertiesDictionary notNil and: [	propertiesDictionary notEmpty]) ifTrue: [		properties := (OrderedDictionary withAll: propertiesDictionary) beImmutable]'.	self assert: (ConstantSpecification example initializeExpressionFor: Testvalue) = 'name := nameString'.	self assert: (OptionalConstantSpecification example initializeExpressionFor: Testvalue) = '(defaultString notNil and: [	self default ~= defaultString]) ifTrue: [		default := defaultString]'</body><body package="Values Testing">testConstantSpecificationName	self assert: ConstantSpecification example selector = #name.	self assert: OptionalConstantSpecification example selector = #default.	self assert: ArraySpecification example selector = #list.	self assert: DictionarySpecification example selector = #properties.	self assert: ConstantSpecification example name = 'name'.	self assert: OptionalConstantSpecification example name = 'default'.	self assert: ArraySpecification example name = 'list'.	self assert: DictionarySpecification example name = 'properties'.	self assert: ConstantSpecification example comment = 'first there were names'.	self assert: OptionalConstantSpecification example comment = 'if nothing is said'.	self assert: ArraySpecification example comment = 'a list of things'.	self assert: DictionarySpecification example comment = 'The Properties'.	self assert: ConstantSpecification example setterName = 'name:'.	self assert: OptionalConstantSpecification example setterName = 'default:'.	self assert: ArraySpecification example setterName = 'list:'.	self assert: DictionarySpecification example setterName = 'properties:'.	self assert: ConstantSpecification example capitalizedName = 'Name'.	self assert: OptionalConstantSpecification example capitalizedName = 'Default'.	self assert: ArraySpecification example capitalizedName = 'List'.	self assert: DictionarySpecification example capitalizedName = 'Properties'.</body><body package="Values Testing">testConstantSpecificationType	self assert: ArraySpecification example type printString = #{Array} printString.	self assert: DictionarySpecification example type printString = #{Dictionary} printString.	self assert: ConstantSpecification example type printString = #{String} printString.	self assert: OptionalConstantSpecification example type printString = #{String} printString.	self assert: ArraySpecification example typeName = 'Array'.	self assert: DictionarySpecification example typeName = 'Dictionary'.	self assert: ConstantSpecification example typeName = 'String'.	self assert: OptionalConstantSpecification example typeName = 'String'</body><body package="Values Testing">testDictionarySpecification	self assert: DictionarySpecification example selector = #properties.	self assert: DictionarySpecification example name = 'properties'.	self assert: DictionarySpecification example comment = 'The Properties'.	self assert: DictionarySpecification example capitalizedName = 'Properties'.	self assert: DictionarySpecification example type printString = #{Dictionary} printString.	self assert: DictionarySpecification example typeName = 'Dictionary'.	self assert: DictionarySpecification example argumentName = 'propertiesDictionary'.	self assert: (DictionarySpecification example initializeExpressionFor: Testvalue) = '(propertiesDictionary notNil and: [	propertiesDictionary notEmpty]) ifTrue: [		properties := (OrderedDictionary withAll: propertiesDictionary) beImmutable]'.	self assert: (DictionarySpecification example initializeExpressionFor: ValueTestingNamespace.Array) = '(propertiesDictionary notNil and: [	propertiesDictionary notEmpty]) ifTrue: [		properties := (Core.OrderedDictionary withAll: propertiesDictionary) beImmutable]'.	self assert: (DictionarySpecification example sourceAccessorFor: Testvalue) = 'properties	"&lt;Dictionary&gt;	The Properties"	^properties ifNil: [Dictionary new beImmutable]'.	self assert: (DictionarySpecification example sourceAccessorFor: ValueTestingNamespace.Array) = 'properties	"&lt;Dictionary&gt;	The Properties"	^properties ifNil: [Core.Dictionary new beImmutable]'.</body><body package="Values Testing">testFullSpecification	self assert: Value specification = ValueSpecification new.	self assert: (OptionalConstantSpecification specification constants collect: [:c | c selector]) = #(#selector #comment #type #default).</body><body package="Values Testing">testNoOptionalParameterCombinations	| parameterCollections |	parameterCollections := ValueSpecification exampleNoOptional parameterCombinations.	self assert: (parameterCollections collect: [:parameters |		(parameters collect: [:p | p selector]) asArray]) asArray = #(#(#name #default #list #properties))</body><body package="Values Testing">testOptionalConstantSpecification	self assert: OptionalConstantSpecification example name = 'default'.	self assert: OptionalConstantSpecification example comment = 'if nothing is said'.	self assert: OptionalConstantSpecification example capitalizedName = 'Default'.	self assert: OptionalConstantSpecification example type printString = #{String} printString.	self assert: OptionalConstantSpecification example typeName = 'String'.	self assert: OptionalConstantSpecification example argumentName = 'defaultString'.	self assert: (OptionalConstantSpecification example initializeExpressionFor: Testvalue) = '(defaultString notNil and: [	self default ~= defaultString]) ifTrue: [		default := defaultString]'</body><body package="Values Testing">testOptionalParameterCombinations	| parameterCollections |	parameterCollections := ValueSpecification example parameterCombinations.	self assert: (parameterCollections collect: [:parameters | (parameters collect: [:p | p selector]) asArray]) asArray = #(#(#name #default #list #properties) #(#name #default #list) #(#name #default #properties) #(#name #default) #(#name #list #properties) #(#name #list) #(#name #properties) #(#name))</body><body package="Values Testing">testOptionalParameters	| parameters |	parameters := ValueSpecification example constants asSet select: [:constant | constant isOptional not].	self assert: parameters asArray = (Array with: (ConstantSpecification selector: #name comment: 'first there were names' type: #{String}))</body><body package="Values Testing">testPrintExpression	self assert: ConstantSpecification example printExpression = 'constant: ''name'' value: self name'.	self assert: OptionalConstantSpecification example printExpression = 'optional: ''default'' value: default'.	self assert: ArraySpecification example printExpression = 'array: ''list'' value: self list'.	self assert: DictionarySpecification example printExpression = 'dictionary: ''properties'' value: self properties'</body><body package="Values Testing">testSource	self assert: OptionalConstantSpecification specification sourcePrintvalueWith = 'printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: ''selector'' value: self selector).	args add: (printer optional: ''comment'' value: comment).	args add: (printer constant: ''type'' value: self type).	args add: (printer optional: ''default'' value: default).	^printer printvalue: self arguments: args'</body><body package="Values Testing">testSource2	self assert: ValueSpecification specification sourcePrintvalueWith = 'printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: ''constants'' value: self constants).	^printer printvalue: self arguments: args'</body><body package="Values Testing">testSourceConstructorWithoutOptionals	| parameters |	parameters := ValueSpecification example constants select: [:constant | constant isOptional not].	self assert: (ValueSpecification example sourceConstructorFor: parameters) = 'name: nameString	| inst |	inst := self new.	inst initializeName: nameString default: nil list: nil properties: nil.	^inst'</body><body package="Values Testing">testSourceExample	self assert: (ValueSpecification example sourceExampleFor: Object) = 'example	^Object		name: ''a string''		default: ''a string''		list: #(1 #a $x ''name'')		properties: (OrderedDictionary with: 1 -&gt; #symbol with: #key -&gt; ''string'')'</body><body package="Values Testing">testSourceInitialize	self assert: (ValueSpecification example sourceInitializerFor: Testvalue) = 'initializeName: nameString default: defaultString list: listArray properties: propertiesDictionary	name := nameString.	(defaultString notNil and: [	self default ~= defaultString]) ifTrue: [		default := defaultString].	(listArray notNil and: [	listArray notEmpty]) ifTrue: [		list := (Array withAll: listArray) beImmutable].	(propertiesDictionary notNil and: [	propertiesDictionary notEmpty]) ifTrue: [		properties := (OrderedDictionary withAll: propertiesDictionary) beImmutable].	self beImmutable'</body></methods><methods><class-id>ValuePrinterTests</class-id> <category>Testing</category><body package="Values Testing">testArray	self assert: Array new asSource = '#()'.	self assert: #(1 2 3 4) asSource = '#(1 2 3 4)'.	self assert: #(1 2 3 4 5 6 7 8 9 10) asSource = '#(1 2 3 4 5 6 7 8 9 10)'.	self assert: (Array with: 1 with: 2 with: 3 with: 4) asSource = '#(1 2 3 4)'.	self assert: (Array with: 1 with: (Date d: 7 m: 7 y: 2007) with: ColorValue red) asSource = '(Array	with: 1	with: (Date d: 7 m: 7 y: 2007)	with: ColorValue red)'.	self assert: (#(1 2 3 4) , (Array with: (Date d: 7 m: 7 y: 2007))) asSource = '((OrderedCollection new: 5)	add: 1;	add: 2;	add: 3;	add: 4;	add: (Date d: 7 m: 7 y: 2007);	yourself)'.	self assert: (Array with: Testvalue example with: (Date d: 7 m: 7 y: 2007) with: ColorValue red) asSource = '(Array	with: (Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x ''name'')		dictionary: (OrderedDictionary			with: 1 -&gt; #symbol			with: #key -&gt; ''string''))	with: (Date d: 7 m: 7 y: 2007)	with: ColorValue red)'.</body><body package="Values Testing">testArraySource	self assert: (Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x 'name')		dictionary: (Dictionary			with: 1 -&gt; #symbol			with: #key -&gt; 'string')) asSource = '(Testvalue	constant: #constantSymbol	optional: #optionalSymbol	array: #(1 #a $x ''name'')	dictionary: (OrderedDictionary		with: 1 -&gt; #symbol		with: #key -&gt; ''string''))'.</body><body package="Values Testing">testArrayWithValue	self assert: (Array with: ValueSpecification example) asSource = '(Array with: (ValueSpecification	constants: (Array		with: (ConstantSpecification selector: #name comment: ''first there were names'' type: #{String})		with: (OptionalConstantSpecification selector: #default comment: ''if nothing is said'' type: #{String} default: ''String new'')		with: (ArraySpecification selector: #list comment: ''a list of things'')		with: (DictionarySpecification selector: #properties comment: ''The Properties''))))'</body><body package="Values Testing">testColorValue	self assert: ColorValue new asSource = 'ColorValue new'.	self assert: ColorValue red asSource = 'ColorValue red'.	self assert: (ColorValue scaledRed: 8191 scaledGreen: 0 scaledBlue: 0) asSource = 'ColorValue red'.	self assert: (ColorValue scaledRed: 8191 scaledGreen: 0 scaledBlue: 10) asSource = '(ColorValue scaledRed: 8191 scaledGreen: 0 scaledBlue: 10)'</body><body package="Values Testing">testDate	self should: [Date new asSource] raise: MessageNotUnderstood.	self assert: (Date d: 7 m: 7 y: 2007) asSource = '(Date d: 7 m: 7 y: 2007)'</body><body package="Values Testing">testDictionary	| dict |	self assert: OrderedDictionary new asSource = 'OrderedDictionary new'.	dict := OrderedDictionary		with: 1 -&gt; 75		with: #b -&gt; $x.	self assert: dict asSource = '(OrderedDictionary	with: 1 -&gt; 75	with: #b -&gt; $x)'</body><body package="Values Testing">testDictionarySource	self assert: (Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x 'name')		dictionary: (Dictionary			with: 1 -&gt; #symbol			with: #key -&gt; 'string')) asSource = '(Testvalue	constant: #constantSymbol	optional: #optionalSymbol	array: #(1 #a $x ''name'')	dictionary: (OrderedDictionary		with: 1 -&gt; #symbol		with: #key -&gt; ''string''))'.	self assert: (Testvalue constant: #Haider) asSource = '(Testvalue constant: #Haider)'</body><body package="Values Testing">testDictionaryWithValues	| dict |	dict := OrderedDictionary		with: 1 -&gt; Testvalue example		with: Testvalue example -&gt; $x.	self assert: dict asSource = '(OrderedDictionary	with: 1 -&gt; (Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x ''name'')		dictionary: (OrderedDictionary			with: 1 -&gt; #symbol			with: #key -&gt; ''string''))	with: (Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x ''name'')		dictionary: (OrderedDictionary			with: 1 -&gt; #symbol			with: #key -&gt; ''string'')) -&gt; $x)'</body><body package="Values Testing">testLiteralArrays	self assert: #(1 2 10 20 100) asSource = '#(1 2 10 20 100)'</body><body package="Values Testing">testLongDictionary	| dict |	dict := Dictionary new.	dict at: 1 put: 75.	dict at: #b put: $x.	dict at: 42 put: 'Hello'.	dict at: 'abc' put: 32.06s.	dict at: 2.004s put: #{String}.	dict at: true put: #hi.	self assert: dict asSource = '((Dictionary new: 6)	add: 1 -&gt; 75;	add: ''abc'' -&gt; 32.06s;	add: true -&gt; #hi;	add: 2.004s -&gt; #{String};	add: #b -&gt; $x;	add: 42 -&gt; ''Hello'';	yourself)'</body><body package="Values Testing">testNamespaceArraySource	self assert: (ValueTestingNamespace.Array value: (Array		with: (Date d: 25 m: 2 y: 2010)		with: #(#a #b #c))) asSource = '(Array	value: (Core.Array		with: (Date d: 25 m: 2 y: 2010)		with: #(#a #b #c)))'</body><body package="Values Testing">testOptionalConstantSource	self assert: (Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x 'name')		dictionary: (Dictionary			with: 1 -&gt; #symbol			with: #key -&gt; 'string')) asSource = '(Testvalue	constant: #constantSymbol	optional: #optionalSymbol	array: #(1 #a $x ''name'')	dictionary: (OrderedDictionary		with: 1 -&gt; #symbol		with: #key -&gt; ''string''))'.	self assert: (Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x 'name')) asSource = '(Testvalue constant: #constantSymbol optional: #optionalSymbol array: #(1 #a $x ''name''))'.	self assert: (Testvalue constant: #constantSymbol optional: #optionalSymbol) asSource = '(Testvalue constant: #constantSymbol optional: #optionalSymbol)'.	self assert: (Testvalue constant: #constantSymbol) asSource = '(Testvalue constant: #constantSymbol)'</body><body package="Values Testing">testPoint	self assert: (1 @ 2) asSource = '1 @ 2'.	self assert: (1 @ (Date d: 7 m: 7 y: 2007)) asSource = '1 @ (Date d: 7 m: 7 y: 2007)'</body><body package="Values Testing">testTime	self assert: Time new asSource = 'Time zero'.	self assert: (Time h: 7 m: 27 s: 13) asSource = '(Time h: 7 m: 27 s: 13)'.	self assert: (Time h: 7 m: 27 s: 0) asSource = '(Time h: 7 m: 27)'.	self assert: (Time h: 7 m: 27) asSource = '(Time h: 7 m: 27)'.	self assert: (Time h: 7 m: 0 s: 0) asSource = '(Time h: 7)'.	self assert: (Time h: 7 m: 0) asSource = '(Time h: 7)'.	self assert: (Time h: 7) asSource = '(Time h: 7)'.	self assert: (Time h: 0) asSource = 'Time zero'.	self assert: Time zero asSource = 'Time zero'</body><body package="Values Testing">testTimestamp	self assert: Timestamp new asSource = '(Timestamp d: 1 m: 1 y: 0)'.	self assert: (Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27 s: 13) asSource = '(Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27 s: 13)'.	self assert: (Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27 s: 0) asSource = '(Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27)'.	self assert: (Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27) asSource = '(Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27)'.	self assert: (Timestamp d: 15 m: 7 y: 2007 h: 7 m: 0 s: 0) asSource = '(Timestamp d: 15 m: 7 y: 2007 h: 7)'.	self assert: (Timestamp d: 15 m: 7 y: 2007 h: 7 m: 0) asSource = '(Timestamp d: 15 m: 7 y: 2007 h: 7)'.	self assert: (Timestamp d: 15 m: 7 y: 2007 h: 7) asSource = '(Timestamp d: 15 m: 7 y: 2007 h: 7)'.	self assert: (Timestamp d: 15 m: 7 y: 2007 h: 0) asSource = '(Timestamp d: 15 m: 7 y: 2007)'.	self assert: (Timestamp d: 15 m: 7 y: 2007) asSource = '(Timestamp d: 15 m: 7 y: 2007)'</body><body package="Values Testing">testValuespecificationExample	self assert: ValueSpecification example asSource = '(ValueSpecification	constants: (Array		with: (ConstantSpecification selector: #name comment: ''first there were names'' type: #{String})		with: (OptionalConstantSpecification selector: #default comment: ''if nothing is said'' type: #{String} default: ''String new'')		with: (ArraySpecification selector: #list comment: ''a list of things'')		with: (DictionarySpecification selector: #properties comment: ''The Properties'')))'</body></methods><methods><class-id>Blockemitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream cr.	self level + 1 timesRepeat: [self stream tab]</body></methods><methods><class-id>Blockemitter</class-id> <category>initialize-release</category><body package="Values">initializePrinter: aPrinter stream: aWriteStream level: anInteger	printer := aPrinter.	stream := aWriteStream.	level := anInteger + 1</body></methods><methods><class-id>OrderedDictionaryTests</class-id> <category>Testing</category><body package="Values Testing">testAdding	| od od1 |	od := OrderedDictionary new.	self assert: od isEmpty.	od add: #foo -&gt; 'bar'.	self assert: od size = 1.	self assert: (od atIndex: 1) = (#foo -&gt; 'bar').	self assert: (od at: #foo) = 'bar'.	od at: #baz put: 'xxx'.	self assert: od size = 2.	self assert: (od atIndex: 2) = (#baz -&gt; 'xxx').	self assert: (od at: #baz) = 'xxx'.	od1 := OrderedDictionary new.	od1 add: #foo -&gt; 'baz'.	od1 at: #baz put: 'yyy'.	od addAll: od1.	self assert: od size = 2.	self assert: (od at: #foo) = 'baz'.	self assert: (od at: #baz) = 'yyy'.</body><body package="Values Testing">testComparing	self assert: (OrderedDictionary with: #foo -&gt; 'bar') = (OrderedDictionary with: #foo -&gt; 'bar').	self deny: (OrderedDictionary with: #foo -&gt; 'bar') == (OrderedDictionary with: #foo -&gt; 'bar').	self deny: (OrderedDictionary with: #foo -&gt; 'bar') = (Dictionary with: #foo -&gt; 'bar').	self deny: (Dictionary with: #foo -&gt; 'bar') = (OrderedDictionary with: #foo -&gt; 'bar').	self assert: (OrderedDictionary with: #foo -&gt; 'bar' with: $a -&gt; 123) = (OrderedDictionary with: #foo -&gt; 'bar' with: $a -&gt; 123).	self deny: (OrderedDictionary with: #foo -&gt; 'bar' with: $a -&gt; 123) = (OrderedDictionary with: $a -&gt; 123 with: #foo -&gt; 'bar' ).	self deny: (OrderedDictionary with: #foo -&gt; 'bar' with: $a -&gt; 123) = (OrderedDictionary with: #foo -&gt; 123 with: $a -&gt; 'bar' ).	self deny: (OrderedDictionary with: #foo -&gt; 'bar' with: $a -&gt; 123) = (OrderedDictionary with: #foo -&gt; 'bar' with: $a -&gt; 1234).	self deny: (OrderedDictionary with: #foo -&gt; 'bar' with: $a -&gt; 123) = (OrderedDictionary with: #foo -&gt; 'bars' with: $a -&gt; 123).	self deny: (OrderedDictionary with: #foo -&gt; 'bar' with: $a -&gt; 123) = (OrderedDictionary with: #foo -&gt; 'bar' with: $a -&gt; 123 with: '' -&gt; 0).</body><body package="Values Testing">testDescribe	self assert: OrderedDictionary example asSource = '((OrderedDictionary new: 8)	add: #isinTitle -&gt; ''ISIN'';	add: #isinValue -&gt; ''DE0009999991'';	add: #börsenwertTitle -&gt; ''Börsenwert'';	add: #börsenwertValue -&gt; ''99,9 Mrd. €'';	add: #hochTiefTitle -&gt; ''Hoch/Tief'';	add: #hochTiefValue -&gt; ''10,00/20,00'';	add: #kgvTitle -&gt; ''KGV'';	add: #kgvValue -&gt; ''9,87'';	yourself)'</body><body package="Values Testing">testDescribeAndReadBackNew	| inst |	inst := OrderedDictionary new.	self assert: inst asDescription = (Compiler evaluate: inst asSource) asDescription</body><body package="Values Testing">testEnumeration	| od |	od := OrderedDictionary new.	od add: #foo -&gt; 'bar'.	od at: #baz put: 'xxx'.	od associationsDo: [:assoc |		self assert: (assoc isKindOf: Association).		self assert: assoc key isSymbol.		self assert: assoc value isString].</body><body package="Values Testing">testIndexOf	| od |	od := OrderedDictionary new.	self assert: od isEmpty.	self assert: (od indexOf: #foo) isZero.	od add: #foo -&gt; 'bar'.	self assert: od size = 1.	self assert: (od indexOf: #foo) = 1.	self assert: (od indexOf: #baz) isZero.	od at: #baz put: 'xxx'.	self assert: od size = 2.	self assert: (od indexOf: #baz) = 2.</body><body package="Values Testing">testIndexedAccess	| od |	od := OrderedDictionary new.	od add: #foo -&gt; 'bar'.	self assert: od size = 1.	self assert: (od atIndex: 1) = (#foo -&gt; 'bar').	self should: [od atIndex: 0] raise: SubscriptOutOfBoundsError.	self should: [od atIndex: 2] raise: SubscriptOutOfBoundsError.	self should: [od atIndex: #key] raise: NonIntegerIndexError.	self should: [od atIndex: '1'] raise: NonIntegerIndexError.</body><body package="Values Testing">testKeyedAccess	| od |	od := OrderedDictionary new.	od add: #foo -&gt; 'bar'.	od at: #baz put: 'xxx'.	self assert: od size = 2.	self assert: (od at: #foo) = 'bar'.	self assert: (od at: #baz) = 'xxx'.	self should: [od at: #bar] raise: NotFoundError.	self assert: (od at: #bar ifAbsent: [nil]) isNil.</body><body package="Values Testing">testReadBackAllTestInstances	(OrderedDictionary class organization listAtCategoryNamed: 'test instances' asSymbol) do: [:sel |		| inst readInst |		inst := OrderedDictionary perform: sel.		self			shouldnt: [			readInst := Compiler				evaluate: inst asSource				for: self				in: inst class environment				notifying: nil				logged: false]			raise: SyntaxErrorException.		self assert: inst asSource = readInst asSource]</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>accessing</category><body package="Values">arguments	"&lt;Array&gt;"	^arguments ifNil: [#()]</body><body package="Values">classname	"&lt;String&gt;"	^classname</body><body package="Values">sourceWith: emitter	self arguments isEmpty ifTrue: [		^emitter emitEmpty: self].	emitter inBracketsDo: [		emitter emitClass: self classname.		self arguments do: [:arg |			emitter emitSeparator.			emitter emitArgument: arg]]</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeClassname: classnameString arguments: argumentsArray	classname := classnameString.	(argumentsArray notNil and: [	argumentsArray notEmpty]) ifTrue: [			arguments := (Array withAll: argumentsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>testing</category><body package="Values">isLine	self arguments size = 1 ifTrue: [		^self arguments first value isLine].	^self arguments size &lt; 5 and: [	self arguments allSatisfy: [:arg | arg isSimple]]</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'classname' value: self classname).	args add: (printer array: 'arguments' value: self arguments).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>instance creation optional</category><body package="Values">classname: classnameString	| inst |	inst := self new.	inst initializeClassname: classnameString arguments: nil.	^inst</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>instance creation</category><body package="Values">classname: classnameString arguments: argumentsArray	| inst |	inst := self new.	inst initializeClassname: classnameString arguments: argumentsArray.	^inst</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>test instances</category><body package="Values Development">example	^ValuePrintvalue		classname: 'ConstantSpecification'		arguments: (Array			with: (Printargument name: 'selector' value: '#value')			with: (Printargument name: 'type' value: '#{Number}'))</body></methods><methods><class-id>ScopeTests</class-id> <category>Testing</category><body package="Values Testing">testScope	self assert: (DictionarySpecification isInScope: UI.Dialog).	self assert: (UI.Dialog nameRelativeTo: DictionarySpecification) = 'Dialog'.	self assert: (DictionarySpecification isInScope: Store.Access) not.	self assert: (Store.Access nameRelativeTo: DictionarySpecification) = 'Store.Access'.</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	wst		nextPut: $(;		nextPutAll: (self origin asSourceFor: printer target);		nextPutAll: ' corner: ';		nextPutAll: (self corner asSourceFor: printer target);		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Core.Point</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| string |	string := (self x asSourceFor: printer target) , ' @ ' , (self y asSourceFor: printer target).	^LiteralPrintvalue string: string</body></methods><methods><class-id>Core.Dictionary</class-id> <category>dictionary testing</category><body package="Values">isEqualValue: anObject	^self contentsEquals: anObject</body></methods><methods><class-id>Core.Dictionary</class-id> <category>printing</category><body package="Values">keysForPrinting	^[self keys asSortedCollection] on: Error do: [:ex | ex return: self keys]</body><body package="Values">printargumentsWith: printer	| args |	args := OrderedCollection new.	self keysForPrinting do: [:key |		args add: (DictionaryPrintargument			name: (key printvalueWith: printer)			value: ((self at: key) printvalueWith: printer))].	^args</body><body package="Values">printvalueWith: printer	^DictionaryPrintvalue arguments: (self printargumentsWith: printer)</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>testing</category><body package="Values">isEmpty	^self scaledRed isNil and: [	self scaledGreen isNil and: [	self scaledBlue isNil]]</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	self class constantNames do: [:const |		(self class perform: const) = self ifTrue: [			^LiteralPrintvalue string: (printer classnameOf: self) , ' ' , const asString]].	args := OrderedCollection new.	args add: (printer constant: 'scaledRed' value: self scaledRed).	args add: (printer constant: 'scaledGreen' value: self scaledGreen).	args add: (printer constant: 'scaledBlue' value: self scaledBlue).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>printing</category><body package="Values">printvalueWith: printer	self isLiteral ifTrue: [		^LiteralPrintvalue string: self storeString].	^ArrayPrintvalue arguments: (self collect: [:item | item printvalueWith: printer])</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="Values">isInScope: aClass	"&lt;Boolean&gt;	true if aClass is visible by the receiver - aClass can be used in the source without namespace qualifier.	false when aClass cannot be seen by the receiver - use the fullName"	| variableDefinition |	variableDefinition := (NameScope forClass: self) variableAt: aClass name from: nil.	^variableDefinition notNil and: [	variableDefinition binding value == aClass]</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Values">nameRelativeTo: targetClass	"&lt;String&gt;"	"self nameRelativeTo: Object"	| ref |	(targetClass isInScope: self) ifTrue: [		^self name asString].	ref := self fullyQualifiedReference.	ref environmentName ifNil: [ref := self fullyQualifiedReferenceFrom: Root].	^ref asString</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation</category><body package="Values">d: dayInteger m: monthInteger y: yearInteger	^self newDay: dayInteger monthNumber: monthInteger year: yearInteger</body></methods><methods><class-id>Core.Date</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' d: ';		nextPutAll: self dayOfMonth printString;		nextPutAll: ' m: ';		nextPutAll: self monthIndex printString;		nextPutAll: ' y: ';		nextPutAll: self year printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Values">d: dayInteger m: monthInteger y: yearInteger	| date time |	date := Date d: dayInteger m: monthInteger y: yearInteger.	time := Time h: 0.	^self fromDate: date andTime: time</body><body package="Values">d: dayInteger m: monthInteger y: yearInteger h: hoursInteger	| date time |	date := Date d: dayInteger m: monthInteger y: yearInteger.	time := Time h: hoursInteger.	^self fromDate: date andTime: time</body><body package="Values">d: dayInteger m: monthInteger y: yearInteger h: hoursInteger m: minutesInteger	| date time |	date := Date d: dayInteger m: monthInteger y: yearInteger.	time := Time h: hoursInteger m: minutesInteger.	^self fromDate: date andTime: time</body><body package="Values">d: dayInteger m: monthInteger y: yearInteger h: hoursInteger m: minutesInteger s: secondsInteger	| date time |	date := Date d: dayInteger m: monthInteger y: yearInteger.	time := Time h: hoursInteger m: minutesInteger s: secondsInteger.	^self fromDate: date andTime: time</body></methods><methods><class-id>Core.Timestamp</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 50).	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' d: ';		nextPutAll: self day printString;		nextPutAll: ' m: ';		nextPutAll: self month printString;		nextPutAll: ' y: ';		nextPutAll: self year printString.	(self hour isZero and: [	self minute isZero and: [	self second isZero]]) ifTrue: [			wst nextPut: $).			^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' h: ';		nextPutAll: self hour printString.	(self minute isZero and: [	self second isZero]) ifTrue: [			wst nextPut: $).			^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' m: ';		nextPutAll: self minute printString.	self second isZero ifTrue: [		wst nextPut: $).		^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' s: ';		nextPutAll: self second printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values">asDescription	"&lt;Text&gt;	produces a text equivalent to the soure with bold leaf values"	^self asDescriptionFor: self class</body><body package="Values">asDescriptionFor: targetClass	"&lt;Text&gt;	produces a text equivalent to the source"	| printer printvalue |	printer := ValuePrinter newFor: targetClass.	printvalue := self printvalueWith: printer.	^printvalue description</body><body package="Values">asSource	"&lt;String&gt;	produces a string which can be evaluated in the context of the receiver class to an object equivalent to the receiver"	^self asSourceFor: self class</body><body package="Values">asSourceFor: targetClass	"&lt;String&gt;	produces a string which can be evaluated in the context of targetClass to an object equivalent to the receiver"	| printer printvalue |	printer := ValuePrinter newFor: targetClass.	printvalue := self printvalueWith: printer.	^printvalue sourceWithPrinter: printer</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="Values">isEqualValue: anObject	^self = anObject</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values">printvalueWith: printer	^LiteralPrintvalue string: self storeString</body></methods><methods><class-id>Core.Duration class</class-id> <category>instance creation</category><body package="Values">nanoseconds: aNumber	^aNumber nanoseconds</body></methods><methods><class-id>Core.Duration</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' nanoseconds: ';		nextPutAll: self asNanoseconds printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="Values">h: hoursInteger	| inst |	inst := self new.	inst hours: hoursInteger minutes: 0 seconds: 0.	^inst</body><body package="Values">h: hoursInteger m: minutesInteger	| inst |	inst := self new.	inst hours: hoursInteger minutes: minutesInteger seconds: 0.	^inst</body><body package="Values">h: hoursInteger m: minutesInteger s: secondsInteger	| inst |	inst := self new.	inst hours: hoursInteger minutes: minutesInteger seconds: secondsInteger.	^inst</body><body package="Values">zero	^self h: 0</body></methods><methods><class-id>Core.Time</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	(self hours isZero and: [	self minutes isZero and: [	self seconds isZero]]) ifTrue: [			wst				nextPutAll: (printer classnameOf: self);				nextPutAll: ' zero'.			^LiteralPrintvalue string: wst contents].	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' h: ';		nextPutAll: self hours printString.	(self minutes isZero and: [	self seconds isZero]) ifTrue: [			wst nextPut: $).			^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' m: ';		nextPutAll: self minutes printString.	self seconds isZero ifTrue: [		wst nextPut: $).		^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' s: ';		nextPutAll: self seconds printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>testing</category><body package="Values">isEqualValue: aQualifiedName	^self class == aQualifiedName class and: [	path = aQualifiedName path]</body></methods><methods><class-id>Core.Object class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^self error: 'this is no literal object'</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values Development">asLiteralSource	"use #asSource"	self halt</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^'a string'</body></methods><methods><class-id>Core.Duration class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^42 nanoseconds</body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="Values Development">betterTestInstanceThan: aCollection	"&lt;Boolean&gt;	true, iff the receiver is better as a test instance than aValue"	^self size &gt;= aCollection size</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^#[42]</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>class probes</category><body package="Values Development">isValueClassSelected	^self isClassSelected and: [	(self selectedClass includesBehavior: Value) or: [	self selectedClass includesBehavior: Value class]]</body></methods><methods><class-id>Core.Character class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^$a</body></methods><methods><class-id>Core.Symbol class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^#symbol</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^Timestamp d: 19 m: 5 y: 2006 h: 11 m: 7 s: 55</body></methods><methods><class-id>Core.Behavior</class-id> <category>source generation</category><body package="Values Development">needs: source	"&lt;Boolean&gt;"	| selector parseTree classAndMethod |	parseTree := Refactory.Browser.RBParser parseMethod: source.	selector := parseTree selector.	(self canUnderstand: selector) ifFalse: [		^true].	classAndMethod := self findSelector: selector.	^(classAndMethod first parseTreeFor: selector) ~= parseTree</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>printing</category><body package="Values Development">literalExample	^nil</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^ColorValue red</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^Time h: 11 m: 8 s: 28</body></methods><methods><class-id>Core.ArithmeticValue class</class-id> <category>constants access</category><body package="Values Development">literalExample	^self unity toMinimumGenerality</body></methods><methods><class-id>Core.Boolean class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^true</body></methods><methods><class-id>Kernel.GeneralBindingReference class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^#{Object}</body></methods><methods><class-id>Graphics.Rectangle class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^1@2 extent: 20@10</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation</category><body package="Values Development">literalExample	^Date d: 19 m: 5 y: 2006</body></methods><methods><class-id>Value class</class-id> <category>pragmas</category><body package="Values">specificationPragmas	&lt;pragmas: #class&gt;	^#(	#constant:class: 		#constant:class:comment: 		#optional:class:default: 	#optional:class:default:comment:		#sequence: 				#sequence:comment: 		#map: 					#map:comment:	)</body></methods><methods><class-id>LiteralPrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #string class: #{String}&gt;</body></methods><methods><class-id>ValueTestingNamespace.Array class</class-id> <category>specification</category><body package="Values Testing">localSpecification	&lt;sequence: #value&gt;</body></methods><methods><class-id>BindingSpecification class</class-id> <category>specification</category><body package="Values Development">localSpecification	&lt;constant: #selector class: #{Symbol}&gt;	&lt;optional: #comment class: #{String} default: 'String new'&gt;</body></methods><methods><class-id>TypedConstantSpecification class</class-id> <category>specification</category><body package="Values Development">localSpecification	&lt;constant: #type class: #{LiteralBindingReference}&gt;</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>specification</category><body package="Values Development">localSpecification	&lt;optional: #default class: #{String} default: 'super default'&gt;</body></methods><methods><class-id>ValueTestingNamespace.Dictionary class</class-id> <category>specification</category><body package="Values Testing">localSpecification	&lt;map: #value&gt;</body></methods><methods><class-id>ValueTestingNamespace.OrderedDictionary class</class-id> <category>specification</category><body package="Values Testing">localSpecification	&lt;map: #value&gt;</body></methods><methods><class-id>Testvalue class</class-id> <category>specification</category><body package="Values Testing">localSpecification	&lt;constant: #constant class: #{Symbol}&gt;	&lt;optional: #optional class: #{Symbol} default: '#none'&gt;	&lt;sequence: #array&gt;	&lt;map: #dictionary&gt;</body></methods><methods><class-id>ValueSpecification class</class-id> <category>specification</category><body package="Values Development">localSpecification	&lt;sequence: #constants&gt;</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;sequence: #arguments&gt;	&lt;optional: #isOrdered class: #{Boolean} default: 'false'&gt;</body></methods><methods><class-id>ArrayPrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;sequence: #arguments&gt;</body></methods><methods><class-id>Printargument class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #name class: #{String}&gt;	&lt;constant: #value class: #{Printvalue}&gt;</body></methods><methods><class-id>DictionaryPrintargument class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #name class: #{Printvalue}&gt;	&lt;constant: #value class: #{Printvalue}&gt;</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #classname class: #{String}&gt;	&lt;sequence: #arguments&gt;</body></methods><methods><class-id>Tools.ListIconLibrary class</class-id> <category>resources</category><body package="Values Development">value16x16	"Tools.UIMaskEditor new openOnClass: self andSelector: #value16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2120 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 3180 3180)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 36 0 0 10 24 0 0 170 101 64 0 169 149 64 0 6 20 0 0 153 85 64 0 101 85 64 0 5 20 0 0 5 20 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Values Development">value16x16mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #value16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 96 0 0 3 96 0 0 15 248 0 0 15 248 0 0 3 96 0 0 15 248 0 0 15 248 0 0 3 96 0 0 3 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>class probes</category><body package="Values Development">generateMethodsForValue	&lt;menuItem: 'add Value methods...'			nameKey: #generateMethodsForValue			enablement: #isValueClassSelected			indication: nil			menu: #(#classMenu )			position: 15.1&gt;	| target |	target := self selectedClass isMeta		ifTrue: [self selectedClass soleInstance]		ifFalse: [self selectedClass].	target generateMethods</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Duration</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>period scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Core</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>DictionaryInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.PartListAbstractInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>linearizedParts valueOrKeyHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class></st-source>