<?xml version="1.0"?><st-source><!-- Name: MacOSXExtraComment: This parcel contains additional code for platform integration into the MacOS X operating system.1.	MenuBar item linking to VisualWorks actions.	For more information look at InputStates class method:		setMenuDispatchTable	for setting up your own menu item tag => method mappings.	And into MacOSXSystemSupports class method:		enableMenuBarItems	for setting up (enable/disable/reset) those menu bar items.	Look into the instance protocol 'private macosx dispatching' for example methods triggered by	menu bar item events.2.	Access documents dropped onto the VM icon, either on startup of the image, or during operation.	For more info look into MacOSSystemSupports class methods:		getInitialDocument			for info on how the first document is fetched on #returnFromSnapshot.		simpleDocumentHandling			to see how subsequent document events can be catched.	In a development image, every startup will print the name of an additional document dropped	onto the VM into the Transcript.After loading this parcel on MacOS X, the additional menu bar integration is initialized.The following menu item setup is installed:	'VisualWorks->About VisualWorks'	-	will open the standard AboutVisualWorksDialog,	'VisualWorks->Preferences...'		-	will open the settings tool,	'VisualWorks->Quit'				-	will open the standard save/exit dialog,	'Help->Topics'					-	will open the help browser, and load the help system if not present.Georg Heeg 2003Author: Roland Wagener, Ralf Propach===================Version History:0.1 - first cut,0.2 - added missing shared vars to MacOSXSystemSupport, added lazy access to MacOSXMenuDispatch in class InputState,0.3 - moved menu bar setup from InputState to MacOSXSystemSupport, now its done on #returnFromSnapshot time,0.4 - added overwrite of InputState>processUnboundEvent: to catch document events and signal the newDocumentSemaphore,0.5 - moved primActivateMenuItem:state: to this parcel,0.6 - changed returnFromSnapshot behaviour, so that only on MacOSX the menu item setup and the open document code is run, added parcel postLoad action to setup everything on parcel load,0.7 - hopefully fixed parcel load activities (delivered by Cincom for 7.1 to 7.6)0.8 - refined unknown event handling to only send document related updates to the newDocumentSemaphoreDbIdentifier: bear73DbTrace: 280390HideSource: falsePackageName: MacOSXExtraParcel: #('MacOSXExtra')ParcelName: MacOSXExtraPrintStringCache: (7.7.1 - 1,BaseSystem)SaveSource: trueVersion: 7.7.1 - 1Post-Load Block: 	[:package | 	MacOSXSystemSupport initialize.	MacOSXSystemSupport enableMenuBarItems]Date: 3:25:24 AM May 3, 2010 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7.1 (apr10.4) of May 3, 2010 on May 3, 2010 at 3:25:24 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><shared-variable><name>DocumentName</name><environment>OS.MacOSXSystemSupport</environment><private>false</private><constant>false</constant><category>document support</category><initializer>nil</initializer><attributes><package>MacOSXExtra</package></attributes></shared-variable><shared-variable><name>NewDocumentSemaphore</name><environment>OS.MacOSXSystemSupport</environment><private>false</private><constant>false</constant><category>document support</category><initializer>Semaphore new</initializer><attributes><package>MacOSXExtra</package></attributes></shared-variable><shared-variable><name>MacOSXMenuDispatch</name><environment>UI.InputState</environment><private>false</private><constant>false</constant><category>dispatch table</category><initializer>nil</initializer><attributes><package>MacOSXExtra</package></attributes></shared-variable><methods><class-id>UI.UIFeelPolicy class</class-id> <category>private</category><body package="MacOSXExtra" selector="getFeelPolicyForPlatform">getFeelPolicyForPlatform	"Here we look at the system name and find and appropriate feel policy for the class.	Ensure that MacOSX is first, so Dialogs have 'No Yes' button arrangements and not 'Yes No' as other platforms have."		| platform platformID |	platform := OSHandle currentOS.	(Screen default platformName = 'MacOSX' or: [platform == #mac])		ifTrue: [^#{MacFeelPolicy} valueOrDo: [DefaultFeelPolicy]].	platform == #unix		ifTrue:			[platformID := OSHandle currentPlatformID.			('* sun*' match: platformID)				ifTrue:					[^#{SunFeelPolicy}						valueOrDo: [#{MotifFeelPolicy} valueOrDo: [DefaultFeelPolicy]]].			('* hp*' match: platformID)				ifTrue:					[^#{HPFeelPolicy}						valueOrDo: [#{MotifFeelPolicy} valueOrDo: [DefaultFeelPolicy]]].			^#{MotifFeelPolicy} valueOrDo: [DefaultFeelPolicy]].	platform == #win32		ifTrue: [^#{Win95FeelPolicy} valueOrDo: [DefaultFeelPolicy]].	^DefaultFeelPolicy</body></methods><methods><class-id>UI.InputState class</class-id> <category>accessing</category><body package="MacOSXExtra" selector="macOSXMenuDispatch">macOSXMenuDispatch	"Lazy initialize the MacOSXMenuDispatch variable."	MacOSXMenuDispatch isNil ifTrue: [self setMenuDispatchTable].	^MacOSXMenuDispatch</body></methods><methods><class-id>UI.InputState class</class-id> <category>class initialization</category><body package="MacOSXExtra" selector="setDispatchTableForPlatform">setDispatchTableForPlatform	"Some old platforms have poor event or window behaviour.	 Add the check here at start-up rather than on every event	 because the dispatch table provides a convenient mechanism."	| platformName |	EventDispatchTable at: 4 put: #send:eventButtonPress:.	EventDispatchTable at: 6 put: #send:eventMouseMoved:.	platformName := Screen default platformName.	platformName = 'Mac' ifTrue: 		[EventDispatchTable at: 6 put: #send:eventMouseMovedMaybeWrongButtons:].	platformName =  'MacOSX' ifTrue: 		[self setMenuDispatchTable.		 [ObjectMemory registerObject: true withEngineFor: 'acceptQuitEvents'] 			on: Error 			do: [:ex | ex return]].	((OSHandle currentPlatformID tokensBasedOn: Character space) includes: 'nt') ifTrue:		[EventDispatchTable at: 4 put: #send:eventButtonPressWithoutDoubleClickSupport:].</body><body package="MacOSXExtra" selector="setMenuDispatchTable">setMenuDispatchTable	"Set up the global EventDispatchTable to process host menubar events, then initialize 	the MacOSX specific dispatch table for events originated from menu bar picks.	As a default, only special items of the default menu bar, as shipped by Cincom, are	registered and enabled."	EventDispatchTable at: 16 put: #send:eventMenu:.	MacOSXMenuDispatch := Dictionary new.	MacOSXMenuDispatch at: 1 put: #aboutVisualWorks:eventMenu:.	MacOSXMenuDispatch at: 2 put: #visualWorksSettings:eventMenu:.	MacOSXMenuDispatch at: 3 put: #quitVisualWorks:eventMenu:.	MacOSXMenuDispatch at: 11 put: #undo:eventMenu:.	MacOSXMenuDispatch at: 12 put: #redo:eventMenu:.	MacOSXMenuDispatch at: 16 put: #clear:eventMenu:.	MacOSXMenuDispatch at: 17 put: #selectAll:eventMenu:.	MacOSXMenuDispatch at: 32 put: #helpTopics:eventMenu:.</body></methods><methods><class-id>UI.InputState</class-id> <category>private macosx dispatching</category><body package="MacOSXExtra" selector="aboutVisualWorks:eventMenu:">aboutVisualWorks: window eventMenu: event	"Open the VisualWorks 'About' window as done by the VisualLauncher."	[AboutVisualWorksDialog open] forkAt: 50</body><body package="MacOSXExtra" selector="clear:eventMenu:">clear: window eventMenu: event</body><body package="MacOSXExtra" selector="helpTopics:eventMenu:">helpTopics: window eventMenu: event	"Open the VisualWorks 'Topics' help window as done by the VisualLaunchers Help-&gt;Topics menu."	[#{VWHelp.HelpBrowser} ifDefinedDo: [:v | ]				elseDo: [Parcel ensureLoadedParcel: 'VWHelp' withVersion: ''].			#{VWHelp.HelpBrowser} ifDefinedDo: [:v | v open]] forkAt: 50</body></methods><methods><class-id>UI.InputState</class-id> <category>private</category><body package="MacOSXExtra" selector="processUnboundEvent:">processUnboundEvent: event	"There is no window corresponding to this event.  This may mean that	the event is not bound to any window, or that the window is not owned	by Smalltalk, or that the window was owned by Smalltalk, but Smalltalk	has already destroyed this window."	"If running on MacOS X, signal the NewDocumentSemaphore, because this	type of event is send in case an open document event has arrived."	Screen default platformName = 'MacOSX'		ifTrue: 			[(event at: 8) = $D asInteger				ifTrue: [MacOSXSystemSupport newDocumentSemaphore signal]].	eventDispatcher == nil ifFalse: [eventDispatcher dispatchEvent: event]</body></methods><methods><class-id>UI.InputState</class-id> <category>private macosx dispatching</category><body package="MacOSXExtra" selector="quitVisualWorks:eventMenu:">quitVisualWorks: window eventMenu: event	"Quit VisualWorks using the standard 'Quit' dialog."	[ObjectMemory quitDialog] forkAt: 50</body><body package="MacOSXExtra" selector="redo:eventMenu:">redo: window eventMenu: event</body><body package="MacOSXExtra" selector="selectAll:eventMenu:">selectAll: window eventMenu: event	self send: window eventKeyPress: event</body></methods><methods><class-id>UI.InputState</class-id> <category>private dispatching</category><body package="MacOSXExtra" selector="send:eventMenu:">send: window eventMenu: event	"This is the hook for host menubar events on MacOS X."	| focusWindow menuItemSelector |	focusWindow := self focusWindowOr: window.	focusWindow ifNil: [^self].	event at: 2 put: focusWindow key.	menuItemSelector := self class macOSXMenuDispatch at: (event at: 8) ifAbsent: [nil].	menuItemSelector isNil 		ifTrue: [" focusWindow sensor eventMenu: event "]		ifFalse: [ self perform: menuItemSelector with: focusWindow with: event ].</body></methods><methods><class-id>UI.InputState</class-id> <category>private macosx dispatching</category><body package="MacOSXExtra" selector="undo:eventMenu:">undo: window eventMenu: event</body><body package="MacOSXExtra" selector="visualWorksSettings:eventMenu:">visualWorksSettings: window eventMenu: event	"Open the VisualWorks SettingsTool."	[Tools.VisualWorksSettings openManager] forkAt: 50</body></methods><methods><class-id>OS.MacOSXSystemSupport class</class-id> <category>change update</category><body package="MacOSXExtra" selector="enableMenuBarItems">enableMenuBarItems	"On #returnFromSnapshot setup the MacOS X menu bar items."	Screen default platformName = 'MacOSX'  ifFalse: [^self].	self primActivateMenuItem: 1 state: true.		"VisualWorks-&gt;About VisualWorks..."	self primActivateMenuItem: 2 state: true.		"VisualWorks-&gt;Preferences"	self primActivateMenuItem: 3 state: true.		"VisualWorks-&gt;Quit""	self primActivateMenuItem: 11 state: true."	"Edit-&gt;Undo""	self primActivateMenuItem: 12 state: true."	"Edit-&gt;Again""	self primActivateMenuItem: 16 state: true."	"Edit-&gt;Clear"	self primActivateMenuItem: 17 state: true.	"Edit-&gt;Select All"	self primActivateMenuItem: 32 state: true.	"Help-&gt;Topics"</body></methods><methods><class-id>OS.MacOSXSystemSupport class</class-id> <category>class accessing</category><body package="MacOSXExtra" selector="getDocumentNames">getDocumentNames	"Get all document names from the VM that were dropped on the executable.	This clears the names from the VM storage for such names."	| names temp |	names := OrderedCollection new.	DocumentName notNil 		ifTrue: 			[names add: DocumentName asString.			DocumentName := nil].	[(temp := self primGetDocumentName) notNil] 		whileTrue: [names add: temp asString].	^names</body></methods><methods><class-id>OS.MacOSXSystemSupport class</class-id> <category>change update</category><body package="MacOSXExtra" selector="getInitialDocument">getInitialDocument	"This is a demo of how to get document names dropped onto the VM on startup."	Screen default platformName = 'MacOSX' ifFalse: [^self].	Transcript		show: 'Docname fetch ..';		cr.	DocumentName := self primGetDocumentName.	DocumentName notNil		ifTrue: 			[DocumentName := DocumentName asString.			self newDocumentSemaphore signal]</body></methods><methods><class-id>OS.MacOSXSystemSupport class</class-id> <category>class initialization</category><body package="MacOSXExtra" selector="initialize">initialize	super initialize.	Screen default platformName = 'MacOSX'  ifFalse: [^self].	InputState setMenuDispatchTable.</body></methods><methods><class-id>OS.MacOSXSystemSupport class</class-id> <category>class accessing</category><body package="MacOSXExtra" selector="newDocumentSemaphore">newDocumentSemaphore	"This semaphore is signalled each time a document event is received on MacOS X."	NewDocumentSemaphore isNil ifTrue: [NewDocumentSemaphore := Semaphore new].	^NewDocumentSemaphore</body></methods><methods><class-id>OS.MacOSXSystemSupport class</class-id> <category>primitives</category><body package="MacOSXExtra" selector="primActivateMenuItem:state:">primActivateMenuItem: tagNumber state: aBooleanOrNil	"MacOS X only primitve!	Set the state of the menubar item with tagNumber to aBooleanOrNil, that is on, off, or default.	As soon as the menu item is enabled, menu events are generated by this item.	Setting the menu item state to nil will restore the original state of the menu.	Returns a boolean, telling you its activation state before the call."	&lt;primitive: 778&gt;	^self primitiveFailed</body><body package="MacOSXExtra" selector="primGetDocumentName">primGetDocumentName	"Get and clear one document name from the VM. If there is none, return nil."	&lt;primitive: 761&gt;</body></methods><methods><class-id>OS.MacOSXSystemSupport class</class-id> <category>examples</category><body package="MacOSXExtra" selector="simpleDocumentHandling">simpleDocumentHandling	"To catch open document events in VisualWorks, MacOSXSystemSupport provides	some class side facilities:		getDocumentNames		-	retrieves names of files of open document events, after									fetching them, they have to be processed by the caller,									because the fetch clears the storage for names in the VM, 		newDocumentSemaphore -	this semaphore is signaled as soon as an open 									document event arrives,	To be able to receive these events on start up of the image, class MacOSXSystemSupport	has to be registered as a dependent of ObjectMemory.	The code of this method serves as an example of a process waiting for open document	events. Each time the newDocumentSemaphore is signaled, it will fetch all document names	and open a FileBrowser on each. 	This example only works, if Textfiles are accepted by the VM. A standard VM does not accept	txt-files, so you have to edit the file		visual.app/Contents/Info.plist	and add another entry into CFBundleDocumentTypes. Look at the Info.plist file of application TextEdit	for examples.	Executing the following code will start the example process:		MacOSXSystemSupport simpleDocumentHandling"	[[MacOSXSystemSupport newDocumentSemaphore wait.	MacOSXSystemSupport getDocumentNames 		do: [ :each | Tools.FileBrowser openOnFileNamed: each]] repeat] fork</body></methods><methods><class-id>OS.MacOSXSystemSupport class</class-id> <category>change update</category><body package="MacOSXExtra" selector="update:with:from:">update: anAspect with: aParam from: anObject 	"On returnFromSnapshot, look for a document dropped on to the application,	and signal the semaphore, if any."	"ObjectMemory removeDependent: self.	ObjectMemory addDependent: self"	super 		update: anAspect		with: aParam		from: anObject.	anAspect == #returnFromSnapshot 		ifTrue: 			[self enableMenuBarItems.			self getInitialDocument]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>InputState</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y bitState shiftState ctrlState commandKeyState metaState metaKeyState altKeyState lastClick eventDispatcher lastDownPoint lastUpPoint lastUpButton lastWindow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class></st-source>