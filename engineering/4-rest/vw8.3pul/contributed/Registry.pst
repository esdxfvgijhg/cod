<?xml version="1.0"?><st-source><!-- Name: RegistryNotice: Copyright 2002 - 2013 Travis GriggsThis utility is free to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This is an interface for the Windows Registry. It even simulates on non windows platforms where it stores data in a directory hierarchy in the user's home directory.DbIdentifier: bear73DbTrace: 407810DbUsername: nrossDbVersion: 30DevelopmentPrerequisites: #(#(#any 'DLLCC' ''))DisregardedPrerequisites: #(#(#name 'Base VisualWorks' #componentType #bundle))PackageName: RegistryParcel: #('Registry')ParcelName: RegistryPrintStringCache: (30,nross)Version: 30Post-Load Block: 	[:package | ''In VisualWorks versions up to and including 7.10, this utility needs to recompile all methods of its ExternalInterface subclass after package load in case they were loaded and compiled in an invalid order.''WindowsRegistry.WindowsRegistryAPI recompileMethods]Date: 7:39:53 AM May 31, 2013 --><time-stamp>From VisualWorksÂ®, 7.10 of May 31, 2013 on May 31, 2013 at 7:39:53 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>WindowsRegistry</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>Registry</package></attributes></name-space><class><name>Value</name><environment>WindowsRegistry</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data name key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Registry</category><attributes><package>Registry</package></attributes></class><comment><class-id>WindowsRegistry.Value</class-id><body>Value represents a value stored under a registry Key. A registry Key works roughly like Smalltalk Dictionary. It contains Values which are composed of a name and Data, i.e. Values are similar to Smalltalk Associations. Value is an abstract class. It has concrete subclasses for the Windows registry (WindowsRegistryValue) and for file based registries (FileSystemValue).Subclasses must implement the following messages:	private		read		write	utility		existsInstance Variables	data	&lt;Data&gt;	Data stored in the Value	key	&lt;Registry.Key&gt;	the Key where the Value is stored	name	&lt;String&gt;	the name of the Value</body></comment><class><name>WindowsRegistryValue</name><environment>WindowsRegistry</environment><super>WindowsRegistry.Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Registry</category><attributes><package>Registry</package></attributes></class><comment><class-id>WindowsRegistry.WindowsRegistryValue</class-id><body>A WindowsRegistryValue represents a value (name/data pair) in the Windows registry.</body></comment><class><name>Key</name><environment>WindowsRegistry</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyPath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Registry</category><attributes><package>Registry</package></attributes></class><comment><class-id>WindowsRegistry.Key</class-id><body>Key represents a registry Key. A registry Key works roughly like Smalltalk Dictionary. It contains Values which are composed of a name and Data, i.e. Values are similar to Smalltalk Associations. Key is an abstract class. It has concrete subclasses for the Windows registry (WindowsRegistryKey) and for file based registries (FileSystemKey). Keys form a hierarchy similar to a directory hierarchy in a file system. The file based registry implementation actually maps Keys onto a directory hierarchy. By default, Key uses WindowsRegistryKey on platforms with the platform id #win32 and FileSystemKey otherwise. You can override this choice by setting the concrete class explicitly, which is stored in the shared variable Key.ConcreteClass. When a #returnFromSnapshot event occurs, the platform id is checked. If the concrete class is not supported on the current platform, ConcreteClass is reset to nil, and the first access to it will revert it to the platform's default Key class.Subclasses must implement the following messages:	printing		printPathOn:	private		deleteSubKeyNamed:		deleteValueNamed:	private-initialize		setPath:	utility		close		create		exists		open		subKeyNames		valueNamesInstance Variables	keyPath	&lt;CharacterArray&gt;	path name of the registry key</body></comment><class><name>FileSystemKey</name><environment>WindowsRegistry</environment><super>WindowsRegistry.Key</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Registry</category><attributes><package>Registry</package></attributes></class><comment><class-id>WindowsRegistry.FileSystemKey</class-id><body>A FileSystemKey is a registry Key which is stored in a file system based registry.</body></comment><class><name>FileSystemValue</name><environment>WindowsRegistry</environment><super>WindowsRegistry.Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Registry</category><attributes><package>Registry</package></attributes></class><comment><class-id>WindowsRegistry.FileSystemValue</class-id><body>A FileSystemValue represents a value (name/data pair) in file system based registry.</body></comment><class><name>Data</name><environment>WindowsRegistry</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bytes type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Registry</category><attributes><package>Registry</package></attributes></class><comment><class-id>WindowsRegistry.Data</class-id><body>Data represents the data which are stored in a registry Value. Instance Variables:	bytes	&lt;ByteArray&gt;	the bytes which are stored in the registry	type	&lt;Integer&gt;	encoding for the kind of object which is stored in bytes</body></comment><class><name>RegistryError</name><environment>WindowsRegistry</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Registry</category><attributes><package>Registry</package></attributes></class><comment><class-id>WindowsRegistry.RegistryError</class-id><body>A RegistryError is raised when an error occurs while accessing a registry.</body></comment><class><name>WindowsRegistryKey</name><environment>WindowsRegistry</environment><super>WindowsRegistry.Key</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osKey rootKeyValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Registry</category><attributes><package>Registry</package></attributes></class><comment><class-id>WindowsRegistry.WindowsRegistryKey</class-id><body>A WindowsRegistryKey is a registry Key which is stored in the Windows registry.Instance Variables	osKey	&lt;CPointer&gt;	pointer to the Windows data structure representing the registry key	rootKeyValue	&lt;Integer&gt;</body></comment><class><name>WindowsRegistryAPI</name><environment>WindowsRegistry</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports>			private WindowsRegistry.WindowsRegistryAPIDictionary.*			</imports><category>Registry</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>advapi32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Registry</package></attributes></class><comment><class-id>WindowsRegistry.WindowsRegistryAPI</class-id><body>WindowsRegistryAPI wraps the Windows API functions from the library advapi32.dll which are needed to access the Windows registry.</body></comment><shared-variable><name>ToObjectMap</name><environment>WindowsRegistry.Data</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Registry</package></attributes></shared-variable><shared-variable><name>ToTypeMap</name><environment>WindowsRegistry.Data</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Registry</package></attributes></shared-variable><shared-variable><name>ToBytesMap</name><environment>WindowsRegistry.Data</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Registry</package></attributes></shared-variable><shared-variable><name>RootKeyValues</name><environment>WindowsRegistry.WindowsRegistryKey</environment><private>false</private><constant>false</constant><category>category</category><initializer>(Dictionary new)		add: ('HKEY_CLASSES_ROOT' -&gt; 16r80000000);		add: ('HKEY_CURRENT_USER'  -&gt;  16r80000001);		add: ('HKEY_LOCAL_MACHINE'  -&gt; 16r80000002);		add: ('HKEY_USERS'  -&gt;  16r80000003);		add: ('HKEY_CURRENT_CONFIG'  -&gt;  16r80000005);		yourself</initializer><attributes><package>Registry</package></attributes></shared-variable><shared-variable><name>ConcreteClass</name><environment>WindowsRegistry.Key</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Registry</package></attributes></shared-variable><shared-variable><name>WriteValueErrorSignal</name><environment>WindowsRegistry.Value</environment><private>false</private><constant>false</constant><category>exceptions</category><attributes><package>Registry</package></attributes></shared-variable><shared-variable><name>ReadValueErrorSignal</name><environment>WindowsRegistry.Value</environment><private>false</private><constant>false</constant><category>exceptions</category><attributes><package>Registry</package></attributes></shared-variable><shared-variable><name>WindowsRegistryAPIDictionary</name><environment>WindowsRegistry</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Registry</package></attributes></shared-variable><methods><class-id>WindowsRegistry.Value</class-id> <category>accessing</category><body package="Registry">dataBytes	^data bytes</body><body package="Registry">key	^key</body><body package="Registry">value		[key open.	self read] ensure: [key close].	^data object</body><body package="Registry">value: anObject 		[key create.	data setObject: anObject.	self write]		ensure: [key close].	^anObject</body></methods><methods><class-id>WindowsRegistry.Value</class-id> <category>private-initialize</category><body package="Registry">initialize	data := Data new</body><body package="Registry">parsePath: aString 	| index |	index := aString lastIndexOf: Key separator				ifAbsent: [self error: 'Cannot parse registry path'].	self setName: (aString copyFrom: index + 1 to: aString size)		key: (Key path: (aString copyFrom: 1 to: index - 1))</body><body package="Registry">setName: aString key: aKey 	name := aString.	key := aKey</body></methods><methods><class-id>WindowsRegistry.Value</class-id> <category>utility</category><body package="Registry">delete	key deleteValueNamed: name</body><body package="Registry">exists	^self subclassResponsibility</body></methods><methods><class-id>WindowsRegistry.Value</class-id> <category>private</category><body package="Registry">read	self subclassResponsibility</body><body package="Registry">write	^self subclassResponsibility</body></methods><methods><class-id>WindowsRegistry.Value class</class-id> <category>examples</category><body package="Registry">readExample	"this shows how one gets at a registry value, you of course have to registry read access to this key"	"self readExample"	^(self path: 'HKey_Local_Machine\System\CurrentControlSet\Control\ComputerName\ActiveComputerName\ComputerName') value</body><body package="Registry">testItAll	"test the various API points of the registry framework"	"self testItAll"	| val1 key1 |	val1 := self path: 'HKey_Current_User\STTestLevel1\STTestLevel2\STTestLevel3\Brag'.	key1 := val1 key.	"test value setting"	val1 value: 2.	val1 exists ifFalse: ["test existance testing"		self error: 'Existance test failed'].		"test value resetting (with type change) and accessing"	val1 value: 'Smalltalk is SOOO Cool'.	val1 value = 'Smalltalk is SOOO Cool' ifFalse: [self error: 'Something is wrong with accessing'].	key1 values first value = 'Smalltalk is SOOO Cool' ifFalse: ["test value enumerating"		self error: 'Problem enumerating values'].		"test value deletion and existance testing again"	val1 delete.	val1 exists ifTrue: [self error: 'Did not delete properly'].	key1 exists ifFalse: ["test key existance testing"		self error: 'Error in testing key existance'].		"test sub key creation, stub out a sibling to key1"	((key1 parentKey subKeyNamed: 'Sibling')		valueNamed: 'Stub')		value: 0.		"test recursive deletion (which also test sub key enumeration)"	(key1 := Key path: 'HKEY_CURRENT_USER\STTestLevel1') delete.	key1 exists ifTrue: ["do a final existance test"		self error: 'Keys not cleanup right']</body><body package="Registry">writeExample	"this shows how one changes a registry value, you of course have to registry read access to the 	CurrentUsers key"	"self writeExample"	^(self path: 'HKey_Current_User\STRegExample\Brag')		value: 'Smalltalk is SOOO Cool'</body></methods><methods><class-id>WindowsRegistry.Value class</class-id> <category>instance creation</category><body package="Registry">new	^super new initialize</body><body package="Registry">path: aPath		^Key concreteClass valueClass new parsePath: aPath</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryValue</class-id> <category>private-accessing</category><body package="Registry">successCode	"return the code to use when evaluation whether API calls completed successfully"	^WindowsRegistryAPI current ERROR_SUCCESS</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryValue</class-id> <category>utility</category><body package="Registry">exists	^	[self value.	true] on: RegistryError do: [:ex | ex return: false]</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryValue</class-id> <category>private</category><body package="Registry">read	| typeHolder byteSizeHolder hkey bytes bsz dataBytesHolder returnCode api encodedName |	typeHolder := CIntegerType unsignedLong gcMalloc.	byteSizeHolder := 100 gcCopyToHeap.	dataBytesHolder := CIntegerType unsignedChar gcMalloc: 100.	hkey := key keyValue.	api := WindowsRegistryAPI current.	encodedName := name nullTerminatedByteArray.	returnCode := (api := WindowsRegistryAPI current)				regQueryValueNamed: encodedName				in: hkey				type: typeHolder				value: dataBytesHolder				size: byteSizeHolder.	returnCode = api ERROR_MORE_DATA		ifTrue: 			[dataBytesHolder := CIntegerType unsignedChar gcMalloc: byteSizeHolder contents.			returnCode := api						regQueryValueNamed: encodedName						in: hkey						type: nil						value: dataBytesHolder						size: byteSizeHolder].	returnCode = self successCode ifFalse: [RegistryError raiseSignal: 'Unable to read value'].	data type: typeHolder contents.	bytes := ByteArray new: (bsz := byteSizeHolder contents).	dataBytesHolder		copyAt: 0		to: bytes		size: bsz		startingAt: 1.	data bytes: bytes</body><body package="Registry">write	| dataBytesHolder |	dataBytesHolder := CIntegerType unsignedChar gcMalloc: data bytesSize.	dataBytesHolder		copyAt: 0		from: data bytes		size: data bytesSize		startingAt: 1.	(WindowsRegistryAPI current		regSetValueNamed: name nullTerminatedByteArray		in: key keyValue		type: data type		value: dataBytesHolder		size: data bytesSize)		= self successCode ifFalse: [RegistryError raiseSignal: 'Unable to write value']</body></methods><methods><class-id>WindowsRegistry.Key</class-id> <category>accessing</category><body package="Registry">at: aString 	^(self valueNamed: aString) value</body><body package="Registry">at: aString put: anObject 	^(self valueNamed: aString) value: anObject</body><body package="Registry">keyPathTail	| index path |	path := self path.	index := path lastIndexOf: self separator.	^path copyFrom: index + 1 to: path size</body><body package="Registry">nameAndDataDo: aTwoArgBlock 	self valueNames 		do: [:name | aTwoArgBlock value: name value: (self at: name)]</body><body package="Registry">parentKey	^self class path: self parentKeyPath</body><body package="Registry">parentKeyPath	| path index |	path := self path.	index := path lastIndexOf: self separator.	^index = 0 ifTrue: [''] ifFalse: [path copyFrom: 1 to: index - 1]</body><body package="Registry">removeValueAt: aString 	^self deleteValueNamed: aString</body><body package="Registry">removeValueAt: aString ifAbsent: aBlock 	^(self valueNamed: aString) exists 		ifTrue: [self deleteValueNamed: aString]		ifFalse: [aBlock value]</body><body package="Registry">subKeyNamed: aString 	| ws |	ws := String new writeStream.	self printPathOn: ws.	ws nextPut: self separator.	ws nextPutAll: aString.	^self class path: ws contents</body><body package="Registry">subKeyNamed: aString ifAbsent: aBlock 	| subKey |	subKey := self subKeyNamed: aString.	^subKey exists ifTrue: [subKey] ifFalse: [aBlock value]</body><body package="Registry">subKeyNamed: aString ifPresent: aOneArgumentBlock 	| subKey |	subKey := self subKeyNamed: aString.	^subKey exists ifTrue: [aOneArgumentBlock value: subKey] ifFalse: [nil]</body><body package="Registry">subTreeNamed: aCollection 	| ws |	ws := String new writeStream.	self printPathOn: ws.	aCollection		do: 			[:each | 			ws nextPut: self separator.			ws nextPutAll: each].	^self class path: ws contents</body><body package="Registry">valueClass		^self class valueClass</body><body package="Registry">valueNamed: aString		^self valueClass new setName: aString key: self</body></methods><methods><class-id>WindowsRegistry.Key</class-id> <category>private-initialize</category><body package="Registry">setPath: aString 	^self subclassResponsibility</body></methods><methods><class-id>WindowsRegistry.Key</class-id> <category>utility</category><body package="Registry">close	^self subclassResponsibility</body><body package="Registry">create	^self subclassResponsibility</body><body package="Registry">delete	self exists ifFalse: [^self].	self subKeys do: [:each | each delete].	self parentKey deleteSubKeyNamed: self keyPathTail</body><body package="Registry">exists	^self subclassResponsibility</body><body package="Registry">flushAndClose	"Flush any changes to the registry and close the key."</body><body package="Registry">open	^self subclassResponsibility</body><body package="Registry">renameKey: aString 	| target block |	target := self parentKey subKeyNamed: aString.	block := 			[:src :dest | 			src valueNames do: [:name | dest at: name put: (src at: name)].			src subKeys 				do: [:each | block value: each value: (dest subKeyNamed: each keyPathTail)]].	block value: self value: target.	self delete</body><body package="Registry">subKeyNames	^self subclassResponsibility</body><body package="Registry">subKeys	"just create actual sub key objects from the list of sub key names"	^self subKeyNames collect: [:each | self subKeyNamed: each]</body><body package="Registry">valueNames	^self subclassResponsibility</body><body package="Registry">values	^self valueNames collect: [:each | self valueNamed: each]</body></methods><methods><class-id>WindowsRegistry.Key</class-id> <category>printing</category><body package="Registry">path	| ws |	ws := String new writeStream.	self printPathOn: ws.	^ws contents</body><body package="Registry">printOn: aStream 	aStream nextPutAll: 'Registry Key: '.	self printPathOn: aStream</body><body package="Registry">printPathOn: aStream 	^self subclassResponsibility</body></methods><methods><class-id>WindowsRegistry.Key</class-id> <category>dictionary-accessing</category><body package="Registry">at: aString ifAbsent: aBlock 	^(self exists and: [self includesValueAt: aString]) 		ifTrue: [self at: aString]		ifFalse: [aBlock value]</body><body package="Registry">at: aString ifAbsentPut: aBlock 	^self at: aString ifAbsent: [self at: aString put: aBlock value]</body><body package="Registry">at: aValueName ifPresent: aBlock 	| data |	data := self at: aValueName ifAbsent: [^self].	^aBlock value: data</body></methods><methods><class-id>WindowsRegistry.Key</class-id> <category>private-accessing</category><body package="Registry">separator	^self class separator</body></methods><methods><class-id>WindowsRegistry.Key</class-id> <category>testing</category><body package="Registry">includesValueAt: aString 	^(self valueNamed: aString) exists</body></methods><methods><class-id>WindowsRegistry.Key</class-id> <category>private</category><body package="Registry">deleteSubKeyNamed: aSubKeyTail 	^self subclassResponsibility</body><body package="Registry">deleteValueNamed: aValueName 	^self subclassResponsibility</body></methods><methods><class-id>WindowsRegistry.Key</class-id> <category>deprecated</category><body package="Registry">closeNow	"Flush any changes to the registry and close the key."	"closeNow does not appropriately describe what the method does. It has been replaced by flushAndClose."	self flushAndClose</body></methods><methods><class-id>WindowsRegistry.Key</class-id> <category>converting</category><body package="Registry">asRegistryKey	^self</body></methods><methods><class-id>WindowsRegistry.Key class</class-id> <category>updating</category><body package="Registry">checkPlatform		ConcreteClass ifNotNil:			[[ConcreteClass checkCurrentOS] on: Error				do: [:error | ConcreteClass := nil]]</body><body package="Registry">update: anAspectSymbol with: aParameter from: aSender	"When returning from a snapshot, check that the ConcreteClass is supported on the current platform. If it is not, uninitialize it."		(aSender == ObjectMemory and: [anAspectSymbol == #returnFromSnapshot]) ifTrue: [self checkPlatform]</body></methods><methods><class-id>WindowsRegistry.Key class</class-id> <category>Windows root paths</category><body package="Registry">HKCC	^self hKeyCurrentConfig</body><body package="Registry">HKCR	^self hKeyClassesRoot</body><body package="Registry">HKCU	^self hKeyCurrentUser</body><body package="Registry">HKLM	^self hKeyLocalMachine</body><body package="Registry">HKU	^self hKeyUsers</body><body package="Registry">hKeyClassesRoot	^self path: 'HKEY_CLASSES_ROOT'</body><body package="Registry">hKeyCurrentConfig	^self path: 'HKEY_CURRENT_CONFIG'</body><body package="Registry">hKeyCurrentUser	^self path: 'HKEY_CURRENT_USER'</body><body package="Registry">hKeyLocalMachine	^self path: 'HKEY_LOCAL_MACHINE'</body><body package="Registry">hKeyUsers	^self path: 'HKEY_USERS'</body></methods><methods><class-id>WindowsRegistry.Key class</class-id> <category>class initialization</category><body package="Registry">initialize		self == Key ifFalse: [^self].	#{SystemEventInterest} ifDefinedDo:			[:interestClass | 			interestClass				removeAllDependenciesFor: self;				atSystemEvent: #returnFromSnapshot send: #checkPlatform to: self]		elseDo:			["for older VisualWorks versions"			ObjectMemory				removeDependent: self;				addDependent: self]</body><body package="Registry">obsolete		#{SystemEventInterest} ifDefinedDo: [:interestClass | interestClass removeAllDependenciesFor: self].	ObjectMemory removeDependent: self	"for VisualWorks versions older than 7.6".	super obsolete</body></methods><methods><class-id>WindowsRegistry.Key class</class-id> <category>instance creation</category><body package="Registry">path: aString 	^self concreteClass new setPath: aString</body></methods><methods><class-id>WindowsRegistry.Key class</class-id> <category>private-accessing</category><body package="Registry">separator	"character separator used to delineate the tree levels in a path"	^$\</body></methods><methods><class-id>WindowsRegistry.Key class</class-id> <category>testing</category><body package="Registry">checkCurrentOS	"Checks if the receiver class is supported on the current platform. Subclasses which are platform specific should raise an error if they are not supported on the current platform."	^self</body></methods><methods><class-id>WindowsRegistry.Key class</class-id> <category>accessing</category><body package="Registry">concreteClass	^ConcreteClass		ifNil: 			[ConcreteClass := OSHandle currentOS == #win32						ifTrue: [WindowsRegistryKey]						ifFalse: [FileSystemKey]]</body><body package="Registry">concreteClass: aClass 	aClass ifNotNil: [aClass checkCurrentOS].	ConcreteClass := aClass</body></methods><methods><class-id>WindowsRegistry.FileSystemKey</class-id> <category>utility</category><body package="Registry">close</body><body package="Registry">create	self makePathAndDirectory: self filename</body><body package="Registry">exists	^self filename exists</body><body package="Registry">open</body><body package="Registry">subKeyNames	| fn |	^(fn := self filename) directoryContents 		select: [:each | (fn construct: each) isDirectory]</body><body package="Registry">valueNames	| fn |	^((fn := self filename) directoryContents 		select: [:each | (fn construct: each) isDirectory not]) 			collect: [:each | each copyFrom: 2 to: each size]</body></methods><methods><class-id>WindowsRegistry.FileSystemKey</class-id> <category>private</category><body package="Registry">deleteFilename: aFilename 	aFilename exists ifFalse: [^self].	aFilename isDirectory 		ifTrue: 			[aFilename directoryContents 				do: [:each | self deleteFilename: (aFilename construct: each)]].	aFilename delete</body><body package="Registry">deleteSubKeyNamed: aSubKeyTail 	self deleteFilename: (self filename construct: aSubKeyTail asLowercase)</body><body package="Registry">deleteValueNamed: aValueName 	self 		deleteFilename: (self filename construct: '_' , aValueName asLowercase)</body><body package="Registry">fileRoot	| homeVariableName |	homeVariableName := OSHandle currentOS == #win32 				ifTrue: ['$(USERPROFILE)']				ifFalse: ['$(HOME)'].	^homeVariableName asLogicalFileSpecification asFilename 		construct: '.registry'</body><body package="Registry">filename	^self fileRoot construct: keyPath asLowercase</body><body package="Registry">makePathAndDirectory: aFilename 	| dir |	(dir := aFilename directory) exists 		ifFalse: [self makePathAndDirectory: dir].	aFilename exists ifFalse: [aFilename makeDirectory]</body></methods><methods><class-id>WindowsRegistry.FileSystemKey</class-id> <category>private-initialize</category><body package="Registry">setPath: aString 	aString isEmpty ifTrue: [self error: 'The path of a registry key must not be empty!'].	keyPath := aString 				collect: [:char | char = self separator ifTrue: [Filename separator] ifFalse: [char]]</body></methods><methods><class-id>WindowsRegistry.FileSystemKey</class-id> <category>printing</category><body package="Registry">printPathOn: aStream 	aStream nextPutAll: (keyPath 				collect: [:char | char = Filename separator ifTrue: [self separator] ifFalse: [char]])</body></methods><methods><class-id>WindowsRegistry.FileSystemKey class</class-id> <category>accessing</category><body package="Registry">valueClass	^FileSystemValue</body></methods><methods><class-id>WindowsRegistry.FileSystemValue</class-id> <category>private</category><body package="Registry">filename	^key filename construct: '_' , name asLowercase</body><body package="Registry">read	| bytes rs |	rs := self filename readStream.	rs binary.	bytes := [rs upToEnd] ensure: [rs close].	data type: bytes first.	data bytes: (bytes copyFrom: 2 to: bytes size)</body><body package="Registry">write	| ws |	ws := self filename writeStream.	ws binary.		[ws		nextPut: data type;		nextPutAll: data bytes] ensure: [ws close]</body></methods><methods><class-id>WindowsRegistry.FileSystemValue</class-id> <category>utility</category><body package="Registry">exists	^self filename exists</body></methods><methods><class-id>WindowsRegistry.Data</class-id> <category>private-accessing</category><body package="Registry">registryBytesFor: anObject 	^self class registryBytesFor: anObject</body><body package="Registry">toObjectBlock	^self class conversionForType: type</body><body package="Registry">typeFor: anObject 	^self class typeFor: anObject</body></methods><methods><class-id>WindowsRegistry.Data</class-id> <category>accessing</category><body package="Registry">bytes	^bytes</body><body package="Registry">bytes: aValue 	bytes := aValue</body><body package="Registry">bytesSize	^bytes size</body><body package="Registry">object	^self toObjectBlock value: bytes</body><body package="Registry">setObject: anObject 	type := self typeFor: anObject.	bytes := self registryBytesFor: anObject</body><body package="Registry">type	^type</body><body package="Registry">type: aValue 	type := aValue</body></methods><methods><class-id>WindowsRegistry.Data class</class-id> <category>private-accessing</category><body package="Registry">conversionForType: anInteger 	"try to get a block to convert byte arrays to objects based on type, if the type is not found in our 	mapping though, return a block that just defaults the byte array as the representation"	^ToObjectMap at: anInteger ifAbsent: [[:ba | ba]]</body><body package="Registry">multipleStringsAsBytes: aCollectionOfStrings 	"provide a service for turning a collection of strings into a byte array as expected by the MULTI_SZ 	registry type"	| ws |	ws := ByteArray new writeStream.	aCollectionOfStrings do: [:each | ws nextPutAll: each asString nullTerminatedByteArray].	ws next: 2 put: 0.	^ws contents</body><body package="Registry">multipleStringsFrom: aByteArray	"provide a service which can turn a null terminated list of null terminated strings into a collection of 	ST strings"	| result readStream writeStream |	result := OrderedCollection new.	readStream := (aByteArray withEncoding: #UTF16) readStream.	writeStream := (String new: aByteArray size) writeStream.	[readStream atEnd] whileFalse: 			[readStream next				ifNotNil: 					[:char |					char codePoint = 0						ifTrue: 							[| string |							string := writeStream contents.							string notEmpty								ifTrue: 									[result add: string.									writeStream reset]]						ifFalse: [writeStream nextPut: char]]].	writeStream isEmpty ifFalse: [result add: writeStream contents].	^result</body><body package="Registry">registryBytesFor: anObject	"given an object, search in our map for first a block whose key (a class) matches that of anObject. If 	that fails, do a more exhaustive search using isKindOf:. Note the installation of an error condition 	block, which is done in case the class heirarchy search turns up nothing"		| block |	block := ToBytesMap at: anObject class		ifAbsent: [nil].	block ifNil:			[ToBytesMap keysAndValuesDo: [:cls :blk | (anObject isKindOf: cls) ifTrue: [block := blk]]].	^block ifNil:			[RegistryError raiseWith: anObject errorString: 'Unable to convert parameter to bytes']		ifNotNil: [block value: anObject]</body><body package="Registry">typeFor: anObject	"first look by class of anObject for aType in our map, if not found, start doing heirarchical searches 	(in case they're using a subclass variant of what we map), and finally fail if we can't find a mapping"	^ToTypeMap at: anObject class		ifAbsent: 			[ToTypeMap				keysAndValuesDo: [:cls :type | (anObject isKindOf: cls) ifTrue: [^type]].			RegistryError raiseWith: anObject errorString: 'Unable to determine type']</body></methods><methods><class-id>WindowsRegistry.Data class</class-id> <category>class initialization</category><body package="Registry">initialize	"set up the various mappings, the types are defined by the WinNT Advanced API"	"self initialize"	ToObjectMap := IdentityDictionary new.	ToTypeMap := IdentityDictionary new.	ToBytesMap := IdentityDictionary new.	ToObjectMap at: 1		put: (ToObjectMap at: 2				put: 					[:ba | 					"strings"					| offset |					offset := (ba size &gt; 1 and: [(ba at: ba size) = 0 and: [(ba at: ba size - 1) = 0]]) 						ifTrue: [2] ifFalse: [0].					(ba copyFrom: 1 to: ba size - offset) asStringEncoding: #UTF16]).	ToObjectMap at: 4		put: (ToObjectMap at: 5				put: 					[:ba | 					"the DWORDs"					(UninterpretedBytes from: ba) unsignedLongAt: 1]).	ToObjectMap at: 7		put: 			[:ba | 			"string lists"			self multipleStringsFrom: ba].	ToTypeMap at: Integer put: (ToTypeMap at: SmallInteger put: 4).	ToTypeMap at: CharacterArray put: (ToTypeMap at: ByteString put: 1).	ToTypeMap at: ByteArray put: 3.	ToTypeMap at: Array put: (ToTypeMap at: OrderedCollection put: 7).	ToBytesMap at: Integer		put: (ToBytesMap at: SmallInteger				put: 					[:obj | 					| ub |					ub := UninterpretedBytes new: 4.					ub unsignedLongAt: 1 put: obj.					ub asByteArray]).	ToBytesMap at: CharacterArray		put: (ToBytesMap at: ByteString				put: [:obj | obj asString nullTerminatedByteArray]).	ToBytesMap at: ByteArray put: [:obj | obj].	ToBytesMap at: Array		put: (ToBytesMap at: OrderedCollection				put: [:obj | self multipleStringsAsBytes: obj])</body></methods><methods><class-id>WindowsRegistry.RegistryError</class-id> <category>printing</category><body package="Registry">description	^parameter ifNil: [super description]		ifNotNil: [super description , ': ' , parameter printString]</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryKey</class-id> <category>utility</category><body package="Registry">close	self isOpen 		ifTrue: 			[(WindowsRegistryAPI current regCloseKey: osKey contents) = self successCode 				ifFalse: [RegistryError raiseSignal: 'Unable to close key'].			osKey := nil]</body><body package="Registry">create	self createAccess: self class writeAccessMask</body><body package="Registry">exists	^	[self		open;		close.	true] on: RegistryError do: [:ex | ex return: false]</body><body package="Registry">flushAndClose	self isOpen		ifTrue: 			[(WindowsRegistryAPI current regFlushKey: osKey contents) = self successCode				ifFalse: [RegistryError raiseSignal: 'Unable to flush key'].			"According to the documentation of RegFlushKey, the key is still open and must be closed now."			self close]</body><body package="Registry">subKeyNames		self open.	^[self readSubKeyNames] ensure: [self close]</body><body package="Registry">valueNames		self open.	^[self readValueNames] ensure: [self close]</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryKey</class-id> <category>private</category><body package="Registry">createAccess: anAccessMask	| rootOSKey returnCode |	self isOpen ifTrue: [^self].	rootOSKey := CVoidType void pointerType gcMalloc.	rootOSKey contents: (CVoidType void pointerType cast: rootKeyValue).	osKey := CVoidType void pointerType gcMalloc.	returnCode := WindowsRegistryAPI current				regCreateSubKey: osKey				named: keyPath nullTerminatedByteArray				under: rootOSKey contents				sam: anAccessMask.	returnCode = self successCode		ifFalse: 			[osKey := nil.			RegistryError raiseSignal: 'Unable to create key']</body><body package="Registry">deleteSubKeyNamed: aSubKeyTail 	self open.		[(WindowsRegistryAPI current regDeleteKey: self keyValue named: aSubKeyTail nullTerminatedByteArray) 		= self successCode 			ifFalse: 				[RegistryError raiseWith: (self subKeyNamed: aSubKeyTail)					errorString: 'Unable to delete key']] 			ensure: [self close]</body><body package="Registry">deleteValueNamed: aValueName 	self openAccess: self class writeAccessMask.		[(WindowsRegistryAPI current regDeleteValue: self keyValue named: aValueName nullTerminatedByteArray) 		= self successCode 			ifFalse: 				[RegistryError raiseWith: (self valueNamed: aValueName)					errorString: 'Unable to delete value']] 			ensure: [self close]</body><body package="Registry">getSubKeyNameAt: anIndex maxSize: anInteger 	| nameHolder |	nameHolder := CIntegerType char gcMalloc: anInteger * 2.	(WindowsRegistryAPI current 		regKeyAt: anIndex - 1		under: self keyValue		name: nameHolder		size: anInteger gcCopyToHeap) = self successCode 		ifFalse: 			[RegistryError raiseWith: anIndex				errorString: 'Unable to access sub key info'].	^nameHolder copyUnicodeStringFromHeap</body><body package="Registry">getValueNameAt: anIndex maxSize: anInteger 	| nameHolder |	nameHolder := CIntegerType char gcMalloc: anInteger * 2.	(WindowsRegistryAPI current 		regValueAt: anIndex - 1		under: self keyValue		name: nameHolder		size: anInteger gcCopyToHeap) = self successCode 		ifFalse: 			[RegistryError raiseWith: anIndex errorString: 'Unable to access value info'].	^nameHolder copyUnicodeStringFromHeap</body><body package="Registry">open	self openAccess: self class readAccessMask</body><body package="Registry">openAccess: anAccessMask	| rootOSKey returnCode |	self isOpen ifTrue: [^self].	rootOSKey := CVoidType void pointerType gcMalloc.	rootOSKey contents: (CVoidType void pointerType cast: rootKeyValue).	osKey := CVoidType void pointerType gcMalloc.	returnCode := WindowsRegistryAPI current				regOpenSubKey: osKey				named: keyPath nullTerminatedByteArray				fromRoot: rootOSKey contents				sam: anAccessMask.	returnCode = self successCode		ifFalse: 			[osKey := nil.			RegistryError raiseSignal: 'Unable to open key']</body><body package="Registry">readSubKeyNames		| numberOfKeysHolder maxLenHolder maxLen |	maxLenHolder := CIntegerType unsignedLong gcMalloc.	numberOfKeysHolder := CIntegerType unsignedLong gcMalloc.	(WindowsRegistryAPI current regKeyInfoFor: self keyValue		numberOfSubKeys: numberOfKeysHolder		maxKeyName: maxLenHolder		numberOfValues: CIntegerType unsignedLong gcMalloc		maxValueName: CIntegerType unsignedLong gcMalloc		maxValueSize: CIntegerType unsignedLong gcMalloc) = self successCode ifFalse:			[RegistryError raiseSignal: 'Unable to stat key'].	maxLen := maxLenHolder contents + 1.	^(1 to: numberOfKeysHolder contents) collect: [:i | self getSubKeyNameAt: i maxSize: maxLen]</body><body package="Registry">readValueNames		| maxLenHolder maxLen numberOfValuesHolder |	maxLenHolder := CIntegerType unsignedLong gcMalloc.	numberOfValuesHolder := CIntegerType unsignedLong gcMalloc.	(WindowsRegistryAPI current regKeyInfoFor: self keyValue		numberOfSubKeys: CIntegerType unsignedLong gcMalloc		maxKeyName: CIntegerType unsignedLong gcMalloc		numberOfValues: numberOfValuesHolder		maxValueName: maxLenHolder		maxValueSize: CIntegerType unsignedLong gcMalloc) = self successCode ifFalse:			[RegistryError raiseSignal: 'Unable to stat key'].	maxLen := maxLenHolder contents + 1.	^(1 to: numberOfValuesHolder contents) collect: [:i | self getValueNameAt: i maxSize: maxLen]</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryKey</class-id> <category>printing</category><body package="Registry">printPathOn: aStream 	aStream nextPutAll: (RootKeyValues keyAtValue: rootKeyValue).	keyPath isEmpty 		ifFalse: 			[aStream				nextPut: self separator;				nextPutAll: keyPath]</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryKey</class-id> <category>private-initialize</category><body package="Registry">setPath: aString 	"parse the head off of the key string and look up its associated key value. Store the rest of the 	string as the subKey tree name"	| rs rootString |	rs := aString readStream.	rootString := rs upTo: self separator.	rootKeyValue := RootKeyValues at: rootString asUppercase ifAbsent: [self error: 'Root key ' , rootString , ' does not exist!'].	keyPath := rs upToEnd</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryKey</class-id> <category>accessing</category><body package="Registry">keyValue	^osKey contents</body><body package="Registry">successCode	"return the code to use when evaluation whether API calls completed successfully"	^WindowsRegistryAPI current ERROR_SUCCESS</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryKey</class-id> <category>testing</category><body package="Registry">isOpen	"this is defined as whether we have a reference to an external pointer, this implies the importantness 	of nilling this when not actually open, otherwise, we'll get dangling CPointers that won't get garbage 	collected"	^osKey notNil</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryKey class</class-id> <category>constants</category><body package="Registry">readAccessMask	^131097</body><body package="Registry">writeAccessMask	"defined by WinNT API"	^131078</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryKey class</class-id> <category>accessing</category><body package="Registry">valueClass	^WindowsRegistryValue</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryKey class</class-id> <category>testing</category><body package="Registry">checkCurrentOS	"Checks if the receiver class is supported on the current platform. WindowsRegistryKey is platform specific for Windows and raises an error if this is not the current platform."	OSHandle currentOS == #win32 		ifFalse: 			[self error: ('&lt;1p&gt; not supported on &lt;2s&gt;' expandMacrosWith: self						with: OSHandle currentOS)]</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryAPI</class-id> <category>private-types</category><body package="Registry">BOOL	&lt;C: typedef long BOOL&gt;</body><body package="Registry">BYTE	&lt;C: typedef unsigned char BYTE&gt;</body><body package="Registry">DWORD	&lt;C: typedef unsigned long DWORD&gt;</body><body package="Registry">FILETIME	&lt;C: typedef struct  {DWORD dwLowDateTime;							DWORD dwHighDateTime;							} FILETIME&gt;</body><body package="Registry">HKEY	&lt;C: typedef void * HKEY&gt;</body><body package="Registry">LONG	&lt;C: typedef long LONG&gt;</body><body package="Registry">LPBYTE	&lt;C: typedef BYTE * LPBYTE&gt;</body><body package="Registry">LPCBYTE	&lt;C: typedef unsigned char  * LPCBYTE&gt;</body><body package="Registry">LPCSTR	&lt;C: typedef const char * LPCSTR&gt;</body><body package="Registry">LPCTSTR	&lt;C: typedef LPCSTR LPCTSTR&gt;</body><body package="Registry">LPCWSTR	&lt;C: typedef const char * LPCWSTR&gt;</body><body package="Registry">LPDWORD	&lt;C: typedef DWORD * LPDWORD&gt;</body><body package="Registry">LPSECURITY_ATTRIBUTES	&lt;C: typedef struct SECURITY_ATTRIBUTES * LPSECURITY_ATTRIBUTES&gt;</body><body package="Registry">LPTSTR	&lt;C: typedef char * LPTSTR&gt;</body><body package="Registry">LPVOID	&lt;C: typedef void * LPVOID&gt;</body><body package="Registry">PFILETIME	&lt;C: typedef FILETIME * PFILETIME&gt;</body><body package="Registry">PHKEY	&lt;C: typedef HKEY *PHKEY&gt;</body><body package="Registry">REGSAM	&lt;C: typedef DWORD REGSAM&gt;</body><body package="Registry">SECURITY_ATTRIBUTES	"Describes security of associated process."	&lt;C: struct SECURITY_ATTRIBUTES {			DWORD nLength;			LPVOID lpSecurityDescriptor;			BOOL bInheritHandle;		}&gt;</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryAPI</class-id> <category>procedures</category><body package="Registry">regCreateSubKey: phkResult named: lpSubKey under: hKey sam: samDesired	"provide a shortcut with the default/annoying arguments filtered out"	^self		regCreateKey: hKey		named: lpSubKey		reserved: 0		class: nil		options: self REG_OPTION_NON_VOLATILE		sam: samDesired		security: nil		result: phkResult		disposition:nil</body><body package="Registry">regKeyAt: dwIndex under: hKey name: lpName size: lpcName	"provide a shortcut method with defaults filled in"	^self		regEnumKey: hKey		subkeyIndex: dwIndex		nameBuffer: lpName		nameSizePointer: lpcName		reserved: nil		class: nil		classSizePointer: nil		lastWriteTimePointer: nil</body><body package="Registry">regKeyInfoFor: hKey numberOfSubKeys: lpcSubKeys maxKeyName: lpcMaxSubKeyLen numberOfValues: lpcValues maxValueName: lpcMaxValueNameLen maxValueSize: lpcMaxValueLen	"shortcut with defaults and don't cares filled in"	^self		regQueryInfoKey: hKey		class: nil		classLengthPointer: nil		reserved: nil		numberOfSubkeys: lpcSubKeys		maxSubkeyLength: lpcMaxSubKeyLen		maxClassLength: nil		numberOfValues: lpcValues		maxValueNameLength: lpcMaxValueNameLen		maxValueLength: lpcMaxValueLen		securitySize: nil		lastWriteTime: nil</body><body package="Registry">regOpenSubKey: phkResult named: lpSubKey fromRoot: hKey sam: samDesired	"stub the don't care arguments"	^self		regOpenKeyEx: hKey		subKey: lpSubKey		options: 0		access: samDesired		result: phkResult</body><body package="Registry">regQueryValueNamed: lpValueName in: hKey type: lpType value: lpData size: lpcbData	"stub out the default arguments"	^self		regQueryValueEx: hKey		name: lpValueName		reserved: nil		type: lpType		data: lpData		size: lpcbData</body><body package="Registry">regSetValueNamed: lpValueName in: hKey type: dwType value: lpData size: cbData	"stub out the reserved arguments"	^self		regSetValueEx: hKey		name: lpValueName		reserved: 0		type: dwType		data: lpData		size: cbData</body><body package="Registry">regValueAt: dwIndex under: hKey name: lpValueName size: lpcchValueName	"stub out the reserved and don't care arguments"	^self		regEnumValue: hKey		subkeyIndex: dwIndex		nameBuffer: lpValueName		nameSizePointer: lpcchValueName		reserved: nil		typePointer: nil		dataBuffer: nil		dataBufferSizePointer: nil</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryAPI</class-id> <category>constants</category><body package="Registry">ERROR_MORE_DATA	^234</body><body package="Registry">ERROR_NO_MORE_ITEMS	^259</body><body package="Registry">ERROR_SUCCESS	^0</body><body package="Registry">KEY_ALL_ACCESS	^983103</body><body package="Registry">KEY_CREATE_LINK	^2r100000</body><body package="Registry">KEY_CREATE_SUB_KEY	^2r100</body><body package="Registry">KEY_ENUMERATE_SUB_KEYS	^2r1000</body><body package="Registry">KEY_EXECUTE	^131097</body><body package="Registry">KEY_NOTIFY	^2r10000</body><body package="Registry">KEY_QUERY_VALUE	^2r1</body><body package="Registry">KEY_READ	^131097</body><body package="Registry">KEY_SET_VALUE	^2r10</body><body package="Registry">KEY_WRITE	^131078</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryAPI</class-id> <category>constants-value types</category><body package="Registry">REG_BINARY	^3</body><body package="Registry">REG_DWORD	^4</body><body package="Registry">REG_DWORD_BIG_ENDIAN	^5</body><body package="Registry">REG_DWORD_LITTLE_ENDIAN	^4</body><body package="Registry">REG_EXPAND_SZ	^2</body><body package="Registry">REG_LINK	^6</body><body package="Registry">REG_MULTI_SZ	^7</body><body package="Registry">REG_NONE	^0</body><body package="Registry">REG_RESOURCE_LIST	^8</body><body package="Registry">REG_SZ	^1</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryAPI</class-id> <category>constants-options</category><body package="Registry">REG_OPTION_BACKUP_RESTORE	^4</body><body package="Registry">REG_OPTION_CREATE_LINK	^2</body><body package="Registry">REG_OPTION_NON_VOLATILE	^0</body><body package="Registry">REG_OPTION_VOLATILE	^1</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryAPI</class-id> <category>constants-disposition</category><body package="Registry">REG_CREATED_NEW_KEY	^1</body><body package="Registry">REG_OPENED_EXISTING_KEY	^2</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryAPI class</class-id> <category>instance creation</category><body package="Registry">current	current isNil ifTrue: [current := self new].	^current</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Registry">asRegistryKey	^WindowsRegistry.Key path: self</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="Registry">nullTerminatedByteArray	"Convert the receiver to a UTF16 encoded ByteArray with C-style null termination."	"We can't use 'self asCStringEncoding: #UTF16' yet because it does not exist in VisualWorks 7.6 and earlier."	^((ByteArray new: self size) withEncoding: #UTF16) writeStream		nextPutAll: self;		nextPut: (Character codePoint: 0);		close;		encodedContents</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryAPI</class-id> <category>procedures</category><body package="Registry">regCloseKey: hKey	&lt;C: LONG RegCloseKey (HKEY  hKey)&gt;	^self externalAccessFailed</body><body package="Registry">regDeleteKey: hKey named: lpSubKey	&lt;C: LONG RegDeleteKeyW (HKEY hKey, LPCTSTR  lpSubKey)&gt;	^self externalAccessFailed</body><body package="Registry">regDeleteValue: hKey named: lpValueName	&lt;C: long int RegDeleteValueW (HKEY hKey, LPCTSTR  lpValueName)&gt;	^self externalAccessFailed</body><body package="Registry">regFlushKey: hKey	&lt;C: LONG RegFlushKey (HKEY hKey)&gt;	^self externalAccessFailed</body></methods><methods><class-id>WindowsRegistry.WindowsRegistryAPI</class-id> <category>private-procedures</category><body package="Registry">regCreateKey: hKey named: lpSubKey reserved: reserved class: lpClass options: dwOptions sam: samDesired security: lpSecurityAttributes result: phkResult disposition: lpdwDisposition	&lt;C: LONG RegCreateKeyExW(			HKEY hKey,			LPCTSTR lpSubKey,			DWORD reserved,			LPTSTR lpClass,			DWORD dwOptions,			REGSAM samDesired,			LPSECURITY_ATTRIBUTES lpSecurityAttributes,			PHKEY phkResult,			LPDWORD lpdwDisposition			)&gt;	^self externalAccessFailed</body><body package="Registry">regEnumKey: hKey subkeyIndex: dwIndex nameBuffer: lpName nameSizePointer: lpcName reserved: lpReserved class: lpClass classSizePointer: lpcClass lastWriteTimePointer: lpftLastWriteTime	&lt;C: LONG RegEnumKeyExW (			HKEY hKey,			DWORD dwIndex,			LPTSTR lpName,			LPDWORD lpcName,			LPDWORD lpReserved,			LPTSTR lpClass,			LPDWORD lpcClass,			PFILETIME lpftLastWriteTime			)&gt;	^self externalAccessFailed</body><body package="Registry">regEnumValue: hKey subkeyIndex: dwIndex nameBuffer: lpValueName nameSizePointer: lpcchValueName reserved: lpReserved typePointer: lpType dataBuffer: lpData dataBufferSizePointer: lpcbData	&lt;C: LONG RegEnumValueW (			HKEY hKey,			DWORD dwIndex,			LPTSTR lpValueName,			LPDWORD lpcchValueName,			LPDWORD lpReserved,			LPDWORD lpType,			LPBYTE lpData,			LPDWORD lpcbData			)&gt;	^self externalAccessFailed</body><body package="Registry">regOpenKeyEx: hKey subKey: lpSubKey options: ulOptions access: samDesired result: phkResult	&lt;C: LONG RegOpenKeyExW (			HKEY hKey,			LPCTSTR lpSubKey,			DWORD ulOptions,			REGSAM samDesired,			PHKEY phkResult			)&gt;	^self externalAccessFailed</body><body package="Registry">regQueryInfoKey: hKey class: lpClass classLengthPointer: lpcClass reserved: lpReserved numberOfSubkeys: lpcSubKeys maxSubkeyLength: lpcMaxSubKeyLen maxClassLength: lpcMaxClassLen numberOfValues: lpcValues maxValueNameLength: lpcMaxValueNameLen maxValueLength: lpcMaxValueLen securitySize: lpcbSecurityDescriptor lastWriteTime: lpftLastWriteTime	&lt;C: LONG RegQueryInfoKeyW (			HKEY hKey,			LPTSTR lpClass,			LPDWORD lpcClass,			LPDWORD lpReserved,			LPDWORD lpcSubKeys,			LPDWORD lpcMaxSubKeyLen,			LPDWORD lpcMaxClassLen,			LPDWORD lpcValues,			LPDWORD lpcMaxValueNameLen,			LPDWORD lpcMaxValueLen,			LPDWORD lpcbSecurityDescriptor,			PFILETIME lpftLastWriteTime			)&gt;	^self externalAccessFailed</body><body package="Registry">regQueryValueEx: hKey name: lpValueName reserved: lpReserved type: lpType data: lpData size: lpcbData	&lt;C: LONG RegQueryValueExW (			HKEY hKey,			LPCTSTR lpValueName,			LPDWORD lpReserved,			LPDWORD lpType,			LPBYTE lpData,			LPDWORD lpcbData			)&gt;	^self externalAccessFailed</body><body package="Registry">regSetValueEx: hKey name: lpValueName reserved: reserved type: dwType data: lpData size: cbData	&lt;C: LONG RegSetValueExW (			HKEY hKey,			LPCTSTR lpValueName,			DWORD reserved,			DWORD dwType,			const BYTE *lpData,			DWORD cbData			)&gt;	^self externalAccessFailed</body></methods><initialize><class-id>WindowsRegistry.Key</class-id></initialize><initialize><class-id>WindowsRegistry.Data</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>