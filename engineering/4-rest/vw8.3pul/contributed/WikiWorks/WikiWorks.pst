<?xml version="1.0"?><st-source><!-- Name: WikiWorksDbIdentifier: psql_public_cst_2007DbTrace: 92371DbUsername: niallrDbVersion: 7.10.1 - 2DevelopmentPrerequisites: #(#(#any 'FileServer' '') #(#any 'HttpServer' '') #(#any 'WikiMacros' '') #(#any 'WikiSpamManagement' ''))PackageName: WikiWorksParcel: #('WikiWorks')ParcelName: WikiWorksPrerequisiteDescriptions: #(#(#name 'FileServer') #(#name 'HttpServer') #(#name 'WikiMacros' #componentType #package) #(#name 'WikiSpamManagement' #componentType #package))PrerequisiteParcels: #(#('FileServer' '') #('HttpServer' '') #('WikiMacros' '') #('WikiSpamManagement' ''))PrintStringCache: (7.10.1 - 2,niallr)Version: 7.10.1 - 2Pre-Unload Block: 	[:pkg | WikiWorks.FlatFileWiki preUnloadActionFor: pkg]Date: 5:00:10 PM January 26, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 26, 2016 at 5:00:10 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WikiPage</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>author timestamp </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.*			</imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks</package></attributes></class><class><name>ChangedWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.WikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>previousVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks</package></attributes></class><class><name>EditedWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.ChangedWikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks</package></attributes></class><class><name>RenamedWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.ChangedWikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks</package></attributes></class><class><name>CollectionAdapter</name><environment>WikiWorks</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>WikiWorks</package></attributes></class><class><name>PageRender</name><environment>WikiWorks</environment><super>WikiWorks.HtmlRender</super><private>false</private><indexed-type>none</indexed-type><inst-vars>page </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks</package></attributes></class><class><name>WikiPageRender</name><environment>WikiWorks</environment><super>WikiWorks.PageRender</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentStream currentChar lastChar headingLevel inTable bulletLevel numberLevel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks</package></attributes></class><class><name>PreviewRender</name><environment>WikiWorks</environment><super>WikiWorks.WikiPageRender</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks</package></attributes></class><class><name>CompositeWiki</name><environment>WikiWorks</environment><super>WikiWorks.CompositeRequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks</package></attributes></class><class><name>Wiki</name><environment>WikiWorks</environment><super>WikiWorks.CompositeWiki</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pages rootPageTitle formattingPageTitle replaceUploadedFiles allowRevert </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks</package></attributes></class><comment><class-id>WikiWorks.Wiki</class-id><body>A Wiki is made up of four kinds of classes; Wiki, WikiServer, WikiPage, and WikiRendering.A Wiki has a collection of pages, which can be read or edited over the web.  A WikiServercatches http requests and converts them into operations on the Wiki.  It can manage aset of Wikis.  The Wiki finds the appropriate page for a request, determines the command being performed on the page, and selects a WikiRendering to match that command.  The WikiRendering then produces HTML for the page, which the WikiServer will sendback to the web browser.There are many subclasses of WikiRendering, one for each way that a page can beconverted into HTML.  Each subclass represents a different command, such as editing,changing the name of a page, or looking at old versions of a page.There are also many subclasses of WikiPage.  Except for the original page, eachversion points to the previous version of the page.  Since the original page is alwaysof the form "Describe XXX here", it is not very interesting.  Other versions of the pagecan have a custom contents or can be renamed or have an attachment.Wiki is currently only subclassed to provide different forms of persistence.Instance Variables:	formattingPageTitle	&lt;Character | CharacterArray&gt;		name	&lt;String&gt;		pages	&lt;(Dictionary of: (ChangedWikiPage | OriginalWikiPage | TextPage ))&gt;		rootPageTitle	&lt;Character | CharacterArray&gt;	</body></comment><class><name>PromotedWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.ChangedWikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>promotedVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks</package></attributes></class><class><name>DifferenceRender</name><environment>WikiWorks</environment><super>WikiWorks.WikiPageRender</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newVersion oldVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks</package></attributes></class><class><name>FlatFileWiki</name><environment>WikiWorks</environment><super>WikiWorks.Wiki</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileCounter idMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks</package></attributes></class><class><name>WikiRender</name><environment>WikiWorks</environment><super>WikiWorks.HtmlRender</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks</package></attributes></class><class><name>WikiPageLink</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>address name siblingReference isMethod fragment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>WikiWorks</package></attributes></class><class><name>CompositeWikiRender</name><environment>WikiWorks</environment><super>WikiWorks.WikiRender</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks</package></attributes></class><class><name>OriginalWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.WikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks</package></attributes></class><class><name>TestPageRender</name><environment>WikiWorks</environment><super>WikiWorks.WikiPageRender</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks</package></attributes></class><class><name>RevertedWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.ChangedWikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks</package></attributes></class><class><name>VersionRender</name><environment>WikiWorks</environment><super>WikiWorks.WikiPageRender</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks</package></attributes></class><class><name>TokenDifference</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>old new results newPos oldPos </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>WikiWorks</package></attributes></class><methods><class-id>WikiWorks.WikiPage</class-id> <category>accessing</category><body package="WikiWorks">allTitles	| oc |	oc := OrderedCollection new.	self allTitlesInto: oc.	^oc</body><body package="WikiWorks">allTitlesInto: aCollection 	self subclassResponsibility</body><body package="WikiWorks">author	^author</body><body package="WikiWorks">author: authorName 	author := authorName</body><body package="WikiWorks">contents	self subclassResponsibility</body><body package="WikiWorks">encodedTitle	^self title encodedHTTP</body><body package="WikiWorks">references: aString 	^(aString match: self contents) or: [aString match: self title]</body><body package="WikiWorks">tabularHistoricalSynopsis	^'?'</body><body package="WikiWorks">timestamp	^timestamp</body><body package="WikiWorks">timestamp: aTimestamp 	timestamp := aTimestamp asTimestamp</body><body package="WikiWorks">title	self subclassResponsibility</body><body package="WikiWorks">versionAt: aNumber 	self versionsDo: [:each | each versionNumber = aNumber ifTrue: [^each]].	^self subscriptBoundsError: aNumber</body><body package="WikiWorks">versionNumber	self subclassResponsibility</body><body package="WikiWorks">versionsDo: aBlock 	self subclassResponsibility</body><body package="WikiWorks">versionsReverseDo: aBlock 	self subclassResponsibility</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>testing</category><body package="WikiWorks">canBeReleased	^false</body><body package="WikiWorks">isOriginal	^false</body><body package="WikiWorks">isPromoted	^false</body><body package="WikiWorks">isRenamed	^false</body><body package="WikiWorks">isReverted	^false</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>initialize-release</category><body package="WikiWorks">initialize	timestamp := Timestamp now.	author := ''</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>flat file</category><body package="WikiWorks">saveToFile: aFileStream under: aWiki 	aFileStream		nextPutAll: self class name;		cr.	aFileStream		nextPutAll: author;		cr.	aFileStream		print: timestamp asSeconds;		cr</body><body package="WikiWorks">specificData: anObject 	self subclassResponsibility</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>editing</category><body package="WikiWorks">changeTitle: titleString by: authorName 	| newGuy |	titleString ifNil: [^self].	titleString isEmpty ifTrue: [^self].	titleString = self title ifTrue: [^self].	newGuy := self newVersionOf: RenamedWikiPage by: authorName.	newGuy title: titleString.	^newGuy</body><body package="WikiWorks">newContents: contentsString by: anAuthor 	| newGuy |	contentsString ifNil: [^self].	(self maliciousTags contains: [:each | each match: contentsString]) 		ifTrue: [^self].	newGuy := self newVersionOf: EditedWikiPage by: anAuthor.	newGuy contents: contentsString.	^newGuy contents = self contents ifTrue: [self] ifFalse: [newGuy]</body><body package="WikiWorks">newContentsProcessMacros: contentsString by: anAuthor inWiki: aWiki 	| signatureTable |	(contentsString == nil) | (self title asUppercase = WikiMacrosProcessor signatureMacrosPageName)			ifTrue: [^self newContents: contentsString by: anAuthor].	signatureTable := (aWiki pageTitled: WikiMacrosProcessor signatureMacrosPageName)					ifNotNil: [:signaturePage | signaturePage contents].	^self		newContents: (WikiMacrosProcessor processString: contentsString by: anAuthor withSignatureTable: signatureTable)		by: anAuthor</body><body package="WikiWorks">newVersionOf: aWikiPageSubClass by: authorName 	| newGuy |	newGuy := aWikiPageSubClass new.	newGuy previousVersion: self.	newGuy author: authorName.	^newGuy</body><body package="WikiWorks">promoteVersion: anInteger by: anAuthor 	| newGuy |	(anInteger &lt;= 0 or: [anInteger &gt;= self versionNumber]) ifTrue: [^self].	newGuy := self newVersionOf: PromotedWikiPage by: anAuthor.	newGuy specificData: (self versionAt: anInteger).	^newGuy</body><body package="WikiWorks">revertToVersion: anInteger by: anAuthor 	"^a RevertedPageI return a new page version that represents the reversion.  All page versions post anInteger version are purged."	(anInteger &lt;= 0 or: [anInteger &gt;= self versionNumber]) ifTrue: [^self].	^(RevertedWikiPage new)		previousVersion: (self versionAt: anInteger);		author: anAuthor;		yourself</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>comparing</category><body package="WikiWorks">&lt;= aPage	^self title &lt;= aPage title</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>constants</category><body package="WikiWorks">maliciousTags	"See http://www.cert.org/advisories/CA-2000-02.html"	^#('*&lt;SCRIPT*' '*&lt;OBJECT*' '*&lt;APPLET*' '*&lt;EMBED*' '*&lt;FORM*')</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>printing</category><body package="WikiWorks">printOn: aStream 	aStream		nextPut: $[;		nextPutAll: self title;		nextPut: $(;		print: self versionNumber;		nextPut: $);		nextPut: $];		cr.	aStream		nextPutAll: self contents;		cr.	aStream		nextPut: ${;		nextPutAll: author;		space;		print: timestamp;		nextPut: $}</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>recovery</category><body package="WikiWorks">prevFilenameFrom: stream in: directory	^directory construct: (stream nextLine, '.pag')</body><body package="WikiWorks">readSpecificPageDataFrom: stream in: directory	^self subclassResponsibility</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>rss-support</category><body package="WikiWorks">addSimpleTag: tag	| element |	element := Element tag: tag.	^element</body><body package="WikiWorks">addSimpleTag: tag to: doc	| element |	element := self addSimpleTag: tag.	doc root addNode: element</body><body package="WikiWorks">addTag: tag withText: text	| xmlText element |	xmlText := Text text: text.	element := Element tag: tag.	element addNode: xmlText.	^element</body><body package="WikiWorks">addTag: tag withText: text to: doc	| element |	element := self addTag: tag withText: text.	doc root addNode: element</body><body package="WikiWorks">addTags: tagArray withTextItems: textArray	| coll |	coll := OrderedCollection new.	1 to: tagArray size do: [:i |		coll add: (self addTag: (tagArray at: i) withText: (textArray at: i))].	^coll</body></methods><methods><class-id>WikiWorks.WikiPage class</class-id> <category>instance creation</category><body package="WikiWorks">new	^super new initialize</body></methods><methods><class-id>WikiWorks.ChangedWikiPage</class-id> <category>accessing</category><body package="WikiWorks">allTitlesInto: aCollection 	previousVersion allTitlesInto: aCollection</body><body package="WikiWorks">allVersions	| allVersions |	allVersions := OrderedCollection new.	self versionsDo: [:aVersion | allVersions add: aVersion].	^allVersions</body><body package="WikiWorks">contents	^previousVersion contents</body><body package="WikiWorks">previousVersion	^previousVersion</body><body package="WikiWorks">previousVersion: aPage 	previousVersion := aPage</body><body package="WikiWorks">title	^previousVersion title</body><body package="WikiWorks">versionNumber	^previousVersion versionNumber + 1</body><body package="WikiWorks">versionsDo: aBlock 	aBlock value: self.	previousVersion versionsDo: aBlock</body><body package="WikiWorks">versionsReverseDo: aBlock 	previousVersion versionsReverseDo: aBlock.	aBlock value: self</body></methods><methods><class-id>WikiWorks.ChangedWikiPage</class-id> <category>flat file</category><body package="WikiWorks">saveToFile: aFileStream under: aWiki 	super saveToFile: aFileStream under: aWiki.	aFileStream		print: (aWiki idForPage: self previousVersion);		cr</body></methods><methods><class-id>WikiWorks.EditedWikiPage</class-id> <category>flat file</category><body package="WikiWorks">saveToFile: aFileStream under: aWiki 	super saveToFile: aFileStream under: aWiki.	aFileStream nextPutAll: contents</body><body package="WikiWorks">specificData: aString 	self contents: aString</body></methods><methods><class-id>WikiWorks.EditedWikiPage</class-id> <category>accessing</category><body package="WikiWorks">contents	^contents</body><body package="WikiWorks">contents: contentsString 	"trim off trailing CRs"	| index |	index := contentsString size.	[index &gt; 1 and: [(contentsString at: index) = Character cr]] 		whileTrue: [index := index - 1].	contents := contentsString copyTo: index</body><body package="WikiWorks">tabularHistoricalSynopsis	^'Edited'</body></methods><methods><class-id>WikiWorks.EditedWikiPage</class-id> <category>recovery</category><body package="WikiWorks">readSpecificPageDataFrom: stream in: directory	| prevFilename tmpStream |	prevFilename := self prevFilenameFrom: stream in: directory.	tmpStream := WriteStream on: (String new: 100).	[stream atEnd]		whileFalse: [| next |					next := stream next.					[tmpStream nextPut: next]						on: Error						do: [:ex | nil]].	self specificData: tmpStream contents.	stream close.	^prevFilename</body></methods><methods><class-id>WikiWorks.RenamedWikiPage</class-id> <category>accessing</category><body package="WikiWorks">allTitlesInto: aCollection 	aCollection add: title.	super allTitlesInto: aCollection</body><body package="WikiWorks">tabularHistoricalSynopsis	^'Renamed'</body><body package="WikiWorks">title	^title</body><body package="WikiWorks">title: titleString 	title := titleString</body></methods><methods><class-id>WikiWorks.RenamedWikiPage</class-id> <category>flat file</category><body package="WikiWorks">saveToFile: aFileStream under: aWiki 	super saveToFile: aFileStream under: aWiki.	aFileStream nextPutAll: title</body><body package="WikiWorks">specificData: titleString 	self title: titleString</body></methods><methods><class-id>WikiWorks.RenamedWikiPage</class-id> <category>recovery</category><body package="WikiWorks">readSpecificPageDataFrom: stream in: directory	| prevFilename |	prevFilename := self prevFilenameFrom: stream in: directory.	self specificData: stream upToEnd.	stream close.	^prevFilename</body></methods><methods><class-id>WikiWorks.RenamedWikiPage</class-id> <category>testing</category><body package="WikiWorks">isRenamed	^true</body></methods><methods><class-id>WikiWorks.CollectionAdapter</class-id> <category>removing</category><body package="WikiWorks">remove: oldObject ifAbsent: anExceptionBlock 	collection remove: (collection 				detect: [:each | (self class with: each) includes: oldObject]				ifNone: [^anExceptionBlock value]).	^oldObject</body></methods><methods><class-id>WikiWorks.CollectionAdapter</class-id> <category>initialize-release</category><body package="WikiWorks">initialize	collection := Set new</body></methods><methods><class-id>WikiWorks.CollectionAdapter</class-id> <category>enumerating</category><body package="WikiWorks">do: aBlock 	collection do: [:each | each value: aBlock]</body></methods><methods><class-id>WikiWorks.CollectionAdapter</class-id> <category>adding</category><body package="WikiWorks">add: anObject 	^collection add: anObject</body></methods><methods><class-id>WikiWorks.CollectionAdapter class</class-id> <category>instance creation</category><body package="WikiWorks">new	^super new initialize</body></methods><methods><class-id>WikiWorks.PageRender</class-id> <category>accessing</category><body package="WikiWorks">formattingPageURL	self linkTo: 			[self handlerURL.			self ,= $/.			self ,= handler formattingPage encodedTitle]		titled: [self ,= handler formattingPage title].	^''</body><body package="WikiWorks">homePageSpecial	^page == handler rootPage 		ifTrue: ['/PAGES" &gt;Pages']		ifFalse: ['" &gt;Back to Top']</body><body package="WikiWorks">page	^page</body><body package="WikiWorks">pageTitle	^self page title</body><body package="WikiWorks">pageURL	^page encodedTitle</body><body package="WikiWorks">pageURL: aBlock 	self linkTo: 			[self handlerURL.			aBlock value.			self ,= self pageURL]		titled: [self ,= self pageTitle].	^''</body><body package="WikiWorks">pageVersion	^page versionNumber</body><body package="WikiWorks">pageVersionString	^self pageVersion printString</body><body package="WikiWorks">previousVersionString	^(self pageVersion - 1 max: 0) printString</body></methods><methods><class-id>WikiWorks.PageRender</class-id> <category>testing</category><body package="WikiWorks">isLatestPage	^true</body><body package="WikiWorks">isOriginalPage	^self page isOriginal</body><body package="WikiWorks">isPreviewPage	^false</body></methods><methods><class-id>WikiWorks.PageRender</class-id> <category>initialize-release</category><body package="WikiWorks">request: aRequest in: aRequestHandler 	| newTitle |	super request: aRequest in: aRequestHandler.	page := handler pageTitled: aRequest lastIdentifier.	"For editting a new page."	page ifNil: 			[page := OriginalWikiPage new.			page author: aRequest peerName.			page title: aRequest lastIdentifier].	"For rename conflict."	newTitle := aRequest postDataAt: #NEWTITLE.	newTitle notNil: [page := page changeTitle: newTitle by: page author]</body></methods><methods><class-id>WikiWorks.WikiPageRender</class-id> <category>parsing states</category><body package="WikiWorks">atLineStart	^lastChar == Character cr</body><body package="WikiWorks">inBullets	^bulletLevel &gt; 0</body><body package="WikiWorks">inHeading	^headingLevel &gt; 0</body><body package="WikiWorks">inNumbers	^numberLevel &gt; 0</body><body package="WikiWorks">inTable	^inTable</body><body package="WikiWorks">isInTable	inTable := true</body><body package="WikiWorks">notInTable	inTable := false</body><body package="WikiWorks">resetBullets	bulletLevel := 0</body><body package="WikiWorks">resetHeading	headingLevel := 0</body><body package="WikiWorks">resetNumbers	numberLevel := 0</body><body package="WikiWorks">resetParsingStates	currentChar := Character cr.	self resetHeading.	self resetBullets.	self resetNumbers.	self notInTable</body></methods><methods><class-id>WikiWorks.WikiPageRender</class-id> <category>parsing</category><body package="WikiWorks">addCurrentChar	self ,= currentChar</body><body package="WikiWorks">closeBullets	self closeListItem.	bulletLevel timesRepeat: [self closeBulletList].	self resetBullets</body><body package="WikiWorks">closeHeading	self		,= '&lt;/FONT&gt;&lt;/H';		,= headingLevel printString;		!= '&gt;'.	self resetHeading</body><body package="WikiWorks">closeNumbers	self closeListItem.	numberLevel timesRepeat: [self closeNumberList].	self resetNumbers</body><body package="WikiWorks">closeTableRow	self closeTableCell.	self != '&lt;/TR&gt;'.	((contentStream peekForAll: '||') 		or: [(contentStream peekForAll: '|{') or: [contentStream peekForAll: '|}']]) 			ifTrue: 				[contentStream skip: -2.				^self].	self != '&lt;/TABLE&gt;'.	self notInTable</body><body package="WikiWorks">getNextChar	lastChar := currentChar.	currentChar := contentStream next</body><body package="WikiWorks">processAsterix	| currentLevel |	self atLineStart ifFalse: [^self addCurrentChar].	self inBullets ifTrue: [self closeListItem].	currentLevel := 1.	[contentStream peekFor: $*] whileTrue: [currentLevel := currentLevel + 1].	bulletLevel - currentLevel timesRepeat: [self closeBulletList].	currentLevel - bulletLevel timesRepeat: [self startBulletList].	self startListItem.	bulletLevel := currentLevel</body><body package="WikiWorks">processBang	self atLineStart 		ifTrue: [self processHeadingLevel]		ifFalse: [self addCurrentChar]</body><body package="WikiWorks">processCR	self inHeading ifTrue: [^self closeHeading].	self inTable ifTrue: [^self closeTableRow].	self atLineStart ifFalse: [^self space].	self inBullets ifTrue: [^self closeBullets].	self inNumbers ifTrue: [^self closeNumbers].	self paragraph</body><body package="WikiWorks">processCurrentChar	currentChar == $\ ifTrue: [^self processEscape].	currentChar == Character space ifTrue: [^self processSpace].	currentChar == Character tab ifTrue: [^self processSpace].	currentChar == Character cr ifTrue: [^self processCR].	currentChar == $[ ifTrue: [^self processLeftBracket].	currentChar == $&lt; ifTrue: [^self processLeftAngle].	currentChar == $* ifTrue: [^self processAsterix].	currentChar == $# ifTrue: [^self processPound].	currentChar == $~ ifTrue: [^self processTilde].	currentChar == $- ifTrue: [^self processDash].	currentChar == $! ifTrue: [^self processBang].	currentChar == $| ifTrue: [^self processPipe].	self addCurrentChar</body><body package="WikiWorks">processDash	(self atLineStart and: [contentStream peekForAll: '---']) 		ifFalse: [^self addCurrentChar].	contentStream skipThrough: Character cr.	currentChar := Character cr.	self horizontalRule</body><body package="WikiWorks">processEscape	self getNextChar.	self addCurrentChar</body><body package="WikiWorks">processExistingPage: link in: targetHandler 	| address |	address := targetHandler currentTitleOf: link address.	self linkTo: 			[targetHandler URLon: replyStream.			self ,= $/.			self ,= address encodedHTTP.			link hasFragment 				ifTrue: 					[self ,= $#.					self ,= link fragment encodedHTTP]]		titled: 			[link isAnonymous 				ifTrue: 					[self ,= address.					link hasFragment 						ifTrue: 							[self ,= $#.							self ,= link fragment]]				ifFalse: [self ,= link name]]</body><body package="WikiWorks">processHeadingLevel	headingLevel := headingLevel + 1.	(contentStream peekFor: $!) ifTrue: [^self processHeadingLevel].	self		,= '&lt;H';		,= headingLevel printString;		,= ' &gt;&lt;FONT face="Arial" &gt;'</body><body package="WikiWorks">processLeftAngle	self addCurrentChar.	(contentStream insensitivePeekForAll: 'PRE') ifFalse: [^self].	self ,= 'PRE'.		[contentStream atEnd or: 			[| closeTag |			closeTag := contentStream through: $&gt;.			self ,= closeTag.			closeTag sameAs: '/PRE&gt;']] 			whileFalse: [self ,= (contentStream through: $&lt;)].	currentChar := $&gt;</body><body package="WikiWorks">processLeftBracket	| link targetHandler |	(contentStream peekFor: $[) ifTrue: [^self addCurrentChar].	link := WikiPageLink new contents: (contentStream upTo: $] escaper: $\).	link isMethod ifTrue: [^self processMethod: link].	targetHandler := (link siblingReference 				notNil: [handler siblingNamed: link siblingReference ifAbsent: [nil]]) 					ifNil: [handler].	link isImage 		ifTrue: 			[^self inlineImage: 					[link isExternalLink ifFalse: [self fileServerURL: targetHandler].					self ,= link address]].	link isExternalLink 		ifTrue: [^self linkTo: [self ,= link address] titled: [self ,= link name]].	(targetHandler hasFilenamed: link address) 		ifTrue: 			[^self linkTo: 					[self fileServerURL: targetHandler.					self ,= link address encodedHTTP]				titled: [self ,= link name]].	self processPage: link in: targetHandler</body><body package="WikiWorks">processMethod: link 	| class className selector |	className := link name.	class := [Compiler 			evaluate: className			for: nil			in: self class environment			notifying: nil			logged: false]				on: Error				do: [:ex | ex return: nil].	selector := link address.	(class isBehavior and: [class canUnderstand: selector]) 		ifTrue: [^self processMethodSelector: selector ofClass: class].	self italicize:		[self ,= className.		self ,= '&gt;&gt;#'.		self ,= selector].</body><body package="WikiWorks">processMethodSelector: selector ofClass: class 	| source realClass |	realClass := (class includesSelector: selector) 				ifTrue: [class]				ifFalse: [class whichClassIncludesSelector: selector].	source := realClass sourceCodeAt: selector.	self precise: 			[self ,= class.			class == realClass 				ifFalse: 					[self ,= $(.					self ,= realClass.					self ,= $)].			self ,= '&gt;&gt;#'.			self ,= source]</body><body package="WikiWorks">processPage: link in: targetHandler 	| fragment |	(targetHandler hasPageTitled: link address) 		ifTrue: [^self processExistingPage: link in: targetHandler].	fragment := link copy fragmentize.	(targetHandler hasPageTitled: fragment address) 		ifTrue: [^self processExistingPage: fragment in: targetHandler].	self linkTo: 			[targetHandler URLon: replyStream.			self ,= '/EDIT/'.			self ,= link address encodedHTTP]		titled: [self italicize: [self ,= link name]]</body><body package="WikiWorks">processPipe	| align |	(contentStream peekFor: $|) ifTrue: [align := 'CENTER'].	(contentStream peekFor: ${) ifTrue: [align := 'LEFT'].	(contentStream peekFor: $}) ifTrue: [align := 'RIGHT'].	align ifNil: [^self addCurrentChar].	self atLineStart 		ifFalse: 			[^self inTable 				ifTrue: 					[self closeTableCell.					self startTableCell: align]				ifFalse: [self ,= '||']].	self inTable 		ifFalse: [self != '&lt;TABLE border="2" cellpadding="4" cellspacing="0" &gt;'].	self startTableRow: align.	self isInTable</body><body package="WikiWorks">processPound	| currentLevel |	self atLineStart ifFalse: [^self addCurrentChar].	self inNumbers ifTrue: [self closeListItem].	currentLevel := 1.	[contentStream peekFor: $#] whileTrue: [currentLevel := currentLevel + 1].	numberLevel - currentLevel timesRepeat: [self closeNumberList].	currentLevel - numberLevel timesRepeat: [self startNumberList].	self startListItem.	numberLevel := currentLevel</body><body package="WikiWorks">processSpace	self atLineStart ifFalse: [^self space].	self getNextChar.	lastChar := Character cr.	self processCurrentChar</body><body package="WikiWorks">processTilde	self atLineStart ifTrue: [self paragraph] ifFalse: [self addCurrentChar]</body></methods><methods><class-id>WikiWorks.WikiPageRender</class-id> <category>private</category><body package="WikiWorks">buildContents	^self page contents</body></methods><methods><class-id>WikiWorks.WikiPageRender</class-id> <category>accessing</category><body package="WikiWorks">contentStream: aStream	contentStream := aStream</body><body package="WikiWorks">fileServerURL: aWiki 	aWiki fileServer URLon: replyStream.	self ,= $/.	^''</body><body package="WikiWorks">pageContents	| content |	self resetParsingStates.	content := self buildContents.	self != '&lt;!-- unformatted page contents --'.	self != content.	self != '//-- unformatted page contents --&gt;'.	contentStream := content readStream.	[contentStream atEnd] whileFalse: 			[self getNextChar.			self processCurrentChar].	lastChar := currentChar := Character cr.	self processCurrentChar.	^''</body></methods><methods><class-id>WikiWorks.PreviewRender</class-id> <category>testing</category><body package="WikiWorks">isOriginalPage	^page versionNumber &lt;= 1</body><body package="WikiWorks">isPreviewPage	^true</body></methods><methods><class-id>WikiWorks.PreviewRender</class-id> <category>initialize-release</category><body package="WikiWorks">request: aRequest in: aRequestHandler 	super request: aRequest in: aRequestHandler.	page := page newContents: (aRequest postDataAt: #NEWCONTENTS)				by: aRequest peerName</body></methods><methods><class-id>WikiWorks.CompositeWiki</class-id> <category>interaction</category><body package="WikiWorks">responseKeyFor: aRequest 	| mightNotBeTheRightPlace key |	mightNotBeTheRightPlace := aRequest identifier size &gt;= self depth.	mightNotBeTheRightPlace 		ifTrue: [key := aRequest identifier at: self depth]		ifFalse: 			[^aRequest postDataAt: #COMMAND				ifAbsent: [aRequest postDataAt: #DEFAULT_COMMAND ifAbsent: [self rootKey]]].	(self wikiActionKeys contains: [:each | key sameAs: each]) 		ifTrue: [aRequest decodeUrlencodedFormData: aRequest lastIdentifier].	^key</body></methods><methods><class-id>WikiWorks.CompositeWiki</class-id> <category>keys</category><body package="WikiWorks">wikiActionKeys	^Set 		with: self class recentChangesKey		with: self class pageListKey		with: self class searchKey		with: self class robotsKey</body></methods><methods><class-id>WikiWorks.CompositeWiki class</class-id> <category>defaults</category><body package="WikiWorks">defaultPagelistHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: Pages&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;%request hasFileserver 	ifTrue: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/UPLOAD" &gt;Upload&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/DOWNLOAD/" &gt;Download&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H2 &gt; There are &lt;?request numberOfPages printString?&gt; pages in &lt;?request handlerName?&gt;&lt;/H2&gt;&lt;HR &gt;&lt;%request pageList.%&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;%request hasFileserver 	ifTrue: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/UPLOAD" &gt;Upload&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/DOWNLOAD/" &gt;Download&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: self summarizer</body><body package="WikiWorks">defaultRecentChangestHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: Recent Changes&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;%request hasFileserver 	ifTrue: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/UPLOAD" &gt;Upload&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/DOWNLOAD/" &gt;Download&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H2 &gt;&lt;FONT face="Arial" &gt;Recent Changes&lt;/FONT&gt;&lt;/H2&gt;&lt;%request recentChanges.%&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;%request hasFileserver 	ifTrue: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/UPLOAD" &gt;Upload&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/DOWNLOAD/" &gt;Download&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: self summarizer</body><body package="WikiWorks">defaultRobotsHandler        ^'&lt;%%&gt;User-agent: *&lt;%(request handler class selectorsFor: #keys)        do: [:eachSelector | %&gt;Disallow: /&lt;?(request handler class perform: eachSelector) encodedHTTP?&gt;/&lt;%   ].request components        do:        [:eachWiki | (eachWiki class selectorsFor: #keys)                do: [:eachSelector | %&gt;Disallow: &lt;%eachWiki URLon: output.%&gt;/&lt;?(eachWiki class perform: eachSelector) encodedHTTP?&gt;/&lt;%           ]        ].%&gt;'                        asHttpRequestHandler: HtmlRender</body><body package="WikiWorks">defaultSearchHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: Search results for "&lt;?request searchString?&gt;"&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;%request hasFileserver 	ifTrue: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/UPLOAD" &gt;Upload&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/DOWNLOAD/" &gt;Download&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;%request references.%&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;%request hasFileserver 	ifTrue: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/UPLOAD" &gt;Upload&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/DOWNLOAD/" &gt;Download&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: self summarizer</body></methods><methods><class-id>WikiWorks.CompositeWiki class</class-id> <category>defaults-components</category><body package="WikiWorks">searchCommand	^super searchCommand 		, '&lt;HR &gt;&lt;INPUT type="HIDDEN" name="DEFAULT_COMMAND" value="SEARCH" &gt;&lt;INPUT type="SUBMIT" name="COMMAND" value="Recent Changes" &gt;&lt;INPUT type="SUBMIT" name="COMMAND" value="Pages" &gt;&lt;INPUT type="SUBMIT" name="COMMAND" value="Search" &gt;&lt;INPUT type="TEXT" name="SEARCHPATTERN" value="" size="40" &gt;&lt;/FORM&gt;'</body></methods><methods><class-id>WikiWorks.CompositeWiki class</class-id> <category>renders</category><body package="WikiWorks">reviewer	^WikiRender</body><body package="WikiWorks">summarizer	^CompositeWikiRender</body></methods><methods><class-id>WikiWorks.CompositeWiki class</class-id> <category>keys</category><body package="WikiWorks">pageListKey	^'PAGES'</body><body package="WikiWorks">recentChangesKey	^'RECENT CHANGES'</body><body package="WikiWorks">robotsKey        ^'ROBOTS.TXT'</body><body package="WikiWorks">searchKey	^'SEARCH'</body></methods><methods><class-id>WikiWorks.CompositeWiki class</class-id> <category>class initialization</category><body package="WikiWorks">initialize        "CompositeWiki initialize."        super initialize.        defaultHandlers at: self pageListKey put: self defaultPagelistHandler.        defaultHandlers at: self recentChangesKey                put: self defaultRecentChangestHandler.        defaultHandlers at: self searchKey put: self defaultSearchHandler.        defaultHandlers at: self robotsKey put: self defaultRobotsHandler</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>accessing</category><body package="WikiWorks">allowRevert	"^a BooleanI return true if reverts are permitted at all, otherwise false.  Even when on, reverts should be protected by a password since they are the only way to actually remove information (history) from the wiki, which is normaly something one would never wish to do, but with wiki spam these days is sadly sometimes needed."	allowRevert isNil ifTrue: [allowRevert := false].	^allowRevert</body><body package="WikiWorks">allowRevert: aBoolean 	"^selfc.f. &gt;&gt;allowRevert"	allowRevert := aBoolean.	^self</body><body package="WikiWorks">currentTitleOf: aString 	(self wikiActionKeys contains: [:each | aString sameAs: each]) 		ifTrue: [^aString].	^(self pageTitled: aString) title</body><body package="WikiWorks">fileDirectory	^directory construct: 'ATTACHMENT'</body><body package="WikiWorks">fileServer	^self componentNamed: self class downloadKey</body><body package="WikiWorks">formattingPageTitle: aString 	| formattingPage |	formattingPageTitle 		notNil: [pages removeKey: formattingPageTitle asUppercase].	formattingPageTitle := aString.	(self hasPageTitled: aString) ifTrue: [^self].	formattingPage := OriginalWikiPage new.	formattingPage title: formattingPageTitle.	formattingPage := formattingPage newContents: self defaultFormattingPage				by: formattingPage author.	self addPage: formattingPage</body><body package="WikiWorks">name	super name ifNil: [self name: 'Wiki'].	^super name</body><body package="WikiWorks">replaceUploadedFiles	^replaceUploadedFiles isNil		ifTrue: [replaceUploadedFiles := false]		ifFalse: [replaceUploadedFiles]</body><body package="WikiWorks">replaceUploadedFiles: anObject	replaceUploadedFiles := anObject</body><body package="WikiWorks">rootPageTitle	^self rootPage title</body><body package="WikiWorks">rootPageTitle: aString 	| rootPage |	rootPageTitle notNil: [pages removeKey: rootPageTitle asUppercase].	rootPageTitle := aString.	(self hasPageTitled: aString) ifTrue: [^self].	rootPage := OriginalWikiPage new.	rootPage title: rootPageTitle.	self addPage: rootPage</body><body package="WikiWorks">startDate	^(self rootPage versionAt: 0) timestamp asDate</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>keys</category><body package="WikiWorks">pageActionKeys	^Set 		with: self class editKey		with: self class renameKey		with: self class historyKey</body><body package="WikiWorks">wikiActionKeys	| actions |	actions := super wikiActionKeys.	actions add: self class uploadKey.	actions add: self class downloadKey.	^actions</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>pages</category><body package="WikiWorks">addPage: aPage 	aPage allTitles do: [:each | pages at: each asUppercase put: aPage].	^aPage</body><body package="WikiWorks">changesFor: aDate 	| sc |	sc := SortedCollection new sortBlock: [:a :b | a timestamp &gt; b timestamp].	self 		pagesDo: [:each | each timestamp asDate = aDate ifTrue: [sc add: each]].	^sc</body><body package="WikiWorks">formattingPage	formattingPageTitle ifNil: [self formattingPageTitle: 'Wiki Syntax'].	^self pageTitled: formattingPageTitle</body><body package="WikiWorks">hasPageTitled: aString 	^(self wikiActionKeys contains: [:each | aString sameAs: each]) 		or: [pages includesKey: aString asUppercase]</body><body package="WikiWorks">pageTitled: aString 	^self pageTitled: aString ifAbsent: []</body><body package="WikiWorks">pageTitled: aString ifAbsent: aBlock 	^pages at: aString asUppercase ifAbsent: aBlock</body><body package="WikiWorks">pages	^pages values asSet</body><body package="WikiWorks">pagesDo: aBlock 	"when enumerating the pages dictionary, we want to filter 	to only those entries whose titles are current, this avoids 	double enumerating a page that might have two or more 	titles in it's history"	self pages do: [:each | aBlock value: each]</body><body package="WikiWorks">referencesFor: aString 	| matchString referringPages |	referringPages := SortedCollection sortBlock: [:a :b | a title &lt; b title].	matchString := aString.	matchString isEmpty ifFalse: [matchString := '*' , matchString , '*'].	self 		pagesDo: [:each | (each references: matchString) ifTrue: [referringPages add: each]].	^referringPages</body><body package="WikiWorks">rootPage	rootPageTitle ifNil: [self rootPageTitle: 'Home Page'].	^self pageTitled: rootPageTitle</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>interaction</category><body package="WikiWorks">responseKeyFor: aRequest 	| key |	aRequest identifier size = (self depth - 1) 		ifTrue: [aRequest identifier add: self rootPageTitle].	aRequest isPost 		ifTrue: [(key := self responseKeyForPost: aRequest) notNil: [^key]].	(key := self responseKeyForWikiAction: aRequest) notNil: [^key].	aRequest isGet ifTrue: [key := self responseKeyForGet: aRequest].	key ifNil: [^self rootKey].	(self hasPageTitled: aRequest lastIdentifier) ifTrue: [^key].	^key = self class editKey ifTrue: [key] ifFalse: [self class absentPageKey]</body><body package="WikiWorks">responseKeyForEdit: aRequest 	| oldPage newPage key newContent |	key := aRequest postDataAt: #EDIT_COMMAND				ifAbsent: [^self class abortedEditKey].	(key sameAs: self class abortedEditKey) 		ifTrue: [^self class abortedEditKey].	(key sameAs: self class previewKey) ifTrue: [^self class previewKey].	oldPage := self pageTitled: aRequest lastIdentifier				ifAbsent: 					[| page |					page := OriginalWikiPage new.					page author: aRequest peerName.					page title: aRequest lastIdentifier.					page].	newContent := aRequest postDataAt: #NEWCONTENTS.	newPage := oldPage newContents: newContent by: aRequest peerName.	(self isLockedPage: newPage forRequest: aRequest) 		ifTrue: [^self class pageKey].	((self checkBadIPList: aRequest peerName) 		or: [self checkForSpam: newContent forNewPage: newPage]) 			ifTrue: 				[self saveOff: newPage.				Transcript cr.				Transcript					show: 'Spam from: ' , aRequest peerName;					cr.				^self class pageKey].	newPage == oldPage ifFalse: [self addPage: newPage].	^self class pageKey</body><body package="WikiWorks">responseKeyForGet: aRequest 	| key |	aRequest identifier size = self depth ifTrue: [^self class pageKey].	key := aRequest identifier at: self depth.	aRequest identifier size = (self depth + 1) 		ifTrue: [self pageActionKeys do: [:each | (key sameAs: each) ifTrue: [^each]]].	aRequest identifier size = (self depth + 2) 		ifTrue: 			[(key sameAs: self class versionKey) ifTrue: [^self class versionKey].			(key sameAs: 'PROMOTE') 				ifTrue: [^self responseKeyForPromote: aRequest]				ifFalse: 					[(key sameAs: 'REVERT') ifTrue: [^self responseKeyForRevert: aRequest]]].	aRequest identifier size = (self depth + 3) 		ifTrue: 			[(key sameAs: self class differenceKey) ifTrue: [^self class differenceKey]].	^nil</body><body package="WikiWorks">responseKeyForPost: aRequest 	| key |	aRequest identifier size = self depth ifFalse: [^nil].	key := aRequest postDataAt: #COMMAND ifAbsent: [^nil].	(key sameAs: self class searchKey) ifTrue: [^self class searchKey].	(key sameAs: self class editKey) 		ifTrue: [^self responseKeyForEdit: aRequest].	(key sameAs: self class renameKey) 		ifTrue: [^self responseKeyForRename: aRequest].	(key sameAs: self class uploadKey) 		ifTrue: [^self responseKeyForUpload: aRequest].	^key</body><body package="WikiWorks">responseKeyForPromote: aRequest 	| oldPage newPage |	oldPage := self pageTitled: aRequest lastIdentifier				ifAbsent: [^self class absentPageKey].	newPage := oldPage 				promoteVersion: (aRequest identifier at: self depth + 1) asNumber				by: aRequest peerName.	newPage == oldPage ifFalse: [self addPage: newPage].	^self class pageKey</body><body package="WikiWorks">responseKeyForRename: aRequest 	| currentPage newTitle newPage |	currentPage := self pageTitled: aRequest lastIdentifier				ifAbsent: [^self class absentPageKey].	newTitle := aRequest postDataAt: #NEWTITLE ifAbsent: [currentPage title].	((self hasPageTitled: newTitle) 		and: [(self pageTitled: newTitle) ~~ currentPage]) 			ifTrue: [^self class renameConflictKey].	newPage := currentPage changeTitle: newTitle by: aRequest peerName.	newPage == currentPage ifFalse: [self addPage: newPage].	^self class pageKey</body><body package="WikiWorks">responseKeyForRevert: aRequest 	"^a StringThe aim here is to make the latest version of the page a PageReversion and to delete every version that post dates the selected version.  Brutal, but needed to combat spam."	| currentSubjectPageVersion revertToPageVersion targetVersionNumber redundantPageVersions namesStillInUse |	self allowRevert 		ifTrue: 			[targetVersionNumber := (aRequest identifier at: self depth + 1) asNumber.			currentSubjectPageVersion := self pageTitled: aRequest lastIdentifier						ifAbsent: [^self class absentPageKey].			revertToPageVersion := currentSubjectPageVersion 						revertToVersion: targetVersionNumber						by: aRequest peerName.			redundantPageVersions := currentSubjectPageVersion allVersions 						select: [:aVersion | aVersion versionNumber &gt; targetVersionNumber].			namesStillInUse := revertToPageVersion allTitles 						collect: [:aName | aName asUppercase asSymbol].			redundantPageVersions do: 					[:aPageVersion | 					| pageId filename |					pageId := self idForPage: aPageVersion.					filename := directory construct: pageId printString , '.pag'.					self idMap removeKey: aPageVersion.					aPageVersion isRenamed 						ifTrue: 							[| uppercaseNameSymbol |							uppercaseNameSymbol := aPageVersion title asUppercase asSymbol.							(namesStillInUse includes: uppercaseNameSymbol) not 								ifTrue: [pages removeKey: uppercaseNameSymbol asString ifAbsent: []]].					filename delete].			revertToPageVersion == currentSubjectPageVersion 				ifFalse: [self addPage: revertToPageVersion]].	^self class pageKey</body><body package="WikiWorks">responseKeyForUpload: aRequest 	| files |	files := aRequest postDataAt: #FILES.	files ifNil: [^self class uploadKey].	files keysAndValuesDo: 			[:filename :contents | 			| dir ws file |			filename isValidFilename ifFalse: [^self class uploadKey]. 			dir := self fileDirectory 						construct: (aRequest postDataAt: #SUBDIR ifAbsent: ['.']) makeFilename.			dir ensureDirectory.			file := dir construct: filename.			file definitelyExists 				ifTrue: [self replaceUploadedFiles ifFalse: [^self class uploadKey].						ws := file newReadWriteStream]				ifFalse: [ws := file newReadAppendStream].						[ws lineEndTransparent.			ws nextPutAll: contents] ensure: [ws close]].	^self class uploadKey</body><body package="WikiWorks">responseKeyForWikiAction: aRequest 	| key |	key := aRequest identifier at: self depth.	self wikiActionKeys do: [:each | (key sameAs: each) ifTrue: [^each]].	key := aRequest lastIdentifier.	self wikiActionKeys do: [:each | (key sameAs: each) ifTrue: [^each]].	^nil</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>testing</category><body package="WikiWorks">hasFilenamed: aString 	^[(self fileDirectory construct: aString) definitelyExists] 		on: OsInvalidArgumentsError		do: [:ex | false]</body><body package="WikiWorks">hasFileserver	^true</body><body package="WikiWorks">occurancesOf: aString inNewContentFrom: aRequest 	"^a BooleanI return the number of occurances of aString in the new wiki page content presumed to be in aRequest."	| stream count testContent newContent |	newContent := aRequest postDataAt: #NEWCONTENTS.	testContent := (TestPageRender request: aRequest in: self) 				getResultingContentFrom: newContent.	stream := testContent asLowercase readStream.	count := 0.	[stream atEnd] whileFalse: 			[stream throughAll: aString.			stream atEnd ifFalse: [count := count + 1]].	^count</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>defaults</category><body package="WikiWorks">defaultFormattingPage	^'The Wiki''s a place where anybody can edit anything. To do so just follow the &lt;U&gt;Edit this page&lt;/U&gt; link at the top or bottom of a page. The formatting rules are pretty simple:* Links are created by placing square brackets around the link name (e.g. [[aPageName]). If you need to create a [[ character, use two of them (e.g. "[[[["). You don''t need to double up the ] character unless you actually want to use it as part of the link name.* If you want to create a link to an "outside" source, just include the full internet protocol name (e.g. [[http://www.somesite.com] or [[mailto:someone@somewhere.com] or [[ftp://somesite.ftp]).* If you want a link (either internal or outside) by another name, then place both the desired name and the actual link target as a pair separated by &gt; character (e.g. [[The Top &gt; Home Page] or [[me &gt; mailto:myname@myplace.com]).* Carriage returns create a new paragraph* Use any HTML you want. The Wiki formatting rules will not be applied between a PRE tag.* To create a horizontal line, start a line with ''----''.* To create a bullet list item, start a line with a * character.* To create a numbered list item, start a line with a # character.* To create a heading, start a line with a ! character.* To create a table, start the line with two | (vertical bar) characters. For each cell in the row, separate again by two | characters. Successive lines that start with the two | characters are made into the same table.'</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>initialize-release</category><body package="WikiWorks">initialize	super initialize.	pages := Dictionary new</body><body package="WikiWorks">postInitialize	super postInitialize.	self fileDirectory ensureDirectory.	self addComponent: (FileServerWiki named: self class downloadKey				directory: self fileDirectory)</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>private-spam</category><body package="WikiWorks">checkBadIPList: ip 	"check against bad IP list"	^BadTextHolder current isFromBadIP: ip</body><body package="WikiWorks">checkForSpam: newContent forNewPage: newPage 	"If there are 'too many' links, kill it"	^BadTextHolder current hasBadText: newContent</body><body package="WikiWorks">isLockedPage: aPage forRequest: aRequest	"^a BooleanI return true and log a message to the transcript if the title of aPage is listed in the image-wide locked pages collection."	| pageTitleIsLocked |	pageTitleIsLocked := LockedPageHolder isLocked: aPage.	pageTitleIsLocked 		ifTrue: 			[Transcript				show: '&lt;&lt; ' , Timestamp now printString , ' &gt;&gt;';				cr.			Transcript				show: '&lt;&lt; Edit Attempt from: ' , aRequest peerName , ' &gt;&gt;';				cr.			Transcript				show: '&lt;&lt; Page: ' , aPage title , ' is locked &gt;&gt;';				cr].	^pageTitleIsLocked</body><body package="WikiWorks">saveOff: aPage 	| dir file filename stream |	dir := 'spam' asFilename.	dir exists ifFalse: [^self].	file := 'spam_' , Timestamp now asSeconds printString , '.txt'.	filename := dir construct: file.		[stream := filename writeStream.	aPage printOn: stream] 			ensure: [stream close].	^self</body><body package="WikiWorks">spamDetectedIn: aRequest 	"^a BooleanI return true if I find spam in the #NEWCONTENTS of aRequest, otherwise false.  In essence: if there are 'too many' links, kill it."	"Being hammered by spammers now, so we may as well treat everything as if it's spam :-("	^true</body></methods><methods><class-id>WikiWorks.Wiki class</class-id> <category>defaults</category><body package="WikiWorks">defaultAbortedEditHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: &lt;?request pageTitle?&gt;&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H3 &gt;&lt;FONT face="Arial" &gt; Your edit has been aborted for: &lt;%	request isOriginalPage 		ifTrue: [%&gt;&lt;?request pageTitle?&gt;&lt;%]		ifFalse: 			[%&gt;&lt;A href="&lt;%request handlerURL.%&gt;/&lt;?request pageURL?&gt;" &gt;&lt;?request pageTitle?&gt;&lt;/A&gt;&lt;%].%&gt;&lt;/FONT&gt;&lt;/H3&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: self reviewer</body><body package="WikiWorks">defaultAbsentPageHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: &lt;?request pageTitle?&gt;&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H3 &gt;&lt;FONT face="Arial" &gt; &lt;?request handlerName?&gt; contains no page titled: "&lt;?request pageTitle?&gt;"&lt;/FONT&gt;&lt;/H3&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: self reviewer</body><body package="WikiWorks">defaultDifferenceHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: &lt;?request pageTitle?&gt;&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;%request pageVersion &lt;= 1 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/DIFF/&lt;?request pageVersionString?&gt;/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Changes&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/&lt;?request pageURL?&gt;" &gt;Latest&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/HISTORY/&lt;?request pageURL?&gt;" &gt;History&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;&lt;?request homePageSpecial?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H2 &gt;&lt;FONT face="Arial" &gt;&lt;?request pageTitle?&gt; (Differences between version &lt;A href="&lt;%request handlerURL.%&gt;/VERSION/&lt;?request newVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;&lt;?request newVersionString?&gt;&lt;/A&gt; and &lt;A href="&lt;%request handlerURL.%&gt;/VERSION/&lt;?request oldVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;&lt;?request oldVersionString?&gt;&lt;/A&gt;)&lt;/FONT&gt;&lt;/H2&gt;&lt;%request pageContents.%&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;%request pageVersion &lt;= 1 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/DIFF/&lt;?request pageVersionString?&gt;/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Changes&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/&lt;?request pageURL?&gt;" &gt;Latest&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/HISTORY/&lt;?request pageURL?&gt;" &gt;History&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;&lt;?request homePageSpecial?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: DifferenceRender</body><body package="WikiWorks">defaultEditHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;Edit: &lt;?request handlerName?&gt; - &lt;?request pageTitle?&gt;&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/RENAME/&lt;?request pageURL?&gt;" &gt;Rename&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%request pageVersion &lt;= 1 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/DIFF/&lt;?request pageVersionString?&gt;/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Changes&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/HISTORY/&lt;?request pageURL?&gt;" &gt;History&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;&lt;?request homePageSpecial?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H2 &gt;&lt;FONT face="Arial" &gt; &lt;%request isOriginalPage ifTrue: [%&gt;Creating: &lt;%] ifFalse: [%&gt;Editing: &lt;%].%&gt;&lt;?request pageTitle?&gt;&lt;/FONT&gt;&lt;/H2&gt;&lt;%request isPreviewPage 	ifTrue: [%&gt;&lt;HR &gt;&lt;CENTER &gt;Preview&lt;/CENTER&gt;&lt;P &gt;&lt;%request pageContents.%&gt;&lt;HR &gt;&lt;%].%&gt;Don''t know how to edit a page? Visit &lt;%request formattingPageURL.%&gt;&lt;/A&gt;.&lt;FORM action="&lt;%request handlerURL.%&gt;/&lt;?request pageURL?&gt;" method="POST" &gt;&lt;INPUT type="HIDDEN" name="COMMAND" value="EDIT" &gt;&lt;P &gt;&lt;TEXTAREA name="NEWCONTENTS" wrap="VIRTUAL" cols="80" rows="20" &gt;&lt;?request page contents encodedHTML?&gt;&lt;/TEXTAREA&gt;&lt;/P&gt;&lt;P &gt;&lt;INPUT type="SUBMIT" name="EDIT_COMMAND" value="Save" &gt;&lt;INPUT type="SUBMIT" name="EDIT_COMMAND" value="Preview" &gt;&lt;INPUT type="SUBMIT" name="EDIT_COMMAND" value="Abort" &gt;&lt;/P&gt;&lt;/FORM&gt;&lt;HR &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/RENAME/&lt;?request pageURL?&gt;" &gt;Rename&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%request pageVersion &lt;= 1 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/DIFF/&lt;?request pageVersionString?&gt;/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Changes&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/HISTORY/&lt;?request pageURL?&gt;" &gt;History&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;&lt;?request homePageSpecial?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 		asHttpRequestHandler: self reviewer</body><body package="WikiWorks">defaultHistoryHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;History of: &lt;?request handlerName?&gt; - &lt;?request pageTitle?&gt;&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/EDIT/&lt;?request pageURL?&gt;" &gt;Edit&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/RENAME/&lt;?request pageURL?&gt;" &gt;Rename&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;&lt;?request homePageSpecial?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H2 &gt;&lt;FONT face="Arial" &gt; History of: &lt;?request pageTitle?&gt;&lt;/FONT&gt;&lt;/H2&gt;&lt;TABLE width="95%" border="1" &gt;&lt;TR &gt;&lt;TD &gt;&lt;STRONG &gt;Version&lt;/STRONG&gt;&lt;/TD&gt;&lt;TD &gt;&lt;STRONG &gt;Type&lt;/STRONG&gt;&lt;/TD&gt;&lt;TD &gt;&lt;STRONG &gt;Author&lt;/STRONG&gt;&lt;/TD&gt;&lt;TD &gt;&lt;STRONG &gt;Creation Time&lt;/STRONG&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;%request page versionsDo: [:each | %&gt;&lt;TR &gt;&lt;TD &gt;&lt;A href="&lt;%request handlerURL.%&gt;/VERSION/&lt;?each versionNumber printString?&gt;/&lt;?request pageURL?&gt;" &gt;&lt;?each versionNumber printString?&gt;&lt;/TD&gt;&lt;TD &gt;&lt;?each tabularHistoricalSynopsis?&gt;&lt;/TD&gt;&lt;TD &gt;&lt;?each author?&gt;&amp;nbsp;&lt;/TD&gt;&lt;TD &gt;&lt;%TimestampPrintPolicy print: each timestamp on: output using: ''yyyy/mm/dd hh:mm:ss''.%&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;%].%&gt;&lt;/TABLE&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/EDIT/&lt;?request pageURL?&gt;" &gt;Edit&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/RENAME/&lt;?request pageURL?&gt;" &gt;Rename&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;&lt;?request homePageSpecial?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: self reviewer</body><body package="WikiWorks">defaultPageHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: &lt;?request pageTitle?&gt;&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/EDIT/&lt;?request pageURL?&gt;" &gt;Edit&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/RENAME/&lt;?request pageURL?&gt;" &gt;Rename&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%request pageVersion &lt;= 1 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/DIFF/&lt;?request pageVersionString?&gt;/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Changes&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/HISTORY/&lt;?request pageURL?&gt;" &gt;History&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/UPLOAD" &gt;Upload&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/DOWNLOAD/" &gt;Download&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;&lt;?request homePageSpecial?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H2 &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/SEARCH/&lt;?request pageURL?&gt;" &gt;&lt;?request pageTitle?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/H2&gt;&lt;%request pageContents.%&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/EDIT/&lt;?request pageURL?&gt;" &gt;Edit&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/RENAME/&lt;?request pageURL?&gt;" &gt;Rename&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%request pageVersion &lt;= 1 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/DIFF/&lt;?request pageVersionString?&gt;/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Changes&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/HISTORY/&lt;?request pageURL?&gt;" &gt;History&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/UPLOAD" &gt;Upload&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/DOWNLOAD/" &gt;Download&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;&lt;?request homePageSpecial?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: WikiPageRender</body><body package="WikiWorks">defaultRenameConflictHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: Pages&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H2 &gt;This name (&lt;A href="&lt;%request handlerURL.%&gt;/&lt;?request pageURL?&gt;" &gt;&lt;?request pageTitle?&gt;&lt;/A&gt;) is in use already. Sorry, cannot complete this rename. &lt;/H2&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: self reviewer</body><body package="WikiWorks">defaultRenameHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;Rename: &lt;?request handlerName?&gt; - &lt;?request pageTitle?&gt;&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/EDIT/&lt;?request pageURL?&gt;" &gt;Edit&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%request pageVersion &lt;= 1 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/DIFF/&lt;?request pageVersionString?&gt;/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Changes&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/HISTORY/&lt;?request pageURL?&gt;" &gt;History&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;&lt;?request homePageSpecial?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H3 &gt;&lt;FONT face="Arial" &gt; Type a new name for: &lt;?request pageTitle?&gt; and Save.&lt;/FONT&gt;&lt;/H3&gt;&lt;FORM action="&lt;%request handlerURL.%&gt;/&lt;?request pageURL?&gt;" method="POST" &gt;&lt;INPUT type="HIDDEN" name="COMMAND" value="RENAME" &gt;&lt;INPUT type="TEXT" name="NEWTITLE" size=60 value="&lt;?request pageTitle encodedHTML?&gt;" &gt;&lt;INPUT type="submit" value="Save" &gt;&lt;/FORM&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/EDIT/&lt;?request pageURL?&gt;" &gt;Edit&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%request pageVersion &lt;= 1 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/DIFF/&lt;?request pageVersionString?&gt;/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Changes&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/HISTORY/&lt;?request pageURL?&gt;" &gt;History&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;&lt;?request homePageSpecial?&gt;&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: self reviewer</body><body package="WikiWorks">defaultRootHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: Pages&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;The &lt;?request handlerName?&gt; wiki is not able to process this request&lt;BR &gt;originator: &lt;?request request peerName?&gt;&lt;BR &gt;action: &lt;?request request command?&gt;&lt;BR &gt;identifier: &lt;%request request identifier do: [:each | %&gt;/&lt;?each?&gt;&lt;%].request request postDataDo: [:key :value | %&gt;&lt;BR &gt;&lt;?key?&gt; = &lt;%value sendOver: output].%&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: self reviewer</body><body package="WikiWorks">defaultUploadHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: Upload&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H3 &gt;&lt;FONT face="Arial" &gt; Choose a file for: &lt;?request handlerName?&gt; and Upload.&lt;/FONT&gt;&lt;/H3&gt;&lt;FORM action="&lt;%request handlerURL.%&gt;/UPLOAD" method="POST" enctype="multipart/form-data" &gt;&lt;INPUT type="HIDDEN" name="COMMAND" value="UPLOAD" &gt;&lt;TABLE cellpadding="2" &gt;&lt;TR &gt;&lt;TD &gt;Upload file:&lt;/TD&gt;&lt;TD &gt;&lt;INPUT type="FILE" name="FILES" size="50" &gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR &gt;&lt;TD &gt;To subdirectory:&lt;/TD&gt;&lt;TD &gt;&lt;INPUT type="TEXT" name="SUBDIR" size="50" &gt;&lt;INPUT type="SUBMIT" value="Upload Now!" &gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FORM&gt;&lt;HR &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt; "&gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 		asHttpRequestHandler: HtmlRender</body><body package="WikiWorks">defaultVersionHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;: &lt;?request pageTitle?&gt; (Version &lt;?request pageVersion printString?&gt;)&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;%request pageVersion &lt;= 1 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/DIFF/&lt;?request pageVersionString?&gt;/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Changes&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/VERSION/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Previous&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].request isLatestPage 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/VERSION/&lt;?(request pageVersion + 1) printString?&gt;/&lt;?request pageURL?&gt;" &gt;Next&lt;/A&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/&lt;?request pageURL?&gt;" &gt;Latest&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/HISTORY/&lt;?request pageURL?&gt;" &gt;History&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;" &gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;H3 &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/SEARCH/&lt;?request pageURL?&gt;" &gt;&lt;?request pageTitle?&gt; (Version &lt;?request pageVersion printString?&gt;)&lt;/A&gt;&lt;/FONT&gt;&lt;/H3&gt;&lt;?request pageContents?&gt;&lt;HR &gt;' 		, self searchCommand 			, '&lt;TABLE width="100%" cellpadding="0" cellspacing="2" bgcolor="#FFFFC0" &gt;&lt;TR &gt;&lt;%request pageVersion &lt;= 1 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/DIFF/&lt;?request pageVersionString?&gt;/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Changes&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/VERSION/&lt;?request previousVersionString?&gt;/&lt;?request pageURL?&gt;" &gt;Previous&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;%		].request isLatestPage 	ifFalse: 		[%&gt;&lt;TD &gt;&lt;A HREF="&lt;%request handlerURL.%&gt;/VERSION/&lt;?(request pageVersion + 1) printString?&gt;/&lt;?request pageURL?&gt;" &gt;Next&lt;/A&gt;&lt;/TD&gt;&lt;%		].%&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/&lt;?request pageURL?&gt;" &gt;Latest&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;/HISTORY/&lt;?request pageURL?&gt;" &gt;History&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;TD &gt;&lt;FONT face="Arial" &gt;&lt;A href="&lt;%request handlerURL.%&gt;" &gt;Back to Top&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 			asHttpRequestHandler: VersionRender</body></methods><methods><class-id>WikiWorks.Wiki class</class-id> <category>keys</category><body package="WikiWorks">abortedEditKey	^'ABORT'</body><body package="WikiWorks">absentPageKey	^'ABSENT PAGE'</body><body package="WikiWorks">differenceKey	^'DIFF'</body><body package="WikiWorks">downloadKey	^'DOWNLOAD'</body><body package="WikiWorks">editKey	^'EDIT'</body><body package="WikiWorks">historyKey	^'HISTORY'</body><body package="WikiWorks">pageKey	^'PAGE'</body><body package="WikiWorks">previewKey	^'PREVIEW'</body><body package="WikiWorks">renameConflictKey	^'RENAME CONFLICT'</body><body package="WikiWorks">renameKey	^'RENAME'</body><body package="WikiWorks">uploadKey	^'UPLOAD'</body><body package="WikiWorks">versionKey	^'VERSION'</body></methods><methods><class-id>WikiWorks.Wiki class</class-id> <category>renders</category><body package="WikiWorks">reviewer	^PageRender</body><body package="WikiWorks">summarizer	^super reviewer</body></methods><methods><class-id>WikiWorks.Wiki class</class-id> <category>defaults-components</category><body package="WikiWorks">searchCommand	^'&lt;FORM action="&lt;%request handlerURL.%&gt;/SEARCH" method="POST" &gt;&lt;INPUT type="HIDDEN" name="COMMAND" value="SEARCH" &gt;&lt;INPUT type="SUBMIT" value="Find..." &gt;&lt;INPUT type="TEXT" name="SEARCHPATTERN" value="" size="40" &gt;&lt;/FORM&gt;'</body></methods><methods><class-id>WikiWorks.Wiki class</class-id> <category>configuration</category><body package="WikiWorks">configurationSectionName	^'wiki'</body></methods><methods><class-id>WikiWorks.Wiki class</class-id> <category>class initialization</category><body package="WikiWorks">initialize	"Wiki initialize."	super initialize.	defaultHandlers at: self abortedEditKey put: self defaultAbortedEditHandler.	defaultHandlers at: self absentPageKey put: self defaultAbsentPageHandler.	defaultHandlers at: self differenceKey put: self defaultDifferenceHandler.	defaultHandlers at: self editKey put: self defaultEditHandler.	defaultHandlers at: self previewKey		put: ((defaultHandlers at: self editKey) copy renderClass: PreviewRender).	defaultHandlers at: self historyKey put: self defaultHistoryHandler.	defaultHandlers at: self pageKey put: self defaultPageHandler.	defaultHandlers at: self renameKey put: self defaultRenameHandler.	defaultHandlers at: self renameConflictKey		put: self defaultRenameConflictHandler.	defaultHandlers at: self uploadKey put: self defaultUploadHandler.	defaultHandlers at: self versionKey put: self defaultVersionHandler</body></methods><methods><class-id>WikiWorks.PromotedWikiPage</class-id> <category>accessing</category><body package="WikiWorks">contents	^promotedVersion contents</body><body package="WikiWorks">promotedVersion	^promotedVersion</body><body package="WikiWorks">promotedVersion: aPage 	promotedVersion := aPage</body><body package="WikiWorks">tabularHistoricalSynopsis	^'Promoted from version ' , promotedVersion versionNumber printString</body><body package="WikiWorks">title	^promotedVersion title</body></methods><methods><class-id>WikiWorks.PromotedWikiPage</class-id> <category>testing</category><body package="WikiWorks">isPromoted	^true</body></methods><methods><class-id>WikiWorks.PromotedWikiPage</class-id> <category>flat file</category><body package="WikiWorks">saveToFile: aFileStream under: aWiki 	super saveToFile: aFileStream under: aWiki.	aFileStream print: (aWiki idForPage: self promotedVersion)</body><body package="WikiWorks">specificData: aPage 	self promotedVersion: aPage</body></methods><methods><class-id>WikiWorks.PromotedWikiPage</class-id> <category>recovery</category><body package="WikiWorks">readSpecificPageDataFrom: stream in: directory	| prevFilename |	prevFilename := self prevFilenameFrom: stream in: directory.	self specificData: stream upToEnd.	stream close.	^prevFilename</body></methods><methods><class-id>WikiWorks.DifferenceRender</class-id> <category>accessing</category><body package="WikiWorks">colorFor: aSymbol 	^aSymbol == #added ifTrue: ['green'] ifFalse: ['red']</body><body package="WikiWorks">newPage	^page versionAt: newVersion</body><body package="WikiWorks">newVersionString	^newVersion printString</body><body package="WikiWorks">oldPage	^page versionAt: oldVersion</body><body package="WikiWorks">oldVersionString	^oldVersion printString</body><body package="WikiWorks">pageVersion	^oldVersion</body><body package="WikiWorks">titleFor: aSymbol 	^aSymbol == #added ifTrue: ['+ '] ifFalse: ['- ']</body></methods><methods><class-id>WikiWorks.DifferenceRender</class-id> <category>testing</category><body package="WikiWorks">isLatestPage	^newVersion = page versionNumber</body></methods><methods><class-id>WikiWorks.DifferenceRender</class-id> <category>initialize-release</category><body package="WikiWorks">request: aRequest in: aRequestHandler 	super request: aRequest in: aRequestHandler.	newVersion := ((aRequest identifier at: handler depth + 1) asNumber max: 0) 				min: page versionNumber.	oldVersion := ((aRequest identifier at: handler depth + 2) asNumber max: 0) 				min: page versionNumber.	newVersion &lt; oldVersion 		ifTrue: 			[| version |			version := newVersion.			newVersion := oldVersion.			oldVersion := version]</body></methods><methods><class-id>WikiWorks.DifferenceRender</class-id> <category>private</category><body package="WikiWorks">buildContents	| diff ws |	diff := TokenDifference new.	ws := String new writeStream.	self oldPage isOriginal 		ifTrue: [diff old: OrderedCollection new]		ifFalse: [diff old: (self oldPage contents tokensBasedOn: Character cr)].	self newPage isOriginal 		ifTrue: [diff new: OrderedCollection new]		ifFalse: [diff new: (self newPage contents tokensBasedOn: Character cr)].	diff results do: [:assoc | self printDifference: assoc on: ws].	^ws contents</body><body package="WikiWorks">printDifference: assoc on: aStream 	| isSpecial |	assoc key = #same 		ifTrue: 			[aStream nextPutAll: assoc value.			aStream cr.			^self].	isSpecial := false.	assoc value isEmpty 		ifFalse: 			[isSpecial := '*#!' includes: assoc value first.			isSpecial ifTrue: [aStream nextPut: assoc value first]].	aStream		nextPutAll: '&lt;FONT color=';		nextPutAll: (self colorFor: assoc key);		nextPutAll: ' &gt;';		nextPutAll: (self titleFor: assoc key).	(assoc value isEmpty not and: [isSpecial not]) 		ifTrue: [aStream nextPut: assoc value first].	assoc value size &gt; 1 		ifTrue: [aStream nextPutAll: (assoc value copyFrom: 2)].	aStream nextPutAll: '&lt;/FONT&gt;'.	aStream cr</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>private-recover</category><body package="WikiWorks">readPageFrom: aReadStream into: aDictionary latests: aCollection 	| page prevFilenameOrNil className |	className := aReadStream nextLine asSymbol.	page := ((LiteralBindingReference simpleName: className) method: thisContext method) value new.	page author: aReadStream nextLine.	page timestamp: aReadStream nextLine asNumber.	prevFilenameOrNil := page readSpecificPageDataFrom: aReadStream in: directory.	prevFilenameOrNil isNil		ifTrue: [^page].	page previousVersion: (self			readPreviousPageFrom: prevFilenameOrNil		into: aDictionary		latests: aCollection).	page isPromoted		ifTrue: [ | promotedFromName |			promotedFromName := directory construct: (page promotedVersion, '.pag').			page specificData: (self				readPreviousPageFrom: promotedFromName				into: aDictionary				latests: aCollection)].	^page</body><body package="WikiWorks">readPageInFile: aFilename into: aDictionary latests: aCollection 	| index |	index := aFilename stem asNumber.	^aDictionary at: index		ifAbsentPut: 			[| rs page |			rs := (aFilename asFilename withEncoding: #UTF8) readStream lineEndAuto.			page := 					[self 						readPageFrom: rs						into: aDictionary						latests: aCollection] 							ensure: [rs close].			page ifNil: [self error: 'Failed read page']				notNil: [aCollection add: page]]</body><body package="WikiWorks">readPagesInto: pageMap latests: latests 	directory filesMatching: '*.pag'		do: 			[:fileName | 			self 				readPageInFile: fileName				into: pageMap				latests: latests].	pageMap keysAndValuesDo: 			[:index :page | 			idMap at: page put: index.			fileCounter := fileCounter max: index]</body><body package="WikiWorks">readPreviousPageFrom: aFilename into: aDictionary latests: aCollection 	| previous |	previous := self 				readPageInFile: aFilename				into: aDictionary				latests: aCollection.	aCollection remove: previous ifAbsent: [].	^previous</body><body package="WikiWorks">recoverFiles	| pageMap latests |	pageMap := IdentityDictionary new.	latests := OrderedCollection new.	self readPagesInto: pageMap latests: latests.	self checkHistories: pageMap latests: latests.	self checkTitles: pageMap latests: latests.	self cleanupLatests: latests.	latests do: [:page | super addPage: page]</body><body package="WikiWorks">recoverWikiFile	| rs aFilename |	aFilename := directory construct: 'wiki.cnf'.	aFilename definitelyExists ifFalse: [^self].	rs := aFilename readStream lineEndAuto.		[rs atEnd ifFalse: [name := rs nextLine].	rs atEnd ifFalse: [rootPageTitle := rs nextLine].	rs atEnd ifFalse: [formattingPageTitle := rs nextLine]] 			ensure: [rs close]</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>private-checking</category><body package="WikiWorks">checkDuplications: duplicationSet for: aDictionary and: aCollection match: matchBlock map: mapBlock error: errorString 	| map |	map := IdentityDictionary new.	duplicationSet do: 			[:each | 			| all |			all := IdentityDictionary new.			(aCollection 				collect: [:page | CollectionAdapter with: [:aBlock | page versionsDo: aBlock]]) 					do: 						[:page | 						page detect: (matchBlock value: each)							ifPresent: 								[:aPage | 								all at: page anyOne									put: (aDictionary select: (mapBlock value: each value: page))]].			all size &gt; 1 ifTrue: [map at: each put: all]].	map size = 0 ifTrue: [^self].	map inspect.	self error: errorString</body><body package="WikiWorks">checkHistories: aDictionary latests: aCollection 	| duplications |	duplications := aDictionary asBag reject: [:each | each isOriginal]				collect: [:each | each previousVersion].	self 		checkDuplications: (duplications asSet 				select: [:each | (duplications occurrencesOf: each) &gt; 1])		for: aDictionary		and: aCollection		match: [:each | [:v | v == each]]		map: [:each :page | [:v | (page includes: v) and: [v versionNumber &gt;= each versionNumber]]]		error: 'Duplicated histories detected!'</body><body package="WikiWorks">checkTitles: aDictionary latests: aCollection 	| duplications |	duplications := Bag new.	aCollection do: [:each | duplications addAll: each allTitles].	self		checkDuplications: (duplications asSet select: [:each | (duplications occurrencesOf: each)					&gt; 1])		for: aDictionary		and: aCollection		match: [:each | [:v | each = v title]]		map: [:each :page | [:v | page includes: v]]		error: 'Duplicated titles detected!'</body><body package="WikiWorks">cleanupLatests: aCollection 	aCollection copy do: 			[:page | 			(page isOriginal and: [page title ~= rootPageTitle]) 				ifTrue: 					[					[aCollection remove: page.					(directory construct: (idMap removeKey: page) printString , '.pag') delete] 							on: OsError							do: [:ex | ex return]]]</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>accessing</category><body package="WikiWorks">formattingPageTitle: aString 	super formattingPageTitle: aString.	self saveWikiFile</body><body package="WikiWorks">idMap	^idMap</body><body package="WikiWorks">name: aString 	super name: aString.	self saveWikiFile</body><body package="WikiWorks">rootPageTitle: aString 	super rootPageTitle: aString.	self saveWikiFile</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>private-persistance</category><body package="WikiWorks">idForPage: aPage 	^idMap at: aPage ifAbsentPut: [self savePage: aPage]</body><body package="WikiWorks">nextFileCounter	^fileCounter := fileCounter + 1</body><body package="WikiWorks">savePage: aPage 	| id ws |	id := idMap at: aPage ifAbsent: [self nextFileCounter].	ws := (directory construct: id printString , '.pag') writeStream.	[aPage saveToFile: ws under: self] ensure: [ws close].	self changed: #addedPage:from: with: aPage.	^id</body><body package="WikiWorks">saveWikiFile	| ws |	ws := (directory construct: 'wiki.cnf') writeStream.		[name ifNil: [^self].	ws nextPutAll: name.	ws cr.	rootPageTitle ifNil: [^self].	ws nextPutAll: rootPageTitle.	ws cr.	formattingPageTitle ifNil: [^self].	ws nextPutAll: formattingPageTitle.	ws cr] 			ensure: [ws close]</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>pages</category><body package="WikiWorks">addPage: aPage 	super addPage: aPage.	self idForPage: aPage.	^aPage</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>initialize-release</category><body package="WikiWorks">initialize	super initialize.	fileCounter := -1.	idMap := IdentityDictionary new</body><body package="WikiWorks">postInitialize	super postInitialize.	self recoverWikiFile.	self recoverFiles</body></methods><methods><class-id>WikiWorks.FlatFileWiki class</class-id> <category>class initialization</category><body package="WikiWorks">initialize	"FlatFileWiki initialize."	super initialize.	ObjectMemory removeDependent: self.	ObjectMemory addDependent: self</body></methods><methods><class-id>WikiWorks.FlatFileWiki class</class-id> <category>updating</category><body package="WikiWorks">returnFromSnapshot	"FlatFileWiki returnFromSnapshot."	| configuration |	configuration := HttpServer defaultConfiguration ifNil: [^self].	(HttpServer current)		handler: CompositeWiki new;		configureFrom: (configuration sectionNamed: 'server').	configuration sectionsNamed: self configurationSectionName		do: [:each | self configureFrom: each]</body><body package="WikiWorks">update: aSymbol 	aSymbol == #returnFromSnapshot ifFalse: [^self].	HttpServer inProduction ifFalse: [^self].	self returnFromSnapshot</body></methods><methods><class-id>WikiWorks.FlatFileWiki class</class-id> <category>parcel load/unload/save</category><body package="WikiWorks">preUnloadActionFor: aParcel	"A Parcel's pre-unload action must be a class method taking one	 argument, the Parcel being unloaded.  Fill-out this template and accept.	 Note that you can give the method whatever selector you want.	 You don't have to use preUnloadActionFor:.	 The pre-unload action should ensure that the Parcel unloads cleanly.	 This usually includes things like checking that any open applications	 derived from the Parcel are closed, and that any long-lived data strutures	 using instances of classes defined in the Parcel are emptied of those	 instances.	ApplicationModel checkUnloadOfApplicationsDefinedBy: aParcel is provided	to close-down any open applications defined by a parcel."		ObjectMemory removeDependent: self</body></methods><methods><class-id>WikiWorks.WikiRender</class-id> <category>rendering-page</category><body package="WikiWorks">renderPage: aPage 	self linkTo: [self renderPageURL: aPage]		titled: [self renderPageTitle: aPage]</body><body package="WikiWorks">renderPageDetail: aPage 	self space.	TimestampPrintPolicy 		print: aPage timestamp		on: replyStream		using: 'hh:mm:ss'.	self ,= ' ('.	self ,= aPage author.	self ,= $)</body><body package="WikiWorks">renderPageTitle: aPage 	self ,= aPage title</body><body package="WikiWorks">renderPageURL: aPage 	self handlerURL.	self ,= $/.	self ,= aPage encodedTitle</body></methods><methods><class-id>WikiWorks.WikiRender</class-id> <category>accessing-references</category><body package="WikiWorks">references		[| referringPages |	referringPages := self referencesFor: self searchString.	referringPages isEmpty 		ifTrue: [self renderNoreferences]		ifFalse: [self renderReferences: referringPages]] 			niceValue</body><body package="WikiWorks">referencesFor: aString 	^handler referencesFor: aString</body><body package="WikiWorks">searchString	^request postDataAt: #SEARCHPATTERN ifAbsent: [request lastIdentifier]</body></methods><methods><class-id>WikiWorks.WikiRender</class-id> <category>accessing-pages</category><body package="WikiWorks">numberOfPages	^handler pages size</body><body package="WikiWorks">pageList		[self 		bulletList: [self pages do: [:each | self listItem: [self renderPage: each]]]] 			niceValue</body><body package="WikiWorks">pages	^handler pages asSortedCollection</body></methods><methods><class-id>WikiWorks.WikiRender</class-id> <category>rendering-changes</category><body package="WikiWorks">renderChangesFor: aDate 	| sc |	sc := self changesFor: aDate.	sc isEmpty ifTrue: [^0].	self heading: 			[TimestampPrintPolicy 				print: aDate				on: replyStream				using: 'mmmm d yyyy']		level: 3.	self bulletList: 			[sc do: 					[:each | 					self listItem: 							[self renderPage: each.							self renderPageDetail: each]]].	^sc size</body></methods><methods><class-id>WikiWorks.WikiRender</class-id> <category>accessing-changes</category><body package="WikiWorks">changesFor: aDate 	^handler changesFor: aDate</body><body package="WikiWorks">recentChanges	| day minDate startDate changesShown |	day := Date today.	minDate := day subtractDays: self numberOfDays.	changesShown := 0.	startDate := self startDate.		[	[day &lt; startDate 		or: [changesShown &gt; self numberOfChanges and: [day &lt; minDate]]] 			whileFalse: 				[changesShown := changesShown + (self renderChangesFor: day).				day := day subtractDays: 1]] 			niceValue</body><body package="WikiWorks">startDate	^handler startDate</body></methods><methods><class-id>WikiWorks.WikiRender</class-id> <category>rendering-references</category><body package="WikiWorks">renderNoreferences	self heading: [self ,= ' No references to: '].	self italicize: 			[self				,= ' ...';				,= self searchString;				,= '... ']</body><body package="WikiWorks">renderReferences: pages 	self heading: 			[pages size = 1 				ifTrue: [self ,= ' There is 1 reference to: ']				ifFalse: 					[self						,= ' There are ';						,= pages size;						,= ' references to: '.					self searchString printOn: replyStream quoteCharacter: $"]].	self horizontalRule.	self 		bulletList: [pages do: [:each | self listItem: [self renderPage: each]]]</body></methods><methods><class-id>WikiWorks.WikiRender</class-id> <category>defaults-changes</category><body package="WikiWorks">numberOfChanges	^20</body><body package="WikiWorks">numberOfDays	^7</body></methods><methods><class-id>WikiWorks.WikiPageLink</class-id> <category>testing</category><body package="WikiWorks">hasFragment	^fragment notNil</body><body package="WikiWorks">isAnonymous	^name isNil</body><body package="WikiWorks">isExternalLink	^self externalLinkPrefixes contains: [:each | each match: address]</body><body package="WikiWorks">isImage	^self imageLinkSuffixes contains: [:each | each match: address]</body><body package="WikiWorks">isMethod	^isMethod</body></methods><methods><class-id>WikiWorks.WikiPageLink</class-id> <category>initialize-release</category><body package="WikiWorks">contents: aString 	| realString rs isAnonymous |	realString := aString trimSeparators.	rs := realString readStream.	(rs insensitivePeekForAll: 'ISBN:') 		ifTrue: 			[name := realString.			address := self isbnUrlPrefix , rs upToEnd trimSeparators.			^self].	rs := realString readStream.	name := (rs upTo: $&gt; escaper: $\) trimSeparators.	isMethod := rs peekForAll: '&gt;#'.	isMethod 		ifTrue: 			[address := rs upToEnd trimSeparators asSymbol.			^self].	isAnonymous := rs atEnd.	address := isAnonymous ifTrue: [name] ifFalse: [rs upToEnd trimSeparators].	isAnonymous ifTrue: [name := nil].	self isExternalLink ifTrue: [^self].	rs := address readStream.	address := (rs upTo: $! escaper: $\) trimSeparators.	rs atEnd 		ifFalse: 			[siblingReference := address.			address := rs upToEnd trimSeparators]</body><body package="WikiWorks">fragmentize	| rs |	rs := address readStream.	address := rs upTo: $# escaper: $\.	rs atEnd ifFalse: [fragment := rs upToEnd]</body><body package="WikiWorks">initialize	isMethod := false</body></methods><methods><class-id>WikiWorks.WikiPageLink</class-id> <category>accessing</category><body package="WikiWorks">address	^address</body><body package="WikiWorks">fragment	^fragment</body><body package="WikiWorks">name	| externalLinkPrefix |	self isAnonymous ifFalse: [^name].	externalLinkPrefix := self externalLinkPrefixes 				detect: [:each | each match: address]				ifNone: [^address].	^address copyFrom: externalLinkPrefix size</body><body package="WikiWorks">siblingReference	^siblingReference</body></methods><methods><class-id>WikiWorks.WikiPageLink</class-id> <category>constants</category><body package="WikiWorks">externalLinkPrefixes	^#('http://*' 'https://*' 'mailto:*' 'file:/*' 'ftp://*' 'news:*' 'nntp://*' 'telnet://*' 'prospero://*' 'gopher://*' 'wais://*')</body><body package="WikiWorks">imageLinkSuffixes	^#('*.gif' '*.jpeg' '*.jpg' '*.jpe')</body><body package="WikiWorks">isbnUrlPrefix	^'http://www.amazon.com/exec/obidos/ASIN/'</body></methods><methods><class-id>WikiWorks.WikiPageLink class</class-id> <category>instance creation</category><body package="WikiWorks">new	^super new initialize</body></methods><methods><class-id>WikiWorks.CompositeWikiRender</class-id> <category>rendering-page</category><body package="WikiWorks">renderPage: pageAndWiki 	handler := pageAndWiki value.	super renderPage: pageAndWiki key</body><body package="WikiWorks">renderPageDetail: pageAndWiki 	super renderPageDetail: pageAndWiki key</body><body package="WikiWorks">renderPageTitle: aPage 	self ,= self handlerName.	self ,= ' -&gt; '.	super renderPageTitle: aPage</body></methods><methods><class-id>WikiWorks.CompositeWikiRender</class-id> <category>accessing-changes</category><body package="WikiWorks">changesFor: aDate 	| sc |	sc := SortedCollection 				sortBlock: [:a :b | a key timestamp &gt; b key timestamp].	components 		do: [:wiki | (wiki changesFor: aDate) do: [:page | sc add: page -&gt; wiki]].	^sc</body><body package="WikiWorks">recentChanges	| savedHandler |	savedHandler := handler.	[super recentChanges] ensure: [handler := savedHandler]</body><body package="WikiWorks">startDate	^components inject: Date today		into: [:bottom :each | each startDate min: bottom]</body></methods><methods><class-id>WikiWorks.CompositeWikiRender</class-id> <category>accessing-pages</category><body package="WikiWorks">numberOfPages	^components inject: 0 into: [:size :each | size + each pages size]</body><body package="WikiWorks">pageList	| savedHandler |	savedHandler := handler.	[super pageList] ensure: [handler := savedHandler]</body><body package="WikiWorks">pages	| sc |	sc := SortedCollection sortBlock: [:a :b | a key title &lt; b key title].	components do: [:wiki | wiki pages do: [:page | sc add: page -&gt; wiki]].	^sc</body></methods><methods><class-id>WikiWorks.CompositeWikiRender</class-id> <category>accessing-references</category><body package="WikiWorks">references	| savedHandler |	savedHandler := handler.	[super references] ensure: [handler := savedHandler]</body><body package="WikiWorks">referencesFor: aString 	| sc |	sc := SortedCollection sortBlock: [:a :b | a key title &lt; b key title].	components 		do: [:wiki | (wiki referencesFor: aString) do: [:page | sc add: page -&gt; wiki]].	^sc</body></methods><methods><class-id>WikiWorks.CompositeWikiRender</class-id> <category>defaults-changes</category><body package="WikiWorks">numberOfChanges	^components size * super numberOfChanges / 2</body></methods><methods><class-id>WikiWorks.CompositeWikiRender</class-id> <category>initialize-release</category><body package="WikiWorks">request: aRequest in: aRequestHandler 	super request: aRequest in: aRequestHandler.	components := SortedCollection sortBlock: [:a :b | a name &lt; b name].	request postDataDo: 			[:key :value | 			((key sameAs: value) or: [value sameAs: 'ON']) 				ifTrue: 					[| each |					each := handler componentNamed: key ifAbsent: [nil].					each notNil: [components add: each]]].	components isEmpty ifTrue: [^nil].	components size = 1 		ifTrue: [^WikiRender request: aRequest in: components first]</body></methods><methods><class-id>WikiWorks.CompositeWikiRender</class-id> <category>accessing</category><body package="WikiWorks">components	^components</body></methods><methods><class-id>WikiWorks.OriginalWikiPage</class-id> <category>accessing</category><body package="WikiWorks">allTitlesInto: aCollection 	aCollection add: title</body><body package="WikiWorks">contents	"Writes a removable title and back link. These can be edited out."	| ws |	ws := (String new: 50) writeStream.	ws		nextPutAll: 'Describe ';		nextPutAll: self title;		nextPutAll: ' here....'.	^ws contents</body><body package="WikiWorks">tabularHistoricalSynopsis	^'Created'</body><body package="WikiWorks">title	^title</body><body package="WikiWorks">title: aString 	^title := aString</body><body package="WikiWorks">versionNumber	^0</body><body package="WikiWorks">versionsDo: aBlock 	aBlock value: self</body><body package="WikiWorks">versionsReverseDo: aBlock 	aBlock value: self</body></methods><methods><class-id>WikiWorks.OriginalWikiPage</class-id> <category>testing</category><body package="WikiWorks">isOriginal	^true</body></methods><methods><class-id>WikiWorks.OriginalWikiPage</class-id> <category>flat file</category><body package="WikiWorks">saveToFile: aFileStream under: aWiki 	super saveToFile: aFileStream under: aWiki.	aFileStream nextPutAll: title</body><body package="WikiWorks">specificData: aString 	self title: aString</body></methods><methods><class-id>WikiWorks.OriginalWikiPage</class-id> <category>recovery</category><body package="WikiWorks">readSpecificPageDataFrom: stream in: directory	self specificData: stream upToEnd.	stream close.	^nil</body></methods><methods><class-id>WikiWorks.TestPageRender</class-id> <category>accessing</category><body package="WikiWorks">replyStream	^replyStream isNil		ifTrue: [replyStream := WriteStream on: (String new: 1000)]		ifFalse: [replyStream]</body></methods><methods><class-id>WikiWorks.TestPageRender</class-id> <category>initialize-release</category><body package="WikiWorks">initialize	self replyStream.</body></methods><methods><class-id>WikiWorks.TestPageRender</class-id> <category>api</category><body package="WikiWorks">getResultingContentFrom: string	| content |	self resetParsingStates.	content := string.	self != '&lt;!-- unformatted page contents --'.	self != content.	self != '//-- unformatted page contents --&gt;'.	contentStream := content readStream.	[contentStream atEnd] whileFalse: 			[self getNextChar.			self processCurrentChar].	lastChar := currentChar := Character cr.	self processCurrentChar.	^replyStream contents</body></methods><methods><class-id>WikiWorks.TestPageRender class</class-id> <category>instance creation</category><body package="WikiWorks">new	^super new initialize</body></methods><methods><class-id>WikiWorks.RevertedWikiPage</class-id> <category>flat file</category><body package="WikiWorks">specificData: aPage 	"^selfI have no specific data."	^self</body></methods><methods><class-id>WikiWorks.RevertedWikiPage</class-id> <category>recovery</category><body package="WikiWorks">readSpecificPageDataFrom: stream in: directory	| prevFilename |	prevFilename := self prevFilenameFrom: stream in: directory.	self specificData: stream upToEnd.	stream close.	^prevFilename</body></methods><methods><class-id>WikiWorks.RevertedWikiPage</class-id> <category>accessing</category><body package="WikiWorks">tabularHistoricalSynopsis	^'Reverted to version ' , previousVersion versionNumber printString</body></methods><methods><class-id>WikiWorks.VersionRender</class-id> <category>accessing</category><body package="WikiWorks">page	^page versionAt: version</body><body package="WikiWorks">pageVersion	^version</body></methods><methods><class-id>WikiWorks.VersionRender</class-id> <category>initialize-release</category><body package="WikiWorks">request: aRequest in: aRequestHandler 	super request: aRequest in: aRequestHandler.	version := ((aRequest identifier at: handler depth + 1) asNumber max: 0) 				min: page versionNumber</body></methods><methods><class-id>WikiWorks.VersionRender</class-id> <category>testing</category><body package="WikiWorks">isLatestPage	^version = page versionNumber</body></methods><methods><class-id>WikiWorks.TokenDifference</class-id> <category>private-process</category><body package="WikiWorks">added	results add: #added -&gt; (new at: newPos).	^newPos := newPos + 1</body><body package="WikiWorks">compareTokens	[oldPos &lt;= old size and: [newPos &lt;= new size]] whileTrue: 			[| offset |			(new at: newPos) = (old at: oldPos) 				ifTrue: [self same]				ifFalse: 					[offset := 1.										[offset &gt; 50 or: 							[oldPos &gt;= old size or: 									[newPos + offset &gt;= new size or: 											[(new at: newPos + offset) = (old at: oldPos) 												and: [(new at: newPos + offset + 1) = (old at: oldPos + 1)]]]]] 							whileFalse: [offset := offset + 1].					(offset &gt; 50 or: [newPos + offset &gt;= new size]) 						ifTrue: [self deleted]						ifFalse: [self added]]]</body><body package="WikiWorks">deleted	results add: #deleted -&gt; (old at: oldPos).	^oldPos := oldPos + 1</body><body package="WikiWorks">initScan	results := OrderedCollection new: old size.	newPos := 1.	oldPos := 1</body><body package="WikiWorks">maybeScan	(old isNil or: [new isNil]) ifFalse: [self scan]</body><body package="WikiWorks">processTails	[newPos &gt; new size] whileFalse: [self added].	[oldPos &gt; old size] whileFalse: [self deleted]</body><body package="WikiWorks">same	results add: #same -&gt; (new at: newPos).	newPos := newPos + 1.	^oldPos := oldPos + 1</body><body package="WikiWorks">scan	self initScan.	self compareTokens.	self processTails</body></methods><methods><class-id>WikiWorks.TokenDifference</class-id> <category>accessing</category><body package="WikiWorks">new: anObject 	new := anObject.	self maybeScan</body><body package="WikiWorks">old: anObject 	old := anObject.	self maybeScan</body><body package="WikiWorks">results	^results</body></methods><methods><class-id>WikiWorks.TokenDifference</class-id> <category>accessing-debugging</category><body package="WikiWorks">emphasisFor: anAssoc 	anAssoc key == #same ifTrue: [^nil].	anAssoc key == #added ifTrue: [^Array with: #bold with: #underline].	anAssoc key == #deleted 		ifTrue: [^Array with: #color -&gt; ColorValue red with: #italic]</body><body package="WikiWorks">resultsText	| ts |	ts := TextStream on: String new.	results do: 			[:each | 			ts emphasis: (self emphasisFor: each).			ts nextPutAll: each value]		separatedBy: [ts space].	^ts contents</body></methods><methods><class-id>WikiWorks.HttpServer class</class-id> <category>examples</category><body package="WikiWorks">initializeNormalWiki	"You can run this several times, once for each wiki you want to create, or you	can change it to create several at once.  Creating a wiki means writing files	for it.  Once a wiki is created, use restartNormalWiki when you want to restart	your image and restart the wikis, too."	| wiki |	wiki := FlatFileWiki directory: 'MyWiki'.	"The next three lines are optional: there are defaults."	wiki name: 'MyWiki'.	wiki rootPageTitle: 'Home Page'.	wiki formattingPageTitle: 'Wiki Syntax'.	self current handler addComponent: wiki.	"you can start it on any port you want"	self startOn: (self defaultServerAddress port: 8080)</body><body package="WikiWorks">restartFancyWiki	"This example method shows how you can other services to the webserver, such as a file server and a servlet loader.  Ignore until you think you know what you are doing."	| "servletHandler" handlers |	self flush.	handlers := self current handler.	"Add a file server on a particular directory."	handlers addComponent: (FileServerWiki named: 'files'				directory: 'C:\ralph' asFilename)."The code below requires you load the WikiServlet package from the Cincom Open Repository.  That package contains long-since-abandoned VW servlet stuff, used in the #restartFancyWiki example method of the WikiWorks goodie.  It is pre-WebToolkit code.  Since WebToolkit now itself requires that the non-default-install Web Application Server (Legacy) component be installed, this indicates its age.  This should be rewritten, or the whole goodie rehandled.	servletHandler := ServletLoader named: 'servlet' directory: 'servlets\'.	servletHandler addComponent: ((DummyServlet new)				name: 'dummy';				yourself).	handlers addComponent: servletHandler."	self restartNormalWiki</body><body package="WikiWorks">restartNormalWiki	"self restartNormalWiki"	| handlers |	handlers := self current handler.	#('MyWiki' 'MyFriendsWiki') 		do: [:eachName | handlers addComponent: (FlatFileWiki directory: eachName)].	"Starts on the default port 80."	self start</body></methods><initialize><class-id>WikiWorks.CompositeWiki</class-id></initialize><initialize><class-id>WikiWorks.Wiki</class-id></initialize><initialize><class-id>WikiWorks.FlatFileWiki</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>HtmlRender</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request handler replyStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><class><name>CompositeRequestHandler</name><environment>WikiWorks</environment><super>WikiWorks.HttpRequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components directory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class></st-source>