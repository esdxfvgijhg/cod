<?xml version="1.0"?><st-source><!-- Name: HttpServerDbIdentifier: psql_public_cst_2007DbTrace: 92364DbUsername: niallrDbVersion: 7.10.1 - 2DevelopmentPrerequisites: #(#(#any 'NetworkServer' ''))PackageName: HttpServerParcel: #('HttpServer')ParcelName: HttpServerPrerequisiteParcels: #(#('NetworkServer' ''))PrintStringCache: (7.10.1 - 2,niallr)Version: 7.10.1 - 2Pre-Unload Block: 	[:pkg| WikiWorks.HttpServer preUnloadActionFor: pkg ]Date: 4:58:02 PM January 26, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 26, 2016 at 4:58:02 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WebResponse</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><class><name>HttpSession</name><environment>WikiWorks</environment><super>WikiWorks.NetworkSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><class><name>HttpAuthenticationResponse</name><environment>WikiWorks</environment><super>WikiWorks.WebResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>realm </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><class><name>HttpServer</name><environment>WikiWorks</environment><super>WikiWorks.NetworkServer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><comment><class-id>WikiWorks.HttpServer</class-id><body>A WebServer forks off a process to handle an incoming connection.  It converts theconnection to a WebClientRequest and gives it to a WebRequestHandler.  Theserver's behavior depends primarily on the WebRequestHandler you give it.  Thus,it is very expandable.  See WikiWorks, the File Server, and Servlets.Instance Variables:	handler	&lt;WebRequestHandler&gt;		port	&lt;Number&gt;	Number of port being watched.	priority	&lt;Number&gt;	Priority of serveLoop	serveLoop	&lt;Process&gt;	Keep track of the process running the loop so you can kill it.	serverSocket	&lt;SocketAccessor&gt;	Socket being listened to.Class Variables:	Current	&lt;WebServer&gt;	The singleton.	Times		&lt;Array of: (Array of: Object)&gt;	Timing information about every request.  Turned off by default.</body></comment><class><name>ActiveHttpResponse</name><environment>WikiWorks</environment><super>WikiWorks.WebResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><class><name>WebClientRequest</name><environment>WikiWorks</environment><super>WikiWorks.NetworkRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientData postData identifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><class><name>HttpRequestHandler</name><environment>WikiWorks</environment><super>WikiWorks.NetworkRequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars>defaultHandlers </class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><comment><class-id>WikiWorks.HttpRequestHandler</class-id><body>A HttpRequestHandler handles WebClientRequests that are given to it.  WebClientRequests come from the HttpServer, but often a HttpRequestHandler will pass them on to other HttpRequestHandlers.  Thus, sometimes there is a tree of HttpRequestHandlers.Subclasses must implement the following messages:	public interface		handle:Instance Variables:	name	&lt;String&gt;	Used by parent to find this handler</body></comment><class><name>Cache</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source staticRepository cacheRepository </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>HttpServer</package></attributes></class><class><name>TimestampedCache</name><environment>WikiWorks</environment><super>WikiWorks.Cache</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>timestampRepository </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>HttpServer</package></attributes></class><class><name>HtmlRender</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request handler replyStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><class><name>ActiveHttpRequestHandler</name><environment>WikiWorks</environment><super>WikiWorks.HttpRequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>formattingBlock renderClass timestamp sourceString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><comment><class-id>WikiWorks.ActiveHttpRequestHandler</class-id><body>I am a RequestHandler whose behavior is defined by an HTML template.  I take this HTML templateand convert it into a block that will produce HTML.  The HTML template can contain Smalltalk code that is run when the block is evaluated.  The block has two parameters, request and output.request is a WebClientRequest and output is a Stream.  The code in the HTML template can readfrom request and write to output.  By default, HTML is written to output, as well.  Of course,since this is Smalltalk, you can change just about any of this.Instance Variables:	formattingBlock	&lt;BlockClosure&gt;	Two-argument block used to handle request.</body></comment><class><name>CompositeRequestHandler</name><environment>WikiWorks</environment><super>WikiWorks.HttpRequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components directory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Framework</category><attributes><package>HttpServer</package></attributes></class><comment><class-id>WikiWorks.CompositeRequestHandler</class-id><body>Handles a request by looking at the next name.  If there is no name, uses the root handler. If there is no handler for the name, uses the error handler.Names are not case sensitive.Instance Variables:	components	&lt;Dictionary&gt;	description of components	errorHandler	&lt;WebRequestHandler&gt;		rootHandler	&lt;WebRequestHandler&gt;	</body></comment><shared-variable><name>StatusStream</name><environment>WikiWorks.HttpServer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HttpServer</package></attributes></shared-variable><shared-variable><name>StatisticsStream</name><environment>WikiWorks.HttpServer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HttpServer</package></attributes></shared-variable><methods><class-id>WikiWorks.WebResponse</class-id> <category>sending</category><body package="HttpServer">sendBodyOver: aStream 	self subclassResponsibility</body><body package="HttpServer">sendContentLengthOver: aStream 	"Don't know the length for several types of messages"</body><body package="HttpServer">sendHeaderOver: aStream 	self sendStandardHeadersOver: aStream.	self sendModifiedTimeOver: aStream.	self sendMimeTypeOver: aStream.	self sendContentLengthOver: aStream</body><body package="HttpServer">sendMimeTypeOver: aStream 	aStream		nextPutAll: 'Content-Type: ';		nextPutAll: self mimeType;		cr</body><body package="HttpServer">sendModifiedTimeOver: aStream 	aStream nextPutAll: 'Last-Modified: '.	self modifiedTime sendOver: aStream.	aStream cr</body><body package="HttpServer">sendOver: aStream 	aStream lineEndCRLF.	self sendStatusLineOver: aStream.	self sendHeaderOver: aStream.	aStream cr.	self sendBodyOver: aStream</body><body package="HttpServer">sendStandardHeadersOver: aStream 	aStream nextPutAll: 'Date: '.	Timestamp now sendOver: aStream.	aStream cr.	aStream		nextPutAll: 'Server: WikiWorks/';		nextPutAll: HttpServer current serverVersion;		nextPutAll: ' (VisualWorks)';		cr.	aStream		nextPutAll: 'Connection: close';		cr</body><body package="HttpServer">sendStatusLineOver: aStream 	aStream		nextPutAll: 'HTTP/1.0 200 OK';		cr</body></methods><methods><class-id>WikiWorks.WebResponse</class-id> <category>accessing</category><body package="HttpServer">mimeType	^'text/html'</body><body package="HttpServer">modifiedTime	^Timestamp now</body></methods><methods><class-id>WikiWorks.HttpSession</class-id> <category>defaults</category><body package="HttpServer">requestClass	^WebClientRequest</body></methods><methods><class-id>WikiWorks.HttpSession class</class-id> <category>instance creation</category><body package="HttpServer">fromSocket: aSocket 	"Not that this is most probably a hack. And should be removed later on	when HTTP/1.1 is being implemented where persistent connection is default	and the concept of session will be valid."	| aSession |	aSession := super fromSocket: aSocket.	^aSession nextRequest</body></methods><methods><class-id>WikiWorks.HttpAuthenticationResponse</class-id> <category>accessing</category><body package="HttpServer">realm	^realm</body><body package="HttpServer">realm: realmString 	realm := realmString</body></methods><methods><class-id>WikiWorks.HttpAuthenticationResponse</class-id> <category>sending</category><body package="HttpServer">sendBodyOver: aStream 	aStream		nextPutAll: '&lt;html&gt;&lt;title&gt;Unauthorized&lt;/title&gt;&lt;body&gt;&lt;h2&gt;Unauthorized for ';		nextPutAll: self realm;		nextPutAll: '&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;';		cr</body><body package="HttpServer">sendModifiedTimeOver: aStream 	aStream		nextPutAll: 'WWW-Authenticate: Basic realm="';		nextPutAll: self realm;		nextPutAll: '"';		cr</body><body package="HttpServer">sendStatusLineOver: aStream 	aStream		nextPutAll: 'HTTP/1.0 401 Unauthorized';		cr</body></methods><methods><class-id>WikiWorks.HttpAuthenticationResponse class</class-id> <category>instance creation</category><body package="HttpServer">fromRealm: realmString 	^self new realm: realmString</body></methods><methods><class-id>WikiWorks.HttpServer</class-id> <category>server accessing</category><body package="HttpServer">serverProtocol	^'HTTP/1.0'</body></methods><methods><class-id>WikiWorks.HttpServer</class-id> <category>accessing</category><body package="HttpServer">URLon: aStream "	aStream nextPutAll: 'http://'.	aStream nextPutAll: self hostname.	port = self defaultPort 		ifFalse: 			[aStream nextPut: $:.			aStream nextPutAll: port printString]"</body><body package="HttpServer">URLon: aStream for: aRequestHandler 	self URLon: aStream</body><body package="HttpServer">componentNamed: key 	^nil</body><body package="HttpServer">componentNamed: key ifAbsent: aBlock 	^aBlock value</body></methods><methods><class-id>WikiWorks.HttpServer</class-id> <category>interaction</category><body package="HttpServer">handleSession: aRequest 	"Defective requests sometimes reach the server. 	They can crash the server by causing the socket 	write primitive to fall into cycle. 	To avoid this, the request is checked for validity. 	If it is invalid, an error is raised and no response is made."	"It is passed in a Request now, although the method is named	#handleSession: . This is for future addition of HTTP/1.1 with	persistent connection by default."	aRequest isValid 		ifFalse: 			[self log: 'Client request not valid...'.			OsError raise.			^self].	self statsFor: aRequest		at: (Time millisecondsToRun: [super handleSession: aRequest]).	aRequest release</body></methods><methods><class-id>WikiWorks.HttpServer</class-id> <category>defaults</category><body package="HttpServer">defaultListenBacklog	^50</body><body package="HttpServer">requestHandlerClass	^CompositeRequestHandler</body><body package="HttpServer">sessionClass	^HttpSession</body></methods><methods><class-id>WikiWorks.HttpServer</class-id> <category>configuration</category><body package="HttpServer">configureFrom: aConfigurationSection 	handler directory: (aConfigurationSection at: 'directory' ifAbsent: ['.']).	handler 		name: (aConfigurationSection at: 'name' ifAbsent: ['Wiki''s Home at UIUC']).	super configureFrom: aConfigurationSection</body></methods><methods><class-id>WikiWorks.HttpServer</class-id> <category>logging</category><body package="HttpServer">statsFor: aRequest at: anInteger 	"Log server activities in common log format."	sessionManager statisticsStreamDo: 			[:ws | 			ws nextPutAll: aRequest peerName.	"remotehost"			"No valid information yet."			ws nextPutAll: ' - - ['.	"rfc931-remote logname"	"authUser"			Timestamp now sendOver: ws.	"[date]"			ws nextPutAll: '] "'.			aRequest sendOver: ws.	""	"request"	""			"No valid infomation yet."			ws nextPutAll: '" - - '.	"status"	"bytes"			anInteger printOn: ws.	"Milliseconds to run"			ws cr.			ws flush]</body></methods><methods><class-id>WikiWorks.HttpServer class</class-id> <category>server accessing</category><body package="HttpServer">defaultPort	^80</body></methods><methods><class-id>WikiWorks.HttpServer class</class-id> <category>parcel load/unload/save</category><body package="HttpServer">preUnloadActionFor: aParcel 	"A Parcel's pre-unload action must be a class method taking one	 argument, the Parcel being unloaded.  Fill-out this template and accept.	 Note that you can give the method whatever selector you want.	 You don't have to use preUnloadActionFor:.	 The pre-unload action should ensure that the Parcel unloads cleanly.	 This usually includes things like checking that any open applications	 derived from the Parcel are closed, and that any long-lived data strutures	 using instances of classes defined in the Parcel are emptied of those	 instances.	ApplicationModel checkUnloadOfApplicationsDefinedBy: aParcel is provided	to close-down any open applications defined by a parcel."	self flushAll</body></methods><methods><class-id>WikiWorks.ActiveHttpResponse</class-id> <category>initialize-release</category><body package="HttpServer">forRequest: aRequest in: aHandler 	request := aRequest.	handler := aHandler</body></methods><methods><class-id>WikiWorks.ActiveHttpResponse</class-id> <category>sending</category><body package="HttpServer">sendBodyOver: aStream 	handler render: request on: aStream</body><body package="HttpServer">sendModifiedTimeOver: aStream</body></methods><methods><class-id>WikiWorks.WebClientRequest</class-id> <category>private</category><body package="HttpServer">contentTypeFrom: aRequestHeader 	^aRequestHeader at: #'CONTENT-TYPE'		ifAbsent: 			[OrderedCollection with: 'application/octet-stream'				with: IdentityDictionary new]</body><body package="HttpServer">decompose: aSymbol inHeader: aRequestHeader 	| pieces major parameter |	pieces := ((aRequestHeader at: aSymbol ifAbsent: [^self]) 				tokensBasedOn: $;) reject: [:each | each isEmpty].	major := pieces removeFirst.	parameter := IdentityDictionary new.	(pieces collect: [:each | each tokensBasedOn: $=]) do: 			[:pair | 			parameter at: pair first trimSeparators asUppercase asSymbol				put: (String readFromCQuotedString: pair last trimSeparators)].	aRequestHeader at: aSymbol		put: (OrderedCollection with: major with: parameter)</body><body package="HttpServer">justFilename: aName 	| rs chunk |	rs := aName readStream.		[chunk := rs upTo: $\.	rs atEnd] whileFalse.	^chunk</body></methods><methods><class-id>WikiWorks.WebClientRequest</class-id> <category>initialize-release</category><body package="HttpServer">initialize	super initialize.	postData := IdentityDictionary new.	clientData := IdentityDictionary new.	identifier := OrderedCollection new</body><body package="HttpServer">initializeIdentifierFromRequestURIPath	identifier := (self firstParameter tokensBasedOn: $/) 				reject: [:each | each isEmpty]				collect: [:each | each trimSeparators decodedHTTP].	^self</body><body package="HttpServer">release	session release.	super release</body></methods><methods><class-id>WikiWorks.WebClientRequest</class-id> <category>accessing</category><body package="HttpServer">authorizer	^self clientDataAt: #AUTHORIZATION</body><body package="HttpServer">clientData	clientData isNil ifTrue: [clientData := IdentityDictionary new].	^clientData</body><body package="HttpServer">clientDataAt: aSymbol 	^self clientDataAt: aSymbol ifAbsent: [nil]</body><body package="HttpServer">clientDataAt: aSymbol ifAbsent: aBlock 	^clientData at: aSymbol ifAbsent: aBlock</body><body package="HttpServer">contentType	^self contentTypeFrom: clientData</body><body package="HttpServer">decodeUrlencodedFormData: aString 	((aString tokensBasedOn: $&amp;) reject: [:each | each isEmpty]		collect: [:each | each tokensBasedOn: $=]) do: 				[:pair | 				postData at: pair first trimSeparators decodedHTTP asUppercase asSymbol					put: pair last trimSeparators decodedHTTP]</body><body package="HttpServer">identifier	"^an OrderedCollectionThe identifier is an OrderedCollection of identifier elements from the request URL.  e.g. http://x.com/tom/dick/harry ... the identitifier collectionis 'tom' 'dick' 'harry'"	^identifier</body><body package="HttpServer">lastIdentifier	^identifier last</body><body package="HttpServer">multipartFormDataBoundary	"Content-Type: multipart/form-data; boundary=-----"	^(String with: Character cr with: Character lf) , '--' 		, (self contentType last at: #BOUNDARY ifAbsent: [''])</body><body package="HttpServer">peerName	| possiblePeer |	possiblePeer := self clientDataAt: #'X-FORWARDED-FOR'.	^possiblePeer isNil		ifTrue: [super peerName]		ifFalse: [possiblePeer]</body><body package="HttpServer">postData	postData isNil ifTrue: [postData := IdentityDictionary new].	^postData</body><body package="HttpServer">postDataAt: aSymbol 	^self postDataAt: aSymbol ifAbsent: [nil]</body><body package="HttpServer">postDataAt: aSymbol ifAbsent: aBlock 	^postData at: aSymbol ifAbsent: aBlock</body><body package="HttpServer">postDataDo: aBlock 	postData keysAndValuesDo: aBlock</body><body package="HttpServer">referer	^self clientDataAt: #REFERER</body></methods><methods><class-id>WikiWorks.WebClientRequest</class-id> <category>testing</category><body package="HttpServer">isGet	^command sameAs: 'GET'</body><body package="HttpServer">isPost	^command sameAs: 'POST'</body><body package="HttpServer">isValid	"Invalid requests can crash the server."	^OSErrorHolder errorSignal handle: [^false]		do: [self peerName isEmpty not and: [command isEmpty not]]</body></methods><methods><class-id>WikiWorks.WebClientRequest</class-id> <category>reading</category><body package="HttpServer">readBodyFrom: aStream removeHeaderIfEqualToFileName: aFileName 	"IE4 for Mac appends 128 bytes of Mac file system info - must remove.	this fix assumes that body size &gt;= 128"	| body rs magicSequence |	aStream lineEndTransparent.	body := aStream upToAndSkipThroughAll: self multipartFormDataBoundary.	aFileName isEmpty ifTrue: [^body].	body size &lt; 128 ifTrue: [^body].	rs := body readStream.	magicSequence := rs next: 2.	magicSequence last isDigit ifFalse: [^body].	magicSequence first isDigit ifFalse: [^body].	magicSequence asNumber = aFileName size ifFalse: [^body].	(rs insensitivePeekForAll: aFileName) ifFalse: [^body].	rs position: 128.	^rs upToEnd</body><body package="HttpServer">readBoundedFormDataFrom: aStream for: aRequestHeader 	| fieldName contentDisposition body fileName |	contentDisposition := aRequestHeader at: #'CONTENT-DISPOSITION'				ifAbsent: [^self].	fieldName := (contentDisposition last at: #NAME ifAbsent: ['']) 				asUppercase asSymbol.	((self contentTypeFrom: aRequestHeader) first sameAs: 'MULTIPART/MIXED') 		ifTrue: [self error: 'This server cannot handle mixed multipart format yet'].	fileName := contentDisposition last at: #FILENAME ifAbsent: [''].	body := self readBodyFrom: aStream removeHeaderIfEqualToFileName: fileName.	fileName isEmpty 		ifTrue: [postData at: fieldName put: body]		ifFalse: 			[(postData at: fieldName ifAbsentPut: [Dictionary new]) 				at: fileName makeFilename asFilename tail				put: body]</body><body package="HttpServer">readPostDataFrom: aStream 	| contentLength |	contentLength := (self clientDataAt: #'CONTENT-LENGTH' ifAbsent: [^self]) 				asNumber.	('MULTIPART/*' match: self contentType first) 		ifTrue: 			[| requestHeader |			[(requestHeader := self readRequestHeaderFrom: aStream) isEmpty] 				whileFalse: [self readBoundedFormDataFrom: aStream for: requestHeader]]		ifFalse: 			[| ws |			ws := (String new: contentLength) writeStream.			aStream lineEndTransparent.			[ws position &lt; contentLength] whileTrue: [ws nextPutAll: aStream nextHunk].			self decodeUrlencodedFormData: ws contents]</body><body package="HttpServer">readRequestHeaderFrom: aStream 	| rs requestHeader |	requestHeader := IdentityDictionary new.	aStream lineEndCRLF.	aStream nextLine = '--' ifTrue: [^requestHeader].	[aStream atEnd or: 			[rs := aStream nextLine readStream.			rs atEnd]] 		whileFalse: 			[requestHeader at: (rs upTo: $:) trimSeparators asUppercase asSymbol				put: rs upToEnd trimSeparators].	self decompose: #'CONTENT-TYPE' inHeader: requestHeader.	self decompose: #'CONTENT-DISPOSITION' inHeader: requestHeader.	^requestHeader</body><body package="HttpServer">readRequestLineFrom: aStream 	super readRequestLineFrom: aStream.	self initializeIdentifierFromRequestURIPath</body><body package="HttpServer">receiveOver: aStream 	super receiveOver: aStream.	clientData := self readRequestHeaderFrom: aStream.	self isPost ifTrue: [self readPostDataFrom: aStream]</body></methods><methods><class-id>WikiWorks.HttpRequestHandler</class-id> <category>testing</category><body package="HttpServer">hasFileserver	^false</body><body package="HttpServer">isFileserver	^false</body></methods><methods><class-id>WikiWorks.HttpRequestHandler</class-id> <category>authorization</category><body package="HttpServer">authorize: aRequest 	(super authorize: aRequest) ifTrue: [^true].	aRequest answerWithAuthenticationResponseFromRealm: self name.	^false</body><body package="HttpServer">privateAuthorize: aRequest 	| authorizer |	authorizer := aRequest authorizer.	authorizer ifNil: [^false].	authorizer := authorizer readStream.	^(authorizer insensitivePeekForAll: 'BASIC ') 		and: [super privateAuthorize: authorizer upToEnd]</body></methods><methods><class-id>WikiWorks.HttpRequestHandler</class-id> <category>accessing</category><body package="HttpServer">URLon: aStream 	parent URLon: aStream for: self</body><body package="HttpServer">URLon: aStream for: aRequestHandler 	self URLon: aStream</body><body package="HttpServer">addComponent: aRequestHandler 	^aRequestHandler</body><body package="HttpServer">componentNamed: key 	^nil</body><body package="HttpServer">componentNamed: key ifAbsent: aBlock 	^aBlock value</body><body package="HttpServer">components	^Dictionary new</body><body package="HttpServer">name	^name</body><body package="HttpServer">name: aString 	name := aString</body><body package="HttpServer">siblingNamed: aString ifAbsent: aBlock 	^parent componentNamed: aString ifAbsent: aBlock</body></methods><methods><class-id>WikiWorks.HttpRequestHandler</class-id> <category>comparing</category><body package="HttpServer">&lt;= aRequestHandler 	^self name &lt;= aRequestHandler name</body></methods><methods><class-id>WikiWorks.HttpRequestHandler</class-id> <category>private</category><body package="HttpServer">activeHandlerFor: key ifAbsent: aBlock 	| aRequestHandler source |	source := self activeHandlerSourceFor: key ifAbsent: [^aBlock value].	aRequestHandler := ActiveHttpRequestHandler readFromString: source.	aRequestHandler defaultRenderClass: self class reviewer.	aRequestHandler parent: self.	aRequestHandler name: key.	^aRequestHandler</body><body package="HttpServer">activeHandlerSourceFor: key ifAbsent: aBlock 	^self class defaultHandlers at: key ifAbsent: aBlock</body></methods><methods><class-id>WikiWorks.HttpRequestHandler</class-id> <category>initialize-release</category><body package="HttpServer">initialize	name := self class name</body></methods><methods><class-id>WikiWorks.HttpRequestHandler class</class-id> <category>accessing</category><body package="HttpServer">defaultHandlers	^defaultHandlers</body></methods><methods><class-id>WikiWorks.HttpRequestHandler class</class-id> <category>instance creation</category><body package="HttpServer">directory: directoryName 	| aRequestHandler |	aRequestHandler := self new.	aRequestHandler directory: directoryName.	^aRequestHandler</body><body package="HttpServer">named: aString 	| aRequestHandler |	aRequestHandler := self new.	aRequestHandler name: aString.	^aRequestHandler</body><body package="HttpServer">named: nameString directory: directoryName 	| aRequestHandler |	aRequestHandler := self directory: directoryName.	aRequestHandler name: nameString.	^aRequestHandler</body><body package="HttpServer">new	^super new initialize</body></methods><methods><class-id>WikiWorks.HttpRequestHandler class</class-id> <category>class initialization</category><body package="HttpServer">initialize	"[HttpRequestHandler withAllSubclasses do: [:each | each initialize].	Cache withAllSubclasses do: 		[:each | each allInstances do: [:cache | cache initializeRepository]]]	[HttpRequestHandler initialize]"	defaultHandlers := Dictionary new</body></methods><methods><class-id>WikiWorks.HttpRequestHandler class</class-id> <category>configuration</category><body package="HttpServer">configurationSectionName	^self subclassResponsibility</body><body package="HttpServer">configureFrom: aConfigurationSection 	| aRequestHandler |	aRequestHandler := self 				named: (aConfigurationSection at: 'name' ifAbsent: [name])				directory: (aConfigurationSection at: 'directory' ifAbsent: [name]).	HttpServer current handler addComponent: aRequestHandler.	HttpServer current 		log: 'Created ' , name , ' named:' , aRequestHandler name</body><body package="HttpServer">configureFromDefault	| configuration |	configuration := HttpServer defaultConfiguration ifNil: [^self].	configuration := (configuration 				sectionsNamed: self configurationSectionName) last.	self configureFrom: configuration</body></methods><methods><class-id>WikiWorks.Cache</class-id> <category>accessing</category><body package="HttpServer">at: key 	"Answer the value at key.  If key is not found, raise a signal."	^self at: key ifAbsent: [self keyNotFoundError: key]</body><body package="HttpServer">at: key ifAbsent: aBlock 	"Answer the value at key.  If key is not found, answer the	result of evaluating aBlock."	^staticRepository at: key ifAbsent: [self cacheAt: key ifAbsent: aBlock]</body><body package="HttpServer">at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	^staticRepository at: key put: anObject</body><body package="HttpServer">staticRepository	^staticRepository</body></methods><methods><class-id>WikiWorks.Cache</class-id> <category>private</category><body package="HttpServer">cacheAt: key ifAbsent: aBlock 	| value |	value := self findCachedObjectOrNil: key.	value notNil: [^value].	value := self fetchFor: key ifAbsent: [^aBlock value].	^cacheRepository at: key put: value</body><body package="HttpServer">fetchFor: key ifAbsent: aBlock 	^source fetchFor: key ifAbsent: aBlock</body><body package="HttpServer">findCachedObjectOrNil: key 	^cacheRepository at: key ifAbsent: [nil]</body><body package="HttpServer">keyNotFoundError: key 	"Raise a signal indicating that the key was not found."	^Dictionary keyNotFoundSignal raiseWith: key</body></methods><methods><class-id>WikiWorks.Cache</class-id> <category>initialize-release</category><body package="HttpServer">initializeRepository	cacheRepository := Dictionary new</body><body package="HttpServer">source: anObject 	source := anObject.	staticRepository := Dictionary new.	self initializeRepository</body></methods><methods><class-id>WikiWorks.Cache class</class-id> <category>instance creation</category><body package="HttpServer">new	^self shouldNotImplement</body><body package="HttpServer">source: anObject 	| aCache |	aCache := super new.	aCache source: anObject.	^aCache</body></methods><methods><class-id>WikiWorks.TimestampedCache</class-id> <category>private</category><body package="HttpServer">fetchFor: key ifAbsent: aBlock 	| latest |	latest := source timestampFor: key ifAbsent: [^aBlock value].	timestampRepository at: key put: latest.	^super fetchFor: key ifAbsent: aBlock</body><body package="HttpServer">findCachedObjectOrNil: key 	| value |	(value := super findCachedObjectOrNil: key) ifNil: [^nil].	(timestampRepository at: key ifAbsent: [Timestamp zero]) 		&lt; (source timestampFor: key ifAbsent: [Timestamp now]) ifTrue: [^nil].	^value</body></methods><methods><class-id>WikiWorks.TimestampedCache</class-id> <category>initialize-release</category><body package="HttpServer">initializeRepository	super initializeRepository.	timestampRepository := Dictionary new</body></methods><methods><class-id>WikiWorks.HtmlRender</class-id> <category>accessing-request</category><body package="HttpServer">isGet	^request isGet</body><body package="HttpServer">postDataAt: aSymbol 	^request postDataAt: aSymbol ifAbsent: ['']</body><body package="HttpServer">postDataAt: aSymbol ifAbsent: aBlock 	^request postDataAt: aSymbol ifAbsent: aBlock</body><body package="HttpServer">request	^request</body></methods><methods><class-id>WikiWorks.HtmlRender</class-id> <category>html-tags</category><body package="HttpServer">bulletList: aBlock 	self startBulletList.	aBlock value.	self closeBulletList</body><body package="HttpServer">closeBulletList	self != '&lt;/UL&gt;'</body><body package="HttpServer">closeListItem	self != '&lt;/LI&gt;'</body><body package="HttpServer">closeNumberList	self != '&lt;/OL&gt;'</body><body package="HttpServer">closeTableCell	self != '&lt;/TD&gt;'</body><body package="HttpServer">heading: aBlock 	self heading: aBlock level: 2</body><body package="HttpServer">heading: aBlock level: anInteger 	self		,= '&lt;H';		,= anInteger;		,= ' &gt;&lt;FONT face="Arial" &gt;'.	aBlock value.	self		,= '&lt;/FONT&gt;&lt;/H';		,= anInteger;		!= '&gt;'</body><body package="HttpServer">horizontalRule	self != '&lt;HR &gt;'</body><body package="HttpServer">inlineImage: aBlock 	self ,= '&lt;IMG src="'.	aBlock value.	self != '" border="0" &gt;'</body><body package="HttpServer">italicize: aBlock 	self ,= '&lt;I &gt;'.	aBlock value.	self ,= '&lt;/I&gt;'</body><body package="HttpServer">linkTo: urlBlock titled: titleBlock 	self ,= '&lt;A href="'.	urlBlock value.	self ,= '" &gt;'.	titleBlock value.	self ,= '&lt;/A&gt;'</body><body package="HttpServer">listItem: aBlock 	self startListItem.	aBlock value.	self closeListItem</body><body package="HttpServer">paragraph	self != '&lt;P &gt;'</body><body package="HttpServer">precise: aBlock 	self ,= '&lt;PRE &gt;'.	aBlock value.	self != '&lt;/PRE&gt;'</body><body package="HttpServer">startBulletList	self ,= '&lt;UL &gt;'</body><body package="HttpServer">startListItem	self ,= '&lt;LI &gt;'</body><body package="HttpServer">startNumberList	self ,= '&lt;OL &gt;'</body><body package="HttpServer">startTableCell: align 	self ,= '&lt;TD align="'.	self ,= align.	self ,= '" &gt;&amp;nbsp;'</body><body package="HttpServer">startTableRow	self startTableRow: 'CENTER'</body><body package="HttpServer">startTableRow: align 	self ,= '&lt;TR &gt;'.	self startTableCell: align</body></methods><methods><class-id>WikiWorks.HtmlRender</class-id> <category>accessing-handler</category><body package="HttpServer">components	^handler components</body><body package="HttpServer">handlerName	^handler name</body><body package="HttpServer">handlerURL	"Note that this always just returns an empty string, but the URL has already been written to the stream (presumably).  So why return the string?"	handler URLon: replyStream.	^''</body><body package="HttpServer">sortedComponentsDo: aBlock 	self components asSortedCollection do: aBlock</body></methods><methods><class-id>WikiWorks.HtmlRender</class-id> <category>initialize-release</category><body package="HttpServer">replyStream: aStream 	replyStream := aStream</body><body package="HttpServer">request: aRequest in: aRequestHandler 	request := aRequest.	handler := aRequestHandler</body></methods><methods><class-id>WikiWorks.HtmlRender</class-id> <category>testing</category><body package="HttpServer">hasFileserver	^handler hasFileserver</body></methods><methods><class-id>WikiWorks.HtmlRender</class-id> <category>streaming</category><body package="HttpServer">!= aStringLikeThing 	"^a string like thingFor those who thought this was some kind of comparison operator, I've added this comment.In fact, this is a concatenation operator which adds aStringLikeThing to the end of my content stream followed by a single &lt;cr&gt; character."	self		,= aStringLikeThing;		cr.	^aStringLikeThing</body><body package="HttpServer">,= aStringLikeThing 	"^selfFor those who thought this was some kind of comparison operator, I've added this comment.In fact, this is a concatenation operator which just adds aStringLikeThing to the end of my content."	^aStringLikeThing sendOver: replyStream</body><body package="HttpServer">cr	replyStream cr</body><body package="HttpServer">space	replyStream space</body></methods><methods><class-id>WikiWorks.HtmlRender class</class-id> <category>instance creation</category><body package="HttpServer">request: aRequest in: aRequestHandler 	^self new request: aRequest in: aRequestHandler</body></methods><methods><class-id>WikiWorks.ActiveHttpRequestHandler</class-id> <category>stream creation</category><body package="HttpServer">readStream	^self</body></methods><methods><class-id>WikiWorks.ActiveHttpRequestHandler</class-id> <category>accessing</category><body package="HttpServer">modifiedTime	^timestamp</body></methods><methods><class-id>WikiWorks.ActiveHttpRequestHandler</class-id> <category>initialize-release</category><body package="HttpServer">defaultRenderClass: aRenderClass 	renderClass ifNil: [self renderClass: aRenderClass]</body><body package="HttpServer">renderClass: aRenderClass 	renderClass := aRenderClass</body><body package="HttpServer">renderClass: aRenderClass sourceString: aString 	self renderClass: aRenderClass.	timestamp := Timestamp now.	sourceString := aString.	formattingBlock := self class 				readFormattingBlockFrom: sourceString readStream</body></methods><methods><class-id>WikiWorks.ActiveHttpRequestHandler</class-id> <category>copying</category><body package="HttpServer">postCopy	"Note that we MUST copy the block.  On the other hand we 	shouldn't copy timestamp, sourceString, and renderClass, 	all of them could be perfectly shared."	formattingBlock := formattingBlock copy</body></methods><methods><class-id>WikiWorks.ActiveHttpRequestHandler</class-id> <category>interaction</category><body package="HttpServer">handle: aRequest 	"Refer to the last 2 statements of CompositeWikiRender&gt;&gt;#request:in:."	| aRender |	aRender := renderClass request: aRequest in: parent.	"If there's no selection made in the CompositeWiki,	nil will be returned instead of an instance of renderClass."	aRender ifNil: [^parent rootComponent handle: aRequest].	"If there's only one element was selected in CompositeWiki,	an instance of a class other than CompositeWikiRender will 	be returned.  Note the second level dispatching denies the	existence of polymorphic keys."	aRender class == renderClass 		ifFalse: 			[^(parent componentNamed: aRender handlerName) componentNamed: name				handle: aRequest].	aRequest answerWith: (self defaultResponse forRequest: aRender in: self)</body><body package="HttpServer">render: aRequest on: aStream 	aRequest replyStream: aStream.	formattingBlock value: aRequest value: aStream</body></methods><methods><class-id>WikiWorks.ActiveHttpRequestHandler</class-id> <category>printing</category><body package="HttpServer">printOn: aStream 	renderClass notNil: 			[aStream nextPutAll: renderClass name.			aStream cr].	sourceString notNil: [aStream nextPutAll: sourceString]</body></methods><methods><class-id>WikiWorks.ActiveHttpRequestHandler</class-id> <category>defaults</category><body package="HttpServer">responseClass	^ActiveHttpResponse</body></methods><methods><class-id>WikiWorks.ActiveHttpRequestHandler class</class-id> <category>instance creation</category><body package="HttpServer">readFrom: aStream 	| aRenderClass |	aRenderClass := [Compiler evaluate: (aStream upTo: $&lt; escaper: $\)] 				on: Error				do: [:ex | ex return: nil].	aStream atEnd ifFalse: [aStream skip: -1].	^self renderClass: aRenderClass sourceString: aStream upToEnd</body><body package="HttpServer">readFromString: aString 	| rs |	rs := aString readStream.	rs == aString ifTrue: [^aString copy	"Not a string, actually!"].	^[self readFrom: rs] ensure: [rs close]</body><body package="HttpServer">renderClass: aRenderClass sourceString: aString 	^self new renderClass: aRenderClass sourceString: aString</body></methods><methods><class-id>WikiWorks.ActiveHttpRequestHandler class</class-id> <category>utility</category><body package="HttpServer">readClosedBlockFrom: aStream into: blockStream 	| chunk |	blockStream nextPutAll: 'output nextPutAll: (['.		[aStream atEnd or: 			[chunk := aStream upTo: self closedBlockTag escaper: $\.			aStream peekFor: $&gt;	"end of a &lt;?...?&gt; expression"]] 			whileFalse: 				[blockStream nextPutAll: chunk.				blockStream nextPut: self closedBlockTag].	blockStream nextPutAll: chunk.	blockStream nextPutAll: '] value ifNil: ['''']).\' withCRs.	^false</body><body package="HttpServer">readFormattingBlockFrom: aStream 	| blockStream isInString |	blockStream := (String new: 1024) writeStream.	blockStream nextPutAll: '[:request :output | \' withCRs.	isInString := false.	[aStream atEnd] whileFalse: 			[isInString := self 						readFormattingFrom: aStream						into: blockStream						inString: isInString].	isInString ifTrue: [blockStream nextPut: $'].	blockStream nextPutAll: ']'.	^Compiler evaluate: blockStream contents</body><body package="HttpServer">readFormattingFrom: aStream into: blockStream inString: isInString 	| chunk notInString |	chunk := aStream upTo: $&lt; escaper: $\.	chunk isEmpty 		ifFalse: 			[isInString ifFalse: [blockStream nextPutAll: 'output nextPutAll: '''].			chunk printInsideOn: blockStream quoteCharacter: $'].	notInString := chunk isEmpty and: [isInString not].	aStream atEnd ifTrue: [^notInString not].	(aStream peekFor: self openBlockTag) 		ifTrue: 			[notInString ifFalse: [blockStream nextPutAll: '''.\' withCRs].			^self readOpenBlockFrom: aStream into: blockStream].	(aStream peekFor: self closedBlockTag) 		ifTrue: 			[notInString ifFalse: [blockStream nextPutAll: '''.\' withCRs].			^self readClosedBlockFrom: aStream into: blockStream].	notInString ifTrue: [blockStream nextPutAll: 'output nextPutAll: '''].	blockStream nextPut: $&lt;.	^true</body><body package="HttpServer">readOpenBlockFrom: aStream into: blockStream 	| chunk |		[aStream atEnd or: 			[chunk := aStream upTo: self openBlockTag escaper: $\.			aStream peekFor: $&gt;	"end of a &lt;%...%&gt; expression"]] 			whileFalse: 				[blockStream nextPutAll: chunk.				blockStream nextPut: self openBlockTag].	blockStream nextPutAll: chunk.	blockStream cr.	^false</body></methods><methods><class-id>WikiWorks.ActiveHttpRequestHandler class</class-id> <category>constants</category><body package="HttpServer">closedBlockTag	^$?</body><body package="HttpServer">openBlockTag	^$%</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler</class-id> <category>private</category><body package="HttpServer">activeHandlerSourceFor: key ifAbsent: aBlock 	| aFilename source |	aFilename := self templateNamed: key.	source := super activeHandlerSourceFor: key ifAbsent: [nil].	^(aFilename definitelyExists 		and: [source isNil or: [aFilename modifiedTime &gt; source modifiedTime]]) 			ifTrue: [aFilename]			ifFalse: [source ifNil: [aBlock value]]</body><body package="HttpServer">templateDirectory	^directory construct: 'TEMPLATE'</body><body package="HttpServer">templateNamed: key 	^self templateDirectory construct: key</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler</class-id> <category>accessing</category><body package="HttpServer">URLon: aStream for: aHandler 	super URLon: aStream for: self.	aStream nextPut: $/.	aStream nextPutAll: aHandler name encodedHTTP</body><body package="HttpServer">addComponent: aRequestHandler 	components at: aRequestHandler name asUppercase put: aRequestHandler.	aRequestHandler parent: self.	^aRequestHandler</body><body package="HttpServer">componentNamed: key 	^self componentNamed: key ifAbsent: [self rootComponent]</body><body package="HttpServer">componentNamed: key ifAbsent: aBlock 	^components at: key asUppercase ifAbsent: aBlock</body><body package="HttpServer">components	^components staticRepository copy</body><body package="HttpServer">directory: directoryName 	directory := directoryName asFilename.	self postInitialize</body><body package="HttpServer">rootComponent	^self componentNamed: self rootKey</body><body package="HttpServer">rootKey	^self class rootKey</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler</class-id> <category>caching support</category><body package="HttpServer">fetchFor: key ifAbsent: aBlock 	^self activeHandlerFor: key ifAbsent: aBlock</body><body package="HttpServer">timestampFor: key ifAbsent: aBlock 	| source |	source := self activeHandlerSourceFor: key ifAbsent: [nil].	^source ifNil: [aBlock value] notNil: [source modifiedTime]</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler</class-id> <category>initialize-release</category><body package="HttpServer">initialize	super initialize.	directory := Filename defaultDirectory.	components := TimestampedCache source: self</body><body package="HttpServer">postInitialize	"^selfIt seems that we are getting the templaces as coded in my class and writing these out to the TEMPLATES directory after first copying any existing files to xxx.orig.  It's not clear why the backup thing happens."	directory ensureDirectory.	self templateDirectory ensureDirectory.	self class defaultHandlers keysAndValuesDo: 			[:key :value | 			| filename ws |			filename := self templateNamed: key.			filename definitelyExists 				ifTrue: [[filename backup] on: OsError do: [:ex | ex return]].			ws := filename writeStream lineEndLF.			[ws print: value] ensure: [ws close]]</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler</class-id> <category>interaction</category><body package="HttpServer">componentNamed: key handle: aRequest 	(self authorize: aRequest) ifFalse: [^self].	(self componentNamed: key) handle: aRequest</body><body package="HttpServer">handle: aRequest 	self componentNamed: (self responseKeyFor: aRequest) handle: aRequest</body><body package="HttpServer">responseKeyFor: aRequest 	aRequest identifier size &lt; self depth ifTrue: [^self rootKey].	^aRequest identifier at: self depth</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler</class-id> <category>testing</category><body package="HttpServer">hasFileserver	^self components contains: [:each | each isFileserver]</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler class</class-id> <category>defaults</category><body package="HttpServer">defaultRootHandler	^'&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN"&gt;&lt;HTML &gt;&lt;HEAD &gt;&lt;TITLE &gt;&lt;?request handlerName?&gt;&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#000000" &gt;&lt;FONT color="#000000" &gt;&lt;%request components isEmpty	ifTrue: 		[%&gt;&lt;H2 &gt;&lt;?request handlerName?&gt; is currently refusing all requests&lt;/H2&gt;&lt;%]	ifFalse: 		[%&gt;' 		, self searchCommand , '&lt;%].%&gt;&lt;/FONT&gt;&lt;/BODY&gt;&lt;/HTML&gt;' 		asHttpRequestHandler: self reviewer</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler class</class-id> <category>renders</category><body package="HttpServer">reviewer	^HtmlRender</body><body package="HttpServer">summarizer	^self reviewer</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler class</class-id> <category>keys</category><body package="HttpServer">rootKey	^'ROOT'</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler class</class-id> <category>defaults-components</category><body package="HttpServer">searchCommand	^'&lt;H2 &gt;&lt;?request handlerName?&gt;&lt;/H2&gt;&lt;FORM action="&lt;%request handlerURL.%&gt; " method="POST" &gt;&lt;%request sortedComponentsDo:	[:each | %&gt;	&lt;INPUT type="CHECKBOX" name="&lt;?each name?&gt;" CHECKED &gt;	&lt;A HREF="&lt;%each URLon: output.%&gt;" &gt;&lt;?each name?&gt;&lt;/A&gt;	&lt;BR &gt;&lt;%].%&gt;'</body></methods><methods><class-id>WikiWorks.CompositeRequestHandler class</class-id> <category>class initialization</category><body package="HttpServer">initialize	"CompositeRequestHandler initialize."	super initialize.	defaultHandlers at: self rootKey put: self defaultRootHandler</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="HttpServer">decodedHTTPFrom: aStream 	"hack to just ignore all url arguments that come in"	| firstChar secondChar |	self == $+ ifTrue: [^$ ].	self == $% ifFalse: [^self].	(self == $? or: [self == $&amp;])		ifTrue: [aStream upToEnd.				^Character lf].	(firstChar := aStream next) ifNil: [^Character lf].	(secondChar := aStream next) ifNil: [^Character lf].	^Character value: firstChar digitValue * 16 + secondChar digitValue</body><body package="HttpServer">encodedHTTPOn: aStream 	self isUnreserved ifTrue: [^aStream nextPut: self].	self == $  ifTrue: [^aStream nextPut: $+].	aStream		nextPut: $%;		nextPut: (Character digitValue: self asInteger // 16);		nextPut: (Character digitValue: self asInteger \\ 16).	self == Character cr ifTrue: [Character lf encodedHTTPOn: aStream]</body></methods><methods><class-id>WikiWorks.NetworkSession</class-id> <category>responding</category><body package="HttpServer">answerWithAuthenticationResponseFromRealm: aRealmName 	self answerWith: (HttpAuthenticationResponse fromRealm: aRealmName).</body></methods><methods><class-id>WikiWorks.NetworkServer class</class-id> <category>accsessing</category><body package="HttpServer">allServers	^AllServers</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="HttpServer">asHttpRequestHandler: aRenderClass 	^WikiWorks.ActiveHttpRequestHandler renderClass: aRenderClass sourceString: self</body><body package="HttpServer">decodedHTTP	"The original version could break if the data was truncated."	| rs ws |	rs := self readStream.	ws := (self species new: self size) writeStream.	[rs atEnd] whileFalse: 			[| char |			char := rs next decodedHTTPFrom: rs.			char == Character lf ifFalse: [ws nextPut: char]].	^ws contents</body><body package="HttpServer">encodedHTML	| rs ws |	rs := self readStream.	ws := (self species new: self size) writeStream.	[rs atEnd] whileFalse: 			[| ch |			(ch := rs next) == $&amp; 				ifTrue: [ws nextPutAll: '&amp;amp;']				ifFalse: [ws nextPut: ch]].	^ws contents</body><body package="HttpServer">encodedHTTP	| rs ws |	rs := self readStream.	ws := (self species new: self size) writeStream.	[rs atEnd] whileFalse: [rs next encodedHTTPOn: ws].	^ws contents</body></methods><initialize><class-id>WikiWorks.HttpRequestHandler</class-id></initialize><initialize><class-id>WikiWorks.CompositeRequestHandler</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NetworkRequest</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command parameters session </inst-vars><class-inst-vars>commands </class-inst-vars><imports>			private IOConstants.*			</imports><category>Network-Framework</category><attributes><package>NetworkServer</package></attributes></class><class><name>NetworkRequestHandler</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent users </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Framework</category><attributes><package>NetworkServer</package></attributes></class><class><name>NetworkSession</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream peerAddress peerName </inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Network-Framework</category><attributes><package>NetworkServer</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>NetworkServer</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listeningSocket ipAddress serverProcess sessionManager handler </inst-vars><class-inst-vars>current </class-inst-vars><imports>			private IOConstants.*			</imports><category>Network-Framework</category><attributes><package>NetworkServer</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>