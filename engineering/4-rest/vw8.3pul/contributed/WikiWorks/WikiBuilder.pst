<?xml version="1.0"?><st-source><!-- Name: WikiBuilderComment: Code for extracting from one Wiki to another.DbIdentifier: psql_public_cst_2007DbTrace: 92368DbUsername: niallrDbVersion: 7.10.1 - 2DevelopmentPrerequisites: #(#(#any 'WikiWorks' ''))PackageName: WikiBuilderParcel: #('WikiBuilder')ParcelName: WikiBuilderPrerequisiteDescriptions: #(#(#name 'WikiWorks'))PrerequisiteParcels: #(#('WikiWorks' ''))PrintStringCache: (7.10.1 - 2,niallr)Version: 7.10.1 - 2Date: 4:59:10 PM January 26, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 26, 2016 at 4:59:10 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WikiContentExtraction</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>input output listChar sucker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wiki-Parser</category><attributes><package>WikiBuilder</package></attributes></class><class><name>VisualWorksWikiContentExtraction</name><environment>WikiWorks</environment><super>WikiWorks.WikiContentExtraction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wiki-Parser</category><attributes><package>WikiBuilder</package></attributes></class><class><name>PatternStoriesExtraction</name><environment>WikiWorks</environment><super>WikiWorks.WikiContentExtraction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasTag hasFormatter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wiki-Parser</category><attributes><package>WikiBuilder</package></attributes></class><class><name>WikiStream</name><environment>WikiWorks</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isAtStartOfLine output </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wiki-Parser</category><attributes><package>WikiBuilder</package></attributes></class><class><name>WikiSucker</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream wiki host port targetWiki targets currentTarget visitedTargets contentExtractionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wiki-Parser</category><attributes><package>WikiBuilder</package></attributes></class><methods><class-id>WikiWorks.WikiContentExtraction</class-id> <category>parsing</category><body package="WikiBuilder">convertedLinkTitle: aString 	^aString</body><body package="WikiBuilder">extractContents	[input atEnd] whileFalse: 			[| char |			(char := input next) = $&lt; 				ifTrue: [self parseTag]				ifFalse: [output nextPut: char]]</body><body package="WikiBuilder">findInside	input		insensitiveSkipThroughAll: '&lt;HR&gt;';		insensitiveSkipThroughAll: '&lt;HR&gt;'.	input nextLine.	input := (input insensitiveUpToAll: '&lt;HR&gt;&lt;FONT SIZE=-1&gt;&lt;A HREF=') 				readStream</body><body package="WikiBuilder">linkTo: aLink 	output		nextPut: $[;		nextPutAll: aLink;		nextPut: $]</body><body package="WikiBuilder">linkTo: link titled: name 	output		nextPut: $[;		nextPutAll: name.	name = link 		ifFalse: 			[output nextPut: $&gt;.			output nextPutAll: link].	output nextPut: $]</body><body package="WikiBuilder">parse	self findInside.	self extractContents</body><body package="WikiBuilder">parseLink: aString 	| name rs link |	name := (input insensitiveUpToAll: '&lt;/A&gt;') trimSeparators.	(rs := aString readStream) skipThrough: $=.	rs skipSeparators.	link := ((rs peekFor: $") ifTrue: [rs upTo: $"] ifFalse: [rs upToEnd]) 				trimSeparators.	(self targetWiki match: link) 		ifTrue: 			[link := link copyFrom: self targetWiki size.			('*.edit' match: link) ifFalse: [self addTarget: link]].	self linkTo: link titled: name</body><body package="WikiBuilder">parsePotentialLink	| underline |	underline := input insensitiveUpToAll: '&lt;/U&gt;'.	(input insensitivePeekForAll: '&lt;A HREF=') 		ifTrue: 			[| link |			link := input upTo: $&gt;.			((input peekFor: $?) and: ['"' , self targetWiki , '.edit"' match: link]) 				ifTrue: [^self linkTo: underline]].	output		nextPutAll: '&lt;U&gt;';		nextPutAll: underline;		nextPutAll: '&lt;/U&gt;'</body><body package="WikiBuilder">parseTag	| tag |	input skipSeparators.	tag := (input upTo: $&gt;) trimSeparators.	(tag sameAs: 'BR') ifTrue: [^output cr].	(tag sameAs: 'P') ifTrue: [^output cr].	(tag sameAs: 'HR') ifTrue: [^output cr; nextPutAll: '----'; cr].	('H#' match: tag) ifTrue: [^output cr; nextPut: $!].	('/H#' match: tag) ifTrue: [^self].	(tag sameAs: 'LI') ifTrue: [listChar notNil ifTrue: [^output cr; nextPut: listChar]].	(tag sameAs: '/LI') ifTrue: [^self].	(tag sameAs: 'UL') ifTrue: [^listChar := $*].	(tag sameAs: '/UL') ifTrue: [^listChar := nil].	(tag sameAs: 'OL') ifTrue: [^listChar := $#].	(tag sameAs: '/OL') ifTrue: [^listChar := nil].	('a*href=*' match: tag) ifTrue: [^self parseLink: tag].	(tag sameAs: 'U') ifTrue: [^self parsePotentialLink].	output nextPut: $&lt;; nextPutAll: tag; nextPut: $&gt;</body></methods><methods><class-id>WikiWorks.WikiContentExtraction</class-id> <category>testing</category><body package="WikiBuilder">isMeaningful	^true</body><body package="WikiBuilder">isSkeptical	^false</body></methods><methods><class-id>WikiWorks.WikiContentExtraction</class-id> <category>accessing</category><body package="WikiBuilder">addTarget: aString 	sucker addTarget: aString</body><body package="WikiBuilder">contents	^output contents</body><body package="WikiBuilder">sucker: aWikiSucker 	sucker := aWikiSucker</body><body package="WikiBuilder">targetWiki	^sucker targetWiki , '*'</body><body package="WikiBuilder">titleIn: aString 	| rs |	rs := aString readStream.	rs insensitiveSkipThroughAll: '&lt;TITLE'.	rs skipThrough: $&gt;.	^self 		convertedLinkTitle: (rs insensitiveUpToAll: '&lt;/TITLE&gt;') trimSeparators</body></methods><methods><class-id>WikiWorks.WikiContentExtraction</class-id> <category>initialize</category><body package="WikiBuilder">setInput: aReadStream 	input := aReadStream.	output := '' writeStream</body></methods><methods><class-id>WikiWorks.WikiContentExtraction class</class-id> <category>instance creation</category><body package="WikiBuilder">in: aSucker 	^self new sucker: aSucker</body></methods><methods><class-id>WikiWorks.VisualWorksWikiContentExtraction</class-id> <category>parsing</category><body package="WikiBuilder">convertedLinkTitle: aString 	"convert &lt;b&gt;foo&lt;/b&gt; to #foo, because that works for the VisualWorks wiki"	| beforeBold bold result inputStream |	result := (String new: 32) writeStream.	inputStream := aString readStream.	beforeBold := inputStream insensitiveUpToAll: '&lt;B'.	inputStream skipThrough: $&gt;.	[inputStream atEnd] whileFalse: 			[result nextPutAll: beforeBold.			inputStream next: 3.			bold := inputStream insensitiveUpToAll: '&lt;/B&gt;'.			result nextPut: $#.			result nextPutAll: bold.			beforeBold := inputStream insensitiveUpToAll: '&lt;B'.			inputStream skipThrough: $&gt;].	result nextPutAll: beforeBold.	^result contents</body><body package="WikiBuilder">findInside	input		insensitiveSkipThroughAll: '&lt;HR&gt;';		insensitiveSkipThroughAll: '&lt;HR&gt;'.	input nextLine.	input := (input insensitiveUpToAll: '&lt;HR&gt;&lt;FONT SIZE=-1&gt;&lt;A HREF=') 				readStream</body><body package="WikiBuilder">linkTo: aLink 	output linkTo: (self convertedLinkTitle: aLink)</body><body package="WikiBuilder">linkTo: link titled: name 	output linkTo: (self convertedLinkTitle: link)		titled: (self convertedLinkTitle: name)</body><body package="WikiBuilder">parseLink: aString 	| name rs link |	name := (input insensitiveUpToAll: '&lt;/A&gt;') trimSeparators.	(rs := aString readStream) skipThrough: $=.	rs skipSeparators.	link := ((rs peekFor: $") ifTrue: [rs upTo: $"] ifFalse: [rs upToEnd]) 				trimSeparators.	link first == $/ ifTrue: [link := link copyFrom: 2].	(self targetWiki match: link) 		ifTrue: 			[link := (link copyFrom: self targetWiki size) decodedHTTP.			('*.edit' match: link) ifFalse: [self addTarget: link]].	self linkTo: link titled: name</body><body package="WikiBuilder">parseTag	| tag |	input skipSeparators.	tag := (input upTo: $&gt;) trimSeparators.	(tag sameAs: 'BR') ifTrue: [^output cr].	(tag sameAs: 'P') ifTrue: [^output newLine].	(tag sameAs: 'HR') ifTrue: [^output nextPutAll: '\----\' withCRs].	('H#' match: tag) 		ifTrue: [^output next: (tag copyFrom: 2) asNumber put: $!].	('/H#' match: tag) ifTrue: [^self].	(tag sameAs: 'LI') 		ifTrue: [listChar notNil ifTrue: [^output nextPut: listChar]].	(tag sameAs: '/LI') ifTrue: [^self].	(tag sameAs: 'UL') ifTrue: [^listChar := $*].	(tag sameAs: '/UL') ifTrue: [^listChar := nil].	(tag sameAs: 'OL') ifTrue: [^listChar := $#].	(tag sameAs: '/OL') ifTrue: [^listChar := nil].	('a*href=*' match: tag) ifTrue: [^self parseLink: tag].	(tag sameAs: 'U') ifTrue: [^self parsePotentialLink].	output		nextPut: $&lt;;		nextPutAll: tag;		nextPut: $&gt;</body></methods><methods><class-id>WikiWorks.VisualWorksWikiContentExtraction</class-id> <category>initialize</category><body package="WikiBuilder">setInput: aReadStream 	input := aReadStream.	output := WikiStream new</body></methods><methods><class-id>WikiWorks.PatternStoriesExtraction</class-id> <category>parsing</category><body package="WikiBuilder">findInside	input insensitiveSkipThroughAll: '&lt;hr size=5&gt;'.	input := (input insensitiveUpToAll: '&lt;hr size=5&gt;&lt;a href="wikic?edit=') 				readStream</body><body package="WikiBuilder">parseLink: aString 	| name rs link |	name := (input insensitiveUpToAll: '&lt;/A&gt;') trimSeparators.	(name first == $[ and: [name last == $]]) 		ifTrue: [name := name copyFrom: 2 to: name size - 1].	(rs := aString readStream) skipThrough: $=.	rs skipSeparators.	link := ((rs peekFor: $") ifTrue: [rs upTo: $"] ifFalse: [rs upToEnd]) 				trimSeparators.	(self targetWiki match: link) 		ifTrue: 			[link := (link copyFrom: self targetWiki size) decodedHTTP.			('edit=*' match: link) 				ifTrue: 					[link := link copyFrom: 6.					name := link.					output skip: link size * -1]				ifFalse: [self addTarget: link]].	output linkTo: link titled: name</body><body package="WikiBuilder">parseTag	| tag |	hasTag := true.	input skipSeparators.	tag := (input upTo: $&gt;) trimSeparators.	(tag sameAs: 'P') ifTrue: [^output newLine].	('HR*' match: tag) ifTrue: [^output nextPutAll: '\----\' withCRs].	('H#' match: tag) 		ifTrue: [^output next: (tag copyFrom: 2) asNumber put: $!].	('/H#' match: tag) ifTrue: [^self].	(tag sameAs: 'LI') 		ifTrue: 			[hasFormatter := true.			^output nextPutAll: listChar].	(tag sameAs: '/LI') ifTrue: [^self].	(tag sameAs: 'UL') ifTrue: [^listChar := '*' , listChar].	(tag sameAs: '/UL') ifTrue: [^listChar := listChar copyFrom: 2].	(tag sameAs: 'OL') ifTrue: [^listChar := '#' , listChar].	(tag sameAs: '/OL') ifTrue: [^listChar := listChar copyFrom: 2].	('a*href=*' match: tag) 		ifTrue: 			[hasFormatter := true.			^self parseLink: tag].	output		nextPut: $&lt;;		nextPutAll: tag;		nextPut: $&gt;</body></methods><methods><class-id>WikiWorks.PatternStoriesExtraction</class-id> <category>initialize</category><body package="WikiBuilder">setInput: aReadStream 	listChar := ''.	input := aReadStream.	output := WikiStream new.	hasTag := hasFormatter := false</body></methods><methods><class-id>WikiWorks.PatternStoriesExtraction</class-id> <category>testing</category><body package="WikiBuilder">isMeaningful	^hasTag</body><body package="WikiBuilder">isSkeptical	^hasFormatter not</body></methods><methods><class-id>WikiWorks.PatternStoriesExtraction</class-id> <category>accessing</category><body package="WikiBuilder">addTarget: aString 	(#('PatternStoriesWeb' 'StatePattertytytn' 'Recent Changes' 'WikicWeb Index' 'index' 'DeadPages' 'Editing Style' 'WelcomeNewVisitors') 		contains: [:each | each sameAs: aString]) 			ifFalse: [super addTarget: aString]</body><body package="WikiBuilder">targetWiki	^(super targetWiki tokensBasedOn: $/) last</body></methods><methods><class-id>WikiWorks.PatternStoriesExtraction class</class-id> <category>examples</category><body package="WikiBuilder">suckWikic: aString rootPageTitle: anotherString 	"self suckWikic: 'PatternStories' rootPageTitle: 'Front Page'."	| wiki vacuum |	wiki := FlatFileWiki named: aString directory: 'wiki/' , aString.	vacuum := WikiSucker new.	vacuum contentExtractionClass: self.	vacuum targetWiki: '/cgi-bin/wikic/wikic?'.	vacuum addTarget: anotherString.	vacuum wiki: wiki.	vacuum suckFrom: 'chip.cs.uiuc.edu' on: 80.	wiki rootPageTitle: anotherString.	wiki formattingPageTitle: 'Wiki Syntax'</body></methods><methods><class-id>WikiWorks.WikiStream</class-id> <category>accessing</category><body package="WikiBuilder">contents	^output contents</body><body package="WikiBuilder">linkTo: link 	output nextPut: $[.	output nextPutAll: link.	output nextPut: $]</body><body package="WikiBuilder">linkTo: link titled: name 	output		nextPut: $[;		nextPutAll: (name copyReplaceAll: '&gt;' with: '&gt;&gt;').	name = link 		ifFalse: 			[output nextPut: $&gt;.			output nextPutAll: link].	output nextPut: $]</body><body package="WikiBuilder">newLine	self nextPut: Character cr.	isAtStartOfLine := false.	self nextPut: Character cr</body><body package="WikiBuilder">nextPut: aChar 	(aChar == Character cr or: [aChar == Character lf]) 		ifTrue: 			[isAtStartOfLine ifFalse: [output cr].			isAtStartOfLine := true]		ifFalse: 			[isAtStartOfLine := false.			"Double the link delimiter characters if they aren't used as links"			aChar == $[ ifTrue: [output nextPut: aChar].			output nextPut: aChar]</body><body package="WikiBuilder">skip: anInteger 	output skip: anInteger</body></methods><methods><class-id>WikiWorks.WikiStream</class-id> <category>initializing</category><body package="WikiBuilder">initialize	output := '' writeStream.	isAtStartOfLine := true</body></methods><methods><class-id>WikiWorks.WikiStream class</class-id> <category>instance creation</category><body package="WikiBuilder">new	^self basicNew initialize</body></methods><methods><class-id>WikiWorks.WikiSucker</class-id> <category>initialize</category><body package="WikiBuilder">initialize	targets := Set new.	visitedTargets := Set new</body></methods><methods><class-id>WikiWorks.WikiSucker</class-id> <category>accessing</category><body package="WikiBuilder">addTarget: aString 	(visitedTargets includes: aString) ifFalse: [targets add: aString]</body><body package="WikiBuilder">buildPage	| aPage |	aPage := OriginalWikiPage new.	aPage title: currentTarget.	aPage author: 'extractor'.	^aPage</body><body package="WikiBuilder">contentExtractionClass: aClass 	contentExtractionClass := aClass</body><body package="WikiBuilder">nextTarget	currentTarget := targets anyOne.	targets remove: currentTarget.	visitedTargets add: currentTarget.	^currentTarget</body><body package="WikiBuilder">targetWiki	^targetWiki</body><body package="WikiBuilder">targetWiki: aString 	targetWiki := aString</body><body package="WikiBuilder">wiki: aWiki 	wiki := aWiki</body></methods><methods><class-id>WikiWorks.WikiSucker</class-id> <category>connection</category><body package="WikiBuilder">connect	| socket |	socket := [SocketAccessor newTCPclientToHost: host port: port] on: Error				do: [:ex | self notify: 'Unable to start sucker socket ' , ex messageText].	stream := socket readAppendStream.	stream lineEndLF</body><body package="WikiBuilder">createContentExtraction	^contentExtractionClass in: self</body><body package="WikiBuilder">endOfRequest	^String 		with: Character cr		with: Character lf		with: Character cr		with: Character lf</body><body package="WikiBuilder">formRequest	self		nextPutAll: 'GET ';		nextPutAll: targetWiki;		nextPutAll: currentTarget encodedHTTP;		nextPutAll: ' HTTP/1.0';		nextPutAll: self endOfRequest</body><body package="WikiBuilder">readResponse	| response aPage contentExtraction |	response := stream upToEnd.	contentExtraction := (self createContentExtraction)				setInput: response readStream;				parse.	aPage := self buildPage.	aPage := aPage newContents: contentExtraction contents by: aPage author.	aPage := aPage 				changeTitle: (self createContentExtraction titleIn: response)				by: aPage author.	"	Transcript		clear;		show: aPage title;		cr;		show: aPage contents;		cr.	"	wiki ifNil: [^self].	contentExtraction isMeaningful ifFalse: [^self].	(contentExtraction isSkeptical and: 			[(#('LaurenceGordon' 'MergingGates' 'KyleBrown' 'DecoupledCardinality') 				contains: [:each | aPage title sameAs: each]) not]) 		ifTrue: [^self].	wiki addPage: aPage</body></methods><methods><class-id>WikiWorks.WikiSucker</class-id> <category>streaming</category><body package="WikiBuilder">nextPut: aCharacter 	stream nextPut: aCharacter</body><body package="WikiBuilder">nextPutAll: aCharacterArray 	stream nextPutAll: aCharacterArray</body><body package="WikiBuilder">print: anObject 	stream print: anObject</body><body package="WikiBuilder">space	stream space</body></methods><methods><class-id>WikiWorks.WikiSucker</class-id> <category>interaction</category><body package="WikiBuilder">suck	[targets isEmpty] whileFalse: 			[self nextTarget.			(Delay forMilliseconds: 10) wait.						[self connect.			self formRequest.			self readResponse] 					ensure: [stream close]]</body><body package="WikiBuilder">suckFrom: aHostName 	^self suckFrom: aHostName on: 80</body><body package="WikiBuilder">suckFrom: aHostName on: aPortNumber 	host := aHostName.	port := aPortNumber.	self suck</body><body package="WikiBuilder">suckOn: aPortNumber 	^self suckFrom: 'localhost' on: aPortNumber</body></methods><methods><class-id>WikiWorks.WikiSucker class</class-id> <category>examples</category><body package="WikiBuilder">suckUIUCWikis	"WikiSucker suckupUIUCWikis"	self suckWikiNamed: 'cs497rej' rootPageTitle: 'Front Page'.	self suckWikiNamed: 'VisualWorks'.	self suckWikiNamed: 'SAG'.	self suckWikiNamed: 'RefactoringBrowser'.	self suckWikiNamed: 'CISTUG'		rootPageTitle: 'Central Illinois Smalltalk User Group (CISTUG)'.	self suckWikiNamed: 'VisualAge'</body><body package="WikiBuilder">suckWikiNamed: aString 	self suckWikiNamed: aString rootPageTitle: aString , ' : Front Page'</body><body package="WikiBuilder">suckWikiNamed: aString rootPageTitle: anotherString 	| wiki vacuum |	wiki := FlatFileWiki named: aString directory: 'wiki/' , aString.	vacuum := self new.	vacuum contentExtractionClass: VisualWorksWikiContentExtraction.	vacuum targetWiki: aString.	vacuum addTarget: anotherString.	vacuum wiki: wiki.	vacuum suckOn: 8080.	wiki rootPageTitle: anotherString.	wiki formattingPageTitle: 'Wiki Syntax'</body></methods><methods><class-id>WikiWorks.WikiSucker class</class-id> <category>instance creation</category><body package="WikiBuilder">new	^super new initialize</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>