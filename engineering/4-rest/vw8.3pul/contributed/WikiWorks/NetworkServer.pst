<?xml version="1.0"?><st-source><!-- Name: NetworkServerComment: The network layer for the Wiki.  It should probably use more modern VW facilities, but this is working "legacy" codeDbIdentifier: psql_public_cst_2007DbTrace: 92365DbUsername: niallrDbVersion: 7.10.1 - 2DevelopmentPrerequisites: #(#(#any 'FTP' ''))PackageName: NetworkServerParcel: #('NetworkServer')ParcelName: NetworkServerPrerequisiteDescriptions: #(#(#name 'FTP' #componentType #package))PrerequisiteParcels: #(#('FTP' ''))PrintStringCache: (7.10.1 - 2,niallr)Version: 7.10.1 - 2Pre-Unload Block: 	[:pkg | WikiWorks.NetworkServer preUnloadActionFor: pkg ]Date: 4:58:34 PM January 26, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 26, 2016 at 4:58:34 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NetworkSession</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream peerAddress peerName </inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Network-Framework</category><attributes><package>NetworkServer</package></attributes></class><class><name>NetworkRequestHandler</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent users </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Framework</category><attributes><package>NetworkServer</package></attributes></class><comment><class-id>WikiWorks.NetworkRequestHandler</class-id><body>A NetworkRequestHandler handles NetworkRequests/NetworkSessions that are given to it.  NetworkRequests/NetworkSessions come from the NetworkServer, but often a NetworkRequestHandler will pass them on to other NetworkRequestHandlers.  Thus, sometimes there is a tree of NetworkRequestHandlers.Subclasses must implement the following messages:	interaction		handle:Instance Variables:	parent	&lt;NetworkServer | NetworkRequestHandler&gt;	users	&lt;Dictionary&gt;	Users authorized to be handled by this handler.</body></comment><class><name>NetworkServer</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listeningSocket ipAddress serverProcess sessionManager handler </inst-vars><class-inst-vars>current </class-inst-vars><imports>			private IOConstants.*			</imports><category>Network-Framework</category><attributes><package>NetworkServer</package></attributes></class><comment><class-id>WikiWorks.NetworkServer</class-id><body>IPServer provides an abstract class for Internet servers.Subclasses must implement the following messages:	private		handleConnection:Instance Variables:	listeningSocket	&lt;SocketAccessor&gt;  The server socket to which connections are made	hostname	&lt;String&gt;  Hostname for above socket; typically just for reference and usually can be wrong without problems.	port	&lt;Integer&gt;  Port number for above socket	serverProcess	&lt;Process&gt;  Process dedicated to accepting connections on the listeningSocketClass Variables:	AllServers	&lt;List of: IPServer&gt;  All instances of IPServer subclasses.	AutoStartServers	&lt;List of: IPServer&gt;  Those IPServers marked for automatic restart upon return-from-snapshot.	Hostname	&lt;String&gt;  Name of host machine; can usually be wrong or only of local meaning ('localhost') without problems.	ExtraRobust	&lt;Boolean&gt;  Indicates wheter a special restarting server loop should be`used, which helps work around socket oddities on Windows.	ChangeWhileRunningSignal	&lt;Signal&gt;  A signal raised when an attempt is made to alter a running server in ways that require it to be stopped first.</body></comment><class><name>VolitileConnection</name><environment>WikiWorks</environment><super>OS.ExternalConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Socket</category><attributes><package>NetworkServer</package></attributes></class><class><name>VolitileWriteStream</name><environment>WikiWorks</environment><super>OS.ExternalWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Network-Socket</category><attributes><package>NetworkServer</package></attributes></class><class><name>NetworkRequest</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command parameters session </inst-vars><class-inst-vars>commands </class-inst-vars><imports>			private IOConstants.*			</imports><category>Network-Framework</category><attributes><package>NetworkServer</package></attributes></class><class><name>VolitileEncodedStreamConstructor</name><environment>WikiWorks</environment><super>OS.ExternalEncodedStreamConstructor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Socket</category><attributes><package>NetworkServer</package></attributes></class><class><name>SessionManager</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sessions statusStream statusLock statisticsStream statisticsLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Framework</category><attributes><package>NetworkServer</package></attributes></class><class><name>StreamAdapter</name><environment>WikiWorks</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream elementSpecies readStream writeStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>NetworkServer</package></attributes></class><class><name>ConfigurationSection</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name dataMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>NetworkServer</package></attributes></class><class><name>VolitileReadStream</name><environment>WikiWorks</environment><super>OS.ExternalReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Network-Socket</category><attributes><package>NetworkServer</package></attributes></class><class><name>VolitileSocketAccessor</name><environment>WikiWorks</environment><super>OS.SocketAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Socket</category><attributes><package>NetworkServer</package></attributes></class><class><name>VolitileReadAppendStream</name><environment>WikiWorks</environment><super>OS.ExternalReadAppendStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Network-Socket</category><attributes><package>NetworkServer</package></attributes></class><class><name>ConfigurationRegistry</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>NetworkServer</package></attributes></class><shared-variable><name>ChangeWhileRunningSignal</name><environment>WikiWorks.NetworkServer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>NetworkServer</package></attributes></shared-variable><shared-variable><name>AutoStartServers</name><environment>WikiWorks.NetworkServer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>NetworkServer</package></attributes></shared-variable><shared-variable><name>Hostname</name><environment>WikiWorks.NetworkServer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>NetworkServer</package></attributes></shared-variable><shared-variable><name>AllServers</name><environment>WikiWorks.NetworkServer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>NetworkServer</package></attributes></shared-variable><shared-variable><name>ExternalIOAccessorInactiveErrorSignal</name><environment>WikiWorks.VolitileReadStream</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>NetworkServer</package></attributes></shared-variable><methods><class-id>WikiWorks.NetworkSession</class-id> <category>accessing</category><body package="NetworkServer">close	stream close</body><body package="NetworkServer">nextRequest	| aRequest |	aRequest := stream next.	aRequest session: self.	^aRequest</body><body package="NetworkServer">nextResponse: aResponse 	^stream nextPut: aResponse</body><body package="NetworkServer">peerAddress	^peerAddress</body><body package="NetworkServer">peerName	^peerName</body><body package="NetworkServer">stream	^stream</body></methods><methods><class-id>WikiWorks.NetworkSession</class-id> <category>testing</category><body package="NetworkServer">closed	^stream atEnd</body></methods><methods><class-id>WikiWorks.NetworkSession</class-id> <category>initialize-release</category><body package="NetworkServer">release	stream close.	super release</body><body package="NetworkServer">socket: aSocket 	peerAddress := aSocket getPeer.	"peerName := peerAddress hostName."	peerName := IPSocketAddress bytesToName: peerAddress hostAddress.	stream := StreamAdapter on: aSocket readAppendStream for: self requestClass</body></methods><methods><class-id>WikiWorks.NetworkSession</class-id> <category>defaults</category><body package="NetworkServer">requestClass	^NetworkRequest</body></methods><methods><class-id>WikiWorks.NetworkSession</class-id> <category>responding</category><body package="NetworkServer">answerWith: aResponse 	^self stream nextPut: aResponse</body></methods><methods><class-id>WikiWorks.NetworkSession class</class-id> <category>instance creation</category><body package="NetworkServer">fromSocket: aSocket 	| aSession |	aSession := self new.	aSession socket: aSocket.	^aSession</body></methods><methods><class-id>WikiWorks.NetworkRequestHandler</class-id> <category>authorization</category><body package="NetworkServer">addUser: nameString password: passwordString 	nameString isNil | passwordString isNil ifTrue: [^self].	users ifNil: [users := Dictionary new].	users at: (self encode: nameString password: passwordString)		put: nameString</body><body package="NetworkServer">authorize: key 	^(parent authorize: key) 		and: [users isNil or: [self privateAuthorize: key]]</body><body package="NetworkServer">authorize: nameString password: passwordString 	^(parent authorize: nameString password: passwordString) and: 			[users isNil 				or: [self privateAuthorize: nameString password: passwordString]]</body><body package="NetworkServer">encode: nameString password: passwordString 	"Encode per RFC1421 of the username:password combination."	| plain plainSize i chars stream code |	nameString isNil | passwordString isNil ifTrue: [^''].	chars := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.	plain := (nameString , ':' , passwordString) asByteArray.	plainSize := plain size.	[plain size \\ 3 ~= 0] whileTrue: [plain := plain , #(0)].	i := 1.	stream := (String new: plainSize) writeStream.	[i &lt; plain size] whileTrue: 			[stream				nextPut: (chars at: (plain at: i) // 4 + 1);				nextPut: (chars at: (plain at: i) \\ 4 * 16 + ((plain at: i + 1) // 16) + 1);				nextPut: (chars 							at: (plain at: i + 1) \\ 16 * 4 + ((plain at: i + 2) // 64) + 1);				nextPut: (chars at: (plain at: i + 2) \\ 64 + 1).			i := i + 3].	code := stream contents.	i := code size.	plain size - plainSize timesRepeat: 			[code at: i put: $=.			i := i - 1].	^code</body><body package="NetworkServer">privateAuthorize: key 	^(users at: key ifAbsent: []) notNil</body><body package="NetworkServer">privateAuthorize: nameString password: passwordString 	^(users at: (self encode: nameString password: passwordString) ifAbsent: []) 		= nameString</body><body package="NetworkServer">removeUser: nameString 	users ifNil: [^self].	users copy 		keysAndValuesDo: [:key :value | nameString = value ifTrue: [users removeKey: key]].	users isEmpty ifTrue: [users := nil]</body></methods><methods><class-id>WikiWorks.NetworkRequestHandler</class-id> <category>defaults</category><body package="NetworkServer">defaultResponse	^self responseClass new</body><body package="NetworkServer">responseClass	^Smalltalk.Net.FTPResponse</body></methods><methods><class-id>WikiWorks.NetworkRequestHandler</class-id> <category>accessing</category><body package="NetworkServer">depth	"^an IntegerThis is how deep I am in the HTTP request location.  E.g. if I am 'dick' in http://x.com/tom/dick/harry/ then I would return 2.  Tom would return 1 and harry would return 3."	^parent isNil ifTrue: [1] ifFalse: [parent depth + 1]</body><body package="NetworkServer">initiator	^parent initiator</body><body package="NetworkServer">parent	^parent</body><body package="NetworkServer">parent: aRequestHandler 	parent := aRequestHandler</body></methods><methods><class-id>WikiWorks.NetworkRequestHandler</class-id> <category>interaction</category><body package="NetworkServer">handle: aSession 	self subclassResponsibility</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>authorization</category><body package="NetworkServer">authorize: aRequest 	^true</body><body package="NetworkServer">authorize: aName password: aPassword 	^true</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>accessing</category><body package="NetworkServer">autoStart	^self shouldAutoStart</body><body package="NetworkServer">autoStart: aBoolean 	aBoolean 		ifTrue: [self shouldAutoStart ifFalse: [AutoStartServers add: self]]		ifFalse: [self shouldAutoStart ifTrue: [AutoStartServers remove: self]]</body><body package="NetworkServer">depth	"I am the root of handlers, thus have no parents"	^0</body><body package="NetworkServer">handler	^handler</body><body package="NetworkServer">handler: aRequestHandler 	handler := aRequestHandler.	handler parent: self</body><body package="NetworkServer">hostname	^ipAddress hostName</body><body package="NetworkServer">initiator	^self</body><body package="NetworkServer">ipAddress	^ipAddress</body><body package="NetworkServer">ipAddress: anIPAddress	anIPAddress = ipAddress ifTrue:[^self].	self isRunning ifTrue: [self class changeWhileRunningSignal raiseRequest].	ipAddress := anIPAddress</body><body package="NetworkServer">port	^ipAddress port</body><body package="NetworkServer">port: anInteger 	anInteger = ipAddress port ifTrue: [^self].	self isRunning ifTrue: [self class changeWhileRunningSignal raiseRequest].	ipAddress port: anInteger</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>configuration</category><body package="NetworkServer">configureFrom: aConfigurationSection 	self class inProduction 		ifTrue: [sessionManager configureFrom: aConfigurationSection].	ipAddress := self socketAddressClass					hostName: (aConfigurationSection at: 'host' ifAbsent: [self defaultHostName])					port: (aConfigurationSection at: 'port' ifAbsent: [self defaultPort]) asNumber.	self startOn: ipAddress</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>defaults</category><body package="NetworkServer">defaultHostName	^self class defaultHostName</body><body package="NetworkServer">defaultListenBacklog	^1</body><body package="NetworkServer">defaultPort	^self class defaultPort</body><body package="NetworkServer">defaultRequestHandler	^self requestHandlerClass new</body><body package="NetworkServer">defaultServerAddress	^self class defaultServerAddress</body><body package="NetworkServer">defaultServerProcessPriority	^self class inProduction 		ifTrue: [Processor userInterruptPriority]		ifFalse: [Processor userInterruptPriority - 1]</body><body package="NetworkServer">requestHandlerClass	^NetworkRequestHandler</body><body package="NetworkServer">sessionClass	^NetworkSession</body><body package="NetworkServer">sessionManagerClass	^SessionManager</body><body package="NetworkServer">socketAccessorClass	^VolitileSocketAccessor</body><body package="NetworkServer">socketAddressClass	^self class defaultAddressClass</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>initialize-release</category><body package="NetworkServer">deleteFromSystem	ObjectMemory removeDependent: self.	self release</body><body package="NetworkServer">initialize	ipAddress := self defaultServerAddress.	sessionManager := self sessionManagerClass new.	self handler: self defaultRequestHandler.	self install</body><body package="NetworkServer">install	ObjectMemory removeDependent: self.	ObjectMemory addDependent: self.	(AllServers includes: self) ifFalse: [AllServers add: self]</body><body package="NetworkServer">release	self shutdown.	sessionManager release.	self autoStart: false.	AllServers remove: self ifAbsent: [].	super release</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>printing</category><body package="NetworkServer">displayString	^self shouldAutoStart 		ifFalse: [super displayString]		ifTrue: [super displayString , '	' , 'auto start']</body><body package="NetworkServer">printOn: aStream 	"Append to the argument aStream a sequence of characters 	that describes the receiver."	aStream print: self class.	aStream tab.	aStream 		nextPutAll: (self isRunning ifTrue: [' active '] ifFalse: [' inactive ']).	aStream tab.	aStream		nextPutAll: self hostname;		nextPutAll: ':';		nextPutAll: self port printString</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>interaction</category><body package="NetworkServer">handle: aSocket 	InputState default ctrlDown ifTrue: [self halt].	[self handleSession: (self sessionClass fromSocket: aSocket)] 		on: aSocket errorReporter errorSignal		do: 			[:ex | 			self log: 'Failed in handleConnection: ' , ex messageText.			ex return]</body><body package="NetworkServer">handleSession: session 	handler handle: session</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>testing</category><body package="NetworkServer">isRunning	^self socketIsActive and: [self processIsActive]</body><body package="NetworkServer">processIsActive	^serverProcess notNil and: [serverProcess suspendedContext notNil]</body><body package="NetworkServer">shouldAutoStart	^AutoStartServers includes: self</body><body package="NetworkServer">socketIsActive	^listeningSocket notNil and: [listeningSocket isActive]</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>server accessing</category><body package="NetworkServer">listenBacklog	^self defaultListenBacklog</body><body package="NetworkServer">serverName	^'Wiki'</body><body package="NetworkServer">serverProtocol	^self subclassResponsibility</body><body package="NetworkServer">serverVersion	^'0.6'</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>logging</category><body package="NetworkServer">log: aString 	sessionManager statusStreamDo: 			[:ws | 			Timestamp now sendOver: ws.			ws nextPutAll: ': '.			ws nextPutAll: aString.			ws cr.			ws flush]</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>private - startup/shutdown</category><body package="NetworkServer">offerToOverrideStart	"offer to force-close any other sockets 	that are connected to the given server's address"	self class inProduction 		ifTrue: 			[(Dialog 				confirm: 'Another socket is already using this address.\Close it, and also orphan sockets?' 						withCRs) 					ifFalse: [^false]].	self overrideSockets.	AllServers keysAndValuesDo: [:serverIndex :server|		server ipAddress = ipAddress			ifTrue:[AllServers changed: #at: with: serverIndex]].	ObjectMemory garbageCollect.	(Delay forSeconds: 1) wait.	^true</body><body package="NetworkServer">overrideSockets	| otherSockets |	otherSockets := SocketAccessor registry select:[:ea | ea isKindOf: SocketAccessor].	otherSockets := otherSockets select: 					[:accessor | 					[accessor isActive not or: 							[accessor getName = ipAddress]] 							on: OsError							do: [:ex | ex return: true	"unable to getName"]].	otherSockets do: [:sa | sa close]</body><body package="NetworkServer">startRequest	"request startUp of the receiver offering to close conflicting ports. 	Return true if successful, false on failure"	self isRunning ifTrue: [^true].	^	[self startup.	true] on: OsError			do: 				[:ex | 				(OSErrorHolder existingReferentSignal accepts: ex signal) 					ifTrue: [self offerToOverrideStart ifTrue: [ex restart]].				ex return: false]</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>updating</category><body package="NetworkServer">returnFromSnapshot	self shouldAutoStart ifTrue: [self startup]</body><body package="NetworkServer">update: anAspectSymbol 	anAspectSymbol == #aboutToQuit ifTrue: [self shutdown].	anAspectSymbol == #returnFromSnapshot ifTrue: [self returnFromSnapshot]</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>private</category><body package="NetworkServer">serverLoop		[(Delay forMilliseconds: 20) wait.	self socketIsActive] whileTrue: 				[				[sessionManager manageSessionForServer: self					andClient: listeningSocket accept] 						on: listeningSocket errorReporter errorSignal						do: 							[:ex | 							self log: 'Failed in serveLoop: ' , ex messageText.							(Delay forMilliseconds: 100) wait.							ex return]]</body></methods><methods><class-id>WikiWorks.NetworkServer</class-id> <category>startup/shutdown</category><body package="NetworkServer">shutdown	self processIsActive ifTrue: [serverProcess terminate].	serverProcess := nil.	self socketIsActive ifTrue: [listeningSocket close].	listeningSocket := nil.	self log: self class name , ' at ' , self hostname, ':', self port printString , ' shutdown succeeded'</body><body package="NetworkServer">startOn: anIPAddress	[self ipAddress: anIPAddress] on: self class changeWhileRunningSignal		do: 			[:ex | 			self shutdown.			ex restart].	self startRequest</body><body package="NetworkServer">startup	self isRunning ifTrue: [^self].	listeningSocket := self socketAccessorClass 							family: self socketAccessorClass AF_INET							type: self socketAccessorClass SOCK_STREAM.	listeningSocket soReuseaddr: true.	[listeningSocket bindTo: ipAddress]		ifCurtailed: [listeningSocket close].	listeningSocket listenFor: self listenBacklog.	serverProcess := [[self serverLoop] ensure: [self shutdown]] 				forkAt: self defaultServerProcessPriority.	self log: self class name , ' ' , self hostname , ':' , self port printString 				, ' startup succeeded'</body></methods><methods><class-id>WikiWorks.NetworkServer class</class-id> <category>Signal constants</category><body package="NetworkServer">changeWhileRunningSignal	^ChangeWhileRunningSignal</body></methods><methods><class-id>WikiWorks.NetworkServer class</class-id> <category>instance creation</category><body package="NetworkServer">current	current ifNil: 			[current := self new.			current autoStart: true].	^current</body><body package="NetworkServer">new	^super new initialize</body><body package="NetworkServer">openOn: portNumber handler: handler 	"Starts a NetworkServer on Port portNumber related to the handler."	| aServer |	aServer := self new.	aServer handler: handler.	aServer startOn: (self defaultServerAddress port: portNumber).	^aServer</body></methods><methods><class-id>WikiWorks.NetworkServer class</class-id> <category>configuration</category><body package="NetworkServer">defaultConfiguration	| configurationFile |	configurationFile := ObjectMemory imagePrefix asFilename tail , '.cfg'.	configurationFile asFilename definitelyExists ifFalse: [^nil].	^ConfigurationRegistry fromFileNamed: configurationFile</body></methods><methods><class-id>WikiWorks.NetworkServer class</class-id> <category>server accessing</category><body package="NetworkServer">defaultAddressClass	^IPSocketAddress</body><body package="NetworkServer">defaultHostName	^self defaultAddressClass hostNameByAddress: self defaultAddressClass thisHost</body><body package="NetworkServer">defaultPort	^0</body><body package="NetworkServer">defaultServerAddress	^self defaultAddressClass hostName: self defaultHostName port: self defaultPort</body></methods><methods><class-id>WikiWorks.NetworkServer class</class-id> <category>server controls</category><body package="NetworkServer">flush	current notNil: [current deleteFromSystem].	current := nil</body><body package="NetworkServer">flushAll	self allInstances do: [:each | each deleteFromSystem].	current := nil</body><body package="NetworkServer">start	self current startup.	self current autoStart: true</body><body package="NetworkServer">startOn: anIPAddress 	self current startOn: anIPAddress</body><body package="NetworkServer">stop	self current shutdown.	self current autoStart: false</body></methods><methods><class-id>WikiWorks.NetworkServer class</class-id> <category>class initialization</category><body package="NetworkServer">initialize	"self initialize"	ObjectMemory removeDependent: self.	ObjectMemory addDependent: self.	AllServers ifNil: [AllServers := List new].	AutoStartServers ifNil: [AutoStartServers := List new].	Hostname ifNil: [self initializeHostname].	self initializeSignals</body><body package="NetworkServer">initializeHostname	Hostname := SocketAccessor getHostname</body><body package="NetworkServer">initializeSignals	ChangeWhileRunningSignal := Object errorSignal newSignal.	ChangeWhileRunningSignal 		notifierString: 'Can not change port of running server'.	ChangeWhileRunningSignal nameClass: self message: #changeWhileRunningSignal</body></methods><methods><class-id>WikiWorks.NetworkServer class</class-id> <category>testing</category><body package="NetworkServer">inProduction	| headless |	headless := Smalltalk at: #HeadlessImage ifAbsent: [nil].	^headless isBehavior and: [headless default isHeadless]</body></methods><methods><class-id>WikiWorks.NetworkServer class</class-id> <category>parcel load/unload/save</category><body package="NetworkServer">preUnloadActionFor: aParcel 	"A Parcel's pre-unload action must be a class method taking one	 argument, the Parcel being unloaded.  Fill-out this template and accept.	 Note that you can give the method whatever selector you want.	 You don't have to use preUnloadActionFor:.	 The pre-unload action should ensure that the Parcel unloads cleanly.	 This usually includes things like checking that any open applications	 derived from the Parcel are closed, and that any long-lived data strutures	 using instances of classes defined in the Parcel are emptied of those	 instances.	ApplicationModel checkUnloadOfApplicationsDefinedBy: aParcel is provided	to close-down any open applications defined by a parcel."	ObjectMemory removeDependent: self.	self flushAll</body></methods><methods><class-id>WikiWorks.NetworkServer class</class-id> <category>updating</category><body package="NetworkServer">update: aSymbol 	aSymbol == #returnFromSnapshot ifTrue: [self initializeHostname]</body></methods><methods><class-id>WikiWorks.VolitileConnection</class-id> <category>stream creation</category><body package="NetworkServer">streamConstructorClass	^VolitileEncodedStreamConstructor</body></methods><methods><class-id>WikiWorks.VolitileWriteStream</class-id> <category>accessing</category><body package="NetworkServer">flush	"Check to see if the ioaccessor is active then flush"	self ioConnection isActive 		ifFalse: [self class externalIOAccessorInactiveErrorSignal raise].	^super flush</body><body package="NetworkServer">nextPut: anObject 	self ioConnection isActive 		ifFalse: [self class externalIOAccessorInactiveErrorSignal raise].	^super nextPut: anObject</body><body package="NetworkServer">size	"Check to see if the ioaccessor is active"	self ioConnection isActive 		ifFalse: [self class externalIOAccessorInactiveErrorSignal raise].	^super size</body></methods><methods><class-id>WikiWorks.VolitileWriteStream class</class-id> <category>signal constants</category><body package="NetworkServer">externalIOAccessorInactiveErrorSignal	^VolitileReadStream externalIOAccessorInactiveErrorSignal</body></methods><methods><class-id>WikiWorks.VolitileWriteStream class</class-id> <category>class initialization</category><body package="NetworkServer">initialize	"Initialize signals."	super initialize</body></methods><methods><class-id>WikiWorks.NetworkRequest</class-id> <category>interaction</category><body package="NetworkServer">answerWith: aResponse 	^session answerWith: aResponse</body><body package="NetworkServer">answerWithAuthenticationResponseFromRealm: aRealmName 	^session answerWithAuthenticationResponseFromRealm: aRealmName</body></methods><methods><class-id>WikiWorks.NetworkRequest</class-id> <category>accessing</category><body package="NetworkServer">command	^command</body><body package="NetworkServer">command: aString 	command := aString.	^self</body><body package="NetworkServer">firstParameter	^self parameterAt: 1</body><body package="NetworkServer">next	^session nextRequest</body><body package="NetworkServer">parameterAt: anInteger 	^parameters size &lt; anInteger 		ifTrue: ['']		ifFalse: [parameters at: anInteger]</body><body package="NetworkServer">parameters	^parameters</body><body package="NetworkServer">parameters: aCollection 	parameters := aCollection.	^self</body><body package="NetworkServer">peerName	^session peerName</body><body package="NetworkServer">session	^session</body><body package="NetworkServer">session: aSession 	session := aSession</body><body package="NetworkServer">shift	command := self firstParameter asUppercase.	parameters := parameters size = 1 				ifTrue: [#()]				ifFalse: [parameters copyFrom: 2 to: parameters size].	^command</body></methods><methods><class-id>WikiWorks.NetworkRequest</class-id> <category>initialize-release</category><body package="NetworkServer">initialize	command := ''.	parameters := #()</body></methods><methods><class-id>WikiWorks.NetworkRequest</class-id> <category>testing</category><body package="NetworkServer">isValidCommand	^self class commands contains: [:each | command sameAs: each]</body></methods><methods><class-id>WikiWorks.NetworkRequest</class-id> <category>printing</category><body package="NetworkServer">printOn: aStream 	aStream nextPutAll: command.	parameters do: 			[:each | 			aStream space.			aStream nextPutAll: each]</body></methods><methods><class-id>WikiWorks.NetworkRequest</class-id> <category>reading</category><body package="NetworkServer">readRequestLineFrom: aStream 	| requestLineStream |	aStream lineEndCRLF.	requestLineStream := aStream nextLine readStream.	command := (requestLineStream upTo: Character space) asUppercase.	parameters := (requestLineStream upToEnd tokensBasedOn: Character space) 				reject: [:token | token isEmpty]</body><body package="NetworkServer">receiveOver: aStream 	self readRequestLineFrom: aStream</body></methods><methods><class-id>WikiWorks.NetworkRequest class</class-id> <category>accessing</category><body package="NetworkServer">commands	^commands</body></methods><methods><class-id>WikiWorks.NetworkRequest class</class-id> <category>class initialization</category><body package="NetworkServer">initialize	"self initialize"	commands := #()</body></methods><methods><class-id>WikiWorks.NetworkRequest class</class-id> <category>instance creation</category><body package="NetworkServer">new	^super new initialize</body><body package="NetworkServer">receiveOver: aStream 	^self new receiveOver: aStream</body></methods><methods><class-id>WikiWorks.VolitileEncodedStreamConstructor</class-id> <category>streams</category><body package="NetworkServer">readAppendStream	"Answer a readAppend stream connected to the file represented by the receiver."	^self addEncodingTo: (VolitileReadAppendStream on: dataRepository)</body><body package="NetworkServer">readStream	"Answer a read stream connected to the file represented by the receiver."	^self addEncodingTo: (VolitileReadStream on: dataRepository)</body><body package="NetworkServer">writeStream	"Answer a write stream connected to the file represented by the receiver."	^self addEncodingTo: (VolitileWriteStream on: dataRepository)</body></methods><methods><class-id>WikiWorks.SessionManager</class-id> <category>configuration</category><body package="NetworkServer">configureFrom: aConfigurationSection 	statusLock critical: 			[statusStream notNil: [statusStream close].			statusStream := (aConfigurationSection at: 'statusLog'						ifAbsent: ['status.log']) asFilename 						readAppendStream].	statisticsLock critical: 			[statisticsStream notNil: [statisticsStream close].			statisticsStream := (aConfigurationSection at: 'accessLog'						ifAbsent: ['access.log']) asFilename 						readAppendStream]</body></methods><methods><class-id>WikiWorks.SessionManager</class-id> <category>defaults</category><body package="NetworkServer">defaultSessionPriority	^NetworkServer inProduction 		ifTrue: [Processor userSchedulingPriority]		ifFalse: [Processor userSchedulingPriority - 1]</body></methods><methods><class-id>WikiWorks.SessionManager</class-id> <category>initialize-release</category><body package="NetworkServer">initialize	sessions := Dictionary new.	statusLock := Semaphore forMutualExclusion.	statisticsLock := Semaphore forMutualExclusion</body><body package="NetworkServer">release	sessions do: [:each | each terminate].	sessions := Dictionary new.	statusStream notNil: [statusStream close].	statusStream := nil.	statisticsStream notNil: [statisticsStream close].	statisticsStream := nil.	super release</body></methods><methods><class-id>WikiWorks.SessionManager</class-id> <category>interaction</category><body package="NetworkServer">manageSessionForServer: aServer andClient: aClient 	| session |	session := 			[[aServer handle: aClient] ensure: 					[sessions removeKey: aClient ifAbsent: [].					aClient close]] 					newProcess.	sessions at: aClient put: session.	session priority: self defaultSessionPriority.	session resume</body></methods><methods><class-id>WikiWorks.SessionManager</class-id> <category>accessing</category><body package="NetworkServer">statisticsStreamDo: aBlock 	statisticsStream ifNil: [^self].	^statisticsLock critical: 			[statisticsStream notNil: 					[statisticsStream openIfClosed.					statisticsStream closed ifTrue: [statisticsStream := nil]].			statisticsStream notNil: [aBlock value: statisticsStream]]</body><body package="NetworkServer">statusStreamDo: aBlock 	statusStream ifNil: [^self].	^statusLock critical: 			[statusStream notNil: 					[statusStream openIfClosed.					statusStream closed ifTrue: [statusStream := nil]].			statusStream notNil: [aBlock value: statusStream]]</body></methods><methods><class-id>WikiWorks.SessionManager class</class-id> <category>instance creation</category><body package="NetworkServer">new	^super new initialize</body></methods><methods><class-id>WikiWorks.StreamAdapter</class-id> <category>testing</category><body package="NetworkServer">atEnd	^self isExternalStream ifTrue: [stream closed] ifFalse: [stream atEnd]</body><body package="NetworkServer">isExternalStream	^stream isExternalStream</body><body package="NetworkServer">isReadable	^stream isReadable</body><body package="NetworkServer">isWritable	^stream isWritable</body><body package="NetworkServer">needsFileLineEndConversion	^stream needsFileLineEndConversion</body></methods><methods><class-id>WikiWorks.StreamAdapter</class-id> <category>status</category><body package="NetworkServer">close	stream close</body></methods><methods><class-id>WikiWorks.StreamAdapter</class-id> <category>accessing</category><body package="NetworkServer">contents	self upToEnd.	^readStream contents</body><body package="NetworkServer">flush	stream flush</body><body package="NetworkServer">next	| element |	element := elementSpecies receiveOver: stream.	readStream nextPut: element.	^element</body><body package="NetworkServer">nextPut: anObject 	writeStream nextPut: anObject.	anObject sendOver: stream.	stream commit.	^anObject</body></methods><methods><class-id>WikiWorks.StreamAdapter</class-id> <category>constants</category><body package="NetworkServer">lineEndCR	self needsFileLineEndConversion ifTrue: [stream lineEndCR]</body><body package="NetworkServer">lineEndCRLF	self needsFileLineEndConversion ifTrue: [stream lineEndCRLF]</body><body package="NetworkServer">lineEndLF	self needsFileLineEndConversion ifTrue: [stream lineEndLF]</body><body package="NetworkServer">lineEndTransparent	self needsFileLineEndConversion ifTrue: [stream lineEndTransparent]</body></methods><methods><class-id>WikiWorks.StreamAdapter</class-id> <category>private</category><body package="NetworkServer">on: aStream for: anObject 	stream := aStream.	elementSpecies := anObject.	readStream := (self contentsSpecies new: 32) writeStream.	writeStream := (self contentsSpecies new: 32) readWriteStream</body></methods><methods><class-id>WikiWorks.StreamAdapter class</class-id> <category>instance creation</category><body package="NetworkServer">on: aStream for: anObject 	^self basicNew on: aStream for: anObject</body></methods><methods><class-id>WikiWorks.ConfigurationSection</class-id> <category>querying</category><body package="NetworkServer">at: key	^self at: key ifAbsent: [self error: 'No such key: ', key printString]</body><body package="NetworkServer">at: key ifAbsent: aOneArgumentBlock 	^dataMap at: key asLowercase ifAbsent: aOneArgumentBlock</body><body package="NetworkServer">keys	^dataMap keys</body><body package="NetworkServer">keysAndValuesDo: aTwoArgumentBlock 	^dataMap keysAndValuesDo: aTwoArgumentBlock</body><body package="NetworkServer">name	^name</body></methods><methods><class-id>WikiWorks.ConfigurationSection</class-id> <category>adding</category><body package="NetworkServer">at: key put: value	dataMap at: key asLowercase put: value</body></methods><methods><class-id>WikiWorks.ConfigurationSection</class-id> <category>initializing</category><body package="NetworkServer">initialize: aString 	dataMap := Dictionary new.	name := aString asLowercase</body></methods><methods><class-id>WikiWorks.ConfigurationSection</class-id> <category>printing</category><body package="NetworkServer">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: name;		nextPut: $)</body></methods><methods><class-id>WikiWorks.ConfigurationSection class</class-id> <category>instance creation</category><body package="NetworkServer">named: aString	^self new initialize: aString; yourself</body></methods><methods><class-id>WikiWorks.VolitileReadStream</class-id> <category>accessing</category><body package="NetworkServer">next	self ioConnection isActive 		ifFalse: [self class externalIOAccessorInactiveErrorSignal raise].	^super next</body></methods><methods><class-id>WikiWorks.VolitileReadStream class</class-id> <category>signal constants</category><body package="NetworkServer">externalIOAccessorInactiveErrorSignal	ExternalIOAccessorInactiveErrorSignal isNil 		ifTrue: 			[ExternalIOAccessorInactiveErrorSignal := (Object errorSignal newSignal)						notifierString: 'IO Accessor attached to this stream is no longer active';						nameClass: self message: #externalIOAccessorInactiveErrorSignal].	^ExternalIOAccessorInactiveErrorSignal</body></methods><methods><class-id>WikiWorks.VolitileReadStream class</class-id> <category>class initialization</category><body package="NetworkServer">initialize	"Initialize signals."	super initialize.	self externalIOAccessorInactiveErrorSignal</body></methods><methods><class-id>WikiWorks.VolitileSocketAccessor</class-id> <category>instance creation</category><body package="NetworkServer">accept	| child |		[[(child := super accept) isNil] on: OsNeedRetryError		do: [:ex | ex return: true]] 			whileTrue.	^child</body></methods><methods><class-id>WikiWorks.VolitileSocketAccessor</class-id> <category>defaults</category><body package="NetworkServer">connectionClass	^VolitileConnection</body></methods><methods><class-id>WikiWorks.VolitileSocketAccessor</class-id> <category>private</category><body package="NetworkServer">primReadInto: buffer startingAt: index for: count 	| result |	OSErrorHolder invalidArgumentsSignal handle: 			[:ex | 			(handle notNil and: 					[buffer class == ByteArray 						and: [index &gt; 0 and: [count &gt; 0 and: [index + count &lt; buffer size]]]]) 				ifTrue: [self class peerFaultSignal raiseRequest]				ifFalse: [self reportErrorProceeding].			ex return]		do: 			[result := super 						primReadInto: buffer						startingAt: index						for: count].	^result</body><body package="NetworkServer">primWriteFrom: buffer startingAt: index for: count 	| result |	OSErrorHolder invalidArgumentsSignal handle: 			[:ex | 			(handle notNil and: 					[buffer isByteObject 						and: [index &gt; 0 and: [count &gt; 0 and: [index + count &lt;= buffer size]]]]) 				ifTrue: [self class peerFaultSignal raiseRequest]				ifFalse: [self reportErrorProceeding].			ex return]		do: 			[result := super 						primWriteFrom: buffer						startingAt: index						for: count].	^result</body></methods><methods><class-id>WikiWorks.VolitileSocketAccessor class</class-id> <category>instance creation</category><body package="NetworkServer">newTCP	"Appropriate for clients, or for servers with no assigned ports."	^self newTCPserverAtPort: IPSocketAddress anyPort</body><body package="NetworkServer">newTCPclientTo: anIPAddress 	"Create a client socket connected to anIPAddress"	| aSocketAccessor |	aSocketAccessor := self 				family: (SocketAddress domainCodeFromName: #afInet)				type: self sockStream.	[aSocketAccessor connectTo: anIPAddress] 		valueOnUnwindDo: [aSocketAccessor close].	^aSocketAccessor</body></methods><methods><class-id>WikiWorks.VolitileReadAppendStream</class-id> <category>accessing</category><body package="NetworkServer">next	self ioConnection isActive 		ifFalse: [self class externalIOAccessorInactiveErrorSignal raise].	^super next</body></methods><methods><class-id>WikiWorks.VolitileReadAppendStream</class-id> <category>private</category><body package="NetworkServer">on: anIOConnection 	"Initialize the receiver on anIOConnection."	writeStream := VolitileWriteStream on: anIOConnection.	^super on: anIOConnection</body></methods><methods><class-id>WikiWorks.VolitileReadAppendStream class</class-id> <category>signal constants</category><body package="NetworkServer">externalIOAccessorInactiveErrorSignal	^VolitileReadStream externalIOAccessorInactiveErrorSignal</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry</class-id> <category>constructing</category><body package="NetworkServer">addSectionNamed: aString 	"	^	&lt;WikiConfigurationSection&gt;"	^sections add: (ConfigurationSection named: aString asLowercase)</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry</class-id> <category>initializing</category><body package="NetworkServer">initialize	sections := OrderedCollection new</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry</class-id> <category>querying</category><body package="NetworkServer">sectionNamed: name 	^self sectionNamed: name asLowercase		ifAbsent: [self error: 'No section named ' , name printString]</body><body package="NetworkServer">sectionNamed: name ifAbsent: aBlock 	^sections detect: [:first | first name = name asLowercase]		ifNone: [^aBlock value]</body><body package="NetworkServer">sectionsNamed: name 	^sections select: [:each | each name = name asLowercase]</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry</class-id> <category>enumerating</category><body package="NetworkServer">sectionsDo: aOneArgumentBlock 	sections do: aOneArgumentBlock</body><body package="NetworkServer">sectionsNamed: name do: aOneArgumentBlock 	^(self sectionsNamed: name asLowercase) do: aOneArgumentBlock</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry class</class-id> <category>instance creation</category><body package="NetworkServer">fromFileNamed: filename 	"filename		&lt;String&gt;	^				&lt;WikiConfiguration&gt;	Answer a new instance of the receiver parsed from the given file."	| stream configuration currentSection line |	configuration := ConfigurationRegistry new.	stream := filename asFilename readStream.	[stream atEnd] whileFalse: 			[line := (stream upTo: Character cr) trimSeparators.			line isEmpty 				ifFalse: 					[line first = $[ 						ifTrue: [currentSection := self sectionFrom: line into: configuration]						ifFalse: [self keyValuePairFrom: line into: currentSection]]].	stream close.	^configuration</body><body package="NetworkServer">new	^super new initialize</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry class</class-id> <category>private-parsing</category><body package="NetworkServer">keyValuePairFrom: line into: configurationSection	"line		&lt;String like: '... = ...'&gt;"	| stream key value |	stream := ReadStream on: line.	key := (stream upTo: $=) trimSeparators.	value := stream upToEnd trimSeparators.		configurationSection at: key put: value</body><body package="NetworkServer">sectionFrom: line into: wikiConfiguration	"line		&lt;String like: '[...]'&gt;	Private"	^wikiConfiguration addSectionNamed: (line copyFrom: 2 to: line size - 1)</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="NetworkServer">ifNil: nilAlternativeBlock notNil: objectAlternativeBlock 	^objectAlternativeBlock value</body><body package="NetworkServer">notNil: aBlock 	^aBlock value</body><body package="NetworkServer">notNil: objectAlternativeBlock ifNil: nilAlternativeBlock 	^objectAlternativeBlock value</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="NetworkServer">sendOver: aStream 	self printOn: aStream</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="NetworkServer">readFrom: inStream quoteCharacter: quoteCharacter 	"Answer a new String that is determined by reading the stream, inStream.  		Embedded double quotes become the quote Character."	| outStream char |	outStream := (String new: 16) writeStream.	"go to first quote"	inStream skipThrough: quoteCharacter.	[inStream atEnd] whileFalse: 			[char := inStream next.			char = quoteCharacter 				ifTrue: 					[(inStream peekFor: quoteCharacter) 						ifTrue: [outStream nextPut: quoteCharacter]						ifFalse: [^outStream contents]]				ifFalse: [outStream nextPut: char]].	^outStream contents</body><body package="NetworkServer">readFromCQuotedString: aString 	aString trimSeparators first == $" ifFalse: [^aString].	^self readFrom: aString readStream quoteCharacter: $"</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="NetworkServer">asCQuotedString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := (String new: 16) writeStream.	self printOn: aStream quoteCharacter: $".	^aStream contents</body></methods><methods><class-id>Core.String</class-id> <category>printing</category><body package="NetworkServer">printInsideOn: aStream quoteCharacter: quoteCharacter 	1 to: self size		do: 			[:i | 			(aStream nextPut: (self at: i)) == quoteCharacter 				ifTrue: [aStream nextPut: quoteCharacter]]	"embedded quotes get doubled"</body><body package="NetworkServer">printOn: aStream quoteCharacter: quoteCharacter 	aStream nextPut: quoteCharacter.	self printInsideOn: aStream quoteCharacter: quoteCharacter.	aStream nextPut: quoteCharacter</body><body package="NetworkServer">sendOver: aStream 	aStream nextPutAll: self</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="NetworkServer">anyOne	"return any arbitrary element from the reciever, 	subclasses may reimplement for performance"	self do: [:each | ^each].	^self emptyCollectionError</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="NetworkServer">detect: aBlock ifPresent: anOneArgumentBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	answer the evaluation result of anOneArgumentBlock with the first 	element for which aBlock evaluates to true. Answer nil otherwise."	self 		do: [:each | (aBlock value: each) ifTrue: [^anOneArgumentBlock value: each]].	^nil</body><body package="NetworkServer">reject: rejectBlock collect: projectBlock 	| newCollection |	newCollection := self species new.	self do: 			[:element | 			(rejectBlock value: element) 				ifFalse: [newCollection add: (projectBlock value: element)]].	^newCollection</body></methods><methods><class-id>OS.LogicalFilename</class-id> <category>converting</category><body package="NetworkServer">asCQuotedString	^self asFilename asCQuotedString</body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="NetworkServer">isMark	^'-_.!~*''()' includes: self</body><body package="NetworkServer">isUnreserved	^self isAlphaNumeric or: [self isMark]</body></methods><methods><class-id>Core.Character</class-id> <category>printing</category><body package="NetworkServer">sendOver: aStream 	aStream nextPut: self</body></methods><methods><class-id>OS.UnixFilename</class-id> <category>printing</category><body package="NetworkServer">printProtectionOn: aStream 	| protection |	aStream nextPut: (self safeIsDirectory ifTrue: [$d] ifFalse: [$-]).	protection := self getProtection.	aStream nextPut: ((protection bitAnd: (1 bitShift: 8)) = 0 				ifTrue: [$-]				ifFalse: [$r]).	aStream nextPut: ((protection bitAnd: (1 bitShift: 7)) = 0 				ifTrue: [$-]				ifFalse: [$w]).	aStream nextPut: ((protection bitAnd: (1 bitShift: 6)) = 0 				ifTrue: [$-]				ifFalse: [$x]).	aStream nextPut: ((protection bitAnd: (1 bitShift: 5)) = 0 				ifTrue: [$-]				ifFalse: [$r]).	aStream nextPut: ((protection bitAnd: (1 bitShift: 4)) = 0 				ifTrue: [$-]				ifFalse: [$w]).	aStream nextPut: ((protection bitAnd: (1 bitShift: 3)) = 0 				ifTrue: [$-]				ifFalse: [$x]).	aStream nextPut: ((protection bitAnd: (1 bitShift: 2)) = 0 				ifTrue: [$-]				ifFalse: [$r]).	aStream nextPut: ((protection bitAnd: (1 bitShift: 1)) = 0 				ifTrue: [$-]				ifFalse: [$w]).	aStream nextPut: ((protection bitAnd: (1 bitShift: 0)) = 0 				ifTrue: [$-]				ifFalse: [$x])</body></methods><methods><class-id>OS.Filename</class-id> <category>accessing</category><body package="NetworkServer">accessedTime	| dateAndTime |	dateAndTime := self dates at: #accessed ifAbsent: [nil].	^dateAndTime ifNil: [self createdTime]		notNil: [Timestamp fromArray: dateAndTime]</body></methods><methods><class-id>OS.Filename</class-id> <category>converting</category><body package="NetworkServer">asCQuotedString	^self asString asCQuotedString</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="NetworkServer">backup	self moveTo: self asString , '.orig'</body></methods><methods><class-id>OS.Filename</class-id> <category>accessing</category><body package="NetworkServer">createdTime	^Timestamp fromArray: ((self dates at: #created ifAbsent: [nil]) 				ifNil: [self dates detect: [:each | each notNil] ifNone: [Timestamp zero]])</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="NetworkServer">ensureDirectory	self directory = self ifFalse: [self directory ensureDirectory].		[self definitelyExists 		ifTrue: 			[self safeIsDirectory ifTrue: [^self].			self backup].	self makeDirectory] 			on: OsError			do: [:ex | ex return]</body></methods><methods><class-id>OS.Filename</class-id> <category>utilities</category><body package="NetworkServer">filesMatching: pattern do: aBlock 	"Evaluate &lt;block1&gt; on the Filenames of all files in the directory 	named by the receiver whose names are matched by &lt;pattern&gt;."	self directoryContents 		do: [:name | (pattern match: name) ifTrue: [aBlock value: (self construct: name)]]</body></methods><methods><class-id>OS.Filename</class-id> <category>parsing</category><body package="NetworkServer">fullExtension	"Answer the receiver's extension if any.  This is the characters from the	first occurrence of a period to the end, inclusive. E.g. the extension of	'visual.sou' is 'sou', for 'visual.tar.gz', it is 'tar.gz'. Answer nil if 	none.  Note that e.g. .login has no extension."	| rs |	rs := self asString readStream.	rs next == $. ifTrue: [^nil].	rs upTo: $..	^rs upToEnd</body></methods><methods><class-id>OS.Filename</class-id> <category>accessing</category><body package="NetworkServer">modifiedTime	| dateAndTime |	dateAndTime := self dates at: #modified ifAbsent: [nil].	^dateAndTime ifNil: [self statusChangedTime]		notNil: [Timestamp fromArray: dateAndTime]</body></methods><methods><class-id>OS.Filename</class-id> <category>printing</category><body package="NetworkServer">printListOn: aStream using: formatString 	"Try to minic 'ls -d' on unix, with appropriate formatting."	self safeIsDirectory 		ifTrue: 			[| files |			files := (self filenamesMatching: '*') 						asSortedCollection: [:a :b | a asString &lt; b asString].			aStream				nextPutAll: 'Total ';				print: files size;				cr.			files do: [:each | each printOneLineOn: aStream using: formatString]]		ifFalse: [self printOneLineOn: aStream using: formatString]</body><body package="NetworkServer">printModifiedTimeOn: aStream 	| modifiedDate now seconds |	seconds := self modifiedTime.	modifiedDate := Timestamp fromSeconds: seconds.	now := Time totalSeconds.	(seconds - now &gt; (24 * 3600) or: [now - seconds &gt; (6 * 30 * 24 * 3600)]) 		ifTrue: 			[TimestampPrintPolicy 				print: modifiedDate				on: aStream				using: 'mmm dd  yyyy']		ifFalse: 			[TimestampPrintPolicy 				print: modifiedDate				on: aStream				using: 'mmm dd hh:mm']</body><body package="NetworkServer">printOneLineOn: aStream using: formatString 	"Try to minic 'ls -d' on unix, with appropriate formatting."	(formatString includes: $l) 		ifTrue: 			[self printProtectionOn: aStream.			self printSizeOn: aStream.			aStream space.			self printModifiedTimeOn: aStream.			aStream space].	aStream nextPutAll: self tail.	(formatString includes: $l) 		ifTrue: [self safeIsDirectory ifTrue: [aStream nextPut: self separator]].	aStream cr</body><body package="NetworkServer">printProtectionOn: aStream 	aStream nextPut: (self safeIsDirectory ifTrue: [$d] ifFalse: [$-]).	aStream nextPut: (self safeIsReadable ifTrue: [$r] ifFalse: [$-]).	aStream nextPut: (self safeIsWritable ifTrue: [$w] ifFalse: [$-]).	aStream nextPutAll: '-------'</body><body package="NetworkServer">printSizeOn: aStream 	self fileSize 		printOn: aStream		paddedWith: $ 		to: 15		base: 10</body></methods><methods><class-id>OS.Filename</class-id> <category>testing</category><body package="NetworkServer">safeIsDirectory	^[self isDirectory] on: OsError do: [:ex | ex return: false]</body><body package="NetworkServer">safeIsReadable	^[self isReadable] on: OsError do: [:ex | ex return: false]</body><body package="NetworkServer">safeIsWritable	^[self isWritable] on: OsError do: [:ex | ex return: false]</body></methods><methods><class-id>OS.Filename</class-id> <category>accessing</category><body package="NetworkServer">statusChangedTime	| dateAndTime |	dateAndTime := self dates at: #statusChanged ifAbsent: [nil].	^dateAndTime ifNil: [self accessedTime]		notNil: [Timestamp fromArray: dateAndTime]</body></methods><methods><class-id>OS.Filename</class-id> <category>parsing</category><body package="NetworkServer">stem	"Answer the filename suffix as a String without its extension."	| tail periodIndex |	tail := self tail.	periodIndex := tail lastIndexOf: $..	^periodIndex &gt; 1		ifTrue: [tail copyFrom: 1 to: periodIndex - 1]		ifFalse: [tail]</body></methods><methods><class-id>Core.Process</class-id> <category>accessing</category><body package="NetworkServer">adjustPriority: aDelta 	^self priority: self priority + aDelta</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="NetworkServer">copyFrom: start 	start &gt; self size ifTrue: [^self species new].	^self copyFrom: (start max: 1) to: self size</body><body package="NetworkServer">copyTo: stop 	stop &gt; self size ifTrue: [^self copy].	^self copyFrom: 1 to: stop</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>wiki-extensions</category><body package="NetworkServer">nextHunk	| hunk |	hunk := self stream nextHunk.	^hunk isString		ifTrue: [hunk]		ifFalse: [hunk asString].</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="NetworkServer">asTimestamp	^Timestamp fromSeconds: self asInteger</body></methods><methods><class-id>Core.Dictionary</class-id> <category>printing</category><body package="NetworkServer">sendOver: aStream 	"This probably needs to be rewritten, but for now it servers our purpose :)"	self keysDo: [:key | key sendOver: aStream]</body></methods><methods><class-id>Core.Timestamp</class-id> <category>printing</category><body package="NetworkServer">sendOver: aStream 	TimestampPrintPolicy 		print: (TimeZone default convertToGMT: self asSeconds				do: [:date :seconds | Timestamp fromDate: date andTime: (Time fromSeconds: seconds)])		on: aStream		using: 'ddd, dd mmm yyyy hh:mm:ss GMT'</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing</category><body package="NetworkServer">ifNil: nilAlternativeBlock notNil: objectAlternativeBlock 	^nilAlternativeBlock value</body><body package="NetworkServer">notNil: aBlock 	^nil</body><body package="NetworkServer">notNil: objectAlternativeBlock ifNil: nilAlternativeBlock 	^nilAlternativeBlock value</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>printing</category><body package="NetworkServer">sendOver: aStream</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="NetworkServer">niceValue	| result |	Processor activeProcess adjustPriority: -1.	result := self value.	Processor activeProcess adjustPriority: 1.	^result</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>positioning</category><body package="NetworkServer">insensitivePeekForAll: aCollection 	| orig |	self atEnd ifTrue: [^false].	orig := self position.	((self nextAvailable: aCollection size) sameAs: aCollection) 		ifTrue: [^true].	self position: orig.	^false</body><body package="NetworkServer">insensitiveSkipThroughAll: aCollection 	| first length |	(length := aCollection size) = 0 ifTrue: [^self].	first := aCollection at: 1.	[self atEnd] whileFalse: 			[(self next sameAs: first) 				ifTrue: 					[| nonMatch |					nonMatch := 2.										[nonMatch &gt; length ifTrue: [^self	"Success."].					self atEnd ifTrue: [^nil].	"Not found."					self next sameAs: (aCollection at: nonMatch)] 							whileTrue: [nonMatch := nonMatch + 1].					self skip: 1 - nonMatch	"Didn't match, back up."]].	^nil	"Not found."</body><body package="NetworkServer">insensitiveUpToAll: aCollection 	| first length newStream |	(length := aCollection size) = 0 ifTrue: [^self].	first := aCollection at: 1.	newStream := (self contentsSpecies new: 64) writeStream.	[self atEnd] whileFalse: 			[| element |			element := self next.			(element sameAs: first) 				ifTrue: 					[| nonMatch |					nonMatch := 2.										[nonMatch &gt; length ifTrue: [^newStream contents	"Success."].					self atEnd 						ifTrue: 							[1 to: nonMatch - 1 do: [:i | newStream nextPut: (aCollection at: i)].							^newStream contents	"Not found."].					self next sameAs: (aCollection at: nonMatch)] 							whileTrue: [nonMatch := nonMatch + 1].					self skip: 1 - nonMatch	"Didn't match, back up."].			newStream nextPut: element].	^newStream contents	"Not found."</body><body package="NetworkServer">peekForAll: aCollection 	| orig |	self atEnd ifTrue: [^false].	orig := self position.	(self nextAvailable: aCollection size) = aCollection ifTrue: [^true].	self position: orig.	^false</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="NetworkServer">upTo: anObject escaper: anotherObject 	| newStream |	newStream := (self contentsSpecies new: 64) writeStream.	[self atEnd] whileFalse: 			[| element |			(element := self next) = anotherObject 				ifTrue: 					[newStream nextPut: ((self peekFor: anObject) 								ifTrue: [anObject]								ifFalse: [anotherObject])]				ifFalse: 					[element = anObject ifTrue: [^newStream contents].					newStream nextPut: element]].	^newStream contents</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>testing</category><body package="NetworkServer">isValidFilename	"Don't allow people to put strange characters or .. in a file directory. 	If we allowed .., then someone could grab our password file."	self isEmpty ifTrue: [^false].	self = '..' ifTrue: [^false].	^(self contains: [:each | each asInteger &lt; 32 or: [each asInteger &gt; 127]]) 		not</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>copying</category><body package="NetworkServer">makeFilename	"Converting $\ to filename seperator."	| rs ws |	self isValidFilename ifFalse: [^'.'].	rs := self string readStream.	ws := (String new: self size) writeStream.		[ws nextPutAll: (rs upTo: $\).	rs atEnd] 			whileFalse: [ws nextPut: Filename separator].	^ws contents</body></methods><methods><class-id>OS.ExternalReadStream</class-id> <category>accessing</category><body package="NetworkServer">nextHunk	"Answer the next buffers worth of stuff in the Stream 	represented by the receiver. Do at most one actual io operation."	| stream ch |	binary 		ifFalse: 			[" Must do it one character at a time. "			self class endOfStreamSignal handle: [:ex | ^self contentsSpecies new: 0]				do: [ch := self next].			stream := (self contentsSpecies new: readLimit - position) writeStream.			stream nextPut: ch.			[position &lt; (readLimit - 1)] whileTrue: [stream nextPut: self next].			^stream contents].	"Force a new buffer if the current position is at the end"	self class endOfStreamSignal handle: [:ex | ^self contentsSpecies new: 0]		do: [self peek].	^self next: readLimit - position</body></methods><initialize><class-id>WikiWorks.NetworkServer</class-id></initialize><initialize><class-id>WikiWorks.VolitileWriteStream</class-id></initialize><initialize><class-id>WikiWorks.NetworkRequest</class-id></initialize><initialize><class-id>WikiWorks.VolitileReadStream</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ExternalEncodedStreamConstructor</name><environment>OS</environment><super>Core.EncodedStreamConstructor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>networkFamily </inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>Process</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList depth hostThreadKey interruptProtect environment isSystem name debugger locale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>ExternalConnection</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputDescriptor outputDescriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalReadStream</name><environment>OS</environment><super>OS.BufferedExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>ExternalReadAppendStream</name><environment>OS</environment><super>OS.ExternalReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>writeStream </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>LogicalFilename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>UnixFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>OS-Unix</package></attributes></class><class><name>EncodedStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binary stream encoder policy lineEndConvention lineEndCharacter skipSize </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ExternalWriteStream</name><environment>OS</environment><super>OS.BufferedExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>