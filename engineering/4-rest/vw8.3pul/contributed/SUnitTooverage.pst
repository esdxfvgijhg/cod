<?xml version="1.0"?><st-source><!-- Name: SUnitToo(verage)Notice: Copyright 2006 - 2015 Michael Lucas-SmithThis utility is free to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This package is a companion to SUnitToo that uses method wrappers to gather code coverage while running your tests. Its UI is in SUnitToo(lsoverage).As with all uses of method wrappers, there is the possibility of edge cases, e.g. gathering coverage on tests of the testing framework itself might show hiccoughs.DbIdentifier: bear73DbTrace: 454548DbUsername: nrossDbVersion: 2.1DevelopmentPrerequisites: #(#(#any 'Method Wrapper Base' '') #(#any 'SUnitToo' ''))PackageName: SUnitToo(verage)Parcel: #('SUnitToo(verage)')ParcelName: SUnitToo(verage)PrerequisiteParcels: #(#('Method Wrapper Base' '') #('SUnitToo' ''))PrintStringCache: (2.1,nross)Version: 2.1VisualworksVersion: VisualWorks®, Pre-Release 7.5 (jan07.2) of January 15, 2007Date: 7:22:58 AM January 9, 2015 --><time-stamp>From VisualWorks®, Pre-Release 8.1 (jan15.1) of January 9, 2015 on January 9, 2015 at 7:22:58 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Coverage</name><environment>SUnit</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>SUnitToo(verage)</category><attributes><package>SUnitToo(verage)</package></attributes></name-space><class><name>CoverageColouring</name><environment>SUnit.Coverage</environment><super>Kernel.ProgramNodeEnumerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text visited visitedStyle notVisitedStyle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>SUnitToo(verage)</package></attributes></class><class><name>CoverageTransformer</name><environment>SUnit.Coverage</environment><super>Kernel.ProgramNodeEnumerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>recorderVariable nextId stack coverageWrapper </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>SUnitToo(verage)</package></attributes></class><class><name>CoverageWrapper</name><environment>SUnit.Coverage</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>coverage recompiled parsetree original clientMethodContext sender </inst-vars><class-inst-vars>dontCoverCache </class-inst-vars><imports></imports><category>Method Wrapper Base</category><attributes><package>SUnitToo(verage)</package></attributes></class><class><name>CoverageTestObject</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bNotificationRun </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo(verage)</category><attributes><package>SUnitToo(verage)</package></attributes></class><class><name>MethodCoverage</name><environment>SUnit.Coverage</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mclass selector parsetree visited branches </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Method Wrapper Base</category><attributes><package>SUnitToo(verage)</package></attributes></class><class><name>CoverageBranches</name><environment>SUnit.Coverage</environment><super>Kernel.ProgramNodeEnumerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>branches </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>SUnitToo(verage)</package></attributes></class><class><name>PercentageCoverage</name><environment>SUnit.Coverage</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>branchSize clientMethod methodCoverage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Method Wrapper Base</category><attributes><package>SUnitToo(verage)</package></attributes></class><class><name>CoverageTestCase</name><environment>SUnit.Coverage</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo(verage)</category><attributes><package>SUnitToo(verage)</package></attributes></class><shared-variable><name>Coverages</name><environment>SUnit.Coverage</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>EphemeronDictionary new</initializer><attributes><package>SUnitToo(verage)</package></attributes></shared-variable><shared-variable><name>Wrapping</name><environment>SUnit.Coverage.CoverageWrapper</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>false</initializer><attributes><package>SUnitToo(verage)</package></attributes></shared-variable><methods><class-id>SUnit.Coverage.CoverageColouring</class-id> <category>accessing</category><body package="SUnitToo(verage)">notVisitedStyle	^notVisitedStyle</body><body package="SUnitToo(verage)">notVisitedStyle: anObject	notVisitedStyle := anObject</body><body package="SUnitToo(verage)">text	^text</body><body package="SUnitToo(verage)">text: anObject	text := anObject</body><body package="SUnitToo(verage)">visited	^visited</body><body package="SUnitToo(verage)">visited: anObject	visited := anObject</body><body package="SUnitToo(verage)">visitedStyle	^visitedStyle</body><body package="SUnitToo(verage)">visitedStyle: anObject	visitedStyle := anObject</body></methods><methods><class-id>SUnit.Coverage.CoverageColouring</class-id> <category>enumerating</category><body package="SUnitToo(verage)">doAssignment: aNode variable: var value: val	super doAssignment: aNode variable: var value: val.	aNode emphasize: (self styleForNode: aNode) on: text</body><body package="SUnitToo(verage)">doMessage: aNode receiver: rcvr selector: sel arguments: args	super doMessage: aNode receiver: rcvr selector: sel arguments: args.	aNode emphasize: (self styleForNode: aNode) on: text</body><body package="SUnitToo(verage)">doMethod: aNode selector: sel primitive: prim block: block	super doMethod: aNode selector: sel primitive: prim block: block.	aNode emphasize: #bold on: text</body><body package="SUnitToo(verage)">doReturn: aNode value: value	super doReturn: aNode value: value.	aNode emphasize: (self styleForNode: aNode) on: text</body></methods><methods><class-id>SUnit.Coverage.CoverageColouring</class-id> <category>private</category><body package="SUnitToo(verage)">styleForNode: aNode	^(self hasVisited: aNode)		ifTrue: [visitedStyle]		ifFalse: [notVisitedStyle]</body></methods><methods><class-id>SUnit.Coverage.CoverageColouring</class-id> <category>testing</category><body package="SUnitToo(verage)">hasVisited: aNode	^visited anySatisfy: [:e | e == aNode]</body></methods><methods><class-id>SUnit.Coverage.CoverageTransformer</class-id> <category>accessing</category><body package="SUnitToo(verage)">clientMethodContext	^self coverageWrapper clientMethodContext</body><body package="SUnitToo(verage)">coverageWrapper	^coverageWrapper</body><body package="SUnitToo(verage)">coverageWrapper: anObject	coverageWrapper := anObject</body><body package="SUnitToo(verage)">nextId	^LiteralNode new value: (nextId := nextId + 1)</body></methods><methods><class-id>SUnit.Coverage.CoverageTransformer</class-id> <category>enumerating</category><body package="SUnitToo(verage)">doAssignment: aNode variable: var value: val	| message |	stack add: aNode.	super doAssignment: aNode variable: var value: val.	stack removeLast.	message := MessageNode new		receiver: recorderVariable		selector: #id:assign:result:		arguments: (Array with: self nextId with: (LiteralNode new value: var name) with: aNode value).	aNode value: message</body><body package="SUnitToo(verage)">doBlock: aNode arguments: args body: seq	stack add: aNode.	super doBlock: aNode arguments: args body: seq.	stack removeLast</body><body package="SUnitToo(verage)">doCascade: aNode receiver: rcvr messages: msgs	| variable assign block sequence message new |	stack add: aNode.	self doNode: aNode receiver.	stack removeLast.	variable := VariableNode new name: 'cascade_c' , stack size printString.	assign := AssignmentNode new variable: variable value: aNode receiver.	sequence := SequenceNode new.	sequence		temporaries: (OrderedCollection with: (ParameterNode new variable: variable type: nil))		statements: (OrderedCollection with: assign).	block := BlockNode new body: sequence.	message := MessageNode new receiver: block selector: #value arguments: #().	stack last swap: aNode with: message.	aNode messages do: [:each |		stack add: each.		self doNodes: each arguments.		stack removeLast.		each receiver: variable.		new := each receiver transformMessage: each transformer: self.		sequence statements add: new].</body><body package="SUnitToo(verage)">doMessage: aNode receiver: rcvr selector: sel arguments: args	| new |	stack add: aNode.	super doMessage: aNode receiver: rcvr selector: sel arguments: args.	stack removeLast.	new := aNode receiver transformMessage: aNode transformer: self.	stack last swap: aNode with: new</body><body package="SUnitToo(verage)">doMethod: aNode selector: sel primitive: prim block: block	recorderVariable := VariableNode new name: '__recorder'.	aNode block		arguments:			(aNode block arguments copyWith: (ParameterNode new variable: recorderVariable type: nil)).	super doMethod: aNode selector: sel primitive: prim block: block</body><body package="SUnitToo(verage)">doReturn: aNode value: value	| message |	stack add: aNode.	super doReturn: aNode value: value.	stack removeLast.	message := MessageNode new		receiver: recorderVariable		selector: #id:return:		arguments: (Array with: self nextId with: aNode value).	aNode value: message</body><body package="SUnitToo(verage)">doSequence: aNode temporaries: temps statements: stats	stack add: aNode.	super doSequence: aNode temporaries: temps statements: stats.	stack removeLast</body><body package="SUnitToo(verage)">transformMessageFromMessage: aNode	"@receiver @selector: @argument(s)__recorder	send: @receiver	selector: @selector	do: [:__@receiver | __@receiver @selector: @argument(s)]	id: 123"	| new selectorLiteral newSelector newArguments messageBlock messageReceiver |	new := MessageNode new.	selectorLiteral := LiteralNode new value: aNode selector.	messageReceiver := VariableNode new name: 'block_b' , stack size printString.	messageBlock := BlockNode new		arguments: (Array with: (ParameterNode new variable: messageReceiver type: nil))		body: (SequenceNode new statements: (Array with: aNode)).	newSelector := #id:send:selector:do:.	newArguments := Array with: aNode receiver with: selectorLiteral with: messageBlock.	aNode receiver: messageReceiver.	new		receiver: recorderVariable		selector: newSelector		arguments: (newArguments copyWithFirst: self nextId).	^new</body><body package="SUnitToo(verage)">transformMessageFromPerformMessage: aNode	"@receiver @selector: @argument(s)__recorder	send: @receiver	perform: @arguments first	with: @argument(s) without first	id: 123"	| new newSelector newArguments |	new := MessageNode new.	newSelector := (#id:send: , aNode selector) asSymbol.	newArguments := (Array with: aNode receiver) , aNode arguments.	new		receiver: recorderVariable		selector: newSelector		arguments: (newArguments copyWithFirst: self nextId).	^new</body><body package="SUnitToo(verage)">transformMessageFromPerformStatement: aNode	"@receiver @selector: @argument(s)__recorder	call: @receiver class	perform: @arguments first	do: [@receiver @selector: @argument(s)]	id: 123"	| new selectorLiteral newSelector newArguments messageBlock classMessage |	new := MessageNode new.	classMessage := MessageNode new receiver: aNode receiver selector: #class arguments: #().	selectorLiteral := aNode arguments first.	messageBlock := BlockNode new body: (SequenceNode new statements: (Array with: aNode)).	newSelector := #id:call:perform:do:.	newArguments := Array with: classMessage with: selectorLiteral with: messageBlock.	new		receiver: recorderVariable		selector: newSelector		arguments: (newArguments copyWithFirst: self nextId).	^new</body><body package="SUnitToo(verage)">transformMessageFromStatement: aNode	"@receiver @selector: @argument(s)__recorder	call: @receiver class	selector: @selector	do: [@receiver @selector: @argument(s)]	id: 123"	| new selectorLiteral newSelector newArguments messageBlock classMessage |	new := MessageNode new.	(aNode receiver class = VariableNode and: [aNode receiver name = 'thisContext']) ifTrue: [		aNode receiver: (LiteralNode new value: self clientMethodContext)].	classMessage := aNode receiver isSuper		ifTrue: [			MessageNode new				receiver:					(MessageNode new						receiver: (LiteralNode new value: coverageWrapper mclass)						selector: #class						arguments: #())				selector: #superclass				arguments: #()]		ifFalse: [MessageNode new receiver: aNode receiver selector: #class arguments: #()].	selectorLiteral := LiteralNode new value: aNode selector.	messageBlock := BlockNode new body: (SequenceNode new statements: (Array with: aNode)).	newSelector := #id:call:selector:do:.	newArguments := Array with: classMessage with: selectorLiteral with: messageBlock.	new		receiver: recorderVariable		selector: newSelector		arguments: (newArguments copyWithFirst: self nextId).	^new</body></methods><methods><class-id>SUnit.Coverage.CoverageTransformer</class-id> <category>private</category><body package="SUnitToo(verage)">performMessages	^#(#perform: #perform:with: #perform:with:with: #perform:with:with:with: #perform:withArguments:)</body></methods><methods><class-id>SUnit.Coverage.CoverageTransformer</class-id> <category>initialize-release</category><body package="SUnitToo(verage)">initialize	super initialize.	nextId := 0.	stack := OrderedCollection new</body></methods><methods><class-id>SUnit.Coverage.CoverageTransformer class</class-id> <category>instance creation</category><body package="SUnitToo(verage)">newFor: wrapper	^self new		coverageWrapper: wrapper;		yourself</body></methods><methods><class-id>SUnit.Coverage.CoverageWrapper</class-id> <category>accessing</category><body package="SUnitToo(verage)">clientMethod	^clientMethod</body><body package="SUnitToo(verage)">clientMethod: anObject	clientMethod := anObject</body><body package="SUnitToo(verage)">clientMethodContext	^clientMethodContext</body><body package="SUnitToo(verage)">clientMethodContext: anObject	clientMethodContext := anObject</body><body package="SUnitToo(verage)">coverage	^coverage ifNil: [		coverage := MethodCoverage			coverageFor: clientMethod			mclass: mclass			selector: selector			parsetree: original]</body><body package="SUnitToo(verage)">parsetree	^parsetree</body><body package="SUnitToo(verage)">recompiled	^recompiled ifNil: [self wrappingDo: [recompiled := self recompileIfError: [^clientMethod]]]</body><body package="SUnitToo(verage)">sender	^sender</body><body package="SUnitToo(verage)">sender: anObject	sender := anObject</body></methods><methods><class-id>SUnit.Coverage.CoverageWrapper</class-id> <category>evaluating</category><body package="SUnitToo(verage)">valueWithReceiver: anObject arguments: anArrayOfObjects	Wrapping ifTrue: [^clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects]."	Transcript cr; show: '[0] executing: ' , mclass name , '&gt;&gt;' , selector."	^self recompiled valueWithReceiver: anObject arguments: (anArrayOfObjects copyWith: self coverage)</body></methods><methods><class-id>SUnit.Coverage.CoverageWrapper</class-id> <category>private</category><body package="SUnitToo(verage)">parsetreeIfError: errorBlock	^self class parsetree: clientMethod ifError: errorBlock</body><body package="SUnitToo(verage)">recompileIfError: errorBlock	original := self parsetreeIfError: [^errorBlock value].	parsetree := self parsetreeIfError: [^errorBlock value].	self transform.	^[Compiler new compile: parsetree in: clientMethod mclass] on: Notification do: [:sig | sig resume]</body><body package="SUnitToo(verage)">transform	| senderContext |	self sender notNil ifTrue: [		senderContext := MethodContext			sender: nil			receiver: self sender mclass instanceBehavior			method: self sender			arguments: (Array new: self sender numArgs)].	clientMethodContext := MethodContext		sender: senderContext		receiver: self mclass instanceBehavior		method: self clientMethod		arguments: (Array new: self clientMethod numArgs).	parsetree nodeDo: (CoverageTransformer newFor: self)</body><body package="SUnitToo(verage)">wrappingDo: aBlock	| old |	old := Wrapping.	Wrapping := true.	^aBlock ensure: [Wrapping := old]</body></methods><methods><class-id>SUnit.Coverage.CoverageWrapper class</class-id> <category>private</category><body package="SUnitToo(verage)">dontCover: aSelector inClass: methodClass	self dontCoverCache add: methodClass -&gt; aSelector.	^false</body><body package="SUnitToo(verage)">parsetree: clientMethod ifError: errorBlock	| source |	(source := [clientMethod getSource] on: Error do: [:sig | ^errorBlock value]) ifNil: [		^errorBlock value].	^[	Parser new		parse: source asString readStream		class: clientMethod mclass		environment: clientMethod mclass environment		noPattern: false		context: nil		notifying: nil		builder: ProgramNodeBuilder new		saveComments: false		ifFail: [^errorBlock value]] on: Notification , Error do: [:sig | sig resume]</body></methods><methods><class-id>SUnit.Coverage.CoverageWrapper class</class-id> <category>accessing</category><body package="SUnitToo(verage)">dontCoverCache	^dontCoverCache ifNil: [dontCoverCache := Set new]</body></methods><methods><class-id>SUnit.Coverage.CoverageWrapper class</class-id> <category>testing</category><body package="SUnitToo(verage)">canWrap: aSelector inClass: callingClass	| methodClass method |	callingClass ifNil: [^false].	(self dontCoverCache includes: callingClass -&gt; aSelector) ifTrue: [^false].	methodClass := callingClass whichClassIncludesSelector: aSelector.	methodClass ifNil: [^false].	(self dontCoverCache includes: methodClass -&gt; aSelector) ifTrue: [		self dontCover: aSelector inClass: callingClass.		^false].	method := methodClass compiledMethodAt: aSelector ifAbsent: [		self dontCover: aSelector inClass: methodClass.		^self dontCover: aSelector inClass: callingClass].	method class == self ifTrue: [^false].	(self shouldWrap: aSelector methodClass: methodClass callingClass: callingClass method: method)		ifTrue: [^true].	self dontCover: aSelector inClass: methodClass.	^self dontCover: aSelector inClass: callingClass</body><body package="SUnitToo(verage)">shouldWrap: aSelector methodClass: methodClass callingClass: callingClass method: method	(SUnit allNameSpaces anySatisfy: [:e | callingClass environment == e]) ifTrue: [^false].	aSelector = #class ifTrue: [^false].	(callingClass includesBehavior: CoverageWrapper) ifTrue: [^false].	(callingClass includesBehavior: MethodCoverage) ifTrue: [^false].	(callingClass includesBehavior: Refactory.Wrappers.MethodWrapper) ifTrue: [^false].	callingClass == BlockClosure ifTrue: [		(#(#valueAsUnwindBlockFrom: #ensure:) includes: aSelector) ifTrue: [^false]].	(callingClass includesBehavior: DeferredBinding) ifTrue: [^false].	(callingClass includesBehavior: VariableBinding) ifTrue: [^false].	(#(#Behavior #Class #Metaclass #ClassDescription) includes: methodClass name) ifTrue: [^false].	(#(#Core #Kernel #Security #OS) includes: methodClass environment name) ifTrue: [^false].	^method compilerClass == Compiler and: [method primitiveNumber isNil]</body></methods><methods><class-id>CoverageTestObject</class-id> <category>API</category><body package="SUnitToo(verage)">a	^self a2</body><body package="SUnitToo(verage)">a2	^19</body><body package="SUnitToo(verage)">b	bNotificationRun := false.	^[	Notification raiseSignal.	self b2] on: Notification do: [:ex | 		bNotificationRun := true.		ex resume]</body><body package="SUnitToo(verage)">b2	^bNotificationRun ifTrue: [42] ifFalse: [0]</body><body package="SUnitToo(verage)">c	^[	Notification raiseSignal.	nil] on: Notification do: [:ex | self c2]</body><body package="SUnitToo(verage)">c2	^7</body><body package="SUnitToo(verage)">d	[Notification raiseSignal] on: Notification do: [:ex | ^self d2].	^nil</body><body package="SUnitToo(verage)">d2	^33</body><body package="SUnitToo(verage)">e	^[	Notification raiseSignal.	nil] on: Notification do: [:ex | ex return: self e2]</body><body package="SUnitToo(verage)">e2	^99</body></methods><methods><class-id>CoverageTestObject</class-id> <category>accessing</category><body package="SUnitToo(verage)">bNotificationRun	^bNotificationRun</body><body package="SUnitToo(verage)">bNotificationRun: anObject	bNotificationRun := anObject</body></methods><methods><class-id>SUnit.Coverage.MethodCoverage</class-id> <category>accessing</category><body package="SUnitToo(verage)">branches	^branches</body><body package="SUnitToo(verage)">getSource	^(mclass compiledMethodAt: selector) getSource</body><body package="SUnitToo(verage)">mclass	^mclass</body><body package="SUnitToo(verage)">mclass: anObject	mclass := anObject</body><body package="SUnitToo(verage)">parsetree	^parsetree</body><body package="SUnitToo(verage)">parsetree: anObject	| brancher |	parsetree := anObject.	brancher := CoverageBranches new.	parsetree nodeDo: brancher.	branches := brancher branches</body><body package="SUnitToo(verage)">selector	^selector</body><body package="SUnitToo(verage)">selector: anObject	selector := anObject</body><body package="SUnitToo(verage)">visited	^visited</body></methods><methods><class-id>SUnit.Coverage.MethodCoverage</class-id> <category>printing</category><body package="SUnitToo(verage)">percentage	^branches isEmpty ifTrue: [^100] ifFalse: [(visited size / branches size * 100) asInteger]</body><body package="SUnitToo(verage)">percentageString	^self percentage printString , '%'</body><body package="SUnitToo(verage)">printOn: stream	stream nextPutAll: '(coverage '.	stream nextPutAll: self percentageString.	stream nextPutAll: ') '.	mclass printOn: stream.	stream nextPutAll: '&gt;&gt;'.	selector printOn: stream.	stream cr.	stream nextPutAll: self getSource</body><body package="SUnitToo(verage)">sourceText	| colouring |	(colouring := CoverageColouring new)		text: self getSource asText;		visitedStyle: (Array with: #color -&gt; ColorValue blue);		notVisitedStyle: (Array with: #color -&gt; ColorValue red);		visited: visited.	parsetree nodeDo: colouring.	^colouring text</body></methods><methods><class-id>SUnit.Coverage.MethodCoverage</class-id> <category>initialize-release</category><body package="SUnitToo(verage)">initialize	visited := IdentitySet new</body></methods><methods><class-id>SUnit.Coverage.MethodCoverage</class-id> <category>API</category><body package="SUnitToo(verage)">id: id assign: variable result: result	visited add: (branches at: id).	^result</body><body package="SUnitToo(verage)">id: id call: aClass perform: aSelector do: aBlock	"	Transcript cr; show: '[' , id printString , '] calling: ' , aClass name , '&gt;&gt;' , aSelector."	visited add: (branches at: id).	SUnit.Coverage.CoverageWrapper.Wrapping ifTrue: [self halt].	self wrap: aSelector in: aClass sender: (self mclass compiledMethodAt: self selector).	^aBlock value</body><body package="SUnitToo(verage)">id: id call: aClass selector: aSelector do: aBlock	"	Transcript cr; show: '[' , id printString , '] calling: ' , aClass name , '&gt;&gt;' , aSelector."	visited add: (branches at: id).	SUnit.Coverage.CoverageWrapper.Wrapping ifTrue: [self halt].	self wrap: aSelector in: aClass sender: (self mclass compiledMethodAt: self selector).	^aBlock value</body><body package="SUnitToo(verage)">id: id return: result	"	Transcript cr; show: '[' , id printString , '] return -&gt; ' , result printString."	visited add: (branches at: id).	^result</body><body package="SUnitToo(verage)">id: id send: receiver perform: aSelector	visited add: (branches at: id).	self wrap: aSelector in: receiver class sender: (self mclass compiledMethodAt: self selector).	^receiver perform: aSelector</body><body package="SUnitToo(verage)">id: id send: receiver perform: aSelector with: arg1	visited add: (branches at: id).	self wrap: aSelector in: receiver class sender: (self mclass compiledMethodAt: self selector).	^receiver perform: aSelector with: arg1</body><body package="SUnitToo(verage)">id: id send: receiver perform: aSelector with: arg1 with: arg2	visited add: (branches at: id).	self wrap: aSelector in: receiver class sender: (self mclass compiledMethodAt: self selector).	^receiver perform: aSelector with: arg1 with: arg2</body><body package="SUnitToo(verage)">id: id send: receiver perform: aSelector with: arg1 with: arg2 with: arg3	visited add: (branches at: id).	self wrap: aSelector in: receiver class sender: (self mclass compiledMethodAt: self selector).	^receiver perform: aSelector with: arg1 with: arg2 with: arg3</body><body package="SUnitToo(verage)">id: id send: receiver perform: aSelector withArguments: args	visited add: (branches at: id).	self wrap: aSelector in: receiver class sender: (self mclass compiledMethodAt: self selector).	^receiver perform: aSelector withArguments: args</body><body package="SUnitToo(verage)">id: id send: receiver selector: aSelector do: aBlock	"	Transcript cr; show: '[' , id printString , '] sending: ' , receiver class name , '&gt;&gt;' , aSelector."	visited add: (branches at: id).	SUnit.Coverage.CoverageWrapper.Wrapping ifTrue: [self halt].	self wrap: aSelector in: receiver class sender: (self mclass compiledMethodAt: self selector).	^aBlock value: receiver</body><body package="SUnitToo(verage)">remove	| aMethod |	aMethod := self mclass methodDictionary at: self selector.	aMethod class = CoverageWrapper ifTrue: [aMethod := aMethod clientMethod].	Coverages removeKey: aMethod</body></methods><methods><class-id>SUnit.Coverage.MethodCoverage</class-id> <category>testing</category><body package="SUnitToo(verage)">isPartiallyCovered	^visited size &lt; branches size</body></methods><methods><class-id>SUnit.Coverage.MethodCoverage</class-id> <category>private</category><body package="SUnitToo(verage)">wrap: aSelector in: aClass sender: aSender	| implementingClass |	implementingClass := aClass whichClassIncludesSelector: aSelector.	(CoverageWrapper on: aSelector inClass: implementingClass) ifNotNil: [:wrapper | 		wrapper sender: aSender; install]</body></methods><methods><class-id>SUnit.Coverage.MethodCoverage class</class-id> <category>instance creation</category><body package="SUnitToo(verage)">new	^super new initialize</body></methods><methods><class-id>SUnit.Coverage.MethodCoverage class</class-id> <category>API</category><body package="SUnitToo(verage)">calculateCoveragesFor: aMethodDefinition inPundle: aPundle	| coverage |	(self hasCoverageForClass: aMethodDefinition implementingClass inPundle: aPundle) ifFalse: [^nil].	coverage := self		percentageCoverageFor:			(aMethodDefinition implementingClass compiledMethodAt: aMethodDefinition selector).	^coverage percentageForPundle: aPundle</body><body package="SUnitToo(verage)">calculateCoveragesForClass: aClass inPundle: aPundle	| coverages visitedSize branchSize |	(aClass isNameSpace or: [aClass isTestCase]) ifTrue: [^nil].	(self hasCoverageForClass: aClass inPundle: aPundle) ifFalse: [^nil].	coverages := self percentageCoveragesForClass: aClass inPundle: aPundle.	coverages := coverages asOrderedCollection		, (self percentageCoveragesForClass: aClass class inPundle: aPundle) asOrderedCollection.	coverages := coverages reject: [:each | each shouldntCover].	(coverages isEmpty or: [(coverages reject: [:each | each hasCoverage]) size = coverages size])		ifTrue: [^nil].	visitedSize := 0.	branchSize := 0.	coverages do: [:each | 		visitedSize := visitedSize + each visitedSize.		branchSize := branchSize + each branchSize].	^branchSize = 0 ifTrue: [0] ifFalse: [(visitedSize / branchSize * 100) asInteger]</body><body package="SUnitToo(verage)">calculateCoveragesForPundle: aPundle	| coverages visitedSize branchSize |	(self hasCoverageForPundle: aPundle) ifFalse: [^nil].	(coverages := self percentageCoveragesForPundle: aPundle) isEmpty ifTrue: [^nil].	(coverages allSatisfy: [:e | e shouldntCover or: [e hasCoverage not]]) ifTrue: [^nil].	visitedSize := 0.	branchSize := 0.	coverages do: [:each | 		each shouldCover ifTrue: [			visitedSize := visitedSize + each visitedSize.			branchSize := branchSize + each branchSize]].	^branchSize = 0 ifTrue: [0] ifFalse: [(visitedSize / branchSize * 100) asInteger]</body><body package="SUnitToo(verage)">coverageFor: aCompiledMethod mclass: mclass selector: selector parsetree: parsetree	| percentageCoverage coverage |	coverage := self new		mclass: mclass;		selector: selector;		parsetree: parsetree;		yourself.	percentageCoverage := Coverages at: aCompiledMethod ifAbsentPut: [		self newPercentageCoverageFor: aCompiledMethod coverage: coverage].	percentageCoverage hasCoverage ifFalse: [percentageCoverage methodCoverage: coverage].	^percentageCoverage</body><body package="SUnitToo(verage)">hasCoverageForClass: aClass inPundle: pundle	pundle ifNil: [^false].	^Coverages anySatisfy: [:each | 		each hasCoverage and: [			each methodCoverage mclass = aClass and: [				pundle definesSelector: each methodCoverage selector forClass: each methodCoverage mclass]]]</body><body package="SUnitToo(verage)">hasCoverageForPundle: pundle	| classes |	pundle ifNil: [^false].	classes := pundle allClasses collect: [:e | e actual].	^Coverages anySatisfy: [:each | 		each hasCoverage and: [			(classes includes: each methodCoverage mclass) and: [				pundle definesSelector: each methodCoverage selector forClass: each methodCoverage mclass]]]</body><body package="SUnitToo(verage)">newPercentageCoverageFor: aCompiledMethod coverage: coverage	^PercentageCoverage newFor: aCompiledMethod coverage: coverage</body><body package="SUnitToo(verage)">percentageCoverageFor: aCompiledMethod	^Coverages at: aCompiledMethod ifAbsentPut: [		self newPercentageCoverageFor: aCompiledMethod coverage: nil]</body><body package="SUnitToo(verage)">percentageCoverageFor: aCompiledMethod ifAbsent: absentBlock	^Coverages at: aCompiledMethod ifAbsent: [^absentBlock value]</body><body package="SUnitToo(verage)">percentageCoveragesForClass: aClass inPundle: aPundle	| selectors |	aPundle ifNil: [^#()].	selectors := aClass selectors select: [:each | aPundle definesSelector: each forClass: aClass].	^selectors collect: [:each | 		| aMethod |		aMethod := aClass methodDictionary at: each.		aMethod class = CoverageWrapper ifTrue: [aMethod := aMethod clientMethod].		self percentageCoverageFor: aMethod]</body><body package="SUnitToo(verage)">percentageCoveragesForPundle: aPundle	aPundle ifNil: [^#()].	^aPundle allClasses inject: OrderedCollection new into: [:all :each | 		all , (self percentageCoveragesForClass: each actual inPundle: aPundle) asOrderedCollection			, (self percentageCoveragesForClass: each actual class inPundle: aPundle) asOrderedCollection]</body></methods><methods><class-id>SUnit.Coverage.CoverageBranches</class-id> <category>enumerating</category><body package="SUnitToo(verage)">doAssignment: aNode variable: var value: val	super doAssignment: aNode variable: var value: val.	self addBranch: aNode</body><body package="SUnitToo(verage)">doMessage: aNode receiver: rcvr selector: sel arguments: args	super doMessage: aNode receiver: rcvr selector: sel arguments: args.	self addBranch: aNode</body><body package="SUnitToo(verage)">doReturn: aNode value: value	super doReturn: aNode value: value.	self addBranch: aNode</body></methods><methods><class-id>SUnit.Coverage.CoverageBranches</class-id> <category>initialize-release</category><body package="SUnitToo(verage)">initialize	super initialize.	branches := OrderedCollection new</body></methods><methods><class-id>SUnit.Coverage.CoverageBranches</class-id> <category>private</category><body package="SUnitToo(verage)">addBranch: aNode	(branches anySatisfy: [:each | each == aNode]) ifTrue: [^self].	branches add: aNode</body></methods><methods><class-id>SUnit.Coverage.CoverageBranches</class-id> <category>accessing</category><body package="SUnitToo(verage)">branches	^branches</body></methods><methods><class-id>SUnit.Coverage.PercentageCoverage</class-id> <category>accessing</category><body package="SUnitToo(verage)">branchSize	^self hasCoverage		ifTrue: [			| size |			size := self methodCoverage branches size.			size = 0 ifTrue: [size := 1].			size]		ifFalse: [branchSize ifNil: [branchSize := self getBranchSize]]</body><body package="SUnitToo(verage)">clientMethod	^clientMethod</body><body package="SUnitToo(verage)">clientMethod: anObject	clientMethod := anObject</body><body package="SUnitToo(verage)">methodCoverage	^methodCoverage</body><body package="SUnitToo(verage)">methodCoverage: anObject	methodCoverage := anObject</body><body package="SUnitToo(verage)">selector	^self hasCoverage ifTrue: [self methodCoverage selector] ifFalse: [self clientMethod selector]</body><body package="SUnitToo(verage)">visitedSize	^self hasCoverage		ifTrue: [self methodCoverage branches size = 0 ifTrue: [1] ifFalse: [self methodCoverage visited size]]		ifFalse: [0]</body></methods><methods><class-id>SUnit.Coverage.PercentageCoverage</class-id> <category>printing</category><body package="SUnitToo(verage)">printOn: stream	self clientMethod definition printOn: stream.	stream space.	self visitedSize printOn: stream.	stream nextPutAll: ' of '.	self branchSize printOn: stream.	stream nextPutAll: ' -&gt; '.	self hasCoverage ifTrue: [self methodCoverage printOn: stream]</body></methods><methods><class-id>SUnit.Coverage.PercentageCoverage</class-id> <category>private</category><body package="SUnitToo(verage)">doesNotUnderstand: aMessage	self methodCoverage ifNil: [^super doesNotUnderstand: aMessage].	^self methodCoverage perform: aMessage selector withArguments: aMessage arguments</body><body package="SUnitToo(verage)">getBranchSize	| parser branch |	parser := SUnit.Coverage.CoverageWrapper parsetree: self clientMethod ifError: [].	^parser		ifNotNil: [:p | 			branch := SUnit.Coverage.CoverageBranches new.			p nodeDo: branch.			branch branches size]		ifNil: [0]</body><body package="SUnitToo(verage)">remove	self hasCoverage ifTrue: [self methodCoverage remove]</body></methods><methods><class-id>SUnit.Coverage.PercentageCoverage</class-id> <category>testing</category><body package="SUnitToo(verage)">hasCoverage	^self methodCoverage notNil</body><body package="SUnitToo(verage)">shouldCover	^self shouldntCover not</body><body package="SUnitToo(verage)">shouldntCover	^self clientMethod mclass isTestCase or: [		self clientMethod mclass = SUnit.TestResource or: [			self clientMethod isSetterMethod or: [				self clientMethod isGetterMethod or: [					self clientMethod isEmptyMethod or: [						self clientMethod isBooleanReturnMethod or: [							self clientMethod isSubclassResponsibility or: [self clientMethod isShouldNotImplement]]]]]]]</body></methods><methods><class-id>SUnit.Coverage.PercentageCoverage</class-id> <category>API</category><body package="SUnitToo(verage)">percentageForPundle: pundle	^self shouldCover		ifTrue: [			self hasCoverage				ifTrue: [(self visitedSize / self branchSize * 100) asInteger]				ifFalse: [					(SUnit.Coverage.MethodCoverage hasCoverageForClass: self clientMethod mclass inPundle: pundle)						ifTrue: [0]						ifFalse: [nil]]]		ifFalse: [nil]</body></methods><methods><class-id>SUnit.Coverage.PercentageCoverage class</class-id> <category>instance creation</category><body package="SUnitToo(verage)">newFor: clientMethod coverage: methodCoverage	^self new		clientMethod: clientMethod;		methodCoverage: methodCoverage;		yourself</body></methods><methods><class-id>SUnit.Coverage.CoverageTestCase</class-id> <category>running</category><body package="SUnitToo(verage)">setUp	object := CoverageTestObject new</body><body package="SUnitToo(verage)">tearDown	| package |	package := Store.Registry containingPackageForClass: self class.	(SUnit.Coverage.MethodCoverage percentageCoveragesForPundle: package) do: [:each | each remove]</body></methods><methods><class-id>SUnit.Coverage.CoverageTestCase</class-id> <category>private</category><body package="SUnitToo(verage)">run: selector expectedCoverage: selectorCollection	| package coverages returnValue |	returnValue := object coveragePerform: selector.	package := Store.Registry containingPackageForClass: object class.	coverages := SUnit.Coverage.MethodCoverage		percentageCoveragesForClass: object class		inPundle: package.	self should: [		((coverages select: #hasCoverage) collect: #selector) asSortedCollection asArray			= selectorCollection].	^returnValue</body></methods><methods><class-id>SUnit.Coverage.CoverageTestCase</class-id> <category>testing</category><body package="SUnitToo(verage)">testCoverage	self should: [(self run: #a expectedCoverage: #(#a #a2)) = 19]</body><body package="SUnitToo(verage)">testCoverageResumeFromException	self should: [(self run: #b expectedCoverage: #(#b #b2)) = 42]</body><body package="SUnitToo(verage)">testCoverageReturnFromException	self should: [(self run: #e expectedCoverage: #(#e #e2)) = 99]</body><body package="SUnitToo(verage)">testCoverageWithException	self should: [(self run: #c expectedCoverage: #(#c #c2)) = 7]</body></methods><methods><class-id>Kernel.SimpleMessageNode</class-id> <category>printing</category><body package="SUnitToo(verage)">emphasize: style on: text	receiver isImplicitlyExecuted ifTrue: [		text emphasizeFrom: receiver sourcePosition first to: receiver sourcePosition last with: style].	self emphasizeMessage: style on: text</body><body package="SUnitToo(verage)">emphasizeMessage: style on: text	| position |	arguments isEmpty ifTrue: [		^text emphasizeFrom: sourcePosition first to: sourcePosition last with: style].	position := sourcePosition first.	selector keywords with: arguments do: [:keyword :argument | 		text emphasizeFrom: position to: position + keyword size with: style.		position := argument sourcePosition last + 1.		[position &lt;= text size and: [(text at: position) isSeparator]] whileTrue: [			position := position + 1].		argument isImplicitlyExecuted ifTrue: [			text emphasizeFrom: argument sourcePosition first to: argument sourcePosition last with: style]]</body></methods><methods><class-id>Kernel.SimpleMessageNode</class-id> <category>accessing</category><body package="SUnitToo(verage)">receiver: aReceiver	receiver := aReceiver</body><body package="SUnitToo(verage)">swap: aNode with: anotherNode	aNode == receiver ifTrue: [^receiver := anotherNode].	(arguments includes: aNode) ifFalse: [^self].	arguments at: (arguments indexOf: aNode) put: anotherNode</body></methods><methods><class-id>Kernel.SimpleMessageNode</class-id> <category>enumerating</category><body package="SUnitToo(verage)">transformMessage: messageNode transformer: transformer	^(transformer performMessages includes: messageNode selector)		ifTrue: [transformer transformMessageFromPerformMessage: messageNode]		ifFalse: [transformer transformMessageFromMessage: messageNode]</body></methods><methods><class-id>Kernel.LiteralNode</class-id> <category>testing</category><body package="SUnitToo(verage)">isImplicitlyExecuted	^true</body></methods><methods><class-id>Core.Object</class-id> <category>controlling</category><body package="SUnitToo(verage)">coveragePerform: aSymbol	| wrapper |	wrapper := SUnit.Coverage.CoverageWrapper on: aSymbol inClass: self class.	wrapper ifNil: [^self perform: aSymbol].	wrapper install.	^[wrapper valueWithReceiver: self arguments: #()] ensure: [SUnit.Coverage.CoverageWrapper nuke]</body></methods><methods><class-id>Kernel.VariableNode</class-id> <category>testing</category><body package="SUnitToo(verage)">isImplicitlyExecuted	^true</body></methods><methods><class-id>Kernel.SequenceNode</class-id> <category>accessing</category><body package="SUnitToo(verage)">swap: aNode with: anotherNode	statements at: (statements indexOf: aNode) put: anotherNode</body></methods><methods><class-id>Kernel.MethodNode</class-id> <category>printing</category><body package="SUnitToo(verage)">emphasize: style on: text	text emphasizeFrom: 1 to: (text indexOf: Character cr) with: style</body></methods><methods><class-id>Kernel.MethodNode</class-id> <category>accessing</category><body package="SUnitToo(verage)">selector: aSelector	selector := aSelector</body></methods><methods><class-id>Kernel.ProgramNode</class-id> <category>testing</category><body package="SUnitToo(verage)">isImplicitlyExecuted	^false</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="SUnitToo(verage)">copyWithFirst: anObject	^(self species with: anObject), self</body></methods><methods><class-id>Kernel.BlockNode</class-id> <category>accessing</category><body package="SUnitToo(verage)">arguments: someArguments	arguments := someArguments</body><body package="SUnitToo(verage)">swap: aNode with: anotherNode	body == aNode ifTrue: [body := anotherNode]</body></methods><methods><class-id>Kernel.StatementNode</class-id> <category>enumerating</category><body package="SUnitToo(verage)">transformMessage: messageNode transformer: transformer	^(transformer performMessages includes: messageNode selector)		ifTrue: [transformer transformMessageFromPerformStatement: messageNode]		ifFalse: [transformer transformMessageFromStatement: messageNode]</body></methods><methods><class-id>Kernel.AssignmentNode</class-id> <category>printing</category><body package="SUnitToo(verage)">emphasize: style on: text	text emphasizeFrom: variable  sourcePosition first to: variable sourcePosition last + 3 with: style.	value isImplicitlyExecuted		ifTrue: [text emphasizeFrom: sourcePosition first to: sourcePosition last with: style]		ifFalse: [text emphasizeFrom: sourcePosition first to: sourcePosition first with: style]</body></methods><methods><class-id>Kernel.AssignmentNode</class-id> <category>accessing</category><body package="SUnitToo(verage)">swap: aNode with: anotherNode	value == aNode ifTrue: [value := anotherNode]</body></methods><methods><class-id>Kernel.AssignmentNode</class-id> <category>enumerating</category><body package="SUnitToo(verage)">transformMessage: messageNode transformer: transformer	^value transformMessage: messageNode transformer: transformer</body></methods><methods><class-id>Kernel.AssignmentNode</class-id> <category>accessing</category><body package="SUnitToo(verage)">value: aValue	value := aValue</body></methods><methods><class-id>Kernel.ReturnNode</class-id> <category>printing</category><body package="SUnitToo(verage)">emphasize: style on: text	value isImplicitlyExecuted ifTrue: [		text emphasizeFrom: sourcePosition first to: sourcePosition last with: style].	text emphasizeFrom: sourcePosition first to: sourcePosition first with: (Array with: #bold) , style</body></methods><methods><class-id>Kernel.ReturnNode</class-id> <category>accessing</category><body package="SUnitToo(verage)">swap: aNode with: anotherNode	value == aNode ifTrue: [value := anotherNode]</body></methods><methods><class-id>Kernel.ReturnNode</class-id> <category>enumerating</category><body package="SUnitToo(verage)">transformMessage: messageNode transformer: transformer	^value transformMessage: messageNode transformer: transformer</body></methods><methods><class-id>SUnit.Result</class-id> <category>accessing</category><body package="SUnitToo(verage)">method	^definition method class = SUnit.Coverage.CoverageWrapper		ifTrue: [definition method clientMethod]		ifFalse: [definition method]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>testing</category><body package="SUnitToo(verage)">definesSelector: aSelector forClass: aBehavior	^self containedItems anySatisfy: [:each | each definesSelector: aSelector forClass: aBehavior]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="SUnitToo(verage)">coveragePercentage	^SUnit.Coverage.MethodCoverage calculateCoveragesForPundle: self</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>converting</category><body package="SUnitToo(verage)">asMethodCoverage	^SUnit.Coverage.Coverages at: self ifAbsent: [nil]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="SUnitToo(verage)">isBooleanReturnMethod	^#(#[16r63] #[16r64]) includes: self bytes</body><body package="SUnitToo(verage)">isEmptyMethod	^self bytesSize = 1 and: [(self byteAt: 1) = 16r60]</body><body package="SUnitToo(verage)">isGetterMethod	(self bytesSize between: 2 and: 3) ifFalse: [^false].	(((self byteAt: 1) between: 0 and: 16rF) and: [(self byteAt: 2) = 16r65]) ifTrue: [^true].	(self byteAt: 1) = 16rD0 ifFalse: [^false].	(self byteAt: 3) = 16r65 ifFalse: [^false].	^(self byteAt: 2) between: 16r10 and: 16rFF</body><body package="SUnitToo(verage)">isSetterMethod	(self bytesSize between: 3 and: 4) ifFalse: [^false].	(self byteAt: 1) = 16r10 ifFalse: [^false].	(self byteAt: 2) = 16rDA ifTrue: [		(self byteAt: 4) = 16r60 ifFalse: [^false].		^(self byteAt: 3) between: 16r8 and: 16rFF].	(self byteAt: 3) = 16r60 ifFalse: [^false].	^(self byteAt: 2) between: 16r58 and: 16r5F</body><body package="SUnitToo(verage)">isShouldNotImplement	^#(#[16r44 16rCE 16rB4 16r65] #[16r44 16rCE 16rB4 16r45 16r65]) includes: self bytes</body><body package="SUnitToo(verage)">isSubclassResponsibility	^#(#[16r44 16rCE 16r48 16r65] #[16r44 16rCE 16r48 16r45 16r65]) includes: self bytes</body></methods><methods><class-id>Kernel.CascadeNode</class-id> <category>accessing</category><body package="SUnitToo(verage)">swap: aNode with: anotherNode	receiver == aNode ifTrue: [^receiver := anotherNode].	(messages includes: aNode) ifFalse: [^self].	messages at: (messages indexOf: aNode) put: anotherNode</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ProgramNode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePosition comment compilerHints blockIndex mapEntry returnMapEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>StatementNode</name><environment>Kernel</environment><super>Kernel.ProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>CascadeNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>SimpleMessageNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector arguments precedence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ReturnNode</name><environment>Kernel</environment><super>Kernel.StatementNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MethodWrapper</name><environment>Refactory.Wrappers</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars>methods </class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class><class><name>ProgramNodeEnumerator</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>Result</name><environment>SUnit</environment><super>SUnit.TestCaseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><class><name>LiteralNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>VariableNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name read </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>SequenceNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>temporaries statements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>MethodNode</name><environment>Kernel</environment><super>Kernel.ProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector primitive primitiveErrorCode primitiveModule primitiveSourcePosition block attributeMessages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>AssignmentNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable value leftArrow assignToArgOK </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>BlockNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments body </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class></st-source>