<?xml version="1.0"?><st-source><!-- Name: SteroidsComment: Steroids is a Eliot's optimization of the Java Asteroids which was a Smalltalk re-implemenation of Mike Hall's Asteroids.   Whew.  After loading you should see a workspace automatically opened containing some not-so-useful information.  Also, two crudely draw toolbar buttons on the Launcher will launch the game.  One button will launch the non-throttled version of the game and the other will launch the throttled (fixed frame rate) version of Asteroids. If for some reason the launcher does not have the toolbar button, the following do-it will launch the game:	Steroids.AsteroidsAppModel openSome reference links can be found at:	http://www.google.com/search?q=Mike+Hall+Asteroids	http://www.brainjar.com/	-  Eliot Miranda & Bob WestergaardDbIdentifier: bear73DbTrace: 51869DevelopmentPrerequisites: #(#(#any 'Windows Goodies' ''))HideSource: falsePackageName: SteroidsParcel: #('Steroids')ParcelName: SteroidsPrerequisiteParcels: #(#('Windows Goodies' ''))PrintStringCache: (0.5,bobw)SaveSource: trueText_explanation: Quite some time ago (back in the fall of 2000), I saw a link to Mike Hall's asteroids game in Java.  It was quite simple, only a 36K source file.  I thought, VisualWorks needs more toys so I'll rewrite that.  I looked at the Java code, rewrote about 60 percent of it and had enough done where I could shoot large asteroids and keep score, but that was it.   I showed some folks at work what I had, they weren't too critical and one even wanted a network version using Opentalk.   However, I never finished converting the game. I just lost interest in it and stopped working on it.  In hindsight, my best guess is that I kept trying to add features to it that weren't in the Java version and got bogged down in those details.  I'm sure there is some XP fanatic out there smiling.So here we are near the completion of 7.1 and I'm disappointed that once again I don't have enough of the game to release it as a goody.  So, I ditched my last attempt at the conversion and tried a different approach this time.  Just get the darn thing working.I took the Asteroids.java file and created two classes: Asteroids and AsteroidsSprite.   I used each method on the Java class as a template (saving the original java source as a comment in the Smalltalk counterpart method).  Then would use search and replace until it looked like Smalltalk.  For example, I would replace "asteroids[i]" with "(asteroids at: [i])".  I resisted the temptation to do any re-factoring of the original code or add anything new. I did have to add #printOn: to a few classes for debugging purposes.  Any call to a Java library I ended up creating a new class with that name and added only the methods required which simply did what I thought it should do in Smalltalk.After a few nights of doing this will watching Joe Millionaire and American Idol I had enough of it done to try to display stuff.  I added the bare minimum VisualWorks display support to do this, again I didn't want to get side-tracked with adding features like menu picks and other cool things.   Once I did that, much to my surprise it worked.    Well to be honest, I wasn't surprised it worked.   After all I was using the best development environment in the world, so even an idiot like yours truly can get something to "work".  I was surprised it was done: The flying saucer and its missile, the extra lives when you get enough points, the asteroids breaking up into little asteroids, the sound.   Much more then I had originally done.  It also performed reasonably well on the 233-mhz laptop I was using.  Now what? Obviously since it is was written using search and replace, it is just begging for some re-factoring.   I know that all of you Smalltalkers love to re-factor so here you go.   Bob Westergaard 2/2003 Text_files_list: asteroids.zip	The original Asteroids code from Mike Hall's websitecrash.wav, fire.wav, explosion.wav, missle.wav, saucer.wav, thrusters.wav, warp.wav	The sound files as wav files (The originals were .au files)JavaAsteroids.pcl, JavaAsteroisd.pst	The parcel and its source fileText_original_license: End User License AgreementMike Hall ("AUTHOR") hereby grants the Licensee ("USER") permission to use,copy, modify, and distribute the software listed below ("SOFTWARE") along withany accompanying documentation for commercial and non-commercial use except asnoted below.USER may not charge any fee or request payment for use of SOFTWARE, USER maynot sell or request payment for distribution of SOFTWARE. USER may not transferor grant license for use of SOFTWARE. USER is not permitted to alter anycopyright notices contained in SOFTWARE. Any distribution of SOFTWARE mustinclude this license agreement.USER agrees to comply with any and all import and export regulations that mayapply to SOFTWARE and indemnifies AUTHOR of any violations.SOFTWARE may not be used in any way that is deemed to be offensive orderogatory by AUTHOR.SOFTWARE is provided "AS IS" without warranty of any kind, eitherexpressed or implied. AUTHOR may not be held responsible for any damages orlosses resulting from use of SOFTWARE. Additionally, AUTHOR is not responsiblefor support or maintenance of SOFTWARE.USER may modify SOFTWARE but the terms of this license will remain in effectand AUTHOR retains copyright ownership as per applicable copyright laws.USER may terminate this License at any time by destroying all copies ofSOFTWARE. AUTHOR may terminate this License without notice if USER fails tocomply with any provision. USER must destroy all copies of SOFTWARE upon noticeof termination.Software:Asteroids Java applet, source code and documentation.Version: 0.5Post-Load Block: 	[:package | ]Date: 8:12:40 AM August 5, 2009 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7 (aug09.0) of August 5, 2009 on August 5, 2009 at 8:12:40 AM </time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Steroids</name><environment>Smalltalk</environment><private>false</private><imports>			private Core.*			</imports><category>Steroids-Name Spaces</category><attributes><package>Steroids</package></attributes></name-space><comment><name-space-id>Steroids</name-space-id><body></body></comment><class><name>Asteroids</name><environment>Steroids</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>playing score shipsLeft asteroidsSpeed newShipScore newUfoScore paused ship loaded thrustersSound thrustersPlaying shipCounter photons photonCounter photonIndex ufo ufoCounter ufoPassesLeft saucerSound saucerPlaying missle sound missleSound misslePlaying missleCounter explosions explosionCounter explosionIndex hyperCounter crashSound left right up down asteroids asteroidsCounter asteroidsLeft asteroidIsSmall explosionSound stars numStars highScore detail fireSound warpSound font fontHeight fontWidth size random </inst-vars><class-inst-vars></class-inst-vars><imports>			Graphics.CharacterAttributes			Graphics.ColorValue			Graphics.ComposedText			Graphics.FontDescription			Graphics.Pixmap			Graphics.TextAttributes			Kernel.Parcel			OS.Filename			</imports><category>Steroids</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.Asteroids</class-id><body>Asteroids represents the Instance Variables:	asteroidIsSmall	&lt;(Array of: (Boolean | BrowserEnvironment | MethodFilter | RBAbstractCondition))&gt;	description of asteroidIsSmall	asteroids	&lt;Object&gt;	description of asteroids	asteroidsCounter	&lt;ArithmeticValue&gt;	description of asteroidsCounter	asteroidsLeft	&lt;ArithmeticValue&gt;	description of asteroidsLeft	asteroidsSpeed	&lt;ArithmeticValue&gt;	description of asteroidsSpeed	crashSound	&lt;AudioClip&gt;	description of crashSound	detail	&lt;Boolean&gt;	description of detail	down	&lt;Boolean&gt;	description of down	explosionCounter	&lt;(Array of: ArithmeticValue)&gt;	description of explosionCounter	explosionIndex	&lt;ArithmeticValue&gt;	description of explosionIndex	explosions	&lt;Object&gt;	description of explosions	explosionSound	&lt;AudioClip&gt;	description of explosionSound	fireSound	&lt;AudioClip&gt;	description of fireSound	fm	&lt;FontMetrics&gt;	description of fm	font	&lt;Object&gt;	description of font	fontHeight	&lt;SmallInteger&gt;	description of fontHeight	fontWidth	&lt;ArithmeticValue&gt;	description of fontWidth	highScore	&lt;SmallInteger&gt;	description of highScore	hyperCounter	&lt;ArithmeticValue&gt;	description of hyperCounter	left	&lt;Boolean&gt;	description of left	loaded	&lt;Boolean&gt;	description of loaded	missle	&lt;AsteroidSprite | AsteroidsSprite | PolylineSprite&gt;	description of missle	missleCounter	&lt;ArithmeticValue&gt;	description of missleCounter	misslePlaying	&lt;Boolean&gt;	description of misslePlaying	missleSound	&lt;AudioClip&gt;	description of missleSound	newShipScore	&lt;ArithmeticValue&gt;	description of newShipScore	newUfoScore	&lt;ArithmeticValue&gt;	description of newUfoScore	numStars	&lt;SmallInteger&gt;	description of numStars	offGraphics	&lt;Graphics&gt;	description of offGraphics	paused	&lt;Boolean&gt;	description of paused	photonCounter	&lt;(Array of: ArithmeticValue)&gt;	description of photonCounter	photonIndex	&lt;ArithmeticValue&gt;	description of photonIndex	photons	&lt;BrowsingAgent | (Collection of: (AsteroidSprite | AsteroidsSprite | PolylineSprite)) | ColoredArea | LDMBrowserModel | LensGraphView | ListNavigatorPart | MethodCollector | PartListAbstractInspector | RadioButtonSpec | SQLAssist | TabNavigatorPart&gt;	description of photons	playing	&lt;Boolean&gt;	description of playing	right	&lt;Boolean&gt;	description of right	saucerPlaying	&lt;Boolean&gt;	description of saucerPlaying	saucerSound	&lt;AudioClip&gt;	description of saucerSound	score	&lt;ArithmeticValue&gt;	description of score	ship	&lt;AsteroidSprite | AsteroidsSprite | PolylineSprite&gt;	description of ship	shipCounter	&lt;ArithmeticValue&gt;	description of shipCounter	shipsLeft	&lt;ArithmeticValue&gt;	description of shipsLeft	size	&lt;Object&gt;	description of size	sound	&lt;Boolean&gt;	description of sound	stars	&lt;(Array of: Point)&gt;	description of stars	thrustersPlaying	&lt;Boolean&gt;	description of thrustersPlaying	thrustersSound	&lt;AudioClip&gt;	description of thrustersSound	ufo	&lt;AsteroidSprite | AsteroidsSprite | PolylineSprite&gt;	description of ufo	ufoCounter	&lt;ArithmeticValue&gt;	description of ufoCounter	ufoPassesLeft	&lt;ArithmeticValue&gt;	description of ufoPassesLeft	up	&lt;Boolean&gt;	description of up	warpSound	&lt;AudioClip&gt;	description of warpSound</body></comment><class><name>ThrottledAsteroids</name><environment>Steroids</environment><super>Steroids.Asteroids</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameTimes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Steroids</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.ThrottledAsteroids</class-id><body></body></comment><class><name>KeyboardProcessor</name><environment>Steroids</environment><super>UI.KeyboardProcessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Steroids-VW Specific</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.KeyboardProcessor</class-id><body>I am a specialized KeyboardProcess that will also forward key release events to the keyboardHook.</body></comment><class><name>AsteroidsAppModel</name><environment>Steroids</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pixmap asteroids process actions actionMutex </inst-vars><class-inst-vars></class-inst-vars><imports>			Steroids.KeyboardProcessor			Smalltalk.Graphics.*			Smalltalk.Kernel.*			Smalltalk.UI.*			Smalltalk.Tools.*			</imports><category>Steroids-VW Specific</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.AsteroidsAppModel</class-id><body>I provide the minimal way to display the Asteroids game.  I'm quirky (resize me and the game restarts).Instance Variables:	actions	&lt;OrderedCollection of: BlockClosure&gt; The action to pass to the game	asteroids	&lt;Asteroids&gt;		The Asteroids game	gc	&lt;GraphicsContext&gt;	The graphics context to use	graphics	&lt;Graphics&gt;	description of graphics	pixmap	&lt;Pixmap&gt;	The pixmap to display to	process	&lt;Process&gt;	The stepping process for the game</body></comment><class><name>ThrottledAsteroidsAppModel</name><environment>Steroids</environment><super>Steroids.AsteroidsAppModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tickSemaphore frameDelay </inst-vars><class-inst-vars></class-inst-vars><imports>			Steroids.KeyboardProcessor			Smalltalk.Graphics.*			Smalltalk.Kernel.*			Smalltalk.UI.*			Smalltalk.Tools.*			</imports><category>Steroids-VW Specific</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.ThrottledAsteroidsAppModel</class-id><body></body></comment><class><name>Polygon</name><environment>Steroids</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>npoints xpoints ypoints polyline </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Steroids-Fake Java</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.Polygon</class-id><body>Polygon is a truly minimal representation of what the java version of Polygon is.  I used the following URL for a reference:	http://java.sun.com/products/java-media/2D/forDevelopers/2Dapi/java/awt/Polygon.htmland only added what I needed to get going.  Instance Variables:	bounds	&lt;Number&gt;	Bounds of the polygon - this class doesn't use it.	npoints	&lt;Number&gt;	The total number of points	xpoints	&lt;OrderedCollection of: Number&gt;	The array of x coordinates	ypoints	&lt;OrderedCollection of: Number&gt;	The array of y coordinates</body></comment><class><name>BoundsCachingPolyline</name><environment>Steroids</environment><super>Graphics.Polyline</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bounds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.BoundsCachingPolyline</class-id><body></body></comment><class><name>AsteroidsSprite</name><environment>Steroids</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>width height shape active angle deltaAngle currentX currentY deltaX deltaY sprite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Steroids</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.AsteroidsSprite</class-id><body>I took the AsteroidsSprite class found in Asteroids.java, and created a Smalltalk class in VisualWorks. I basically took the Java method, copied it as a comment to a Smalltalk method - cut &amp; paste until it looked like Smalltalk then accepted it.   It was tough to leave those class variables with leading lower case names. :)  The only real changes I made was to add accessor and a printOn for easier debugging.  The comments below come straight from the Asteroids.java file.  The AsteroidsSprite class defines a game object, including it's shape,  position, movement and rotation. It also can detemine if two objects collide.Instance Variables:	active	&lt;Boolean&gt;	Active flag.	angle	&lt;Number&gt;	description of angle	currentX	&lt;Number&gt;	description of currentX	currentY	&lt;Number&gt;	description of currentY	deltaAngle	&lt;Number&gt;	Amount to change the rotation angle.	deltaX	&lt;Number&gt;	Amount to change the screen position.	deltaY	&lt;Number&gt;	Amount to change the screen position.	shape	&lt;Polygon&gt;	Initial sprite shape, centered at the origin (0,0).	sprite	&lt;Polygon&gt;	Final location and shape of sprite after applying rotation and						moving to screen position. Used for drawing on the screen and						in detecting collisions.Class Variables:	height	&lt;Number&gt;	Dimensions of the graphics area.	width	&lt;Number&gt;	Dimensions of the graphics area.</body></comment><class><name>RatedAsteroids</name><environment>Steroids</environment><super>Steroids.Asteroids</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameTimes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Steroids</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.RatedAsteroids</class-id><body></body></comment><class><name>AudioClip</name><environment>Steroids</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>url soundPlayer soundAvailable filename </inst-vars><class-inst-vars></class-inst-vars><imports>			OS.*			</imports><category>Steroids-Fake Java</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.AudioClip</class-id><body>AudioClip is a minimal version of the Java AudioClip class.  I got my descriptions from:	http://java.sun.com/j2se/1.4.1/docs/api/java/applet/AudioClip.htmlSince VW doesn't have built in au support, I changed AudioClip to play wav files.Instance Variables:	soundAvailable	&lt;Boolean&gt;	Can sound be played on this platform	soundPlayer	&lt;WindowsMultimedia&gt;	The media layer	url	&lt;URI&gt;	filename of the wave file</body></comment><class><name>AsteroidsHelp</name><environment>Steroids</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>playingText playingLabel controlsLabel tableInterface controlsText scoringTableInterface scoringText scoringLabel </inst-vars><class-inst-vars></class-inst-vars><imports>			Graphics.*			UI.*			</imports><category>Steroids-VW Specific</category><attributes><package>Steroids</package></attributes></class><comment><class-id>Steroids.AsteroidsHelp</class-id><body></body></comment><shared-variable><name>TwoPi</name><environment>Steroids.AsteroidsSprite</environment><private>false</private><constant>true</constant><category>constants</category><initializer>Double pi * 2</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>width</name><environment>Steroids.AsteroidsSprite</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>height</name><environment>Steroids.AsteroidsSprite</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>STORM_PAUSE</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>30 </initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MAX_SHIPS</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer> 3 "Starting number of ships per game" </initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MAX_ROCK_SIDES</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer> 12 </initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MAX_ROCKS</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer> 8 "asteroids and explosions" </initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>NEW_UFO_POINTS</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer> 2750 "Number of points between flying saucers"</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MIN_ROCK_SIZE</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>20.0</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>UFO_POINTS</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>250</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MIN_ROCK_SIDES</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer> 8 </initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MAX_ROCK_SIZE</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>50.0</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MAX_ROCK_SPEED</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>12.0</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MAX_SCRAP</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>20</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>SMALL_POINTS</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>50</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>SCRAP_COUNT</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer> 30 "Counter starting values" </initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>HYPER_COUNT</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>60</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>NEW_SHIP_POINTS</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer> 5000 "Number of points needed to earn a new ship." </initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>BIG_POINTS</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>25</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MISSLE_POINTS</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer> 500 "Starting number of ships per game" </initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MIN_ROCK_SPEED</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>2.0</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>UFO_PASSES</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer>3</initializer><attributes><package>Steroids</package></attributes></shared-variable><shared-variable><name>MAX_SHOTS</name><environment>Steroids.Asteroids</environment><private>false</private><constant>true</constant><category>constants</category><initializer> 6 "Maximum number of sprites for photons" </initializer><attributes><package>Steroids</package></attributes></shared-variable><methods><class-id>Steroids.Asteroids</class-id> <category>As yet unclassified</category><body package="Steroids" selector="drawNotPlayingInfoOn:">drawNotPlayingInfoOn: pixmap	| s gc bounds |	gc := pixmap graphicsContext.	bounds := pixmap bounds.	gc paint: ColorValue white.	(ComposedText		withText: (s := '	A S T E R O I D S')		style: font)			displayOn: gc			at: (bounds width - (gc widthOfString: s)) @ bounds height / 2.	(ComposedText		withText: (s := '	Copyright 1998 by Mike Hall')		style: font)			displayOn: gc			at: (bounds width - (gc widthOfString: s)) / 2 @ (bounds height / 2 + fontHeight).	loaded		ifTrue: 			[(ComposedText				withText: (s := 'Game Over')				style: font)					displayOn: gc					at: (bounds width - (gc widthOfString: s)) / 2@ (bounds height / 4).			(ComposedText				withText: (s := '''S'' to Start')				style: font)					displayOn: gc					at: (bounds width - (gc widthOfString: s)) / 2 @ (bounds height / 4 + fontHeight).			(ComposedText				withText: (s := '''F1'' for help')				style: font)					displayOn: gc					at: (bounds width - (gc widthOfString: s)) / 2 @ (bounds height / 4 + (fontHeight + fontHeight))]		ifFalse: 			[(ComposedText				withText: (s := 'Loading sounds...')				style: font)					displayOn: gc					at: (bounds width - (gc widthOfString: s)) / 2 @ (bounds height / 4)]</body><body package="Steroids" selector="endGame">endGame	"Stop ship, flying saucer, guided missle and associated sounds"	playing := false.	self stopShip.	self stopUfo.	self stopMissle	"  public void endGame() {    // Stop ship, flying saucer, guided missle and associated sounds.    playing = false;    stopShip();    stopUfo();    stopMissle();  }"</body><body package="Steroids" selector="explode:">explode: s 	"Create sprites for explosion animation. The each individual line segment	of the given sprite is used to create a new sprite that will move	outward  from the sprite's original position with a random rotation."	| c i  j |	s render.	c := 2.	(detail or: [s sprite npoints &lt;= 6]) ifTrue: [c := 1].	i := 1.	[i &lt;= s sprite npoints] whileTrue: 			[explosionIndex := explosionIndex + 1.			explosionIndex &gt;= MAX_SCRAP ifTrue: [explosionIndex := 1].			(explosions at: explosionIndex) active: true.			(explosions at: explosionIndex) shape: Polygon Polygon.			(explosions at: explosionIndex) shape addPoint_x: (s shape xpoints at: i)				y: (s shape ypoints at: i).			j := i + 1.			j &gt;= s sprite npoints ifTrue: [j := j - s sprite npoints + 1].			(explosions at: explosionIndex) shape addPoint_x: (s shape xpoints at: j)				y: (s shape ypoints at: j).			(explosions at: explosionIndex) angle: s angle.			(explosions at: explosionIndex) 				deltaAngle: (random next * 2 * Double pi - Double pi) / 15.0d.			(explosions at: explosionIndex) currentX: s currentX.			(explosions at: explosionIndex) currentY: s currentY.			(explosions at: explosionIndex) 				deltaX: (s shape xpoints at: i) negated / 5.			(explosions at: explosionIndex) 				deltaY: (s shape ypoints at: i) negated / 5.			explosionCounter at: explosionIndex put: SCRAP_COUNT.			i := i + c]	"  public void explode(AsteroidsSprite s) {    int c, i, j;    // Create sprites for explosion animation. The each individual line segment    // of the given sprite is used to create a new sprite that will move    // outward  from the sprite's original position with a random rotation.    s.render();    c = 2;    if (detail || s.sprite.npoints &lt; 6)      c = 1;    for (i = 0; i &lt; s.sprite.npoints; i += c) {      explosionIndex++;      if (explosionIndex &gt;= MAX_SCRAP)        explosionIndex = 0;      explosions[explosionIndex].active = true;      explosions[explosionIndex].shape = new Polygon();      explosions[explosionIndex].shape.addPoint(s.shape.xpoints[i], s.shape.ypoints[i]);      j = i + 1;      if (j &gt;= s.sprite.npoints)        j -= s.sprite.npoints;      explosions[explosionIndex].shape.addPoint(s.shape.xpoints[j], s.shape.ypoints[j]);      explosions[explosionIndex].angle = s.angle;      explosions[explosionIndex].deltaAngle = (Math.random() * 2 * Math.PI - Math.PI) / 15;      explosions[explosionIndex].currentX = s.currentX;      explosions[explosionIndex].currentY = s.currentY;      explosions[explosionIndex].deltaX = -s.shape.xpoints[i] / 5;      explosions[explosionIndex].deltaY = -s.shape.ypoints[i] / 5;      explosionCounter[explosionIndex] = SCRAP_COUNT;    }  }    return true;  }  "</body><body package="Steroids" selector="getAppletInfo">getAppletInfo	^'Asteroids, Copyright 1998 by Mike Hall.'	"  public String getAppletInfo() {    return(""Asteroids, Copyright 1998 by Mike Hall."");  }  "</body><body package="Steroids" selector="guideMissle">guideMissle	| dx dy angle |	(ship active not or: [hyperCounter &gt; 0]) ifTrue: [^self].	"Find the angle needed to hit the ship"	dx := ship currentX - missle currentX.	dy := ship currentY - missle currentY.	dx = 0 		ifTrue: 			[angle := (dy &lt; 0 ifTrue: [Double pi negated] ifFalse: [Double pi]) / 2]		ifFalse: 			[dy = 0				ifTrue: [angle := 0]				ifFalse:					[angle := (dy / dx) abs arcTan.					dy &gt; 0 ifTrue: [angle := angle negated].					dx &lt; 0 ifTrue: [angle := Double pi - angle]]].	"Adjust angle for screen coordinates"	missle angle: angle - (Double pi / 2).	"Change the missle's angle so that it points toward the ship."	missle deltaX: MIN_ROCK_SIZE / 3 * missle angle sin negated.	missle deltaY: MIN_ROCK_SIZE / 3 * missle angle cos</body><body package="Steroids" selector="init">init	| d extent |	"Take credit."	Transcript		cr;		show: 'Asteroids, Copyright 1998 by Mike Hall.'.	d := self size.	AsteroidsSprite width: d width.	AsteroidsSprite height: d height.	"Generate starry background."	numStars := (AsteroidsSprite width * AsteroidsSprite height / 5000) 				truncated.	extent := AsteroidsSprite width @ AsteroidsSprite height.	stars := (1 to: numStars) collect: [:i| (random next @ random next * extent) truncated].	"Create shape for the ship sprite"	ship := AsteroidsSprite AsteroidsSprite.	ship shape addPoint_x: 0 y: -10.	ship shape addPoint_x: 7 y: 10.	ship shape addPoint_x: -7 y: 10.	"Create shape for the photon sprites."	1 to: MAX_SHOTS do:		[:i|		(photons at: i put: AsteroidsSprite AsteroidsSprite)			shape				addPoint_x: 1 y: 1;				addPoint_x: 1 y: -1;				addPoint_x: -1 y: 1;				addPoint_x: -1 y: -1].	"Create shape for the flying saucer."	ufo := AsteroidsSprite AsteroidsSprite.	ufo shape addPoint_x: -15 y: 0.	ufo shape addPoint_x: -10 y: -5.	ufo shape addPoint_x: -5 y: -5.	ufo shape addPoint_x: -5 y: -9.	ufo shape addPoint_x: 5 y: -9.	ufo shape addPoint_x: 5 y: -5.	ufo shape addPoint_x: 10 y: -5.	ufo shape addPoint_x: 15 y: 0.	ufo shape addPoint_x: 10 y: 5.	ufo shape addPoint_x: -10 y: 5.	"Create shape for the guided missle."	missle := AsteroidsSprite AsteroidsSprite.	missle shape addPoint_x: 0 y: -4.	missle shape addPoint_x: 1 y: -3.	missle shape addPoint_x: 1 y: 3.	missle shape addPoint_x: 2 y: 4.	missle shape addPoint_x: -2 y: 4.	missle shape addPoint_x: -1 y: 3.	missle shape addPoint_x: -1 y: -3.	"Create asteroid sprites."	1 to: MAX_ROCKS do:		[:i| asteroids at: i put: AsteroidsSprite AsteroidsSprite].	"Create explosion sprites."	1 to: MAX_SCRAP do:		[:i| explosions at: i put: AsteroidsSprite AsteroidsSprite].	"not sure on this yet"	"    // Set font data.    g.setFont(font);    fm = g.getFontMetrics();    fontWidth = fm.getMaxAdvance();    fontHeight = fm.getHeight();"	"Initialize game data and put us in 'game over' mode"	highScore := 0.	sound := true.	detail := true.	self initGame.	self endGame	"  public void init() {    Graphics g;    Dimension d;    int i;    // Take credit.    System.out.println("	"Asteroids, Copyright 1998 by Mike Hall."	");    // Find the size of the screen and set the values for sprites.    g = getGraphics();    d = size();    AsteroidsSprite.width = d.width;    AsteroidsSprite.height = d.height;    // Generate starry background.    numStars = AsteroidsSprite.width * AsteroidsSprite.height / 5000;    stars = new Point[numStars];    for (i = 0; i &lt; numStars; i++)      stars[i] = new Point((int) (Math.random() * AsteroidsSprite.width), (int) (Math.random() * AsteroidsSprite.height));    // Create shape for the ship sprite.    ship = new AsteroidsSprite();    ship.shape.addPoint(0, -10);    ship.shape.addPoint(7, 10);    ship.shape.addPoint(-7, 10);    // Create shape for the photon sprites.    for (i = 0; i &lt; MAX_SHOTS; i++) {      photons[i] = new AsteroidsSprite();      photons[i].shape.addPoint(1, 1);      photons[i].shape.addPoint(1, -1);      photons[i].shape.addPoint(-1, 1);      photons[i].shape.addPoint(-1, -1);    }    // Create shape for the flying saucer.    ufo = new AsteroidsSprite();    ufo.shape.addPoint(-15, 0);    ufo.shape.addPoint(-10, -5);    ufo.shape.addPoint(-5, -5);    ufo.shape.addPoint(-5, -9);    ufo.shape.addPoint(5, -9);    ufo.shape.addPoint(5, -5);    ufo.shape.addPoint(10, -5);    ufo.shape.addPoint(15, 0);    ufo.shape.addPoint(10, 5);    ufo.shape.addPoint(-10, 5);    // Create shape for the guided missle.    missle = new AsteroidsSprite();    missle.shape.addPoint(0, -4);    missle.shape.addPoint(1, -3);    missle.shape.addPoint(1, 3);    missle.shape.addPoint(2, 4);    missle.shape.addPoint(-2, 4);    missle.shape.addPoint(-1, 3);    missle.shape.addPoint(-1, -3);    // Create asteroid sprites.    for (i = 0; i &lt; MAX_ROCKS; i++)      asteroids[i] = new AsteroidsSprite();    // Create explosion sprites.    for (i = 0; i &lt; MAX_SCRAP; i++)      explosions[i] = new AsteroidsSprite();    // Set font data.    g.setFont(font);    fm = g.getFontMetrics();    fontWidth = fm.getMaxAdvance();    fontHeight = fm.getHeight();    // Initialize game data and put us in 'game over' mode.    highScore = 0;    sound = true;    detail = true;    initGame();    endGame();  }  "</body><body package="Steroids" selector="initAsteroids">initAsteroids	"Create random shapes, positions and movements for each asteroid."	| s theta r x y |	1 to: MAX_ROCKS do:		[:i| | asteroid |		"Create random shapes, positions and movements for each asteroid."		asteroid := asteroids at: i.		asteroid shape: Polygon Polygon.		s := MIN_ROCK_SIDES 					+ (random next * (MAX_ROCK_SIDES - MIN_ROCK_SIDES)) truncated.		1 to: s do:			[:j|			theta := 2 * Double pi / s * j.			r := MIN_ROCK_SIZE 							+ (random next * (MAX_ROCK_SIZE - MIN_ROCK_SIZE)) truncated.			x := (r * theta sin) rounded negated truncated.			y := (r * theta cos) rounded truncated.			asteroid shape addPoint_x: x y: y].		asteroid active: true.		asteroid angle: 0.0d.		asteroid deltaAngle: (random next - 0.5d) / 10.		"Place the asteroid at one edge of the screen."		random next &lt; 0.5d 			ifTrue: 				[asteroid currentX: (AsteroidsSprite width / 2) negated.				random next &lt; 0.5d 					ifTrue: [asteroid currentX: AsteroidsSprite width / 2].				asteroid currentY: random next * AsteroidsSprite height]			ifFalse: 				[asteroid currentX: random next * AsteroidsSprite width.				asteroid currentY: (AsteroidsSprite height / 2) negated.				random next &lt; 0.5d 					ifTrue: [asteroid currentY: AsteroidsSprite height / 2]].		"Set a random motion for the asteroid."		asteroid deltaX: random next * asteroidsSpeed.		random next &lt; 0.5d 			ifTrue: [asteroid deltaX: asteroid deltaX negated].		asteroid deltaY: random next * asteroidsSpeed.		random next &lt; 0.5d 			ifTrue: [asteroid deltaY: asteroid deltaY negated].		asteroid render.		asteroidIsSmall at: i put: false].	asteroidsCounter := STORM_PAUSE.	asteroidsLeft := MAX_ROCKS.	asteroidsSpeed &lt; MAX_ROCK_SPEED ifTrue:		[asteroidsSpeed := asteroidsSpeed + 1]	"    public void initAsteroids() {    int i, j;    int s;    double theta, r;    int x, y;    // Create random shapes, positions and movements for each asteroid.    for (i = 0; i &lt; MAX_ROCKS; i++) {      // Create a jagged shape for the asteroid and give it a random rotation.      asteroids[i].shape = new Polygon();      s = MIN_ROCK_SIDES + (int) (Math.random() * (MAX_ROCK_SIDES - MIN_ROCK_SIDES));      for (j = 0; j &lt; s; j ++) {        theta = 2 * Math.PI / s * j;        r = MIN_ROCK_SIZE + (int) (Math.random() * (MAX_ROCK_SIZE - MIN_ROCK_SIZE));        x = (int) -Math.round(r * Math.sin(theta));        y = (int)  Math.round(r * Math.cos(theta));        asteroids[i].shape.addPoint(x, y);      }      asteroids[i].active = true;      asteroids[i].angle = 0.0;      asteroids[i].deltaAngle = (Math.random() - 0.5) / 10;      // Place the asteroid at one edge of the screen.      if (Math.random() &lt; 0.5) {        asteroids[i].currentX = -AsteroidsSprite.width / 2;        if (Math.random() &lt; 0.5)          asteroids[i].currentX = AsteroidsSprite.width / 2;        asteroids[i].currentY = Math.random() * AsteroidsSprite.height;      }      else {        asteroids[i].currentX = Math.random() * AsteroidsSprite.width;        asteroids[i].currentY = -AsteroidsSprite.height / 2;        if (Math.random() &lt; 0.5)          asteroids[i].currentY = AsteroidsSprite.height / 2;      }      // Set a random motion for the asteroid.      asteroids[i].deltaX = Math.random() * asteroidsSpeed;      if (Math.random() &lt; 0.5)        asteroids[i].deltaX = -asteroids[i].deltaX;      asteroids[i].deltaY = Math.random() * asteroidsSpeed;      if (Math.random() &lt; 0.5)        asteroids[i].deltaY = -asteroids[i].deltaY;      asteroids[i].render();      asteroidIsSmall[i] = false;    }    asteroidsCounter = STORM_PAUSE;    asteroidsLeft = MAX_ROCKS;    if (asteroidsSpeed &lt; MAX_ROCK_SPEED)      asteroidsSpeed++;  }"</body><body package="Steroids" selector="initExplosions">initExplosions	1 to: MAX_SCRAP do:		[:i|		(explosions at: i)			shape: Polygon Polygon;			active: false.		explosionCounter at: i put: 1].	explosionIndex := 0	"  public void initExplosions() {    int i;    for (i = 0; i &lt; MAX_SCRAP; i++) {      explosions[i].shape = new Polygon();      explosions[i].active = false;      explosionCounter[i] = 0;    }    explosionIndex = 0;  }  "</body><body package="Steroids" selector="initGame">initGame	" Initialize game data and sprites."	score := 0.	shipsLeft := MAX_SHIPS.	asteroidsSpeed := MIN_ROCK_SPEED.	newShipScore := NEW_SHIP_POINTS.	newUfoScore := NEW_UFO_POINTS.	self initShip.	self initPhotons.	self stopUfo.	self stopMissle.	self initAsteroids.	self initExplosions.	playing := true.	paused := false	"public void initGame() {    // Initialize game data and sprites.    score = 0;    shipsLeft = MAX_SHIPS;    asteroidsSpeed = MIN_ROCK_SPEED;    newShipScore = NEW_SHIP_POINTS;    newUfoScore = NEW_UFO_POINTS;    initShip();    initPhotons();    stopUfo();    stopMissle();    initAsteroids();    initExplosions();    playing = true;    paused = false;  }"</body><body package="Steroids" selector="initMissle">initMissle	missle active: true.	missle angle: 0.0.	missle deltaAngle: 0.0.	missle currentX: ufo currentX.	missle currentY: ufo currentY.	missle deltaX: 0.0.	missle deltaY: 0.0.	missle render.	missleCounter := 3 * ((AsteroidsSprite width  max: AsteroidsSprite height) / MIN_ROCK_SIZE) 								truncated.	sound ifTrue: [missleSound loop].	misslePlaying := true	"  public void initMissle() {    missle.active = true;    missle.angle = 0.0;    missle.deltaAngle = 0.0;    missle.currentX = ufo.currentX;    missle.currentY = ufo.currentY;    missle.deltaX = 0.0;    missle.deltaY = 0.0;    missle.render();    missleCounter = 3 * Math.max(AsteroidsSprite.width, AsteroidsSprite.height) / MIN_ROCK_SIZE;    if (sound)      missleSound.loop();    misslePlaying = true;  }  "</body><body package="Steroids" selector="initPhotons">initPhotons	1 to: MAX_SHOTS do:		[:i|			(photons at: i) active: false.			photonCounter at: i put: 0].	photonIndex := 1	"  public void initPhotons() {    int i;    for (i = 0; i &lt; MAX_SHOTS; i++) {      photons[i].active = false;      photonCounter[i] = 0;    }    photonIndex = 0;  }"</body><body package="Steroids" selector="initShip">initShip	ship active: true.	ship angle: 0.0.	ship deltaAngle: 0.0.	ship currentX: 0.0.	ship currentY: 0.0.	ship deltaX: 0.0.	ship deltaY: 0.0.	ship render.	loaded ifTrue: [thrustersSound stop].	thrustersPlaying := false	"  public void initShip() {    ship.active = true;    ship.angle = 0.0;    ship.deltaAngle = 0.0;    ship.currentX = 0.0;    ship.currentY = 0.0;    ship.deltaX = 0.0;    ship.deltaY = 0.0;    ship.render();    if (loaded)      thrustersSound.stop();    thrustersPlaying = false;    hyperCounter = 0;  }"</body><body package="Steroids" selector="initSmallAsteroids:">initSmallAsteroids: n 	"Create one or two smaller asteroids from a larger one using inactive	asteroids. The new asteroids will be placed in the same position as the	old one but will have a new, smaller shape and new, randomly generated	movements."	| count i s tempX tempY theta r x y |	count := 0.	i := 1.	tempX := (asteroids at: n) currentX.	tempY := (asteroids at: n) currentY.		[| asteroid |	asteroid := (asteroids at: i).	asteroid active ifFalse:		[asteroid shape: Polygon Polygon.		s := MIN_ROCK_SIDES 					+ (random next * (MAX_ROCK_SIDES - MIN_ROCK_SIDES)) truncated.		0 to: s - 1 do:			[:j|			theta := 2 * Double pi / s * j.			r := ((MIN_ROCK_SIZE + (random next * (MAX_ROCK_SIZE - MIN_ROCK_SIZE))) 							/ 2) truncated.			x := (r * theta sin) rounded negated truncated.			y := (r * theta cos) rounded truncated.			asteroid shape addPoint_x: x y: y].		asteroid active: true.		asteroid angle: 0.0d.		asteroid deltaAngle: (random next - 0.5d) / 10.		asteroid currentX: tempX.		asteroid currentY: tempY.		asteroid 			deltaX: random next * 2 * asteroidsSpeed - asteroidsSpeed.		asteroid 			deltaY: random next * 2 * asteroidsSpeed - asteroidsSpeed.		asteroid render.		asteroidIsSmall at: i put: true.		count := count + 1.		asteroidsLeft := asteroidsLeft + 1].	i &lt; MAX_ROCKS and: [count &lt; 2]] 		whileTrue: [i := i + 1]	"  public void initSmallAsteroids(int n) {    int count;    int i, j;    int s;    double tempX, tempY;    double theta, r;    int x, y;    // Create one or two smaller asteroids from a larger one using inactive    // asteroids. The new asteroids will be placed in the same position as the    // old one but will have a new, smaller shape and new, randomly generated    // movements.    count = 0;    i = 0;    tempX = asteroids[n].currentX;    tempY = asteroids[n].currentY;    do {      if (!asteroids[i].active) {        asteroids[i].shape = new Polygon();        s = MIN_ROCK_SIDES + (int) (Math.random() * (MAX_ROCK_SIDES - MIN_ROCK_SIDES));        for (j = 0; j &lt; s; j ++) {          theta = 2 * Math.PI / s * j;          r = (MIN_ROCK_SIZE + (int) (Math.random() * (MAX_ROCK_SIZE - MIN_ROCK_SIZE))) / 2;          x = (int) -Math.round(r * Math.sin(theta));          y = (int)  Math.round(r * Math.cos(theta));          asteroids[i].shape.addPoint(x, y);        }        asteroids[i].active = true;        asteroids[i].angle = 0.0;        asteroids[i].deltaAngle = (Math.random() - 0.5) / 10;        asteroids[i].currentX = tempX;        asteroids[i].currentY = tempY;        asteroids[i].deltaX = Math.random() * 2 * asteroidsSpeed - asteroidsSpeed;        asteroids[i].deltaY = Math.random() * 2 * asteroidsSpeed - asteroidsSpeed;        asteroids[i].render();        asteroidIsSmall[i] = true;        count++;        asteroidsLeft++;      }      i++;    } while (i &lt; MAX_ROCKS &amp;&amp; count &lt; 2);  }"</body><body package="Steroids" selector="initUfo">initUfo	"Randomly set flying saucer at left or right edge of the screen."	ufo active: true.	ufo currentX: AsteroidsSprite width negated / 2.	ufo currentY: random next * AsteroidsSprite height.	ufo deltaX: MIN_ROCK_SPEED + (random next * (MAX_ROCK_SPEED - MIN_ROCK_SPEED)).	random next &lt; 0.5 ifTrue: 		[ufo deltaX: ufo deltaX negated.		ufo currentX: AsteroidsSprite width / 2].	ufo deltaY: MIN_ROCK_SPEED + (random next * (MAX_ROCK_SPEED - MIN_ROCK_SPEED)).	random next &lt; 0.5 ifTrue: [ufo deltaY: ufo deltaY negated].	ufo render.	saucerPlaying := true.	sound ifTrue: [saucerSound loop].	"Set counter for this pass."	ufoCounter := (AsteroidsSprite width / ufo deltaX abs) floor truncated	"  public void initUfo() {    double temp;    // Randomly set flying saucer at left or right edge of the screen.    ufo.active = true;    ufo.currentX = -AsteroidsSprite.width / 2;    ufo.currentY = Math.random() * AsteroidsSprite.height;    ufo.deltaX = MIN_ROCK_SPEED + Math.random() * (MAX_ROCK_SPEED - MIN_ROCK_SPEED);    if (Math.random() &lt; 0.5) {      ufo.deltaX = -ufo.deltaX;      ufo.currentX = AsteroidsSprite.width / 2;    }    ufo.deltaY = MIN_ROCK_SPEED + Math.random() * (MAX_ROCK_SPEED - MIN_ROCK_SPEED);    if (Math.random() &lt; 0.5)      ufo.deltaY = -ufo.deltaY;    ufo.render();    saucerPlaying = true;    if (sound)      saucerSound.loop();    // Set counter for this pass.    ufoCounter = (int) Math.floor(AsteroidsSprite.width / Math.abs(ufo.deltaX));  }"</body><body package="Steroids" selector="keyDown:">keyDown: key 	key = #Left ifTrue: [left := true].	key = #Right ifTrue: [right := true].	key = #Down ifTrue: [down := true].	key = #Up ifTrue: [up := true].	((up or: [down]) and: [ship active and: [thrustersPlaying not]]) 		ifTrue: 			[(sound and: [paused not]) ifTrue: [thrustersSound loop].			thrustersPlaying := true].	"Spacebar: fire a photon and start its counter."	(key = 32 and: [ship active]) 		ifTrue: 			[(sound and: [paused not]) ifTrue: [fireSound play].			photonIndex := photonIndex + 1.			photonIndex &gt;= MAX_SHOTS ifTrue: [photonIndex := 1].			(photons at: photonIndex) active: true.			(photons at: photonIndex) currentX: ship currentX.			(photons at: photonIndex) currentY: ship currentY.			(photons at: photonIndex) deltaX: MIN_ROCK_SIZE * ship angle sin negated.			(photons at: photonIndex) deltaY: MIN_ROCK_SIZE * ship angle cos.			photonCounter at: photonIndex				put: (AsteroidsSprite width min: AsteroidsSprite height) / MIN_ROCK_SIZE].	"'H' key: warp ship into hyperspace by moving to a random location and	starting counter."	(key = 104 and: [ship active and: [hyperCounter &lt;= 0]]) 		ifTrue: 			[ship currentX: random next * AsteroidsSprite width.			ship currentX: random next * AsteroidsSprite height.			hyperCounter := HYPER_COUNT.			(sound and: [paused not]) ifTrue: [warpSound play]].	"'P' key: toggle pause mode and start or stop any active looping sound	clips."	key = 112 		ifTrue: 			[paused 				ifTrue: 					[(sound and: [misslePlaying]) ifTrue: [missleSound loop].					(sound and: [saucerPlaying]) ifTrue: [saucerSound loop].					(sound and: [thrustersPlaying]) ifTrue: [thrustersSound loop]]				ifFalse: 					[misslePlaying ifTrue: [missleSound stop].					saucerPlaying ifTrue: [saucerSound stop].					thrustersPlaying ifTrue: [thrustersSound stop]].			paused := paused not].	"'M' key: toggle sound on or off and stop any looping sound clips."	(key == 109 and: [loaded]) 		ifTrue: 			[sound 				ifTrue: 					[crashSound stop.					explosionSound stop.					fireSound stop.					missleSound stop.					saucerSound stop.					thrustersSound stop.					warpSound stop]				ifFalse: 					[(misslePlaying and: [paused not]) ifTrue: [missleSound loop].					(saucerPlaying and: [paused not]) ifTrue: [saucerSound loop].					(thrustersPlaying and: [paused not]) ifTrue: [thrustersSound loop]].			sound := sound not].	"'D' key: toggle graphics detail on or off."	key == 100 ifTrue: [detail := detail not].	"'S' key: start the game, if not already in progress."	(key = 115 and: [loaded and: [playing not]]) ifTrue: [self initGame].	^true	"  public boolean keyDown(Event e, int key) {    // Check if any cursor keys have been pressed and set flags.    if (key == Event.LEFT)      left = true;    if (key == Event.RIGHT)      right = true;    if (key == Event.UP)      up = true;    if (key == Event.DOWN)      down = true;    if ((up || down) &amp;&amp; ship.active &amp;&amp; !thrustersPlaying) {      if (sound &amp;&amp; !paused)        thrustersSound.loop();      thrustersPlaying = true;    }    // Spacebar: fire a photon and start its counter.    if (key == 32 &amp;&amp; ship.active) {      if (sound &amp; !paused)        fireSound.play();      photonIndex++;      if (photonIndex &gt;= MAX_SHOTS)        photonIndex = 0;      photons[photonIndex].active = true;      photons[photonIndex].currentX = ship.currentX;      photons[photonIndex].currentY = ship.currentY;      photons[photonIndex].deltaX = MIN_ROCK_SIZE * -Math.sin(ship.angle);      photons[photonIndex].deltaY = MIN_ROCK_SIZE *  Math.cos(ship.angle);      photonCounter[photonIndex] = Math.min(AsteroidsSprite.width, AsteroidsSprite.height) / MIN_ROCK_SIZE;    }    // 'H' key: warp ship into hyperspace by moving to a random location and    // starting counter.    if (key == 104 &amp;&amp; ship.active &amp;&amp; hyperCounter &lt;= 0) {      ship.currentX = Math.random() * AsteroidsSprite.width;      ship.currentX = Math.random() * AsteroidsSprite.height;      hyperCounter = HYPER_COUNT;      if (sound &amp; !paused)        warpSound.play();    }    // 'P' key: toggle pause mode and start or stop any active looping sound    // clips.    if (key == 112) {      if (paused) {        if (sound &amp;&amp; misslePlaying)          missleSound.loop();        if (sound &amp;&amp; saucerPlaying)          saucerSound.loop();        if (sound &amp;&amp; thrustersPlaying)          thrustersSound.loop();      }      else {        if (misslePlaying)          missleSound.stop();        if (saucerPlaying)          saucerSound.stop();        if (thrustersPlaying)          thrustersSound.stop();      }      paused = !paused;    }    // 'M' key: toggle sound on or off and stop any looping sound clips.    if (key == 109 &amp;&amp; loaded) {      if (sound) {        crashSound.stop();        explosionSound.stop();        fireSound.stop();        missleSound.stop();        saucerSound.stop();        thrustersSound.stop();        warpSound.stop();      }      else {        if (misslePlaying &amp;&amp; !paused)          missleSound.loop();        if (saucerPlaying &amp;&amp; !paused)          saucerSound.loop();        if (thrustersPlaying &amp;&amp; !paused)          thrustersSound.loop();      }      sound = !sound;    }    // 'D' key: toggle graphics detail on or off.    if (key == 100)      detail = !detail;    // 'S' key: start the game, if not already in progress.    if (key == 115 &amp;&amp; loaded &amp;&amp; !playing)      initGame();    return true;  }"</body><body package="Steroids" selector="keyUp:">keyUp: key 	"Check if any cursor keys where released and set flags"	key = #Left ifTrue: [left := false].	key = #Right ifTrue: [right := false].	key = #Down ifTrue: [down := false].	key = #Up ifTrue: [up := false].	(up not and: [down not and: [thrustersPlaying]]) 		ifTrue: 			[thrustersSound stop.			thrustersPlaying := false].	^true	"  public boolean keyUp(Event e, int key) {    // Check if any cursor keys where released and set flags.    if (key == Event.LEFT)      left = false;    if (key == Event.RIGHT)      right = false;    if (key == Event.UP)      up = false;    if (key == Event.DOWN)      down = false;    if (!up &amp;&amp; !down &amp;&amp; thrustersPlaying) {      thrustersSound.stop();      thrustersPlaying = false;    }    return true;  }  "</body><body package="Steroids" selector="loadSounds">loadSounds	"Load all sound clips by playing and immediately stopping them."		| soundDirectory |	"Look for the wave files"	soundDirectory := Filename fromComponents: #('$(VISUALWORKS)' 'parc' 'Steroids').	soundDirectory definitelyExists ifFalse: [soundDirectory := Filename currentDirectory].	crashSound url: (soundDirectory construct: 'crash.wav') asFilename asURI.	explosionSound url: (soundDirectory construct:  'explosion.wav') asFilename asURI.	fireSound url: (soundDirectory construct:  'fire.wav') asFilename asURI.	missleSound url: (soundDirectory construct:  'missle.wav') asFilename asURI.	saucerSound url: (soundDirectory construct:  'saucer.wav') asFilename asURI.	thrustersSound url: (soundDirectory construct:  'thrusters.wav') asFilename asURI.	warpSound url: (soundDirectory construct:  'warp.wav') asFilename asURI</body><body package="Steroids" selector="paint:">paint: pixmap	| s gc bounds |	gc := pixmap graphicsContext.	bounds := pixmap bounds.	"Fill in background and stars."	gc paint: ColorValue black.	(0 @ 0 corner: bounds extent) displayFilledOn: gc.	detail ifTrue: 		[gc paint: ColorValue white.		1 to: numStars do:			[:i| | star |			star := stars at: i.			gc displayLineFrom: star to: star + (1@0)]].	"Draw photon bullets."	gc paint: ColorValue white.	1 to: MAX_SHOTS do:		[:i| (photons at: i) active ifTrue: [gc displayPolyline: (photons at: i) sprite points]].	"Draw the guided missle, counter is used to quickly fade color to black	when near expiration."	gc paint: (ColorValue brightness: (missleCounter * 24 min: 256) / 256.0).	missle active ifTrue: 		[gc displayPolyline: missle sprite points].	"Draw the asteroids."	1 to: MAX_ROCKS do:		[:i| | asteroid |		(asteroid := asteroids at: i) active ifTrue: 			[detail ifTrue: 				[gc paint: ColorValue black.				 gc displayPolygon: asteroid sprite points].			gc paint: ColorValue white.			gc displayPolyline: (asteroids at: i) sprite points]].	"Draw the flying saucer."	ufo active ifTrue: 		[detail ifTrue: 			[gc paint: ColorValue black.			gc displayPolygon: ufo sprite points].		gc paint: ColorValue white.		gc displayPolyline: ufo sprite points].	"Draw the ship, counter is used to fade color to white on hyperspace."	ship active ifTrue: 		[(detail and: [hyperCounter = 0]) ifTrue: 				[gc paint: ColorValue black.				gc displayPolygon: ship sprite points].		gc paint: (ColorValue brightness: 256.0 - (256.0 / HYPER_COUNT * hyperCounter) / 256.0).		gc displayPolyline: ship sprite points].	"Draw any explosion debris, counters are used to fade color to black."	1 to: MAX_SCRAP do:		[:i|		(explosions at: i) active ifTrue: 			[gc paint: (ColorValue brightness: 256.0 / SCRAP_COUNT * (explosionCounter at: i) / 256.0).			gc displayPolyline: (explosions at: i) sprite points]].	"Display status and messages"	gc paint: ColorValue white.	(ComposedText		withText: ('		Score: 	' , score printString) asText		style: font)			displayOn: gc at: fontWidth@fontHeight.	(ComposedText		withText: ('		Ships: 	' , shipsLeft printString) asText		style: font)			displayOn: gc at: fontWidth@(bounds height - fontHeight).	(ComposedText		withText: (s := 'High: ' , highScore printString) asText		style: font)			displayOn: gc at: bounds width - (fontWidth + (gc widthOfString: s))@fontHeight.	sound ifFalse:		[(ComposedText			withText: (s := '	Mute') asText			style: font)				displayOn: gc at: bounds width - (fontWidth + (gc widthOfString: s))@(bounds height - fontHeight)].	playing 		ifFalse: [self drawNotPlayingInfoOn: pixmap]		ifTrue: 			[paused 				ifTrue: 					[(ComposedText						withText: (s := 'Game Paused') asText						style: font)							displayOn: gc							at: (bounds width - (gc widthOfString: s)) / 2 @ (bounds height / 4)]]</body><body package="Steroids" selector="size">size	^size</body><body package="Steroids" selector="size:">size: aRectangle 	size := aRectangle</body><body package="Steroids" selector="start">start		"  public void start() {    if (loopThread == null) {      loopThread = new Thread(this);      loopThread.start();    }    if (!loaded &amp;&amp; loadThread == null) {      loadThread = new Thread(this);      loadThread.start();    }  }  "</body><body package="Steroids" selector="step">step	loaded ifFalse: 		[self loadSounds.		 loaded := true].	paused ifFalse: 		["Move and process all sprites."		self updateGame.		"Check the score and advance high score, add a new ship or 		start the flying saucer as necessary."		score &gt; highScore ifTrue: [highScore := score].		score &gt; newShipScore ifTrue: 			[newShipScore := newShipScore + NEW_SHIP_POINTS.			shipsLeft := shipsLeft + 1].		(playing and: [score &gt; newUfoScore and: [ufo active not]]) ifTrue: 			[newUfoScore := newUfoScore + NEW_UFO_POINTS.			ufoPassesLeft := ufoPassesLeft + UFO_PASSES.			self initUfo].		"If all asteroids have been destroyed create a new batch."		asteroidsLeft &lt;= 0 ifTrue: 			[asteroidsCounter := asteroidsCounter - 1.			asteroidsCounter &lt;= 0 ifTrue: [self initAsteroids]]]	"  public void run() {    int i, j;    long startTime;    // Lower this thread's priority and get the current time.    Thread.currentThread().setPriority(Thread.MIN_PRIORITY);    startTime = System.currentTimeMillis();    // Run thread for loading sounds.    if (!loaded &amp;&amp; Thread.currentThread() == loadThread) {      loadSounds();      loaded = true;      loadThread.stop();    }    // This is the main loop.    while (Thread.currentThread() == loopThread) {      if (!paused) {        // Move and process all sprites.        updateShip();        updatePhotons();        updateUfo();        updateMissle();        updateAsteroids();        updateExplosions();        // Check the score and advance high score, add a new ship or start the        // flying saucer as necessary.        if (score &gt; highScore)          highScore = score;        if (score &gt; newShipScore) {          newShipScore += NEW_SHIP_POINTS;          shipsLeft++;        }        if (playing &amp;&amp; score &gt; newUfoScore &amp;&amp; !ufo.active) {          newUfoScore += NEW_UFO_POINTS;          ufoPassesLeft = UFO_PASSES;          initUfo();        }        // If all asteroids have been destroyed create a new batch.        if (asteroidsLeft &lt;= 0)            if (--asteroidsCounter &lt;= 0)              initAsteroids();      }      // Update the screen and set the timer for the next loop.      repaint();      try {        startTime += DELAY;        Thread.sleep(Math.max(0, startTime - System.currentTimeMillis()));      }      catch (InterruptedException e) {        break;      }    }  }"</body><body package="Steroids" selector="stop">stop		"  public void stop() {    if (loopThread != null) {      loopThread.stop();      loopThread = null;    }    if (loadThread != null) {      loadThread.stop();      loadThread = null;    }  }"</body><body package="Steroids" selector="stopMissle">stopMissle	missle active: false.	missleCounter := 0.	loaded ifTrue: [missleSound stop].	misslePlaying := false	"  public void stopMissle() {    missle.active = false;    missleCounter = 0;    if (loaded)      missleSound.stop();    misslePlaying = false;  }  "</body><body package="Steroids" selector="stopShip">stopShip	ship active: false.	shipCounter := SCRAP_COUNT.	shipsLeft &gt; 0 ifTrue: [shipsLeft := shipsLeft - 1].	loaded ifTrue: [thrustersSound stop].	thrustersPlaying := false	"  public void stopShip() {    ship.active = false;    shipCounter = SCRAP_COUNT;    if (shipsLeft &gt; 0)      shipsLeft--;    if (loaded)      thrustersSound.stop();    thrustersPlaying = false;  }"</body><body package="Steroids" selector="stopUfo">stopUfo	ufo active: false.	ufoCounter := 0.	ufoPassesLeft := 0.	loaded ifTrue: [saucerSound stop].	saucerPlaying := false	" public void stopUfo() {    ufo.active = false;    ufoCounter = 0;    ufoPassesLeft = 0;    if (loaded)      saucerSound.stop();    saucerPlaying = false;  }"</body><body package="Steroids" selector="updateAsteroids">updateAsteroids	"Move any active asteroids and check for collisions."	1 to: MAX_ROCKS do:		[:i| | asteroid |		(asteroid := asteroids at: i) active ifTrue:			[asteroid advance.			asteroid render.			"If hit by photon, kill asteroid and advance score. If asteroid is			large, make some smaller ones to replace it."			1 to: MAX_SHOTS do:				[:j| | photon |				((photon := photons at: j) active				and: [asteroid active 				and: [asteroid isColliding: photon]]) ifTrue: 					[asteroidsLeft := asteroidsLeft - 1.					asteroid active: false.					photon active: false.					sound ifTrue: [explosionSound play].					self explode: asteroid.					(asteroidIsSmall at: i)						ifTrue:[score := score + SMALL_POINTS]						ifFalse: [score := score + BIG_POINTS.									self initSmallAsteroids: i]]].			"If the ship is not in hyperspace, see if it is hit."			(ship active			and: [hyperCounter &lt;= 0 			and: [asteroid active and: [asteroid isColliding: ship]]]) ifTrue: 				[sound ifTrue: [crashSound play].				self explode: ship.				self stopShip.				self stopUfo.				self stopMissle]]]	"  public void updateAsteroids() {    int i, j;    // Move any active asteroids and check for collisions.    for (i = 0; i &lt; MAX_ROCKS; i++)      if (asteroids[i].active) {        asteroids[i].advance();        asteroids[i].render();        // If hit by photon, kill asteroid and advance score. If asteroid is        // large, make some smaller ones to replace it.        for (j = 0; j &lt; MAX_SHOTS; j++)          if (photons[j].active &amp;&amp; asteroids[i].active &amp;&amp; asteroids[i].isColliding(photons[j])) {            asteroidsLeft--;            asteroids[i].active = false;            photons[j].active = false;            if (sound)              explosionSound.play();            explode(asteroids[i]);            if (!asteroidIsSmall[i]) {              score += BIG_POINTS;              initSmallAsteroids(i);            }            else              score += SMALL_POINTS;          }        // If the ship is not in hyperspace, see if it is hit.        if (ship.active &amp;&amp; hyperCounter &lt;= 0 &amp;&amp; asteroids[i].active &amp;&amp; asteroids[i].isColliding(ship)) {          if (sound)            crashSound.play();          explode(ship);          stopShip();          stopUfo();          stopMissle();        }    }  }  "</body><body package="Steroids" selector="updateExplosions">updateExplosions	1 to: MAX_SCRAP do:		[:i| | explosion |		(explosion := explosions at: i) active ifTrue: 			[explosion advance; render.			(explosionCounter at: i put: (explosionCounter at: i) - 1) &lt; 1 ifTrue:				[explosion active: false]]]	"  public void updateExplosions() {    int i;    // Move any active explosion debris. Stop explosion when its counter has    // expired.    for (i = 0; i &lt; MAX_SCRAP; i++)      if (explosions[i].active) {        explosions[i].advance();        explosions[i].render();        if (--explosionCounter[i] &lt; 0)          explosions[i].active = false;      }  }"</body><body package="Steroids" selector="updateGame">updateGame	self updateShip.	self updatePhotons.	self updateUfo.	self updateMissle.	self updateAsteroids.	self updateExplosions</body><body package="Steroids" selector="updateMissle">updateMissle	missle active ifTrue:		[(missleCounter := missleCounter - 1) &lt;= 1 			ifTrue: [self stopMissle]			ifFalse: 				[self guideMissle.				missle advance; render.				1 to: MAX_SHOTS do:					[:i|					((photons at: i) active and: [missle isColliding: (photons at: i)]) ifTrue: 						[sound ifTrue: [crashSound play].						self explode: missle.						self stopMissle.						score := score + MISSLE_POINTS]].				(missle active 				 and: [ship active				 and: [hyperCounter &lt;= 1				 and: [ship isColliding: missle]]]) ifTrue: 					[sound ifTrue: [crashSound play].					self explode: ship.					self stopShip.					self stopUfo.					self stopMissle]]]	"public void updateMissle() {    int i;    // Move the guided missle and check for collision with ship or photon. Stop    // it when its counter has expired.    if (missle.active) {      if (--missleCounter &lt;= 0)        stopMissle();      else {        guideMissle();        missle.advance();        missle.render();        for (i = 0; i &lt; MAX_SHOTS; i++)          if (photons[i].active &amp;&amp; missle.isColliding(photons[i])) {            if (sound)              crashSound.play();            explode(missle);            stopMissle();            score += MISSLE_POINTS;          }        if (missle.active &amp;&amp; ship.active &amp;&amp; hyperCounter &lt;= 0 &amp;&amp; ship.isColliding(missle)) {          if (sound)            crashSound.play();          explode(ship);          stopShip();          stopUfo();          stopMissle();        }      }    }  }"</body><body package="Steroids" selector="updatePhotons">updatePhotons	1 to: MAX_SHOTS do:		[:i| | photon |		photon := photons at: i.		photon active ifTrue: 			[photon advance; render.			photonCounter at: i put: (photonCounter at: i) - 1.			(photonCounter at: i) &lt; 0 ifTrue: [photon active: false]]]	"  public void updatePhotons() {    int i;    // Move any active photons. Stop it when its counter has expired.    for (i = 0; i &lt; MAX_SHOTS; i++)      if (photons[i].active) {        photons[i].advance();        photons[i].render();        if (--photonCounter[i] &lt; 0)          photons[i].active = false;      }  }  }"</body><body package="Steroids" selector="updateShip">updateShip	| dx dy limit |	playing ifFalse: [^self].	"Rotate the ship if left or right cursor key is down."	left 		ifTrue: 			[ship angle: ship angle + (Double pi / 16.0d).			ship angle &gt; (2 * Double pi) 				ifTrue: [ship angle: ship angle - (2 * Double pi)]].	right 		ifTrue: 			[ship angle: ship angle - (Double pi / 16.0d).			ship angle &lt; 0 ifTrue: [ship angle: ship angle + (2 * Double pi)]].	"Fire thrusters if up or down cursor key is down. Don't let ship go past	the speed limit."	dx := ship angle sin negated.	dy := ship angle cos.	limit := 0.8d * MIN_ROCK_SIZE.	up 		ifTrue: 			[(ship deltaX + dx &gt; limit negated and: [ship deltaX + dx &lt; limit]) 				ifTrue: [ship deltaX: ship deltaX + dx].			(ship deltaY + dy &gt; limit negated and: [ship deltaY + dy &lt; limit]) 				ifTrue: [ship deltaY: ship deltaY + dy]].	down 		ifTrue: 			[(ship deltaX - dx &gt; limit negated and: [ship deltaX - dx &lt; limit]) 				ifTrue: [ship deltaX: ship deltaX - dx].			(ship deltaY - dy &gt; limit negated and: [ship deltaY - dy &lt; limit]) 				ifTrue: [ship deltaY: ship deltaY - dy]].	"Move the ship. If it is currently in hyperspace, advance the countdown."	ship active 		ifTrue: 			[ship advance.			ship render.			hyperCounter &gt; 0 ifTrue: [hyperCounter := hyperCounter - 1]]		ifFalse: 			["Ship is exploding, advance the countdown or create a new ship if it is			done exploding. The new ship is added as though it were in hyperspace.			(This gives the player time to move the ship if it is in imminent			danger.) If that was the last ship, end the game."			shipCounter := shipCounter - 1.			shipCounter &lt;= 0 				ifTrue: 					[shipsLeft &gt; 0 						ifTrue: 							[self initShip.							hyperCounter := HYPER_COUNT]						ifFalse: [self endGame]]]	"  public void updateShip() {    double dx, dy, limit;    if (!playing)      return;    // Rotate the ship if left or right cursor key is down.    if (left) {      ship.angle += Math.PI / 16.0;      if (ship.angle &gt; 2 * Math.PI)        ship.angle -= 2 * Math.PI;    }    if (right) {      ship.angle -= Math.PI / 16.0;      if (ship.angle &lt; 0)        ship.angle += 2 * Math.PI;    }    // Fire thrusters if up or down cursor key is down. Don't let ship go past    // the speed limit.    dx = -Math.sin(ship.angle);    dy =  Math.cos(ship.angle);    limit = 0.8 * MIN_ROCK_SIZE;    if (up) {      if (ship.deltaX + dx &gt; -limit &amp;&amp; ship.deltaX + dx &lt; limit)        ship.deltaX += dx;      if (ship.deltaY + dy &gt; -limit &amp;&amp; ship.deltaY + dy &lt; limit)        ship.deltaY += dy;    }    if (down) {      if (ship.deltaX - dx &gt; -limit &amp;&amp; ship.deltaX - dx &lt; limit)        ship.deltaX -= dx;      if (ship.deltaY - dy &gt; -limit &amp;&amp; ship.deltaY - dy &lt; limit)        ship.deltaY -= dy;    }    // Move the ship. If it is currently in hyperspace, advance the countdown.    if (ship.active) {      ship.advance();      ship.render();      if (hyperCounter &gt; 0)        hyperCounter--;    }    // Ship is exploding, advance the countdown or create a new ship if it is    // done exploding. The new ship is added as though it were in hyperspace.    // (This gives the player time to move the ship if it is in imminent    // danger.) If that was the last ship, end the game.    else      if (--shipCounter &lt;= 0)        if (shipsLeft &gt; 0) {          initShip();          hyperCounter = HYPER_COUNT;        }        else          endGame();  }  "</body><body package="Steroids" selector="updateUfo">updateUfo	| d |	ufo active ifTrue:		[ufo advance.		 ufo render.		 ufoCounter := ufoCounter - 1.		 ufoCounter &lt;= 0 		 	ifTrue: 		 		[ufoPassesLeft := ufoPassesLeft - 1.		 		ufoPassesLeft &gt; 0 ifTrue: [self initUfo] ifFalse: [self stopUfo]]		 	ifFalse: 		 		[1 to: MAX_SHOTS do:		 			[:i| ((photons at: i) active and: [ufo isColliding: (photons at: i)]) 		 					ifTrue: 		 						[sound ifTrue: [crashSound play].		 						self explode: ufo.		 						self stopUfo.		 						score := score + UFO_POINTS]]].		 "On occassion, fire a missle at the ship if the saucer is not too		close to it."		 d := ((ufo currentX - ship currentX) abs 		 			max: (ufo currentY - ship currentY) abs) truncated.		 (ship active and: 		 		[hyperCounter &lt;= 0 and: 		 				[ufo active and: 		 						[missle active not 		 							and: [d &gt; (4 * MAX_ROCK_SIZE) and: [random next &lt; 0.03d]]]]]) 		 	ifTrue: [self initMissle]]	"  public void updateUfo() {    int i, d;    // Move the flying saucer and check for collision with a photon. Stop it    // when its counter has expired.    if (ufo.active) {      ufo.advance();      ufo.render();      if (--ufoCounter &lt;= 0)        if (--ufoPassesLeft &gt; 0)          initUfo();        else          stopUfo();      else {        for (i = 0; i &lt; MAX_SHOTS; i++)          if (photons[i].active &amp;&amp; ufo.isColliding(photons[i])) {            if (sound)              crashSound.play();            explode(ufo);            stopUfo();            score += UFO_POINTS;          }          // On occassion, fire a missle at the ship if the saucer is not too          // close to it.          d = (int) Math.max(Math.abs(ufo.currentX - ship.currentX), Math.abs(ufo.currentY - ship.currentY));          if (ship.active &amp;&amp; hyperCounter &lt;= 0 &amp;&amp; ufo.active &amp;&amp; !missle.active &amp;&amp;              d &gt; 4 * MAX_ROCK_SIZE &amp;&amp; Math.random() &lt; .03)            initMissle();       }    }  }"</body></methods><methods><class-id>Steroids.Asteroids</class-id> <category>initialize-release</category><body package="Steroids" selector="initialize">initialize	| fd ca |	numStars := 0.	loaded := false.	paused := false.	playing := false.	sound := false.	detail := false.	"Game data"	score := 0.	highScore := 0.	newShipScore := 0.	newUfoScore := 0.	"Ship data"	shipsLeft := 0.	"Number of ships left to play, including current one."	shipCounter := 0.	"Time counter for ship explosion."	hyperCounter := 0.	"Time counter for hyperspace."	"Key flags"	left := false.	right := false.	up := false.	down := false.	"Sprite objects"	ship := AsteroidsSprite AsteroidsSprite.	ufo := AsteroidsSprite AsteroidsSprite.	missle := AsteroidsSprite AsteroidsSprite.	photons := ((1 to: MAX_SHOTS) 				collect: [:i | AsteroidsSprite AsteroidsSprite]) asArray.	asteroids := ((1 to: MAX_ROCKS) 				collect: [:i | AsteroidsSprite AsteroidsSprite]) asArray.	explosions := ((1 to: MAX_SCRAP) 				collect: [:i | AsteroidsSprite AsteroidsSprite]) asArray.	"Photon data."	photonCounter := Array new: MAX_SHOTS withAll: 0.	"Time counter for life of a photon."	photonIndex := 1.	"Next available photon sprite."	"Flying saucer data."	ufoPassesLeft := 0.	"Number of flying saucer passes."	ufoCounter := 0.	"Time counter for each pass."	"Missle data."	missleCounter := 0.	"Counter for life of missle."	"Asteroid data."	asteroidIsSmall := Array new: MAX_ROCKS withAll: false.	"Asteroid size flag."	asteroidsCounter := 0.	"Break-time counter."	asteroidsSpeed := 0.	"Asteroid speed."	asteroidsLeft := 0.	"Number of active asteroids."	"Explosion data."	explosionCounter := Array new: MAX_SCRAP withAll: 0.	"Time counters for explosions."	explosionIndex := 0.	"Next available explosion sprite."	"Sound clips."	crashSound := AudioClip new.	explosionSound := AudioClip new.	fireSound := AudioClip new.	missleSound := AudioClip new.	saucerSound := AudioClip new.	thrustersSound := AudioClip new.	warpSound := AudioClip new. 	"Flags for looping sound clips."	 thrustersPlaying := false.	 saucerPlaying := false.	 misslePlaying := false.	"Font data.""	font := Font family: 'Helvetica' style: Font BOLD size: 12."		fd := FontDescription new.	fd family: #('helvetica' 'arial' '*');		manufacturer: #('*');		fixedWidth: false;		pixelSize: 16;		boldness: 1.0.	ca := CharacterAttributes newWithDefaultAttributes setDefaultQuery: fd.	font := TextAttributes characterAttributes: ca.	fontWidth := 10.	fontHeight := 15.	random := Random new</body></methods><methods><class-id>Steroids.Asteroids</class-id> <category>testing</category><body package="Steroids" selector="photonsValid">photonsValid	"Check that all of the photons that are active actually have sprites."	| photonSprites activePhotons |	activePhotons := photons select: [:each | each active].	photonSprites := activePhotons collect: [:each | each sprite].	self class 		assert: [photonSprites allSatisfy: [:each | each npoints ~= 0]]</body></methods><methods><class-id>Steroids.Asteroids class</class-id> <category>utilities</category><body package="Steroids" selector="assert:">assert: aBlock	"Copied from CodeReader"	| inspector source range |	aBlock value == true ifFalse:		[inspector := aBlock method inspectorClass inspect: aBlock.		source := aBlock method homeMethod getSource.		range := inspector pcRange.		self error: (#AssertionFailed &lt;&lt; #dialogs &gt;&gt; 'assertion failed &lt;1s&gt;'			expandMacrosWith: (source copyFrom: range first to: range last))]	"self  assert: [1 even and: [2 odd]]"</body></methods><methods><class-id>Steroids.Asteroids class</class-id> <category>instance creation</category><body package="Steroids" selector="new">new	^super new initialize</body></methods><methods><class-id>Steroids.Asteroids class</class-id> <category>tests</category><body package="Steroids" selector="test1">test1	"self test1"	| asteroids |	asteroids := self new.	asteroids init.	^asteroids</body></methods><methods><class-id>Steroids.ThrottledAsteroids</class-id> <category>private</category><body package="Steroids" selector="frameRateString">frameRateString	| start end |	^(start := frameTimes first) &gt;= (end := frameTimes last)		ifTrue: ['?']		ifFalse: [(1000000 * (frameTimes size - 1) // (end - start)) printString]</body></methods><methods><class-id>Steroids.ThrottledAsteroids</class-id> <category>initialize-release</category><body package="Steroids" selector="initialize">initialize	super initialize.	frameTimes := OrderedCollection new.</body></methods><methods><class-id>Steroids.ThrottledAsteroids</class-id> <category>game-display</category><body package="Steroids" selector="paint:">paint: pixmap	| s gc bounds |	super paint: pixmap.	gc := pixmap graphicsContext.	bounds := pixmap bounds.	gc paint: ColorValue white.	(ComposedText		withText: (s := 'Frame Rate:' , self frameRateString)		style: font)			displayOn: gc			at: bounds width - (gc widthOfString: s) // 2 @ fontHeight</body><body package="Steroids" selector="step">step	super step.	frameTimes addLast: Time microsecondClock.	frameTimes size &gt; 100 ifTrue: [frameTimes removeFirst]</body></methods><methods><class-id>Steroids.KeyboardProcessor</class-id> <category>event driven</category><body package="Steroids" selector="processKeyboardEvent:for:">processKeyboardEvent: keyboardEvent for: aController 	"Process keyboard input from aController's sensor."	"Re-implemented to remove the restriction of only passing along key down events."	| ev |	ev := keyboardEvent.	(keyboardHook notNil) ifTrue: 		["Allow the keyboard hook to process or modify the keyboardEvent."		ev := keyboardHook value: keyboardEvent value: aController].	ev == nil ifFalse: [self processKeyboardEvent: ev].	aController sensor window flush</body></methods><methods><class-id>Steroids.AsteroidsAppModel</class-id> <category>private</category><body package="Steroids" selector="addAction:">addAction: action 	"Add an action to the action queue."	actionMutex critical: [actions addLast: action]</body><body package="Steroids" selector="dealWithResize">dealWithResize	self stop.	pixmap := nil.	self setupGame.	^self start</body><body package="Steroids" selector="game:">game: anAsteroidsGame	asteroids := anAsteroidsGame</body><body package="Steroids" selector="handleKeyboardEvent:">handleKeyboardEvent: anEvent 	"Return true if handled, false otherwise"	| keyValue handled |	anEvent isKeyboard ifFalse: [^false].	keyValue := anEvent keyValue.	handled := false.	anEvent isKeyPress		ifTrue: 			[keyValue = #F1 ifTrue: 				[AsteroidsHelp open.				 handled := true].			keyValue = #Home ifTrue: "More convenient Hyperspace key"				[self addAction: [asteroids keyDown: $h asInteger].				 handled := true].			(#(#Right #Left #Down #Up) includes: keyValue) ifTrue:				[self addAction: [asteroids keyDown: keyValue].				 handled := true].			('sdphm ' includes: keyValue) ifTrue: 				[self addAction: [asteroids keyDown: keyValue asInteger].				 handled := true]]		ifFalse:			[(#(#Right #Left #Down #Up) includes: keyValue) ifTrue:				[self addAction: [asteroids keyUp: keyValue].				 handled := true]].	^handled</body><body package="Steroids" selector="removeAction">removeAction	"Return the next action in the queue, or nil if there is none."	^actionMutex 		critical: [actions isEmpty ifTrue: [nil] ifFalse: [actions removeFirst]]</body><body package="Steroids" selector="setupGame">setupGame	asteroids := asteroids class new.	asteroids size: self pixmap bounds.	asteroids init</body><body package="Steroids" selector="step">step	| bc |	[bc := self removeAction.	bc notNil] whileTrue: [bc value].	asteroids step; paint: self pixmap.	self pixmap displayOn: self mainWindow graphicsContext.	self mainWindow graphicsDevice sync</body></methods><methods><class-id>Steroids.AsteroidsAppModel</class-id> <category>interface closing</category><body package="Steroids" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow 	super noticeOfWindowClose: aWindow.	self stop</body></methods><methods><class-id>Steroids.AsteroidsAppModel</class-id> <category>accessing</category><body package="Steroids" selector="pixmap">pixmap	^pixmap isNil 		ifTrue: [pixmap := Pixmap extent: self builder window bounds extent]		ifFalse: [pixmap]</body></methods><methods><class-id>Steroids.AsteroidsAppModel</class-id> <category>interface opening</category><body package="Steroids" selector="postOpenWith:">postOpenWith: aBuilder 	| defIcon |	super postOpenWith: aBuilder.	self setupGame.	aBuilder keyboardProcessor 		keyboardHook: [:ev :ctrl | (self handleKeyboardEvent: ev) ifTrue: [nil] ifFalse: [ev]].	self mainWindow when: #resize do: [self dealWithResize].	self dealWithResize.	defIcon := Icon					figure: self class windowIcon					shape: self class windowIconMask.	defIcon cleanFigure.	aBuilder window icon: defIcon</body><body package="Steroids" selector="preBuildWith:">preBuildWith: aBuilder 	"Install our special KeyboardProcessor."	super preBuildWith: aBuilder.	aBuilder keyboardProcessor: KeyboardProcessor new</body></methods><methods><class-id>Steroids.AsteroidsAppModel</class-id> <category>actions</category><body package="Steroids" selector="start">start	self stop.	process := [[self step] repeat] forkAt: 49</body><body package="Steroids" selector="stop">stop	process isNil ifTrue: [^self].	process terminate</body></methods><methods><class-id>Steroids.AsteroidsAppModel</class-id> <category>initialize-release</category><body package="Steroids" selector="initialize">initialize	super initialize.	actions := OrderedCollection new.	actionMutex := Semaphore forMutualExclusion.	self game: Asteroids new</body></methods><methods><class-id>Steroids.AsteroidsAppModel class</class-id> <category>instance creation</category><body package="Steroids" selector="on:">on: anAsteroidsGame	^self new game: anAsteroidsGame</body></methods><methods><class-id>Steroids.AsteroidsAppModel class</class-id> <category>loading</category><body package="Steroids" selector="postLoadAction:">postLoadAction: package 	"Open a workspace with the nitty gritty."	| pageStream wb pages defIcon |	(package isNil or: [package isUpdating]) ifTrue: [^self].	pages := OrderedCollection new.	#(#comment #text_explanation #text_files_list #text_original_license ) 		with: #('Comment' 'Explanation' 'Files' 'Original License' )		do: 			[:key :label | 			pages add: (WorkspacePage labeled: label with: (package propertyAt: key))].	pageStream := pages readStream.	wb := Workbook new.	wb replaceAllTextPagesWith: pageStream next.	[pageStream atEnd] whileFalse: [wb addPage: pageStream next].	wb open.	defIcon := Icon new figure: self windowIcon shape: self windowIconMask.	defIcon cleanFigure.	wb builder window icon: defIcon.	wb builder window label: 'Asteroids Information'	"self postLoadAction: (Store.Registry packageNamed: 'Steroids')"	"self postLoadAction: (Parcel parcelNamed: 'Steroids')"</body></methods><methods><class-id>Steroids.ThrottledAsteroidsAppModel</class-id> <category>initialize-release</category><body package="Steroids" selector="initialize">initialize	tickSemaphore := Semaphore new.	frameDelay := Delay forMilliseconds: 1000 // 30.  "30 frames per second"	super initialize</body></methods><methods><class-id>Steroids.ThrottledAsteroidsAppModel</class-id> <category>private</category><body package="Steroids" selector="step">step	[frameDelay disable; wait. tickSemaphore signal]		forkAt: Processor userInterruptPriority.	super step.	tickSemaphore wait</body></methods><methods><class-id>Steroids.Polygon</class-id> <category>Methods</category><body package="Steroids" selector="addPoint_x:y:">addPoint_x: x y: y	"Appends the specified coordinates to this Polygon."	xpoints addLast: x.	ypoints addLast: y.	npoints := npoints + 1.	polyline := nil"addPointpublic void addPoint(int x,                     int y)Appends the specified coordinates to this Polygon. If an operation that calculates the bounding box of this Polygon has already been performed, such as getBounds or contains, then this method updates the bounding box.Parameters:x, y - the specified coordinates"</body><body package="Steroids" selector="contains_x:y:">contains_x: x y: y 	"Determines whether the specified coordinates are contained in this Polygon."	"El-cheapo way. :)"	^self polyline containsPoint: x @ y</body><body package="Steroids" selector="npoints">npoints	^npoints</body><body package="Steroids" selector="pointAt:">pointAt: i	^(xpoints at: i) @ (ypoints at: i)</body><body package="Steroids" selector="points">points	| points |	points := Array new: npoints + 1.	1 to: npoints do:		[:i|		points at: i put: (xpoints at: i) @ (ypoints at: i)].	points at: npoints + 1 put: points first.	^points</body><body package="Steroids" selector="xpoints">xpoints	^xpoints</body><body package="Steroids" selector="ypoints">ypoints	^ypoints</body></methods><methods><class-id>Steroids.Polygon</class-id> <category>initialize-release</category><body package="Steroids" selector="initialize">initialize	^self initialize: 5</body><body package="Steroids" selector="initialize:">initialize: anInteger	xpoints := OrderedCollection new: anInteger.	ypoints := OrderedCollection new: anInteger.	npoints := 0.</body></methods><methods><class-id>Steroids.Polygon</class-id> <category>private</category><body package="Steroids" selector="polyline">polyline	polyline == nil ifTrue:		[polyline := (BoundsCachingPolyline vertices: self points) asFiller].	^polyline</body></methods><methods><class-id>Steroids.Polygon</class-id> <category>printing</category><body package="Steroids" selector="printOn:">printOn: aStream 	| points |	super printOn: aStream.	points := OrderedCollection new.	xpoints with: ypoints do: [:x :y | points add: x @ y].	aStream nextPutAll: ' ('.	points do: [:point | point printOn: aStream]		separatedBy: [aStream nextPutAll: ', '].	aStream nextPutAll: ') '</body></methods><methods><class-id>Steroids.Polygon class</class-id> <category>instance creation</category><body package="Steroids" selector="new">new	^super new initialize</body><body package="Steroids" selector="new:">new: anInteger	^super new initialize: anInteger</body></methods><methods><class-id>Steroids.Polygon class</class-id> <category>Constructors</category><body package="Steroids" selector="Polygon">Polygon	"Creates an empty polygon."	^self new</body></methods><methods><class-id>Steroids.BoundsCachingPolyline</class-id> <category>accessing</category><body package="Steroids" selector="bounds">bounds	"Answer a rectangle that bounds the coordinate region used by the 	receiver."	bounds == nil ifTrue: [bounds := self computeBounds].	^bounds</body></methods><methods><class-id>Steroids.AsteroidsSprite</class-id> <category>accessing</category><body package="Steroids" selector="active">active	^active</body><body package="Steroids" selector="active:">active: anObject	active := anObject</body><body package="Steroids" selector="angle">angle	^angle</body><body package="Steroids" selector="angle:">angle: anObject	angle := anObject</body><body package="Steroids" selector="currentX">currentX	^currentX</body><body package="Steroids" selector="currentX:">currentX: anObject	currentX := anObject</body><body package="Steroids" selector="currentY">currentY	^currentY</body><body package="Steroids" selector="currentY:">currentY: anObject	currentY := anObject</body><body package="Steroids" selector="deltaAngle">deltaAngle	^deltaAngle</body><body package="Steroids" selector="deltaAngle:">deltaAngle: anObject	deltaAngle := anObject</body><body package="Steroids" selector="deltaX">deltaX	^deltaX</body><body package="Steroids" selector="deltaX:">deltaX: anObject	deltaX := anObject</body><body package="Steroids" selector="deltaY">deltaY	^deltaY</body><body package="Steroids" selector="deltaY:">deltaY: anObject	deltaY := anObject</body><body package="Steroids" selector="shape">shape	^shape</body><body package="Steroids" selector="shape:">shape: anObject	shape := anObject</body><body package="Steroids" selector="sprite">sprite	^sprite</body><body package="Steroids" selector="sprite:">sprite: anObject	sprite := anObject</body></methods><methods><class-id>Steroids.AsteroidsSprite</class-id> <category>Methods</category><body package="Steroids" selector="advance">advance	"Update the rotation and position of the sprite based on the delta	values. If the sprite moves off the edge of the screen, it is wrapped	around to the other side."	angle := angle + deltaAngle.	angle &lt; 0 ifTrue: [angle := angle + TwoPi].	angle &gt; TwoPi ifTrue: [angle := angle - TwoPi].	currentX := currentX + deltaX.	currentX &lt; (width negated / 2) ifTrue: [currentX := currentX + width].	currentX &gt; (width / 2) ifTrue: [currentX := currentX - width].	currentY := currentY - deltaY.	currentY &lt; (height negated / 2) ifTrue: [currentY := currentY + height].	currentY &gt; (height / 2) ifTrue: [currentY := currentY - height]"  public void advance() {    // Update the rotation and position of the sprite based on the delta    // values. If the sprite moves off the edge of the screen, it is wrapped    // around to the other side.    this.angle += this.deltaAngle;    if (this.angle &lt; 0)      this.angle += 2 * Math.PI;    if (this.angle &gt; 2 * Math.PI)      this.angle -= 2 * Math.PI;    this.currentX += this.deltaX;    if (this.currentX &lt; -width / 2)      this.currentX += width;    if (this.currentX &gt; width / 2)      this.currentX -= width;    this.currentY -= this.deltaY;    if (this.currentY &lt; -height / 2)      this.currentY += height;    if (this.currentY &gt; height / 2)      this.currentY -= height;  }"</body><body package="Steroids" selector="isColliding:">isColliding: s 	"Determine if one sprite overlaps with another, i.e., if any vertice of one sprite lands inside the other."	1 to: s sprite npoints do:		[:i| (sprite contains_x: (s sprite xpoints at: i) y: (s sprite ypoints at: i)) ifTrue: [^true]].	1 to: sprite npoints do:		[:i| (s sprite contains_x: (sprite xpoints at: i) y: (sprite ypoints at: i)) ifTrue: [^true]].	^false	"  public boolean isColliding(AsteroidsSprite s) {    int i;    // Determine if one sprite overlaps with another, i.e., if any vertice    // of one sprite lands inside the other.    for (i = 0; i &lt; s.sprite.npoints; i++)      if (this.sprite.inside(s.sprite.xpoints[i], s.sprite.ypoints[i]))        return true;    for (i = 0; i &lt; this.sprite.npoints; i++)      if (s.sprite.inside(this.sprite.xpoints[i], this.sprite.ypoints[i]))        return true;    return false;  }}"</body><body package="Steroids" selector="render">render	"Render the sprite's shape and location by rotating it's base shape and moving it to it's proper screen position."	| cos sin halfWidth halfHeight |	cos := angle cos.	sin := angle sin.	halfWidth := width / 2.	halfHeight := height / 2.	sprite := Polygon new: shape npoints.	1 to: shape npoints do: 		[:i | 		sprite 			addPoint_x: (((shape xpoints at: i) * cos + ((shape ypoints at: i) * sin)) 						rounded + (currentX + halfWidth) rounded truncated) 						truncated			y: (((shape ypoints at: i) * cos - ((shape xpoints at: i) * sin)) rounded 						+ currentY rounded + halfHeight truncated) 						truncated]	"    this.sprite = new Polygon();    for (i = 0; i &lt; this.shape.npoints; i++)      this.sprite.addPoint((int) Math.round(this.shape.xpoints[i] * Math.cos(this.angle) + this.shape.ypoints[i] * Math.sin(this.angle)) + (int) Math.round(this.currentX) + width / 2,                 (int) Math.round(this.shape.ypoints[i] * Math.cos(this.angle) - this.shape.xpoints[i] * Math.sin(this.angle)) + (int) Math.round(this.currentY) + height / 2);"</body></methods><methods><class-id>Steroids.AsteroidsSprite</class-id> <category>initialize-release</category><body package="Steroids" selector="initialize">initialize	width := self class width.	height := self class height</body></methods><methods><class-id>Steroids.AsteroidsSprite</class-id> <category>printing</category><body package="Steroids" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream cr.	aStream nextPutAll: ' [active] '.	active printOn: aStream.	aStream cr.	aStream nextPutAll: ' [shape] '.	shape printOn: aStream.	aStream cr.	aStream nextPutAll: ' [sprite] '.	sprite printOn: aStream</body></methods><methods><class-id>Steroids.AsteroidsSprite class</class-id> <category>Constructors</category><body package="Steroids" selector="AsteroidsSprite">AsteroidsSprite	"self AsteroidsSprite"	| asteroidsSprite |	asteroidsSprite := self new.	asteroidsSprite shape: Polygon new.	asteroidsSprite active: false.	asteroidsSprite angle: 0.0.	asteroidsSprite deltaAngle: 0.0.	asteroidsSprite currentX: 0.0.	asteroidsSprite currentY: 0.0.	asteroidsSprite deltaX: 0.0.	asteroidsSprite deltaY: 0.0.	asteroidsSprite sprite: Polygon new.	^asteroidsSprite</body></methods><methods><class-id>Steroids.AsteroidsSprite class</class-id> <category>accessing</category><body package="Steroids" selector="height">height	^height</body><body package="Steroids" selector="height:">height: anInteger	height := anInteger</body><body package="Steroids" selector="width">width	^width</body><body package="Steroids" selector="width:">width: anInteger	width := anInteger</body></methods><methods><class-id>Steroids.AsteroidsSprite class</class-id> <category>instance creation</category><body package="Steroids" selector="new">new	^super new initialize</body></methods><methods><class-id>Steroids.RatedAsteroids</class-id> <category>private</category><body package="Steroids" selector="frameRateString">frameRateString	| start end |	^(start := frameTimes first) &gt;= (end := frameTimes last)		ifTrue: ['?']		ifFalse: [(1000000 * (frameTimes size - 1) // (end - start)) printString]</body></methods><methods><class-id>Steroids.RatedAsteroids</class-id> <category>initialize-release</category><body package="Steroids" selector="initialize">initialize	super initialize.	frameTimes := OrderedCollection new.</body></methods><methods><class-id>Steroids.RatedAsteroids</class-id> <category>game-display</category><body package="Steroids" selector="paint:">paint: pixmap	| s gc bounds |	super paint: pixmap.	gc := pixmap graphicsContext.	bounds := pixmap bounds.	gc paint: ColorValue white.	(ComposedText		withText: (s := 'Frame Rate:' , self frameRateString)		style: font)			displayOn: gc			at: bounds width - (gc widthOfString: s) // 2 @ fontHeight</body><body package="Steroids" selector="step">step	super step.	frameTimes addLast: Time microsecondClock.	frameTimes size &gt; 100 ifTrue: [frameTimes removeFirst]</body></methods><methods><class-id>Steroids.AudioClip</class-id> <category>private</category><body package="Steroids" selector="checkSound">checkSound	"Return a boolean indicating we can actually play the sound file."	soundAvailable ifFalse: [^false].	filename isNil ifTrue: [filename := self url asFilename].	^[filename definitelyExists]		on: Error		do: [:ex |			filename := nil.			false]</body></methods><methods><class-id>Steroids.AudioClip</class-id> <category>initialize</category><body package="Steroids" selector="initialize">initialize	soundAvailable := false.	filename := nil.	"Only install the sound player if the class is around and we are on Windows."	#{OS.WindowsMultimedia} ifDefinedDo: 			[:wm | 			OSHandle currentOS == #win32 ifTrue: 				[soundPlayer := wm new.				 soundAvailable := true]]</body></methods><methods><class-id>Steroids.AudioClip</class-id> <category>sound</category><body package="Steroids" selector="loop">loop	self checkSound ifTrue: [soundPlayer playSoundFile: filename asString loop: true]</body><body package="Steroids" selector="play">play	self checkSound ifTrue: [soundPlayer playSoundFile: filename asString]</body><body package="Steroids" selector="stop">stop	self checkSound ifTrue: [soundPlayer stopSound]</body></methods><methods><class-id>Steroids.AudioClip</class-id> <category>accessing</category><body package="Steroids" selector="url">url	^url</body><body package="Steroids" selector="url:">url: anObject	url := anObject</body></methods><methods><class-id>Steroids.AudioClip class</class-id> <category>instance creation</category><body package="Steroids" selector="new">new	^super new initialize</body></methods><methods><class-id>Steroids.AsteroidsHelp</class-id> <category>aspects</category><body package="Steroids" selector="controlsLabel">controlsLabel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^controlsLabel isNil		ifTrue:			[controlsLabel := String new asValue]		ifFalse:			[controlsLabel]</body><body package="Steroids" selector="controlsText">controlsText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^controlsText isNil		ifTrue:			[controlsText := String new asValue]		ifFalse:			[controlsText]</body><body package="Steroids" selector="playingLabel">playingLabel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^playingLabel isNil		ifTrue:			[playingLabel := String new asValue]		ifFalse:			[playingLabel]</body><body package="Steroids" selector="playingText">playingText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^playingText isNil		ifTrue:			[playingText := String new asValue]		ifFalse:			[playingText]</body><body package="Steroids" selector="scoringLabel">scoringLabel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^scoringLabel isNil		ifTrue:			[scoringLabel := String new asValue]		ifFalse:			[scoringLabel]</body><body package="Steroids" selector="scoringTableInterface">scoringTableInterface	^scoringTableInterface</body><body package="Steroids" selector="scoringText">scoringText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^scoringText isNil		ifTrue:			[scoringText := String new asValue]		ifFalse:			[scoringText]</body><body package="Steroids" selector="tableInterface">tableInterface	^tableInterface</body></methods><methods><class-id>Steroids.AsteroidsHelp</class-id> <category>private</category><body package="Steroids" selector="helpStyle">helpStyle	| fd ca |	fd := FontDescription new.	fd		family: #('arial' 'helv*' '*');		manufacturer: #('adobe' '*');		pixelSize: 16.	ca := CharacterAttributes newWithDefaultAttributes setDefaultQuery: fd.	^TextAttributes characterAttributes: ca</body></methods><methods><class-id>Steroids.AsteroidsHelp</class-id> <category>initialize-release</category><body package="Steroids" selector="initialize">initialize	| list |	super initialize.	self setupRegionLabels.	self playingText value: (self class playingText asText 				emphasizeAllWith: #color -&gt; ColorValue lightYellow).	self scoringText 		value: ('A new ship is awarded for every 5000 points scored.' asText 				emphasizeAllWith: #color -&gt; ColorValue lightYellow).	list := TwoDList 				on: self class controlsData				columns: 4				rows: 5.	tableInterface := TableInterface new selectionInTable: (SelectionInTable with: list).	tableInterface columnWidths: #(130 130 130 130).	self controlsText value: self class controlsText.	list := TwoDList 				on: self class scoringData				columns: 4				rows: 2.	scoringTableInterface := TableInterface new selectionInTable: (SelectionInTable with: list).	scoringTableInterface columnWidths: #(130 130 130 130)</body><body package="Steroids" selector="setupRegionLabels">setupRegionLabels	self playingLabel 		value: ('Playing the Game' asText emphasizeAllWith: (Array with: #bold						with: #color -&gt; ColorValue white)).	self controlsLabel 		value: ('Controls' asText emphasizeAllWith: (Array with: #bold						with: #color -&gt; ColorValue white)).	self scoringLabel 		value: ('Scoring' asText emphasizeAllWith: (Array with: #bold						with: #color -&gt; ColorValue white))</body></methods><methods><class-id>Steroids.AsteroidsHelp</class-id> <category>interface opening</category><body package="Steroids" selector="postBuildWith:">postBuildWith: aBuilder 	| ta defIcon |	super postBuildWith: aBuilder.	ta := self helpStyle.	#(#playingText #playingLabel #controlsLabel #controlsTable #controlsText #scoringTable #scoringLabel #scoringText) 		do: [:key | (self widgetAt: key) textStyle: ta].	self tableInterface tableView 		backgroundColor: (ColorValue brightness: 0.429984).	self scoringTableInterface tableView 		backgroundColor: (ColorValue brightness: 0.429984).	defIcon := Icon new figure: AsteroidsAppModel windowIcon				shape: AsteroidsAppModel windowIconMask.	defIcon cleanFigure.	aBuilder window icon: defIcon</body></methods><methods><class-id>Steroids.AsteroidsHelp class</class-id> <category>instructions</category><body package="Steroids" selector="controlsData">controlsData	| array |	array := #('S' 'Start Game' 'P' 'Pause Game' 'Cursor Left' 'Rotate Left' 'Cursor Down' 'Reverse Thrust' 'Cursor Right' 'Rotate Right' 'Cursor Up' 'Forward Thrust' 'Spacebar' 'Fire Cannon' 'H or Home' 'Hyperspace' 'M' 'Toggle Sound' 'D' 'Toggle Graphics Detail').	^(1 to: array size) collect: 			[:index | 			(array at: index) asText emphasizeAllWith: (index odd 						ifTrue: [#color -&gt; ColorValue orange]						ifFalse: [#color -&gt; ColorValue white])]</body><body package="Steroids" selector="controlsText">controlsText	| s |	s := '*Note: If the game appears to run slowly on your machine, try turning sound and/or graphics detail off. This will not affect game play. ' 				asText.	s emphasizeAllWith: #color -&gt; ColorValue lightYellow.	s 		addEmphasis: #(#bold)		removeEmphasis: #()		allowDuplicates: false		from: 1		to: 6.	^s</body><body package="Steroids" selector="playingText">playingText	^'Use the keyboard controls described below to maneuver your ship, destroying as many asteroids as you can while avoiding collision with them. Also watch for the flying saucers armed with guided missles. If you warp into hyperspace, your ship will momentarily disappear then reappear on another part of the screen, gradually fading in. During this time the ship is invunerable. Likewise, when your ship is destroyed, a new one will appear in the center of the screen. You can still maneuver and fire during this time so if you are in imminent danger, you have a couple of seconds to get out of it. '</body><body package="Steroids" selector="scoringData">scoringData	| array |	array := #('Large Asteroids' '25' 'Small Asteroids' '50' 'Flying Saucer' '250' 'Enemy Missle' '500').	^(1 to: array size) collect: 			[:index | 			(array at: index) asText emphasizeAllWith: (index odd 						ifTrue: [#color -&gt; ColorValue orange]						ifFalse: [#color -&gt; ColorValue white])]</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>generated resources</category><body package="Steroids" selector="steroidsToolbarIcon">steroidsToolbarIcon	^ToolbarIconLibrary visualFor: #steroidsToolbarIcon</body></methods><methods><class-id>Steroids.AsteroidsAppModel class</class-id> <category>resources</category><body package="Steroids" selector="windowIcon">windowIcon	"UIMaskEditor new openOnClass: self andSelector: #windowIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0 29 0 0 0 241 0 0 3 131 0 0 14 2 0 0 56 6 0 0 224 4 0 3 128 12 0 6 0 8 0 12 0 16 0 22 0 48 0 3 0 32 0 1 128 96 0 0 192 64 0 0 96 128 0 0 49 128 0 0 27 0 0 0 14 0 0 0 4 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Steroids" selector="windowIconMask">windowIconMask	"UIMaskEditor new openOnClass: self andSelector: #windowIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 248 255 255 255 226 255 255 255 14 255 255 252 124 255 255 241 253 255 255 199 249 255 255 31 251 255 252 127 243 255 249 255 247 255 243 255 239 255 233 255 207 255 252 255 223 255 254 127 159 255 255 63 191 255 255 159 127 255 255 206 127 255 255 228 255 255 255 241 255 255 255 251 255 255 255 247 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255])</body></methods><methods><class-id>Steroids.AsteroidsAppModel class</class-id> <category>interface specs</category><body package="Steroids" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Asteroids' 			#bounds: #(#{Graphics.Rectangle} 0 0 560 510 ) 			#colors: 			#(#{UI.LookPreferences} 				#setBackgroundColor: #(#{Graphics.ColorValue} #black ) ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #() ) )</body></methods><methods><class-id>Steroids.AsteroidsHelp class</class-id> <category>interface specs</category><body package="Steroids" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: 'Asteroids Help' 			#min: #(#{Core.Point} 548 580 ) 			#max: #(#{Core.Point} 1280 1024 ) 			#bounds: #(#{Graphics.Rectangle} 640 268 1188 848 ) 			#colors: 			#(#{UI.LookPreferences} 				#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 5 0 -3 1 40 0 ) 					#name: #playing 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 5 0 -3 1 40 0 ) 					#name: #playingLabel 					#flags: 4 					#model: #playingLabel 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 43 0 -3 1 203 0 ) 					#name: #playingText 					#flags: 4 					#model: #playingText 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 206 0 -3 1 241 0 ) 					#name: #controls 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 206 0 -3 1 241 0 ) 					#name: #controlsLabel 					#flags: 4 					#model: #controlsLabel 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.TableViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 244 0 -3 1 390 0 ) 					#name: #controlsTable 					#flags: 4 					#model: #tableInterface 					#tabable: false ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 390 0 -3 1 450 0 ) 					#name: #controlsText 					#flags: 4 					#model: #controlsText 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 453 0 -3 1 483 0 ) 					#name: #scoring 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 453 0 -3 1 483 0 ) 					#name: #scoringLabel 					#flags: 4 					#model: #scoringLabel 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.TableViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 486 0 -3 1 526 0 ) 					#name: #scoringTable 					#flags: 4 					#model: #scoringTableInterface 					#tabable: false ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 529 0 -3 1 559 0 ) 					#name: #scoringText 					#flags: 4 					#model: #scoringText 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Steroids" selector="steroids">steroids	&lt;menuItem: 'Asteroids'		icon: #steroidsToolbarIcon		nameKey: nil		menu: #(#launcherToolBar)		position: 85.02		helpText: 'Play Asteroids'&gt;	Steroids.AsteroidsAppModel open</body><body package="Steroids" selector="steroidsThrottled">steroidsThrottled	&lt;menuItem: 'Asteroids'		icon: #steroidsToolbarIcon		nameKey: nil		menu: #(#launcherToolBar)		position: 85.03		helpText: 'Play Throttled Asteroids'&gt;	Steroids.ThrottledAsteroidsAppModel open</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="Steroids" selector="steroidsToolbarIcon20x20">steroidsToolbarIcon20x20	"UIMaskEditor new openOnClass: self andSelector: #steroidsToolbarIcon20x20"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 30 64 0 0 120 64 0 1 192 192 0 7 0 128 0 28 0 128 0 48 1 128 0 88 1 0 0 12 3 0 0 6 2 0 0 3 2 0 0 1 134 0 0 0 196 0 0 0 108 0 0 0 56 0 0 0 16 0 0 0 32 0 0]))</body><body package="Steroids" selector="steroidsToolbarIcon20x20mask">steroidsToolbarIcon20x20mask	"UIMaskEditor new openOnClass: self andSelector: #steroidsToolbarIcon20x20mask"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 240 0 255 255 240 0 255 255 240 0 255 252 48 0 255 225 176 0 255 135 176 0 254 63 48 0 248 255 112 0 227 255 112 0 207 254 112 0 167 254 240 0 243 252 240 0 249 253 240 0 252 253 240 0 254 121 240 0 255 59 240 0 255 147 240 0 255 199 240 0 255 239 240 0 255 223 240 0]))</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>KeyboardProcessor</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardConsumers currentConsumer default cancel keyboardHook focusIsShifting currentConsumerChannel acceptOnControlChange menuBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>Polyline</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>vertices </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>