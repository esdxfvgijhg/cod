<?xml version="1.0"?><st-source><!-- Name: Parcel Load BrowserNotice: Copyright © 1999, 2000, 2002, 2001 Cincom Systems, Inc.  All Rights Reserved.Comment: A Parcels Load Browser allows one ease to view, select, and search parcels to load by name, class, and path.HideSource: falsePackageName: Parcel Load BrowserPackageName:: Parcel Load BrowserParcel: #('ParcelLoadBrowser')ParcelName: Parcel Load BrowserSaveSource: trueVersion: 7.1Date: 10:44:23 am October 24, 2005 --><time-stamp>From VisualWorks®, Pre-Release 7.4 (oct05.3) of October 18, 2005 on October 24, 2005 at 10:44:23 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>FileAssociationTree</name><environment>UI</environment><super>UI.AssociationTreeWithParent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isDirectory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Parcels Load Dialog</category><attributes><package>Parcel Load Browser</package></attributes></class><comment><class-id>UI.FileAssociationTree</class-id><body>Instances of this class represent a file system tree node for directories or files. Instance Variables:	isDirectory	&lt;Boolean&gt;	optimization for whether this instance represents a directory</body></comment><class><name>ParcelLoadBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parcelsTree parcelsToLoad pageKeys comment parcelNameCache unlist obeyVersion searchDirectories viewMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Parcels Load Dialog</category><attributes><package>Parcel Load Browser</package></attributes></class><comment><class-id>Tools.ParcelLoadBrowser</class-id><body>A ParcelsLoadBrowser allows a user ease to view, select, search, and parse parcels to load by name and directory.Instance Variables:	parcelsTree		&lt;IndentedSelectionInList&gt;	tree of parcel search directories and files	parcelsToLoad		&lt;SelectionInList&gt;	list of parcels to load selected by the user.	comment	&lt;ValueHolder on: String&gt; selected parcel description	parcelNameCache &lt;Dictionary&gt; cached parcel name and version information by child.	viewMode	&lt;ValueHolder on: String&gt;  format to list parcels; by filename or name and version.	unlist	&lt;ValueHolder on: Boolean&gt;  remove from parcelsToLoad any listing of parcel prerequisites when true.	pageKeys &lt;SelectionInList&gt; list of notebook page keys.	obeyVersion &lt;ValueHolder on: Boolean&gt; don't list any parcel prerequisites of dissimilar version when true.</body></comment><class><name>ParcelByClassFinder</name><environment>Tools</environment><super>Tools.ParcelLoadBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classMatch parcelsList superclassMatch namespaceMatch constraints definition searchProcess changeList fileSearched </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Parcels Load Dialog</category><attributes><package>Parcel Load Browser</package></attributes></class><comment><class-id>Tools.ParcelByClassFinder</class-id><body>ParcelByClassFinder searches for parcels with class definitions matching the name, superclass, or namespace specified.  The search is performed within a selected branch of a parcelsTree, a FileAssociationTree of all parcel files in the search path.  The matching classes and their associated parcels are listed.  The wildcard '*' may be used in either classMatch, superclassMatch, or namespaceMatch entries.Instance Variables:	classMatch	&lt;ValueHolder on: String&gt;  entry for class to match.	superclassMatch	&lt;ValueHolder on: String&gt;  entry for superclass of class to match.	namespaceMatch	&lt;ValueHolder on: String&gt;  entry for namespace of class to match.	parcelsList	&lt;MultiSelectionInList&gt;  list of parcels found matching the class, superclass, or namespace entered.	classDefinition	&lt;ValueHolder on: String&gt;  definition display of selected class.	fileSearched	&lt;ValueHolder on: String&gt;  message displaying parcel file currently under search.	constraints	&lt;OrderedCollection of:BlockClosure&gt;  collection of filters to be applied to the class search.	searchProcess	&lt;Process | nil&gt;  parcel search process.	classList	&lt;SelectionInList&gt;  list of classes found.</body></comment><class><name>ParcelByMethodFinder</name><environment>Tools</environment><super>Tools.ParcelByClassFinder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodMatch categoryMatch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Parcels Load Dialog</category><attributes><package>Parcel Load Browser</package></attributes></class><comment><class-id>Tools.ParcelByMethodFinder</class-id><body>ParcelByMethodFinder searches for parcels with method definitions matching the selector, selector protocol, class name, superclass, or namespace specified.  The search is performed within a selected branch of a parcelsTree, a FileAssociationTree of all parcel files in the search path.  The matching method definitions and their associated parcels are listed.  The wildcard '*' may be used in any match.Instance Variables:	methodMatch	&lt;ValueHolder on: String&gt;  entry for selector to match.	categoryMatch	&lt;ValueHolder on: String&gt;  entry for protocol to match.</body></comment><class><name>ParcelByPathFinder</name><environment>Tools</environment><super>Tools.ParcelLoadBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter parcelsToSelect pathnameEntry sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Parcels Load Dialog</category><attributes><package>Parcel Load Browser</package></attributes></class><comment><class-id>Tools.ParcelByPathFinder</class-id><body>ParcelByPathFinder offers a user interface to select parcels to load by file location and name.  The parcel search tree, parcelsTree, is a hiearchical list of directories and parcel files.  The user may add, remove, and trim branches from the search tree.  When a branch of the tree is selected all parcels in that branch that match in name to a filter pattern are listed in the parcelsToSelect list.  If no branch is selected all parcels in the search tree are listed.  The user may select to display parcel by filenames or name and version.Instance Variables:	filter	&lt;ValueHolder on: String&gt;	parcels matching the filter pattern will be displayed in the parcelsToSelect list.	pathnameEntry		&lt;ValueHolder on: Filename&gt;	user entered Filename to add to search directory tree.	parcelsToSelect	&lt;MultiSelectionInList&gt;  list of parcels located in the selected path in the parcelsTree to select for loading. 	sortBlock	&lt;BlockClosure&gt;  block in use to sort parcels appearing in the parcelsToSelect list and the parcelsTree.</body></comment><class><name>FastSourceScannerNodeBuilder</name><environment>XML</environment><super>XML.SourceScannerNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>forgetFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>Parcel Load Browser</package></attributes></class><class><name>FastChangeScanner</name><environment>Kernel</environment><super>Kernel.ChangeScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>Parcel Load Browser</package></attributes></class><class><name>ParcelByNameFinder</name><environment>Tools</environment><super>Tools.ParcelLoadBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parsedListType entries nameList available missing loaded </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Parcels Load Dialog</category><attributes><package>Parcel Load Browser</package></attributes></class><comment><class-id>Tools.ParcelByNameFinder</class-id><body>ParcelByNameFinder parses a text list of parcel names and versions for parcels available to load, for those that are loaded, or those otherwise missing from the parcel search path.  The text list of parcels may be pasted from Parcels: section of info dialog accessed by Help-&gt;About VisualWorks selection from the VisualLauncher.  The line format for parsing by tag is: &lt;parcel name&gt; Version &lt;version&gt; of &lt;timestamp&gt;.Instance Variables:		parsedListType	&lt;ValueHolder on: String&gt;	current parsed parcel list mode.	entries	&lt;ValueHolder on: String&gt;	source for parsed parcels.	nameList	&lt;SelectionInList&gt; list of parsed parcel selections.	available	&lt;List&gt;	list of parcels parsed and available to load. 	missing	&lt;List&gt; list of parcels parsed but not found. 	loaded	&lt;List&gt;	 list of parcels parsed and already loaded.</body></comment><class><name>ParcelFavorites</name><environment>Tools</environment><super>Tools.ParcelLoadBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parcelFavorites sortMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Parcels Load Dialog</category><attributes><package>Parcel Load Browser</package></attributes></class><comment><class-id>Tools.ParcelFavorites</class-id><body>ParcelFavorites is used to tally parcels loaded in an image and to display this list of parcels for selection ranked by their most frequent or last use.  The tallies, last load time, and filenames are recorded in Favorites.  Favorites is recorded to a file named by class accessor #storageFile on closure of the ParcelFavorites window.  Instance Variables:	parcelFavorites	&lt;MultiSelectionInList&gt;  list of parcel favorites.	sortMode	&lt;ValueHolder on:Symbol&gt;  method to sort parcels appearing top down in parcelFavorites; by most used or last used.Shared Variables:	Favorites	&lt;Dictionary key: (Array with: nameString with: versionString) value: (Bag | Dictionary)&gt;  mostUsed parcels, lastUsed parcel times, and parcel filenames keyed by a two element array of the parcel name and version.</body></comment><shared-variable><name>UserPathnames</name><environment>Tools.ParcelLoadBrowser</environment><private>false</private><constant>false</constant><category>user pathnames</category><initializer>List new</initializer><attributes><package>Parcel Load Browser</package></attributes></shared-variable><shared-variable><name>Favorites</name><environment>Tools.ParcelFavorites</environment><private>false</private><constant>false</constant><category>parcel favorites</category><attributes><package>Parcel Load Browser</package></attributes></shared-variable><methods><class-id>UI.FileAssociationTree</class-id> <category>adding</category><body package="Parcel Load Browser" selector="addAllFilesMatching:">addAllFilesMatching: pattern	"Perform a depth-first search for files matching pattern in name.  Add all files that match to the tree"	self addChildFilesMatching: pattern toDepth: SmallInteger maxVal</body><body package="Parcel Load Browser" selector="addChildFilesMatching:">addChildFilesMatching: string	"Add as children file nodes that match filename pattern string" 	value isNil ifTrue:[^nil]. 	(value filenamesMatching: string)		do: [:file | self children 						detect: [:child | child value = file]						ifNone: [self addChild: (FileAssociationTree file: file)]]</body><body package="Parcel Load Browser" selector="addChildFilesMatching:toDepth:">addChildFilesMatching: pattern toDepth: depthLimit	"Add missing child files matching pattern by name and directories to the hierarchy up to depthLimit levels from my leaf nodes"	(depthLimit = 0 or:[value isNil]) ifTrue:[^self].		self offspring do:[:child| 			child isDirectory				ifTrue:[child addChildFilesMatching: pattern toDepth: (child isLeaf ifTrue:[depthLimit - 1] ifFalse:[depthLimit]).						 (self children includes: child)  ifFalse:[self addChild: child]]				ifFalse:[((self children includes: child) not and:[pattern match: child key ignoreCase: Filename isCaseSensitive not])							ifTrue:[self addChild: child]]]</body><body package="Parcel Load Browser" selector="addDirectory:andFilesMatching:">addDirectory: aFilename andFilesMatching: aString	"Add the directory aFilename to the tree adding its subdirectory child nodes.  Add child nodes for files matching the specification aString to the directory.  Answer the node"		^self addFileComponents: (PortableFilename components: aFilename asString) asOrderedCollection andFilesMatching: aString</body><body package="Parcel Load Browser" selector="addDirectory:withFilesMatching:">addDirectory: aFilename withFilesMatching: aString	"Add the directory aFilename to the tree adding subdirectory nodes if they contain files that match the specification aString in the directory.  Include the child nodes that match in the hierarchy.  Answer the node"		^self addFileComponents: (PortableFilename components: aFilename asString) asOrderedCollection withFilesMatching: aString</body></methods><methods><class-id>UI.FileAssociationTree</class-id> <category>private</category><body package="Parcel Load Browser" selector="addFileComponents:andFilesMatching:">addFileComponents: components andFilesMatching: pattern	"Add nodes for all files matching pattern to the hierarchy for the path composed of components.  Add directory nodes as needed to complete the hierarchy" 	| head headString child |	components isEmpty ifTrue: [^self addChildFilesMatching: pattern].	head := components removeFirst.	headString := (head isKindOf: SystemVariable)				ifTrue: ['$(' , head name , ')']				ifFalse: [head].	child := self childNamed: headString.	child isNil		ifTrue: 			[| childFile |			childFile := value isNil						ifTrue: [PortableFilename named: headString]						ifFalse: [value construct: headString].			child := self class key: headString value: childFile.			childFile exists				ifTrue: 					[self addChild: child.					childFile isDirectory						ifTrue: [child beFolder]						ifFalse: 							[child beFile.							^self addChildFilesMatching: pattern]]				ifFalse: [^self addChildFilesMatching: pattern]].	^child addFileComponents: components andFilesMatching: pattern</body><body package="Parcel Load Browser" selector="addFileComponents:withFilesMatching:">addFileComponents: components withFilesMatching: pattern	"If there are any nodes for files matching pattern in the path composed of components then add them to the hierarchy.  Add directory nodes only if needed to include any file nodes"  	| head headString child |	components isEmpty		ifTrue: 			[self addChildFilesMatching: pattern.			^self children isEmpty				ifTrue: [nil]				ifFalse: [self]].	head := components removeFirst.	headString := (head isKindOf: SystemVariable)				ifTrue: ['$(' , head name , ')']				ifFalse: [head].	child := self childNamed: headString.	child isNil		ifTrue: 			[| childFile |			childFile := value isNil						ifTrue: [PortableFilename named: headString]						ifFalse: [value construct: headString].			child := FileAssociationTree key: headString value: childFile.			childFile exists				ifTrue: 					[childFile isDirectory						ifTrue:[^self addFolderNotNil: (child addFileComponents: components withFilesMatching: pattern)]						ifFalse:[child beFile.								  ^self addChildFilesMatching: pattern]]				ifFalse: 					[^self addChildFilesMatching: pattern]].	^child addFileComponents: components withFilesMatching: pattern</body><body package="Parcel Load Browser" selector="addFolderNotNil:">addFolderNotNil: aChildOrNil	^aChildOrNil isNil		ifTrue:[nil]		ifFalse:[self addChild: aChildOrNil beFolder]</body><body package="Parcel Load Browser" selector="beFile">beFile	isDirectory := false.	self icon: ExtendedLabelAndIcon file.</body><body package="Parcel Load Browser" selector="beFolder">beFolder	isDirectory := true.	self icon: ExtendedLabelAndIcon folder.</body></methods><methods><class-id>UI.FileAssociationTree</class-id> <category>searching</category><body package="Parcel Load Browser" selector="findValue:">findValue: aValue"Recursively (depth-first) search the receiver's children to find the child with value aValue. Answer the child if it exists, otherwise return nil."	| result |	aValue = value		ifTrue: [^self]		ifFalse: [self isLeaf				ifTrue: [^nil]				ifFalse: 					[children						do: 							[:child | 							result := child findValue: aValue.							result == nil ifFalse: [^result]].					^nil]]</body><body package="Parcel Load Browser" selector="immediateChildDirectories">immediateChildDirectories	"Answer the child directories in the tree that contain file nodes"	^self isLeaf		ifTrue: [#()]		ifFalse: 			[| initial |			initial := [(self children contains: [:child | child isDirectory not])						ifTrue: [OrderedCollection with: self]						ifFalse: [OrderedCollection new]]						on: OsError						do:[:ex| OrderedCollection new].			self children inject: initial into: [:sofar :child | sofar , child immediateChildDirectories]]</body></methods><methods><class-id>UI.FileAssociationTree</class-id> <category>testing</category><body package="Parcel Load Browser" selector="hasChildFiles">hasChildFiles	"Answer true if any children are files"	self childrenDo:[:child| (child isLeaf and:[child isDirectory not]) ifTrue:[^true]].	^false</body><body package="Parcel Load Browser" selector="hasEmptyChildDirectories">hasEmptyChildDirectories	"Answer true if any children are empty directories"	self childrenDo:[:child| (child isLeaf and:[child isDirectory]) ifTrue:[^true]].	^false</body><body package="Parcel Load Browser" selector="isDirectory">isDirectory	^isDirectory</body></methods><methods><class-id>UI.FileAssociationTree</class-id> <category>accessing</category><body package="Parcel Load Browser" selector="childNamed:ifAbsentPut:">childNamed: aChildName ifAbsentPut: aBlock 	^self children detect: [:assoc | assoc key = aChildName]		ifNone: 			[| child |			self addChild: (child := aBlock value).			child]</body><body package="Parcel Load Browser" selector="leafFileChildren">leafFileChildren	"Answer a collection of all children that represent files"	^[(self isLeaf and:[self isDirectory not])		ifTrue:[OrderedCollection with: self]		ifFalse:[self children inject: OrderedCollection new into:[:sofar :child| sofar, child leafFileChildren]]]	on: OsError	do:[:ex | OrderedCollection new]</body><body package="Parcel Load Browser" selector="offspring">offspring	"Answer my children and any children eligible for adoption"	^[value directoryContents 		collect: [:file | self children 			detect: [:child | child value tail match: file ignoreCase: Filename isCaseSensitive not]			ifNone: [self class path: (value construct: file)]]]	on: OsError 	do: [:ex | #()]</body></methods><methods><class-id>UI.FileAssociationTree</class-id> <category>removing</category><body package="Parcel Load Browser" selector="removeAllEmptyChildDirectories">removeAllEmptyChildDirectories	"Remove all children that are empty directories"	self children copy do:[:child| (child isLeaf and:[child isDirectory])		 ifTrue:[self removeChild: child]		ifFalse:[child removeAllEmptyChildDirectories]].</body><body package="Parcel Load Browser" selector="removeLeafFilesMatching:toHeight:">removeLeafFilesMatching: pattern toHeight: heightLimit	"Remove file nodes that match pattern in name starting from the leaf nodes up to heightLimit levels in the tree"	heightLimit = 0 ifTrue:[^self].	self isLeaf 		ifTrue:[ | bereaved |				 parent isNil ifTrue:[^self].				 bereaved := parent copy.				(pattern match: key) ifTrue:[parent removeChild: self].				 bereaved removeLeafFilesMatching: pattern toHeight: heightLimit -1]		ifFalse:[self children copy do:[:child| child removeLeafFilesMatching: pattern toHeight: heightLimit]].</body></methods><methods><class-id>UI.FileAssociationTree</class-id> <category>sorting</category><body package="Parcel Load Browser" selector="sortAllAscendingByName">sortAllAscendingByName	self children isEmpty ifTrue:[^self].	self sortAscendingByName.	self children do:[:child| child sortAllAscendingByName].</body><body package="Parcel Load Browser" selector="sortAllChildrenBy:">sortAllChildrenBy: aBlock	self children isEmpty ifTrue:[^self].	self sortChildrenBy: aBlock.	self children do:[:child| child sortAllChildrenBy: aBlock].</body><body package="Parcel Load Browser" selector="sortAllDescendingByName">sortAllDescendingByName	self children isEmpty ifTrue:[^self].	self sortDescendingByName.	self children do:[:child| child sortAllDescendingByName].</body><body package="Parcel Load Browser" selector="sortAscendingByName">sortAscendingByName	self sortChildrenBy:[:a :b| a key &lt; b key]</body><body package="Parcel Load Browser" selector="sortChildrenBy:">sortChildrenBy: aBlock	self children isEmpty ifTrue:[^self].	self children: (self children asSortedCollection: aBlock) asOrderedCollection.</body><body package="Parcel Load Browser" selector="sortDescendingByName">sortDescendingByName	self sortChildrenBy:[:a :b| a key &gt; b key]</body></methods><methods><class-id>UI.FileAssociationTree</class-id> <category>adding-directories</category><body package="Parcel Load Browser" selector="addDirectories:matching:">addDirectories: aCollection matching: matchString 	aCollection do: [:directory | self addDirectory: directory matching: matchString]</body><body package="Parcel Load Browser" selector="addDirectory:matching:">addDirectory: aFilename matching: matchString 	[(aFilename filenamesMatching: matchString)				do: [:file | self addFile: file]]		on: OsError		do: 			[:ex | 			Dialog warn: 'Invalid filename ' , aFilename asString.			ex return]</body><body package="Parcel Load Browser" selector="addFile:">addFile: aFilename	self addFile: aFilename components: (PortableFilename components: aFilename asString)</body><body package="Parcel Load Browser" selector="addFile:components:">addFile: aFilename components: componentCollection 	componentCollection isEmpty ifTrue: [^self].	componentCollection size = 1		ifTrue: [self childNamed: componentCollection last ifAbsentPut: [FileAssociationTree file: aFilename]]		ifFalse: 			[| name child comp|			comp := componentCollection first.			name := comp isString ifTrue: [comp] ifFalse: ['$(', comp name, ')'].			child := self childNamed: name ifAbsentPut: [self value isNil								ifTrue: [(FileAssociationTree folder:(PortableFilename named: name)) key: name]								ifFalse: [FileAssociationTree folder: (self value construct: name)]].			child addFile: aFilename components: (componentCollection copyFrom: 2 to: componentCollection size)]</body></methods><methods><class-id>UI.FileAssociationTree</class-id> <category>adding-paths</category><body package="Parcel Load Browser" selector="addPath:">addPath: aFilename	self addPath: aFilename components: (PortableFilename components: aFilename asString)</body><body package="Parcel Load Browser" selector="addPath:components:">addPath: aFilename components: componentCollection 	componentCollection isEmpty ifTrue: [^self].	componentCollection size = 1		ifTrue: [self childNamed: componentCollection last ifAbsentPut: [FileAssociationTree path: aFilename]]		ifFalse: 			[| name child comp|			comp := componentCollection first.			name := comp isString ifTrue: [comp] ifFalse: ['$(', comp name, ')'].			child := self childNamed: name ifAbsentPut: [self value isNil								ifTrue: [(FileAssociationTree path:(PortableFilename named: name)) key: name]								ifFalse: [FileAssociationTree path: (self value construct: name)]].			child addPath: aFilename components: (componentCollection copyFrom: 2 to: componentCollection size)]</body><body package="Parcel Load Browser" selector="addPath:matching:">addPath: aFilename matching: matchString 	[((aFilename asString includes: $*)		or: [aFilename isDirectory])		ifTrue: [(aFilename filenamesMatching: '*')				do: [:file | self addPath: file matching: matchString]]		ifFalse: [(matchString match: aFilename asString)				ifTrue: [self addPath: aFilename]]]		on: OsError		do: 			[:ex | 			Dialog warn: 'Invalid filename ' , aFilename asString.			ex return]</body><body package="Parcel Load Browser" selector="addPath:matching:toDepth:">addPath: aFilename matching: matchString toDepth: depthLimit 	depthLimit = -1 ifTrue: [^self].	[((aFilename asString includes: $*)		or: [aFilename isDirectory])		ifTrue: [self				addPaths: (aFilename filenamesMatching: '*')				matching: matchString				toDepth: depthLimit - 1]		ifFalse: [(matchString match: aFilename asString)				ifTrue: [self addPath: aFilename]]]		on: OsError		do: 			[:ex | 			Dialog warn: 'Invalid filename ' , aFilename asString.			ex return]</body><body package="Parcel Load Browser" selector="addPaths:matching:toDepth:">addPaths: aCollection matching: matchString toDepth: depthLimit	aCollection do:[:file| self addPath: file matching: matchString toDepth: depthLimit]</body></methods><methods><class-id>UI.FileAssociationTree class</class-id> <category>instance creation</category><body package="Parcel Load Browser" selector="file:">file: aFilename	^(self key: aFilename tail value: aFilename) beFile</body><body package="Parcel Load Browser" selector="folder:">folder: aFilename	^(self key: aFilename tail value: aFilename) beFolder</body><body package="Parcel Load Browser" selector="path:">path: aFilename	^aFilename isDirectory		ifTrue:[self folder: aFilename ]			ifFalse:[self file: aFilename].</body></methods><methods><class-id>UI.FileAssociationTree class</class-id> <category>examples</category><body package="Parcel Load Browser" selector="example1">example1		| root parcelDirectories |	root := FileAssociationTree key: 'Root' value: nil.	parcelDirectories := (UI.UISettings.UserPreferences at: #parcelPath) value.	root addPaths: parcelDirectories matching:'*.pcl' toDepth: 1.	^root</body><body package="Parcel Load Browser" selector="example2">example2		| root parcelDirectories |	root := FileAssociationTree key: 'Root' value: nil.	parcelDirectories := (UI.UISettings.UserPreferences at: #parcelPath) value.	root addDirectories: parcelDirectories matching:'*.pcl'.	^root</body><body package="Parcel Load Browser" selector="example3">example3		| root |	root := FileAssociationTree key: 'Root' value: nil.	root addDirectory: '.' asFilename matching:'*.pcl'.	^root</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>cacheing</category><body package="Parcel Load Browser" selector="cachedDisplayName:">cachedDisplayName: aFileAssociation 	| pair |	pair := self cachedNameVer: aFileAssociation.	^pair first , ' ' , pair last</body><body package="Parcel Load Browser" selector="cachedName:">cachedName: aFileAssociation	^(self cachedNameVer: aFileAssociation) first</body><body package="Parcel Load Browser" selector="cachedNameVer:">cachedNameVer: aFileAssociation	^parcelNameCache at: aFileAssociation value ifAbsentPut:[self class nameVerFor: aFileAssociation value]</body><body package="Parcel Load Browser" selector="cacheParcelNames">cacheParcelNames	Cursor wait showWhile: [self parcelsTree tree immediateChildDirectories do: [:parent | Parcel withFileCachesDo: [Parcel					cachedParcelFileInfoIn: parent value					for: nil					do: 						[:info :file | 						| childToName |						childToName := parent childNamed: file tail.						childToName isNil ifFalse: [parcelNameCache at: childToName put: (Array with: (info at: #parcel)									with: (info at: #version ifAbsent: ['']))]]]]]</body><body package="Parcel Load Browser" selector="emphasizedName:">emphasizedName: aFileAssociation 	"Answer the key for the file association as italisized text if the parcel is loaded"	^(Parcel parcelNamed: (self cachedName: aFileAssociation)) isNil		ifTrue: [aFileAssociation key]		ifFalse: [Text string: aFileAssociation key emphasis: #italic]</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>aspects</category><body package="Parcel Load Browser" selector="comment">comment		^comment isNil		ifTrue:			[comment := String new asValue]		ifFalse:			[comment]</body><body package="Parcel Load Browser" selector="comment:">comment: aValueHolder 	comment := aValueHolder</body><body package="Parcel Load Browser" selector="fileSelections">fileSelections	^self parcelsToLoad list collect:[:each| each value]</body><body package="Parcel Load Browser" selector="obeyVersion">obeyVersion	^obeyVersion isNil		ifTrue:			[obeyVersion := false asValue]		ifFalse:			[obeyVersion]</body><body package="Parcel Load Browser" selector="pageKeys">pageKeys	^pageKeys isNil 		ifTrue: 			[pageKeys := SelectionInList with: self class tabsMenu labels.			pageKeys selectionIndex: 1]		ifFalse: [pageKeys]</body><body package="Parcel Load Browser" selector="parcelsToLoad">parcelsToLoad	^parcelsToLoad isNil		ifTrue:			[parcelsToLoad := SelectionInList new]		ifFalse:			[parcelsToLoad]</body><body package="Parcel Load Browser" selector="parcelsToLoad:">parcelsToLoad: aSelectionInList	parcelsToLoad:= aSelectionInList</body><body package="Parcel Load Browser" selector="parcelsToLoadList:">parcelsToLoadList: selections	self parcelsToLoad list: (self unlist value			ifTrue: [self unlistPrerequisites: selections]			ifFalse: [selections]) asList.	self showComment: (selections size = 1			ifTrue: [selections asOrderedCollection first]			ifFalse: [nil])</body><body package="Parcel Load Browser" selector="parcelsTree">parcelsTree	parcelsTree isNil		ifTrue: 			[| root |			root := FileAssociationTree key: 'Root' value: nil.   			root addDirectories: self searchDirectories matching: '*.pcl'.			parcelsTree := IndentedTreeSelectionInList						listObjectHierarchy: root						isLeafSelector: #isLeaf						childAccessor: #children						childNameAccessor: #key.			parcelsTree treeAccessor iconSelector: #icon].	^parcelsTree</body><body package="Parcel Load Browser" selector="parcelsTree:">parcelsTree: aFileAssociationTree	parcelsTree := aFileAssociationTree.</body><body package="Parcel Load Browser" selector="unlist">unlist	^unlist isNil		ifTrue: [unlist := true asValue]		ifFalse: [unlist]</body><body package="Parcel Load Browser" selector="unlist:">unlist: aValueHolder	unlist := aValueHolder</body><body package="Parcel Load Browser" selector="viewChoices">viewChoices	^#('View by file' 'View by name') asValue</body><body package="Parcel Load Browser" selector="viewMode">viewMode	^viewMode isNil		ifTrue:			[viewMode := 'View by file' asValue]		ifFalse:			[viewMode]</body><body package="Parcel Load Browser" selector="viewMode:">viewMode: aValueHolder 	viewMode := aValueHolder</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>interface opening</category><body package="Parcel Load Browser" selector="postOpenWith:">postOpenWith: aBuilder	self changedPage</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>actions-dialog</category><body package="Parcel Load Browser" selector="load">load	"Load a parcel in the parcelsToLoad list and add a reference to the file in the ParcelFavorites tally"	self parcelsToLoad list isEmpty		ifFalse: 			[| files |			files := self fileSelections.			files do: [:file | ParcelFavorites loadParcelFrom: file]].	self closeRequest</body><body package="Parcel Load Browser" selector="showComment:">showComment: anAssoc 	self comment value: ((anAssoc isNil or:[anAssoc value isString])			ifTrue: ['']			ifFalse: [self class commentFor: anAssoc value])</body><body package="Parcel Load Browser" selector="unlistChange">unlistChange	self unlist value		ifTrue:[self parcelsToLoad list: (self unlistPrerequisites: self parcelsToLoad list) asList]</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>parcel path accessing</category><body package="Parcel Load Browser" selector="searchDirectories">searchDirectories	"Collection of directories that form the search path for parcels"	^searchDirectories isNil		ifTrue:[searchDirectories := (UISettings preferenceModelFor: #parcelPath) value]		ifFalse:[searchDirectories]</body><body package="Parcel Load Browser" selector="searchDirectories:">searchDirectories: aCollection 	searchDirectories := aCollection</body><body package="Parcel Load Browser" selector="selectedPath">selectedPath	"Selected FileAssociationTree node or root node if no selection"	| selection |	^(selection := self parcelsTree selection) isNil		ifTrue: [self parcelsTree tree]		ifFalse: [selection]</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>private</category><body package="Parcel Load Browser" selector="setViewModeName:">setViewModeName: aFileAssociation 	self viewMode value = self viewChoices value first ifTrue: [aFileAssociation key: aFileAssociation value tail].	self viewMode value = self viewChoices value last ifTrue: [aFileAssociation key: (self cachedDisplayName: aFileAssociation)].</body><body package="Parcel Load Browser" selector="unlistPrerequisites:">unlistPrerequisites: aCollection 	"Answer aCollection of parcel name-&gt;file associations without any prerequisite parcels listed"	| withoutPrereqs removals |	withoutPrereqs := Dictionary new.	^self obeyVersion value		ifTrue: 			[| verDictionary result |			aCollection				do: 					[:assoc | 					| pair |					pair := self cachedNameVer: assoc.					verDictionary := withoutPrereqs at: pair first ifAbsentPut: [Dictionary new].					verDictionary at: pair last put: assoc.					verDictionary at: '' put: assoc].			removals := aCollection inject: Set new into: [:sofar :assoc | sofar addAll: (self class prerequisitesFor: assoc value); yourself].			removals				do: 					[:pair | 					verDictionary := withoutPrereqs at: pair first ifAbsent: [].					verDictionary isNil ifFalse: [						pair last isEmpty							ifTrue: [withoutPrereqs removeKey: pair first]							ifFalse: [verDictionary removeKey: pair last ifAbsent: []]]].			result := Set new.			withoutPrereqs values do: [:d | result addAll: d values].			result]		ifFalse: 			[aCollection do: [:assoc | withoutPrereqs at: (self cachedName: assoc) put: assoc].			removals := aCollection inject: Set new into: [:sofar :assoc | sofar addAll: ((self class prerequisitesFor: assoc value)								collect: [:pair | pair first]); yourself].			removals do: [:name | withoutPrereqs removeKey: name ifAbsent: []].			withoutPrereqs values]</body><body package="Parcel Load Browser" selector="updateSelections:">updateSelections: aController 	| selections |	(aController sensor shiftDown or: [aController sensor ctrlDown])		ifTrue: 			[selections := Set withAll: (self parcelsToLoad list reject: [:each | (self parcelSelections includes: each) not and: [self parcelsToSelect list includes: each]]).			selections addAll: self parcelSelections]		ifFalse: [selections := self parcelSelections].	self parcelsToLoadList: selections</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>notebook</category><body package="Parcel Load Browser" selector="changedPage">changedPage	(self builder componentAt: #searchNotebook) widget		client: (self perform: (self class tabsMenu valueAt: self pageKeys selectionIndex))		spec: #windowSpec		builder: self builder</body><body package="Parcel Load Browser" selector="classPage">classPage	^self builder namedComponents at: #classPage		ifAbsentPut: [ParcelByClassFinder on: self]</body><body package="Parcel Load Browser" selector="favoritesPage">favoritesPage	^self builder namedComponents at: #favoritesPage		ifAbsentPut: [ParcelFavorites on: self]</body><body package="Parcel Load Browser" selector="methodPage">methodPage	^self builder namedComponents at: #methodPage		ifAbsentPut: [ParcelByMethodFinder on: self]</body><body package="Parcel Load Browser" selector="namePage">namePage	^self builder namedComponents at: #namePage		ifAbsentPut: [ParcelByNameFinder on: self]</body><body package="Parcel Load Browser" selector="pathPage">pathPage	^self builder namedComponents at: #pathPage		ifAbsentPut: [ParcelByPathFinder on: self]</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>notification</category><body package="Parcel Load Browser" selector="showSelectionComment:">showSelectionComment: aSequenceController	self showComment: aSequenceController view selection.</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>initialize-release</category><body package="Parcel Load Browser" selector="initialize">initialize	super initialize.	parcelNameCache := Dictionary new</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>actions</category><body package="Parcel Load Browser" selector="removeLoadSelection">removeLoadSelection	"Remove the parcel selected from the parcelsToLoad list"	| selection |	selection := self parcelsToLoad selection. 	selection isNil ifFalse:[self parcelsToLoad list remove: selection].	(self builder componentAt: #Path) ifNotNil:[:page| page updateFileSelections].</body></methods><methods><class-id>Tools.ParcelLoadBrowser</class-id> <category>events</category><body package="Parcel Load Browser" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow 	self class tabsMenu values do: 			[:key | 			| app |			app := self builder namedComponents removeKey: key ifAbsent: [].			app isNil ifFalse: [app noticeOfWindowClose: aWindow]]</body></methods><methods><class-id>Tools.ParcelLoadBrowser class</class-id> <category>aspects</category><body package="Parcel Load Browser" selector="userPathnames">userPathnames	^UserPathnames</body></methods><methods><class-id>Tools.ParcelLoadBrowser class</class-id> <category>instance creation</category><body package="Parcel Load Browser" selector="on:">on: aParcelLoadBrowser	"Create a new instance with shared variables"	^self new		parcelsToLoad: aParcelLoadBrowser parcelsToLoad;		comment: aParcelLoadBrowser comment;		parcelsTree: aParcelLoadBrowser parcelsTree;		unlist: aParcelLoadBrowser unlist;		viewMode: aParcelLoadBrowser viewMode.</body></methods><methods><class-id>Tools.ParcelLoadBrowser class</class-id> <category>initialization</category><body package="Parcel Load Browser" selector="initialize">initialize	UserPathnames := List new</body></methods><methods><class-id>Tools.ParcelLoadBrowser class</class-id> <category>private-parcel info</category><body package="Parcel Load Browser" selector="commentFor:">commentFor: aFilename 	| tail |	tail := aFilename tail.	Parcel withFileCachesDo: [Parcel		cachedParcelFileInfoIn: aFilename directory		for: (tail copyFrom: 1 to: tail size - Parcel fileExtension size)		do: [:info :file | ^(info at: #comment ifAbsent: [#('This parcel has not been commented')]) first]].	^String new</body><body package="Parcel Load Browser" selector="nameVerFor:">nameVerFor: aFilename 	| tail |	tail := aFilename tail.	Parcel withFileCachesDo: [Parcel			cachedParcelFileInfoIn: aFilename directory			for: (tail copyFrom: 1 to: tail size - aFilename extension size)			do: [:info :fileName | ^Array with: (info at: #parcel ifAbsent: ['unknown'])					with: (info at: #version ifAbsent: [''])]].	^#('unknown' '')</body><body package="Parcel Load Browser" selector="prerequisitesFor:">prerequisitesFor: aFilename 	Parcel withFileCachesDo: [Parcel			cachedParcelFileInfoIn: aFilename directory			for: (aFilename tail copyUpTo: $.)			do: [:info :file | ^info at: #prerequisiteParcels]].	^Array new</body></methods><methods><class-id>Tools.ParcelByClassFinder</class-id> <category>aspects</category><body package="Parcel Load Browser" selector="changeList">changeList		^changeList isNil		ifTrue:			[changeList := SelectionInList new]		ifFalse:			[changeList]</body><body package="Parcel Load Browser" selector="classMatch">classMatch	^classMatch isNil		ifTrue:			[classMatch := String new asValue]		ifFalse:			[classMatch]</body><body package="Parcel Load Browser" selector="constraints">constraints	^constraints isNil		ifTrue:[constraints := self buildConstraints]		ifFalse:[constraints]</body><body package="Parcel Load Browser" selector="definition">definition	^definition isNil		ifTrue:			[definition := String new asValue]		ifFalse:			[definition]</body><body package="Parcel Load Browser" selector="fileSearched">fileSearched	^fileSearched isNil		ifTrue:			[fileSearched := String new asValue]		ifFalse:			[fileSearched]</body><body package="Parcel Load Browser" selector="namespaceMatch">namespaceMatch	^namespaceMatch isNil		ifTrue:			[namespaceMatch := String new asValue]		ifFalse:			[namespaceMatch]</body><body package="Parcel Load Browser" selector="parcelSelections">parcelSelections	^self parcelsList selections</body><body package="Parcel Load Browser" selector="parcelsList">parcelsList	^parcelsList isNil		ifTrue:			[parcelsList := MultiSelectionInList new]		ifFalse:			[parcelsList]</body><body package="Parcel Load Browser" selector="parcelsToSelect">parcelsToSelect	^self parcelsList</body><body package="Parcel Load Browser" selector="superclassMatch">superclassMatch	^superclassMatch isNil		ifTrue:			[superclassMatch := String new asValue]		ifFalse:			[superclassMatch]</body></methods><methods><class-id>Tools.ParcelByClassFinder</class-id> <category>private</category><body package="Parcel Load Browser" selector="changeString:">changeString: aClassDefinitionChange	^aClassDefinitionChange className</body><body package="Parcel Load Browser" selector="promptMode">promptMode	searchProcess := nil.	self fileSearched value: String new.	(self builder componentAt:#searchButtons) enable.	(self builder componentAt:#stopButton) disable.</body><body package="Parcel Load Browser" selector="searchMode">searchMode	(self builder componentAt:#searchButtons) disable.	(self builder componentAt:#stopButton) enable.</body></methods><methods><class-id>Tools.ParcelByClassFinder</class-id> <category>testing</category><body package="Parcel Load Browser" selector="useDefinition:">useDefinition: change	^change isClassDefinitionChange and: [change objectType = #class and: [self matchConstraints: change]]</body></methods><methods><class-id>Tools.ParcelByClassFinder</class-id> <category>actions</category><body package="Parcel Load Browser" selector="reset">reset	self classMatch value: String new.	self superclassMatch value: String new. 	self namespaceMatch value: String new.	self definition value: String new.	self changeList list:  List new.	self parcelsList list: List new.	constraints := nil</body><body package="Parcel Load Browser" selector="search">search	self parcelsList list: List new.	self changeList list:  List new.	self definition value: String new.	self buildConstraints.	searchProcess := 			[self searchMode.   			self searchTree: self selectedPath.			self promptMode]				forkAt: Processor userBackgroundPriority</body><body package="Parcel Load Browser" selector="stopSearch">stopSearch	searchProcess terminate.	self promptMode.</body></methods><methods><class-id>Tools.ParcelByClassFinder</class-id> <category>searching-files</category><body package="Parcel Load Browser" selector="search:">search: aFilename 	((aFilename asResolvedString includes: $*)		or: [aFilename isDirectory])		ifTrue: [(aFilename filenamesMatching: '*.pst')				do: [:each | self search: each]]		ifFalse: 			[| parcelFile tail baseName |			tail := aFilename tail.			baseName := tail copyFrom: 1 to: tail size - Parcel sourceExtension size.			parcelFile := aFilename directory construct: baseName , Parcel fileExtension.			parcelFile exists ifTrue: [self searchSource: aFilename of: parcelFile]]</body><body package="Parcel Load Browser" selector="searchFiles:">searchFiles: aCollection	aCollection do:[:file| self search: file].</body></methods><methods><class-id>Tools.ParcelByClassFinder</class-id> <category>notification</category><body package="Parcel Load Browser" selector="classSelect">classSelect	| selection |	(selection := self changeList selection) isNil		ifTrue: 			[self definition value: String new.			self parcelsList selections: #()]		ifFalse: 			[self definition value: selection key text.			self parcelsList selections: (Array with: selection value tail -&gt; selection value)].	self parcelsToLoadList: self parcelSelections.</body></methods><methods><class-id>Tools.ParcelByClassFinder</class-id> <category>interface opening</category><body package="Parcel Load Browser" selector="postBuildWith:">postBuildWith: aBuilder 	| changeListWidget |	searchProcess isNil ifFalse:[self searchMode].	changeListWidget := (aBuilder componentAt: #changes) widget.	changeListWidget visualBlock: [:v :i | BoundedWrapper on: (Label				with: (self changeString: (v model value at: i) key)				attributes: v textStyle				offset: 2 @ 0)].	changeListWidget		selectedVisualBlock: 			[:v :i | 			| rw |			rw := ReversingWrapper on: (Label							with:  (self changeString: (v model value at: i) key)							attributes: v textStyle							offset: 2 @ 0).			rw reverse setValue: true.			BoundedWrapper on: rw].</body><body package="Parcel Load Browser" selector="postOpenWith:">postOpenWith: aBuilder</body><body package="Parcel Load Browser" selector="preBuildWith:">preBuildWith: aBuilder 	(aBuilder bindings) 		removeKey: #classMatch ifAbsent: [];		removeKey: #search ifAbsent: [];		removeKey: #stopSearch ifAbsent: [];		removeKey: #reset ifAbsent: [];		removeKey: #changeList ifAbsent: [];		removeKey: #parcelsList ifAbsent: [];		removeKey: #fileSearched ifAbsent: [].</body></methods><methods><class-id>Tools.ParcelByClassFinder</class-id> <category>searching-tree</category><body package="Parcel Load Browser" selector="searchSource:of:">searchSource: aSourceFile of: aParcelFile 	"Defer obtaining source for definition until match is confirmed thereby improving search speed"	| fileStream |	self fileSearched value: 'Searching ' , aSourceFile asString , '...'.	fileStream := (aSourceFile withEncoding: #Source) readStream.		[FastChangeScanner new scanFile: fileStream		do: 			[:change :scanner | 			(self useDefinition: change) 				ifTrue: 					[| files nameFilePair |					files := self parcelsList list.					nameFilePair := aParcelFile tail -&gt; aParcelFile.					(files includes: nameFilePair) ifFalse: [files add: nameFilePair].					scanner obtainSource: change.					self changeList list add: change -&gt; aParcelFile]].	Processor yield] 			ensure: [fileStream close]</body><body package="Parcel Load Browser" selector="searchTree:">searchTree: aFileAssociationTree 	aFileAssociationTree leafFileChildren		do: 			[:node | 			| tail sourceFile file baseName |			file := node value.			tail := file tail.			baseName := tail copyFrom: 1 to: tail size - Parcel fileExtension size.   			sourceFile := file directory construct: baseName, Parcel sourceExtension.			sourceFile exists ifTrue: [self searchSource: sourceFile of: file]]</body></methods><methods><class-id>Tools.ParcelByClassFinder</class-id> <category>initialize release</category><body package="Parcel Load Browser" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	searchProcess isNil ifFalse:[searchProcess terminate]</body></methods><methods><class-id>Tools.ParcelByClassFinder</class-id> <category>constraint matching</category><body package="Parcel Load Browser" selector="buildConstraints">buildConstraints	| classString superclassString namespaceString |	constraints := OrderedCollection new.	(classString := self classMatch value trimBlanks) isEmpty ifFalse: [constraints			add: 				[:change | | className |				className := change className asString.				((classString match: className) or:[				(className indexOfSubCollection:'class' startingAt:1) &gt; 0					ifTrue:['*.' , classString,' class' match: className]					ifFalse:['*.' , classString match: className]])]].	(superclassString := self superclassMatch value trimBlanks) isEmpty ifFalse: [constraints			add: 				[:change | 				| parameters |				parameters := Dictionary withAll: change parameters last.				(parameters includesKey:#superclass:)					ifTrue:[ | superclass |				superclass := (parameters at: #superclass:) isNil ifTrue:['nil'] ifFalse:[(parameters at: #superclass:) asString]. 				'*' , superclassString match: superclass]					ifFalse:[false]]].	(namespaceString := self namespaceMatch value trimBlanks) isEmpty ifFalse: [constraints 			add: [:change | '*' , namespaceString match: (change parameters at: 2) asString]].	^constraints</body><body package="Parcel Load Browser" selector="matchConstraints:">matchConstraints: aChange	"True if all constraints pass. Or, answer false on the first constraint that fails"	^self constraints allSatisfy:[:test| test value: aChange]</body></methods><methods><class-id>Tools.ParcelByMethodFinder</class-id> <category>constraint matching</category><body package="Parcel Load Browser" selector="buildConstraints">buildConstraints	| methodString categoryString |	super buildConstraints.	(methodString := self methodMatch value trimBlanks) isEmpty ifFalse: [constraints add: [:change | methodString match: change selector asString]].	(categoryString := self categoryMatch value trimBlanks) isEmpty ifFalse: [constraints add: [:change | categoryString match: change category asString]].	^constraints</body></methods><methods><class-id>Tools.ParcelByMethodFinder</class-id> <category>private</category><body package="Parcel Load Browser" selector="changeString:">changeString: aMethodDefinitionChange	^aMethodDefinitionChange className,'&gt;&gt;',aMethodDefinitionChange selector</body></methods><methods><class-id>Tools.ParcelByMethodFinder</class-id> <category>aspects</category><body package="Parcel Load Browser" selector="categoryMatch">categoryMatch	^categoryMatch isNil		ifTrue: [categoryMatch := String new asValue]		ifFalse: [categoryMatch]</body><body package="Parcel Load Browser" selector="methodMatch">methodMatch	^methodMatch isNil		ifTrue: [methodMatch := String new asValue]		ifFalse: [methodMatch]</body></methods><methods><class-id>Tools.ParcelByMethodFinder</class-id> <category>testing</category><body package="Parcel Load Browser" selector="useDefinition:">useDefinition: change	^change isDefinition and: [change type = #'method definition' and: [self matchConstraints: change]]</body></methods><methods><class-id>Tools.ParcelByMethodFinder</class-id> <category>actions</category><body package="Parcel Load Browser" selector="reset">reset	self methodMatch value: String new.	self categoryMatch value: String new.	super reset.</body></methods><methods><class-id>Tools.ParcelByPathFinder</class-id> <category>actions</category><body package="Parcel Load Browser" selector="addPathname">addPathname	| pathNode entry |	entry := self pathnameEntry value.	pathNode := self parcelsTree tree addDirectory: entry andFilesMatching: '*.pcl'.	pathNode notNil		ifTrue: 			[pathNode sortAllChildrenBy: sortBlock.			self updateTreeList.			self addPathToHistory: entry]</body><body package="Parcel Load Browser" selector="all">all	| selection |	selection := self parcelsTree selection.	selection isNil ifTrue: [^self].	Cursor wait		showWhile: 			[selection addAllFilesMatching: '*.pcl'.			selection sortAllChildrenBy: sortBlock].	self updateTreeList</body><body package="Parcel Load Browser" selector="less">less	"Show fewer entries under the node selection"	| selection |	selection := self parcelsTree selection. 	selection isNil ifTrue:[^self].	selection hasEmptyChildDirectories		ifTrue:[selection removeAllEmptyChildDirectories]		ifFalse:[selection removeLeafFilesMatching: '*' toHeight:1].	self updateTreeList</body><body package="Parcel Load Browser" selector="more">more	"Show more selections under the node selection"	| selection |	selection := self parcelsTree selection.   	selection isNil ifTrue:[^self].  	Cursor wait		showWhile: 			[selection addChildFilesMatching: '*.pcl' toDepth: 2].	selection sortAllChildrenBy: sortBlock.	self updateTreeList</body><body package="Parcel Load Browser" selector="remove">remove	"Remove the node from the directory search tree"	| selection |	selection := self parcelsTree selection. 	selection isNil ifTrue:[^self].  	selection parent removeChild: selection.	self updateTreeList</body><body package="Parcel Load Browser" selector="sortAscending">sortAscending	sortBlock := [:a :b| a key &lt; b key].	self parcelsTree tree sortAllChildrenBy: sortBlock.	self parcelsToSelect list: (self parcelsToSelect list asSortedCollection: sortBlock) asList.</body><body package="Parcel Load Browser" selector="sortDescending">sortDescending	sortBlock := [:a :b| a key &gt; b key].	self parcelsTree tree sortAllChildrenBy: sortBlock.	self parcelsToSelect list: (self parcelsToSelect list asSortedCollection: sortBlock) asList.</body><body package="Parcel Load Browser" selector="updateFileSelections">updateFileSelections	| selections |  	selections := self parcelsToLoad list collect:[:assoc| assoc value].	self parcelsToSelect selections: (self parcelsToSelect list select:[:assoc| selections includes: assoc value]).</body><body package="Parcel Load Browser" selector="updateFileSelectList">updateFileSelectList	| candidates pattern |	Cursor wait showWhile:[candidates := self selectedPath leafFileChildren collect: [:child | (self emphasizedName: child)-&gt;child value]].  	"Filter candidates"	pattern := self filter value trimBlanks.	candidates := candidates select: [:assoc | pattern match: assoc key].		"Sort candidates"	candidates := candidates asSortedCollection: sortBlock.	self parcelsToSelect list: candidates asList.	self updateFileSelections</body></methods><methods><class-id>Tools.ParcelByPathFinder</class-id> <category>aspects</category><body package="Parcel Load Browser" selector="filter">filter	^filter isNil		ifTrue:			[filter := '*' asValue]		ifFalse:			[filter]</body><body package="Parcel Load Browser" selector="parcelSelections">parcelSelections	^self parcelsToSelect selections</body><body package="Parcel Load Browser" selector="parcelsToSelect">parcelsToSelect	^parcelsToSelect isNil		ifTrue:			[parcelsToSelect := MultiSelectionInList new]		ifFalse:			[parcelsToSelect]</body><body package="Parcel Load Browser" selector="pathnameEntry">pathnameEntry	^pathnameEntry isNil		ifTrue:			[pathnameEntry := nil asValue]		ifFalse:			[pathnameEntry]</body><body package="Parcel Load Browser" selector="userPathnamesHolder">userPathnamesHolder	^self class userPathnames asValue</body></methods><methods><class-id>Tools.ParcelByPathFinder</class-id> <category>notification</category><body package="Parcel Load Browser" selector="changeDisplayMode">changeDisplayMode	Cursor wait		showWhile: 			[self parcelsTree tree leafFileChildren do: [:child | self setViewModeName: child].			self updateTreeList.			self filter value: '*']</body></methods><methods><class-id>Tools.ParcelByPathFinder</class-id> <category>interface opening</category><body package="Parcel Load Browser" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self sortAscending.</body><body package="Parcel Load Browser" selector="postOpenWith:">postOpenWith: aBuilder</body></methods><methods><class-id>Tools.ParcelByPathFinder</class-id> <category>private-conversions</category><body package="Parcel Load Browser" selector="pathToString:">pathToString: aFilename	^aFilename asString</body><body package="Parcel Load Browser" selector="stringToPath:">stringToPath: aString	^PortableFilename named: aString trimBlanks</body></methods><methods><class-id>Tools.ParcelByPathFinder</class-id> <category>private</category><body package="Parcel Load Browser" selector="addPathToHistory:">addPathToHistory: pathString 	| pathnames |	pathnames := self class userPathnames.	(pathnames includes: pathString)		ifFalse: [pathnames addFirst: pathString]</body><body package="Parcel Load Browser" selector="updateTreeList">updateTreeList	| selectionIndex |	selectionIndex := self parcelsTree selectionIndex.	self parcelsTree buildIndentedList.	self parcelsTree list size &lt; selectionIndex		ifFalse:[self parcelsTree selectionIndex: selectionIndex].	self updateFileSelectList.</body></methods><methods><class-id>XML.FastSourceScannerNodeBuilder</class-id> <category>scanning</category><body package="Parcel Load Browser" selector="scanFile:do:">scanFile: file do: aBlock	changeBlock := aBlock.	XMLParser new		builder: self;		parseElements: file.</body></methods><methods><class-id>XML.FastSourceScannerNodeBuilder</class-id> <category>private</category><body package="Parcel Load Browser" selector="doChange:">doChange: aChange	changeBlock value: aChange value: self</body></methods><methods><class-id>XML.FastSourceScannerNodeBuilder</class-id> <category>priviledged</category><body package="Parcel Load Browser" selector="obtainSource:">obtainSource: aChange	"Only temporarily valid for current aChange"	aChange file == nil		ifTrue: [aChange file: currentFile position: currentPosition].</body></methods><methods><class-id>XML.FastSourceScannerNodeBuilder</class-id> <category>building</category><body package="Parcel Load Browser" selector="comment:">comment: aText	| comment |	comment := Comment new text: aText.	changeBlock value: (OtherChange new text: aText; type: #comment) value: self.	^comment</body></methods><methods><class-id>Kernel.FastChangeScanner</class-id> <category>file scanning</category><body package="Parcel Load Browser" selector="scanFile:do:">scanFile: aFileStream do: aBlock	"Evaluate aBlock with each item on the file"	(aFileStream		withPosition: 0		do: [:pos| aFileStream peek == $&lt;]) ifTrue:			[#{XML.FastSourceScannerNodeBuilder} ifDefinedDo:				[:xmlChangeScanner |				[xmlChangeScanner new scanFile: aFileStream do: aBlock]					on: (#{XML.MalformedSignal} valueOrDo: [Signal new])					do: [:ex|						"Ignore malformed errors caused by missing endtags						 in changes files"						ex getSignal = XML.BadCharacterSignal							ifTrue: [Transcript cr; show: 'Bad character'. ex resume].						aFileStream size = aFileStream position ifTrue:							[ex return].						ex pass]].				^self].	[| position peek |	file := aFileStream.	[file skipSeparators.	(peek := file peek) == nil]		whileFalse:			[peek = $!				ifTrue:					[file next.					self scan: self nextChunkStream.					self scanSpecialDo: aBlock]				ifFalse:					[position := file position.					self scanExpression: self nextChunkStream do:						[:item | aBlock value: (item file: file position: position) value: self]]]]		on: Stream endOfStreamSignal		do: [:ex| ex resume: nil]</body><body package="Parcel Load Browser" selector="scanMethodsClass:category:do:">scanMethodsClass: class category: category do: aBlock	| classObject position method selector |	classObject := (class includes: Character space)			ifTrue: [((class copyUpTo: Character space)					asQualifiedReference valueOrDo: []) class]			ifFalse: [class asQualifiedReference valueOrDo: []].	classObject isBehavior ifFalse: [classObject := Object].	[file skipSeparators.	position := file position.	(method := self nextChunkStream) atEnd]		whileFalse:			[method := method contents.			selector := classObject parserClass new parseSelector: method.			selector notNil ifTrue:				[aBlock value: ((MethodDefinitionChange file: file position: position) className: class; selector: selector; category: category) value: self]]</body></methods><methods><class-id>Tools.ParcelByNameFinder</class-id> <category>initialize release</category><body package="Parcel Load Browser" selector="initialize">initialize	super initialize.	self clearList.</body></methods><methods><class-id>Tools.ParcelByNameFinder</class-id> <category>aspects</category><body package="Parcel Load Browser" selector="entries">entries	^entries isNil		ifTrue:			[entries := self initialText asValue]		ifFalse:			[entries]</body><body package="Parcel Load Browser" selector="nameList">nameList	^nameList isNil		ifTrue:			[nameList := SelectionInList new]		ifFalse:			[nameList]</body><body package="Parcel Load Browser" selector="parcelSelections">parcelSelections	^available</body><body package="Parcel Load Browser" selector="parsedChoices">parsedChoices	^#('Available' 'Missing' 'Loaded') asValue</body><body package="Parcel Load Browser" selector="parsedListType">parsedListType	^parsedListType isNil		ifTrue:			[parsedListType := 'Available' asValue]		ifFalse:			[parsedListType]</body></methods><methods><class-id>Tools.ParcelByNameFinder</class-id> <category>private</category><body package="Parcel Load Browser" selector="editorEntry">editorEntry	self entries value = self initialText ifTrue: [self entries value: String new]</body><body package="Parcel Load Browser" selector="listParcelName:version:file:from:">listParcelName: parcelName version: version file: file from: parsedNames 	| name | 	name := parsedNames detect: [:item | 		self obeyVersion value					ifTrue: [item = (parcelName -&gt; version)]					ifFalse: [item key = parcelName]]				ifNone: [^self].  	(Parcel parcelNamed: parcelName) isNil		ifTrue: [available add: (self tagForName: parcelName andVersion: version)-&gt; file]		ifFalse: [loaded add: (Text string: parcelName , ' ' , version emphasis: #italic)-&gt; file].	parsedNames remove: name</body><body package="Parcel Load Browser" selector="listParcelsNamed:">listParcelsNamed: parsedNames 	"Set the contents of the missing, loaded, and available 	parcel  lists according to the parsedNames list"	Cursor wait showWhile: [self parcelsTree tree immediateChildDirectories do: [:parent | Parcel withFileCachesDo: [Parcel					cachedParcelFileInfoIn: parent value					for: nil					do: 						[:info :file | 						self							listParcelName: (info at: #parcel)							version: (info at: #version ifAbsent: [''])							file: file							from: parsedNames.						parsedNames isEmpty							ifTrue: 								[missing := List new.								^self]]]]].	missing := parsedNames</body><body package="Parcel Load Browser" selector="parsedChange">parsedChange	| type |	type := self parsedListType value. 	type = 'Available'		ifTrue: 			[self nameList list: available.			(self builder componentAt: #add) enable].	type = 'Missing'		ifTrue: 			[self nameList list: missing.			(self builder componentAt: #add) disable].	type = 'Loaded'		ifTrue: 			[self nameList list: loaded.			(self builder componentAt: #add) enable]</body><body package="Parcel Load Browser" selector="tagForName:andVersion:">tagForName: nameString andVersion: versionString 	^self obeyVersion value		ifTrue: [nameString , ' ' , versionString]		ifFalse: [nameString]</body><body package="Parcel Load Browser" selector="updateLists">updateLists	| type | 	type := self parsedListType value.	type = 'Available' ifTrue: [available := self nameList list].	type = 'Missing' ifTrue:  [missing := self nameList list].	type = 'Loaded' ifTrue:  [loaded := self nameList list].</body></methods><methods><class-id>Tools.ParcelByNameFinder</class-id> <category>actions</category><body package="Parcel Load Browser" selector="addParcels">addParcels	"Add all parcels in the available list optionally without any prerequisite parcels named in the list"	| loadSet |	loadSet := Set withAll: self parcelsToLoad list.	loadSet addAll: available.	self parcelsToLoadList: loadSet.</body><body package="Parcel Load Browser" selector="clearList">clearList	self nameList list: List new.	available := List new.	missing := List new.	loaded := List new.</body><body package="Parcel Load Browser" selector="initialText">initialText	^'Paste lines from the System: page of the Launcher Help-&gt;About VisualWorks... to supply parcel names.'</body><body package="Parcel Load Browser" selector="parseParcels">parseParcels	| names stream |	names := Set new.	stream := self entries value readStream.	["Expects entries in the form of: &lt;parcel name&gt; Version &lt;version&gt; 	of &lt;timestamp&gt;"	stream atEnd]		whileFalse: 			[| lineStream version name timestamp |			lineStream := (stream upTo: Character cr) readStream.			lineStream skipSeparators.			name := lineStream upToAll: 'Version'.			name isEmpty				ifFalse: 					[version := String new.					lineStream atEnd						ifTrue: [name := lineStream reset skipSeparators upToAll: ' of']						ifFalse: 							[lineStream throughAll: 'Version '.							version := lineStream upToAll: ' of'].					lineStream throughAll: ' of '.					timestamp := lineStream upToEnd.					names add: name asString trimBlanks-&gt;version asString trimBlanks]].	self clearList.	self listParcelsNamed: names asList.	self parsedChange</body><body package="Parcel Load Browser" selector="removeName">removeName	self nameList list remove: self nameList selection.	self updateLists</body></methods><methods><class-id>Tools.ParcelByNameFinder</class-id> <category>interface opening</category><body package="Parcel Load Browser" selector="postOpenWith:">postOpenWith: aBuilder</body></methods><methods><class-id>Tools.ParcelFavorites</class-id> <category>events</category><body package="Parcel Load Browser" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	self class saveFavorites</body></methods><methods><class-id>Tools.ParcelFavorites</class-id> <category>aspects</category><body package="Parcel Load Browser" selector="parcelFavorites">parcelFavorites	parcelFavorites isNil		ifTrue: 			[parcelFavorites := MultiSelectionInList new.			self setFavoritesList].	^parcelFavorites</body><body package="Parcel Load Browser" selector="parcelSelections">parcelSelections	^self parcelFavorites selections</body><body package="Parcel Load Browser" selector="parcelsToSelect">parcelsToSelect	^self parcelFavorites</body><body package="Parcel Load Browser" selector="sortMode">sortMode	^sortMode isNil		ifTrue:			[sortMode := #mostFrequent asValue]		ifFalse:			[sortMode]</body></methods><methods><class-id>Tools.ParcelFavorites</class-id> <category>actions</category><body package="Parcel Load Browser" selector="addFavorites">addFavorites	self parcelsToLoad list do:[:assoc| self class addFavorite: assoc value].	self setFavoritesList.</body><body package="Parcel Load Browser" selector="removeFavorites">removeFavorites	| selections |	(selections := self parcelFavorites selections) isEmpty		ifFalse: 			[selections do:[:assoc| self class removeFavorite: assoc value].			self setFavoritesList]</body></methods><methods><class-id>Tools.ParcelFavorites</class-id> <category>notification</category><body package="Parcel Load Browser" selector="changeDisplayMode">changeDisplayMode	self parcelFavorites list		do: 			[:assoc | 			self setViewModeName: assoc.			assoc key: (self emphasizedName: assoc)].  	self parcelFavorites listHolder changed.</body></methods><methods><class-id>Tools.ParcelFavorites</class-id> <category>interface opening</category><body package="Parcel Load Browser" selector="postOpenWith:">postOpenWith: aBuilder</body></methods><methods><class-id>Tools.ParcelFavorites</class-id> <category>private</category><body package="Parcel Load Browser" selector="setFavoritesList">setFavoritesList	| list |	self sortMode value == #mostFrequent		ifTrue: [list := self class filesRankedMostUsed]		ifFalse: [list := self class filesRankedLastUsed].	list		do: 			[:assoc | 			self setViewModeName: assoc.			assoc key: (self emphasizedName: assoc)].	self parcelFavorites list: list.</body></methods><methods><class-id>Tools.ParcelFavorites class</class-id> <category>parcel load</category><body package="Parcel Load Browser" selector="loadParcelFrom:">loadParcelFrom: aFilename	aFilename exists ifFalse:[^Dialog warn: 'Unable to find parcel ', aFilename asString].	self addFavorite: aFilename.	Parcel loadParcelFrom: aFilename.</body></methods><methods><class-id>Tools.ParcelFavorites class</class-id> <category>accessing</category><body package="Parcel Load Browser" selector="favorites">favorites	^Favorites isNil		ifTrue: 			[self storageFile exists				ifTrue: 					[self readFavorites.					Favorites]				ifFalse: [Favorites := Dictionary new]]		ifFalse: [Favorites]</body><body package="Parcel Load Browser" selector="files">files	^self favorites at:#files ifAbsentPut:[Dictionary new]</body><body package="Parcel Load Browser" selector="filesRankedLastUsed">filesRankedLastUsed	| lastUsed |	lastUsed := self lastUsed.	^SortedCollection withAll: (self files associations collect:[:assoc| assoc copy])  sortBlock:[:a :b | (lastUsed at: a key) &gt; (lastUsed at: b key)]</body><body package="Parcel Load Browser" selector="filesRankedLastUsedNotLoaded">filesRankedLastUsedNotLoaded	^self filesRankedLastUsed select:[:assoc|(Parcel parcelNamed: assoc key first) isNil]</body><body package="Parcel Load Browser" selector="filesRankedMostUsed">filesRankedMostUsed	| mostUsed |	mostUsed := self mostUsed.	^SortedCollection withAll: (self files associations collect:[:assoc| assoc copy]) sortBlock: [:a :b | (mostUsed occurrencesOf: a key)					&gt; (mostUsed occurrencesOf: b key)]</body><body package="Parcel Load Browser" selector="filesRankedMostUsedNotLoaded">filesRankedMostUsedNotLoaded	^self filesRankedMostUsed select:[:assoc|(Parcel parcelNamed: assoc key first) isNil]</body><body package="Parcel Load Browser" selector="lastUsed">lastUsed	^self favorites at:#lastUsed ifAbsentPut:[Dictionary new]</body><body package="Parcel Load Browser" selector="mostUsed">mostUsed	^self favorites at:#mostUsed ifAbsentPut:[Bag new]</body></methods><methods><class-id>Tools.ParcelFavorites class</class-id> <category>changing favorites</category><body package="Parcel Load Browser" selector="addFavorite:">addFavorite: aFilename	| key |	key := self nameVerFor: aFilename.	self mostUsed add: key.	self lastUsed at: key put: Timestamp now.	self files at: key put: aFilename.</body><body package="Parcel Load Browser" selector="removeFavorite:">removeFavorite: aFilename 	| key |	key := self files keyAtValue: aFilename ifAbsent: [^self].	self mostUsed remove: key ifAbsent: [].	self lastUsed removeKey: key ifAbsent: [].	self files removeKey: key ifAbsent: []</body></methods><methods><class-id>Tools.ParcelFavorites class</class-id> <category>storage</category><body package="Parcel Load Browser" selector="readFavorites">readFavorites	| readStream |	readStream := self storageFile readStream.	[Favorites := Dictionary readFrom: readStream]		ensure: [readStream close]</body><body package="Parcel Load Browser" selector="saveFavorites">saveFavorites	"Save the favorites to disk. Abort silently on error"	| storeStream |		[storeStream := self storageFile writeStream.	[Favorites storeOn: storeStream]		ensure: [storeStream close]]		on: OsError do: [:ex | ex return]</body><body package="Parcel Load Browser" selector="storageFile">storageFile	^'parcels.fav' asFilename</body></methods><methods><class-id>Tools.ParcelFavorites class</class-id> <category>initialization</category><body package="Parcel Load Browser" selector="initialize">initialize	Favorites := nil.</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>api</category><body package="Parcel Load Browser" selector="loadParcelFor:">loadParcelFor: aVisualOrNil 	"UI for reading in a parcel in fast-loading binary format."	Tools.ParcelLoadBrowser open</body><body package="Parcel Load Browser" selector="loadParcelByNameFor:">loadParcelByNameFor: aVisualOrNil 	"UI for reading in a parcel in fast-loading binary format."	self loadParcelFor: aVisualOrNil</body></methods><methods><class-id>Tools.ParcelLoadBrowser class</class-id> <category>resources</category><body package="Parcel Load Browser" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: 'remove' 				#value: #removeName ) 			#(#MenuItem 				#rawLabel: 'clear all' 				#value: #clearList ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Parcel Load Browser" selector="loadMenu">loadMenu	"MenuEditor new openOnClass: self andSelector: #loadMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'remove' 				#value: #removeLoadSelection ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="Parcel Load Browser" selector="tabsMenu">tabsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #tabsPage"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Path' 				#value: #pathPage ) 			#(#{UI.MenuItem} 				#rawLabel: 'Name' 				#value: #namePage ) 			#(#{UI.MenuItem} 				#rawLabel: 'Class' 				#value: #classPage ) 			#(#{UI.MenuItem} 				#rawLabel: 'Method' 				#value: #methodPage ) 			#(#{UI.MenuItem} 				#rawLabel: 'Favorites' 				#value: #favoritesPage ) ) #(5 ) nil ) decodeAsLiteralArray</body><body package="Parcel Load Browser" selector="treeMenu">treeMenu	"MenuEditor new openOnClass: self andSelector: #treeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'all' 				#value: #all ) 			#(#{UI.MenuItem} 				#rawLabel: 'more' 				#value: #more ) 			#(#{UI.MenuItem} 				#rawLabel: 'less' 				#value: #less ) 			#(#{UI.MenuItem} 				#rawLabel: 'remove' 				#value: #remove ) 			#(#{UI.MenuItem} 				#rawLabel: 'sort...' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'ascending' 							#value: #sortAscending ) 						#(#{UI.MenuItem} 							#rawLabel: 'descending' 							#value: #sortDescending ) ) #(2 ) nil ) ) ) #(1 2 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ParcelLoadBrowser class</class-id> <category>interface specs</category><body package="Parcel Load Browser" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Parcel Load Selection' 			#bounds: #(#{Graphics.Rectangle} 56 374 551 843 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 8 0.666666 -15 1 -10 0.8 ) 					#name: #selectionsWidget 					#model: #parcelsToLoad 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#showSelectionComment: ) 					#menu: #loadMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -30 1 -15 1 -5 1 ) 					#model: #closeRequest 					#label: 'Done' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 15 0 -15 0.666666 ) 					#label: 'Selections:' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 10 0.8 -15 1 -40 1 ) 					#model: #comment 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 15 0 -12 0.8 ) 					#label: 'Description:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -175 1 -30 1 -100 1 -5 1 ) 					#model: #load 					#label: 'Load' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 15 0 -29 1 ) 					#model: #unlist 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #unlistChange ) 					#label: 'Unlist prerequisites' ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -15 0.666666 ) 					#name: #searchNotebook 					#model: #pageKeys 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedPage ) 					#labels: #() ) ) ) )</body></methods><methods><class-id>Tools.ParcelByClassFinder class</class-id> <category>interface specs</category><body package="Parcel Load Browser" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Parcel finder' 			#bounds: #(#{Graphics.Rectangle} 730 109 1225 360 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 87 20 199 45 ) 					#model: #classMatch ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 87 48 199 73 ) 					#model: #superclassMatch ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 87 78 199 103 ) 					#model: #namespaceMatch ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 8 109 66 134 ) 					#name: #stopButton 					#flags: 40 					#model: #stopSearch 					#label: 'Stop' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 19 ) 					#label: 'Class' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 49 ) 					#label: 'Superclass' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.666666 20 0 -10 1 140 0 ) 					#name: #parcels 					#flags: 15 					#model: #parcelsList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#updateSelections: ) 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #checkMark ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 166 0 -9 1 -8 1 ) 					#model: #definition 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 78 ) 					#label: 'Namespace' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 205 0 20 0 16 0.666666 140 0 ) 					#name: #changes 					#flags: 15 					#model: #changeList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #classSelect ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 142 0 -9 1 161 0 ) 					#flags: 0 					#model: #fileSearched 					#style: #small 					#isReadOnly: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 66 0 124 25 ) 							#model: #search 							#label: 'Search' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 0 0 58 25 ) 							#model: #reset 							#label: 'Reset' 							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 74 109 199 134 ) 						#name: #searchButtons ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 205 -2 ) 					#label: 'Class:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 16 0.666666 -2 0 ) 					#label: 'Parcel:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 -2 ) 					#label: 'Find definition:' ) ) ) )</body></methods><methods><class-id>Tools.ParcelByMethodFinder class</class-id> <category>interface specs</category><body package="Parcel Load Browser" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Parcel finder' 			#bounds: #(#{Graphics.Rectangle} 172 596 667 847 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 87 19 199 44 ) 					#model: #methodMatch ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 87 48 199 73 ) 					#model: #categoryMatch ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 87 78 199 103 ) 					#model: #classMatch ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 8 109 66 134 ) 					#name: #stopButton 					#flags: 40 					#model: #stopSearch 					#label: 'Stop' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 78 ) 					#label: 'Class' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.666666 20 0 -10 1 140 0 ) 					#name: #parcels 					#flags: 15 					#model: #parcelsList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#updateSelections: ) 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #checkMark ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 166 0 -9 1 -8 1 ) 					#model: #definition 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 205 0 20 0 16 0.666666 140 0 ) 					#name: #changes 					#flags: 15 					#model: #changeList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #classSelect ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 142 0 -9 1 161 0 ) 					#flags: 0 					#model: #fileSearched 					#style: #small 					#isReadOnly: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 66 0 124 25 ) 							#model: #search 							#label: 'Search' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 0 0 58 25 ) 							#model: #reset 							#label: 'Reset' 							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 75 109 199 134 ) 						#name: #searchButtons ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 205 -2 ) 					#label: 'Method:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 16 0.666666 -2 0 ) 					#label: 'Parcel:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 -2 ) 					#label: 'Find definition:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 19 ) 					#label: 'Method' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 49 ) 					#label: 'Protocol' ) ) ) )</body></methods><methods><class-id>Tools.ParcelByPathFinder class</class-id> <category>interface specs</category><body package="Parcel Load Browser" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Parcels by Path' 			#bounds: #(#{Graphics.Rectangle} 388 337 892 688 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.HierarchicalViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 68 0 -5 0.5 -15 1 ) 					#flags: 15 					#model: #parcelsTree 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateFileSelectList ) 					#menu: #treeMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 23 0 -5 0.5 45 0 ) 					#model: #pathnameEntry 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #addPathname ) 					#isReadOnly: false 					#type: #object 					#comboList: #userPathnamesHolder 					#readSelector: 					#stringToPath: 					#printSelector: 					#pathToString: ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0.5 23 0 -15 1 45 0 ) 					#model: #filter 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateFileSelectList ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 15 42 ) 					#label: 'Find in:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0.5 42 0 ) 					#label: 'Files:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0.5 0 0 ) 					#label: 'Filter:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 15 0 ) 					#label: 'Add path:' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0.5 68 0 -15 1 -42 1 ) 					#name: #selectWidget 					#flags: 15 					#model: #parcelsToSelect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#updateSelections: ) 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #checkMark ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.5 -37 1 -15 1 -15 1 ) 					#model: #viewMode 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changeDisplayMode ) 					#comboList: #viewChoices ) ) ) )</body></methods><methods><class-id>Tools.ParcelByPathFinder class</class-id> <category>resources</category><body package="Parcel Load Browser" selector="treeMenu">treeMenu	"MenuEditor new openOnClass: self andSelector: #treeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'all' 				#value: #all ) 			#(#{UI.MenuItem} 				#rawLabel: 'more' 				#value: #more ) 			#(#{UI.MenuItem} 				#rawLabel: 'less' 				#value: #less ) 			#(#{UI.MenuItem} 				#rawLabel: 'remove' 				#value: #remove ) 			#(#{UI.MenuItem} 				#rawLabel: 'sort...' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'ascending' 							#value: #sortAscending ) 						#(#{UI.MenuItem} 							#rawLabel: 'descending' 							#value: #sortDescending ) ) #(2 ) nil ) ) ) #(1 2 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ParcelByNameFinder class</class-id> <category>interface specs</category><body package="Parcel Load Browser" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Parcels by Name' 			#bounds: #(#{Graphics.Rectangle} 536 383 865 668 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 37 0 -5 0.5 -38 1 ) 					#name: #parseText 					#flags: 15 					#model: #entries 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#focusInSelector: #editorEntry ) 					#tabRequiresControl: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0.5 36 0 -14 1 -38 1 ) 					#name: #parcelNameList 					#flags: 15 					#model: #nameList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#showSelectionComment: ) 					#menu: #listMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 15 3 ) 					#label: 'Parcel names to load' ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.5 4 0 -15 1 26 0 ) 					#model: #parsedListType 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parsedChange ) 					#comboList: #parsedChoices ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} -40 0.25 -30 1 ) 					#model: #parseParcels 					#label: 'Accept' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} -20 0.75 -30 1 ) 					#name: #add 					#model: #addParcels 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} -53 0.5 -30 1 ) 					#model: #obeyVersion 					#label: 'Obey Version' ) ) ) )</body></methods><methods><class-id>Tools.ParcelFavorites class</class-id> <category>interface specs</category><body package="Parcel Load Browser" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Parcel favorites list' 			#bounds: #(#{Graphics.Rectangle} 495 375 786 649 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -125 1 -10 1 ) 					#model: #parcelFavorites 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSelections: ) 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #checkMark ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -70 1 19 0 -10 1 44 0 ) 					#model: #addFavorites 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -70 1 64 0 -10 1 89 0 ) 					#model: #removeFavorites 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} -118 1 103 0 -3 1 157 0 ) 					#label: 'Sort by' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} -112 1 116 0 ) 					#model: #sortMode 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setFavoritesList ) 					#label: 'Most Frequent' 					#select: #mostFrequent ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} -112 1 134 0 ) 					#model: #sortMode 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setFavoritesList ) 					#label: 'Last Used' 					#select: #lastUsed ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Parcel Load Browser" selector="toolsLoadParcelFavorites">toolsLoadParcelFavorites	"Add a submenu to load a parcel favorite by name."	&lt;computedSubmenu: 'Load &amp;Favorite Parcel'        nameKey: nil       menu: #(#menuBar #system)       position: 9.3&gt;	| mb |	mb := MenuBuilder new.	ParcelFavorites filesRankedMostUsedNotLoaded do: [:assoc | mb addLabel: assoc key first , ' ' , assoc key last			value: 				[ParcelFavorites loadParcelFrom: assoc value.				ParcelFavorites saveFavorites]].	^mb menu</body><body package="Parcel Load Browser" selector="toolsLoadParcelByName">toolsLoadParcelByName	&lt;menuItem: #(#loadParcelNamed #menus '&amp;Load Parcel Named...')	nameKey: nil	menu: #(#menuBar #system)	position: 9.02&gt;	^ParcelLoadBrowser open</body></methods><initialize><class-id>Tools.ParcelLoadBrowser</class-id></initialize><initialize><class-id>Tools.ParcelFavorites</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ChangeScanner</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>file chunkString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>SourceScannerNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors currentFile currentPosition positions changeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>AssociationTreeWithParent</name><environment>UI</environment><super>UI.AssociationTree</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent expanded rootIcon icon trailingIcon displayableIndents visual </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>