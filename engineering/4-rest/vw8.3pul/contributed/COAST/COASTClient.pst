<?xml version="1.0"?><st-source><!-- Name: COASTClientNotice: The MIT LicenseCopyright (c) 2013 intelligent views GmbHPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DevelopmentPrerequisites: #(#(#any 'COASTCore' '') #(#any 'COASTGarbageCollection' '') #(#any 'MD5' '') #(#any 'UUID' '') #(#any 'WeakCollections' '') #(#any 'COASTBinaryObjectStore' ''))EnvyVersion: 4.3.2PackageName: COASTClientPackageName:: COASTClientParcel: #('COASTClient')ParcelDirectory: COASTClientPrerequisiteDescriptions: #(#(#name 'COASTCore' #componentType #bundle) #(#name 'COASTGarbageCollection' #componentType #package) #(#name 'MD5' #componentType #package) #(#name 'UUID' #componentType #package) #(#name 'WeakCollections' #componentType #package) #(#name 'COASTBinaryObjectStore' #componentType #package))PrerequisiteParcels: #(#('COASTCore' '') #('COASTGarbageCollection' '') #('MD5' '') #('UUID' '') #('WeakCollections' '') #('COASTBinaryObjectStore' ''))Version: 5.4.68Post-Load Block: 	[:package | ]Date: 11:13:09 AM July 18, 2014 --><time-stamp>From VisualWorksÂ®, 7.10.1 of 6. Februar 2014 on 18. Juli 2014 at 11:13:09</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CacheAccessor</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>LocalCacheAccessor</name><environment>COAST</environment><super>COAST.CacheAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storageAccessor expireAge maxCacheSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>FramePagingCacheAccessor</name><environment>COAST</environment><super>COAST.LocalCacheAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readOnly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastModel</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastApplicationModel</name><environment>COAST</environment><super>COAST.CoastModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastUniversalLocalApplicationModel</name><environment>COAST</environment><super>COAST.CoastApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastComponentApplicationModel</name><environment>COAST</environment><super>COAST.CoastApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastCompositeApplicationModel</name><environment>COAST</environment><super>COAST.CoastComponentApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastPerformanceCounterNode</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parentNode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>CoastClientVolumeManager</name><environment>COAST</environment><super>COAST.CatCSVolumeManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultHost connectionLostBlock responseQueue transactionManager requestTimeout interruptProtect persistentClientID defaultUnloadStrategy useProxyValueHolder reconnectAttempts clientDescription </inst-vars><class-inst-vars>defaultServerPort </class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>LogOnlyUnloadStrategy</name><environment>COAST</environment><super>COAST.CatCSUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastInterruptHandler</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handlerBlock processToInterrupt targets forkedInterrupt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastClientConfiguration</name><environment>COAST</environment><super>COAST.CoastApplicationConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COASTClient</package></attributes></class><class><name>UnresolvedFramesDictionary</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManager lastCompress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>WeakSubscriptionRegistry</name><environment>COAST</environment><super>Core.SubscriptionRegistry</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>COASTClient</package></attributes></class><class><name>WeakAnnouncer</name><environment>COAST</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>ClusterUnloadProcess</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager process active priority delay unloadableCountOrRatio </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>CatRMClientPacketStation</name><environment>COAST</environment><super>COAST.CatRMPacketStation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ownID host connectPort reconnectSemaphore lastSendTime keepAliveProcess inReconnectPhase </inst-vars><class-inst-vars>connectTimeout </class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CatCSAbstractClientClusterManager</name><environment>COAST</environment><super>COAST.CatCSClusterManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unloadStrategy unresolvedFrames clustersWithStreams volumeContext unloadProcessHandler reusableClusters blockCaches statistics </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastApplicationClient</name><environment>COAST</environment><super>COAST.CoastApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumeManager </inst-vars><class-inst-vars>default active </class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>ClientClassNameManager</name><environment>COAST</environment><super>COAST.ClassNameManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldClassName2ClassDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastConnectionRefusedError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastPerformanceUnit</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>RPCCacheKey</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frame slot selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>CatRMClientVolumeTimeManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeDifference clusterManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CatRMMediatorLostError</name><environment>COAST</environment><super>COAST.CoastConnectionLostError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastPerformanceStatistics</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startTime lastLogTime rootNode clusterManager </inst-vars><class-inst-vars>enabled </class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>CoastInterrupt</name><environment>COAST</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler interruptMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>ObserverIgnorantMinAgeUnloadStrategy</name><environment>COAST</environment><super>COAST.MinAgeLRUUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>CatBFCacheBlockFileSystem</name><environment>COAST</environment><super>COAST.CatBFBlockFileSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changeCount cacheAccessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COASTClient</package></attributes></class><class><name>CatRMClientCC</name><environment>COAST</environment><super>COAST.CatCSClusterController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>log packetStation localSeqNum localBase acceptedLocalBase acknowledgedGlobalSeqNum globalSeqNum outstandingGlobalSeqNums localRolledBack unloadStrategyInformation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>WeakFrameResolver</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterID clusterManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastPerformanceCounterSection</name><environment>COAST</environment><super>COAST.CoastPerformanceCounterNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodes key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>CoastInteractiveClientConfiguation</name><environment>COAST</environment><super>COAST.CoastClientConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>SegmentedUnresolvedFramesRegistry</name><environment>COAST</environment><super>COAST.UnresolvedFramesDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>weakFramesSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>CoastLocalClientClusterManager</name><environment>COAST</environment><super>COAST.CatCSAbstractClientClusterManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>autoSaveProcess testAndSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CacheDisabledAccessor</name><environment>COAST</environment><super>COAST.CacheAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>DisabledUnloadStrategy</name><environment>COAST</environment><super>COAST.LogOnlyUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastPerformanceCounter</name><environment>COAST</environment><super>COAST.CoastPerformanceCounterNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unit quantity ticks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>CoastPerformanceUnitBytes</name><environment>COAST</environment><super>COAST.CoastPerformanceUnit</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>CoastDomainUser</name><environment>COAST</environment><super>COAST.CoastModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastUser</name><environment>COAST</environment><super>COAST.CoastModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>localCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastPerformanceUnitDuration</name><environment>COAST</environment><super>COAST.CoastPerformanceUnit</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>CoastPerformanceUnitNumber</name><environment>COAST</environment><super>COAST.CoastPerformanceUnit</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>CoastClientClusterManager</name><environment>COAST</environment><super>COAST.CatCSAbstractClientClusterManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageQueue messageProcess waitingMultiParts requiredMultiParts timeManager host cacheAccessor interruptHandlers waitingSingleParts criticalLoadTimeLimit binaryStoreInterfaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>LanCacheAccessor</name><environment>COAST</environment><super>COAST.CacheAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cacheHost mediatorHost cache clusterManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastPerformanceCounterRoot</name><environment>COAST</environment><super>COAST.CoastPerformanceCounterSection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTClient</package></attributes></class><class><name>CoastNotifierShared</name><environment>COAST</environment><super>COAST.CoastApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTClient</package></attributes></class><shared-variable><name>RegisteredUnits</name><environment>COAST.CoastPerformanceUnit</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COASTClient</package></attributes></shared-variable><shared-variable><name>ClusterUnloadCounter</name><environment>COAST.CatCSAbstractClientClusterManager</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COASTClient</package></attributes></shared-variable><shared-variable><name>ClusterLoadCounter</name><environment>COAST.CatCSAbstractClientClusterManager</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COASTClient</package></attributes></shared-variable><shared-variable><name>ClientPacketStationClass</name><environment>COAST.CoastClientVolumeManager</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COASTClient</package></attributes></shared-variable><shared-variable><name>CriticalLoadTimeLimit</name><environment>COAST.CoastClientClusterManager</environment><private>false</private><constant>false</constant><category>cluster load</category><initializer>nil</initializer><attributes><package>COASTClient</package></attributes></shared-variable><methods><class-id>COAST.CoastApplicationClient</class-id> <category>parameters</category><body package="COASTClient">parseLogConsole: stream	&lt;	commandlineParameter: #console		canPerform: nil		aliases: nil		usage: 'console {true/false}'		help: 'enable/disable console output for this application'		&gt;	| boolean |	boolean := stream next			ifNotNil: [ : s | 'true' match: s ]			ifNil: [ self errorInCommandLine: 'log console: true/false expected' ].	CoastLog singleton enableConsole: boolean.</body></methods><methods><class-id>COAST.ClientClassNameManager</class-id> <category>initialize-release</category><body package="COASTClient">buildRenamedClassesDict	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #referenceNonPrerequisiteClass&gt;		| newClass2OldNameDict |	oldClassName2ClassDict := Dictionary new.	newClass2OldNameDict := Dictionary new.	#{COAST.CatFSFrame} ifDefinedDo: 		[: catFSFrame |			catFSFrame withAllSubclasses do: 				[: class | ( Pragma allNamed: #coastFormerName: in: class class ) do: 						[: pragma | | oldName oldNameString ref oldClass |							oldNameString := pragma argumentAt: 1.							( ref := oldNameString asQualifiedReference ) isDefined ifTrue: 								[	oldClass := ref value.									(( oldClass isKindOf: CatFSFrame class ) and: [ oldClass fullName asString = oldNameString ]) 										ifTrue: [ self error: 'old class name ' , oldNameString , ': this class still exists!' ]								].							oldName := oldNameString asSymbol.							( oldClassName2ClassDict at: oldName ifAbsentPut: class ) = class ifFalse: [ self error: oldNameString , ' is not a unique old class name!' ].							" newClass2OldNameDict is only required to detect errors "							( newClass2OldNameDict at: class ifAbsentPut: oldNameString ) = oldNameString 								ifFalse: [ self error: class printString , ' has different former names' ]						]				]		].	^ oldClassName2ClassDict</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>user management</category><body package="COASTClient">localUser	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #sentNotImplemented&gt;	| aUser t |	((t := self activeTransaction) notNil and: [ (aUser := t localUser) notNil ])		ifTrue:  [ ^ aUser ]. 	localUser notNil ifTrue: [ ^ localUser ].	( Notifier isHeadless or: [( self respondsTo: #localUsers ) not ]) ifTrue: [ ^ nil ].	aUser := self localUsers anyElement.	aUser isNil ifTrue: [ ^ nil ].	aUser := aUser sharedCopy.	^ aUser isNil 		ifTrue: [ self localUsers anyElement ]		ifFalse: [ aUser ]</body></methods><methods><class-id>COAST.CacheAccessor</class-id> <category>interface</category><body package="COASTClient">basicWriteBackCluster: clusterController	self subclassResponsibility</body><body package="COASTClient">closeCache	self subclassResponsibility</body><body package="COASTClient">clusterFromCacheHitMessage: cacheHitMessage	self subclassResponsibility</body><body package="COASTClient">clusterFromCacheMissMessage: cacheMissMessage	self invalidateAccessFor: cacheMissMessage clusterID.</body><body package="COASTClient">emergencyCloseCache	" shutdown the cache as fast as possible. make sure that the cache remains valid after shutdown "</body><body package="COASTClient">invalidateAccessFor: clusterIDInteger	self subclassResponsibility</body><body package="COASTClient">modificationNumberFor: clusterIDInteger	self subclassResponsibility</body><body package="COASTClient">shouldWriteBackClusterController: clusterController 	^ clusterController clusterStub valueHolder notNil</body><body package="COASTClient">writeBackClusterController: clusterController 	(self shouldWriteBackClusterController: clusterController)		ifTrue: [ self basicWriteBackCluster: clusterController ]</body></methods><methods><class-id>COAST.CacheAccessor</class-id> <category>interface - blobs</category><body package="COASTClient">bytesAtID: clusterIDInteger	self subclassResponsibility</body><body package="COASTClient">bytesAtID: clusterIDInteger toFile: filename 	^filename = ''		ifTrue: [self bytesAtID: clusterIDInteger]		ifFalse: [self copyBytesAtID: clusterIDInteger toFile: filename]</body><body package="COASTClient">copyBytesAtID: clusterIDInteger  toFile: filename 	self subclassResponsibility</body><body package="COASTClient">hasBytesAtID: clusterIDInteger	self subclassResponsibility</body><body package="COASTClient">writeBytes: bytes blobID: blobIDInteger	self subclassResponsibility</body><body package="COASTClient">writeFile: file blobID: blobIDInteger	self subclassResponsibility</body></methods><methods><class-id>COAST.CacheAccessor</class-id> <category>accessing</category><body package="COASTClient">clusterManager	^ nil</body><body package="COASTClient">maxCacheSize: anInteger	" ignored "</body><body package="COASTClient">setReadOnly</body></methods><methods><class-id>COAST.CacheAccessor class</class-id> <category>instance creation</category><body package="COASTClient">fallBackCacheAccessorReason: aString	CoastLog logError: 'Caching not possible: ', aString.	^CacheDisabledAccessor new</body></methods><methods><class-id>COAST.LocalCacheAccessor</class-id> <category>interface</category><body package="COASTClient">basicWriteBackCluster: clusterController 	| writeStream cluster |	cluster := clusterController clusterStub.	writeStream := storageAccessor writeStreamOnCluster: cluster id.	[	clusterController saveClusterOn: writeStream marshaller: clusterController clusterManager loadSaveMarshaller	] valueNowOrOnUnwindDo: [ writeStream close ].</body><body package="COASTClient">closeCache	self readOnly ifFalse: [ storageAccessor removeClustersByAge: self expireAge andSize: self maxCacheSize ].	storageAccessor releaseVolumeAccess.	CoastLog log: 'disk cache closed'.</body><body package="COASTClient">clusterFromCacheHitMessage: cacheHitMessage	| cluster marshaller |	marshaller := cacheHitMessage marshallerForCachedCluster.	cluster := marshaller loadCluster: cacheHitMessage clusterLocator id fromStore: storageAccessor.	marshaller clusterController cluster: cluster.	cluster clusterController globalSeqNum: cluster modificationNumber.	CoastLog logDebug: [ 'Cache hit: ', cluster clusterID printString ] channel: #coastCache.	^cluster</body><body package="COASTClient">clusterFromCacheMissMessage: cacheMissMessage 	" now is the best moment to save the cluster: this is the last chance to get the bytes directly,	later we would need to marshall the cluster "	self readOnly ifFalse: [ storageAccessor importCluster: cacheMissMessage clusterID fromBytes: cacheMissMessage byteArray ].	CoastLog logDebug: [ 'Cache miss: ' , cacheMissMessage clusterID printString ] channel: #coastCache.</body><body package="COASTClient">emergencyCloseCache	" shutdown the cache as fast as possible. make sure that the cache remains valid after shutdown "	CoastLog log: 'Emergency close cache. Deleting all clusters in cache'.	storageAccessor emergencyRemoveAllClusters 		ifTrue: 		[	storageAccessor releaseVolumeAccess.			CoastLog log: 'cache deleted'		]		ifFalse: [ CoastLog logError: 'Failed deleting all clusters in cache' ]</body><body package="COASTClient">invalidateAccessFor: clusterIDInteger	storageAccessor deleteCluster: clusterIDInteger</body><body package="COASTClient">modificationNumberFor: clusterIDInteger 	| newCluster num readStream |	num := 0.	[	readStream := storageAccessor readStreamOnCluster: clusterIDInteger.		readStream notNil ifTrue: 			[	newCluster :=					[ CatCSCluster loadHeaderFromStream: readStream marshaller: CatMAMarshallBinary new ] ensure: [ readStream close ].				( newCluster notNil and: [ newCluster modificationNumber notNil ]) ifTrue: [ num := newCluster modificationNumber ]			]	] on: Error		do: 		[: ex |			num := 0.			ex return		].	^ num</body><body package="COASTClient">saveAllClustersFor: aClusterControllerCollection 	aClusterControllerCollection do: [: cc | self writeBackClusterController: cc ].	aClusterControllerCollection do: [: cc | cc clusterStub valueHolder: nil ].</body><body package="COASTClient">shouldWriteBackClusterController: clusterController	^ (super shouldWriteBackClusterController: clusterController)		and: [ | cluster |			cluster := clusterController clusterStub.			(self modificationNumberFor: cluster id) ~= cluster modificationNumber		]</body></methods><methods><class-id>COAST.LocalCacheAccessor</class-id> <category>interface - blobs</category><body package="COASTClient">bytesAtID: clusterIDInteger	^storageAccessor bytesFor: clusterIDInteger</body><body package="COASTClient">copyBytesAtID: clusterIDInteger  toFile: filename 	| targetStream |	targetStream := filename asFilename writeStream binary.	[		storageAccessor transferBlobData: clusterIDInteger to: targetStream.	] ensure: [ targetStream close ].	^nil</body><body package="COASTClient">hasBytesAtID: clusterIDInteger	^storageAccessor blobExists: clusterIDInteger</body><body package="COASTClient">writeBytes: bytes blobID: blobIDInteger	storageAccessor importBlob: blobIDInteger fromBytes: bytes</body><body package="COASTClient">writeFile: file blobID: blobIDInteger	storageAccessor importBlob: blobIDInteger fromFile: file</body></methods><methods><class-id>COAST.LocalCacheAccessor</class-id> <category>accessing</category><body package="COASTClient">clusterManager	^ storageAccessor notNil 		ifTrue: [ storageAccessor clusterManager ]		ifFalse: [ nil ]</body><body package="COASTClient">expireAge	expireAge isNil ifTrue:[expireAge := (60*60*24*7*10)].		"ten weeks"	^expireAge</body><body package="COASTClient">expireAge: someSeconds	expireAge := someSeconds.</body><body package="COASTClient">maxCacheSize	maxCacheSize isNil ifTrue:[ maxCacheSize := 5*1024*1024]	"5 MByte".	^maxCacheSize</body><body package="COASTClient">maxCacheSize: someBytes	maxCacheSize := someBytes</body><body package="COASTClient">readOnly	"not readOnly by default"	^false</body><body package="COASTClient">storageAccessor: sa 	storageAccessor := sa.	storageAccessor cacheAccessor: self.</body></methods><methods><class-id>COAST.LocalCacheAccessor class</class-id> <category>instance creation</category><body package="COASTClient">directory: directory clusterManager: clusterManager 	^ self directory: directory		clusterManager: clusterManager		onError: [ : ex | self fallBackCacheAccessorReason: ex description ]</body><body package="COASTClient">directory: directory clusterManager: clusterManager onError: errorBlock 	| uniqueVolumeID sa ownDirectory lsi |	uniqueVolumeID := clusterManager uniqueVolumeID.	ownDirectory := directory construct: clusterManager volume.	ownDirectory ensureFullDirectory.	[ sa := CatCSVolumeManager defaultStorageClass storageAccessorClass cachingDirectory: ownDirectory ] on: CoastError		do: [: ex | ^ errorBlock value: ex ].	sa uniqueVolumeID = uniqueVolumeID 		ifTrue: [ sa quickCheckForCache ]		ifFalse: 		[	sa uniqueVolumeID notNil ifTrue: [ CoastLog log: 'cache reset ' , clusterManager volume , ' - old ID ' , sa uniqueVolumeID ].			sa removeAllClusters.			sa uniqueVolumeID: uniqueVolumeID		].	CoastLog log: 'cache open ' , clusterManager volume , ' as ' , uniqueVolumeID.	lsi := LocalStorageInterface onAccessor: sa.	lsi clusterManager: clusterManager.	^ self storageAccessor: lsi</body><body package="COASTClient">storageAccessor: accessor 	^(self new)		storageAccessor: accessor; 		yourself</body></methods><methods><class-id>COAST.FramePagingCacheAccessor</class-id> <category>interface</category><body package="COASTClient">basicWriteBackCluster: clusterController 	storageAccessor basicWriteBackCluster: clusterController</body><body package="COASTClient">clusterFromCacheHitMessage: cacheHitMessage	self setFilenameFor: cacheHitMessage.	^ super clusterFromCacheHitMessage: cacheHitMessage.</body><body package="COASTClient">clusterFromCacheMissMessage: cacheMissMessage	super clusterFromCacheMissMessage: cacheMissMessage.	self setFilenameFor: cacheMissMessage.</body><body package="COASTClient">invalidateAccessFor: clusterIDInteger	(self clusterManager isClusterLoaded: clusterIDInteger)		ifFalse: [ super invalidateAccessFor: clusterIDInteger ]</body><body package="COASTClient">shouldWriteBackClusterController: clusterController	^ self readOnly not and: [ super shouldWriteBackClusterController: clusterController ]</body></methods><methods><class-id>COAST.FramePagingCacheAccessor</class-id> <category>private</category><body package="COASTClient">setFilenameFor: clusterMessage	| filename |	filename := storageAccessor filenameForClusterID: clusterMessage clusterID.	filename notNil ifTrue: [ clusterMessage clusterController byteArrayFilename: filename ].</body></methods><methods><class-id>COAST.FramePagingCacheAccessor</class-id> <category>accessing</category><body package="COASTClient">readOnly	"not readOnly by default"	^ readOnly == true</body><body package="COASTClient">readOnly: aReadOnly 	readOnly := aReadOnly.</body><body package="COASTClient">setReadOnly	readOnly := true</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>testing</category><body package="COASTClient">&lt;= anotherComponentAppModel	^self domainModel &lt;= anotherComponentAppModel domainModel</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>accessing</category><body package="COASTClient">addComponent: aComponentApplicationModel	^self at: #components add: aComponentApplicationModel</body><body package="COASTClient">components	^self isLocal 		ifTrue: [self at: #computedComponents]		ifFalse: [self at: #components]</body><body package="COASTClient">domainModel	^self at: #domainModel</body><body package="COASTClient">domainModel: aModel	self at: #domainModel set: aModel</body><body package="COASTClient">editorReuseKey	" association editor symbol -&gt; domain model oder nil 	wenn editor symbol und domain model nicht nil und gleich sind, sind die beiden editoren 'gleich' bezÃ¼glich wiederverwendung "	^ self class fullName asSymbol -&gt; self domainModel</body><body package="COASTClient">interestedUsers	^self at: #interestedUsers</body><body package="COASTClient">localUser	^self transactionManager localUser</body><body package="COASTClient">parent	^self at: #parent</body><body package="COASTClient">parent: anApplicationModel	self at: #parent set: anApplicationModel</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>adaption</category><body package="COASTClient">addComponentForDomainModel: aDomainModel	"do nothing by default"</body><body package="COASTClient">removeComponentForDomainModel: aDomainModel 	"try to remove the corresponding application model, ignore if already removed"	| appModel |	appModel := self componentForDomainModel: aDomainModel.	appModel isNil ifFalse: [self at: #components remove: appModel]</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>open - close</category><body package="COASTClient">closeFor: aCoastUser 	self at: #interestedUsers remove: (self isLocal		ifTrue: [aCoastUser localCopy]		ifFalse: [aCoastUser sharedCopy])</body><body package="COASTClient">closeForAll	self depleteSlot: #interestedUsers.</body><body package="COASTClient">closeForAll: someCoastUsers 	someCoastUsers do: [:u| self closeFor: u].</body><body package="COASTClient">openFor: aUser 	^ self openFor: aUser reuse: self reuseExistingWindow</body><body package="COASTClient">openFor: aUser reuse: reuse 	| reusedApp |	reusedApp := reuse 			ifTrue: [ aUser bringReuseableAppToTop: self ]			ifFalse: [ nil ].	^ reusedApp notNil 		ifTrue: [ reusedApp ]		ifFalse: 		[	self at: #interestedUsers add: ( self sharedOrLocalUserFrom: aUser ).			self		]</body><body package="COASTClient">openForAll: someCoastUsers 	someCoastUsers do: [:u| self openFor: u].</body><body package="COASTClient">reuseExistingWindow	^ true</body><body package="COASTClient">sharedOrLocalUserFrom: aCoastUser 	^self isLocal 		ifTrue: [aCoastUser localCopy]		ifFalse: [aCoastUser sharedCopy]</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>private adaption</category><body package="COASTClient">actualDomainModels	^ ( self at: #observedComponentsSlot ) notNil 		ifTrue: [( self domainModel at: ( self at: #observedComponentsSlot )) coastAsSet ]		ifFalse: [ Set new ]</body><body package="COASTClient">adaptToSlot: slotname 	"adapt the #components slot to the given slot in the domain model.	i.e. the components slot in the app model and the given slot in the domain model	will be kept isomorphic (one sub-application model for each sub-domain model)"	self at: #observedComponentsSlot set: slotname.</body><body package="COASTClient">computeComponents	(self prototype slotNamed: #components) isVirtual 		ifFalse: [self recomputeComponents].	^self at: #components</body><body package="COASTClient">notifyOfAccess: anAccess frame: frame slot: slotName 	"an access to an observed frame/slot has occurred"	super		notifyOfAccess: anAccess		frame: frame		slot: slotName.	(frame = self domainModel and: [slotName = (self at: #observedComponentsSlot)])		ifTrue: 		[ | differences |			anAccess isWriteAccess ifTrue: [				differences := anAccess differences.				differences removed do: [:somethingRemoved |					self removeComponentForDomainModel: somethingRemoved].				differences added do: [:somethingAdded |					self addComponentForDomainModel: somethingAdded].						]		]</body><body package="COASTClient">recomputeComponents	"create the application models for missing domain model components and remove 	application models that are no longer needed"	| knownDomainModels actualDomainModels toBeCreated toBeRemoved |	knownDomainModels := (( self at: #components ) collect: [: e | e domainModel ]) coastAsSet.	actualDomainModels := self actualDomainModels.	toBeCreated := actualDomainModels - knownDomainModels.	toBeRemoved := knownDomainModels - actualDomainModels.	toBeRemoved do: [: tooMuch | self removeComponentForDomainModel: tooMuch ].	toBeCreated do: [: toDo | self addComponentForDomainModel: toDo ]</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>domain model</category><body package="COASTClient">componentForDomainModel: aDomainModel 	^(self at: #components)		detect: [:am | am domainModel == aDomainModel]		ifNone: [nil]</body><body package="COASTClient">domainModelChanged	"this method will be envoked whenever the domain model changes"	"subclasses may override this method to initialize/release subapplication models"	"if my components should be in sync to the domain model, add an adapter here"	(self domainModel notNil and: [ (self at: #observedComponentsSlot) notNil ])		ifTrue: [ self adaptToSlot: (self at: #observedComponentsSlot) ].</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>announcements - private</category><body package="COASTClient">createSubscriptionRegistry	^WeakSubscriptionRegistry new</body><body package="COASTClient">releaseObservers	super releaseObservers.	subscriptionRegistry notNil 		ifTrue: 		[	subscriptionRegistry release.			subscriptionRegistry := nil		].</body><body package="COASTClient">subscriptionRegistry: aSubscriptionRegistry	subscriptionRegistry := aSubscriptionRegistry</body><body package="COASTClient">subscriptionRegistryOrNil	^subscriptionRegistry</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>copying</category><body package="COASTClient">postCopy	super postCopy.	subscriptionRegistry := nil</body></methods><methods><class-id>COAST.CoastApplicationModel class</class-id> <category>slot description</category><body package="COASTClient">componentsSlot	^(self slotOfType: #set)		range: CoastApplicationModel;		invertsTo: #parent; yourself</body><body package="COASTClient">computedComponentsSlot	^(self slotComputedBy: #computeComponents)		yourself</body><body package="COASTClient">domainModelSlot	^(self slotSingleValue) afterWrite: [:demon :slotAccess :slot | slot frame domainModelChanged]		named: #domainModelChangeDemon; yourself</body><body package="COASTClient">interestedUsersSlot	"users having an open browser on the model"	^(self slotOfType: #set)		range: CoastUser;		invertsTo: #interests; yourself</body><body package="COASTClient">observedComponentsSlotSlot	^(self slotOfType: #singleValue)		range: Symbol; yourself</body><body package="COASTClient">parentSlot	^(self slotSingleValue)		range: CoastApplicationModel;		invertsTo: #components; yourself</body></methods><methods><class-id>COAST.CoastApplicationModel class</class-id> <category>instance creation</category><body package="COASTClient">domainModel: aModel 	^self domainModel: aModel parent: nil</body><body package="COASTClient">domainModel: aModel parent: anApplicationModel 	| newInst |	newInst := anApplicationModel notNil 			ifTrue: [ self newColocatedTo: anApplicationModel ]			ifFalse: [ self new ].	^ newInst		domainModel: aModel;		parent: anApplicationModel;		yourself</body><body package="COASTClient">domainModel: aModel parent: anApplicationModel onSlot: slotname 	"create a new instance on the given domain model with the given parent 	that adapts itself to the given slot in the domain model. 	i.e. the components slot in the app model and the given slot in the domain model 	will be kept isomorphic (one sub-application model for each sub-domain model)"	| appModel |	appModel := aModel cluster isNil		ifTrue: [ self new ]		ifFalse: [ self newInCluster: aModel cluster ].	appModel		at: #observedComponentsSlot set: slotname; 		domainModel: aModel; 		parent: anApplicationModel.	^ appModel</body><body package="COASTClient">localOnDomainModel: aCoastModel	^ (self newLocal)		domainModel: aCoastModel;		yourself</body></methods><methods><class-id>COAST.CoastPerformanceCounterNode</class-id> <category>printing</category><body package="COASTClient">logOn: aStream 	self logOn: aStream indent: 0</body><body package="COASTClient">logOn: aStream duration: duration indent: indent 	self subclassResponsibility.</body><body package="COASTClient">logOn: aStream indent: indent 	self logOn: aStream duration: nil indent: indent</body><body package="COASTClient">streamContents: aBlock	| stream |	stream := String new writeStream.	aBlock value: stream.	^ stream contents</body></methods><methods><class-id>COAST.CoastPerformanceCounterNode</class-id> <category>accessing</category><body package="COASTClient">counterAtPath: aCollectionOfKeys 	" Liefert das Counter-Objekt "	^ self counterAtPath: aCollectionOfKeys index: 1</body><body package="COASTClient">counterAtPath: aCollectionOfKeys add: anInteger unit: aUnitSymbol 	" Counter erhÃ¶hen. Liefert das Counter-Objekt "	| counter |	counter := self ensureCounterAtPath: aCollectionOfKeys unit: aUnitSymbol.	counter addQuantity: anInteger unit: aUnitSymbol.</body><body package="COASTClient">ensureCounterAtPath: aCollectionOfKeys unit: aUnitSymbol 	" Liefert ein Counter-Objekt. Wird angelegt wenn noch nicht vorhanden "	^ self ensureCounterAtPath: aCollectionOfKeys index: 1 unit: aUnitSymbol</body></methods><methods><class-id>COAST.CoastPerformanceCounterNode</class-id> <category>private</category><body package="COASTClient">clusterManager	^ self parentNode clusterManager</body><body package="COASTClient">counterAtPath: aCollectionOfKeys index: index	" Liefert das Counter-Objekt "	self subclassResponsibility</body><body package="COASTClient">ensureCounterAtPath: aCollectionOfKeys index: index unit: aUnitSymbol 	" Liefert ein Counter-Objekt. Wird angelegt wenn noch nicht vorhanden "	self subclassResponsibility</body><body package="COASTClient">parentNode	^ parentNode</body><body package="COASTClient">parentNode: aCounterNode	parentNode := aCounterNode.</body><body package="COASTClient">printKey: aKey on: aStream 	| frame |	aKey isFrameOrFrameReference 		ifTrue: 		[	frame := self clusterManager resolveFrameReference: aKey.			frame notNil 				ifTrue: [ frame deleteContextDisplayStringOn: aStream ]				ifFalse: 				[	aStream						print: aKey;						nextPutAll: '('; nextPutAll: ( #deletedMLS &lt;&lt; #mls &gt;&gt; 'deleted' ) asString; nextPutAll: ')'				]		]		ifFalse: [ aStream nextPutAll: aKey asString ].</body></methods><methods><class-id>COAST.CoastPerformanceCounterNode</class-id> <category>initialize-release</category><body package="COASTClient">initialize</body></methods><methods><class-id>COAST.CoastPerformanceCounterNode class</class-id> <category>instance creation</category><body package="COASTClient">new	^ super new initialize</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>mediator services</category><body package="COASTClient">availableVolumes	^ self volumesAtHost: self defaultHost</body><body package="COASTClient">blockUntilBackupIsDone: aVolume 	^ ( self hostForVolume: aVolume ) 		ifNotNil: [: hostname | CoastMediatorStub blockUntilBackupIsDoneVolume: aVolume atHost: hostname ]		ifNil: [ super blockUntilBackupIsDone: aVolume ]</body><body package="COASTClient">connectionsAtHost: hostname 	"contact host and retrieve all available volumes, answer a set of 	ip-addresses"	| reply |	reply := self requestService: CatRMConnectionsRequest new atHost: hostname.	^reply isNil		ifTrue: [Set new]		ifFalse: [reply connections ]</body><body package="COASTClient">recoverableVolumesAtHost: hostname 	"contact host and retrieve all available recoverable volumes, answer a dictionary of volumenames -&gt; timetamps (as ms)"	^ hostname isNil 		ifTrue: [ self volumeInterface recoverableVolumes ]		ifFalse: [( self class recoverableVolumesAtHost: hostname ) ifNil: [ Dictionary new ]]</body><body package="COASTClient">transmitMessage: msg	self broadcastMessage: msg atHost: self defaultHost</body><body package="COASTClient">volumeExists: aVolume 	" returns true if the volume exists "	^ self volumeExists: aVolume atHost: self defaultHost</body><body package="COASTClient">volumeExists: aVolume atHost: aHostname 	" returns true if the volume exists "	^ aHostname isNil 		ifTrue: [ self volumeInterface volumeExists: aVolume ]		ifFalse: [ CoastMediatorStub volumeExists: aVolume atHost: aHostname ]</body><body package="COASTClient">volumesAtHost: hostname password: password 	"contact host and retrieve all available volumes, 	answer a set of volumenames"	^ hostname isNil 		ifTrue: [ self volumeInterface storedVolumes ]		ifFalse: [ CoastMediatorStub volumesAtHost: hostname password: password ]</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>volume management</category><body package="COASTClient">bindVolume: volumename toHost: hostname 	^self clusterManagerForVolume: volumename host: hostname</body><body package="COASTClient">defaultHost	^defaultHost</body><body package="COASTClient">defaultHost: aHostName	defaultHost := aHostName</body><body package="COASTClient">hostForVolume: aVolume 	^(clusterManagers at: aVolume ifAbsent: [ ^self defaultHost ]) host</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>accessing</category><body package="COASTClient">addToPersistentClientID: aByteArray 	persistentClientID notNil 		ifTrue: [ self generatePersistentClientIDUsing: self persistentClientID , aByteArray ]		ifFalse: [ self generatePersistentClientIDUsing: aByteArray ].</body><body package="COASTClient">clientDescription	" Return a dictionary with string keys and coast primitive values that describes the client	the description will be transmitted to the mediator at client connection time "	clientDescription isNil 		ifTrue: [ clientDescription := self applicationDescription ].	^ clientDescription</body><body package="COASTClient">clientID	| ps |	self defaultHost isNil		ifTrue: [ ^ nil ].	ps := self packetStationForHost: self defaultHost.	^ ps notNil		ifTrue: [ ps clientID ]		ifFalse: [ nil ].</body><body package="COASTClient">clusterManagerClass	^CoastClientClusterManager</body><body package="COASTClient">clusterManagerForVolume: aVolume host: aHost 	^ self clusterManagerForVolume: aVolume ifAbsent: [ self newClusterManagerForVolume: aVolume host: aHost ]</body><body package="COASTClient">connectionLostBlock: aBlock	"allows to set a block which will be executed after the	connection to the mediator was lost unexpectedly"	connectionLostBlock := aBlock</body><body package="COASTClient">createClusterManagerForHost: aHost 	| newClusterManager |	( aHost notNil and: [ aHost isEmpty not ]) 		ifTrue: 		[	newClusterManager := CoastClientClusterManager new.			newClusterManager host: aHost		]		ifFalse: [ newClusterManager := CoastLocalClientClusterManager new ].	^ newClusterManager</body><body package="COASTClient">defaultUnloadStrategy	^defaultUnloadStrategy</body><body package="COASTClient">defaultUnloadStrategy: anUnloadStrategy	defaultUnloadStrategy := anUnloadStrategy.</body><body package="COASTClient">generatePersistentClientIDUsing: aByteArray 	"always return 16 bytes using MD5 on &gt;a lot of parameters&lt;"	| bstr |	bstr := ( ByteArray new: 64 ) writeStream.	bstr nextPutAll: IPSocketAddress thisHostFullAddressOrRandom.	bstr nextPutAll: Filename defaultDirectoryName asByteArray.	self defaultHost ifNotNil: [: dh | bstr nextPutAll: dh asByteArray ].	OSSystemSupport concreteClass new coastSystemUserName ifNotNil: [: username | bstr nextPutAll: username asByteArray ].	CEnvironment commandLine do: [: para | bstr nextPutAll: para asByteArray ].	bstr nextPutAll: aByteArray.	^ persistentClientID := Security.MD5 hash: bstr contents</body><body package="COASTClient">generateUniquePersistentClientID	^ self generatePersistentClientIDUsing: ( Time microsecondClock printString , Random new next printString, UUID next printString ) asByteArray</body><body package="COASTClient">logCoastClientId	self packetStations do: [: ps | 		CoastLog log: [ 'coast-client: id=' , ps clientIDString , ', port=' , ps socketAccessor getName port printString ]	].</body><body package="COASTClient">newClusterManagerForVolume: aVolume	^ self newClusterManagerForVolume: aVolume host: self defaultHost</body><body package="COASTClient">newClusterManagerForVolume: aVolume host: aHost 	| newClusterManager |	self class checkVolumeName: aVolume.	newClusterManager := self createClusterManagerForHost: aHost.	self initializeClusterManager: newClusterManager forVolume: aVolume.	self registerClusterManager: newClusterManager volume: aVolume.	^ newClusterManager</body><body package="COASTClient">persistentClientID	^ persistentClientID ifNil: [ self generatePersistentClientIDUsing: #[] ]</body><body package="COASTClient">reconnectAttempts	^ reconnectAttempts ifNil: [ 10 ]</body><body package="COASTClient">reconnectAttempts: anInteger	reconnectAttempts := anInteger</body><body package="COASTClient">requestTimeout	" number of seconds to wait for answers to syncr. requests. when	no answer is received, the client assumes that the connection is dead "	^ requestTimeout</body><body package="COASTClient">requestTimeout: numberOfSeconds	" number of seconds to wait for answers to syncr. requests. when	no answer is received, the client assumes that the connection is dead "	requestTimeout := numberOfSeconds</body><body package="COASTClient">sizeOfBlobOrCluster: clusterID in: volume 	| hostname |	hostname := self hostForVolume: volume.	^ hostname isNil 		ifTrue: [ super sizeOfBlobOrCluster: clusterID in: volume ]		ifFalse: [ CoastMediatorStub sizeOfBlobOrCluster: clusterID in: volume atHost: hostname ]</body><body package="COASTClient">transactionManager	^transactionManager</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>GC</category><body package="COASTClient">collectGarbageInVolume: aVolume	" currently local use only "	self exclusiveUseDo: [		(self clusterManagerForVolume: aVolume) collectGarbage	].</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>packet stations</category><body package="COASTClient">connectPacketStationTo: hostAndPort 	"Connect to mediator"	| hostToPortAssoc host port newPacketStation |	hostToPortAssoc := SocketAccessor defaultClass hostnameAndPortNumFrom: hostAndPort.	host := hostToPortAssoc key.	port := hostToPortAssoc value ifNil: [ self class defaultServerPort ].	[	| class |		class := self class clientPacketStationClass.		newPacketStation := class connectedToServerAtHost: host port: port volumeManager: self	] on: OsError		do: 		[: ex |			ex 				resignalAs: ( CoastError new messageText: 'connection to ' , host , ':' , port printString , ' can not be established' )		].	newPacketStation isNil 		ifTrue: [( CoastError new messageText: 'connection to ' , hostAndPort , ' can not be established' ) raiseSignal ]		ifFalse: [ packetStations at: hostAndPort put: newPacketStation ].	^ newPacketStation</body><body package="COASTClient">ensurePacketStationForHost: hostname	^packetStations at: hostname ifAbsent: [ self connectPacketStationTo: hostname ].</body><body package="COASTClient">notifyConnectionLost	| semOrNil |	connectionLostBlock notNil 		ifTrue: 		[	connectionLostBlock numArgs = 0 				ifTrue: 				[						[	Processor yield.						connectionLostBlock value					] fork				]				ifFalse: 				[	semOrNil := Semaphore new.					[	Processor yield.						connectionLostBlock value: semOrNil					] fork.					" wait until the connection lost block was evaluated "					semOrNil wait				]		].</body><body package="COASTClient">stationIrreversibleLostConnection: aStation 	"this means that we have somehow lost the connection,	either intended (shutdown) or not intended (socket error etc.) "	| oldQueue |	aStation isInShutdown 		ifTrue: 		[	" no need to ring the alarm bells, the station is within a controlled shutdown "			^ self		].	oldQueue := responseQueue.	self reInitialize.	self notifyConnectionLost.	packetStations removeKey: ( packetStations keyAtValue: aStation ifAbsent: [ nil ]) ifAbsent: [ nil ].	[	exclusiveLock interruptOrTerminateOwnerWith: CatRMMediatorLostError.		oldQueue nextPut: ( CatRMErrorMessage description: 'Station lost connection' ).		CatRMMediatorLostError raiseSignal	] on: UnhandledException do: [: ex | ex return	"nobody was waiting for the signal" ].</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>exclusive use</category><body package="COASTClient">criticalNow: aBlock unblockedDo: bBlock 	^ exclusiveLock criticalNow: aBlock unblockedDo: bBlock</body><body package="COASTClient">exclusiveAndInterruptProtectDo: block  	^ self exclusiveUseDo: [ self interruptProtectDo: block ]</body><body package="COASTClient">exclusiveLockBlocksAnyProcess	^ exclusiveLock exclusiveLockBlocksAnyProcess</body><body package="COASTClient">interruptProtectDo: aBlock	^interruptProtect critical: aBlock</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>mediator services private</category><body package="COASTClient">broadcastMessage: msg atHost: hostname 	self exclusiveUseDo:	[ | packetStation |		packetStation := self ensurePacketStationForHost: hostname.		(packetStation notNil and: [ packetStation connected ])			ifTrue:			[				[ packetStation transmitMessage: msg ]					on: CoastConnectionLostError 					do: [ :ex | CoastLog logError: ex description; cr].			]	]</body><body package="COASTClient">requestService: aCatRMRequestMessage atHost: hostname 	"send &lt;aCatRMRequestMessage&gt; using the appropriate packet station and return the reply message"	| result |	result := self exclusiveUseDo:	[ | packetStation |		packetStation := self ensurePacketStationForHost: hostname.		packetStation notNil			ifTrue: [ self requestService: aCatRMRequestMessage usingPacketStation: packetStation ]			ifFalse: [ nil ]	].	(result notNil and: [result isError])		ifTrue: [ CoastError raiseSignal: result fullDescription ].	^result</body><body package="COASTClient">requestService: aCatRMRequestMessage usingPacketStation: aCatRMClientPacketStation 	"send &lt;aCatRMRequestMessage&gt; and return the reply message"	| success |	success := false.	^ self exclusiveAndInterruptProtectDo: 		[ | reply |			reply := nil.			( aCatRMClientPacketStation notNil and: [ aCatRMClientPacketStation connected ]) 				ifTrue: 				[	responseQueue isEmpty 						ifFalse: [ CoastError raiseSignal: 'Response queue out of sync' ].					aCatRMClientPacketStation transmitMessage: aCatRMRequestMessage.					success :=						[ reply := responseQueue next ] coastValueWithinSeconds: self requestTimeout.					success 						ifFalse: [ aCatRMClientPacketStation timeoutAfter: self requestTimeout whileWaitingFor: aCatRMRequestMessage ]				].			success 				ifTrue: [ reply ]				ifFalse: [ nil ]		]</body><body package="COASTClient">saveVolume: volumename atHost: hostname 	^self requestService: (CatRMVolumeSaveRequest volume: volumename)		atHost: hostname</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>initialize - release</category><body package="COASTClient">initialize	super initialize.	useProxyValueHolder := true.	self reInitialize.	defaultHost := nil.	requestTimeout := 1800.	defaultUnloadStrategy := nil.</body><body package="COASTClient">reInitialize	interruptProtect := RecursionLock new.	responseQueue := SharedQueue new.	transactionManager := self transactionManagerClass new.	transactionManager volumeManager: self</body><body package="COASTClient">shutDown	transactionManager shutDown.	super shutDown.	" in case that the volume manager is reused "	self reInitialize.</body><body package="COASTClient">shutDownKeepTM	"do not throw away the transaction manager"	self exclusiveUseDo:	[	[ self waitUntilSendQueueIsEmpty ] coastValueWithinMilliseconds: 1000 orDo: [ CoastLog log: 'Send queue is not empty, continuing shutdown anyway' ].		clusterManagers copy do: [ :cm | cm releaseAllClusters ].		self disconnectAllPacketStations.	].	volumeInterface notNil ifTrue: [ volumeInterface shutDown ].	currentLoadedClusterID changed: #shutDown.	interruptProtect := RecursionLock new.	responseQueue := SharedQueue new.</body><body package="COASTClient">transactionManagerClass	^ CoastTransactionManager</body><body package="COASTClient">useProxyValueHolder	^ useProxyValueHolder</body><body package="COASTClient">useProxyValueHolder: bool 	^ useProxyValueHolder := bool</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>messages</category><body package="COASTClient">handleMessage: aCatRMMessage 	| receiverClusterManager |	aCatRMMessage isResponse 		ifTrue: [ responseQueue nextPut: aCatRMMessage ]		ifFalse: 		[	receiverClusterManager := clusterManagers at: aCatRMMessage receiver volume ifAbsent: [ nil ].			receiverClusterManager notNil 				ifTrue: [ receiverClusterManager addToMessageQueue: aCatRMMessage ]				ifFalse: 				[	CoastLog log: 						[	'Received message ' , aCatRMMessage printString , ' for volume without cluster manager: ' , aCatRMMessage receiver volume						]				]		].</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>requests</category><body package="COASTClient">backupVolume: aVolume remotePassword:  remotePassword	^  ( self hostForVolume: aVolume )  		ifNotNil: [: hostname | CoastMediatorStub backupVolume: aVolume atHost: hostname remotePassword: remotePassword ]		ifNil: [ super backupVolume: aVolume remotePassword:  remotePassword]</body><body package="COASTClient">copyVolume: aVolume to: newName remotePassword: remotePassword 	^  ( self hostForVolume: aVolume )  		ifNotNil: [: hostname | CoastMediatorStub copyVolume: aVolume to: newName atHost: hostname remotePassword: remotePassword ]		ifNil: [ super copyVolume: aVolume to: newName remotePassword: remotePassword ]</body><body package="COASTClient">deleteBackup: backupVolume version: version remotePassword: remotePassword 	^  ( self hostForVolume: backupVolume )  		ifNotNil: [: hostname | CoastMediatorStub deleteBackup: backupVolume version: version atHost: hostname remotePassword: remotePassword  ]		ifNil: [ super deleteBackup: backupVolume version: version remotePassword: remotePassword ]</body><body package="COASTClient">deleteVolume: aVolume remotePassword: remotePassword 	^ ( self hostForVolume: aVolume ) 		ifNotNil: 		[: hostname | 			| currentClusterManager |			currentClusterManager := self clusterManagerForVolume: aVolume ifAbsent: [ nil ].			currentClusterManager notNil 				ifTrue: 				[	currentClusterManager releaseAllClusters;						shutDown				].			CoastMediatorStub deleteVolume: aVolume atHost: hostname remotePassword: remotePassword		]		ifNil: [ super deleteVolume: aVolume remotePassword: remotePassword ]</body><body package="COASTClient">recoverToVolume: targetVolume fromVolume: backupVolume version: version remotePassword: remotePassword 	^  self defaultHost		ifNotNil: [: hostname | CoastMediatorStub recoverToVolume: targetVolume fromVolume: backupVolume version: version atHost: hostname remotePassword: remotePassword  ]		ifNil: [ super recoverToVolume: targetVolume fromVolume: backupVolume version: version remotePassword: remotePassword ]</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>mediator services - deprecated</category><body package="COASTClient">volumesAtHost: hostname 	" compatibility - will be removed "	^ hostname isNil 		ifTrue: [ self volumeInterface storedVolumes ]		ifFalse: 		[ | reply |			reply := self requestService: CatRMVolumesRequest new atHost: hostname.			reply isNil 				ifTrue: [ Set new ]				ifFalse: [ reply volumes ]		]</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>naming service</category><body package="COASTClient">modelNamed: aString inExistingVolume: aVolume 	| host cm |	host := self hostForVolume: aVolume.	cm := self 			clusterManagerForVolume: aVolume			ifAbsent: 			[( self volumeExists: aVolume atHost: host ) 					ifTrue: [ self clusterManagerForVolume: aVolume host: host ]					ifFalse: [ nil ]			].	^ cm notNil 		ifTrue: [ cm modelNamed: aString ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>private</category><body package="COASTClient">initializeClusterManager: clusterManager forVolume: aVolume	[	super initializeClusterManager: clusterManager forVolume: aVolume.		clusterManager loadIndex.		clusterManager executeLastWishes.		defaultUnloadStrategy notNil ifTrue: 			[ | unloadStrategy |				unloadStrategy := defaultUnloadStrategy copy.				unloadStrategy clusterManager: clusterManager.				clusterManager unloadStrategy: unloadStrategy			]	] on: CoastError		do: 		[: coastError |			self removeClusterManager: aVolume.			coastError pass		].	^ clusterManager</body></methods><methods><class-id>COAST.CoastClientVolumeManager class</class-id> <category>accessing</category><body package="COASTClient">clientPacketStationClass	^  ClientPacketStationClass ifNil: [ CatRMClientPacketStation ]</body><body package="COASTClient">clientPacketStationClass: aClass	"self clientPacketStationClass: (CatRMClientPacketStationWithLatency latency: 22)"	"self clientPacketStationClass: nil"	 ClientPacketStationClass := aClass</body><body package="COASTClient">defaultServerPort	^defaultServerPort ifNil: [ CoastMediatorStub defaultServerPort ]</body><body package="COASTClient">defaultServerPort: anInteger	defaultServerPort := anInteger</body></methods><methods><class-id>COAST.CoastClientVolumeManager class</class-id> <category>mediator services</category><body package="COASTClient">buildInformationAtHost: hostname 	"COAST.CoastClientVolumeManager buildInformationAtHost: 'localhost' "	| buildInfo |	buildInfo := Dictionary new.	CoastMediatorStub 		sendTo: hostname		requestID: CoastConstant buildInfoID		andStrings: Array new		receiveStreamDo: 		[: receiveStream | | marshaller statusResponse  |			marshaller := CatMAMarshallBinary new.			statusResponse := CoastStatusResponse fromStream: receiveStream.			statusResponse ok ifFalse: [ CoastError raiseSignal: statusResponse message ].			receiveStream nextOptimized32 timesRepeat: 				[ | key value |					key := marshaller unmarshallValueFrom: receiveStream morph: nil.					value := marshaller unmarshallValueFrom: receiveStream morph: nil.					buildInfo at: key put: value				]		].	^ buildInfo</body><body package="COASTClient">coastVersionAtHost: hostname 	"COAST.CoastClientVolumeManager coastVersionAtHost: 'localhost' "	^ hostname isNil 		ifTrue: [ CoastVersion defaultCoastVersion ]		ifFalse: [ CoastMediatorStub versionAtHost: hostname ]</body></methods><methods><class-id>COAST.CoastClientVolumeManager class</class-id> <category>volume services</category><body package="COASTClient">backupVolume: aVolume atHost: hostname remotePassword: remotePassword 	| vm |	^ hostname isNil 		ifTrue: 		[	vm := self new.			[ vm backupVolume: aVolume  ] ensure: [ vm shutDown ].		]		ifFalse: 		[	CoastMediatorStub backupVolume: aVolume atHost: hostname remotePassword: remotePassword 		]</body><body package="COASTClient">blockUntilBackupIsDoneVolume: aVolume atHost: hostname 	| vm |	^ hostname isNil 		ifTrue: 		[	vm := self new.			[ vm blockUntilBackupIsDone: aVolume   ] ensure: [ vm shutDown ].		]		ifFalse: 		[	CoastMediatorStub blockUntilBackupIsDoneVolume: aVolume atHost: hostname 		]</body><body package="COASTClient">copyVolume: volumename to: newName atHost: hostname remotePassword: remotePassword 	| vm |	^ hostname isNil 		ifTrue: 		[	vm := self new.			[ vm copyVolume: volumename to: newName ] ensure: [ vm shutDown ].		]		ifFalse: 		[	CoastMediatorStub copyVolume: volumename to: newName atHost: hostname remotePassword: remotePassword 		]</body><body package="COASTClient">deleteBackup: backupVolume version: version atHost: hostname remotePassword: remotePassword 	| vm |	^ hostname isNil 		ifTrue: 		[	vm := self new.			[ vm deleteBackup: backupVolume version: version ] ensure: [ vm shutDown ]		]		ifFalse: 		[	CoastMediatorStub deleteBackup: backupVolume version: version atHost: hostname remotePassword: remotePassword 		]</body><body package="COASTClient">deleteVolume: volumename atHost: hostname remotePassword: remotePassword 	| vm |	^ hostname isNil 		ifTrue: 		[	vm := self new.			[ vm deleteVolume: volumename ] ensure: [ vm shutDown ]		]		ifFalse: 		[	CoastMediatorStub deleteVolume: volumename atHost: hostname remotePassword: remotePassword 		]</body><body package="COASTClient">downloadVolume: volumename fromHost: hostname toLocalVolume: localVolumename remotePassword: remotePassword 	" Download the volume.  returns a CoastStatusResponse "	| vm |	vm := self new.	^ [	( vm volumeExists: localVolumename atHost: nil ) 			ifTrue: [ CoastError raiseSignal: 'Volume already exists!' ].		CoastMediatorStub 			sendTo: hostname			requestID: CoastConstant downloadVolumeID			andStrings: ( Array with: remotePassword with: volumename )			receiveStreamDo: 			[: receiveStream | | statusResponse cm |				statusResponse := CoastStatusResponse fromStream: receiveStream.				statusResponse ok 					ifFalse: [ CoastError raiseSignal: statusResponse message ].				cm := vm newClusterManagerForVolume: localVolumename host: nil.				cm receiveVolumeFrom: receiveStream			]	] ensure: [ vm shutDown ]</body><body package="COASTClient">recoverToVolume: volumename fromVolume: backupVolume version: version atHost: hostname remotePassword: remotePassword 	| vm |	^ hostname isNil 		ifTrue: 		[	vm := self new.			[ vm recoverToVolume: volumename fromVolume: backupVolume version: version ] ensure: [ vm shutDown ]		]		ifFalse: 		[	CoastMediatorStub recoverToVolume: volumename fromVolume: backupVolume version: version atHost: hostname remotePassword: remotePassword		]</body><body package="COASTClient">recoverableVolumesAtHost: hostname 	"contact host and retrieve all available recoverable volumes, answer a dictionary of volumenames -&gt; timetamps (as ms)"	| vm |	^ hostname isNil 		ifTrue: 		[	vm := self new.			[ vm recoverableVolumes ] ensure: [ vm shutDown ]		]		ifFalse: [ CoastMediatorStub recoverableVolumesAtHost: hostname ]</body><body package="COASTClient">uploadVolume: volumename toHost: hostname toHostVolume: hostVolumename remotePassword: remotePassword 	| vm cm |	vm := self new.	^[	cm := vm newClusterManagerForVolume: volumename host: nil.		cm uploadVolumeToHost: hostname toHostVolume: hostVolumename remotePassword: remotePassword	] ensure: [ vm shutDown ].</body><body package="COASTClient">volumeExists: aVolume atHost: aHostname 	" returns true if the volume exists "	| vm |	^ aHostname isNil 		ifTrue: 		[	vm := self new.			[ vm volumeExists: aVolume atHost: nil ] ensure: [ vm shutDown ]		]		ifFalse: [ CoastMediatorStub volumeExists: aVolume atHost: aHostname ]</body><body package="COASTClient">volumesAtHost: hostname password: password	| vm |	^ hostname isNil 		ifTrue: 		[	vm := self new.			[ vm volumesAtHost: hostname password: password ] ensure: [ vm shutDown ]		]		ifFalse: [ CoastMediatorStub volumesAtHost: hostname password: password ]</body></methods><methods><class-id>COAST.CoastClientVolumeManager class</class-id> <category>volume services - deprecated</category><body package="COASTClient">volumesAtHost: hostname 	| vm |	^ hostname isNil 		ifTrue: 		[	vm := self new.			[ vm volumesAtHost: nil ] ensure: [ vm shutDown ]		]		ifFalse: [ CoastMediatorStub volumesAtHost: hostname ]</body></methods><methods><class-id>COAST.LogOnlyUnloadStrategy</class-id> <category>testing</category><body package="COASTClient">clusterUnloadNeeded	"never unload"	^false</body><body package="COASTClient">unloadRecommended	"never unload"	^false</body></methods><methods><class-id>COAST.CoastInterruptHandler</class-id> <category>handling</category><body package="COASTClient">forkedInterruptWith: aCatRMInterruptMessage volumeManager: aCoastClientVolumeManager cleanUpBlock: cleanUpBlock 	forkedInterrupt notNil 		ifTrue: [ ^ self ].	"already forked"	forkedInterrupt := Process 			forBlock: 			[	self interruptWith: aCatRMInterruptMessage volumeManager: aCoastClientVolumeManager.				cleanUpBlock value.				forkedInterrupt := nil			]			priority: Processor lowIOPriority.	forkedInterrupt resume.</body><body package="COASTClient">handleInterrupt: aCoastInterrupt	handlerBlock value: aCoastInterrupt</body><body package="COASTClient">interruptWith: aCatRMInterruptMessage volumeManager: aCoastClientVolumeManager 	( self handlesInterrupt: aCatRMInterruptMessage ) 		ifTrue: 		[						processToInterrupt interruptWith: 						[								[ CoastInterrupt raiseWithInterruptMessage: aCatRMInterruptMessage handler: self ] 								on: UnhandledException								do: 								[: ex |									[ CoastLog logException: ex message: 'Interrupt not handled' ] fork.									ex resume								]						]		]</body></methods><methods><class-id>COAST.CoastInterruptHandler</class-id> <category>accessing</category><body package="COASTClient">addTarget: aTarget 	targets add: aTarget.</body><body package="COASTClient">handlerBlock	^handlerBlock</body><body package="COASTClient">handlerBlock: anObject	handlerBlock := anObject</body><body package="COASTClient">processToInterrupt	^processToInterrupt</body><body package="COASTClient">processToInterrupt: anObject	processToInterrupt := anObject</body><body package="COASTClient">target	^ targets singleElement</body><body package="COASTClient">target: aString 	targets := Set with: aString.</body><body package="COASTClient">targets: aSetOfStrings 	targets := aSetOfStrings.</body></methods><methods><class-id>COAST.CoastInterruptHandler</class-id> <category>testing</category><body package="COASTClient">handlesInterrupt: aCatRMInterruptMessage 	^ ( targets includes: aCatRMInterruptMessage target ) and: [ processToInterrupt notNil and: [ processToInterrupt isTerminated not ]]</body></methods><methods><class-id>COAST.CoastInterruptHandler</class-id> <category>initialize-release</category><body package="COASTClient">initialize	targets := Set new.</body></methods><methods><class-id>COAST.CoastInterruptHandler class</class-id> <category>instance creation</category><body package="COASTClient">new	^ super new initialize</body><body package="COASTClient">targets: targetStrings handlerBlock: aBlock processToInterrupt: aProcess 	^ ( self new )		targets: targetStrings;		handlerBlock: aBlock;		processToInterrupt: aProcess;		yourself</body></methods><methods><class-id>COAST.CoastClientConfiguration</class-id> <category>private</category><body package="COASTClient">configureUnloadStrategy: unloadStrategy 	unloadStrategy		keepSize: self keepSize;		unloadSize: self unloadSize;		minAge: self minAge;		unloadInterval: self unloadInterval;		maxUnloadTime: self maxUnloadTime;		maxMemory: self unloadMaxMemory</body><body package="COASTClient">unloadMaxMemory	^ (ObjectMemory currentMemoryPolicy growthRegimeUpperBound * 0.8) rounded</body></methods><methods><class-id>COAST.CoastClientConfiguration</class-id> <category>config</category><body package="COASTClient">configure: client 	| time volumeInterface criticalLoadTimeLimit |	super configure: client.	( volumeInterface := client volumeInterface ) notNil 		ifTrue: [ volumeInterface configuration: self ].	( time := self autoSaveTimeInterval ) notNil 		ifTrue: [ client volumeManager autoSaveTimeInterval: ( time max: 5 )].	( criticalLoadTimeLimit := self criticalLoadTimeLimit ) notNil 		ifTrue: [ CoastClientClusterManager criticalLoadTimeLimit: criticalLoadTimeLimit milliseconds ].	CatRMClientPacketStation connectTimeout: self connectTimeout.	self enableLowSpaceHandler 		ifTrue: [ client transactionManager enableLowSpaceHandler ].	self installRestartActionFor: client.</body><body package="COASTClient">createUnloadStrategyFor: clusterManager 	| unloadStrategy |	unloadStrategy := self createUnloadStrategyWithClass: self unloadStrategyClass.	unloadStrategy clusterManager: clusterManager;		keepClusterIDs: clusterManager clusterController keys.	clusterManager unloadStrategy: unloadStrategy.</body><body package="COASTClient">createUnloadStrategyWithClass: aClassOrNil	| unloadStrategyClass unloadStrategy |	unloadStrategyClass := aClassOrNil ifNotNil: [ : class | class ] ifNil: [ self unloadStrategyClass ].	unloadStrategy := unloadStrategyClass new.	self configureUnloadStrategy: unloadStrategy.	CoastLog log: 'unload strategy: ', unloadStrategyClass fullName asString.	unloadStrategy additionalInfoString ifNotNil: [ : string |		string notEmpty ifTrue: [			CoastLog logDebug: string channel: #unloadStrategy.			].		].	^ unloadStrategy</body><body package="COASTClient">installRestartActionFor: application 	| shutdownInterval shutdownTimeString restartTime now shutdownTime |	shutdownTimeString := self iniAccess stringAt: 'scheduleShutdown' ifAbsent: [ nil ].	restartTime := nil.	now := Time now.	shutdownInterval := shutdownTimeString notNil 			ifTrue: 			[	" keine Beachtung der ÃbergÃ¤nge von Sommerzeit/Winterzeit "				[ restartTime := Locale current readTimeFrom: shutdownTimeString readStream ] 					on: Error					do: 					[: ex |						CoastLog logWarning: 'Illegal restartTime, no shutdown scheduled (' , ex description , ')'.						^ self					].				now &lt; restartTime 					ifTrue: [ restartTime asSeconds - now asSeconds ]					ifFalse: [ 24 * 60 * 60 - ( now asSeconds - restartTime asSeconds )]			]			ifFalse: [ 				(self iniAccess numberAt: 'restartInterval' ifAbsent: [ nil ]) ifNotNil: [ : hours | hours * 60 * 60 ]			].	shutdownInterval notNil 		ifTrue: 		[				[	shutdownTime := Time fromSeconds: (now asSeconds + shutdownInterval) \\ ( 24 * 60 * 60).				CoastLog log: 'Shutdown scheduled at ', shutdownTime printString.				( Delay forSeconds: shutdownInterval  ) wait.				CoastLog log: 'Scheduled shutdown'.				application handleScheduledShutdown			] forkAt: Processor userInterruptPriority		].</body></methods><methods><class-id>COAST.CoastClientConfiguration</class-id> <category>parameters</category><body package="COASTClient">autoSaveTimeInterval	^ self iniAccess numberAt: 'autoSaveTimeInterval' ifAbsent: [ nil ]</body><body package="COASTClient">connectTimeout	^ self iniAccess numberAt: 'connectTimeout' ifAbsent: [ 8 ]</body><body package="COASTClient">criticalLoadTimeLimit	^ self iniAccess numberAt: 'clusterloadDurationLimit' ifAbsent: [ nil ]</body><body package="COASTClient">defaultKeepSize	^ 3500</body><body package="COASTClient">defaultMaxUnloadTime	^ nil</body><body package="COASTClient">defaultMinAge	^ 30</body><body package="COASTClient">defaultUnloadInterval	^ 10</body><body package="COASTClient">defaultUnloadSize	^ 4000</body><body package="COASTClient">defaultUnloadStrategyClass	^ MemoryBasedUnloadStrategy</body><body package="COASTClient">keepSize	^ self iniAccess numberAt: 'keepSize' ifAbsent: [ self defaultKeepSize ]</body><body package="COASTClient">maxUnloadTime	" max. time (milliseconds) for a single unload "	^ self iniAccess millisecondsAt: 'maxUnloadTime' ifAbsent: [ self defaultMaxUnloadTime ]</body><body package="COASTClient">minAge	^ self iniAccess numberAt: 'minAge' ifAbsent: [ self defaultMinAge ]</body><body package="COASTClient">unloadInterval	^ self iniAccess numberAt: 'unloadInterval' ifAbsent: [ self defaultUnloadInterval ]</body><body package="COASTClient">unloadSize	^ self iniAccess numberAt: 'unloadSize' ifAbsent: [ self defaultUnloadSize ]</body><body package="COASTClient">unloadStrategyClass	| shortName |	shortName := self iniAccess stringAt: 'unloadStrategy' ifAbsent: [ nil ].	^ shortName isNil 		ifTrue: [ self defaultUnloadStrategyClass ]		ifFalse: [ AbstractUnloadStrategy strategyNamed: shortName fallBack: self defaultUnloadStrategyClass ]</body></methods><methods><class-id>COAST.UnresolvedFramesDictionary</class-id> <category>accessing</category><body package="COASTClient">atClusterID: clusterID put: frame 	self subclassResponsibility</body><body package="COASTClient">atFrameID: frameID clusterID: clusterID ifAbsent: aBlock 	self subclassResponsibility</body><body package="COASTClient">clusterManager	^clusterManager</body><body package="COASTClient">clusterManager: cm	clusterManager := cm</body><body package="COASTClient">disresolveAll: aDictionary clusterID: clusterID 	self subclassResponsibility</body><body package="COASTClient">exactNumberOfFrames	self subclassResponsibility</body><body package="COASTClient">frameResolverAt: clusterID 	^ WeakFrameResolver clusterManager: self clusterManager clusterID: clusterID</body><body package="COASTClient">numberOfFrames	self subclassResponsibility</body><body package="COASTClient">removeFrameID: id clusterID: clusterID ifAbsent: aBlock 	self subclassResponsibility</body></methods><methods><class-id>COAST.UnresolvedFramesDictionary</class-id> <category>private</category><body package="COASTClient">compress	| now |	now := Time millisecondClockValue.	( lastCompress isNil or: [ now - lastCompress &gt; 10000 ]) 		ifTrue: 		[	self compressWhile: [ true ].			lastCompress := now		].</body><body package="COASTClient">compressWhile: block 	self subclassResponsibility</body><body package="COASTClient">growSize	^ 10000</body><body package="COASTClient">indexOfClusterID: clusterID 	^ clusterID + 1</body></methods><methods><class-id>COAST.UnresolvedFramesDictionary</class-id> <category>initialize</category><body package="COASTClient">initialize</body></methods><methods><class-id>COAST.UnresolvedFramesDictionary class</class-id> <category>instance creation</category><body package="COASTClient">new	^super new initialize</body></methods><methods><class-id>COAST.WeakSubscriptionRegistry</class-id> <category>initialize-release</category><body package="COASTClient">initialize	classesAndSubscriptions := Dictionary new.	subscriptionClass := WeakAnnouncementSubscription</body></methods><methods><class-id>COAST.WeakAnnouncer</class-id> <category>private</category><body package="COASTClient">createSubscriptionRegistry	^ WeakSubscriptionRegistry new</body></methods><methods><class-id>COAST.ClusterUnloadProcess</class-id> <category>accessing</category><body package="COASTClient">delay	^ delay ifNil: [ 5	"seconds" ]</body><body package="COASTClient">delay: newDelay 	delay := newDelay.</body><body package="COASTClient">manager: newManager 	manager := newManager.</body><body package="COASTClient">maxUnloadableClusters	" maxUnloadableClusters can be a count or a ratio"	^ unloadableCountOrRatio &lt; 1 		ifTrue: [ manager clusterController size * unloadableCountOrRatio	"ratio" ]		ifFalse: [ unloadableCountOrRatio	"count" ]</body><body package="COASTClient">maxUnloadableClusters: countOrRatio 	unloadableCountOrRatio := countOrRatio</body><body package="COASTClient">priority	^ priority ifNil: [ Processor userBackgroundPriority ]</body><body package="COASTClient">priority: processPriority 	priority := processPriority</body><body package="COASTClient">startProcess	unloadableCountOrRatio isNil ifTrue: [ unloadableCountOrRatio := 10 ].	active := true.	process :=		[				[	CoastLog logDebug: 'Cluster Unload Process started' channel: #unloadProcess.				[ active ] whileTrue: 					[	self unloadAction.						( Delay forSeconds: self delay ) wait					]			] ensure: 				[	active ifTrue: [ manager stopUnloadProcess ].					CoastLog logDebug: 'Cluster Unload Process terminated' channel: #unloadProcess				]		] forkAt: self priority.	process name: manager  processNamePrefix , ' - unload process'</body><body package="COASTClient">stopProcess	active := false</body><body package="COASTClient">unloadAction	manager criticalNow: [ manager tryUnloadClustersMaxCount: self maxUnloadableClusters ]		unblockedDo: 		[	CoastLog logDebug: [ 'client is busy - clusters loaded: ' , manager clusterController size printString ]				channel: #unloadProcess		]</body></methods><methods><class-id>COAST.ClusterUnloadProcess class</class-id> <category>instance creation</category><body package="COASTClient">manager: newManager 	^ ( self new )		manager: newManager;		startProcess;		yourself</body></methods><methods><class-id>COAST.CatRMClientPacketStation</class-id> <category>accessing</category><body package="COASTClient">clientID	^self ownID</body><body package="COASTClient">clientIDString	^self ownID ifNotNil: [ : id | id displayString ] ifNil: [ '-' ]</body><body package="COASTClient">connectPort: aString	connectPort := aString</body><body package="COASTClient">host: aString	host := aString</body><body package="COASTClient">ownID	^ownID.</body><body package="COASTClient">printPeerTypeOn: stream 	stream nextPutAll: 'mediator'</body></methods><methods><class-id>COAST.CatRMClientPacketStation</class-id> <category>private: send/receive</category><body package="COASTClient">handleConnectionLostTo: oldSocket 	oldSocket notNil 		ifTrue: 		[( self tryReconnect: oldSocket ) 				ifTrue: [ ^ self ]		].	super handleConnectionLostTo: oldSocket.</body><body package="COASTClient">ignoreMessageLoopErrors	^ super ignoreMessageLoopErrors or: [ inReconnectPhase == true ]</body><body package="COASTClient">lastSendTime	^ lastSendTime ifNil: [ 0 ]</body><body package="COASTClient">reConnect	"answer true if reconnect succesful, false otherwise"	| aSocketAccessor coastSocketAccessor |	aSocketAccessor := SocketAccessor defaultClass newTCPclientToHostAndPort: host defaultPort: connectPort.	^ ( aSocketAccessor notNil and: [ aSocketAccessor isActive ]) 		ifTrue: 		[	coastSocketAccessor := CoastSocketAccessor connectSocketAccessor: aSocketAccessor.			self connectToSocketAccessor: coastSocketAccessor reconnect: true.			self connected ifTrue: 				[	receiveProcess notNil ifTrue: [ receiveProcess terminate ].					sendProcess notNil ifTrue: [ sendProcess terminate ].					self restartSendProcess.					self restartReceiveProcess.					self startKeepAliveProcess				].			self connected		]		ifFalse: [ false	"oooops" ]</body><body package="COASTClient">send: aCatRMMessage	self setLastSendTime.	^super send: aCatRMMessage</body><body package="COASTClient">setLastSendTime	lastSendTime := Time secondClock.</body><body package="COASTClient">tryReconnect: oldSocket 	| try tryAttempts |	reconnectSemaphore wait.	"avoid simultaneos reconnect"	( connected and: [ socketAccessor == oldSocket ]) ifFalse: 		[	reconnectSemaphore signal.			^ true		].	" get rid of the resources allocated by the old one "	[		oldSocket close 	] on: Error do: [ : ex | ].	inReconnectPhase := true.	try := 1.	" try until reconnectAttempts is reached (note: reconnectAttempts may change while trying to reconnect!) "	[ try &lt;= ( tryAttempts := self volumeManager reconnectAttempts )] whileTrue: 		[	CoastLog log: 'Trying to reconnect (Try ' , try printString , ' of ' , tryAttempts printString , ')'.			( Delay forSeconds: try * 2 ) wait.			[	self reConnect ifTrue: 					[	CoastLog log: 'Reconnect successful'.						inReconnectPhase := false.						reconnectSemaphore signal.						^ true					]			] on: Error				do: 				[: ex |					ex coastIsConnectionRefuse 						ifTrue: 						[	CoastLog logError: ex description.							CoastLog log: 'Reconnect aborted'.							^ false						]						ifFalse: [ CoastLog logDebug: [ 'Error during reconnect: ' , ex description ]]				].			try := try + 1		].	CoastLog log: 'Reconnect failed'.	^ false</body></methods><methods><class-id>COAST.CatRMClientPacketStation</class-id> <category>private: initialize</category><body package="COASTClient">authenticate	" mediator wants to know who I am "	| pidResponse |	self statusLog:  [ 'Sending persistent client ID' ].	self persistentClientID marshallBinaryTo: sendStream marshaller: nil.	self clientDescription asCoastPrimitive marshallBinaryArgumentTo: sendStream marshaller: CatMAMarshallBinary new.	sendStream flush.	pidResponse := receiveStream next.	self statusLog:  [ 'Persistent client ID response: ', pidResponse printString ].	pidResponse = CoastConstant authenticationRejected ifTrue: [ CoastConnectionRefusedError raiseSignal: 'Persistent client ID rejected' ].	pidResponse = CoastConstant authenticationOK ifFalse: [ CoastError raiseSignal: 'Persistent client ID rejected' ].</body><body package="COASTClient">basicCheckConnection	" check that the mediator confirms my (re)connection request "	| securityFault mediatorProtocolVersion connectStatus |	connectStatus := CoastStatusResponse fromStream: receiveStream.	connectStatus ok ifFalse: [ CoastError raiseSignal: 'Connection rejected by mediator: ' , connectStatus message ].	ownID := receiveStream nextOptimized32.	"this is my ID"	self checkMediatorVersion: ( CoastVersion unmarshallBinaryFrom: receiveStream marshaller: nil ).	mediatorProtocolVersion := receiveStream nextOptimized32.	self checkProtocolVersion: mediatorProtocolVersion.	self authenticate.	securityFault := self secureHandshakeWithReceiveStream: receiveStream SendStream: sendStream.	securityFault notNil ifTrue: 		[	sendStream nextOptimized32Put: -1.			sendStream nextCoastStringPut: securityFault.			sendStream flush.			SecurityFault raiseSignal: 'secure handshake failed: ' , securityFault		].	^ ownID</body><body package="COASTClient">checkMediatorVersion: mediatorCoastVersion 	| minRequired |	minRequired := self minRequiredMediatorVersion.	( mediatorCoastVersion isNil or: [ mediatorCoastVersion &lt; minRequired ]) ifTrue: 		[	CoastError raiseSignal: 'Mediator version too old, current is ' , mediatorCoastVersion printString , ', required ' , minRequired printString		].	^ true</body><body package="COASTClient">checkProtocolVersion: mediatorProtocolVersion 	| ok |	ok := mediatorProtocolVersion = CoastConstant protocolVersion.	ok 		ifFalse: 		[	CoastError 				raiseSignal: 'Mediator protocol version is ' , mediatorProtocolVersion printString , ', client requires version ' , CoastConstant protocolVersion printString		].</body><body package="COASTClient">connectToSocketAccessor: aSocketAccessor reconnect: reconnect 	| connOK |	connOK :=		[				[	socketAccessor := aSocketAccessor.				sendStream := aSocketAccessor coastBinaryWriteStream.				receiveStream := aSocketAccessor coastBinaryReadStream.				reconnect 					ifTrue: [ self sendReConnectionRequest ]					ifFalse: [ self sendConnectionRequest ].				sendStream flush			] coastValueWithinSeconds: self class connectTimeout		] 			on: Error			do: 			[: ex |				socketAccessor := nil.				false			].	connOK 		ifFalse: [( CoastError new messageText: 'Connection can not be established' ) raise ].	connOK := self receiveConnectionResponseFrom: aSocketAccessor.	connOK 		ifFalse: [( CoastError new messageText: 'Connection refused' ) raise ].	self setLastSendTime.	connected := true.</body><body package="COASTClient">initialize	super initialize.	reconnectSemaphore := Semaphore forMutualExclusion.	inReconnectPhase := false.</body><body package="COASTClient">initializeForSocketAccessor: aSocketAccessor	self connectToSocketAccessor: aSocketAccessor reconnect: false.	self startKeepAliveProcess.	self initializeProcesses.</body><body package="COASTClient">minRequiredMediatorVersion	^ CoastVersion major: 5 minor: 4</body><body package="COASTClient">receiveConnectionResponseFrom: aSocketAccessor 	| try peer ok |	try := 3.	[	try := try - 1.		ok :=			[ self basicCheckConnection ] coastValueWithinSeconds: self class connectTimeout.		( ok not and: [ try &gt;= 0 ]) 			ifTrue: 			[	peer :=					[ aSocketAccessor getPeer ] on: Error do: [: ex | nil ].				CoastLog log: 'Not connected, peer is ' , peer printString.				peer notNil 					ifTrue: [ CoastLog log: 'peer seems to be alive, retrying...' ].				peer notNil			]			ifFalse: [ false ]	] whileTrue.	^ ok</body><body package="COASTClient">sendConnectionRequest			sendStream nextPut: CoastConstant clientConnection.	self class marshallVersionOn: sendStream.	sendStream flush.</body><body package="COASTClient">sendReConnectionRequest	sendStream nextPut: CoastConstant clientReConnection.	self class marshallVersionOn: sendStream.	sendStream nextOptimized32Put: ownID.</body></methods><methods><class-id>COAST.CatRMClientPacketStation</class-id> <category>keep alive</category><body package="COASTClient">killKeepAliveProcess	keepAliveProcess notNil		ifTrue: [			keepAliveProcess terminate.			keepAliveProcess := nil.		].</body><body package="COASTClient">maxSilentSeconds	"max amount of seconds silent time (no message sent to peer) before keep alive msg is activated"	^300	"5 minutes should be enough"</body><body package="COASTClient">processNamePrefix	| stream |	stream := String new writeStream.	stream nextPutAll: 'CoastClient['.	stream nextPutAll: host.	stream nextPut: $:.	connectPort printOn: stream.	stream nextPut: $].	^ stream contents</body><body package="COASTClient">startKeepAliveProcess	keepAliveProcess notNil ifTrue: [ ^ self ].	keepAliveProcess :=		[ | lastKeepAliveSeconds |			lastKeepAliveSeconds := Time secondClock.			[ connected ] whileTrue: 				[ | delta |					delta := Time secondClock - ( self lastSendTime max: lastKeepAliveSeconds ).					delta &gt;= self maxSilentSeconds 						ifTrue: 						[	connected ifTrue: 								[	self sendAlivePacket.									lastKeepAliveSeconds := Time secondClock								]						]						ifFalse: [( Delay forSeconds: self maxSilentSeconds - delta ) wait ]				]		] forkAt: Processor userSchedulingPriority + 8.	keepAliveProcess name: self processNamePrefix , ' - keep alive process'.</body></methods><methods><class-id>COAST.CatRMClientPacketStation</class-id> <category>private: accessing</category><body package="COASTClient">clientDescription	^ volumeManager notNil		ifTrue: [ volumeManager clientDescription ]		ifFalse: [ Dictionary new ] "should not happen"</body><body package="COASTClient">persistentClientID	^ volumeManager notNil		ifTrue: [ volumeManager persistentClientID ]		ifFalse: [ #[] ]</body><body package="COASTClient">printOn: stream 	stream nextPutAll: 'Client PS ['.	self peerStringTo: stream.	stream nextPutAll: ']'</body><body package="COASTClient">psPrintString	^ 'Client PS [', self peerString, ']'</body><body package="COASTClient">terminateProcessesAndStreams	self killKeepAliveProcess.	super terminateProcessesAndStreams.</body></methods><methods><class-id>COAST.CatRMClientPacketStation class</class-id> <category>accessing</category><body package="COASTClient">connectTimeout	^ connectTimeout notNil		ifTrue: [ connectTimeout ]		ifFalse: [ 8 ]</body><body package="COASTClient">connectTimeout: anInteger	connectTimeout := anInteger</body></methods><methods><class-id>COAST.CatRMClientPacketStation class</class-id> <category>instance creation</category><body package="COASTClient">connectedToServerAtHost: hname port: pnum volumeManager: aVM 	| aSocketAccessor coastSocketAccessor |	aSocketAccessor := SocketAccessor defaultClass newTCPclientToHostAndPort: hname defaultPort: pnum.	^ ( aSocketAccessor notNil and: [ aSocketAccessor isActive ]) 		ifTrue: 		[ | ps |			ps := self new.			ps host: hname.			ps connectPort: pnum.			ps volumeManager: aVM.			coastSocketAccessor := CoastSocketAccessor connectSocketAccessor: aSocketAccessor.			ps initializeForSocketAccessor: coastSocketAccessor.			ps connected 				ifTrue: [ ps ]				ifFalse: [ nil ]		]		ifFalse: [ nil	"oooops" ]</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>caching</category><body package="COASTClient">cacheAccessor	^ nil</body><body package="COASTClient">newLanCacheAccessorFor: cacheHost 	^nil</body><body package="COASTClient">newLocalCacheAccessorFor: directory	"not with me"	^nil</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>accessing</category><body package="COASTClient">accessCountFor: clusterID 	^ unloadStrategy notNil 		ifTrue: [ unloadStrategy accessCountFor: clusterID ]		ifFalse: [ super accessCountFor: clusterID ]</body><body package="COASTClient">cleanUpClustersWithStreams	" Lenor fix "	clustersWithStreams copy do: [ : cl | 		cl clusterManager isNil			ifTrue: [				clustersWithStreams remove: cl.				cl closeClusterStream.			].	].	^ clustersWithStreams</body><body package="COASTClient">deregisterClusterWithStream: aCatCSCluster	self cleanUpClustersWithStreams.	clustersWithStreams remove: aCatCSCluster ifAbsent: []</body><body package="COASTClient">hasWaitingMessages	^ false</body><body package="COASTClient">host	^ nil</body><body package="COASTClient">manyClustersToLoadDo: aBlock	^ self unloadStrategy manyClustersToLoadDo: aBlock</body><body package="COASTClient">maxClusterCount	^self unloadStrategy maxClusterCount</body><body package="COASTClient">maxOpenClusterStreams	^ 10</body><body package="COASTClient">networkHost	^ nil</body><body package="COASTClient">processNamePrefix	self subclassResponsibility.</body><body package="COASTClient">recordApplicationLog: aCatCSApplicationLog	" record a standalone application log (which is not recorded as a part of a transaction) "	self subclassResponsibility</body><body package="COASTClient">releaseAllClusters	self stopUnloadProcess.	super releaseAllClusters</body><body package="COASTClient">transactionManager	^volumeManager transactionManager</body><body package="COASTClient">unloadStrategy	^unloadStrategy.</body><body package="COASTClient">unloadStrategy: aStrategy	unloadStrategy := aStrategy ifNil: [DisabledUnloadStrategy new].</body><body package="COASTClient">volumeContextAt: key ifAbsent: aBlock	volumeContext isNil ifTrue: [ ^aBlock value ].	^volumeContext at: key ifAbsent: aBlock</body><body package="COASTClient">volumeContextAt: key ifAbsentPut: aBlock	^self volumeContextAt: key ifAbsent: [ | value | value := aBlock value. self volumeContextAt: key put: value. value ]</body><body package="COASTClient">volumeContextAt: key put: aValue	volumeContext isNil ifTrue: [ volumeContext := Dictionary new ].	(aValue isCoastFrame and: [ aValue isLocal not ]) ifTrue: [ self unloadStrategy keepClusterIDs add: aValue clusterID ].	volumeContext at: key put: aValue.</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>private</category><body package="COASTClient">classNameManagerClass	^ ClientClassNameManager</body><body package="COASTClient">closeOpenClusterStreams	clustersWithStreams copy do: [ : cl | cl closeClusterStream ]</body><body package="COASTClient">volumeLockInfoString	^ 'CoastClient (local)'</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>controlling</category><body package="COASTClient">controllerClass	^CatRMClientCC</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>initialize-release</category><body package="COASTClient">basicEmergencyShutDown	self closeOpenClusterStreams.	super basicEmergencyShutDown.</body><body package="COASTClient">emergencyShutDown	self closeOpenClusterStreams.	super emergencyShutDown.</body><body package="COASTClient">initialize	super initialize.	unresolvedFrames := SegmentedUnresolvedFramesRegistry new.	unresolvedFrames clusterManager: self.	unloadStrategy := MemoryBasedUnloadStrategy newWith: self.	clustersWithStreams := OrderedCollection new.	reusableClusters := OrderedCollection new.</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>cluster creation</category><body package="COASTClient">addReusableCluster: cluster 	CoastLog logDebug: 'Remember reuseable cluster: ' , cluster clusterID printString.	reusableClusters add: cluster.</body><body package="COASTClient">basicLoadCluster: clusterIDInteger 	| cluster |	cluster := super basicLoadCluster: clusterIDInteger.	cluster notNil ifTrue: [ self notifyLoadCluster: cluster ].	^ cluster</body><body package="COASTClient">createCluster	^ reusableClusters isEmpty 		ifTrue: [ super createCluster ]		ifFalse: [ self getReusableCluster ]</body><body package="COASTClient">createCluster: clusterIDInteger 	"create the cluster with the given locator"	| cluster |	volumeManager interruptProtectDo:	[		cluster := self basicCreateCluster: clusterIDInteger.		cluster notNil			ifTrue: [					self unloadStrategy checkForClusterUnload.				self notifyLoadCluster: cluster			].	].	^ cluster</body><body package="COASTClient">getReusableCluster	| cluster |	cluster := reusableClusters removeLast.	self notifyLoadCluster: cluster.	CoastLog logDebug: 'Reused cluster: ' , cluster clusterID printString.	^ cluster</body><body package="COASTClient">loadCluster: clusterIDInteger	| cluster |	volumeManager interruptProtectDo:	[		self unloadStrategy checkForClusterUnload.		cluster := self basicLoadCluster: clusterIDInteger.	].	^ cluster</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>resolving</category><body package="COASTClient">getFrameForLoading: aCatFSExternalFrameDefinition 	"A frame has to be loaded. If the frame was used as preliminary frame 	before, use this frame. Otherwise create a blank frame to continue loading."	| aFrame fcl |	aFrame := unresolvedFrames 			removeFrameID: aCatFSExternalFrameDefinition id		clusterID: aCatFSExternalFrameDefinition clusterID		ifAbsent: [ nil ].	^ aFrame isNil		ifTrue: [ 	aCatFSExternalFrameDefinition createBlankFrameFor: self ]		ifFalse: [			((fcl := aCatFSExternalFrameDefinition frameClassFor: self classNameManager) notNil				and: [ aFrame class ~= fcl ]) ifTrue: 			[				CoastLog logWarning: [ ' changing class from ' , aFrame frameClassName , 									' to ' , fcl printString , 									' for ' , aCatFSExternalFrameDefinition printString ].				aFrame changeClassTo: fcl			].			aFrame		].</body><body package="COASTClient">resolveAbsentFrameReference: aCatFSFrameReference 	| unresolvedFrame |	unresolvedFrame := aCatFSFrameReference createBlankFrameFor: self.	unresolvedFrame id: aCatFSFrameReference id.	unresolvedFrames atClusterID: aCatFSFrameReference clusterID put: unresolvedFrame.	^ unresolvedFrame</body><body package="COASTClient">resolveFrameLocator: aCatCSFrameLocator 	"same as resolveFrameReference!"	^ self resolveFrameLocator: aCatCSFrameLocator ifAbsent: [ aCatCSFrameLocator resolveAbsentFor: self ]</body><body package="COASTClient">resolveFrameLocator: aCatFSFrameLocator ifAbsent: absentBlock 	^ self resolveFrameLocator: aCatFSFrameLocator ifAbsent: absentBlock complainMissingFrames: true</body><body package="COASTClient">resolveFrameLocator: aCatFSFrameLocator ifAbsent: absentBlock complainMissingFrames: complainMissingFrames 	"First have a look if the frame is unresolved and return the preliminary frame. 	If it isn't unresolved, get the frame from the loaded cluster or - if the cluster 	isn't loaded  execute absentBlock. "	| controller frame |	controller := self clusterController at: aCatFSFrameLocator clusterID ifAbsent: [ nil ].	controller notNil 		ifTrue: 		[	frame := aCatFSFrameLocator frameForCluster: controller cluster.			frame notNil 				ifTrue: [ ^ frame ].			complainMissingFrames 				ifTrue: [ CoastLog logWarning: 'Found unresolved Frame for loaded cluster: ' , aCatFSFrameLocator printString ]		].	^ unresolvedFrames atFrameID: aCatFSFrameLocator id clusterID: aCatFSFrameLocator clusterID ifAbsent: absentBlock</body><body package="COASTClient">resolveFrameReference: aCatFSFrameReference 	"First have a look if the frame is unresolved and return the preliminary frame. 	If it isn't unresolved, get the frame from the loaded cluster or - if the cluster 	isn't loaded - create a preliminary frame.	lenor: works also with frame locators - using double dispatch #resolveAbsentFor:"	aCatFSFrameReference isCoastFrame ifTrue: [ ^aCatFSFrameReference ].	^ self resolveFrameLocator: aCatFSFrameReference ifAbsent: [ aCatFSFrameReference resolveAbsentFor: self ]</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>saving</category><body package="COASTClient">saveAllModifiedClusters	| success |	success := super saveAllModifiedClusters.	success ifTrue: [ self unloadStrategy checkForClusterUnload ].	^success</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>timing</category><body package="COASTClient">timestamp	^ Timestamp coastRightNow</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>exclusive use</category><body package="COASTClient">criticalNow: aBlock unblockedDo: bBlock 	^ volumeManager criticalNow: aBlock unblockedDo: bBlock</body><body package="COASTClient">exclusiveLockBlocksAnyProcess	^ volumeManager exclusiveLockBlocksAnyProcess</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>cluster logging</category><body package="COASTClient">notifyCacheLoad: aClusterIDInterger 	self unloadStrategy notNil ifTrue: [ self unloadStrategy notifyCacheLoad: aClusterIDInterger ]</body><body package="COASTClient">notifyClusterAccess: clusterIDInteger 	self unloadStrategy notNil ifTrue: [ self unloadStrategy notifyClusterAccess: clusterIDInteger ]</body><body package="COASTClient">notifyExternalFileLoad: clusterIDInteger 	self unloadStrategy notNil ifTrue: [ self unloadStrategy notifyExternalFileLoad: clusterIDInteger ]</body><body package="COASTClient">notifyLoadCluster: cluster	self unloadStrategy notNil ifTrue: [ self unloadStrategy notifyLoadCluster: cluster ]</body><body package="COASTClient">notifyUnloadCluster: cluster 	self unloadStrategy ifNotNil: [: strategy | strategy notifyUnloadCluster: cluster ].	self transactionManager activeTransaction ifNotNil: [: transaction | transaction notifyUnloadCluster: cluster cluster ].</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>testing</category><body package="COASTClient">supportsLazyUnmarshalling	^ true</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>cluster unload</category><body package="COASTClient">emergencyUnloadAllPossibleClusters	self exclusiveUseDo: [ self unloadAllPossibleClustersIgnoreRestrictions: true keepObserved: false].</body><body package="COASTClient">keepClusterIDs	^ unloadStrategy nonWeakObservedClustersFor: self</body><body package="COASTClient">tryUnloadClustersMaxCount: maxCount 	| unloadableClusterIDs count |	self unloadStrategy isNil 		ifTrue: [ ^ self stopUnloadProcess ].	self transactionManager isSequenceActive 		ifTrue: [ ^ self ].	"not now!"	count := 0.	unloadableClusterIDs := self unloadStrategy unloadableClustersWithout: #( ) background: true ignoreRestrictions: false.	[ count &gt;= maxCount or: [ count &gt;= unloadableClusterIDs size or: [ self exclusiveLockBlocksAnyProcess ]]] whileFalse: 		[ | id |			count := count + 1.			id := unloadableClusterIDs at: count.			self unloadClusterWithID: id.			CoastLog logDebug: [ 'unloaded cluster ' , id printString , ' clusters loaded: ' , clusterController size printString ] channel: #unloadProcess		].	count &gt; 0 		ifTrue: [ unresolvedFrames compressWhile: [ self exclusiveLockBlocksAnyProcess not ]].	( unloadableClusterIDs isEmpty and: [ count = 0 ]) 		ifTrue: 		[	CoastLog logDebug: [ 'no unloadable clusters ' , ' clusters loaded: ' , clusterController size printString ] channel: #unloadProcess		]		ifFalse: 		[	CoastLog 				logDebug: 				[	count &gt;= maxCount 						ifTrue: [ 'unloaded maximum clusters ' , count printString , ' clusters loaded: ' , clusterController size printString ]						ifFalse: [ 'retreat from exclusive lock - clusters loaded: ' , clusterController size printString ]				]				channel: #unloadProcess		].	self unloadStrategy clusterUnloadFinished: count &gt; 0.	^ count</body><body package="COASTClient">unloadAllClusters	self unloadClustersWithIDs: self loadedClusterIDs ignoreRestrictions: true</body><body package="COASTClient">unloadAllPossibleClusters	self unloadAllPossibleClustersIgnoreRestrictions: false</body><body package="COASTClient">unloadAllPossibleClustersIgnoreRestrictions: ignoreRestrictions	" ignoreRestrictions: true -&gt; ignore restrictions like unloadSize, minAge etc. "	self unloadAllPossibleClustersIgnoreRestrictions: ignoreRestrictions keepObserved: true</body><body package="COASTClient">unloadAllPossibleClustersIgnoreRestrictions: ignoreRestrictions keepObserved: keepObserved 	" ignoreRestrictions: true -&gt; ignore restrictions like unloadSize, minAge etc.	keepObserved = false requires a transaction ! "	| unloadableClusterIDs |	unloadableClusterIDs := #( ).	self unloadStrategy notNil 		ifTrue: 		[ | keepIDs |			keepIDs := self transactionManager activeTransaction ifNotNil: [: t | t keepClusterIDs ] ifNil: [ #( )].			unloadableClusterIDs := self unloadStrategy unloadableClustersWithout: keepIDs background: false ignoreRestrictions: ignoreRestrictions.			unloadableClusterIDs do: [: id | self unloadClusterWithID: id ]		].	unresolvedFrames compress.	self unloadStrategy notNil 		ifTrue: [ self unloadStrategy clusterUnloadFinished: unloadableClusterIDs notEmpty ].</body><body package="COASTClient">unloadClusterWithID: clusterID 	| cc |	cc := self clusterController at: clusterID ifAbsent: [ nil ].	cc notNil 		ifTrue: [ self unloadClusterIfPossible: cc clusterStub disresolve: true ]		ifFalse: [ CoastLog logDebug: [ 'Cannot unload cluster, cluster not loaded:' , self volume , '/' , clusterID printString ] channel: #load ].</body><body package="COASTClient">unloadClustersIfNecessaryExcept: moreKeepClusterIDs 	| unloadableClusterIDs unloadTime previousNumberOfClusters keepClusterIDs |	( self unloadStrategy notNil and: [ self unloadStrategy clusterUnloadNeeded ]) 		ifTrue: 		[	keepClusterIDs := moreKeepClusterIDs copy.			reusableClusters do: [: cluster | keepClusterIDs add: cluster clusterID ].			unloadableClusterIDs := self unloadStrategy unloadableClustersWithout: keepClusterIDs.			previousNumberOfClusters := clusterController size.			unloadTime := Time millisecondsToRun: [ self unloadClustersWithIDs: unloadableClusterIDs ].			CoastLog 				logDebug: 				[	'unloaded ' , ( previousNumberOfClusters - clusterController size ) printString , ' clusters from ' , unloadableClusterIDs size printString 						, ' in ' , unloadTime printString 						, ' ms - clusters left: ' , clusterController size printString				]				channel: #load		].</body><body package="COASTClient">unloadClustersWithIDs: sortedClusterIDs 	self unloadClustersWithIDs: sortedClusterIDs ignoreRestrictions: false</body><body package="COASTClient">unloadClustersWithIDs: sortedClusterIDs ignoreRestrictions: ignoreRestrictions 	" ignoreRestrictions: true -&gt; ignore maxUnloadTime etc. "	| clusterIDInteger startTime clustersToUnload ignoreTimeRestrictions |	ignoreTimeRestrictions := ignoreRestrictions or: [ self unloadStrategy maxUnloadTime &gt; 600000	"10 minutes seem to be endless" ].	sortedClusterIDs notEmpty 		ifTrue: 		[	startTime := Time millisecondClockValue.			clustersToUnload := sortedClusterIDs asOrderedCollection.			[	clustersToUnload notEmpty and: [ ignoreTimeRestrictions or: [ Time millisecondClockValue - startTime &lt; self unloadStrategy maxUnloadTime ]]			] whileTrue: 				[ | cc |					clusterIDInteger := clustersToUnload removeFirst.					cc := self clusterController at: clusterIDInteger ifAbsent: [ nil ].					( cc notNil and: [ ignoreRestrictions or: [ cc cluster hasNonWeakObservers not ]]) 						ifTrue: [ self unloadClusterWithID: clusterIDInteger ]				].			unresolvedFrames compress		].	self volumeManager currentLoadedClusterID: nil.	self unloadStrategy clusterUnloadFinished: sortedClusterIDs notEmpty.</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>cluster unload - private</category><body package="COASTClient">canUnloadCluster: aCluster 	^ (self transactionManager transactionReferencesClusterWithID: aCluster clusterID) not and: [ aCluster clusterController hasLog not ]</body><body package="COASTClient">disresolveAllFramesInCluster: aCluster	unresolvedFrames disresolveAll: aCluster cellValue clusterID: aCluster id</body><body package="COASTClient">startUnloadProcess	unloadProcessHandler isNil ifTrue: [ unloadProcessHandler := ClusterUnloadProcess manager: self ].	^ unloadProcessHandler</body><body package="COASTClient">stopUnloadProcess	unloadProcessHandler notNil ifTrue: 		[	unloadProcessHandler stopProcess.			unloadProcessHandler := nil		].	^ nil</body><body package="COASTClient">unloadCluster: aCluster disresolve: disresolve notifyMediator: doNotify 	" PRIVATE - don't call outside COAST! use #unloadClusterWithID: instead "	doNotify ifTrue: [ self notifyUnloadCluster: aCluster ].	reusableClusters remove: aCluster ifAbsent: [ ].	"by default these are not unloaded"	self coastStatistics ifNotNil: [: coastStatistics | coastStatistics counterAt: #clustersUnloaded add: 1 unit: nil ].	super unloadCluster: aCluster disresolve: disresolve notifyMediator: doNotify.</body><body package="COASTClient">unloadClusterIfPossible: aCluster disresolve: disresolve 	( self canUnloadCluster: aCluster ) 		ifTrue: [ self unloadCluster: aCluster disresolve: disresolve ]		ifFalse: [ CoastLog logDebug: [ 'Cannot unload cluster ' , aCluster clusterID printString , ', cluster in use' ] channel: #load ].</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>block cache per cm</category><body package="COASTClient">blockCacheAt: aBlock ifAbsentPut: absentBlock 	^ self blockCachesNeeded at: aBlock ifAbsentPut: absentBlock</body><body package="COASTClient">blockCachesNeeded	blockCaches isNil ifTrue: [ blockCaches := IdentityDictionary new ].	^ blockCaches</body><body package="COASTClient">flushBlockCaches	blockCaches notNil ifTrue: 		[	blockCaches := nil.			self blockCachesNeeded		].</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>statistics</category><body package="COASTClient">coastStatistics	^ statistics</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>blob handling</category><body package="COASTClient">loadFromID: fileID toStream: targetStream 	^ self loadFromID: fileID toStream: targetStream bytesOnly: false</body><body package="COASTClient">loadFromID: fileID toStream: targetStream bytesOnly: bytesOnly 	" Transfer the file contents to the stream. The header (currently only the file size) will be streamed first if bytesOnly = false "	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>utility</category><body package="COASTClient">patch: someBytes 	"cluster bytes of a cluster that needs an upgrade.	unmarshal and marshal again "	| newClusterController marshaller cluster newBytesStream |	"Transcript show: '.'."	newClusterController := self localControllerClass new.	newClusterController clusterManager: self.	marshaller := self loadMarshaller.	marshaller clusterController: newClusterController.	cluster := marshaller loadClusterFromStream: someBytes readStream.	newBytesStream := (ByteArray new: someBytes size) writeStream.	cluster marshallBinaryTo: newBytesStream marshaller: marshaller.	^ newBytesStream contents</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>binary storage</category><body package="COASTClient">binaryStoreInterfaceNeededForStore: store	^ self storageInterface binaryStoreInterfaceNeededForStore: store</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>requests</category><body package="COASTClient">receiveVolumeFrom: receiveStream 	self exclusiveUseDo: [ self storageInterface receiveVolumeFrom: receiveStream ].	^ CoastStatusResponse okCode: #volumeDownloaded message: 'Volume ', self volume, ' downloaded'</body></methods><methods><class-id>COAST.CoastApplicationClient</class-id> <category>configuration</category><body package="COASTClient">configurationClass	^ CoastClientConfiguration</body><body package="COASTClient">reconfigureForNewTransactionManager	" Notwendig, wenn ein neuer TransactionManager gebaut wird (#reinitialize) "	self configuration ifNotNil: [: config | config configureTransactionManagerPragmasFor: self transactionManager ]</body></methods><methods><class-id>COAST.CoastApplicationClient</class-id> <category>user management</category><body package="COASTClient">defaultUserClass	^ CoastUser</body><body package="COASTClient">localUser	"NOTE: assumes there is only one local user"	| aUser |	aUser := self localUsers anyElement.	^aUser isNil 		ifTrue: [nil]		ifFalse: [aUser sharedCopy]</body><body package="COASTClient">localUsers	^self transactionManager localUsers</body><body package="COASTClient">registerUser: userName inVolume: volume	| user |	user := self modelNamed: userName inExistingVolume: volume.	user isNil ifTrue:	[		user := self defaultUserClass newInCluster: (self rootClusterInVolume: volume).		user coastName: userName.	].	user register.	^user</body></methods><methods><class-id>COAST.CoastApplicationClient</class-id> <category>transactions</category><body package="COASTClient">displayDo: aBlock	^self transactionManager displayDo: aBlock</body><body package="COASTClient">fastReadTransactionDo: aBlock	^self transactionManager fastReadTransactionDo: aBlock</body><body package="COASTClient">sequenceDo: aBlock	^self transactionManager sequenceDo: aBlock</body><body package="COASTClient">transactionDo: aBlock	^self transactionManager transactionDo: aBlock</body></methods><methods><class-id>COAST.CoastApplicationClient</class-id> <category>naming service</category><body package="COASTClient">findOrCreate: aClass named: modelName inVolume: volume 	^ volumeManager findOrCreate: aClass named: modelName inVolume: volume</body><body package="COASTClient">modelNamed: modelName inExistingVolume: volume	^volumeManager modelNamed: modelName inExistingVolume: volume</body><body package="COASTClient">modelNamed: modelName inVolume: volume	^volumeManager modelNamed: modelName inVolume: volume</body><body package="COASTClient">namedModelsInVolume: volume	^volumeManager namedModelsInVolume: volume</body></methods><methods><class-id>COAST.CoastApplicationClient</class-id> <category>initialize-release</category><body package="COASTClient">abortAndShutDown: shutDownTimeoutSeconds	[	self transactionManager abortTransactionOfAnyProcess.		self shutDown.		Notifier isDevelopment 			ifFalse: [ ObjectMemory quitWithError: CoastExitCode scheduledShutdown ]	] coastValueWithinSeconds: shutDownTimeoutSeconds.</body><body package="COASTClient">handleScheduledShutdown	self abortAndShutDown: self configuration shutDownTimeout</body><body package="COASTClient">initialize	self initializeCoast.	self volumeManager: self volumeManagerClass new.	"persistentClientID has to be constant for 'logically identical' clients. Obsolete last wishes will be executed otherwise! - JS"	volumeManager generatePersistentClientIDUsing: self class name asByteArray.	"describe the client"	self initializeClientDescription.	" for logging "	self transactionManager applicationClientClass: self class.	CoastMemoryPolicy installInSystem.</body><body package="COASTClient">initializeClientDescription	volumeManager clientDescription at: CoastConstant clientType put: self class fullName.</body><body package="COASTClient">release	self == self class default ifTrue: [self class resetDefault].	volumeManager notNil ifTrue: [ volumeManager shutDown ].	self class emptyPrototypes.	super release</body><body package="COASTClient">shutDown	self release</body><body package="COASTClient">volumeManagerClass	^ CoastClientVolumeManager</body></methods><methods><class-id>COAST.CoastApplicationClient</class-id> <category>accessing</category><body package="COASTClient">connectionLostBlock: aBlock	self volumeManager connectionLostBlock: aBlock</body><body package="COASTClient">transactionManager	^volumeManager transactionManager</body><body package="COASTClient">volumeInterface	^volumeManager volumeInterface</body><body package="COASTClient">volumeManager	^volumeManager</body><body package="COASTClient">volumeManager: aVM	volumeManager := aVM.</body></methods><methods><class-id>COAST.CoastApplicationClient</class-id> <category>volume management</category><body package="COASTClient">rootClusterInVolume: volume	^volumeManager getRootClusterInVolume: volume</body></methods><methods><class-id>COAST.CoastApplicationClient class</class-id> <category>accessing</category><body package="COASTClient">active	active isNil ifTrue: [ active := false asValue ].	^active</body><body package="COASTClient">default	^default</body><body package="COASTClient">default: aClient	default := aClient.</body><body package="COASTClient">defaultApplicationClass	" for the generic launcher "	^ CoastNotifierShared</body><body package="COASTClient">resetDefault	default := nil</body><body package="COASTClient">transactionManager	^default isNil		ifTrue: [ nil ]		ifFalse: [ default transactionManager ]</body></methods><methods><class-id>COAST.CoastApplicationClient class</class-id> <category>testing</category><body package="COASTClient">isActive	^self active value</body></methods><methods><class-id>COAST.CoastApplicationClient class</class-id> <category>instance creation</category><body package="COASTClient">new	^super new initialize; yourself</body><body package="COASTClient">startUp	"self shutDown"	default isNil		ifTrue: [ default := self new. self active value: true. ]		ifFalse: [ self halt: 'application already started.\ if you proceed, the application will not restart.' withCRs ].	^ default.</body></methods><methods><class-id>COAST.CoastApplicationClient class</class-id> <category>release</category><body package="COASTClient">emptyPrototypes	CatFSFrame withAllSubclasses do: [: s | s emptyPrototype ].</body><body package="COASTClient">shutDown	default isNil ifFalse:	[		default shutDown.		default := nil.		self active value: false.	].</body><body package="COASTClient">shutDownAll	self shutDown.	self allInstances do: [ :each |		each shutDown. ].</body></methods><methods><class-id>COAST.ClientClassNameManager</class-id> <category>initialize-release</category><body package="COASTClient">initialize	super initialize.	self buildRenamedClassesDict.</body></methods><methods><class-id>COAST.ClientClassNameManager</class-id> <category>private</category><body package="COASTClient">getClassForCoastClassName: coastClassName 	^ oldClassName2ClassDict at: coastClassName asSymbol ifAbsent: [ super getClassForCoastClassName: coastClassName ]</body></methods><methods><class-id>COAST.ClientClassNameManager</class-id> <category>namespace converting</category><body package="COASTClient">classForCoastClassName: coastClassName	" returns the class associated with the class name (which may be	qualified), or nil if the class does not exist "	^ name2classDict at: coastClassName ifAbsentPut: [		self getClassForCoastClassName: coastClassName	].</body></methods><methods><class-id>COAST.ClientClassNameManager</class-id> <category>printing</category><body package="COASTClient">addDumpInfoTo: stream 	super addDumpInfoTo: stream.	stream nextPutAll: 'Coast renamed classes: '.	oldClassName2ClassDict isEmpty 		ifTrue: [ stream nextPutAll: 'no renamed classes'; cr ]		ifFalse: 		[	oldClassName2ClassDict size printOn: stream.			stream cr.			oldClassName2ClassDict keysAndValuesDo: 				[: oldClassSymbol : newClass |					stream tab.					stream nextPutAll: oldClassSymbol asString; nextPutAll: ' --&gt; '; nextPutAll: newClass fullName.					stream cr				]		].</body></methods><methods><class-id>COAST.CoastConnectionRefusedError</class-id> <category>testing</category><body package="COASTClient">coastIsConnectionRefuse	^ true</body></methods><methods><class-id>COAST.CoastPerformanceUnit class</class-id> <category>accessing</category><body package="COASTClient">compatibleUnitSymbols	^ #()</body><body package="COASTClient">normalizeQuantity: aQuantity unit: aUnitSymbol 	" in die bevorzugte Einheit Umwandeln "	^ aUnitSymbol = self unitSymbol 		ifTrue: [ aQuantity ]		ifFalse: [ self normalizeUnknownUnit: aUnitSymbol ]</body><body package="COASTClient">unitSymbol	self subclassResponsibility</body></methods><methods><class-id>COAST.CoastPerformanceUnit class</class-id> <category>printing</category><body package="COASTClient">printQuantity: aQuantity on: aStream 	aStream print: aQuantity.	self unitSymbol ifNotNil: 		[: unitSymbol |			aStream space.			aStream nextPutAll: unitSymbol		].</body><body package="COASTClient">printQuantity: aQuantity ticks: ticks duration: duration on: aStream 	self printQuantity: aQuantity on: aStream.	aQuantity ~= ticks 		ifTrue: 		[	aStream nextPutAll: ', Events: '.			ticks printOn: aStream		].	( duration isNil or: [ duration isZero ]) 		ifFalse: 		[	aStream nextPutAll: ', '.			self printQuantity: ( aQuantity / duration asSeconds ) asFloat on: aStream.			aStream nextPutAll: '/' , ( #secondMLS &lt;&lt; #mls &gt;&gt; 'second' ) asString		].</body><body package="COASTClient">printQuantity: aQuantity unit: aUnitSymbol on: stream 	| normalizedQuantity |	normalizedQuantity := self normalizeQuantity: aQuantity unit: aQuantity.	self printQuantity: normalizedQuantity on: stream.</body></methods><methods><class-id>COAST.CoastPerformanceUnit class</class-id> <category>registry</category><body package="COASTClient">registerUnits	RegisteredUnits := Dictionary new.	CoastPerformanceUnit allSubclasses do: 		[: unit |			RegisteredUnits at: unit unitSymbol put: unit.			unit compatibleUnitSymbols do: [: symbol | RegisteredUnits at: symbol put: unit ]		].</body><body package="COASTClient">registeredUnitAt: aSymbol 	aSymbol isNil 		ifTrue: [ ^ CoastPerformanceUnitNumber ].	RegisteredUnits isNil 		ifTrue: [ self registerUnits ].	^ RegisteredUnits at: aSymbol ifAbsent: [ CoastError raiseSignal: 'Unknown performance unit: ' , aSymbol ]</body></methods><methods><class-id>COAST.CoastPerformanceUnit class</class-id> <category>private</category><body package="COASTClient">normalizeUnknownUnit: aUnitSymbol 	CoastLog log: 'Cannot convert performance counter unit ' , aUnitSymbol printString.	" lieber nicht verfÃ¤lschen "	^ 0</body></methods><methods><class-id>COAST.RPCCacheKey</class-id> <category>accessing</category><body package="COASTClient">args	^ args</body><body package="COASTClient">args: argArray	args := argArray collect: [ : arg | arg asRPCKey].</body><body package="COASTClient">frame	^ frame</body><body package="COASTClient">frame: aFrame 	frame := aFrame.</body><body package="COASTClient">selector	^ selector</body><body package="COASTClient">selector: aSelector 	selector := aSelector.</body><body package="COASTClient">slot	^ slot</body><body package="COASTClient">slot: aSlot 	slot := aSlot.</body></methods><methods><class-id>COAST.RPCCacheKey</class-id> <category>comparing</category><body package="COASTClient">= anotherKey 	| otherArgs |	anotherKey class = self class ifFalse: [ ^false ].	frame = anotherKey frame ifFalse: [ ^false ].	slot = anotherKey slot ifFalse: [ ^false ].	selector = anotherKey selector ifFalse: [ ^false ].	otherArgs := anotherKey args.	args size = otherArgs size ifFalse: [ ^false ].	args keysAndValuesDo: [ : idx : arg |		(arg isRPCKeyEqualTo: (otherArgs at: idx)) ifFalse: [ ^false ].	].	^true</body><body package="COASTClient">hash	| hash |	hash := frame hash.	args size &gt; 0 		ifTrue: [ hash := hash bitXor: args first rpcArgHash ].	^ hash</body></methods><methods><class-id>COAST.RPCCacheKey class</class-id> <category>instance creation</category><body package="COASTClient">frame: frame slot: slot selector: selector args: args 	^ ( self new )		frame: frame;		slot: slot;		selector: selector;		args: args;		yourself</body></methods><methods><class-id>COAST.CatRMClientVolumeTimeManager</class-id> <category>accessing</category><body package="COASTClient">clusterManager	^clusterManager</body><body package="COASTClient">clusterManager: myClusterManager 	clusterManager := myClusterManager</body><body package="COASTClient">host	"The Volume Managers know the Hosts for their Volumes."	^self clusterManager host</body><body package="COASTClient">minSynchableVersion	^CoastVersion major: 4 minor: 5</body><body package="COASTClient">timeDifference	timeDifference isNil		ifTrue: [ self synchronize ].	^timeDifference</body><body package="COASTClient">timeDifference: aDifference 	timeDifference := aDifference</body></methods><methods><class-id>COAST.CatRMClientVolumeTimeManager</class-id> <category>synchronizing</category><body package="COASTClient">basicSynchronize	"Set a new value for &gt;timeDifference&lt; depending on the server's 	time (for aVolume). If any errors occur, timeDifference is set to 	old value (or zero)"	self timeDifference: ( CoastMediatorStub timeDifferenceAtHost: self clusterManager volumeManager defaultHost )</body><body package="COASTClient">synchronize	timeDifference := 0.	self clusterManager host isNil ifTrue: [ ^ self ].	"skip"	self basicSynchronize.</body></methods><methods><class-id>COAST.CatRMClientVolumeTimeManager class</class-id> <category>instance creation</category><body package="COASTClient">newForClusterManager: aClusterManager	^self new clusterManager: aClusterManager; yourself</body></methods><methods><class-id>COAST.CatRMMediatorLostError</class-id> <category>initialize-release</category><body package="COASTClient">initialize	super initialize.	messageText := 'Connection to mediator lost'</body></methods><methods><class-id>COAST.CoastPerformanceStatistics</class-id> <category>accessing</category><body package="COASTClient">counterAt: aSymbol add: anInteger	self counterAt: aSymbol add: anInteger unit: nil.</body><body package="COASTClient">counterAt: aSymbol add: anInteger unit: aUnit	self counterAtPath: (Array with: aSymbol) add: anInteger unit: aUnit</body><body package="COASTClient">counterAtPath: aCollectionOfKeys 	" Liefert das Counter-Objekt "	^ self rootNode counterAtPath: aCollectionOfKeys</body><body package="COASTClient">counterAtPath: aCollectionOfKeys add: anInteger unit: aUnitSymbol 	" Counter erhÃ¶hen. Liefert das Counter-Objekt "	^ self rootNode counterAtPath: aCollectionOfKeys add: anInteger unit: aUnitSymbol</body><body package="COASTClient">increaseCounterAt: symbol 	self counterAt: symbol add: 1</body><body package="COASTClient">startTime	^ startTime</body><body package="COASTClient">startTime: aStartTime 	startTime := aStartTime.</body></methods><methods><class-id>COAST.CoastPerformanceStatistics</class-id> <category>accessing - compatibility</category><body package="COASTClient">counterAt: aSymbol subKey: aFrameOrSymbol add: anInteger unit: aUnit 	self counterAtPath: (Array with: aSymbol with: aFrameOrSymbol) add: anInteger unit: aUnit</body><body package="COASTClient">counterAt: aSymbol subKeys: aCollectionOfKeys add: anInteger unit: aUnit 	self counterAtPath: (Array with: aSymbol), aCollectionOfKeys add: anInteger unit: aUnit</body><body package="COASTClient">counters	^ self rootNode subCounters</body></methods><methods><class-id>COAST.CoastPerformanceStatistics</class-id> <category>logging</category><body package="COASTClient">logOn: aStream 	| now delta |	now := Time millisecondClockValue.	delta := now - startTime.	aStream nextPutAll: 'Statistics: '; cr.	self rootNode logOn: aStream duration: delta milliseconds indent: 1.</body></methods><methods><class-id>COAST.CoastPerformanceStatistics</class-id> <category>private</category><body package="COASTClient">clusterManager	^ clusterManager</body><body package="COASTClient">clusterManager: aClusterManager 	clusterManager := aClusterManager.</body><body package="COASTClient">rootNode	^ rootNode</body></methods><methods><class-id>COAST.CoastPerformanceStatistics</class-id> <category>well known counters</category><body package="COASTClient">numberOfClustersLoaded	^ ( self counterAtPath: #(clusterLoadTime) ) ifNotNil: [: counter | counter ticks ] ifNil: [ 0 ]</body></methods><methods><class-id>COAST.CoastPerformanceStatistics</class-id> <category>initialize-release</category><body package="COASTClient">resetStatistics	startTime := Time millisecondClockValue.	lastLogTime := startTime.	rootNode := CoastPerformanceCounterRoot clusterManager: self clusterManager .</body></methods><methods><class-id>COAST.CoastPerformanceStatistics class</class-id> <category>accessing</category><body package="COASTClient">enabled	^ enabled ifNil: [ enabled := false ]</body><body package="COASTClient">enabled: aBoolean	"self enabled: true"	"self enabled: false"	enabled := aBoolean</body></methods><methods><class-id>COAST.CoastPerformanceStatistics class</class-id> <category>instance creation</category><body package="COASTClient">clusterManager: aClusterManager 	^ self new 		clusterManager: aClusterManager;		resetStatistics;		yourself</body></methods><methods><class-id>COAST.CoastInterrupt</class-id> <category>accessing</category><body package="COASTClient">handler	^handler</body><body package="COASTClient">handler: anObject	handler := anObject</body><body package="COASTClient">interruptMessage	^interruptMessage</body><body package="COASTClient">interruptMessage: anObject	interruptMessage := anObject</body></methods><methods><class-id>COAST.CoastInterrupt class</class-id> <category>signalling</category><body package="COASTClient">raiseWithInterruptMessage: aCatRMInterruptMessage handler: aCoastInterruptHandler	"Raise an an exception."	^self new 		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		interruptMessage: aCatRMInterruptMessage;		handler: aCoastInterruptHandler;		raiseSignal.</body></methods><methods><class-id>COAST.CoastInterrupt class</class-id> <category>accessing</category><body package="COASTClient">mayResume	^ true</body></methods><methods><class-id>COAST.ObserverIgnorantMinAgeUnloadStrategy</class-id> <category>cluster unload</category><body package="COASTClient">nonWeakObservedClustersFor: cm 	^Set new</body><body package="COASTClient">selectNonObservedClustersFrom: clusterIDs 	^ clusterIDs</body></methods><methods><class-id>COAST.CatBFCacheBlockFileSystem</class-id> <category>accessing</category><body package="COASTClient">cacheAccessor: newCacheAccessor 	cacheAccessor := newCacheAccessor.</body><body package="COASTClient">changeCountLimit	"Anzahl Ãnderungen, bis Ã¼ber Cache-Cleanup nachgedacht wird"	^ 1000</body><body package="COASTClient">clusterManager	^ cacheAccessor notNil 		ifTrue: [ cacheAccessor clusterManager ]		ifFalse: [ nil ]</body><body package="COASTClient">writeBack	"self allInstances"	self removeFilesFromCache.	changeCount := 0.	^ super writeBack</body></methods><methods><class-id>COAST.CatBFCacheBlockFileSystem</class-id> <category>removing</category><body package="COASTClient">maxCacheSize	^ cacheAccessor notNil 		ifTrue: [ cacheAccessor maxCacheSize ]		ifFalse: [ nil ]</body><body package="COASTClient">removeFilesFromCache	self exclusiveUseDo: 		[ | clusterManager |			changeCount &gt; 0 				ifTrue: 				[( self maxCacheSize notNil and: 						[	clusterManager := self clusterManager.							clusterManager notNil						]) 						ifTrue: 						[	self privateRemoveFilesFromCacheFor: clusterManager.							self logStatus						]				]		].</body></methods><methods><class-id>COAST.CatBFCacheBlockFileSystem</class-id> <category>private</category><body package="COASTClient">logStatus	"self allInstances"	CoastLog logDebug: [ self numberOfFiles displayString , ' files in cache' ] channel: #coastCache.</body><body package="COASTClient">privateEmergencyReleaseLock	lockFile notNil 		ifTrue: 		[				[ lockFile releaseLock ] 				on: Error				do: 				[: ex |					" schade, aber nicht so wichtig "				].			lockFile := nil		].</body><body package="COASTClient">privateRemoveFilesFromCacheFor: clusterManager 	| allocatedBlockSize exceedSize availableFiles filesWithInfo sortedFilesWithInfo |	allocatedBlockSize := self usedBlocksSize.	( exceedSize := allocatedBlockSize - self maxCacheSize ) &gt; 0 		ifTrue: 		[	availableFiles := OrderedCollection new.			self filesDo: 				[: blockFile | ( self hasOpenStreamOnFile: blockFile ) 						ifFalse: [ availableFiles add: blockFile ]				].			filesWithInfo := availableFiles 					collect: [: blockFile | Array with: blockFile with: ( clusterManager accessCountFor: blockFile fileNumber ) with: blockFile fileSize ].			sortedFilesWithInfo := filesWithInfo asSortedCollection: 					[: info1 : info2 | ( info1 at: 2 ) &lt; ( info2 at: 2 ) or: [( info1 at: 2 ) = ( info2 at: 2 ) and: [( info1 at: 3 ) &gt;= ( info2 at: 3 )]]					].			sortedFilesWithInfo do: 				[: info | | file |					self privateDeleteFile: ( file := info at: 1 ).					exceedSize := exceedSize - (( self privateNumberOfBlocksOfFile: file ) * self blockSize ).					exceedSize &lt; 0 						ifTrue: [ ^ self ]				]		].</body><body package="COASTClient">quickCheckForCache	[ self ensureClosedWhile: [ self recoverErrorsDetectedWith: [ self quickCheck ]]] 		on: CoastError		do: 		[: ex |			CoastLog logWarning: ex description.			CoastLog log: 'Creating new cache'.			self emergencyRemoveAllFiles.			self create		].</body><body package="COASTClient">reset	super reset.	changeCount := 0.</body><body package="COASTClient">usedBlocksSize	^ self numberOfUsedBlocks * self blockSize</body></methods><methods><class-id>COAST.CatBFCacheBlockFileSystem</class-id> <category>file operations</category><body package="COASTClient">writeStreamOnFileNumber: fileNumber fileType: fileType 	( changeCount := changeCount + 1 ) &gt; self changeCountLimit 		ifTrue: 		[				self writeBack		].	" eigentlich braucht der Cache keine nextClusterID, aber damit die Checks nicht weinen, hier die nextClusterID pflegen "	(CatBFFile isSpecialFileNumber: fileNumber )		ifFalse: [ self nextClusterID: ( self nextClusterID max: fileNumber + 1 )].	^ super writeStreamOnFileNumber: fileNumber fileType: fileType</body></methods><methods><class-id>COAST.CatRMClientCC</class-id> <category>updating</category><body package="COASTClient">addOutstandingGlobalSeqNum: anInteger	(outstandingGlobalSeqNums includes: anInteger)		ifFalse: [ outstandingGlobalSeqNums add: anInteger ]</body><body package="COASTClient">canPerformMultipartUpdate: aCoastTransactionID receivedMultiParts: receivedMultiParts 	" true if the update can be performed now "	| newSeqNum updateSeqNum missing availablePart |	newSeqNum := aCoastTransactionID globalSeqNum.	(self globalSeqNum &gt;= newSeqNum 		and: [ (self outstandingGlobalSeqNums includes: newSeqNum) not ]) ifTrue: 			[	" we already know that ( prepareUpdate: will ignore this update) "				^ true 			].	log isEmpty ifFalse: 		[	" cant update now, because it might be necessary to roll back the log. and this cant be done if updates have been replayed "			^ false 		].	((missing := self lowestMissingGlobalSeqNum) notNil and: [ missing &lt; newSeqNum ]) ifTrue: 		[	" there's still missing some old agenda. we have to wait for that one first "			^ false 		].	availablePart := receivedMultiParts 				detect: [: loggedAgenda | loggedAgenda transactionID = aCoastTransactionID ]				ifNone: [ nil ].	^ availablePart notNil 		ifTrue: 		[	updateSeqNum := aCoastTransactionID globalSeqNum.			(updateSeqNum = (globalSeqNum + 1) or: [ updateSeqNum = self lowestMissingGlobalSeqNum ]) 				ifTrue: 				[	" this is the next agenda "					true 				]				ifFalse: 				[	" this is the an agenda  from the future, cannot perform it yet "					false 				] 		]		ifFalse: 		[	" no agenda received yet "			false 		]</body><body package="COASTClient">checkAndSendAliveMessage	globalSeqNum &gt; ( acknowledgedGlobalSeqNum + 50 ) ifTrue: 		[	"it's time to tell the mediator that we are still alive"			self sendAliveMessageToMediator		].</body><body package="COASTClient">checkLogAgainst: aCatRMLoggedTransactionAgenda 	"aCatCSAgenda was accepted and sent as update message.	See if local transactions commute with it. If not, they have to be rolled back"	| badID agenda |	badID := nil.	agenda := aCatRMLoggedTransactionAgenda agenda.	log reverseDo: 		[: entry | | entryAgenda |			entryAgenda := entry transaction combinedAgenda simpleAgendaForCluster: self cluster.			( agenda isCommutativeTo: entryAgenda loggedAgenda: aCatRMLoggedTransactionAgenda ) ifFalse: [ badID := entry transactionID ]	"Here we have one"		].	badID isNil ifFalse: 		[	"rollback everything up to the bad one"			"Transcript show: 'rollback necessary'; cr."			[ | ripOff |				ripOff := log removeLast.				localRolledBack add: ripOff transactionID.				self transactionManager rollBackTransaction: ripOff transaction.				localBase := localBase - 1.	"do not refer to this one any more"				CoastLog log: 					[	ripOff transactionID displayString , ' not commutative to ' , aCatRMLoggedTransactionAgenda transactionID displayString 							, ', falling back to local base ' , localBase printString					].				ripOff transactionID = badID			] whileFalse		].</body><body package="COASTClient">hasLog	^log isEmpty not</body><body package="COASTClient">lowestMissingGlobalSeqNum	^ outstandingGlobalSeqNums notEmpty		ifTrue: [ outstandingGlobalSeqNums first ]		ifFalse: [ nil ]</body><body package="COASTClient">outstandingGlobalSeqNums	^ outstandingGlobalSeqNums</body><body package="COASTClient">performUpdate: aCatRMLoggedTransactionAgenda 	"note: this update has to be already prepared using prepareUpdate: !!!"	| updateTransaction |	updateTransaction := CatRMUpdateSingleTransaction new.	updateTransaction simpleAgenda: aCatRMLoggedTransactionAgenda agenda.	updateTransaction clusterController: self.	self transactionManager rollForwardTransaction: updateTransaction.	self checkAndSendAliveMessage.	"it's time to tell the mediator that we are still alive"</body><body package="COASTClient">prepareUpdate: aCatRMLoggedTransactionAgenda	| newSeqNum |	log isEmpty ifFalse: [ self checkLogAgainst: aCatRMLoggedTransactionAgenda ].	COAST.CoastLog logDebug: [ 'Cluster ', self clusterID printString, ' prepare ', aCatRMLoggedTransactionAgenda transactionID printString ].	newSeqNum := aCatRMLoggedTransactionAgenda transactionID globalSeqNum.	^ (self updateGlobalSeqNum: newSeqNum)		ifTrue: [ 			" Update OK "			true		]		ifFalse: [ 			" This update is obsolete "			COAST.CoastLog logDebug: [ '	Update is obsolete (current: ', globalSeqNum printString ].			^ false		].</body></methods><methods><class-id>COAST.CatRMClientCC</class-id> <category>private: accessing</category><body package="COASTClient">clientID	^packetStation ownID</body><body package="COASTClient">transactionManager	^self clusterStub transactionManager</body></methods><methods><class-id>COAST.CatRMClientCC</class-id> <category>accessing</category><body package="COASTClient">acceptedLocalBase: anInteger 	acceptedLocalBase &gt; anInteger		ifTrue: [			" old information. (may happen if the accept of a pesimistic transaction is handled before the accept of a previous optimistic transaction) "			CoastLog logDebug: 				[	'Ignored acceptedLocalBase ' , anInteger printString , ' of cluster ' , self clusterID printString 						, ', acceptedLocalBase is already ' , acceptedLocalBase printString				].			^ self		].	acceptedLocalBase := anInteger.	localBase &lt; acceptedLocalBase 		ifTrue: 		[	" patch the local base (necessary if the client handles the accept of a optimistic transaction 			after the reject of a pessimistic transaction that is based on the optimistic transaction)						see diagram below "						CoastLog logDebug: 				[	'Adjusted localBase (' , localBase printString , ') of cluster ' , self clusterID printString 						, ' to accepted localBase ' , acceptedLocalBase printString				].			localBase := acceptedLocalBase		]"Client				local		base	accepted		Mediator			ClientState localBase					0			0		0									0&gt; optimistic1		1					1			0						accepts (1,0)		1								1&gt; pessimistic2		2					2			1						rejects (2,1)			1								2&lt; reject2						0&lt; accept1 								1localBase &lt; acceptedBase, all transactions regarding this cluster will be rejected !&gt; pessimistic3		3						3			0						reject(3,0): ClientState localBase = 1 != 0								3						&lt; reject3						0&gt; pessimistic4		4						4			0						reject(4,0): ClientState localBase = 1  != 0								4						&lt; reject4						0.... "</body><body package="COASTClient">cluster: aCatCSCluster 	super cluster: aCatCSCluster.	self globalSeqNum: self clusterStub modificationNumber.</body><body package="COASTClient">globalSeqNum	^globalSeqNum</body><body package="COASTClient">globalSeqNum: anInteger	globalSeqNum &gt; anInteger		ifTrue: [ 			self error: 'Cluster ', self clusterID printString, ': New global seqnum ', anInteger printString, 				' is lower than current (', globalSeqNum printString, ')'		].	globalSeqNum := anInteger</body><body package="COASTClient">packetStation: aCatRMClientPS	packetStation := aCatRMClientPS</body><body package="COASTClient">rollForwardDebugString	| stream |	stream := String new writeStream.	stream nextPutAll: 'Client '.	self clientID printOn: stream.	stream nextPutAll: ' Roll forward cluster '.	self clusterID printOn: stream.	stream nextPutAll: ' seq '.	self globalSeqNum printOn: stream.	^ stream contents</body><body package="COASTClient">unloadStrategyInformation	^ unloadStrategyInformation</body><body package="COASTClient">unloadStrategyInformation: aUnloadStrategyInformation 	unloadStrategyInformation := aUnloadStrategyInformation.</body><body package="COASTClient">updateGlobalSeqNum: newSeqNum	" Update the globalSeqNum. Returns true if this was new information,	false if the update was ignored "	| wasWaitingFor |	wasWaitingFor := outstandingGlobalSeqNums remove: newSeqNum ifAbsent: [ nil ].	wasWaitingFor notNil		ifTrue: [ 			" filled a gap "			self updateModificationNumber.			^ true 		].	newSeqNum &gt; globalSeqNum		ifTrue: [			" new, higher seq num. Remember gaps "			globalSeqNum + 1 to: newSeqNum - 1 do: [ : missing | self addOutstandingGlobalSeqNum: missing ].			self globalSeqNum: newSeqNum	.			self updateModificationNumber.			^ true.		].	" obsolete "	^ false</body><body package="COASTClient">updateModificationNumber	| newModNum |	self outstandingGlobalSeqNums isEmpty		ifTrue: [ 			" updates up to globalSeqNum have been performed "			self cluster modificationNumber: self globalSeqNum 		]		ifFalse: [			" check lowest seqNum with complete updates "			newModNum := self lowestMissingGlobalSeqNum - 1.			" newModNum must be equal or newer than the current modification number "			self cluster modificationNumber: newModNum 		].</body></methods><methods><class-id>COAST.CatRMClientCC</class-id> <category>receiving</category><body package="COASTClient">handleAcceptMessage: aCatRMAcceptMessage	| entry targetGlobal acceptedID |	acceptedID := aCatRMAcceptMessage transactionID.	(localRolledBack includes: acceptedID)		ifTrue: [			localRolledBack remove: acceptedID.			CoastLog log: 'Ignored accept of locally rolled back transaction ', acceptedID printString.			^ self		].	log isEmpty 		ifTrue: [ self transactionManager statusError: 'ClientCC transaction log is empty, cannot handle accept of ', acceptedID printString ].	entry := log removeFirst.	self transactionManager decreaseOutstandingTransactionsCount.	(entry transactionID = acceptedID)		ifFalse: [ self transactionManager statusError: 'ClientCC expected accept of ', entry transactionID printString, ' , received ', acceptedID printString ].	targetGlobal := acceptedID globalSeqNum.	self updateGlobalSeqNum: targetGlobal.	self acceptedLocalBase: acceptedID localSeqNum.	entry transaction commited.	self hasLog ifFalse: [ self clusterManager performPendingUpdates ]</body><body package="COASTClient">handleMultiPartUpdateMessage: aCatRMMultiPartUpdateMessage	"ask the cluster manager to handle it"	clusterManager		processMultiPartUpdate: aCatRMMultiPartUpdateMessage loggedTransactionAgenda		withRequiredIDs: aCatRMMultiPartUpdateMessage allTransactionIDs.</body><body package="COASTClient">handleRejectMessage: aCatRMRejectMessage 	"a transaction in the log was rejected"	"Transcript show: ('reject ', aCatRMRejectMessage transactionID localSeqNum printString); cr."	"if the transaction is still in the log the whole log is bad and has to be rollbacked"	self transactionManager decreaseOutstandingTransactionsCount.	log isEmpty ifFalse:	[		log first transactionID = aCatRMRejectMessage transactionID 			ifTrue: [self rollbackLog]	].	self hasLog ifFalse: [ self clusterManager performPendingUpdates ]</body><body package="COASTClient">sendAliveMessageToMediator	"tell the mediator what we have seen so far"	| msg |	msg := CatRMAliveMessage				globalSeqNum: globalSeqNum				clientID: self clientID				receiver: self clusterStub clusterLocator.	packetStation transmitMessage: msg.	acknowledgedGlobalSeqNum := globalSeqNum</body></methods><methods><class-id>COAST.CatRMClientCC</class-id> <category>local transactions</category><body package="COASTClient">nextTransactionID	| newID |	newID := CatRMTransactionID new.	localSeqNum := localSeqNum + 1.	newID localSeqNum: localSeqNum.	newID clientID: self clientID.	newID clusterLocator: (CatCSClusterLocator id: self clusterStub id volume: self clusterManager volume).	newID basedOnGlobal: globalSeqNum.	newID basedOnLocal: localBase.	localBase := localSeqNum.	^newID</body><body package="COASTClient">recordLastWishTransaction: aTransaction	"a last wish transaction has to be directly forwarded to the mediator"	"in comparison to regular transactions avoid all the bookkeeping and make that thingy as invisible as possible"	"ATTENTION: this is for transactions that touch only one cluster"	| newEntry newTID newLoggedAgenda msg |	newTID  := CatRMTransactionID new.	newTID localSeqNum: localSeqNum.	newTID clientID: self clientID.	newTID clusterLocator: (CatCSClusterLocator id: self clusterStub id volume: self clusterManager volume).	newTID basedOnGlobal: globalSeqNum.	newTID basedOnLocal: localBase.	newEntry := CatRMLoggedTransaction new.	newEntry transaction: aTransaction.	newEntry transactionID: newTID.	newLoggedAgenda := CatRMLoggedTransactionAgenda new.	newLoggedAgenda transactionID: newTID.	newLoggedAgenda agenda: (aTransaction combinedAgenda simpleAgendaForCluster: self cluster).	msg := CatRMLastWishMessage new.	msg loggedTransactionAgenda: newLoggedAgenda.	packetStation transmitMessage: msg.</body><body package="COASTClient">recordOptimisticTransaction: aTransaction 	" optimistic transaction, mediator mode "	"a successful local transaction has to be recorded in the agenda log and forwarded to the mediator"	"ATTENTION: this is for transactions that touch only one cluster"	| newEntry newLoggedAgenda msg |	newLoggedAgenda := CatRMLoggedTransactionAgenda transaction: aTransaction inClusterController: self.	newEntry := CatRMLoggedTransaction new.	newEntry transaction: aTransaction.	newEntry transactionID: newLoggedAgenda transactionID.	log addLast: newEntry.	aTransaction transactionManager increaseOutstandingTransactionsCount.	msg := CatRMTryMessage new.	msg applicationLog: aTransaction applicationLog.	aTransaction flushApplicationLog.	msg loggedTransactionAgenda: newLoggedAgenda.	packetStation transmitMessage: msg.	acknowledgedGlobalSeqNum := globalSeqNum.	^ #optimistic</body><body package="COASTClient">returnToPreviousTransactionID	localBase := acceptedLocalBase.</body><body package="COASTClient">rollbackLog	"rollback everything in the log - unfortunately"	[log isEmpty]		whileFalse: [ self transactionManager rollBackTransaction: log removeLast transaction ].		"fall down to the accepted base"	localBase := acceptedLocalBase</body><body package="COASTClient">tryAndTell: aTransaction 	| aTryAndTellMessage involvedClusterControllers tryResponse involvedDict |	aTryAndTellMessage := CatRMTryAndTell new.	aTryAndTellMessage applicationLog: aTransaction applicationLog.	aTransaction flushApplicationLog.	involvedClusterControllers := aTransaction combinedAgenda involvedClusters collect: [: eachCluster | eachCluster clusterController ].	COAST.CoastLog logDebug: [ 'try and tell ' , self clientID printString ].	involvedClusterControllers do: [: eachClusterController | eachClusterController tryAndTell: aTransaction to: aTryAndTellMessage ].	tryResponse := clusterManager volumeManager requestService: aTryAndTellMessage usingPacketStation: packetStation.	^ tryResponse isNil 		ifTrue: 		[	"there is no usable result at all, so assume a failure"			COAST.CoastLog logDebug: [ 'No result for try and tell ' , self clientID printString ].			false		]		ifFalse: 		[	tryResponse didAccept 				ifTrue: 				[	" update accepted "					COAST.CoastLog logDebug: [ 'try and tell accepted: ' , self clientID printString ].					tryResponse rollReplacementsWithCC: self.					aTryAndTellMessage loggedTransactionAgendas 						with: tryResponse transactionIDs 						do: [: agenda : transactionID | agenda transactionID globalSeqNum: transactionID globalSeqNum ].					involvedDict := Dictionary new: involvedClusterControllers size.					involvedClusterControllers do: [: cc | involvedDict at: cc clusterID put: cc ].					tryResponse transactionIDs do: 						[: transactionID | | cc |							cc := involvedDict at: transactionID clusterLocator id ifAbsent: [ nil ].							cc notNil 								ifTrue: 								[	cc acceptedLocalBase: transactionID localSeqNum;										updateGlobalSeqNum: transactionID globalSeqNum								]						]				]				ifFalse: 				[	" update rejected "					COAST.CoastLog logDebug: [ 'try and tell rejected: ' , self clientID printString ].					involvedClusterControllers do: [: eachClusterController | eachClusterController returnToPreviousTransactionID ]				].			tryResponse didAccept		]</body><body package="COASTClient">tryAndTell: aTransaction to: aTryAndTellMessage 	| newLoggedAgenda |	newLoggedAgenda := CatRMLoggedTransactionAgenda transaction: aTransaction inClusterController: self.	aTryAndTellMessage addLoggedTransactionAgenda: newLoggedAgenda.	COAST.CoastLog logDebug: [ '  client tid ' , newLoggedAgenda transactionID printString ].</body></methods><methods><class-id>COAST.CatRMClientCC</class-id> <category>single part updates</category><body package="COASTClient">handleUpdateMessage: aCatRMUpdateMessage 	"we received a single (optimistic, one cluster) update message"	"check if we can update now or if we have to wait for some multi-part update to finish"	| loggedTransactionAgenda |	self clusterManager performPendingUpdates.	"try this first"	loggedTransactionAgenda := aCatRMUpdateMessage loggedTransactionAgenda.	(self performSinglePartUpdateIfNeeded: loggedTransactionAgenda) ifFalse: 		[	" need to wait for the missing updates first "			clusterManager delayUpdate: loggedTransactionAgenda.			CoastLog log: [ 'handleUpdateMessage: delayed' ] 		]</body><body package="COASTClient">performSinglePartUpdateIfNeeded: loggedTransactionAgenda 	| updateSeqNum updateNeeded |	updateSeqNum := loggedTransactionAgenda transactionID globalSeqNum.	(self globalSeqNum &gt;= updateSeqNum and: [ (self outstandingGlobalSeqNums includes:updateSeqNum) not ])		ifTrue: [	" we already know that one "			^ true 		].	log isEmpty ifFalse: 		[	" cant update now, because it might be necessary to roll back the log. and this cant be done if updates have been replayed "			^ false 		].	^ (updateSeqNum = (globalSeqNum + 1) or: [ self lowestMissingGlobalSeqNum = updateSeqNum ]) 		ifTrue: 		[	"ok - update it now"			updateNeeded := self prepareUpdate: loggedTransactionAgenda.			updateNeeded ifTrue: [ self performUpdate: loggedTransactionAgenda ].			true 		]		ifFalse: 		[	" need to wait for the missing updates first "			false 		]</body></methods><methods><class-id>COAST.CatRMClientCC</class-id> <category>release</category><body package="COASTClient">releaseClusterAndNotifyMediator: doNotify	"tell the mediator that I do not need this cluster any more"	| msg clusterLocator |	doNotify ifTrue:	[		clusterLocator := CatCSClusterLocator id: self clusterStub id volume: self clusterManager volume.		msg := CatRMClusterReleaseMessage clusterLocator: clusterLocator.		clusterManager volumeManager requestService: msg usingPacketStation: packetStation.	].	super releaseClusterAndNotifyMediator: doNotify.</body></methods><methods><class-id>COAST.CatRMClientCC</class-id> <category>initialize</category><body package="COASTClient">initialize	super initialize.	log := OrderedCollection new: 20.	outstandingGlobalSeqNums := SortedCollection new.	localSeqNum := 0.	localBase := 0.	globalSeqNum := 0.	acceptedLocalBase := 0.	acknowledgedGlobalSeqNum := 0.	localRolledBack := Set new.</body></methods><methods><class-id>COAST.CatRMClientCC</class-id> <category>printing</category><body package="COASTClient">printOn: stream 	super printOn: stream.	self cluster hasNonWeakObservers 		ifTrue: [ stream nextPutAll: ' &lt;observed&gt;' ].	self cluster isIndexCluster 		ifTrue: [ ^ stream nextPutAll: ' &lt;index&gt;' ].	unloadStrategyInformation notNil 		ifTrue: 		[	stream nextPutAll: ' unload info:  '.			unloadStrategyInformation printOn: stream		].</body></methods><methods><class-id>COAST.WeakFrameResolver</class-id> <category>accessing</category><body package="COASTClient">clusterID	^ clusterID</body><body package="COASTClient">clusterID: newClusterID 	clusterID := newClusterID.</body><body package="COASTClient">clusterLocator	^ CatCSClusterLocator id: self clusterID volume: self volume</body><body package="COASTClient">clusterManager	^ clusterManager</body><body package="COASTClient">clusterManager: newClusterManager 	clusterManager := newClusterManager.</body><body package="COASTClient">getCluster	( clusterManager hasCluster: clusterID ) ifTrue: [ CoastTriedToLoadClusterTwiceError raiseForClusterID: clusterID].	^ clusterManager getCluster: clusterID</body><body package="COASTClient">notifyFastRead: aFrame	" irrelevant "</body><body package="COASTClient">propagateNonWeakObserver	" Cluster des Frames nicht geladen -&gt; ignorieren "</body><body package="COASTClient">transactionManager	^ self clusterManager transactionManager</body><body package="COASTClient">volume	^ clusterManager volume</body><body package="COASTClient">volumeManager	^ clusterManager volumeManager</body></methods><methods><class-id>COAST.WeakFrameResolver class</class-id> <category>instance creation</category><body package="COASTClient">clusterManager: clusterManager clusterID: clusterID 	^ ( self new ) clusterManager: clusterManager;		clusterID: clusterID;		yourself</body></methods><methods><class-id>COAST.CoastPerformanceCounterSection</class-id> <category>private</category><body package="COASTClient">counterAtPath: aCollectionOfKeys index: index	" Liefert das Counter-Objekt "	| nextKey node |	^ index &lt;= aCollectionOfKeys size		ifTrue: 		[	nextKey := (aCollectionOfKeys at: index) coastStatisticsKey.			node := self nodes at: nextKey ifAbsent: [ nil ].			node notNil 				ifTrue: [ node counterAtPath: aCollectionOfKeys index: index + 1 ]				ifFalse: [ nil ]		]		ifFalse: [ self nodes at: self counterLeafKey ifAbsent: [ nil ]]</body><body package="COASTClient">counterLeaf	^ self nodes at: self counterLeafKey ifAbsent: [ nil ]</body><body package="COASTClient">counterLeafKey	^ #_counter_</body><body package="COASTClient">ensureCounterAtPath: aCollectionOfKeys index: index unit: aUnitSymbol 	" Counter erhÃ¶hen. Wird angelegt wenn noch nicht vorhanden.	Liefert das Counter-Objekt " 	| nextKey node |	^ index &lt;= aCollectionOfKeys size		ifTrue: [			nextKey := (aCollectionOfKeys at: index) coastStatisticsKey.			node := self nodes at: nextKey ifAbsentPut: [ CoastPerformanceCounterSection key: nextKey parentNode: self ].			node ensureCounterAtPath: aCollectionOfKeys index: index + 1 unit: aUnitSymbol 		]		ifFalse: [ 			" damit es keine Konflikte mit Unterabschnitten gibt, bekommt der Counter seinen eigenen, speziellen SchlÃ¼ssel "			self nodes at: self counterLeafKey ifAbsentPut: [ CoastPerformanceCounter unitSymbol: aUnitSymbol parentNode: self ].		]</body><body package="COASTClient">nodes	^ nodes ifNil: [ nodes := Dictionary new ].</body><body package="COASTClient">printKeyOn: aStream 	| frame |	self key isFrameOrFrameReference 		ifTrue: 		[	frame := self clusterManager resolveFrameReference: self key.			frame notNil 				ifTrue: [ frame deleteContextDisplayStringOn: aStream ]				ifFalse: 				[	aStream						print: self key;						nextPutAll: '('; nextPutAll: ( #deletedMLS &lt;&lt; #mls &gt;&gt; 'deleted' ) asString; nextPutAll: ')'				]		]		ifFalse: 		[	self key = #localFrame 				ifTrue: [ aStream nextPutAll: '(Local objects)' ]				ifFalse: [ aStream nextPutAll: self key ]		].</body></methods><methods><class-id>COAST.CoastPerformanceCounterSection</class-id> <category>accessing - compatibility</category><body package="COASTClient">quantity	^ self counterLeaf ifNotNil: [ : leaf | leaf quantity ]</body><body package="COASTClient">subCounters	| counterNodes |	counterNodes :=  self nodes asSet.	self counterLeaf ifNotNil: [ : counter | counterNodes remove: counter ].	^ counterNodes</body><body package="COASTClient">ticks	^ self counterLeaf ifNotNil: [ : leaf | leaf ticks ]</body><body package="COASTClient">unitSymbol	^ self counterLeaf ifNotNil: [ : leaf | leaf unitSymbol ]</body></methods><methods><class-id>COAST.CoastPerformanceCounterSection</class-id> <category>accessing</category><body package="COASTClient">counterAtPath: aCollectionOfKeys 	" Liefert das Counter-Objekt "	| nextKey node |	^ aCollectionOfKeys notEmpty 		ifTrue: 		[	nextKey := aCollectionOfKeys first coastStatisticsKey.			node := self nodes at: nextKey ifAbsent: [ nil ].			node notNil 				ifTrue: [ node counterAtPath: ( aCollectionOfKeys copyFrom: 2 to: aCollectionOfKeys size )]				ifFalse: [ nil ]		]		ifFalse: [ self nodes at: self counterLeafKey ifAbsent: [ nil ]]</body><body package="COASTClient">key	" key that describes the measured quantity.	^ frame reference or symbol "	^ key</body><body package="COASTClient">key: aFrameReferenceOrSymbol	" key that describes the measured quantity. "	key := aFrameReferenceOrSymbol.</body></methods><methods><class-id>COAST.CoastPerformanceCounterSection</class-id> <category>printing</category><body package="COASTClient">displayString	^ self streamContents: [ : stream | self printKeyOn: stream. ]</body><body package="COASTClient">logOn: aStream duration: duration indent: indent 	indent timesRepeat: [ aStream tab ].	aStream nextPutAll: self displayString.	aStream nextPutAll: ': '.	( self nodes sortedBy: [: node | node displayString ]) do: 		[: subCounter |			aStream cr.			subCounter logOn: aStream duration: duration indent: indent + 1		].</body></methods><methods><class-id>COAST.CoastPerformanceCounterSection class</class-id> <category>instance creation</category><body package="COASTClient">key: aFrameReferenceOrSymbol parentNode: aCounterNode 	^ self new key: aFrameReferenceOrSymbol;		parentNode: aCounterNode;		yourself</body></methods><methods><class-id>COAST.CoastInteractiveClientConfiguation</class-id> <category>parameters - memory</category><body package="COASTClient">defaultKeepSize	^ 150</body><body package="COASTClient">defaultMaxUnloadTime	^ 5000</body><body package="COASTClient">defaultUnloadSize	^ 300</body><body package="COASTClient">growthRegimeMarginFactor	" interactive clients usually are not configured and should not use all available memory "	^ 0.5</body></methods><methods><class-id>COAST.CoastInteractiveClientConfiguation</class-id> <category>config</category><body package="COASTClient">logCreatedMemoryPolicy: memoryPolicy	" don't care "</body></methods><methods><class-id>COAST.SegmentedUnresolvedFramesRegistry</class-id> <category>public interface</category><body package="COASTClient">atClusterID: clusterID put: frame 	frame cellContainer: ( self frameResolverAt: clusterID ).	weakFramesSet add: frame.</body><body package="COASTClient">atFrameID: frameID clusterID: clusterID ifAbsent: aBlock 	| frame |	frame := weakFramesSet frameOrNilWithClusterID: clusterID frameID: frameID.	^ frame ifNil: aBlock</body><body package="COASTClient">compressWhile: whileBlock 	"Ziel: leere Teile wegwerfen, kleine Teile wieder zusammenfassen (ohne overflow)"	weakFramesSet compressWhile: whileBlock.</body><body package="COASTClient">disresolveAll: aDictionary clusterID: clusterID 	weakFramesSet disresolveAll: aDictionary clusterID: clusterID resolver: ( self frameResolverAt: clusterID ).</body><body package="COASTClient">removeFrameID: frameID clusterID: clusterID ifAbsent: aBlock 	^ ( weakFramesSet removeFrameWithClusterID: clusterID frameID: frameID ) ifNil: aBlock</body></methods><methods><class-id>COAST.SegmentedUnresolvedFramesRegistry</class-id> <category>accessing</category><body package="COASTClient">exactNumberOfFrames	weakFramesSet updateTally.	^ self numberOfFrames</body><body package="COASTClient">numberOfFrames	^ weakFramesSet size</body></methods><methods><class-id>COAST.SegmentedUnresolvedFramesRegistry</class-id> <category>initialize</category><body package="COASTClient">initialize	super initialize.	weakFramesSet := WeakSegmentedFrameSet new.</body></methods><methods><class-id>COAST.SegmentedUnresolvedFramesRegistry</class-id> <category>printing</category><body package="COASTClient">printOn: stream 	self numberOfFrames printOn: stream.	stream nextPutAll: ' unresolved Frames'.</body></methods><methods><class-id>COAST.SegmentedUnresolvedFramesRegistry</class-id> <category>copying</category><body package="COASTClient">postCopy	super postCopy.	weakFramesSet := weakFramesSet copy.</body></methods><methods><class-id>COAST.CoastLocalClientClusterManager</class-id> <category>saving</category><body package="COASTClient">autoSaveWaitForTimeout	"no whileFalse used to be able to modify the living method ;-)"	| saveSeconds waitSeconds |	saveSeconds := autosaveTime - Time secondClock max: 0.	waitSeconds := saveSeconds min: 30.	( Delay forSeconds: waitSeconds ) wait.	Time secondClock &gt;= autosaveTime ifFalse: [ self autoSaveWaitForTimeout ]</body><body package="COASTClient">autoSaveWhenPossible	"fork this, problems will kill the autosave process (THIS process) from the forked process below (saveProcess)	the forked process saveProcess must be able to finish his dirty job	to avoid spawning too many processes, synch them with a semaphore	to avoid ever waiting for sequence end, pass gate or use watchDog to kill saveProcess 	only saveProcess or watchDog can pass the gate, the lucky one will kill the waiting one"	"if all works like expected, the code runs like this simplified linear version:	self transactionManager transactionSequenceExclusiveUseDo: [ self saveAllModifiedClusters ]		which does not work if			- save will crash			- transactionSequence will never terminate"	| sync gate saveProcess watchDog |	sync := Semaphore new.	gate := Semaphore new.	watchDog := nil.	saveProcess :=		[				[	self transactionManager transactionSequenceExclusiveUseDo: 					[	"do not save between sequences"						gate wait.						watchDog terminate.						self saveAllModifiedClusters					]			] ensure: [ sync signal ]		] fork.	watchDog :=		[	"to be on the very save sige, wait for max. 60 Seconds"			( Delay forSeconds: 60 ) wait.			self exclusiveUseDo: 				[	gate wait.	"only kill it, when saveProcess has not passed the gate"					saveProcess terminate				]		] fork.	gate signal.	"wait until save is done"	sync wait</body><body package="COASTClient">hasModifiedClusters	^ self exclusiveUseDo: [ clusterController values contains: [: cc | cc modified ]]</body><body package="COASTClient">saveAllModifiedClusters	| success |	success := super saveAllModifiedClusters.	success ifTrue: [ autosaveTime := Time secondClock + self autoSaveTimeInterval ].	^ success</body><body package="COASTClient">setAutosaveTime: seconds 	super setAutosaveTime: seconds.	autoSaveProcess isNil ifTrue: [ self startAutoSave ]</body><body package="COASTClient">startAutoSave	autoSaveProcess :=		[				[	self autoSaveWaitForTimeout.				self hasModifiedClusters 					ifTrue: [ self autoSaveWhenPossible ]					ifFalse: [ autosaveTime := Time secondClock + self autoSaveTimeInterval ].				self storageInterface optimizeInMemory			] repeat		] forkAt: Processor activePriority + 1.	autoSaveProcess name: self processNamePrefix , ' - autosave'.</body><body package="COASTClient">stopAutosave	self exclusiveUseDo: [		autoSaveProcess notNil 			ifTrue: [				autoSaveProcess terminate. 				autoSaveProcess := nil]].</body></methods><methods><class-id>COAST.CoastLocalClientClusterManager</class-id> <category>initialize-release</category><body package="COASTClient">emergencyShutDown	self stopAutosave.	super emergencyShutDown.</body><body package="COASTClient">releaseAllClusters	( clusterController includesKey: 0 ) ifTrue: [ self removeLastWishesFor: 0 ].	self stopAutosave.	super releaseAllClusters.</body><body package="COASTClient">shutDown	self exclusiveUseDo: [		self stopAutosave.	].	super shutDown.</body></methods><methods><class-id>COAST.CoastLocalClientClusterManager</class-id> <category>testing</category><body package="COASTClient">isLocalClient	^true</body></methods><methods><class-id>COAST.CoastLocalClientClusterManager</class-id> <category>cluster unload - private</category><body package="COASTClient">canUnloadCluster: aCluster 	^ (super canUnloadCluster: aCluster)		and: [ aCluster clusterController modified not ]</body></methods><methods><class-id>COAST.CoastLocalClientClusterManager</class-id> <category>accessing</category><body package="COASTClient">collectGarbage	self exclusiveUseDo: 		[ | garbageCollector nf |			self releaseAllClusters.			self storageInterface startUpStorageAccessorFrom: self.			ObjectMemory globalCompactingGC.			( nf := unresolvedFrames exactNumberOfFrames ) = 0 				ifFalse: [ self error: ( 'Garbage collection not possible, &lt;1p&gt; frames are still referenced' expandMacrosWith: nf )].			garbageCollector := CatCSGarbageCollector newWithManager: self inVolume: volume.			garbageCollector collectGarbage.			self releaseAllClusters		].</body><body package="COASTClient">processNamePrefix	| stream |	stream := String new writeStream.	stream nextPutAll: 'CoastClient[-/'.	stream nextPutAll: volume.	stream nextPut: $].	^ stream contents</body><body package="COASTClient">recordApplicationLog: aCatCSApplicationLog	self storageInterface addToApplicationLog: aCatCSApplicationLog</body></methods><methods><class-id>COAST.CoastLocalClientClusterManager</class-id> <category>upload</category><body package="COASTClient">uploadVolumeToHost: hostname toHostVolume: hostVolumename remotePassword: remotePassword 	^CoastMediatorStub 		sendTo: hostname		requestID: CoastConstant uploadVolumeID		andStrings: ( Array with: remotePassword with: hostVolumename )		sendStreamDo: [: sendStream | self storageInterface sendVolumeTo: sendStream ]		receiveStreamDo: [: receiveStream | CoastMediatorStub checkValidResponseFrom: receiveStream ].</body></methods><methods><class-id>COAST.CoastLocalClientClusterManager</class-id> <category>test and set</category><body package="COASTClient">validTestAndSet: key oldValue: oldValue newValue: newValue 	^ testAndSet testAndSet: key oldValue: oldValue newValue: newValue</body></methods><methods><class-id>COAST.CoastLocalClientClusterManager</class-id> <category>blob handling</category><body package="COASTClient">loadFromID: clusterIDInteger toStream: targetStream bytesOnly: bytesOnly	( storageInterface blobExists: clusterIDInteger )		ifTrue: [ 	storageInterface transferBlob: clusterIDInteger to: targetStream bytesOnly: bytesOnly ]		ifFalse: [ CoastError raiseSignal: 'file not found: ', clusterIDInteger]</body></methods><methods><class-id>COAST.CacheDisabledAccessor</class-id> <category>interface</category><body package="COASTClient">basicWriteBackCluster: clusterController	"don't care"</body><body package="COASTClient">closeCache	"don't care"</body><body package="COASTClient">invalidateAccessFor: clusterIDInteger	"don't care"</body><body package="COASTClient">modificationNumberFor: clusterIDInteger	"no cache - no usable modification number"	^0</body></methods><methods><class-id>COAST.CacheDisabledAccessor</class-id> <category>interface - blobs</category><body package="COASTClient">bytesAtID: clusterIDInteger	self shouldNotImplement</body><body package="COASTClient">clusterFromCacheHitMessage: cacheHitMessage	self shouldNotImplement</body><body package="COASTClient">copyBytesAtID: clusterIDInteger  toFile: filename	self shouldNotImplement</body><body package="COASTClient">hasBytesAtID: clusterIDInteger	^false</body><body package="COASTClient">writeBytes: bytes blobID: blobIDInteger	"don't care"</body><body package="COASTClient">writeFile: file blobID: blobIDInteger	"don't care"</body></methods><methods><class-id>COAST.DisabledUnloadStrategy</class-id> <category>load / unload</category><body package="COASTClient">notifyCacheLoad: clusterID 	"ignore"</body><body package="COASTClient">notifyClusterAccess: clusterIDInteger 	"ignore"</body><body package="COASTClient">notifyExternalFileLoad: clusterID 	"ignore"</body><body package="COASTClient">notifyLoadCluster: clusterIDInteger 	"ignore"</body><body package="COASTClient">notifyUnloadCluster: cluster 	"ignore"</body><body package="COASTClient">unloadableClustersWithout: someImportantClusters	^OrderedCollection new.</body></methods><methods><class-id>COAST.CoastPerformanceCounter</class-id> <category>accessing</category><body package="COASTClient">addQuantity: aNumber unit: aUnitSymbol 	| normalizedQuantity |	normalizedQuantity := self unit normalizeQuantity: aNumber unit: aUnitSymbol .	self quantity: self quantity + normalizedQuantity.	self ticks: self ticks + 1.</body><body package="COASTClient">counterAtPath: aCollectionOfKeys 	^ self</body><body package="COASTClient">key	^ self parentNode key</body><body package="COASTClient">quantity	^ quantity</body><body package="COASTClient">quantity: aNumber 	quantity := aNumber.</body><body package="COASTClient">quantity: aQuantity ticks: aNumberOfTicks unit: aUnitSymbol 	| normalizedQuantity |	normalizedQuantity := self unit normalizeQuantity: aQuantity unit: aUnitSymbol .	self quantity: normalizedQuantity.	self ticks: aNumberOfTicks</body><body package="COASTClient">ticks	^ ticks</body><body package="COASTClient">ticks: aTicks 	ticks := aTicks.</body><body package="COASTClient">unit	^ unit</body><body package="COASTClient">unit: aUnit 	unit := aUnit.</body><body package="COASTClient">unitSymbol	^ self unit unitSymbol</body><body package="COASTClient">unitSymbol: aUnitSymbol	unit := CoastPerformanceUnit registeredUnitAt: aUnitSymbol.</body></methods><methods><class-id>COAST.CoastPerformanceCounter</class-id> <category>initialize-release</category><body package="COASTClient">initialize	super initialize.	ticks := 0.	quantity := 0.</body></methods><methods><class-id>COAST.CoastPerformanceCounter</class-id> <category>printing</category><body package="COASTClient">displayString	^ self streamContents: [ : stream | self logOn: stream ]</body><body package="COASTClient">logOn: aStream duration: duration indent: indent 	indent timesRepeat: [ aStream tab ].	self logQuantityOn: aStream duration: duration.</body><body package="COASTClient">logQuantityOn: aStream duration: duration 	self unit printQuantity: self quantity ticks: self ticks duration: duration on: aStream</body><body package="COASTClient">logValueOn: aStream timeDelta: timeDelta 	self class printQuantity: self value unit: self unit on: aStream.	self isDurationUnit 		ifTrue: 		[	aStream nextPutAll: ' / Events: '.			self ticks printOn: aStream.			aStream nextPutAll: ',  Avg: '.			self class printQuantity: ( self value / self ticks ) asFloat unit: self unit on: aStream		]		ifFalse: 		[	timeDelta &gt; 0 				ifTrue: 				[	self value ~= self ticks 						ifTrue: 						[	aStream nextPutAll: ' / Events: '.							self ticks printOn: aStream						].					aStream nextPutAll: ', '.					( self value * 1000 / timeDelta ) asFloat printOn: aStream.					aStream nextPutAll: '/second'				]		].</body><body package="COASTClient">printOn: aStream 	self unit printQuantity: self quantity on: aStream</body></methods><methods><class-id>COAST.CoastPerformanceCounter</class-id> <category>private</category><body package="COASTClient">counterAtPath: aCollectionOfKeys index: index	^ self</body><body package="COASTClient">ensureCounterAtPath: aCollectionOfKeys index: index unit: aUnitSymbol</body><body package="COASTClient">isDurationUnit	^ self class isDurationUnit: unit</body></methods><methods><class-id>COAST.CoastPerformanceCounter class</class-id> <category>instance creation</category><body package="COASTClient">unitSymbol: aUnitSymbol parentNode: aCounterNode 	^ self new unitSymbol: aUnitSymbol; parentNode: aCounterNode ;yourself</body></methods><methods><class-id>COAST.CoastPerformanceCounter class</class-id> <category>utilities</category><body package="COASTClient">isDurationUnit: unit	^ #(msecs microseconds milliseconds seconds) includes: unit</body><body package="COASTClient">printQuantity: quantity unit: unit on: stream 	| unitToPrint quantityToPrint |	unitToPrint := unit.	quantityToPrint := quantity.	unitToPrint = #msecs 		ifTrue: [ unitToPrint := #milliseconds ].	( unitToPrint = #microseconds and: [ quantityToPrint &gt; 1000 ]) 		ifTrue: 		[	quantityToPrint := ( quantityToPrint / 1000 ) rounded.			unitToPrint := #milliseconds		].	( unitToPrint = #milliseconds and: [ quantityToPrint &gt; 10000 ]) 		ifTrue: 		[	quantityToPrint := ( quantityToPrint / 1000 ) rounded.			unitToPrint := #seconds		].	( unitToPrint = #seconds and: [ quantityToPrint &gt; 60 ]) 		ifTrue: [ stream nextPutAll: (Timestamp fromSeconds: quantityToPrint rounded) remainingPrintString ]		ifFalse: 		[	quantityToPrint printOn: stream.			unitToPrint notNil ifTrue: [ stream space; nextPutAll: unitToPrint ].		].</body></methods><methods><class-id>COAST.CoastPerformanceUnitBytes class</class-id> <category>accessing</category><body package="COASTClient">unitSymbol	^ #bytes</body></methods><methods><class-id>COAST.CoastPerformanceUnitBytes class</class-id> <category>printing</category><body package="COASTClient">printQuantity: aQuantity on: aStream 	aQuantity coastShortByteSizePrintOn: aStream</body></methods><methods><class-id>COAST.CoastDomainUser</class-id> <category>accessing</category><body package="COASTClient">domainUser	"Use this to be able to display a domain user and an application user with the same user view."	^self</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>register</category><body package="COASTClient">activate	"make visible that i am active"	self ensureLocalCopy.	self isActive ifTrue: [ ^ self ].	self updateNetworkAddress.	self updateLastLogin.	self activateLastWish.	self isActive: true.</body><body package="COASTClient">activateLastWish	[ | transactionManager |		transactionManager := self transactionManager.		transactionManager notNil ifTrue: [ transactionManager lastWishTransactionDo: [ self isActive: false ]]	] fork</body><body package="COASTClient">deActivate		"inverse to activate"	self isActive: false.</body><body package="COASTClient">updateLastLogin	| lastLogonTime now |	lastLogonTime := self sharedCopy at: #lastLogonTime.	now := Timestamp now.	self sharedCopy at: #lastLogonTime set: now.	"this login time"	self localCopy at: #lastLogonTime set: lastLogonTime	"previous log in time"</body><body package="COASTClient">updateNetworkAddress	| serverAddress socketAddress |	serverAddress := self clusterManager networkHost.	serverAddress notNil ifTrue: [		serverAddress :=  [ IPSocketAddress hostAddressByName: serverAddress ]							on: OsInaccessibleError do: [ : ex | ex return: nil ].		].	self serverNetworkAddress: serverAddress.	" the PC possibly hasn't got any network socket software installed, so prepare for an error "	socketAddress := Error						handle: [ :ex | nil ]						do: [ IPSocketAddress hostAddressByName: SocketAccessor getHostname ].	self ownNetworkAddress: socketAddress.</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>accessing</category><body package="COASTClient">createLocalCopy	^ self species newLocal</body><body package="COASTClient">domainUser	^self at: #domainUser</body><body package="COASTClient">domainUser: anSCUser	self at: #domainUser set: anSCUser</body><body package="COASTClient">editorReuse	"Bring existing window in front, do not open new window"	^ true</body><body package="COASTClient">ensureLocalCopy	localCopy isNil 		ifTrue: 		[	localCopy := self createLocalCopy.			localCopy at: #sharedCopy set: self		].</body><body package="COASTClient">hostName	^self ownNetworkAddress notNil		ifTrue: [IPSocketAddress hostNameByAddress: self ownNetworkAddress]		ifFalse: [nil]</body><body package="COASTClient">interests	^self at: #interests</body><body package="COASTClient">isActive	" the user is only active if he's either in local usage mode or if the server	confirms that he's active "	^(self at: #isActive) == true</body><body package="COASTClient">isActive: aBoolean	self at: #isActive set: aBoolean</body><body package="COASTClient">localCopy	^self isLocal 		ifTrue: [self]		ifFalse: [localCopy]</body><body package="COASTClient">name	^self coastName</body><body package="COASTClient">name: aString	^self at: #coastName set: aString</body><body package="COASTClient">ownNetworkAddress	^self at: #ownNetworkAddress</body><body package="COASTClient">ownNetworkAddress: aHostname	self at: #ownNetworkAddress set: aHostname.</body><body package="COASTClient">previousLogin	^ self localCopy at: #lastLogonTime</body><body package="COASTClient">serverHostName	^self serverNetworkAddress notNil		ifTrue: [IPSocketAddress hostNameByAddress: self serverNetworkAddress]		ifFalse: [nil]</body><body package="COASTClient">serverNetworkAddress	^self at: #serverNetworkAddress</body><body package="COASTClient">serverNetworkAddress: aHostname	self at: #serverNetworkAddress set: aHostname.</body><body package="COASTClient">sharedCopy	^self isLocal 		ifTrue: [self fastAt: #sharedCopy]		ifFalse: [self]</body><body package="COASTClient">thisLoginTime	^ self sharedCopy at: #lastLogonTime</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>interests</category><body package="COASTClient">bringReuseableAppToTop: aCoastApplication	^ nil</body><body package="COASTClient">endAllInterests	"remove all currently active interests"	self interests copy do: [:i| self releaseInterestOn: i].</body><body package="COASTClient">expressInterestOn: aCoastModel	self at: #interests add: aCoastModel.</body><body package="COASTClient">releaseInterestOn: aCoastModel	self at: #interests remove: aCoastModel.</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>testing</category><body package="COASTClient">isUser	^true</body></methods><methods><class-id>COAST.CoastUser class</class-id> <category>slots</category><body package="COASTClient">domainUserSlot	^(self slotOfType: #singleValue)	range: CoastDomainUser.</body><body package="COASTClient">interestsSlot	^(self slotOfType: #set)		range: CoastApplicationModel;		invertsTo: #interestedUsers;		yourself</body><body package="COASTClient">isActiveSlot	^self slotOfType: #singleValue.</body><body package="COASTClient">lastLogonTimeSlot	^ ( self slotSingleValue )		range: Timestamp;		yourself</body><body package="COASTClient">localInterestsSlot	^(self slotOfType: #set)		range: CoastApplicationModel;		yourself</body><body package="COASTClient">ownNetworkAddressSlot	^self slotOfType: #singleValue.</body><body package="COASTClient">serverNetworkAddressSlot	^self slotOfType: #singleValue</body><body package="COASTClient">sharedCopySlot	^self slotOfType: #singleValue.</body></methods><methods><class-id>COAST.CoastPerformanceUnitDuration class</class-id> <category>accessing</category><body package="COASTClient">compatibleUnitSymbols	^ #(milliseconds msecs seconds)</body><body package="COASTClient">normalizeQuantity: aQuantity unit: aUnitSymbol 	aUnitSymbol = #microseconds 		ifTrue: [ ^ aQuantity ].	( aUnitSymbol = #milliseconds or: [ aUnitSymbol = #msecs ]) 		ifTrue: [ ^ aQuantity * 1000 ].	aUnitSymbol = #seconds 		ifTrue: [ ^ aQuantity * 1000000 ].	^ self normalizeUnknownUnit: aUnitSymbol</body><body package="COASTClient">unitSymbol	^ #microseconds</body></methods><methods><class-id>COAST.CoastPerformanceUnitDuration class</class-id> <category>printing</category><body package="COASTClient">printQuantity: aQuantity on: aStream 	aQuantity &lt;= 10000000  " bis zu 10 Sekunden als Millisekunden ausgeben "		ifTrue: 		[	aStream print: ( aQuantity / 1000 ) asFloat; space;				nextPutAll: ( #millisecondsMLS &lt;&lt; #mls &gt;&gt; 'milliseconds' ) asString		]		ifFalse: [ aStream nextPutAll: ( Timestamp fromMilliseconds: ( aQuantity / 1000 ) rounded ) remainingPrintString ].</body><body package="COASTClient">printQuantity: aQuantity ticks: ticks duration: duration on: aStream 	self printQuantity: aQuantity on: aStream.	aStream nextPutAll: ', Events: '.	ticks printOn: aStream.	aStream nextPutAll: ',  Avg: '.	self printQuantity: aQuantity / ticks on: aStream.</body></methods><methods><class-id>COAST.CoastPerformanceUnitNumber class</class-id> <category>accessing</category><body package="COASTClient">compatibleUnitSymbols	^ #(number topics)</body><body package="COASTClient">normalizeQuantity: aQuantity unit: aUnitSymbol 	" Zahlen sind Zahlen "	^ aQuantity</body><body package="COASTClient">unitSymbol	^ #number</body></methods><methods><class-id>COAST.CoastPerformanceUnitNumber class</class-id> <category>printing</category><body package="COASTClient">printQuantity: aQuantity on: aStream 	aStream print: aQuantity.</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>dumping</category><body package="COASTClient">addDumpInfoTo: aStream	super addDumpInfoTo: aStream.	aStream tab; nextPutAll: 'host '; nextPutAll: host printString; cr.</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>messages</category><body package="COASTClient">addToMessageQueue: aCatRMMessage	aCatRMMessage isInterruptMessage		ifTrue: [ [ self interruptWith: aCatRMMessage ] forkAt: Processor userSchedulingPriority + 1 ]		ifFalse: [ messageQueue nextPut: aCatRMMessage ]</body><body package="COASTClient">handleQueuedMessage: aCatRMMessage 	"used to be suspended while a transactionSequence was running - and somtimes created Errors (when suspending a suspended process)"	"using #transactionSequenceExclusiveUseDo: will pass the exclusive lock "	"and - when a transactionSequence is running, will wait at a new Semaphore until the sequence is finished"	self transactionManager transactionSequenceExclusiveUseDo: 		[ | cc |			cc := clusterController at: aCatRMMessage receiver id ifAbsent: [ nil ].			cc isNil 				ifTrue: [ CoastLog logDebug: [ 'dropped message ' , aCatRMMessage displayString ]]				ifFalse: [ aCatRMMessage initiateFor: cc ]		].</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>cluster creation</category><body package="COASTClient">basicLoadCluster: clusterIDInteger	^ self requestCluster: clusterIDInteger</body><body package="COASTClient">createCluster	^ reusableClusters isEmpty 		ifTrue: [ self loadNewCluster ]		ifFalse: [ self getReusableCluster ]</body><body package="COASTClient">requestCluster: clusterIDInteger 	| reply modNum request cluster elapsedTime clusterLocator requestTime unmarshalTime |	CoastLog logDebug: [ 'Requesting cluster ' , clusterIDInteger printString ] channel: #load.	requestTime := Time microsecondsToRun: 			[	modNum := self cacheAccessor modificationNumberFor: clusterIDInteger.				clusterLocator := CatCSClusterLocator id: clusterIDInteger volume: self volume.				request := CatRMClusterRequest clusterLocator: clusterLocator withModificationNumber: modNum.				reply :=					[ volumeManager requestService: request atHost: host ] on: CoastError do: [: ex | ClusterNotFoundError raiseSignal: ex description ]			].	unmarshalTime := Time microsecondsToRun: 			[	cluster := self receiveClusterFromMessage: reply.				self notifyLoadCluster: cluster			].	elapsedTime := requestTime + unmarshalTime.	( self isCriticalLoadTime: elapsedTime ) "always show when time limit is exceeded"		ifTrue: [ CoastLog log: [ self receiveStringFor: cluster elapsedTime: elapsedTime ] channel: #load ]		ifFalse: [ CoastLog logDebug: [ self receiveStringFor: cluster elapsedTime: elapsedTime ] channel: #load ].		self coastStatistics ifNotNil: 		[: coastStatistics |			coastStatistics counterAt: #clusterLoadTime add: elapsedTime unit: #microseconds.			coastStatistics counterAt: #clusterRequestTime add: requestTime unit: #microseconds.			coastStatistics counterAt: #clusterUnmarshalTime add: unmarshalTime unit: #microseconds		].	^ cluster</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>interrupt</category><body package="COASTClient">addInterruptHandler: aCoastInterruptHandler 	interruptHandlers add: aCoastInterruptHandler.	^aCoastInterruptHandler</body><body package="COASTClient">broadcastInterrupt: targetString data: dataString	| msg |	msg := CatRMInterruptMessage volume: volume target: targetString data: dataString.	volumeManager broadcastMessage: msg atHost: host.</body><body package="COASTClient">interruptHandlers	^ interruptHandlers</body><body package="COASTClient">lowSpaceAction	self interruptHandlers do: 		[: ih | | interrupt |			interrupt := CatRMInterruptMessage memoryLowInVolume: self volume additionalInfo: 'low space detected'.			( ih handlesInterrupt: interrupt ) ifTrue: 				[	ih forkedInterruptWith: interrupt volumeManager: self volumeManager cleanUpBlock: [ self emergencyUnloadAllPossibleClusters ]				]		].</body><body package="COASTClient">removeInterruptHandler: aCoastInterruptHandler	^interruptHandlers remove: aCoastInterruptHandler ifAbsent: [ nil ]</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>caching</category><body package="COASTClient">cacheAccessor	^cacheAccessor</body><body package="COASTClient">cacheAccessor: aCacheAccessor	cacheAccessor notNil ifTrue: [ cacheAccessor closeCache ].	cacheAccessor := aCacheAccessor.</body><body package="COASTClient">disableCache	self cacheAccessor: CacheDisabledAccessor new.</body><body package="COASTClient">newLanCacheAccessorFor: cacheHost 	self cacheAccessor: (LanCacheAccessor clusterManager: self cacheHost: cacheHost)</body><body package="COASTClient">newLocalCacheAccessorFor: directory	| cache |	cache := FramePagingCacheAccessor directory: directory asFilename clusterManager: self.	self cacheAccessor: cache.	^ cache</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>accessing</category><body package="COASTClient">createRootCluster	| cluster |	cluster := self createCluster.	cluster clusterID = self rootClusterID ifFalse: [ CoastError raiseSignal: 'could not create rootcluster for volume ', self volume printString ].	^ cluster</body><body package="COASTClient">criticalLoadTimeLimit	^ self class criticalLoadTimeLimit</body><body package="COASTClient">hasWaitingMessages	^ messageQueue isEmpty not</body><body package="COASTClient">host	^host</body><body package="COASTClient">host: aString	(clusterController isEmpty not and: [ aString ~= host ]) ifTrue:		[ CoastError raiseSignal: 'host must not change'. ].	aString = ''		ifTrue: [ host := nil ]		ifFalse: [ host := aString ].</body><body package="COASTClient">networkHost	| networkHost |	networkHost := ( SocketAccessor hostnameAndPortNumFrom: self host ) key.	^ networkHost = 'internalhost' 		ifTrue: [ 'localhost' ]		ifFalse: [ networkHost ]</body><body package="COASTClient">processNamePrefix	| stream |	stream := String new writeStream.	stream nextPutAll: 'CoastClient'.	stream nextPut: $[.	stream nextPutAll: host.	stream nextPut: $/.	stream nextPutAll: volume.	stream nextPut: $].	^ stream contents</body><body package="COASTClient">recordApplicationLog: aCatCSApplicationLog	| msg |	msg := CatRMApplicationLogMessage new.	msg applicationLog: aCatCSApplicationLog.	msg volume: self volume.	self volumeManager transmitMessage: msg.</body><body package="COASTClient">responsibleForVolume	^ false</body><body package="COASTClient">setAutosaveTime: secondsTimestamp 	" I don't care "</body><body package="COASTClient">storageInterface	" don't need one "	^ nil</body><body package="COASTClient">uniqueVolumeID	| reply |	reply := self volumeManager requestService: (CatRMVolumeIDRequest volume: self volume) atHost: self host.	^reply volumeID</body><body package="COASTClient">useProxyValueHolder	^ self volumeManager useProxyValueHolder</body><body package="COASTClient">volume: aString 	" last check that the volume is really ok "	super volume: aString.	messageProcess name: self processNamePrefix , ' - message queue process'</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>initialize-release</category><body package="COASTClient">initialize	super initialize.	waitingMultiParts := Dictionary new.	waitingSingleParts := Dictionary new.	requiredMultiParts := Dictionary new.	messageQueue := SharedQueue new.	self initializeMessageProcess.	timeManager := (CatRMClientVolumeTimeManager newForClusterManager: self).	interruptHandlers := Set new.	self initializeCacheAccessor.	statistics := CoastPerformanceStatistics clusterManager: self.</body><body package="COASTClient">initializeCacheAccessor	self cacheAccessor: CacheDisabledAccessor new.</body><body package="COASTClient">initializeMessageProcess	messageProcess :=		[	"Blocking read from messageQueue. Thread is suspended until data available."			[					[ self handleQueuedMessage: messageQueue next ] on: Error					do: 					[: ex |						CoastLog logException: ex message: 'bug in message process'.						ex isFatalClientMessageProcessError ifTrue: 							[	CoastLog log: 'Fatal Error -&gt; emergency shutdown'.								self emergencyShutDown							]					].				true			] whileTrue		] forkAt: self messageProcessPriority.</body><body package="COASTClient">initializeStorageInterface	" don't need one "</body><body package="COASTClient">messageProcessPriority	| isHeadless |	isHeadless := #{HeadlessImage} 				ifDefinedDo: [: cl | cl default isHeadless ]				elseDo: [ false ].	^ isHeadless 		ifTrue: 		[	" headless - try to keep up-to-date "			Processor userInterruptPriority 		]		ifFalse: 		[	" headfull - dont interrupt the user's activitiy "			Processor userSchedulingPriority 		]</body><body package="COASTClient">releaseAllClusters	super releaseAllClusters.	self shutDown.	self cacheAccessor closeCache.</body><body package="COASTClient">shutDown	self exclusiveUseDo: [		messageProcess notNil			ifTrue: [ messageProcess terminate ].	].	self releaseBinaryStoreInterfaces.	super shutDown.</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>private</category><body package="COASTClient">interruptWith: aCatRMMessage	self volumeManager interruptProtectDo: [		interruptHandlers do: [: irHandler | irHandler interruptWith: aCatRMMessage volumeManager: volumeManager ]	].</body><body package="COASTClient">newClusterID	" cluster IDs are controlled by the mediator, so return nil "	^ nil</body><body package="COASTClient">removeWaitingMultiPart: multiPartID	requiredMultiParts removeKey: multiPartID.	^ waitingMultiParts removeKey: multiPartID.</body><body package="COASTClient">volumeLockInfoString	^'CoastClient on ' , self hostDescription</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>cluster replication</category><body package="COASTClient">loadNewCluster	"load the new cluster from the given host in the given volume"		| reply |	self unloadStrategy checkForClusterUnload.	reply := self volumeManager requestService: ( CatRMClusterCreateRequest volume: self volume ) atHost: self host.	^self receiveClusterFromMessage: reply</body><body package="COASTClient">receiveCluster: cluster fromMessage: replyMessage	cluster clusterController packetStation: (self volumeManager packetStationForHost: self host).	self registerClusterController: cluster clusterController atID: replyMessage clusterID.	^cluster</body><body package="COASTClient">receiveClusterFromMessage: replyMessageOrNil	^ replyMessageOrNil notNil		ifTrue: [ 			replyMessageOrNil logActionForClusterManager: self.			replyMessageOrNil clusterForClusterManager: self.		]		ifFalse: [ CoastError raiseSignal: 'error receiving cluster: no connection'. nil ].</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>saving</category><body package="COASTClient">saveAllModifiedClusters	| response success |	response := self volumeManager saveVolume: self volume atHost: self host.	success := response isError not.	success ifTrue: [ self unloadStrategy checkForClusterUnload ].	^success</body><body package="COASTClient">stopAutosave	" I don't care "</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>blob handling</category><body package="COASTClient">loadFromID: fileID toLocalFile: targetFile 	"When &lt;targetFile&gt; is an empty string, the bytes are returned.	otherwise the bytes are streamed to the file "	^ (self cacheAccessor hasBytesAtID: fileID )		ifTrue: [ self cacheAccessor bytesAtID: fileID toFile: targetFile ]		ifFalse: [ | reply |			reply := volumeManager 						requestService: (CatRMFileDownloadRequest							fileID: fileID							volume: volume							targetFile: targetFile)					atHost: host.			reply isNil				ifTrue: [ CoastError raiseSignal: 'Could not open blob ',  fileID printString, ', no reply' ]				ifFalse: [ reply bytes ]		]</body><body package="COASTClient">loadFromID: fileID toStream: targetStream bytesOnly: bytesOnly 	| reply request |	request := CatRMFileDownloadRequest fileID: fileID volume: volume targetStream: targetStream bytesOnly: bytesOnly.	reply :=		[ volumeManager requestService: request atHost: host ] ensure: [ request deregisterTargetStream ].	^ reply isError 		ifTrue: [ CoastError raiseSignal: reply description ]		ifFalse: [ reply bytes ]</body><body package="COASTClient">storeBytes: aByteArray 	| reply request |	request := CatRMFileUploadRequest fromBytes: aByteArray toVolume: self volume.	reply := self volumeManager requestService: request atHost: self host.	^ request uploadSucceeded 		ifTrue: 		[	self cacheAccessor writeBytes: aByteArray blobID: reply fileID.			reply fileID		]		ifFalse: [ nil ]</body><body package="COASTClient">storeFile: aFilename 	| reply request |	request := CatRMFileUploadRequest fromFile: aFilename toVolume: self volume.	reply := self volumeManager requestService: request atHost: self host.	^ request uploadSucceeded 		ifTrue: 		[	self cacheAccessor writeFile: aFilename blobID: reply fileID.			reply fileID		]		ifFalse: [ nil ]</body><body package="COASTClient">storeStream: aStream 	| reply request |	request := CatRMFileUploadRequest fromStream: aStream toVolume: self volume.	reply := self volumeManager requestService: request atHost: self host.	^ request uploadSucceeded 		ifTrue: [ reply fileID ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>utility</category><body package="COASTClient">totalClustersByteSize	^ clusterController 		inject: 0		into: 		[: sz : cc |			sz + ( cc lazyLoad 						ifTrue: [ 0 ]						ifFalse: [ cc clusterStub coastTotalByteSize ])		]</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>printing</category><body package="COASTClient">printOn: stream 	super printOn: stream.	stream nextPutAll: ' host: '.	host printOn: stream</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>requests</category><body package="COASTClient">backupVolume	^ self responsibleForVolume 		ifTrue: [ super backupVolume ]		ifFalse: 		[	" mediator is responsible for backups "			CoastStatusResponse failureCode: #couldNotBackupVolume message: 'Client cannot backup volume, backup request must be sent to mediator'		]</body><body package="COASTClient">cacheKeyFor: selector frame: aFrame slot: slotSymbol args: argArray 	"| cacheKey |	cacheKey := Array new: argArray size + 3.	cacheKey at: 1 put: aFrame.	cacheKey at: 2 put: slotSymbol.	cacheKey at: 3 put: selector.	argArray keysAndValuesDo: [: i : arg | cacheKey at: i + 3 put: arg asRPCKey ].	^ cacheKey"	^RPCCacheKey frame: aFrame slot: slotSymbol selector: selector args: argArray</body><body package="COASTClient">copyVolumeTo: newVolume remotePassword: remotePassword	^ self responsibleForVolume		ifTrue: [ super copyVolumeTo: newVolume remotePassword: remotePassword ]		ifFalse: [ self volumeManager copyVolume: self volume to: newVolume atHost: self host remotePassword: remotePassword ]</body><body package="COASTClient">deleteVolume	self releaseAllClusters. 	^ self volumeManager deleteVolume: self volume</body><body package="COASTClient">isCriticalLoadTime: loadTimeMicroseconds 	^ loadTimeMicroseconds &gt; self criticalLoadTimeLimit</body><body package="COASTClient">receiveStringFor: cluster elapsedTime: elapsedTime 	^ 'Received cluster ' , cluster clusterID printString , ' (' , elapsedTime microseconds printString , ', ' 		, cluster approxByteSize coastShortByteSizePrintString , ')'</body><body package="COASTClient">remoteCall: aFrame selector: selector arguments: argArray 	^ self remoteCall: aFrame slotName: nil selector: selector arguments: argArray allowCache: true</body><body package="COASTClient">remoteCall: aFrame slotName: slotSymbol selector: selector arguments: argArray allowCache: allowCache 	| transaction |	transaction := allowCache 			ifTrue: [ aFrame transactionManager activeTransaction ]			ifFalse: [ nil ].	^ transaction isNil 		ifTrue: [ self uncachedRemoteCall: aFrame slotName: slotSymbol selector: selector arguments: argArray ]		ifFalse: 		[ | rpcCacheDict cacheKey result |			rpcCacheDict := transaction rpcCache.			cacheKey := self cacheKeyFor: selector frame: aFrame slot: slotSymbol args: argArray.			result := rpcCacheDict at: cacheKey ifAbsentPut: [ self uncachedRemoteCall: aFrame slotName: slotSymbol selector: selector arguments: argArray ].			result copy		]</body><body package="COASTClient">uncachedRemoteCall: aFrame slotName: slotSymbol selector: selector arguments: argArray 	| request reply time |	time := Time microsecondsToRun: 			[	request := CatRMRPCRequest recipient: aFrame slotName: slotSymbol selector: selector arguments: argArray.				reply := volumeManager requestService: request atHost: host			].	self coastStatistics ifNotNil: 		[: coastStatistics |			coastStatistics counterAt: #rpc add: time unit: #microseconds		].	CoastLog 		logDebug: 		[ | stream |			stream := ( String new: 200 ) writeStream.			stream nextPutAll: 'performed in '.			time microseconds printOn: stream.			stream nextPutAll: ' RPC '.			selector printOn: stream.			stream nextPutAll: ' on '.			aFrame printRPCKeyOn: stream.			stream nextPutAll: ' slot '.			slotSymbol printOn: stream.			stream nextPutAll: ' with '.			argArray printRPCKeyOn: stream.			stream contents		]		channel: #coastRPC.	reply isNil 		ifTrue: [ CoastError raiseSignal: 'no result from mediator' ].	reply isError 		ifTrue: [ CoastError raiseSignal: reply description ].	reply resultError notNil 		ifTrue: [ CoastError raiseSignal: reply resultError ].	^ reply result</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>update messages</category><body package="COASTClient">delayUpdate: aCatRMLoggedTransactionAgenda	| delayedClusterLocator |	delayedClusterLocator := aCatRMLoggedTransactionAgenda transactionID clusterLocator.	(waitingSingleParts at: delayedClusterLocator ifAbsentPut: [ OrderedCollection new ])		add: aCatRMLoggedTransactionAgenda</body><body package="COASTClient">multiPartIsComplete: receivedMultiParts requiredID: tid 	"check if the transaction part is complete "	| cc |	cc := clusterController at: tid clusterLocator id			ifAbsent: 			[	"don't wait for multiparts for clusters that are not loaded"				^ true			].	^ cc canPerformMultipartUpdate: tid receivedMultiParts: receivedMultiParts</body><body package="COASTClient">multiPartIsComplete: receivedMultiParts requiredIDs: transactionIDs 	"check if all required (and possible) transaction agendas are accumulated"	^ transactionIDs allSatisfy: [: tid | self multiPartIsComplete: receivedMultiParts requiredID: tid ]</body><body package="COASTClient">performMultiPartUpdate: loggedTransactionAgendas	"all possible parts (contained in loggedTransactionAgendas) have been received, do a combined update"	"construct a multipart update transaction, prepare the update in the cluster controllers, and use	the transaction to perform the update"	| updateTransaction simpleAgendas correspondingClusterControllers |	simpleAgendas := OrderedCollection new.	correspondingClusterControllers := OrderedCollection new.	loggedTransactionAgendas do:	[ :loggedAgenda | | cc transactionID agenda updateNeeded |		transactionID := loggedAgenda transactionID.		agenda := loggedAgenda agenda.		cc := clusterController at: transactionID clusterLocator id ifAbsent: [ nil ].		cc isNil ifFalse: 	"clusters currently not loaded may be ignored"		[			updateNeeded := cc prepareUpdate: loggedAgenda.			updateNeeded				ifTrue: [					simpleAgendas add: agenda.					correspondingClusterControllers add: cc.				].		].	].	updateTransaction := CatRMUpdateMultipartTransaction new.	updateTransaction simpleAgendas: simpleAgendas.	updateTransaction clusterControllers: correspondingClusterControllers.	self transactionManager rollForwardTransaction: updateTransaction.	correspondingClusterControllers do: [ : cc | cc checkAndSendAliveMessage ]</body><body package="COASTClient">performPendingUpdates	"maybe a an update complete now (because we loaded a cluster in a new version, or received a required update, etc.)"	| cycles performed |	cycles := 0.	[	performed := false.		" single part "		waitingSingleParts copy keysAndValuesDo: 			[: clusterLocator : singlePartsForCluster | | cc |				cc := clusterController at: clusterLocator id ifAbsent: [ nil ].				cc notNil 					ifTrue: 					[	singlePartsForCluster copy do: 							[: singlePart |								(cc performSinglePartUpdateIfNeeded: singlePart) ifTrue: 									[	performed := true.										CoastLog log: 'Performed waiting single part'.										singlePartsForCluster remove: singlePart 									] 							].						singlePartsForCluster isEmpty ifTrue: [ waitingSingleParts removeKey: clusterLocator ] 					]					ifFalse: 					[	" cluster unloaded, dont need the update anymore "						waitingSingleParts removeKey: clusterLocator 					] 			].		" multi part "		waitingMultiParts copy keysAndValuesDo: 			[: multiPartID : waitingParts | | requiredParts waitingMultiPartCollection |				requiredParts := requiredMultiParts at: multiPartID.				(self multiPartIsComplete: waitingParts requiredIDs: requiredParts) ifTrue: 					[	performed := true.						waitingMultiPartCollection := self removeWaitingMultiPart: multiPartID.						self performMultiPartUpdate: waitingMultiPartCollection.						CoastLog log: 'Performed waiting multi part'.					] 			].		performed 	] whileTrue: [ cycles := cycles + 1 ].	cycles &gt; 0 ifTrue: [ CoastLog log: 'Performed pending updates, ' , cycles printString , ' cycles' ]</body><body package="COASTClient">processMultiPartUpdate: aCatRMLoggedTransactionAgenda withRequiredIDs: transactionIDs	"the given agenda is part of a greater update	make sure to accumulate all possible parts and do the update as a whole"	| multiPartID waitingMultiPart |		self performPendingUpdates. "try this first"	multiPartID := transactionIDs first. "use the first required transactionID as multi-part id"	waitingMultiPart := waitingMultiParts at: multiPartID ifAbsentPut: [ OrderedCollection new ].	requiredMultiParts at: multiPartID ifAbsentPut: [ transactionIDs copy ].	waitingMultiPart add: aCatRMLoggedTransactionAgenda.	(self multiPartIsComplete: waitingMultiPart requiredIDs: transactionIDs) ifTrue:	[		self removeWaitingMultiPart: multiPartID.		self performMultiPartUpdate: waitingMultiPart.	].</body><body package="COASTClient">waitingMultiParts	^ waitingMultiParts</body><body package="COASTClient">waitingSingleParts	^ waitingSingleParts</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>index</category><body package="COASTClient">loadIndex	| reply ini |	reply := self volumeManager requestService: ( CatRMIndexDownloadRequest volume: self volume ) atHost: self host.	ini := CoastIniAccess readFrom: ( ReadStream on: reply bytes asByteString ).	self loadIndexFromIni: ini.</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>initialize</category><body package="COASTClient">frameClassIndexClass	"DO NOT Remove This Method!	effective only in 5.3"	^ RemoteFrameClassIndex</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>cluster unload</category><body package="COASTClient">unloadCluster: aCluster disresolve: disresolve notifyMediator: doNotify 	self cacheAccessor writeBackClusterController: aCluster clusterController.	super unloadCluster: aCluster disresolve: disresolve notifyMediator: doNotify.</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>timeing</category><body package="COASTClient">milliseconds	^ self timeDifference + self localTimestamp asMilliseconds</body><body package="COASTClient">timeDifference	"in milliseconds"	^ timeManager timeDifference</body><body package="COASTClient">timestamp	^ Timestamp fromMilliseconds: self milliseconds</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>binary storage</category><body package="COASTClient">binaryStoreInterfaceNeededForStore: store 	binaryStoreInterfaces isNil ifTrue: [ binaryStoreInterfaces := Dictionary new ].	^ binaryStoreInterfaces at: store storeID		ifAbsentPut: [ RemoteBinaryStoreInterface store: store mediatorHost: self host ]</body><body package="COASTClient">releaseBinaryStoreInterfaces	binaryStoreInterfaces notNil ifTrue: 		[	binaryStoreInterfaces do: [: interface | interface release ].			binaryStoreInterfaces := nil		].</body></methods><methods><class-id>COAST.CoastClientClusterManager</class-id> <category>test and set</category><body package="COASTClient">validTestAndSet: key oldValue: oldValue newValue: newValue 	| request |	request := CatRMTestAndSetRequest keyFrame: key oldValue: oldValue newValue: newValue.	^ ( volumeManager requestService: request atHost: host ) result ifNotNil: 		[: frameRef |			frameRef = newValue 				ifTrue: [ newValue	"ist der Frame, anstelle der frameReference" ]				ifFalse: [ frameRef ]		]</body></methods><methods><class-id>COAST.CoastClientClusterManager class</class-id> <category>accessing</category><body package="COASTClient">cacheDirectory	"default cache directory"	^'cache'</body><body package="COASTClient">criticalLoadTimeLimit	CriticalLoadTimeLimit isNil ifTrue: [ self criticalLoadTimeLimit: 1 seconds ].	^ CriticalLoadTimeLimit</body><body package="COASTClient">criticalLoadTimeLimit: durationOrMilliseconds 	CriticalLoadTimeLimit := ( durationOrMilliseconds asDurationDefaultUnit: #milliseconds ) asMicroseconds.</body></methods><methods><class-id>COAST.CoastClientClusterManager class</class-id> <category>mediator services</category><body package="COASTClient">minCoastTransferVersion	^(CoastVersion major: 4 minor: 7)</body></methods><methods><class-id>COAST.LanCacheAccessor</class-id> <category>interface</category><body package="COASTClient">basicWriteBackCluster: clusterController	"don't care"</body><body package="COASTClient">closeCache	self initialize.</body><body package="COASTClient">clusterFromCacheHitMessage: cacheHitMessage	| cluster marshaller stream bytes |	marshaller := cacheHitMessage marshallerForCachedCluster.	bytes := self bytesAtID: cacheHitMessage clusterLocator id.	stream := bytes readStream.	[ cluster := marshaller loadClusterFromStream: stream ] ensure: [stream close].	cluster approxByteSize: bytes.	marshaller clusterController cluster: cluster.	cluster clusterController globalSeqNum: cluster modificationNumber.	^cluster</body><body package="COASTClient">invalidateAccessFor: clusterIDInteger	cache removeKey: clusterIDInteger ifAbsent: []</body><body package="COASTClient">modificationNumberFor: clusterIDInteger 	| number |	self sendTo: cacheHost		requestID: CoastConstant getCachedCluster		sendStreamDo: 		[: sendStream |			CatCSCluster marshallID: clusterIDInteger volume: self clusterManager volume to: sendStream.			sendStream nextCoastStringPut: mediatorHost		]		receiveBlock: 		[: receiveStream | | bytes |			number := receiveStream nextOptimized32.			number = 0 				ifTrue: [ bytes := ByteArray new ]				ifFalse: 				[ | clusterByteSize |					clusterByteSize := receiveStream nextUnsigned32.					bytes := ByteArray new: clusterByteSize.					receiveStream next: clusterByteSize into: bytes startingAt: 1				].			cache at: clusterIDInteger put: bytes		]		failureBlock: [ number := 0 ].	^ number</body></methods><methods><class-id>COAST.LanCacheAccessor</class-id> <category>interface - blobs</category><body package="COASTClient">bytesAtID: clusterIDInteger	^cache removeKey: clusterIDInteger</body><body package="COASTClient">copyBytesAtID: clusterIDInteger  toFile: filename	| writeStream |	writeStream := filename asFilename writeStream.	[	writeStream binary.		writeStream nextPutAll: (self bytesAtID: clusterIDInteger ).	] ensure: [writeStream close]</body><body package="COASTClient">hasBytesAtID: clusterIDInteger 	| result number |	self sendTo: cacheHost		requestID: CoastConstant getCachedBlob		sendStreamDo: 		[: sendStream |			CatCSCluster marshallID: clusterIDInteger volume: self clusterManager volume to: sendStream.			sendStream nextCoastStringPut: mediatorHost		]		receiveBlock: 		[: receiveStream | | bytes |			number := receiveStream nextOptimized32.			number = 0 				ifTrue: [ result := false ]				ifFalse: 				[ | blobByteSize |					blobByteSize := receiveStream nextUnsigned32.					bytes := ByteArray new: blobByteSize.					receiveStream next: blobByteSize into: bytes startingAt: 1.					cache at: clusterIDInteger put: bytes.					result := true				]		]		failureBlock: [ result := false ].	^ result</body><body package="COASTClient">writeBytes: bytes blobID: blobIDInteger 	self sendTo: cacheHost		requestID: CoastConstant putBlobToCache		sendStreamDo: 		[: sendStream |			CatCSCluster marshallID: blobIDInteger volume: self clusterManager volume to: sendStream.			sendStream nextCoastStringPut: mediatorHost.			sendStream nextUnsigned32Put: bytes size.			sendStream nextPutAll: bytes		]		receiveBlock: 		[: receiveStream |			receiveStream nextOptimized32 = 1 				ifTrue: 				[	"ok"				]				ifFalse: 				[	"failed"				]		]		failureBlock: 		[	"failed"		].</body><body package="COASTClient">writeFile: file blobID: blobIDInteger 	| stream bytes |	stream := file readStream.	[stream binary.	bytes := stream contents]		ensure: [stream close].	self writeBytes: bytes blobID: blobIDInteger</body></methods><methods><class-id>COAST.LanCacheAccessor</class-id> <category>accessing</category><body package="COASTClient">cacheHost: host	cacheHost := host</body><body package="COASTClient">clusterManager	^ clusterManager</body><body package="COASTClient">clusterManager: aCatCSClusterManager 	clusterManager := aCatCSClusterManager.	self mediatorHost: aCatCSClusterManager host.</body><body package="COASTClient">mediatorHost: hostString	| assoc port ipAddr |	assoc := (SocketAccessor hostnameAndPortNumFrom: hostString).	port := (assoc value ifNil: [CoastClientVolumeManager defaultServerPort]) printString.	ipAddr := ( [ IPSocketAddress hostAddressByName: assoc key ]					on: OsInaccessibleError do: [ : ex | ex return: (ByteArray new: 4) ] 				) asIPAdressString.	mediatorHost := ipAddr , ':' , port</body></methods><methods><class-id>COAST.LanCacheAccessor</class-id> <category>private</category><body package="COASTClient">initialize	cache := Dictionary new</body><body package="COASTClient">sendTo: hostname requestID: requestID sendStreamDo: sendBlock receiveBlock: receiveBlock failureBlock: failureBlock 	^ [ | aSocketAccessor coastSocketAccessor receiveStream sendStream |		aSocketAccessor := receiveStream := sendStream := nil.		[	aSocketAccessor := SocketAccessor defaultClass newTCPclientToHostAndPort: hostname defaultPort: self class defaultCachePort.			( aSocketAccessor notNil and: [ aSocketAccessor isActive ]) ifTrue: 				[	coastSocketAccessor := CoastSocketAccessor connectSocketAccessor: aSocketAccessor.					sendStream := coastSocketAccessor writeStream binary.					sendStream nextPut: requestID.					sendBlock value: sendStream.					sendStream flush.					receiveStream := coastSocketAccessor readStream binary.					receiveBlock value: receiveStream				]		] ensure: 			[	receiveStream isNil ifFalse: [ receiveStream close ].				sendStream isNil ifFalse: [ sendStream close ].				coastSocketAccessor isNil ifFalse: [ coastSocketAccessor close ]			]	] on: self errorSignal		do: 		[: ex |			CoastLog log: 'Error while accessing LAN cache: ' , ex description.			clusterManager disableCache.			failureBlock value		]</body></methods><methods><class-id>COAST.LanCacheAccessor class</class-id> <category>instance creation</category><body package="COASTClient">clusterManager: clusterManager cacheHost: cacheHost	| newInst |	newInst := self new.	newInst clusterManager: clusterManager.	newInst cacheHost: cacheHost.	newInst initialize.	^newInst</body></methods><methods><class-id>COAST.LanCacheAccessor class</class-id> <category>accessing</category><body package="COASTClient">defaultCachePort	^30007</body></methods><methods><class-id>COAST.CoastPerformanceCounterRoot</class-id> <category>printing</category><body package="COASTClient">displayString	^  (#performanceMLS &lt;&lt; #mls &gt;&gt; 'Performance') asString</body></methods><methods><class-id>COAST.CoastPerformanceCounterRoot</class-id> <category>accessing</category><body package="COASTClient">clusterManager	^ clusterManager</body><body package="COASTClient">clusterManager: aClusterManager 	clusterManager := aClusterManager.</body></methods><methods><class-id>COAST.CoastPerformanceCounterRoot class</class-id> <category>instance creation</category><body package="COASTClient">clusterManager: aClusterManager 	^ self new key: #performance;		clusterManager: aClusterManager;		yourself</body></methods><methods><class-id>COAST.CoastNotifierShared</class-id> <category>accessing</category><body package="COASTClient">message	^self at: #message</body><body package="COASTClient">message: aString	self at: #message set: aString</body></methods><methods><class-id>COAST.CoastNotifierShared class</class-id> <category>instance creation</category><body package="COASTClient">message: aString 	^(self new)		message: aString;		yourself</body></methods><methods><class-id>COAST.CoastNotifierShared class</class-id> <category>slot description</category><body package="COASTClient">messageSlot	^ ( self slotOfType: #singleValue )		defaultValue: String new;		yourself</body></methods><methods><class-id>COAST.CatRMErrorMessage</class-id> <category>testing</category><body package="COASTClient">clusterForClusterManager: clusterManager	^nil</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>caching client services</category><body package="COASTClient">getCachedCluster	^255</body></methods><methods><class-id>COAST.WeakSegmentedFrameSet</class-id> <category>private</category><body package="COASTClient">disresolveAll: frames clusterID: clusterID resolver: resolver 	"optimized addAll: combined with disresolve -- all frames have the same clusterID"	self setForSegmentHash: clusterID		withSegmentDo: 		[: weakSet : segment | | size |			frames do: 				[: frame |					frame disresolve.					frame cellContainer: resolver				].			size := weakSet size + frames size.			size &gt; ( weakSet capacity * 4 / 3 ) ifTrue: [ weakSet changeCapacityTo: size ].			weakSet addAll: frames.			segment splitIfNeeded		].</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COASTClient">asRPCKey	^ self</body><body package="COASTClient">coastStatisticsKey	^ self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COASTClient">isRPCKeyEqualTo: anotherObject	^self = anotherObject</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="COASTClient">printRPCKeyOn: aStream 	self printOn: aStream.</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COASTClient">rpcArgHash	^ self hash</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>accessing</category><body package="COASTClient">applicationClientClass	^ self transactionManagerContextAt: #applicationClientClass</body><body package="COASTClient">applicationClientClass: aClass 	self transactionManagerContextAt: #applicationClientClass put: aClass.</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>user management</category><body package="COASTClient">localUser: aCoastUser	localUser := aCoastUser sharedCopy</body></methods><methods><class-id>COAST.CatRMAcceptMessage</class-id> <category>execution</category><body package="COASTClient">initiateFor: aMessageHandler	aMessageHandler handleAcceptMessage: self</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>testing</category><body package="COASTClient">areCoastManagersActive	| cm |	^ self isShared 		ifTrue: 		[	cm := self clusterManager.			cm notNil and: [ cm areCoastManagersActive ]		]		ifFalse: [ self transactionManager active ]</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing</category><body package="COASTClient">coastStatisticsKey	" Dictionary key for storing statistics about this frame .	must be a primitive value or a frame locator "	^ self isLocal 		ifTrue: [ #localFrame ]		ifFalse: [ self frameLocator ]</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>testing</category><body package="COASTClient">isUser	^false</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>printing</category><body package="COASTClient">printRPCKeyOn: aStream 	self frameReference printRPCKeyOn: aStream.</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing</category><body package="COASTClient">withoutWrappers	^ self</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>accessing</category><body package="COASTClient">cacheAccessor: cacheAccessor</body><body package="COASTClient">quickCheckForCache</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>accessing</category><body package="COASTClient">asRPCKey	^ value</body><body package="COASTClient">printRPCKeyOn: aStream 	^ value printRPCKeyOn: aStream</body></methods><methods><class-id>Core.RecursionLock</class-id> <category>mutual exclusion</category><body package="COASTClient">criticalNow: aBlock unblockedDo: bBlock 	"Evaluate aBlock only if the resource represented by the receiver is not 	already in use by another Process. If it is, execute bBlock. If the resource is already in use by the 	current process, execution may proceed. Answer the result of evaluating 	the block"	| activeProcess |	activeProcess := Processor activeProcess.	^ activeProcess == owner 		ifTrue: [ aBlock value ]		ifFalse: 		[	owner isNil 				ifTrue: [ self critical: aBlock	"still might block - sorry" ]				ifFalse: [ bBlock value ]		]</body><body package="COASTClient">exclusiveLockBlocksAnyProcess	^ semaphore isEmpty not</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>printing</category><body package="COASTClient">printRPCKeyOn: stream 	self printOn: stream.</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>testing</category><body package="COASTClient">areCoastManagersActive	| tm |	tm := self volumeManager transactionManager.	( tm notNil and: [ tm active not ]) 		ifTrue: [ ^ false ].	( self volumeManager clusterManagerForVolume: self volume ifAbsent: [ nil ]) ~~ self 		ifTrue: [ ^ false ].	^ true</body></methods><methods><class-id>COAST.CatRMMultiPartUpdateMessage</class-id> <category>execution</category><body package="COASTClient">initiateFor: aMessageHandler	COAST.CoastLog logDebug: [ 'multipart update ', aMessageHandler clientID printString, ' agenda  ', self loggedTransactionAgenda transactionID printString ].	aMessageHandler handleMultiPartUpdateMessage: self</body></methods><methods><class-id>Core.MessageNotUnderstood</class-id> <category>testing</category><body package="COASTClient">isFatalClientMessageProcessError	^ true</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>comparing</category><body package="COASTClient">isRPCKeyEqualTo: anotherObject 	^self class = anotherObject class and: 		[	self isCompact and: [ anotherObject isCompact and: [ frameIDs = anotherObject frameIDs and: [ clusterIDs = anotherObject clusterIDs ]]]		]</body><body package="COASTClient">rpcArgHash	^ 0</body></methods><methods><class-id>COAST.CatRMUpdateMessage</class-id> <category>execution</category><body package="COASTClient">initiateFor: aMessageHandler 	COAST.CoastLog logDebug: [ 'update ' , aMessageHandler clientID printString , ' agenda  ' , self loggedTransactionAgenda transactionID printString ].	[ aMessageHandler handleUpdateMessage: self ] on: Error		do: 		[: ex | | clusterManager |			clusterManager := aMessageHandler clusterManager.			CoastLog logException: ex message: 'bug in update message'.			CoastLog log: 'Fatal Error -&gt; emergency shutdown'.			clusterManager emergencyShutDown		].</body></methods><methods><class-id>COAST.CatCSCluster class</class-id> <category>marshalling</category><body package="COASTClient">marshallID: clusterIDInteger volume: volume to: aStream 	" utility method "	aStream nextShortStringPut: volume.	aStream nextOptimized32Put: clusterIDInteger.</body></methods><methods><class-id>COAST.CatRMCachedClusterOkMessage</class-id> <category>execution</category><body package="COASTClient">clusterForClusterManager: clusterManager	| cluster |	cluster := clusterManager cacheAccessor clusterFromCacheHitMessage: self.	^clusterManager receiveCluster: cluster fromMessage: self</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>accessing</category><body package="COASTClient">localUser	^ self transactionContextAt: #localUser</body><body package="COASTClient">localUser: aCoastUser	self transactionContextAt: #localUser put: aCoastUser</body></methods><methods><class-id>COAST.CatFSFrameID</class-id> <category>printing</category><body package="COASTClient">printRPCKeyOn: aStream 	self basicPrintOn: aStream.</body></methods><methods><class-id>COAST.CatCSFrameLocator</class-id> <category>accessing</category><body package="COASTClient">resolveAbsentFor: clusterManager 	"load frame now"	^ clusterManager getFrame: self frameID inCluster: self clusterID</body></methods><methods><class-id>Core.Collection</class-id> <category>printing</category><body package="COASTClient">printRPCKeyOn: aStream 	"Append to the argument aStream a sequence of characters 	that identifies the collection.  The general format for collections	is		Collection-name ( element element element )	unless there are a large number in which case the listing is	truncated with the words ...etc..."	| tooMany |	aStream print: self class;		nextPutAll: ' size: '.	self size printOn: aStream.	tooMany := aStream position + 150.	aStream nextPutAll: ' ('.	self 		do: 		[: element |			aStream position &gt; tooMany ifTrue: 				[	aStream nextPutAll: ( #etc &lt;&lt; #dialogs &gt;&gt; '...etc...' ) asString; nextPut: $).					^ self				].			element printRPCKeyOn: aStream		]		separatedBy: [ aStream space ].	aStream nextPut: $).</body></methods><methods><class-id>COAST.CatFSFrameReference</class-id> <category>empty frame creation</category><body package="COASTClient">createBlankFrameFor: aClusterManager	"create a new unresolved frame ('empty nut'), use CatFSUniversalFrame if frame class	is not present in the current image (esp. true for mediators)."	| frame frameClass |	frameClass := self frameClassFor: aClusterManager classNameManager.	frame := frameClass notNil		ifTrue: [ frameClass basicNew ]		ifFalse: [ CatFSUniversalFrame newWithFrameClassName: self frameClassName ].	^frame</body></methods><methods><class-id>COAST.CatFSFrameReference</class-id> <category>accessing</category><body package="COASTClient">resolveAbsentFor: clusterManager 	"create deaf nut"	^ clusterManager resolveAbsentFrameReference: self</body></methods><methods><class-id>COAST.CatCSClusterInfo</class-id> <category>accessing</category><body package="COASTClient">accessCountForLanCache	"initial load = 1 additional accesses"	^self accessCount - 1</body></methods><methods><class-id>Core.WeakSet</class-id> <category>adding</category><body package="COASTClient">addAndReturnOldOrNil: newObject 	"Include newObject as one of the receiver's elements.  Answer nil if newObject was added or old if not added"	| index old |	newObject == nil ifTrue: [ ^ nil ].	index := self findElementOrNil: newObject.	old := self basicAt: index.	^ ( old = self tombstone or: [ old == nil ]) 		ifTrue: 		[	self atNewIndex: index put: newObject.			nil		]		ifFalse: [ old ]</body></methods><methods><class-id>Core.WeakSet</class-id> <category>private</category><body package="COASTClient">frameWithClusterID: clusterID frameID: frameID withIndexDo: block 	| index length probe pass |	length := self basicSize.	pass := 1.	index := self initialIndexFor: frameID boundedBy: length.	[	probe := self basicAt: index.		probe == nil or: [ probe isCoastFrame and: [ probe clusterID = clusterID and: [ probe frameID = frameID ]]]	] whileFalse: 		[( index := index + 1 ) &gt; length ifTrue: 				[	index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [ ^ nil ]				]		].	^ probe ~~ self tombstone 		ifTrue: [ block value: probe value: index ]		ifFalse: [ block value: nil value: index ]</body></methods><methods><class-id>COAST.CatRMRejectMessage</class-id> <category>execution</category><body package="COASTClient">initiateFor: aMessageHandler	aMessageHandler handleRejectMessage: self</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor class</class-id> <category>instance creation</category><body package="COASTClient">cachingDirectory: aDirectory 	| bfs |	bfs := CatBFCacheBlockFileSystem directory: aDirectory name: 'cache'.	bfs openOrCreate.	^ self blockFileSystem: bfs</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor</class-id> <category>accessing</category><body package="COASTClient">cacheAccessor: cacheAccessor 	blockFileSystem cacheAccessor: cacheAccessor.</body><body package="COASTClient">quickCheckForCache	self blockFileSystem quickCheckForCache</body></methods><methods><class-id>COAST.CatRMClusterForClientMessage</class-id> <category>execution</category><body package="COASTClient">clusterForClusterManager: clusterManager	clusterManager cacheAccessor clusterFromCacheMissMessage: self.	^clusterManager receiveCluster: self cluster fromMessage: self</body></methods><methods><class-id>OS.IPSocketAddress class</class-id> <category>As yet unclassified</category><body package="COASTClient">thisHostFullAddressOrRandom	| address | 	[ address := self thisHostFullAddress ] on: OsInaccessibleError		do: 		[: ex |			COAST.CoastLog log: 'unable to determine this host''s ip adress for persistent client id - using random value instead'.			^ IPSocketAddress randomHostAddress		].	^ address = #[ 127 0 0 1 ] 		ifTrue: [ IPSocketAddress randomHostAddress ]		ifFalse: [ address ]</body></methods><methods><class-id>COAST.CatRMInterruptMessage class</class-id> <category>instance creation</category><body package="COASTClient">lowMemString	^ 'memory-low'</body><body package="COASTClient">memoryLowInVolume: volume additionalInfo: dataString 	^ ( self new )		volume: volume;		target: self lowMemString;		data: dataString;		yourself</body></methods><methods><class-id>COAST.CatRMInterruptMessage</class-id> <category>testing</category><body package="COASTClient">isMemoryLowInterrupt	^ target = self class lowMemString</body></methods><methods><class-id>Core.Error</class-id> <category>testing</category><body package="COASTClient">coastIsConnectionRefuse	^ false</body><body package="COASTClient">isFatalClientMessageProcessError	" true wenn dieser Fehler im Message-Process einen Shutdown des Clients erfordert "	^ self isFatalCoastError</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Announcer</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>System-Announcements</package></attributes></class><class><name>CatCSCellValueHolder</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars>indexArray </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>WeakSet</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>weakStorage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>WeakCollections</package></attributes></class><class><name>CatCSClusterController</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cluster clusterID modified changeCount clusterManager lastSaveTime byteArrayFilename oldStyleFrameDetected </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>CoastError</name><environment>COAST</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>CatCSVolumeManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManagers volumeInterface exclusiveLock currentLoadedClusterID packetStations autoSaveTimeInterval maxModifiedClusters segmentSplitSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSUnloadStrategy</name><environment>COAST</environment><super>COAST.AbstractUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessTable keepSize unloadSize maxUnloadTime unloadClustersFlag systemSupport basicUnloadableClusterIDs maxUnloadSize clusterInfoClass lastAccessTableCompress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatRMPacketStation</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sendQueue sendProcess receiveProcess sendStream receiveStream socketAccessor connected volumeManager trySendMessage lastSendID lastReceiveID isInShutdown ipAdressString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatRMInterruptMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume data target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatCSClusterManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterController autoSaveInterval volume volumeManager volumeID storageInterface autosaveTime lastSaveTime frameClassIndex nextClusterID tempBytesPool classNameManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CompactCollection</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>addedFrames removedFrames clusterManager frameIDs clusterIDs classIndices frameClassArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatFSFrameID</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class><class><name>CatCSStorageAccessor</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumeAccessor applicationLoggers volume volumeLockInfoString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSBlockFileStorageAccessor</name><environment>COAST</environment><super>COAST.CatCSAbstractDiskStorageAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockFileSystem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFBlockFileSystem</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bfsFileHandle isLocked lockInfoString seekPosition accessLock numberOfBlocks blockSize patchMode lastModification version modificationNumber processID headerBuffer availableBuffers buffers openWriteStreams openReadStreams workingDirectory coreName directory freeList nextClusterID uniqueVolumeID lockFile backupCopyInfo backgroundCopyInfos growSizeInBytes backgroundOperationProcessPriority readOnly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatRMUpdateMessage</name><environment>COAST</environment><super>COAST.CatRMMessageWithAgenda</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMAcceptMessage</name><environment>COAST</environment><super>COAST.CatRMTryResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatFSFrame</name><environment>COAST</environment><super>COAST.CatCSContainerCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>coastFrameClassSymbol coastFrameClassName </class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>MessageNotUnderstood</name><environment>Core</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reachedDefaultHandler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CatCSTransaction</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context rolledBack composedCells composedCellsLock inDisplayPhase outstandingCompositions combinedAgenda endDemons postDemons failureBlocks inInvalidationPhase ownerProcess transactionManager isFastRead oldValuesDict commitBlocks endBlocks applicationLog delegationContexts invalidationSuppressed delayedCompositions postViewUpdateBlocks failureReason </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastConnectionLostError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>SubscriptionRegistry</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionClass classesAndSubscriptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>CatRMRejectMessage</name><environment>COAST</environment><super>COAST.CatRMTryResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMClusterForClientMessage</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cluster globalSeqNum byteArray byteSize clusterByteSize isPrepared marshall </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CoastTransactionManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activeTransaction transactionSequence eagerObservers developmentMode active rollForwardNotificationBlocks rollBackNotificationBlocks updateNotificationBlocks pendingProcesses volumeManager context outstandingTransactionsCount blockCaches needsFlush localUser </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>RecursionLock</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner semaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>CatCSFrameLocator</name><environment>COAST</environment><super>COAST.CatFSFrameID</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class><class><name>MinAgeLRUUnloadStrategy</name><environment>COAST</environment><super>COAST.LRUUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>minAge unloadInterval lastUnloadAttempt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastApplicationConfiguration</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iniAccess infoString infoDict defaultLogFilename logFilename needsIni serviceName serviceAction winService iniFilename defaultIniFilename maxMemory preConfigurationBlocks parentConfiguration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class><class><name>WeakSegmentedFrameSet</name><environment>COAST</environment><super>COAST.SegmentedFrameSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COFramesystem</package></attributes></class><class><name>CatRMCachedClusterOkMessage</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterLocator marshall </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatCSClusterInfo</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loadTime accessTime accessCount loadFromMediatorCount loadFromCacheCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatRMErrorMessage</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMMultiPartUpdateMessage</name><environment>COAST</environment><super>COAST.CatRMUpdateMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>allTransactionIDs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatFSFrameReference</name><environment>COAST</environment><super>COAST.CatCSFrameLocator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClassOrSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class><class><name>ClassNameManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultNameSpaces class2nameDict name2classDict </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COBase</package></attributes></class><class><name>CoastApplication</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration winService startAction subApplications </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class></st-source>