<?xml version="1.0"?><st-source><!-- Name: COASTMediatorNotice: The MIT LicenseCopyright (c) 2013 intelligent views GmbHPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DevelopmentPrerequisites: #(#(#any 'COASTCore' '') #(#any 'COASTMailNotifier' '') #(#any 'WinService' '') #(#any 'COASTGarbageCollection' '') #(#any 'OSProcessSignalHandler' '') #(#any 'MD5' '') #(#any 'COASTBlobService' '') #(#any 'COASTBinaryObjectStore' ''))EnvyVersion: 4.3.2PackageName: COASTMediatorPackageName:: COASTMediatorParcel: #('COASTMediator')ParcelDirectory: COASTMediatorPrerequisiteDescriptions: #(#(#name 'COASTCore' #componentType #bundle) #(#name 'COASTMailNotifier' #componentType #package) #(#name 'WinService' #componentType #package) #(#name 'COASTGarbageCollection' #componentType #package) #(#name 'OSProcessSignalHandler' #componentType #package) #(#name 'MD5' #componentType #package) #(#name 'COASTBlobService' #componentType #package) #(#name 'COASTBinaryObjectStore' #componentType #package))PrerequisiteParcels: #(#('COASTCore' '') #('COASTMailNotifier' '') #('WinService' '') #('COASTGarbageCollection' '') #('OSProcessSignalHandler' '') #('MD5' '') #('COASTBlobService' '') #('COASTBinaryObjectStore' ''))Version: 5.5.14Post-Load Block: 	[:package | ObjectMemory sizesAtStartup: #(4.0 2.0 100.0 2.0 5.0 1.0 1.0)]Date: 11:13:24 AM July 18, 2014 --><time-stamp>From VisualWorksÂ®, 7.10.1 of 6. Februar 2014 on 18. Juli 2014 at 11:13:24</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CoastAbstractRequest</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enabled performer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CoastMediatorRequest</name><environment>COAST</environment><super>COAST.CoastAbstractRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeOperationRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeCompressRequest</name><environment>COAST</environment><super>COAST.CMVolumeOperationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeCopyRequest</name><environment>COAST</environment><super>COAST.CMVolumeOperationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMGCStatusRequest</name><environment>COAST</environment><super>COAST.CMVolumeOperationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeTransferRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeUploadRequest</name><environment>COAST</environment><super>COAST.CMVolumeTransferRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeReplaceRequest</name><environment>COAST</environment><super>COAST.CMVolumeUploadRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMGCRequest</name><environment>COAST</environment><super>COAST.CMVolumeOperationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMStopGCRequest</name><environment>COAST</environment><super>COAST.CMGCRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMPauseGCRequest</name><environment>COAST</environment><super>COAST.CMGCRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMStartGCRequest</name><environment>COAST</environment><super>COAST.CMGCRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CoastMediatorConfiguration</name><environment>COAST</environment><super>COAST.CoastApplicationConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMMediatorVolumeManager</name><environment>COAST</environment><super>COAST.CatCSVolumeManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestQueue requestProcess nextClientID persistentClients clusterReleaseDelay compactFreedMemoryThreshold quickCompactFreedMemoryThreshold </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMMediatorFrame</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClassSymbol slots frameID cluster byteArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMMediatorAgenda</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientAgendas mediatorAgendas </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMMediatorSlot</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id container valueHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>MediatorJobScheduler</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jobs jobProcess jobsFileTimestamp mediator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTMediator</package></attributes></class><class><name>AbstractMediatorTransaction</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMAbstractJob</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume jobTime jobInterval lastJobTime nextJobTime initialRun </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMMediatorCC</name><environment>COAST</environment><super>COAST.CatCSClusterController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clients globalSeqNum totalChangeCount wasUsedInGC lastRead </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CoastMediator</name><environment>COAST</environment><super>COAST.CoastApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceSocket serviceProcess serverPort serverHost volumeManager remotePassword jobScheduler requestDict skipVolumesCheck baseDirectory pidFilename sslContext </inst-vars><class-inst-vars>startMediatorOnStartup defaultSkipVolumesCheck </class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>MediatorClassNameManager</name><environment>COAST</environment><super>COAST.ClassNameManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMMediatorClusterManager</name><environment>COAST</environment><super>COAST.CatCSClusterManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>garbageCollector clusterMemoryFreedCounter testAndSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMClientState</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>acceptedLocalSeqNum unseen </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMMediatorPacketStation</name><environment>COAST</environment><super>COAST.CatRMPacketStation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>peerID lastReceiveTime clientActivityWatchdog connectionStartTime persistentClientID reconnectProcess peerDescription </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>MediatorRPCTransaction</name><environment>COAST</environment><super>COAST.AbstractMediatorTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ignoreWriteAccesses volumeManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVersionRequest</name><environment>COAST</environment><super>COAST.CoastAbstractRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>MediatorTransaction</name><environment>COAST</environment><super>COAST.AbstractMediatorTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rollingAgenda replacedAccesses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMBackupJob</name><environment>COAST</environment><super>COAST.CatRMAbstractJob</super><private>false</private><indexed-type>none</indexed-type><inst-vars>backupsToKeep </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMGarbageCollectJob</name><environment>COAST</environment><super>COAST.CatRMAbstractJob</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMLazyMediatorCC</name><environment>COAST</environment><super>COAST.CatRMMediatorCC</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lazy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMSynchTimeRequest</name><environment>COAST</environment><super>COAST.CoastAbstractRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeListRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMCreateVolumeRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMChangePasswordRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMBackupOperationRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMFrameClassIndexRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume classIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMEvaluateRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMReconnectRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMDownloadLogRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMConnectRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMBlobOrClusterSizeRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMListConnectionsRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMShutdownRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeExistsRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMBuildInfoRequest</name><environment>COAST</environment><super>COAST.CoastMediatorRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMPasswordProtectedVolumesListRequest</name><environment>COAST</environment><super>COAST.CMVolumeListRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeDownloadRequest</name><environment>COAST</environment><super>COAST.CMVolumeTransferRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMBackupDeleteRequest</name><environment>COAST</environment><super>COAST.CMBackupOperationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMRecoverableVolumesRequest</name><environment>COAST</environment><super>COAST.CMBackupOperationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeDeleteRequest</name><environment>COAST</environment><super>COAST.CMVolumeOperationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMWaitForBackupFinishedRequest</name><environment>COAST</environment><super>COAST.CMVolumeOperationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMVolumeBackupRequest</name><environment>COAST</environment><super>COAST.CMVolumeOperationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CMRecoverToVolumeRequest</name><environment>COAST</environment><super>COAST.CMBackupOperationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><shared-variable><name>TimeCheckpoint</name><environment>COAST.CatRMMediatorCC</environment><private>false</private><constant>false</constant><category>usedInGC</category><initializer>0</initializer><attributes><package>COASTMediator</package></attributes></shared-variable><shared-variable><name>Default</name><environment>COAST.CoastMediator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>COASTMediator</package></attributes></shared-variable><shared-variable><name>MaxSilentSeconds</name><environment>COAST.CatRMMediatorPacketStation</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COASTMediator</package></attributes></shared-variable><shared-variable><name>MaxReconnectSeconds</name><environment>COAST.CatRMMediatorPacketStation</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COASTMediator</package></attributes></shared-variable><shared-variable><name>ImplementationFrameClasses</name><environment>COAST.CatRMMediatorFrame</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>CatRMMediatorFrame buildImplementationFrameClasses</initializer><attributes><package>COASTMediator</package></attributes></shared-variable><methods><class-id>COAST.CoastMediatorConfiguration</class-id> <category>parameters - blobservice</category><body package="COASTMediator">configureBlobServiceFor: mediator	&lt;applicationConfiguration&gt;		| startBlobService blobService |	startBlobService := iniAccess booleanAt: CoastConstant iniAccessStartBlobService ifAbsent: [ ^ self ].	startBlobService ifTrue: 		[			blobService := MediatorBlobService new.			mediator addSubApplication: blobService.		].</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>accessing</category><body package="COASTMediator">parseCompressVolume: stream 	&lt;commandlineParameter: #compressVolume		canPerform: nil		aliases: nil		usage: 'compressVolume {volume name}'		help: 'start a compression of volume named {volume name}, returns immediately (needs -password).'		&gt;		| volumeName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to start compress on not specified' ].	self startAction: 		[ | statusResponse |			statusResponse := CoastMediatorStub compressVolume: volumeName atHost: self serverHost remotePassword: self remotePassword.			self showStatusResponseAndQuit: statusResponse 		].</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>parameters</category><body package="COASTMediator">parseBFSCommand: stream 	&lt;	commandlineParameter: #bfscommand		canPerform: nil		aliases: nil		usage: 'bfscommand {volume name} {command}'		help: 'execute a {command} for the block file system of {volume name}; commands may have further parameters; possible commands: dumpbadblocks {target directory}, checkfragmentation, extractblock {block number} {target file}, copyto {target volume}'		&gt;	[ | cmdLineIndexBlock |		cmdLineIndexBlock := CatBFBlockFileSystem parseBFSCommand: stream.		self startAction: 			[	cmdLineIndexBlock value.				self shutDownAndQuit			]	] on: CatBFError		do: 		[: ex |			CoastLog logException: ex message: 'Error while evaluating BFS command'.			CoastLog enableConsoleWhile: [ CoastLog logError: ex description ].			self shutDownAndQuit		]."	| stream |	stream := String new writeStream.	stream nextPutAll: 'execute a {command} for the block file system of {volume name}; commands may have further parameters; possible commands: '.	CatBFBlockFileSystem commandLineParameters keys do: [ : string | stream nextPutAll: string ] separatedBy: [ stream nextPutAll: ', ' ].	stream contents"</body><body package="COASTMediator">parseBackup: stream 	&lt;commandlineParameter: #backup		canPerform: nil		aliases: nil		usage: 'backup {volume name}'		help: 'perform backup of volume {volume name}, wait for completion (needs password).'		&gt;		| volumeName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to backup not specified' ].	self startAction: 		[ | statusResponse |			statusResponse := CoastMediatorStub backupVolume: volumeName atHost: self serverHost remotePassword: self remotePassword.			self consoleShow: statusResponse message.			statusResponse code = CoastStatusResponse codeBackupStarted 				ifTrue: 				[	statusResponse := CoastMediatorStub blockUntilBackupIsDoneVolume: volumeName atHost: self serverHost.					self consoleShow: statusResponse message				].			self terminateWithStatusResponse: statusResponse		].</body><body package="COASTMediator">parseBaseDirectory: stream	&lt;	commandlineParameter: #volumes		canPerform: nil		aliases: #(baseDirectory)		usage: 'volumes {directory name}'		help: 'set the base {directory name} for the volumes handled by this mediator'		&gt;	baseDirectory := stream next ifNil: [ self commandLineError: 'Base directory not specified' ]</body><body package="COASTMediator">parseDisable: stream	&lt;	commandlineParameter: #disableRequest		canPerform: nil		aliases: nil		usage: 'disableRequest {request number}'		help: 'disable specific coast request with {request number}'		&gt;	| requestID |	requestID := stream next ifNotNil: [ : s | s asInteger ] ifNil: [ self commandLineError: 'Request to disable not specified' ].	self disableRequest: requestID</body><body package="COASTMediator">parseDownload: stream	&lt;	commandlineParameter: #download		canPerform: nil		aliases: nil		usage: 'download {remote volume name} {local volume name}'		help: 'download remote volume {remote volume name} to local directory {local volume name} (needs password).'		&gt;	| volumeName targetName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to download not specified' ].	targetName := stream next ifNil: [ self commandLineError: 'Target volume name not specified' ].	self startAction: 		[ | targetDir | 			[	| statusResponse | 				targetDir := self volumesDirectoryOrDefault asFilename.				self consoleShow: 'Downloading volume "' , volumeName , '" to local volume "' , targetName , '" in directory "' , targetDir asString , '"'.				statusResponse := CoastMediatorStub downloadVolume: volumeName fromHost: self serverHost toLocalVolume: targetName in: targetDir remotePassword: self remotePassword.				self showStatusResponseAndQuit: statusResponse.			] on: CoastError				do: 				[: ex |					self consoleShow: ex description.					Notifier isDevelopment ifFalse: [ ObjectMemory quitWithError: CoastExitCode operationFailed ]				]		].</body><body package="COASTMediator">parseEnable: stream	&lt;	commandlineParameter: #enableRequest		canPerform: nil		aliases: nil		usage: 'enableRequest {request number}'		help: 'enable specific coast request with {request number}'		&gt;	| requestID |	requestID := stream next ifNotNil: [ : s | s asInteger ] ifNil: [ self commandLineError: 'Request to enable not specified' ].	self enableRequest: requestID</body><body package="COASTMediator">parseHost: stream	&lt;	commandlineParameter: #host		canPerform: nil		aliases: nil		usage: 'host {hostname:port}'		help: 'set hostname and port number of another mediator process to connect to (used with other options)'		&gt;	| index |	serverHost := stream next ifNil: [ self commandLineError: 'Host name not specified' ].	index := serverHost indexOf: $:.	index &gt; 1 		ifTrue: [			self serverPort: ( serverHost copyFrom: index + 1 to: serverHost size ) asInteger.			serverHost := serverHost copyFrom: 1 to: index - 1			]		ifFalse: [ 			self serverPort: self class defaultServerPort.			].</body><body package="COASTMediator">parseIdleTimeout: stream	&lt;	commandlineParameter: #clientTimeout		canPerform: nil		aliases: nil		usage: 'clientTimeout {seconds}'		help: 'disconnect idle clients after {seconds}'		&gt;	| timeout |	timeout := stream next ifNotNil: [ : s | s asInteger ] ifNil: [ self commandLineError: 'Timeout not specified' ].	timeout &gt; 0		ifTrue: [ CatRMMediatorPacketStation maxSilentSeconds: timeout ]</body><body package="COASTMediator">parseInfoGC: stream	&lt;	commandlineParameter: #infoGC		canPerform: nil		aliases: nil		usage: 'infoGC {volume name}'		help: 'print the garbage collection status of  volume {volume name} to the console (needs password).'		&gt;	| volumeName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to get information from garbage collection not specified' ].	self startAction: 		[	| statusResponse |			statusResponse  := (CoastMediatorStub statusGCAtHost: self serverHost volume: volumeName remotePassword: self remotePassword).			self showStatusResponseAndQuit: statusResponse.		].</body><body package="COASTMediator">parseNewPassword: stream 	&lt;	commandlineParameter: #newPassword		canPerform: nil		aliases: nil		usage: 'newPassword {password string}'		help: 'change the password of a running mediator (needs password).'		&gt;		| newPassword |	newPassword := stream next ifNil: [ self commandLineError: 'new password not specified' ].	self startAction: 		[ 			[	| statusResponse |				statusResponse := CoastMediatorStub sendTo: self serverHost					requestID: CoastConstant changeRemotePasswordID					andStrings: ( Array with: self remotePassword with: newPassword )					receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream  ].				self showStatusResponseAndQuit: statusResponse.			] on: CoastError				do: 				[: ex |					self consoleShow: ex description.					Notifier isDevelopment ifFalse: [ ObjectMemory quitWithError: CoastExitCode operationFailed ]				]		].</body><body package="COASTMediator">parsePassword: stream	&lt;	commandlineParameter: #password		canPerform: nil		aliases: nil		usage: 'password {password string}'		help: 'set the password for a starting mediator or provide the password for specific requests'		&gt;	| pwd |	pwd := stream next ifNil: [ self commandLineError: 'Password not specified' ].	self remotePassword: pwd.</body><body package="COASTMediator">parsePauseGC: stream	&lt;	commandlineParameter: #pauseGC		canPerform: nil		aliases: nil		usage: 'pauseGC {volume name}'		help: 'pause a running garbage collection of {volume name} (needs password).'		&gt;	| volumeName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to pause garbage collection not specified' ].	self startAction: 		[	| statusResponse |			statusResponse := CoastMediatorStub pauseGCAtHost: self serverHost volume: volumeName remotePassword: self remotePassword.			self showStatusResponseAndQuit: statusResponse.		].</body><body package="COASTMediator">parsePidFile: stream	&lt;	commandlineParameter: #pidfile		canPerform: nil		aliases: #()		usage: 'pidfile {file name}'		help: 'write the process id of this process to the file named {file name}'		&gt;	| fn |	fn := stream next.	fn isNil 		ifTrue: [ self errorInCommandLine: 'Pid file name not specified'. ]		ifFalse: [ self pidFilename: fn. ].</body><body package="COASTMediator">parsePort: stream	&lt;	commandlineParameter: #port		canPerform: nil		aliases: nil		usage: 'port {port number}'		help: 'listen on tcp/ip {port number}'		&gt;	| port |	port := stream next ifNotNil: [ : s | s asInteger ] ifNil: [ self commandLineError: 'Server port not specified' ].	self serverPort: port.</body><body package="COASTMediator">parseQuickRecover: stream	&lt;	commandlineParameter: #quickRecover		canPerform: nil		aliases: nil		usage: 'quickRecover {volume name}'		help: 'perform a fast recover of the volume with name {volume name}'		&gt;	| volumeName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to recover not specified' ].	self startAction: 		[	self quickRecoverVolume: volumeName.			Notifier isDevelopment ifFalse: [ ObjectMemory quit ].		].</body><body package="COASTMediator">parseRecover: stream 	&lt;	commandlineParameter: #recover		canPerform: nil		aliases: nil		usage: 'recover {volume name}'		help: 'perform a full recover of the volume with name {volume name}'		&gt;	| volumeName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to recover not specified' ].	self startAction: 		[	self recoverVolume: volumeName.			Notifier isDevelopment 				ifFalse: [ ObjectMemory quit ]		].</body><body package="COASTMediator">parseStartBackup: stream 	&lt;commandlineParameter: #startBackup		canPerform: nil		aliases: nil		usage: 'startBackup {volume name}'		help: 'start backup of volume {volume name} (needs password).'		&gt;		| volumeName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to backup not specified' ].	self startAction: 		[ | statusResponse |			statusResponse := CoastMediatorStub backupVolume: volumeName atHost: self serverHost remotePassword: self remotePassword.			self showStatusResponseAndQuit: statusResponse.		].</body><body package="COASTMediator">parseStartGC: stream	&lt;	commandlineParameter: #startGC		canPerform: nil		aliases: nil		usage: 'startGC {volume name}'		help: 'start garbage collection of volume {volume name}, returns immediately (needs password).'		&gt;	| volumeName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to start garbage collection not specified' ].	self startAction: 		[	| statusResponse |			statusResponse  := CoastMediatorStub startGCAtHost: self serverHost volume: volumeName remotePassword: self remotePassword.			self showStatusResponseAndQuit: statusResponse .		].</body><body package="COASTMediator">parseStop: stream	"stopAt: now by -host theHostToKill -stop"	&lt;	commandlineParameter: #stop		canPerform: nil		aliases: nil		usage: 'stop'		help: 'stop another mediator, use host-option to specify (needs password).'		&gt;	self startAction: 		[	| statusResponse |			statusResponse  := ( CoastMediatorStub shutDownMediatorAtHost: self serverHost password: self remotePassword ).			self showStatusResponseAndQuit: statusResponse		].</body><body package="COASTMediator">parseStopGC: stream	&lt;	commandlineParameter: #stopGC		canPerform: nil		aliases: nil		usage: 'stopGC {volume name}'		help: 'stop a running garbage collection of volume {volume name} (needs password).'		&gt;	| volumeName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to stop garbage collection not specified' ].	self startAction: 		[	| statusResponse | 			statusResponse := CoastMediatorStub stopGCAtHost: self serverHost volume: volumeName remotePassword: self remotePassword.			self showStatusResponseAndQuit: statusResponse.		].</body><body package="COASTMediator">parseUseBFS: stream	&lt;	commandlineParameter: #bfs		canPerform: nil		aliases: nil		usage: 'bfs'		help: 'use block file system storage type'		&gt;	CatCSVolumeManager defaultStorageClass: CatBSBlockFileVolumeAccessor.</body><body package="COASTMediator">parseUseFS: stream	&lt;	commandlineParameter: #fs		canPerform: nil		aliases: nil		usage: 'fs'		help: 'use multiple files storage type'		&gt;	CatCSVolumeManager defaultStorageClass: CatCSVolumeFileStorageAccessor.</body><body package="COASTMediator">parseWaitForBackup: stream	&lt;	commandlineParameter: #waitForBackup		canPerform: nil		aliases: nil		usage: 'waitForBackup {volume name}'		help: 'wait for the backup of volume {volume name} to be finished'		&gt;	| volumeName |	volumeName := stream next ifNil: [ self commandLineError: 'Volume to backup not specified' ].	self startAction: 		[	| statusResponse | 			statusResponse := ( CoastMediatorStub blockUntilBackupIsDoneVolume: volumeName atHost: self serverHost ).			self showStatusResponseAndQuit: statusResponse.		].</body></methods><methods><class-id>COAST.CoastAbstractRequest</class-id> <category>actions</category><body package="COASTMediator">answerDisabledRequestAt: aSocketAccessor	| replyStream response |	replyStream := aSocketAccessor writeStream binary.	response := CoastStatusResponse failureCode: #requestDisabled message: 'Request ' , self printString , ' is disabled'.	CoastLog logDebugNotify: response message.	response marshallBinaryTo: replyStream.	replyStream close.</body><body package="COASTMediator">answerInvalidClientVersionTo: aSocketAccessor 	| replyStream response |	replyStream := aSocketAccessor writeStream binary.	response := CoastStatusResponse failureCode: #invalidVersion message: 'Invalid client version'.	CoastLog logDebugNotify: response message.	response marshallBinaryTo: replyStream.	replyStream close.</body><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self subclassResponsibility</body><body package="COASTMediator">performRequestAt: aSocketAccessor readStream: receiveStream 	self enabled		ifTrue: [ 			(self checkClientVersionAt: aSocketAccessor from: receiveStream )				ifTrue: [ 	self basicPerformRequestAt: aSocketAccessor readStream: receiveStream ]				ifFalse: [ self answerInvalidClientVersionTo: aSocketAccessor ].		]		ifFalse: [ self answerDisabledRequestAt: aSocketAccessor ]</body></methods><methods><class-id>COAST.CoastAbstractRequest</class-id> <category>accessing</category><body package="COASTMediator">disable	enabled := false</body><body package="COASTMediator">enable	enabled := true</body><body package="COASTMediator">enabled	^enabled ifNil: [ enabled := true ]</body><body package="COASTMediator">enabled: aBoolean	 enabled := aBoolean</body><body package="COASTMediator">performer: object	^performer := object</body><body package="COASTMediator">requestId	self subclassResponsibility</body></methods><methods><class-id>COAST.CoastAbstractRequest</class-id> <category>printing</category><body package="COASTMediator">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' id: '.	self requestId printOn: aStream.</body></methods><methods><class-id>COAST.CoastAbstractRequest</class-id> <category>private</category><body package="COASTMediator">checkClientVersionAt: aSocketAccessor from: receiveStream 	| stubCoastVersion clientProtocolVersion requiredCoastVersion |	stubCoastVersion := CoastVersion unmarshallBinaryFrom: receiveStream marshaller: nil.	clientProtocolVersion := receiveStream nextOptimized32.	requiredCoastVersion := CoastVersion defaultCoastVersion.	( stubCoastVersion notNil and: [ stubCoastVersion = requiredCoastVersion ]) 		ifFalse: 		[	CoastLog logWarning: 'Old client, version is ' , stubCoastVersion printString , ', required is ' , requiredCoastVersion printString.			^ false		].	clientProtocolVersion = CoastConstant protocolVersion 		ifFalse: 		[	CoastLog 				logWarning: 'Client protocol version is ' , clientProtocolVersion printString , ', required is ' , CoastConstant protocolVersion printString.			^ false		].	^ true</body><body package="COASTMediator">requestFrom: receiveStream socketAccessor: socketAccessor replyStreamDo: aBlock 	| replyStream |	replyStream := socketAccessor writeStream binary.	[ aBlock value: replyStream ] ensure: 		[	replyStream flush.			receiveStream close.			replyStream close		].</body></methods><methods><class-id>COAST.CoastAbstractRequest class</class-id> <category>instance creation</category><body package="COASTMediator">performer: object	^ ( self new )		performer: object;		yourself</body></methods><methods><class-id>COAST.CoastAbstractRequest class</class-id> <category>testing</category><body package="COASTMediator">isAbstractRequest	^ self = CoastAbstractRequest</body></methods><methods><class-id>COAST.CoastMediatorRequest</class-id> <category>private</category><body package="COASTMediator">exclusiveUseDo: aBlock	^ self volumeManager exclusiveUseDo: aBlock</body><body package="COASTMediator">existingClusterManagerForStream: receiveStream 	| volume |	volume := receiveStream nextCoastString.	^self mediator existingClusterManagerForVolume: volume</body><body package="COASTMediator">timeoutDo: aBlock 	^ aBlock coastValueWithinSeconds: self class requestTimeout</body></methods><methods><class-id>COAST.CoastMediatorRequest</class-id> <category>accessing</category><body package="COASTMediator">mediator	^performer</body></methods><methods><class-id>COAST.CoastMediatorRequest</class-id> <category>actions</category><body package="COASTMediator">hasValidPasswordFromStream: receiveStream 	| password |	password := receiveStream nextCoastString.	^ self mediator matchesRemotePassword: password</body><body package="COASTMediator">validPasswordFromStream: receiveStream do: block to: aSocketAccessor 	self requestFrom: receiveStream socketAccessor: aSocketAccessor replyStreamDo:  [ : replyStream |		| statusResponse |		statusResponse := ( self hasValidPasswordFromStream: receiveStream ) 				ifTrue: [ block value: receiveStream ]				ifFalse: [ CoastStatusResponse accessDenied ].		statusResponse marshallBinaryTo: replyStream.	]</body><body package="COASTMediator">volumeInterface	^ self volumeManager volumeInterface</body><body package="COASTMediator">volumeManager	^self mediator volumeManager</body></methods><methods><class-id>COAST.CoastMediatorRequest class</class-id> <category>accessing</category><body package="COASTMediator">requestTimeout	^ 10</body></methods><methods><class-id>COAST.CoastMediatorRequest class</class-id> <category>testing</category><body package="COASTMediator">isAbstractRequest	^ self = CoastMediatorRequest</body></methods><methods><class-id>COAST.CMVolumeOperationRequest</class-id> <category>actions</category><body package="COASTMediator">actionFor: clusterManager with: parameters 	" perform the operation. 	returns a CoastStatusResponse "	^ self subclassResponsibility</body><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: readStream 	self 		validPasswordFromStream: readStream		do: 		[: receiveStream | | parameters volumeName |			parameters := self readParametersFrom: receiveStream.			( parameters size &gt;= 1 and: [( volumeName := parameters first ) isString and: [ volumeName notEmpty ]]) 				ifTrue: 				[						[	self exclusiveUseDo: 							[ | clusterManager |								clusterManager := self mediator clusterManagerForExistingVolume: volumeName ifAbsent: [ nil ].								clusterManager isNil 									ifTrue: [ CoastStatusResponse volumeDoesNotExist: volumeName ]									ifFalse: 									[	self logOperationOn: volumeName parameters: parameters peer: aSocketAccessor getPeer.										self actionFor: clusterManager with: parameters									]							]					] 						on: Error						do: 						[: ex |							CoastLog logFatalException: ex message: self class name , ' failed'.							CoastStatusResponse failureCode: CoastStatusResponse codeUnhandledError message: ex description						]				]				ifFalse: [ CoastStatusResponse failureCode: CoastStatusResponse codeBadVolumeName message: 'No volume name specified' ]		]		to: aSocketAccessor.</body><body package="COASTMediator">readParametersFrom: receiveStream 	^ OrderedCollection with: receiveStream nextCoastString</body></methods><methods><class-id>COAST.CMVolumeOperationRequest</class-id> <category>accessing</category><body package="COASTMediator">logOperationOn: volume parameters: parameters peer: peerSocketAddress 	self class shouldLogOperation 		ifTrue: 		[	CoastLog log: [ self class operationName , ' volume "' , volume , '" from client ' , peerSocketAddress addressPrintString ] channel: #audit		].</body></methods><methods><class-id>COAST.CMVolumeOperationRequest class</class-id> <category>accessing</category><body package="COASTMediator">operationName	^ self name asString</body><body package="COASTMediator">shouldLogOperation	^ true</body></methods><methods><class-id>COAST.CMVolumeOperationRequest class</class-id> <category>testing</category><body package="COASTMediator">isAbstractRequest	^ self = CMVolumeOperationRequest</body></methods><methods><class-id>COAST.CMVolumeCompressRequest</class-id> <category>actions</category><body package="COASTMediator">actionFor: clusterManager with: parameters 	^ clusterManager compress</body></methods><methods><class-id>COAST.CMVolumeCompressRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^ CoastConstant compressVolumeID</body></methods><methods><class-id>COAST.CMVolumeCompressRequest class</class-id> <category>accessing</category><body package="COASTMediator">operationName	^ 'Compress'</body></methods><methods><class-id>COAST.CMVolumeCopyRequest</class-id> <category>actions</category><body package="COASTMediator">actionFor: clusterManager with: parameters 	| target |	clusterManager saveAllModifiedClusters.	target := parameters at: 2.	CoastLog log: 'Copying volume to "', target, '"'.	^ clusterManager copyVolumeTo: target</body><body package="COASTMediator">readParametersFrom: receiveStream 	^ OrderedCollection 		with: receiveStream nextCoastString		with: receiveStream nextCoastString</body></methods><methods><class-id>COAST.CMVolumeCopyRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant copyVolumeID</body></methods><methods><class-id>COAST.CMVolumeCopyRequest class</class-id> <category>accessing</category><body package="COASTMediator">operationName	^ 'Copy'</body></methods><methods><class-id>COAST.CMGCStatusRequest</class-id> <category>actions</category><body package="COASTMediator">actionFor: clusterManager with: noArguments 	| gcoll |	gcoll := clusterManager garbageCollector.	^ gcoll isNil 		ifTrue: [ 	CoastStatusResponse okCode: #gcInactive message: 'GC not active' ]		ifFalse: [ CoastStatusResponse okCode: #gcActive message: gcoll statusString ]</body><body package="COASTMediator">requestId	^ CoastConstant statusGCID</body></methods><methods><class-id>COAST.CMGCStatusRequest class</class-id> <category>accessing</category><body package="COASTMediator">operationName	^ 'Status'</body><body package="COASTMediator">shouldLogOperation	^ false</body></methods><methods><class-id>COAST.CMVolumeTransferRequest class</class-id> <category>testing</category><body package="COASTMediator">isAbstractRequest	^ self = CMVolumeTransferRequest</body></methods><methods><class-id>COAST.CMVolumeUploadRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | | password volume statusResponse |			password := receiveStream nextCoastString.			statusResponse := ( self mediator matchesRemotePassword: password ) 					ifTrue: 					[	volume := receiveStream nextCoastString.						[ | message |							volume isValidVolumeString 								ifFalse: [ CoastError raiseSignal: 'Bad volume name: ' , volume ].							CoastLog log: [ 'Uploading volume "' , volume , '" from client ', aSocketAccessor getPeer addressPrintString ] channel: #audit.							self volumeManager exclusiveUseDo: [ self uploadVolume: volume readStream: receiveStream ]. 							message := 'Uploaded volume "', volume, '"'.							CoastLog log: message.							CoastStatusResponse okCode: #volumeUploaded message: message						] 							on: Error							do: 							[: ex | | message |								message := 'Upload of volume "' , volume , '" failed'.								CoastLog logException: ex message: message.								CoastStatusResponse failureCode: #volumeUploadFailed message: message , ': ' , ex description							]					]					ifFalse: [ CoastStatusResponse accessDenied ].			statusResponse marshallBinaryTo: replyStream		].</body><body package="COASTMediator">uploadVolume: volume readStream: receiveStream 	| clusterManager |	clusterManager := self volumeManager clusterManagerForVolume: volume.	[			[ clusterManager storageInterface receiveVolumeFrom: receiveStream ] ensure: [ clusterManager cleanup ]	] 		on: Error		do: 		[: ex |			clusterManager cleanup.			clusterManager deleteVolume.			ex pass		].</body></methods><methods><class-id>COAST.CMVolumeUploadRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant uploadVolumeID</body></methods><methods><class-id>COAST.CMVolumeUploadRequest class</class-id> <category>testing</category><body package="COASTMediator">isAbstractRequest	^false</body></methods><methods><class-id>COAST.CMVolumeReplaceRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | | password volume tempVolume statusResponse message |			password := receiveStream nextCoastString.			statusResponse := ( self mediator matchesRemotePassword: password ) 					ifTrue: 					[	volume := receiveStream nextCoastString.						[	volume isValidVolumeString 								ifFalse: [ CoastError raiseSignal: 'bad volume name: ' , volume ].							tempVolume := volume , Timestamp now asSeconds printString.							CoastLog log: [ 'Replacing volume "' , volume , '" with volume from client ', aSocketAccessor getPeer addressPrintString ] channel: #audit.							self volumeManager exclusiveUseDo: 								[	self uploadVolume: tempVolume readStream: receiveStream.									self volumeManager replaceVolume: volume with: tempVolume								].							message := 'Volume "' , volume , '" replaced'.							CoastLog log: message.							CoastStatusResponse okCode: #volumeReplaced message: message						] on: Error do: [: ex | CoastStatusResponse failureCode: #volumeReplaceFailed message: ex description ]					]					ifFalse: [ CoastStatusResponse accessDenied ].			statusResponse marshallBinaryTo: replyStream		].</body></methods><methods><class-id>COAST.CMVolumeReplaceRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant replaceVolumeID.</body></methods><methods><class-id>COAST.CMGCRequest</class-id> <category>actions</category><body package="COASTMediator">actionFor: clusterManager with: parameters 	^ self actionForClusterManager: clusterManager</body><body package="COASTMediator">actionForClusterManager: cm 	self subclassResponsibility.</body><body package="COASTMediator">readParametersFrom: readStream 	^ Array with: readStream nextCoastString</body></methods><methods><class-id>COAST.CMGCRequest class</class-id> <category>testing</category><body package="COASTMediator">isAbstractRequest	^ self = CMGCRequest</body></methods><methods><class-id>COAST.CMStopGCRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant stopGCID.</body></methods><methods><class-id>COAST.CMStopGCRequest</class-id> <category>actions</category><body package="COASTMediator">actionForClusterManager: cm	^ cm stopCollectingGarbage.</body></methods><methods><class-id>COAST.CMStopGCRequest class</class-id> <category>accessing</category><body package="COASTMediator">operationName	^ 'Stop garbage collection'</body></methods><methods><class-id>COAST.CMPauseGCRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant pauseGCID.</body></methods><methods><class-id>COAST.CMPauseGCRequest</class-id> <category>actions</category><body package="COASTMediator">actionForClusterManager: cm	^ cm pauseCollectingGarbage</body></methods><methods><class-id>COAST.CMPauseGCRequest class</class-id> <category>accessing</category><body package="COASTMediator">operationName	^ 'Pause garbage collection'</body></methods><methods><class-id>COAST.CMStartGCRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant startGCID.</body></methods><methods><class-id>COAST.CMStartGCRequest</class-id> <category>actions</category><body package="COASTMediator">actionForClusterManager: cm 	^ cm collectGarbage.</body></methods><methods><class-id>COAST.CMStartGCRequest class</class-id> <category>accessing</category><body package="COASTMediator">operationName	^ 'Start garbage collection'</body></methods><methods><class-id>COAST.CoastMediatorConfiguration</class-id> <category>parameters - memory</category><body package="COASTMediator">growthRegimeMarginFactor	" Leave more room, Mediator does not need a large working set "	^ 0.4</body></methods><methods><class-id>COAST.CoastMediatorConfiguration</class-id> <category>config</category><body package="COASTMediator">configureApplicationPragmasFor: mediator 	self 		configurePragma: #applicationConfiguration for: mediator.</body><body package="COASTMediator">configurePluginPragmasFor: application 	self 		configurePragma: #pluginConfiguration for: nil;		configurePragma: #pluginApplicationConfiguration for: application.</body></methods><methods><class-id>COAST.CatRMMediatorVolumeManager</class-id> <category>accessing</category><body package="COASTMediator">availableVolumes	^ self volumeInterface storedVolumes</body><body package="COASTMediator">basicExclusiveUseDo: aBlock	"evaluate a block ensuring exclusive use of all clusters"	^exclusiveLock critical: aBlock</body><body package="COASTMediator">clients	^packetStations values</body><body package="COASTMediator">clusterManagerClass	^CatRMMediatorClusterManager</body><body package="COASTMediator">clusterReleaseDelay	" VerzÃ¶gerung (in Sekunden), bevor ein ClusterController ohne Clients entfernt wird.	wirkt nur auf Cluster, in denen per #fastAt:... auf Implementierungsframes zugegriffen wird. Dies ist derzeit nur beim Cluster 0 (lastWishes) und bei Clustern mit Indexstrukturen der Fall.	alle anderen (mit MediatorFrames bzw nicht per LastWishTransaction oder coastRPC zugegriffenen Frames) werden asap vom Mediator abgelegt	dies ist eine ursprÃ¼nglich nicht beabsichtigte Implementierung, die aber durchaus ihre Vorteile hat :-)	=&gt; Insbesondere die VerzÃ¶gerung zwischen dem Disconnect des letzten Clients und dem ShutDown des Volumes"	^ clusterReleaseDelay ifNil: [ 300 ]</body><body package="COASTMediator">clusterReleaseDelay: aNumber 	" VerzÃ¶gerung (in Sekunden), bevor ein ClusterController ohne Clients entfernt wird.	wirkt nur auf Cluster, in denen per #fastAt:... auf Implementierungsframes zugegriffen wird. Dies ist derzeit nur beim Cluster 0 (lastWishes) und bei Clustern mit Indexstrukturen der Fall.	alle anderen (mit MediatorFrames bzw nicht per LastWishTransaction oder coastRPC zugegriffenen Frames) werden asap vom Mediator abgelegt	dies ist eine ursprÃ¼nglich nicht beabsichtigte Implementierung, die aber durchaus ihre Vorteile hat :-)	=&gt; Insbesondere die VerzÃ¶gerung zwischen dem Disconnect des letzten Clients und dem ShutDown des Volumes"	clusterReleaseDelay := aNumber.</body><body package="COASTMediator">compactFreedMemoryThreshold	" note: refers to cluster size on disk "	^ compactFreedMemoryThreshold ifNil: [ compactFreedMemoryThreshold := 10 * 1024 * 1024 ]</body><body package="COASTMediator">compactFreedMemoryThreshold: anInteger 	" note: refers to cluster size on disk "	compactFreedMemoryThreshold := anInteger.</body><body package="COASTMediator">deregisterPersistentClientPS: packetStation	| pid |	self statusLog: 'Client ', packetStation peerString, ' deregistered'.	pid := packetStation persistentClientID .	self persistentClients removeKey: pid ifAbsent: [ ].</body><body package="COASTMediator">exclusiveUseDo: aBlock 	clusterManagers do: [:e | e interruptGC].	^[self basicExclusiveUseDo: aBlock]		ensure: [clusterManagers do: [:e | e proceedGC]]</body><body package="COASTMediator">gcExclusiveUseDo: aBlock	^ self basicExclusiveUseDo: aBlock</body><body package="COASTMediator">newClusterManagerForVolume: aVolume 	| cm |	self class checkVolumeName: aVolume.	cm := self clusterManagerClass new.	self initializeClusterManager: cm forVolume: aVolume.	self registerClusterManager: cm volume: aVolume.	self statusLog: 'clusterManager ' , aVolume , ' started'.	^ cm</body><body package="COASTMediator">persistentClients	"persistent client id - &gt; packet station dictionary"	^ persistentClients</body><body package="COASTMediator">prepareNewConnectedPacketStation: packetStation 	| pid oldPS |	pid := packetStation persistentClientID.	oldPS := self persistentClients at: pid ifAbsent: [ nil ].	oldPS notNil ifTrue: 		[	CoastLog 				logWarning: 'Removing old packet station: ' , oldPS peerID printString.			" client does not want to reconnect. remove smelly PS "			clusterManagers do: [: cm | cm executeLastWishesFor: oldPS peerID ].			oldPS disconnectIrreversible		].	self persistentClients at: pid put: packetStation</body><body package="COASTMediator">quickCompactFreedMemoryThreshold	" note: refers to cluster size on disk "	^ quickCompactFreedMemoryThreshold ifNil: [ quickCompactFreedMemoryThreshold := 512 * 1024 ]</body><body package="COASTMediator">quickCompactFreedMemoryThreshold: anInteger 	" note: refers to cluster size on disk "	quickCompactFreedMemoryThreshold := anInteger.</body><body package="COASTMediator">removeClusterManager: name	clusterManagers removeKey: name ifAbsent: [^self].	self statusLog: 'clustermanager ' , name , ' finished.'</body></methods><methods><class-id>COAST.CatRMMediatorVolumeManager</class-id> <category>packet stations</category><body package="COASTMediator">calculateNewID	"come up with a new unique client id"	"avoid using client-ids twice during reasonable time spans"	| id |	id := nextClientID.	nextClientID := nextClientID + 1.	"allow turn over at 65535 or better SmallInteger maxVal"	(nextClientID &gt;= SmallInteger maxVal) ifTrue: [ nextClientID := 1. ].	^ id</body><body package="COASTMediator">clientIPNumbers	^packetStations values collect: [ :packetStation | packetStation peerIPNumber ]</body><body package="COASTMediator">clientReConnectionAt: aSocketAccessor receiveStream: aReceiveStream 	"a client packet station wants to re-connect"	| clientID |	clientID := aReceiveStream nextOptimized32.	self exclusiveUseDo: 		[ "try to find the corresponding packet-station"			| ps |			ps := packetStations at: clientID ifAbsent: [ nil ].			ps isNil 				ifTrue: 				[	CatRMMediatorPacketStation fakeReconnectAndFailFor: clientID from: aReceiveStream to: aSocketAccessor writeStream binary.					CoastLog logError: 'packet station is unable to re-connect to unknown client &lt;' , clientID printString , '&gt;'				]				ifFalse: 				[( ps reConnectTo: aSocketAccessor receiveStream: aReceiveStream ) 						ifTrue: [ self statusLog: 'Client [' , clientID printString , '] reconnected: ' , aSocketAccessor getPeer printString ]				]		].</body><body package="COASTMediator">clientRegularDisconnected: clientID 	self exclusiveUseDo: 		[			clusterManagers do: [: cm | cm removeLastWishesFor: clientID ].		].</body><body package="COASTMediator">diedClientID: clientID	"inform all cluster controllers about this event, maybe the client was one of their customers"	clusterManagers do: 	[ :cm | 		cm executeLastWishesFor: clientID.	].</body><body package="COASTMediator">disconnectAllPacketStations	| activePacketStations closedSemaphore notClosed |	activePacketStations := packetStations values.	closedSemaphore := Semaphore new.	" close all connections simulatenously "	notClosed := activePacketStations size.	[	activePacketStations do: 			[: ps |								[	ps closeConnection.					notClosed := notClosed - 1.					closedSemaphore signal				] forkAt: Processor activeProcess priority - 1			].		activePacketStations size timesRepeat: [ closedSemaphore wait ]	] coastValueWithinSeconds: CatRMPacketStation closePacketTimeout + 1.	notClosed &gt; 0 		ifTrue: [ CoastLog log: notClosed printString , ' client(s) did not respond to the close command' ].	packetStations := Dictionary new.</body><body package="COASTMediator">disconnectStations: stations	"this means that the corresponding client had somehow lost the connection"	self exclusiveUseDo: 	[			stations do: [: pStation | 	pStation closeConnection ]	]</body><body package="COASTMediator">fakeReconnectAndFailFor: clientID from: aReceiveStream to: aSendStream 	"a client packet station wants to re-connect, it's an unknown client"	CatRMMediatorPacketStation fakeReconnectAndFailFor: clientID from: aReceiveStream to: aSendStream</body><body package="COASTMediator">newClientConnectionAt: aSocketAccessor receiveStream: aStream		| newPacketStation idForNewPeer |		self exclusiveUseDo:	[		idForNewPeer := self calculateNewID.		newPacketStation := CatRMMediatorPacketStation				newWithSocket: aSocketAccessor				forPeerID: idForNewPeer				receiveStream: aStream				volumeManager: self.		(newPacketStation isNil)		ifTrue:		[			self statusError: 'packet station is unable to connect to new client'.		]		ifFalse:		[			packetStations at: idForNewPeer put: newPacketStation.			newPacketStation activate.			self statusLog: 'Client ', newPacketStation peerString, ' registered'.			self statusLog: 'Client ', newPacketStation peerID printString, ' description: ', newPacketStation peerDescriptionString.		].	].</body><body package="COASTMediator">stationIrreversibleLostConnection: aStation	"this means that the corresponding client had somehow lost the connection,	either intended (shutdown) or not intended (socket error etc.) "	self exclusiveUseDo:	[ | clientID |		clientID := aStation peerID.		"is the information new to me?"		(packetStations includesKey: clientID)		ifTrue:		[			self diedClientID: clientID.			self deregisterPersistentClientPS: aStation.			"after every cc has adapted to the new situation the corresponding client can be removed"			packetStations removeKey: clientID.		].	].</body><body package="COASTMediator">transmitMessage: aCatRMMessage to: clientID 	| ps |	ps := packetStations at: clientID ifAbsent: [nil].	ps isNil 		ifTrue: [self statusError: 'trying to transmit message to unknown client: ', clientID printString.				self diedClientID: clientID.]		ifFalse: [ps transmitMessage: aCatRMMessage]</body></methods><methods><class-id>COAST.CatRMMediatorVolumeManager</class-id> <category>requests</category><body package="COASTMediator">handleConnectionsRequest: aCatRMConnectionsRequest 	"Return a Collection of client ids in response to &lt;aCatRMConnectionsRequest&gt;."	aCatRMConnectionsRequest receiverPacketStation transmitMessage:		(CatRMConnectionsResponse connections: self clientIPNumbers).</body><body package="COASTMediator">handleRequest: aMessage 	self exclusiveUseDo: 		[ | receiverVolume process errorMsg |			aMessage = #timeOut 				ifTrue: 				[	process :=						[	( Delay forSeconds: 15 ) wait.							requestQueue nextPut: #timeOut						] forkAt: Processor activePriority + 1.					process name: 'CoastMediator - autoSaveAndRelease'.					self checkAutoSaveAndRelease				]				ifFalse: 				[ | time |					time := Time millisecondsToRun: 							[	receiverVolume := aMessage receiverVolume.								receiverVolume isNil 									ifTrue: [ aMessage safeInitiateFor: [ self ]]									ifFalse: 									[( self isExistingVolumeForRequest: receiverVolume ) 											ifTrue: 											[	aMessage isRequest 													ifTrue: [ aMessage safeInitiateFor: [ self clusterManagerForVolume: receiverVolume ]]													ifFalse: [( self clusterManagerForVolume: receiverVolume ) handleMessage: aMessage ]											]											ifFalse: 											[	aMessage isRequest 													ifTrue: 													[	errorMsg := CatRMErrorMessage description: 'unknown volume ' , receiverVolume , ' for ' , aMessage printString.														aMessage receiverPacketStation transmitMessage: errorMsg													]													ifFalse: [ self statusError: 'unknown volume ' , receiverVolume , ' for ' , aMessage printString ]											]									]							].					CoastLog logDebug: [ '[' , time printString , ' ms] ' , aMessage printString ] channel: #request minTime: time				]		].</body><body package="COASTMediator">handleVolumesRequest: aCatRMVolumesRequest 	aCatRMVolumesRequest receiverPacketStation transmitMessage: ( CatRMVolumesResponse volumes: self volumeInterface storedVolumes ).</body><body package="COASTMediator">isExistingVolumeForRequest: volume 	^ ( self clusterManagerForVolume: volume ifAbsent: [ nil ]) notNil or: [ self volumeInterface storedVolumes includes: volume ]</body></methods><methods><class-id>COAST.CatRMMediatorVolumeManager</class-id> <category>messages</category><body package="COASTMediator">handleMessage: aCatRMMessage	requestQueue nextPut: aCatRMMessage</body></methods><methods><class-id>COAST.CatRMMediatorVolumeManager</class-id> <category>saving</category><body package="COASTMediator">sync	self exclusiveUseDo:	[		clusterManagers do: [ :cm | cm saveAllModifiedClusters ].	].</body></methods><methods><class-id>COAST.CatRMMediatorVolumeManager</class-id> <category>initialize</category><body package="COASTMediator">emergencyShutDown	self haltOrContinue.	self exclusiveUseDo: 		[	self disconnectAllPacketStations.			clusterManagers copy do: [: cm | cm emergencyShutDown ].			requestProcess isNil ifFalse: [ requestProcess terminate ]		].	Notifier isDevelopment ifFalse: [ ObjectMemory quitPrimitive ]</body><body package="COASTMediator">initialize	super initialize.	nextClientID := 1.	"this will be the ID of my first client"	requestQueue := SharedQueue new.	self initializeRequestProcess.	persistentClients := Dictionary new.	CatRMMediatorFrame buildImplementationFrameClasses</body><body package="COASTMediator">initializeRequestProcess	"just handle requests from the queue until the process will be terminated"	requestQueue nextPut: #timeOut.	requestProcess :=		[				[	"catch all kinds of errors, it would be *very* bad for other clients if this process terminates"				[ self handleRequest: requestQueue next ] on: Error					do: 					[: ex |						self logError: ex message: 'bug in request handling'.						ex isFatalCoastError ifTrue: 							[	CoastLog log: 'Fatal Error -&gt; emergency shutdown'.								self emergencyShutDown							]					].				true			] whileTrue		] fork.	requestProcess name: 'CoastMediator - request process'.</body><body package="COASTMediator">shutDown	"check blocking first"	| notBlocked str |	notBlocked :=		[ self exclusiveUseDo: [ ]] coastValueWithinSeconds: 60.	notBlocked 		ifTrue: 		[	self exclusiveUseDo: 				[	requestProcess isNil 						ifFalse: [ requestProcess terminate ].					self disconnectAllPacketStations.					clusterManagers copy do: 						[: cm |														[ cm releaseAllClusters ] on: Error do: [: ex | CoastLog logException: ex message: 'Shutdown of volume ' , cm volume printString , ' failed' ]						].					volumeInterface notNil ifTrue: [ volumeInterface shutDown ].				]		]		ifFalse: 		[	str := String new writeStream.			str nextPutAll: 'mediator shut down failed: mediator blocked'; cr.			str nextPutAll: exclusiveLock blockerPrintString; cr.			str nextPutAll: 'mediator will exit now anyway ...'; cr.			self statusError: str contents		].</body></methods><methods><class-id>COAST.CatRMMediatorVolumeManager</class-id> <category>volumes</category><body package="COASTMediator">replaceVolume: volume with: replacementVolume	| cm |	(self clusterManagerForVolume: replacementVolume) releaseAllClusters.	cm := self clusterManagerForVolume: volume.	self disconnectStations: cm ownPacketStations.	cm releaseAllClusters.	volumeInterface replaceVolume: volume with: replacementVolume.</body></methods><methods><class-id>COAST.CatRMMediatorVolumeManager</class-id> <category>private</category><body package="COASTMediator">initializeClusterManager: clusterManager forVolume: aVolume	super initializeClusterManager: clusterManager forVolume: aVolume.	clusterManager initializeStorageInterface.	clusterManager loadIndex.	clusterManager executeLastWishes.</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>update</category><body package="COASTMediator">addSlotForUpdate: aSlot 	" ATTENTION: this only works if there are no gaps in the slots array "	| slot slotID newSize |	slots isNil ifTrue: [self unmarshallLazy].	slotID := aSlot id.	1 to: slots size		do: 			[:i | 			slot := slots at: i.			(slot isNil or: [slot id = slotID]) 				ifTrue: 					[slots at: i put: aSlot.					^self]].	newSize := slots size + 1.	slots changeSizeTo: newSize.	slots at: newSize put: aSlot</body><body package="COASTMediator">slotAccessForUpdate: aCatRMSlotAccess argumentTranslationBlock: translationBlock transaction: aTransaction 	| slot access |	slot := self slotAt: aCatRMSlotAccess slotName asSymbol.	slot isNil ifTrue: 		[	aCatRMSlotAccess accessClass = COAST.CatCSDepleteAccess ifTrue: [ ^ self ].			CoastFatalError raiseSignal: 'slot ' , aCatRMSlotAccess slotName , ' not found - slot access failed'		].	access := aCatRMSlotAccess createCellAccessWith: translationBlock.	access transaction: aTransaction.	slot accessForUpdate: access.</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>compatibility</category><body package="COASTMediator">basicSlotNamed: slotName	^self slotAt: slotName</body><body package="COASTMediator">cellContainer: aCluster 	cluster := aCluster</body><body package="COASTMediator">coastCompareFrameOrReferenceTo: frame 	| clusterID |	clusterID := self clusterID.	^ clusterID = frame clusterID 		ifTrue: [ frameID coastCompareTo: frame frameID ]		ifFalse: [ clusterID coastCompareTo: frame clusterID ]</body><body package="COASTMediator">coastCompareTo: frame 	^ ( frame coastCompareFrameOrReferenceTo: self ) negated</body><body package="COASTMediator">isPrototype	^false</body><body package="COASTMediator">notifyFastRead	"i don't care - do you?"</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>slots</category><body package="COASTMediator">basicSlots	slots isNil ifTrue: [self unmarshallLazy].	^slots</body><body package="COASTMediator">slotAt: slotID	^ self basicSlots detect: [ :slot | slot notNil and: [ slot id = slotID ]] ifNone: [ nil ]</body><body package="COASTMediator">slotClass	^CatRMMediatorSlot</body><body package="COASTMediator">slotExists: slotName	^ (self slotAt: slotName) notNil</body><body package="COASTMediator">slotNames	^self basicSlots collect: [: slot | slot id ]</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>initialize-release</category><body package="COASTMediator">breakReferences	slots := nil</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>accessing</category><body package="COASTMediator">asCompactArgument	^ self frameReference</body><body package="COASTMediator">asValidFrameReferenceOrNil	^self frameReference</body><body package="COASTMediator">at: slot 	^ ( self slotAt: slot ) valueHolder valueForReadAccess</body><body package="COASTMediator">at: slotName set: anObject 	| slot access |	slot := self basicSlotNamed: slotName.	access := CatCSValueWriteAccess cell: slot argument: anObject.	access transaction recordAccess: access.	^ access performOn: slot valueHolder</body><body package="COASTMediator">byteArrayIndex	^ nil</body><body package="COASTMediator">cluster	^cluster</body><body package="COASTMediator">cluster: aCluster 	cluster := aCluster</body><body package="COASTMediator">clusterID	^ self cluster id</body><body package="COASTMediator">coastFrameDictKey	^ self frameClassSymbol</body><body package="COASTMediator">coastInternalRemoveFromCluster	"nothing to do..."</body><body package="COASTMediator">coastInternalRemoveSlotNamed: slotID 	^ slots := self basicSlots reject: [: slot | slot id = slotID ]</body><body package="COASTMediator">frame</body><body package="COASTMediator">frameClassName	^frameClassSymbol asString</body><body package="COASTMediator">frameClassName: aStringOrSymbol	frameClassSymbol := aStringOrSymbol asSymbol</body><body package="COASTMediator">frameClassSymbol	^frameClassSymbol</body><body package="COASTMediator">frameID	^frameID</body><body package="COASTMediator">frameReference	^ CatFSFrameReference frame: self</body><body package="COASTMediator">frameReferenceOrSelf	^ CatFSFrameReference frame: self</body><body package="COASTMediator">fullIDNumber	" 64 bit number "	^ self isLocal 		ifTrue: [ 0 ]		ifFalse: 		[	self frameID positive 				ifTrue: [( self clusterID bitShift: 32 ) bitOr: self frameID ]				ifFalse: [(( self clusterID bitShift: 32 ) bitOr: self frameID abs ) negated ]		]</body><body package="COASTMediator">id	^frameID</body><body package="COASTMediator">id: anInteger	frameID := anInteger</body><body package="COASTMediator">replaceConflictiongBlobIDWith: newBlobID 	"fixing code of the GC"	| loggedTransactionAgenda simpleAgenda access clusterController |	clusterController := self cluster clusterController.	"build access"	access := CatCSValueWriteAccess argument: newBlobID.	access cell: ( self basicSlotNamed: #fileID ).	"agenda"	simpleAgenda := CatRMSimpleAgenda new.	simpleAgenda addWriteAccess: access.	simpleAgenda cluster: self cluster.	"loggedTransactionAgenda"	loggedTransactionAgenda := CatRMLoggedTransactionAgenda new.	loggedTransactionAgenda transactionID: ( clusterController fakedTransactionIDFor: simpleAgenda ).	loggedTransactionAgenda agenda: simpleAgenda.	"do it"	clusterController doAndBroadcast: loggedTransactionAgenda client: 0</body><body package="COASTMediator">transactionManager	^cluster transactionManager</body><body package="COASTMediator">unmarshaller	^cluster unmarshaller</body><body package="COASTMediator">unwrappedCell	^self</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>gc accessing</category><body package="COASTMediator">frameLocator	^ self</body><body package="COASTMediator">referencedFile	| fileID fileIDSlot sym |	sym := self frameClassSymbol.	((sym = #'CoastBinaryContainer') or: [ sym = #'COAST.CoastBinaryContainer' ])		ifFalse: [ ^nil ]. "only these can reference files"	fileIDSlot := self slotAt: #fileID.	fileIDSlot isNil ifTrue: [ ^nil ].	fileID := fileIDSlot resolvedCellValue.	^ fileID</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>testing</category><body package="COASTMediator">foundByGarbageCollector: aGarbageCollector inClusterID: aClusterID	aGarbageCollector foundClusterID: self clusterID frameID: self frameID</body><body package="COASTMediator">isCell	^true</body><body package="COASTMediator">isFrameOrFrameReference	^true</body><body package="COASTMediator">isLocal	^ false</body><body package="COASTMediator">isValidAccessParameter	^ true</body><body package="COASTMediator">selfOrFrameLocator	^ CatCSFrameLocator newFrameID: frameID clusterID: self clusterID</body><body package="COASTMediator">shouldHandleJournalAccess	^ true</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>marshalling</category><body package="COASTMediator">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall 	aCatRMMarshall frameSlotIndexForSymbol: self frameClassSymbol.	self unmarshallBeforeMarshallIfNecessaryWith: aCatRMMarshall.	"byteArray can be nil now (after unmarshallLazy) -&gt; check again!"	byteArray isNil ifTrue: [ self basicSlots do: [: slot | slot ensureUpdatedFrameSlotIndexWith: aCatRMMarshall frame: self ]].</body><body package="COASTMediator">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	self frameReference marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall</body><body package="COASTMediator">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	"unmarshall now or update is futile"	| bstr |	self unmarshallBeforeMarshallIfNecessaryWith: aCatRMMarshall.	"byteArray can be nil now (after unmarshallLazy) -&gt; check again!"	byteArray isNil 		ifTrue: 		[	" marshal slots to a temporary stream "			slots := self basicSlots reject: [: slot | slot isNil ].			aCatRMMarshall tempBytesDo: 				[: tempBytes | | byteSize |					bstr := tempBytes writeStream.					bstr nextPut: slots size.					slots do: 						[: slot |							aCatRMMarshall writeSlotName: slot id frame: self to: bstr.							slot marshallBinaryTo: bstr marshaller: aCatRMMarshall						].					byteSize := bstr position.					aStream nextOptimized32Put: byteSize.					aStream next: byteSize putAll: tempBytes startingAt: 1				]		]		ifFalse: 		[	" marshal stored slot bytes "			aStream nextOptimized32Put: byteArray size.			aStream nextPutAll: byteArray		].</body><body package="COASTMediator">marshallBinaryValueTo: aStream marshaller: aCatRMMarshall 	self clusterID = aCatRMMarshall currentClusterID 		ifTrue: [ CatFSFrameID marshallBinaryValue: self frameID to: aStream ]		ifFalse: [ self frameReference marshallBinaryValueTo: aStream marshaller: aCatRMMarshall  ].</body><body package="COASTMediator">privateUnmarshallSlotsFrom: aStream marshaller: aCatRMMarshall slotIDBlock: slotIDBlock 	| numberOfSlots |	numberOfSlots := aStream next.	slots := Array new: numberOfSlots.	1 to: numberOfSlots do: [ : i |		| slot |		slot := self slotClass basicNew.		slot id: slotIDBlock value.		slot cellContainer: self.		slot unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall.		slots at: i put: slot.	]</body><body package="COASTMediator">translatedArgumentForCluster: aCatCSCluster	" Mediator frames should never be referenced "	^ self frameReference</body><body package="COASTMediator">unmarshallBeforeMarshallIfNecessaryWith: aCatRMMarshall 	( byteArray notNil and: [ self unmarshaller wasLoadedFromOldCoastVersion or: [ self cluster clusterController hasOldStyleFrames ]]) ifTrue: 		[				[ self unmarshallLazy ] on: FrameNotFoundError				do: 				[: ex |					ex frameLocator isTempShared 						ifTrue: 						[	CoastLog logWarning: 'TempSharedFrame reference not found: ' , ex frameLocator printString.							ex resume: nil						]						ifFalse: [ ex pass ]				]		].</body><body package="COASTMediator">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	| byteArraySize |	( aCatRMMarshall loadCoastVersion isMin: 4 minor: 3 ) ifTrue: [ byteArraySize := aStream nextOptimized32 ].	( aCatRMMarshall loadCoastVersion isMin: 4 minor: 4 ) 		ifTrue: [ byteArray := aStream next: byteArraySize ]		ifFalse: [ self privateUnmarshallSlotsFrom: aStream marshaller: aCatRMMarshall slotIDBlock: [ aCatRMMarshall readSlotNameFrom: aStream ]].</body><body package="COASTMediator">unmarshallLazy	| frameSlotIndex marshall aStream |	byteArray isNil ifTrue: 		[	slots := Array new.			^ self		].	aStream := byteArray readStream.	marshall := self unmarshaller.	frameSlotIndex := marshall frameSlotIndexForSymbol: self frameClassSymbol.	self privateUnmarshallSlotsFrom: aStream		marshaller: marshall		slotIDBlock: 		[	marshall readSlotNameFrom: aStream withIndex: frameSlotIndex ifOldStyleDo: [ self cluster clusterController oldStyleFrameDetected ]		].	aStream atEnd ifFalse: [ self haltOrError: 'internal error: bytes left after resolving slots for ' , self printString ].	byteArray := nil.</body><body package="COASTMediator">valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall 	aCatRMMarshall frameSlotIndexForSymbol: self frameClassSymbol.</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>printing</category><body package="COASTMediator">classLabel	^ self frameClassName</body><body package="COASTMediator">printOn: stream 	super printOn: stream.	stream nextPut: $:.	self frameID printOn: stream.	stream nextPutAll: ' ('.	self frameClassName printOn: stream.	stream nextPut: $)</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>comparing</category><body package="COASTMediator">= anotherMediatorFrameOrFrameReference 	^ anotherMediatorFrameOrFrameReference == self 		or: [ anotherMediatorFrameOrFrameReference isFrameOrFrameReference and: [ self equalFromFrameLocator: anotherMediatorFrameOrFrameReference ]]</body><body package="COASTMediator">equalFromFrameLocator: frameLocator	^ frameID == frameLocator frameID		and: [ self clusterID == frameLocator clusterID ]</body><body package="COASTMediator">hash	^frameID hash</body></methods><methods><class-id>COAST.CatRMMediatorFrame class</class-id> <category>instanceCreation</category><body package="COASTMediator">addImplementationFrameClass: frameClass 	ImplementationFrameClasses at: frameClass frameClassSymbol put: frameClass</body><body package="COASTMediator">buildImplementationFrameClasses	ImplementationFrameClasses := Dictionary new.	CoastCollection withAllSubclasses do: [: cl | self addImplementationFrameClass: cl ].	CoastCollectionSegment withAllSubclasses do: [: cl | self addImplementationFrameClass: cl ].	self addImplementationFrameClass: CatCSClusterAdministrationFrame.	self addImplementationFrameClass: CoastBinaryStore.	^ ImplementationFrameClasses</body><body package="COASTMediator">newWithFrameClassName: aStringOrSymbol 	| implementationClass |	implementationClass := ImplementationFrameClasses at: aStringOrSymbol asSymbol ifAbsent: [ ^ self basicNew frameClassName: aStringOrSymbol ].	^ ( implementationClass basicNew )		initializeSpawned;		yourself</body></methods><methods><class-id>COAST.CatRMMediatorAgenda</class-id> <category>broadcast</category><body package="COASTMediator">broadcast: someAgendas required: requiredTransactionIDs with: aClusterManager originator: clientID sendToOriginator: sendToOriginator 	| msgs ownRequired writingAgendas |	writingAgendas := someAgendas reject: [ : agenda | agenda isReadOnly ].	writingAgendas isEmpty ifTrue: [ ^ self ].	" check single part or multipart "	( writingAgendas size &gt; 1 or: [ mediatorAgendas notEmpty ]) 		ifTrue: 		[ " multipart "			| allRequired |			msgs := Set new.			ownRequired := writingAgendas collect: [: agenda | agenda transactionID ].			allRequired := ownRequired copy.			allRequired addAll: requiredTransactionIDs.			ownRequired := ownRequired asSortedCollection.			allRequired := allRequired asSortedCollection.			writingAgendas do: 				[: agenda | | msg |					sendToOriginator ifTrue: 						[	" originator does not receive required transaction IDs for its own transaction "							(( aClusterManager clusterControllerAt: agenda transactionID clusterLocator id ) clients includesKey: clientID ) 								ifTrue: 								[	"... except for updates made by the mediator in respons to originator's actions"									msg := CatRMMultiPartUpdateMessage loggedTransactionAgenda: agenda.									msg allSortedTransactionIDs: ownRequired.									aClusterManager transmitMessage: msg to: clientID								]						].					" everyone else receives required transaction IDs for the client and the mediator transaction "					msg := CatRMMultiPartUpdateMessage loggedTransactionAgenda: agenda.					msg allSortedTransactionIDs: allRequired.					msgs add: msg				]		]		ifFalse: 		[	" single part "			msgs := Set with: ( CatRMUpdateMessage loggedTransactionAgenda: writingAgendas singleElement )		].	msgs do: 		[: msg | | cc |			cc := aClusterManager clusterControllerAt: msg loggedTransactionAgenda transactionID clusterLocator id.			cc broadcast: msg exceptTo: clientID		]</body><body package="COASTMediator">broadcastWith: aClustermanager originator: clientID	" send a complete update (client transaction + mediator tranaction) "	self broadcast: clientAgendas required: self mediatorTransactionIDs with: aClustermanager originator: clientID sendToOriginator: false. 	self broadcast: mediatorAgendas required: self clientTransactionIDs with: aClustermanager originator: clientID sendToOriginator: true.</body></methods><methods><class-id>COAST.CatRMMediatorAgenda</class-id> <category>accessing</category><body package="COASTMediator">addClientAgenda: aLoggedTransactionAgenda 	clientAgendas add: aLoggedTransactionAgenda</body><body package="COASTMediator">addMediatorAgenda: aLoggedTransactionAgenda	mediatorAgendas add: aLoggedTransactionAgenda</body><body package="COASTMediator">clientTransactionIDs	^ clientAgendas collect: [: agenda | agenda transactionID ]</body><body package="COASTMediator">mediatorAgendas	^ mediatorAgendas</body><body package="COASTMediator">mediatorTransactionIDs	^ mediatorAgendas collect: [: agenda | agenda transactionID ]</body></methods><methods><class-id>COAST.CatRMMediatorAgenda</class-id> <category>initialize-release</category><body package="COASTMediator">initialize	clientAgendas := Set new.	mediatorAgendas := Set new.</body></methods><methods><class-id>COAST.CatRMMediatorAgenda class</class-id> <category>instance creation</category><body package="COASTMediator">new	^ super new initialize</body></methods><methods><class-id>COAST.CatRMMediatorSlot</class-id> <category>accessing</category><body package="COASTMediator">accessForUpdate: aCatCSCellAccess	| result |	aCatCSCellAccess cell: self.	result := aCatCSCellAccess performOn: self valueHolder.	^result</body><body package="COASTMediator">basicValueAccess: aCatCSCellAccess	^self valueHolder access: aCatCSCellAccess.</body><body package="COASTMediator">basicValueHolderContent	" for compatiblity "	^ self resolvedCellValue</body><body package="COASTMediator">cellContainer	"the container this cell belongs to"	^container isCell ifTrue: [ container ] ifFalse: [ nil ]</body><body package="COASTMediator">cellContainer: aCatCSContainerCell	"the container this cell belongs to"	container := aCatCSContainerCell</body><body package="COASTMediator">cellValue	" By default, the value of the cell is stored in a value holder "	^self valueHolder value.</body><body package="COASTMediator">cluster	"the cluster this cell belongs to, ask container for it"	^self cellContainer isNil ifTrue: [ nil ] ifFalse: [ container cluster ]</body><body package="COASTMediator">clusterID	^ container notNil 		ifTrue: [ container clusterID ]		ifFalse: [ nil ]</body><body package="COASTMediator">clusterManager	^self cellContainer isNil		ifTrue: [ nil ]		ifFalse: [ self cluster clusterManager ]</body><body package="COASTMediator">coastID	^ id</body><body package="COASTMediator">frame	^(self cellContainer isNil) ifTrue: [ nil ] ifFalse: [ container frame ]</body><body package="COASTMediator">id	^id</body><body package="COASTMediator">id: anID	(id ~= anID and: [ id isString or: [ id isSymbol ]])		ifTrue: [ self error: 'Cell already has an ID' ].	id := anID</body><body package="COASTMediator">idPrintString	| stream |	stream := String new writeStream.	self idPrintStringOn: stream.	^ stream contents</body><body package="COASTMediator">idPrintStringOn: stream 	stream nextPut: $[.	self id printOn: stream.	stream nextPut: $/.	container isNil 		ifTrue: [ stream nextPutAll: 'no container' ]		ifFalse: [ stream nextPutAll: container classLabel ].	stream nextPut: $].</body><body package="COASTMediator">initializeForArgumentsBlock: argumentsBlock inVolume: volume 	^ self valueHolder initializeForArgumentsBlock: argumentsBlock inVolume: volume</body><body package="COASTMediator">isCell	^true</body><body package="COASTMediator">isLocal	^ false</body><body package="COASTMediator">isShared	^ self isLocal not</body><body package="COASTMediator">isSingleValueSlot	^self valueHolder isSingleValue</body><body package="COASTMediator">isSlot	^ true</body><body package="COASTMediator">isUnresolved	^ false</body><body package="COASTMediator">isVirtual	" true if this this cell computed. if true, isLocal must be true, too "	^false</body><body package="COASTMediator">name	^id</body><body package="COASTMediator">referencedFramesOrLocatorsCursorDo: aBlock 	"for use of garbage-collection only!!!"	self valueHolder notNil 		ifTrue: [ self valueHolder referencedFramesOrLocatorsCursorDo: aBlock ]</body><body package="COASTMediator">resolvedCellValue		^self cellValue</body><body package="COASTMediator">resolvedValueHolder	^ self valueHolder</body><body package="COASTMediator">sequenceDo: aBlock	^self transactionManager sequenceDo: aBlock</body><body package="COASTMediator">slotName	^ id</body><body package="COASTMediator">transactionDo: aBlock	^self transactionManager transactionDo: aBlock</body><body package="COASTMediator">transactionManager	"the transaction manager can be usually reached via the cluster"	"if a cell does not (yet) belong to a cluster,	the *cluster* is the transaction manager that created the cell"	^container isNil		ifTrue: [ self isUnresolved ifTrue: [ id clusterManager transactionManager ] ifFalse: [ nil ] ]		ifFalse: [ container transactionManager ]</body><body package="COASTMediator">unwrappedCell	^self</body><body package="COASTMediator">valueHolder	^valueHolder</body><body package="COASTMediator">valueHolder: aCatCSValueHolder	aCatCSValueHolder notNil		ifTrue: [ aCatCSValueHolder slot: self ].	valueHolder := aCatCSValueHolder</body><body package="COASTMediator">volume	^ self cluster isNil ifTrue: [ nil ] ifFalse: [ self cluster volume ]</body><body package="COASTMediator">volumeManager	^ container volumeManager</body></methods><methods><class-id>COAST.CatRMMediatorSlot</class-id> <category>printing</category><body package="COASTMediator">printOn: stream 	self idPrintStringOn: stream.	stream nextPutAll: ' ('.	stream nextPutAll: self classLabel.	stream nextPutAll: ')'.</body></methods><methods><class-id>COAST.CatRMMediatorSlot</class-id> <category>marshalling</category><body package="COASTMediator">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall frame: frame	aCatRMMarshall slotIndexFor: self id frame: frame.	self valueHolder ensureUpdatedFrameSlotIndexWith: aCatRMMarshall.</body><body package="COASTMediator">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self valueHolder index.	self valueHolder marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COASTMediator">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	self valueHolder: ( CatCSCellValueHolder valueHolderClassWithID: aStream next ) newWithoutValue.	self valueHolder unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: nil.</body></methods><methods><class-id>COAST.MediatorJobScheduler</class-id> <category>initialize-release</category><body package="COASTMediator">startJobScheduler	jobs := Set new.	self readJobsFromIniSkipIfUnchanged: false.	jobProcess :=		[	(Delay forSeconds: 1) wait.			[ self safePerformJobAction ] repeat		] forkAt: Processor userInterruptPriority.	jobProcess name: 'Mediator jobs'.</body><body package="COASTMediator">stopJobScheduler	jobProcess isNil 		ifFalse: 		[	jobProcess terminate.			jobProcess := nil		].</body></methods><methods><class-id>COAST.MediatorJobScheduler</class-id> <category>accessing</category><body package="COASTMediator">doBackupJobs	self jobs do: [: j | j doBackupJobFor: self mediator ]</body><body package="COASTMediator">jobProcess	^ jobProcess</body><body package="COASTMediator">jobProcess: aJobProcess 	jobProcess := aJobProcess.</body><body package="COASTMediator">jobs	^ jobs ifNil: [ #() ]</body><body package="COASTMediator">jobs: aJobs 	jobs := aJobs.</body><body package="COASTMediator">mediator	^ mediator</body><body package="COASTMediator">mediator: aMediator 	mediator := aMediator.</body></methods><methods><class-id>COAST.MediatorJobScheduler</class-id> <category>private</category><body package="COASTMediator">jobAction	" perform the next job "	| sortedJobs nextJob secondsUntilSchedule waitInterval skip currentNextJob secondsSinceSchedule |	currentNextJob := nil.	[	" update jobs "		[	self readJobsFromIniSkipIfUnchanged: true.			self jobs isEmpty		] whileTrue: [ self jobPollInterval seconds wait ].		sortedJobs := self sortedJobs.		nextJob := sortedJobs first.		currentNextJob ~~ nextJob 			ifTrue: 			[	currentNextJob := nextJob.				CoastLog log: 'next job will be: ' , nextJob schedulePrintString channel: #jobs.			].		waitInterval := self jobPollInterval.		secondsUntilSchedule := nextJob nextJobTime asSeconds - Timestamp now asSeconds.		secondsUntilSchedule &gt; 0	] whileTrue: [ 		| nextPollWait |		nextPollWait := (secondsUntilSchedule min: waitInterval) max: 1.		nextPollWait seconds wait 	].	secondsSinceSchedule := secondsUntilSchedule negated.	skip := nextJob initialRun 			ifTrue: 			[	nextJob initialRun: false.				secondsSinceSchedule &gt; ( 5 * 60 )			]			ifFalse: 			[	" consider  DST and other changes "				secondsSinceSchedule &gt; ( 2 * 60 * 60 )			].	skip 		ifTrue: [ nextJob skipJob ]		ifFalse: [ self performJob: nextJob ].</body><body package="COASTMediator">jobPollInterval	" wegen Zeitumstellung / Umkonfigurierung der Jobs nicht zu lange warten. "	^ 30</body><body package="COASTMediator">jobsFilename	^ 'jobs.ini'</body><body package="COASTMediator">performJob: nextJob 	" perform with a lower priority than the scheduler "	[ self safePerformJob: nextJob ] forkAt: Processor activeProcess priority - 1.	" workaround for unsynchronized log mess "	1 seconds wait.</body><body package="COASTMediator">readJobsFromIniSkipIfUnchanged: skipIfUnchanged 	" read the scheduled jobs. do not read if the configuration has not changed and skipIfUnchanged = true "	| iniDict file newTimestamp newJobs |	file := self jobsFilename asFilename.	file exists 		ifFalse: [ ^ self ].	newTimestamp :=		[ file modificationTimestamp ifNil: [ file creationTimestamp ]] 			on: OsError			do: 			[: ex |				CoastLog logError: 'Could not get timestamp of ' , file displayString , ': ' , ex description.				nil			].	( skipIfUnchanged and: [ newTimestamp notNil and: [ jobsFileTimestamp = newTimestamp ]]) 		ifTrue: [ ^ self ].	CoastLog log: 'Reading jobs from ' , file asString, ' (timestamp: ', newTimestamp coastShortPrintString, ')'  channel: #jobs.	jobsFileTimestamp := newTimestamp.	[		newJobs := Set new.		iniDict := CoastIniAccess readFile: file.		iniDict categorySet do: 			[: v |				newJobs add: ( CatRMBackupJob fromIniDictionary: iniDict volume: v ).				newJobs add: ( CatRMGarbageCollectJob fromIniDictionary: iniDict volume: v )			].		jobs := newJobs.		CoastLog log: 'Scheduled jobs:'  channel: #jobs.		self sortedJobs do: [ : job | CoastLog log: job schedulePrintString channel: #jobs. ].	] on: Error do: [ : ex |			CoastLog logFatalError: 'Error while parsing jobs: ', ex description	].</body><body package="COASTMediator">safePerformJob: nextJob	[ nextJob doJobFor: self mediator ] 		on: Error		do: 		[: ex |			CoastLog logFatalException: ex message: 'Error while performing job ' , nextJob printString.			( Delay forSeconds: self jobPollInterval ) wait		].</body><body package="COASTMediator">safePerformJobAction	[ self jobAction] 		on: Error		do: 		[: ex |			CoastLog logFatalException: ex message: 'Error while performing jobs'.			( Delay forSeconds: self jobPollInterval ) wait		].</body><body package="COASTMediator">sortedJobs	^ self jobs asSortedCollection: [: j1 : j2 | j1 nextJobTime &lt; j2 nextJobTime ]</body></methods><methods><class-id>COAST.MediatorJobScheduler class</class-id> <category>instance creation</category><body package="COASTMediator">mediator: aMediator 	^ ( self new ) mediator: aMediator;		yourself</body></methods><methods><class-id>COAST.AbstractMediatorTransaction</class-id> <category>testing</category><body package="COASTMediator">skipValidAccessTest	^ true</body></methods><methods><class-id>COAST.AbstractMediatorTransaction</class-id> <category>access handling</category><body package="COASTMediator">rememberAccessIfFirst: cellAccess	" I am the mediator. No rollbacks possible "</body></methods><methods><class-id>COAST.AbstractMediatorTransaction</class-id> <category>accessing</category><body package="COASTMediator">isFastRead	^ true</body><body package="COASTMediator">processCreatedFrames	"mark corresponding clusters as modified"	combinedAgenda accessedUnregisteredCells keysDo: [: frame | frame cluster clusterController modified: true ].</body></methods><methods><class-id>COAST.AbstractMediatorTransaction</class-id> <category>accessing - transaction manager compatibility</category><body package="COASTMediator">activeTransaction	"the mediator transaction is passed as transactionmanager to various methods. therefore some methods have to be emulated"	^ self</body><body package="COASTMediator">activeTransactionOfCurrentProcess	"the mediator transaction is passed as transactionmanager to various methods. therefore some methods have to be emulated"	^ self</body><body package="COASTMediator">transactionManager	"the mediator transaction is passed as transactionmanager to various methods. therefore some methods have to be emulated"	^ self</body></methods><methods><class-id>COAST.AbstractMediatorTransaction</class-id> <category>agenda handling</category><body package="COASTMediator">addReadCluster: cluster 	"nope"</body></methods><methods><class-id>COAST.AbstractMediatorTransaction</class-id> <category>rolling</category><body package="COASTMediator">unloadClustersForVolumeManager: volumeManager</body></methods><methods><class-id>COAST.CatRMAbstractJob</class-id> <category>action</category><body package="COASTMediator">basicDoJobFor: aMediator	self subclassResponsibility</body><body package="COASTMediator">doBackupJobFor: aMediator	"do nothing"</body><body package="COASTMediator">doJobFor: aMediator 	CoastLog log: 'Running scheduled job ' , self printString channel: #jobs.	self scheduleNextJob.	self basicDoJobFor: aMediator.	CoastLog log: 'Done initiating scheduled job ' , self printString channel: #jobs.</body><body package="COASTMediator">scheduleNextJob	lastJobTime := Timestamp now.	self computeNextJobTime.	CoastLog logDebug: self printString, ' scheduled'  channel: #jobs.</body><body package="COASTMediator">skipJob	CoastLog log: 'skipped job: ' , self printString , ' (was scheduled for ' , self nextJobTime coastShortPrintString , ')' channel: #jobs.	self scheduleNextJob.</body></methods><methods><class-id>COAST.CatRMAbstractJob</class-id> <category>initialize</category><body package="COASTMediator">initialize</body></methods><methods><class-id>COAST.CatRMAbstractJob</class-id> <category>accessing</category><body package="COASTMediator">computeNextJobTime	| scheduledTodayTimestamp |	nextJobTime := lastJobTime isNil 			ifTrue: 			[	scheduledTodayTimestamp := Timestamp fromDate: Date today andTime: jobTime.				Timestamp now asSeconds - scheduledTodayTimestamp asSeconds &lt; self class runMissedJobInterval 					ifTrue: [ scheduledTodayTimestamp ]					ifFalse: [ Timestamp fromDate: ( Date today addDays: 1 ) andTime: jobTime ]			]			ifFalse: [ Timestamp fromDate: ( lastJobTime asDate addDays: jobInterval ) andTime: jobTime ].	^ nextJobTime</body><body package="COASTMediator">initialRun	^ initialRun ifNil: [ true ]</body><body package="COASTMediator">initialRun: aInitialRun 	initialRun := aInitialRun.</body><body package="COASTMediator">jobInterval	^jobInterval</body><body package="COASTMediator">jobInterval: aValue	jobInterval := aValue</body><body package="COASTMediator">jobTime	^jobTime</body><body package="COASTMediator">jobTime: aValue	jobTime := aValue</body><body package="COASTMediator">lastJobTime	^lastJobTime</body><body package="COASTMediator">lastJobTime: aValue	lastJobTime := aValue</body><body package="COASTMediator">nextJobTime	^nextJobTime ifNil: [ self computeNextJobTime ]</body><body package="COASTMediator">nextJobTime: aValue	nextJobTime := aValue</body><body package="COASTMediator">volume	^volume</body><body package="COASTMediator">volume: aValue	volume := aValue</body></methods><methods><class-id>COAST.CatRMAbstractJob</class-id> <category>printing</category><body package="COASTMediator">printOn: stream 	stream nextPutAll: self class type.	stream nextPutAll: ' [volume: '.	self volume printOn: stream.	stream nextPutAll: ']'</body><body package="COASTMediator">schedulePrintString	^ self printString , ' scheduled for ' , self nextJobTime coastShortPrintString</body></methods><methods><class-id>COAST.CatRMAbstractJob</class-id> <category>private</category><body package="COASTMediator">logNoMatchingVolumes	CoastLog logError: self printString , ': No matching volumes found'.</body><body package="COASTMediator">matchingVolumesForVolumeManager: volumeManager 	^ volumeManager availableVolumes select: [ : v | volume match: v ignoreCase: true ]</body></methods><methods><class-id>COAST.CatRMAbstractJob class</class-id> <category>instance creation</category><body package="COASTMediator">fromIniDictionary: iniDict volume: aVolume	| newInst |	newInst := self new.	newInst volume: aVolume.	^newInst</body><body package="COASTMediator">new	^super new initialize; yourself</body></methods><methods><class-id>COAST.CatRMAbstractJob class</class-id> <category>constants</category><body package="COASTMediator">runMissedJobInterval	" if we missed a job by less than this interval (in seconds), it will be still run "	^ 5 * 60</body><body package="COASTMediator">type	^'job'</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>replication</category><body package="COASTMediator">cachedClusterOkMessage: aClientID clusterLocator: aClusterLocator 	"create a CatRMCachedClusterOkMessage to indicate that the client-cached cluster is up to date"	| message |	message := CatRMCachedClusterOkMessage new.	message clusterLocator: aClusterLocator.	clients at: aClientID put: CatRMClientState new.	"immidiately register the new client"	^message</body><body package="COASTMediator">clusterForClientMessage: aClientID 	"create a CatRMClusterForClientMessage that is needed to replicate 	the cluster this CC controls"	| message |	message := CatRMClusterForClientMessage new.	message cluster: self clusterStub.	message globalSeqNum: globalSeqNum.	message prepare.	clients at: aClientID put: CatRMClientState new.	"immidiately register the new client"	^message</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>accessing</category><body package="COASTMediator">clients	^clients</body><body package="COASTMediator">cluster: aCatCSCluster 	super cluster: aCatCSCluster.	self heatUpTotalChangeCount.	globalSeqNum := self clusterStub modificationNumber.</body><body package="COASTMediator">coolDownTotalChangeCount	totalChangeCount := self totalChangeCount // 2.</body><body package="COASTMediator">flushLastRead	lastRead := nil.</body><body package="COASTMediator">globalSeqNum	^ globalSeqNum</body><body package="COASTMediator">heatUpTotalChangeCount	totalChangeCount := self totalChangeCount * 4.</body><body package="COASTMediator">incChangeCount	totalChangeCount := self totalChangeCount + 1.	^super incChangeCount</body><body package="COASTMediator">notifyFastRead: aFrame in: aCluster	lastRead := Time microsecondClock</body><body package="COASTMediator">packetStations	| myPeers |	myPeers := self clients keys.	^self clusterManager volumeManager clients select: [: ps |		myPeers includes: ps peerID]</body><body package="COASTMediator">removeClient: aClientID 	"a client just leaved - answer true if it was the last one, false otherwise"	clients removeKey: aClientID ifAbsent: [nil].	^clients isEmpty</body><body package="COASTMediator">rollForwardDebugString	| stream |	stream := String new writeStream.	stream nextPutAll: 'Mediator Roll forward cluster '.	self clusterID printOn: stream.	stream nextPutAll: ' seq '.	self globalSeqNum printOn: stream.	^ stream contents</body><body package="COASTMediator">totalChangeCount	^totalChangeCount ifNil: [totalChangeCount := 0]</body><body package="COASTMediator">usedInGC	^ wasUsedInGC &gt; TimeCheckpoint</body><body package="COASTMediator">usedInGC: bool 	wasUsedInGC := bool 			ifTrue: [ Time secondClock ]			ifFalse: [ 0 ]</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>try and tell</category><body package="COASTMediator">acceptHold: loggedAgenda mediatorAgenda: aCatRMMediatorAgenda 	" accept agenda of a transaction that touched multiple clusters "	| mediatorTransaction |	mediatorTransaction := MediatorTransaction rollingAgenda: loggedAgenda agenda.	loggedAgenda agenda rollForwardForClusterController: self transaction: mediatorTransaction.	mediatorTransaction processCreatedFrames.	self checkForCGCLoggedAgenda: loggedAgenda.	self doAccept: loggedAgenda.	aCatRMMediatorAgenda addClientAgenda: loggedAgenda.	mediatorTransaction addPendingChanges: clusterManager to: aCatRMMediatorAgenda.	^ mediatorTransaction replacements</body><body package="COASTMediator">clusterControllerForAgenda: aAgenda	^self clusterManager clusterController at: aAgenda transactionID clusterLocator id</body><body package="COASTMediator">fakedTransactionIDFor: simpleAgenda 	| newID |	newID := CatRMTransactionID new.	newID localSeqNum: 1.	newID clientID: 0.	newID clusterLocator: simpleAgenda clusterLocator.	newID basedOnGlobal: globalSeqNum.	newID globalSeqNum: globalSeqNum + 1.	newID basedOnLocal: 0.	^ newID</body><body package="COASTMediator">handleTryAndTellMessage: aCatRMTryAndTellMessage 	" handle a transaction that touched multiple clusters "	| initiator loggedTransactionAgendas allTransactionIDs acceptedByAll acceptMessage mediatorAgenda |	loggedTransactionAgendas := aCatRMTryAndTellMessage loggedTransactionAgendas.	initiator := loggedTransactionAgendas first transactionID clientID.	"each clustercontroller must agree"	acceptedByAll :=		[ 			loggedTransactionAgendas allSatisfy: [: eachAgenda | 				( self clusterControllerForAgenda: eachAgenda ) wouldAccept: eachAgenda 			]		] on: CoastError do: 	[: ex |			CoastLog logException: ex message: 'Error while checking client message, request will be rejected'.			false		].	acceptedByAll 		ifTrue: 		[ | replacedAccesses |			replacedAccesses := Set new.			allTransactionIDs := loggedTransactionAgendas collect: [: eachAgenda | eachAgenda transactionID ].			mediatorAgenda := CatRMMediatorAgenda new.			loggedTransactionAgendas do: 				[: eachAgenda | | eachReplacedAgenda |					eachReplacedAgenda := ( self clusterControllerForAgenda: eachAgenda ) acceptHold: eachAgenda mediatorAgenda: mediatorAgenda.					replacedAccesses add: eachReplacedAgenda				].			acceptMessage := CatRMDidAcceptMessage new.			acceptMessage addTransactionIDs: allTransactionIDs.			acceptMessage replacementAgendas: replacedAccesses.			mediatorAgenda broadcastWith: clusterManager originator: initiator.			clusterManager transmitMessage: acceptMessage to: initiator.			self clusterManager addToApplicationLog: aCatRMTryAndTellMessage applicationLog		]		ifFalse: [ clusterManager transmitMessage: CatRMDidRejectMessage new to: initiator ].</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>receiving</category><body package="COASTMediator">checkForCGCLoggedAgenda: loggedAgenda 	clusterManager garbageCollector notNil ifTrue: [ clusterManager garbageCollector updateWithAgenda: loggedAgenda agenda ].</body><body package="COASTMediator">clusterReleaseByClientID: clientID	self removeClient: clientID.</body><body package="COASTMediator">handleAliveMessage: aCatRMAliveMessage 	"reduce the list of unseen updates for the originator of &lt;aCatRMAliveMessage&gt;"	| client |	client := clients at: aCatRMAliveMessage clientID				ifAbsent: 					[self statusError: 'recieved alive message from unknown client: ' 								, aCatRMAliveMessage clientID printString.					^nil].	client reduceUnseenBefore: aCatRMAliveMessage globalSeqNum</body><body package="COASTMediator">handleClusterReleaseMessage: aCatRMClusterReleaseMessage 	| clientID |	clientID := aCatRMClusterReleaseMessage receiverPacketStation peerID.	self clusterReleaseByClientID: clientID</body><body package="COASTMediator">handleLastWishMessage: aCatRMLastWishMessage	self clusterManager addLastWish: aCatRMLastWishMessage loggedTransactionAgenda.</body><body package="COASTMediator">handleTryMessage: aCatRMTryMessage 	" handle a transaction that touches only one cluster "	| loggedAgenda id initiator accept mediatorAgenda |	loggedAgenda := aCatRMTryMessage loggedTransactionAgenda.	id := loggedAgenda transactionID.	initiator := id clientID.	accept := self tryAccept: loggedAgenda.	accept 		ifTrue: 		[ | mediatorTransaction |			mediatorTransaction := MediatorTransaction rollingAgenda: loggedAgenda agenda.			loggedAgenda agenda rollForwardForClusterController: self transaction: mediatorTransaction.			mediatorTransaction replacements notNil 				ifTrue: [ CoastError raiseSignal: 'optimistic transaction with proxy write acces not supported!' ].			clusterManager transmitMessage: ( CatRMAcceptMessage transactionID: id ) to: initiator.			self checkForCGCLoggedAgenda: loggedAgenda.			mediatorAgenda := CatRMMediatorAgenda new.			mediatorAgenda addClientAgenda: loggedAgenda.			mediatorTransaction addPendingChanges: clusterManager to: mediatorAgenda.			mediatorAgenda broadcastWith: clusterManager originator: initiator.			self clusterManager addToApplicationLog: aCatRMTryMessage applicationLog		]		ifFalse: [ clusterManager transmitMessage: ( CatRMRejectMessage transactionID: id ) to: initiator ]</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>last wishes</category><body package="COASTMediator">broadcastLastWishes: wishes client: clientID 	wishes isEmpty ifTrue: [ ^ nil ].	self statusLog: 'executing last wish for client ' , clientID printString.	wishes do: 		[: loggedTransactionAgenda |			[ self doAndBroadcast: loggedTransactionAgenda client: clientID ] on: Error				do: [: ex | self statusLog: 'error executing last wish: ' , ex description ]		]</body><body package="COASTMediator">doAndBroadcast: loggedTransactionAgenda client: clientID 	loggedTransactionAgenda agenda rollForwardForClusterController: self.	self doAccept: loggedTransactionAgenda.	^ self broadcast: ( CatRMUpdateMessage loggedTransactionAgenda: loggedTransactionAgenda ) exceptTo: clientID</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>initialize</category><body package="COASTMediator">initialize	super initialize.	globalSeqNum := 0.	wasUsedInGC := 0.	clients := Dictionary new</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>frame creation</category><body package="COASTMediator">createFrame: aCatRMFrameCreation	| newFrame |	newFrame := CatRMMediatorFrame newWithFrameClassName: aCatRMFrameCreation frameClassName.	newFrame id: aCatRMFrameCreation frameID.	self cluster directTableAccessAt: newFrame id put: newFrame.	newFrame cellContainer: self cluster</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>concurrency control</category><body package="COASTMediator">doAccept: aLoggedTransactionAgenda	"the transaction is ok"	| targetID originatorState |	aLoggedTransactionAgenda isReadOnly ifTrue: [ ^self doAcceptReadOnly: aLoggedTransactionAgenda ].	targetID := aLoggedTransactionAgenda transactionID clientID.	globalSeqNum := globalSeqNum + 1.	CoastLog logDebug: [ 'Accepted seq num: ', globalSeqNum printString, ' cluster: ', self clusterStub id printString ].	self cluster modificationNumber: globalSeqNum.	self modified: true.	aLoggedTransactionAgenda transactionID globalSeqNum: globalSeqNum.	" originator of the transaction may have disconnected in the meantime "	originatorState := clients at: targetID ifAbsent: [nil].	originatorState notNil		ifTrue: [ originatorState doAccept: aLoggedTransactionAgenda ].	clients keysAndValuesDo: [ :clientID :clientStatus |		clientID = targetID			ifFalse: [ clientStatus addUnseen: aLoggedTransactionAgenda ].	].</body><body package="COASTMediator">doAcceptReadOnly: aLoggedTransactionAgenda	"the transaction is ok"	| targetID originatorState tid |	tid := aLoggedTransactionAgenda transactionID.	targetID := tid clientID.	tid globalSeqNum: tid basedOnGlobal.	CoastLog logDebug: [ 'Accepted read only seq num: ', tid globalSeqNum printString, ' cluster: ', self clusterStub id printString ].	" originator of the transaction may have disconnected in the meantime "	originatorState := clients at: targetID ifAbsent: [nil].	originatorState notNil		ifTrue: [ originatorState doAccept: aLoggedTransactionAgenda ].</body><body package="COASTMediator">tryAccept: aLoggedTransactionAgenda 	"answer true if the transaction is ok and swallow it then"	| accept |	accept :=		[ self wouldAccept: aLoggedTransactionAgenda ] 			on: CoastError			do: 			[: ex |				CoastLog logException: ex message: 'Error while checking client message, request will be rejected'.				false			].	accept 		ifTrue: [ self doAccept: aLoggedTransactionAgenda ].	^ accept</body><body package="COASTMediator">wouldAccept: aLoggedTransactionAgenda 	"answer true if the transaction would be ok, but do not do anything"	| targetID client |	targetID := aLoggedTransactionAgenda transactionID clientID.	aLoggedTransactionAgenda transactionID globalSeqNum: globalSeqNum + 1.	"this would be the global sequence number"	client := clients at: targetID			ifAbsent: 			[	aLoggedTransactionAgenda logConcurrencyFail: [ 'Transaction ' , aLoggedTransactionAgenda printString , ' rejected, no clients' ].				^ false			].	( client wouldAccept: aLoggedTransactionAgenda ) ifFalse: [ aLoggedTransactionAgenda logFailReasons. ^ false ].	( aLoggedTransactionAgenda agenda hasValidSlotCreationsForClusterController: self loggedAgenda: aLoggedTransactionAgenda ) ifFalse: 		[	aLoggedTransactionAgenda logConcurrencyFail: [ 'Conflict detected in transaction ' , aLoggedTransactionAgenda printString ].			^ false		].	( aLoggedTransactionAgenda agenda passesSanityCheckForCC: self ) ifFalse: 		[	self statusError: 'Transaction sanity check failed for transaction: ' , aLoggedTransactionAgenda transactionID printString.			^ false		].	^ true</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>testing</category><body package="COASTMediator">hasClientWithID: peerID	^ self clients includesKey: peerID</body><body package="COASTMediator">isLazyCandidate	^ self lazyLoad not and: [ self isDispensable ]</body><body package="COASTMediator">isNewCluster	| clusterStub |	clusterStub := self clusterStub.	^ clusterStub notNil and: [ clusterStub modificationNumber = 1 and: [ clusterStub numberOfFrames = 0 ]]</body><body package="COASTMediator">isUnloadCandidate	^ clients isEmpty and: [ self isDispensable ]</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>release</category><body package="COASTMediator">releaseClusterAndNotifyMediator: doNotify	" the cluster state on disk should be kept in a consitent state.	therefore save all modified clusters, not just the released cluster "	modified ifTrue: [ self clusterManager saveAllModifiedClusters ].	super releaseClusterAndNotifyMediator: doNotify</body><body package="COASTMediator">releaseIfPossible	^ self isUnloadCandidate 		ifTrue: 		[	clusterManager releaseClusterController: self.			true		]		ifFalse: [ false ]</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>broadcasting</category><body package="COASTMediator">broadcast: aCatRMMessage exceptTo: aClientID	COAST.CoastLog debugDo: [		((aCatRMMessage isKindOf: CatRMMessageWithAgenda) and: [ clients notEmpty ])			ifTrue: [ 				COAST.CoastLog logDebug: [ 'broadcast ', aCatRMMessage class name , ' ', 					aCatRMMessage loggedTransactionAgenda transactionID printString, ' to ', clients keys printString ].				(aCatRMMessage isKindOf: CatRMMultiPartUpdateMessage)					ifTrue: [						aCatRMMessage allTransactionIDs do: [ : tid |							COAST.CoastLog logDebug: [ '  tid ', tid printString ].						]					].			]	].	clients keys do:	[ :client |		(client = aClientID)			ifFalse: [ clusterManager transmitMessage: aCatRMMessage copy to: client ].	].</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>private</category><body package="COASTMediator">clusterReleaseDelay	" VerzÃ¶gerung (in Sekunden), bevor ein ClusterController ohne Clients entfernt wird.	wirkt nur auf Cluster, in denen per #fastAt:... auf Implementierungsframes zugegriffen wird. Dies ist derzeit nur beim Cluster 0 (lastWishes) und bei Clustern mit Indexstrukturen der Fall.	alle anderen (mit MediatorFrames bzw nicht per LastWishTransaction oder coastRPC zugegriffenen Frames) werden asap vom Mediator abgelegt	dies ist eine ursprÃ¼nglich nicht beabsichtigte Implementierung, die aber durchaus ihre Vorteile hat :-)	=&gt; Insbesondere die VerzÃ¶gerung zwischen dem Disconnect des letzten Clients und dem ShutDown des Volumes"	| delay |	delay := self clusterManager ifNotNil: [: cm | cm volumeManager ifNotNil: [: vm | vm clusterReleaseDelay ]].	^ delay ifNil: [ 0 ]</body><body package="COASTMediator">isDispensable	self modified ifTrue: [ ^ false ].	self usedInGC ifTrue: [ ^ false ].	( self isNewCluster and: [ self packetStations notEmpty ]) ifTrue: [ ^ false ].	^ lastRead isNil or: [( Time microsecondClock - lastRead ) // 1000000 &gt;= self clusterReleaseDelay ]</body></methods><methods><class-id>COAST.CatRMMediatorCC class</class-id> <category>initialize</category><body package="COASTMediator">setTimeCheckpoint	"set seconds to keep GC clusters"	TimeCheckpoint := Time secondClock - 30</body><body package="COASTMediator">setTimeCheckpointNow	TimeCheckpoint := Time secondClock</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>setup requests</category><body package="COASTMediator">addRequest: aRequestClass	| aRequest id |	aRequest := aRequestClass performer: self.	id := aRequest requestId.	( requestDict includesKey: id )		ifTrue: [ CoastError raiseSignal: 'overwritten request at ' , id printString ].	requestDict at: id put: aRequest</body><body package="COASTMediator">disableRequest: id 	( self requestDict at: id ifAbsent: [^self]) enabled: false</body><body package="COASTMediator">enableRequest: id 	( self requestDict at: id ifAbsent: [^self]) enabled: true</body><body package="COASTMediator">initRequestDict		( CoastAbstractRequest withAllSubclasses 		reject: [: requestClass | requestClass isAbstractRequest ])		do: [: requestClass | self addRequest: requestClass ]</body><body package="COASTMediator">requestDict	requestDict isNil		ifTrue: [	requestDict := Dictionary new.				self initRequestDict].	^requestDict</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>configuration</category><body package="COASTMediator">applicationInfoString	^'Mediator on ' , self hostString , ', ' , self versionString.</body><body package="COASTMediator">createMemoryPolicy	self configuration createMemoryPolicyFor: self.</body><body package="COASTMediator">needsIni		^ false</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>accessing</category><body package="COASTMediator">autoSaveMaxModifiedClusters	^ self iniAccess numberAt: 'autoSaveMaxModifiedClusters'</body><body package="COASTMediator">autoSaveTimeInterval	^ self iniAccess numberAt: 'autoSaveTimeInterval'</body><body package="COASTMediator">backupDirectory	^ self iniAccess stringAt: CoastConstant iniAccessBackupDirectory ifAbsent: [ nil ]</body><body package="COASTMediator">baseDirectory	^ baseDirectory</body><body package="COASTMediator">clientTimeout	^ self iniAccess numberAt: 'clientTimeout'</body><body package="COASTMediator">clusterReleaseDelay	^ self iniAccess numberAt: 'clusterReleaseDelay' ifAbsent: [ nil ]</body><body package="COASTMediator">compactFreedMemoryThreshold	^ self iniAccess memoryAt: 'compactFreedMemoryThreshold' ifAbsent: [ nil ]</body><body package="COASTMediator">matchesRemotePassword: aPassword	^ self remotePassword = aPassword</body><body package="COASTMediator">memoryPolicyClassString	^'COAST.CoastServerMemoryPolicy'</body><body package="COASTMediator">pidFilename	^ pidFilename</body><body package="COASTMediator">pidFilename: aFilenameOrString 	pidFilename := aFilenameOrString.</body><body package="COASTMediator">quickCompactFreedMemoryThreshold	^ self iniAccess memoryAt: 'quickCompactFreedMemoryThreshold' ifAbsent: [ nil ]</body><body package="COASTMediator">remotePassword	remotePassword isNil ifTrue: [ remotePassword := self iniAccess stringAt: 'password' ifAbsent: [ '' ]].	^ remotePassword</body><body package="COASTMediator">remotePassword: password	remotePassword := password</body><body package="COASTMediator">serverHost	| stream |	stream := String new writeStream.	stream nextPutAll: self serverHostName.	stream nextPut: $:.	self currentPort printOn: stream.	^ stream contents</body><body package="COASTMediator">serverHostName	^ serverHost notNil 		ifTrue: [ serverHost ]		ifFalse: [ 'localhost' ]</body><body package="COASTMediator">serverPort	^serverPort ifNil: [ serverPort := self iniAccess numberAt: 'port' ifAbsent: [ self class defaultServerPort ]]</body><body package="COASTMediator">serverPort: anInteger 	( serverPort notNil and: [ serverPort ~= anInteger ]) 		ifTrue: [ self error: 'port conflict: current port: ' , serverPort printString , ', new port: ' , anInteger printString , '?' ].	serverPort := anInteger.</body><body package="COASTMediator">serviceSocketAddress	| adr |	adr := serviceSocket getName.	adr convertToFullAddress.	^adr</body><body package="COASTMediator">serviceSocketPort	| adr |	adr := serviceSocket getName.	^adr port.</body><body package="COASTMediator">skipVolumesCheck	^ skipVolumesCheck ifNil: [ self iniAccess booleanAt: CoastConstant iniAccessSkipVolumesCheck ifAbsent: [ self class defaultSkipVolumesCheck ]]</body><body package="COASTMediator">skipVolumesCheck: aBoolean	skipVolumesCheck := aBoolean</body><body package="COASTMediator">useSSL	^ self iniAccess booleanAt: CoastConstant iniAccessUseSSL ifAbsent: [ false ]</body><body package="COASTMediator">volumeManager	^volumeManager</body><body package="COASTMediator">volumesDirectory	^ self iniAccess stringAt: CoastConstant iniAccessVolumesDirectory ifAbsent: [ nil ]</body><body package="COASTMediator">volumesDirectoryOrDefault	^ self volumesDirectory ifNil: [ CoastConstant defaultVolumeDirectory ]</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>private</category><body package="COASTMediator">badVolumeNameError: volume		CoastError raiseSignal: 'bad volume name: ' , volume.</body><body package="COASTMediator">basicShutDown	Default = self ifTrue: [Default := nil].	(#{HeadlessImage} isDefined 		and: [#{HeadlessImage} value default isHeadless]) 		ifTrue: [ObjectMemory quit]</body><body package="COASTMediator">clusterManagerForExistingVolume: volume ifAbsent: block 	" Returns (might create) a cluster manager for the volume, if the volume exists.	Evaluates the block if the volume does not exist "	" check volume manager first. checking if a volume exists takes some time (file checks) "	^ self volumeManager 		clusterManagerForVolume: volume		ifAbsent: 		[(( self volumeManager volumeInterface volumeExists: volume ) and: [ volume isValidVolumeString ]) 				ifTrue: [ self volumeManager clusterManagerForVolume: volume ]				ifFalse: [ block value ]		]</body><body package="COASTMediator">commandLineError: aString	CoastCommandLineError raiseSignal: aString</body><body package="COASTMediator">consoleShow: aString 	CoastLog consoleShow: aString; consoleShow: (String with: Character cr)</body><body package="COASTMediator">currentPort	^ ( self serverPort = IPSocketAddress anyPort and: [ serviceSocket notNil ]) 		ifTrue: [ self serviceSocketPort  ]		ifFalse: [ self serverPort  ].</body><body package="COASTMediator">debugDisconnectClients	volumeManager packetStations do: [ : ps | 		ps socketAccessor close.	]</body><body package="COASTMediator">existingClusterManagerForVolume: volume 	^ self clusterManagerForExistingVolume: volume ifAbsent: [ self badVolumeNameError: volume ]</body><body package="COASTMediator">jobScheduler	^ jobScheduler</body><body package="COASTMediator">quickRecoverVolume: volumeName	CoastLog log: 'Starting quick recovery of volume ', volumeName printString.	self newVolumeManager volumeInterface quickRecoverVolume: volumeName.	CoastLog log: 'Done'.</body><body package="COASTMediator">recoverVolume: volumeName	CoastLog log: 'Starting recovery of volume ', volumeName printString.	self newVolumeManager volumeInterface recoverVolume: volumeName.	CoastLog log: 'Done'.</body><body package="COASTMediator">saveStartupDo: block 	| s |	^ block on: Error		do: 		[: ex |			Notifier isDevelopment 				ifTrue: [ ex pass ]				ifFalse: 				[	s := 'Fatal error, Mediator will now quit'.					CoastLog logException: ex message: s.					self consoleAndLogShow: s , ': ' , ex description.					ObjectMemory quitWithError: CoastExitCode unhandledException				]		]</body><body package="COASTMediator">showStatusResponseAndQuit: statusResponse 	self consoleShow: statusResponse message.	self terminateWithStatusResponse: statusResponse.</body><body package="COASTMediator">shutDownWithPassword: password from: senderSocketAddress 	| resultString |	^ ( self matchesRemotePassword: password ) 		ifTrue: 		[	resultString := 'Mediator shut down from ' , senderSocketAddress addressPrintString.			CoastLog log: resultString channel: #audit.			self shutDown.			CoastStatusResponse okCode: #mediatorShutDown message: resultString		]		ifFalse: 		[	resultString := 'Mediator shut down rejected '.			CoastLog log: resultString.			CoastStatusResponse accessDenied		]	"self basicShutDown."	"do this later - we wann give a reply first"</body><body package="COASTMediator">terminateWithStatusResponse: statusResponse 	| returncode |	CoastLog flush.	Notifier isDevelopment 		ifFalse: 		[	returncode := statusResponse ok 					ifTrue: [ CoastExitCode noError ]					ifFalse: [ CoastExitCode operationFailed ].			ObjectMemory quitWithError: returncode		]</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>initialize</category><body package="COASTMediator">configureVolumeAccessor	| volumeAccessorClasses |	volumeAccessorClasses := CatCSAbstractDiskVolumeAccessor allSubclasses reject: [: cl | cl isAbstract ].	self baseDirectory ifNotNil: [: dir | volumeAccessorClasses do: [: cl | cl defaultBaseDirectory: dir ]].</body><body package="COASTMediator">deinstallService: newServiceName	configuration deinstallService: newServiceName</body><body package="COASTMediator">hostString	| stream |	stream := String new writeStream.	"when used in a hardware cluster, setting the host-parameter enables volume unlocking by both cluster nodes"	stream nextPutAll: (serverHost ifNil: [ self iniAccess at: 'host' ifAbsent: [ SocketAccessor hostDescription ]]).	stream nextPut: $:.	self currentPort printOn: stream.	^ stream contents</body><body package="COASTMediator">initialize	"initialize and start the mediator "	| coreVersion mediatorVersion |	self initializeCoast.	ObjectMemory removeDependent: self class.	ObjectMemory addDependent: self class.	self configureApplication.	" sanity check "	( coreVersion := CoastVersion defaultCoastVersion ) = ( mediatorVersion := self class mediatorVersion ) 		ifFalse: 		[	self consoleAndLogShow: 'Wrong COAST version ' , coreVersion printString , ', expected ' , mediatorVersion printString.			^ self shutDownAndQuit		].	self checkVMAndImageVersion.	COBinaryExternal libAvailable.	self createMemoryPolicy.	self configureVolumeAccessor.	self configureSSL.	self clientTimeout ifNotNil: 		[: timeout |			CoastLog log: 'Client timeout: ' , timeout printString.			CatRMMediatorPacketStation maxSilentSeconds: timeout		].	self startAction ifNil: [ self startMediator ] ifNotNil: [: action | self saveStartupDo: action ].</body><body package="COASTMediator">initializeJobs		jobScheduler := MediatorJobScheduler mediator: self.	jobScheduler startJobScheduler.</body><body package="COASTMediator">initializeOSSignals	| handler |	handler := OSProcessSignalHandler current.	handler		listenToLifecycleSignals;		listenToSignalsNamed: #( #SIGHUP #SIGUSR2 );		announceSignalNamed: #SIGHUP with: OSProcessCloseSignal;		when: OSProcessUser2Signal			do: 			[: signal |				self consoleAndLogShow: 'Received ' , signal signalName.				self jobScheduler ifNotNil: 					[: s |												[ s doBackupJobs ] fork					]			]			for: self.	self isWindowsService 		ifFalse: 		[	handler 				when: OSProcessBreakSignal , OSProcessCloseSignal				do: 				[: signal |					self consoleAndLogShow: 'Received ' , signal signalName.					self release.					ObjectMemory quit				]				for: self		].</body><body package="COASTMediator">newVolumeManager	| vm |	vm := CatRMMediatorVolumeManager new.	vm autoSaveTimeInterval: self autoSaveTimeInterval;		maxModifiedClusters: self autoSaveMaxModifiedClusters.	self clusterReleaseDelay ifNotNil: [: delayInSeconds | vm clusterReleaseDelay: ( delayInSeconds max: 0 )].	self compactFreedMemoryThreshold ifNotNil: [: threshold | vm compactFreedMemoryThreshold: threshold ].	self quickCompactFreedMemoryThreshold ifNotNil: [: threshold | vm quickCompactFreedMemoryThreshold: threshold ].	vm volumeInterface configuration: self configuration.	^ vm</body><body package="COASTMediator">release	"close the shop, do not accept customers (clients) any longer"	self consoleAndLogShow: 'About to shutdown the Mediator'.	subApplications notNil ifTrue: [ subApplications do: [ : subApp | subApp shutDown ]. subApplications := nil ].	jobScheduler isNil 		ifFalse: 		[	jobScheduler stopJobScheduler.			jobScheduler := nil		].	serviceProcess isNil 		ifFalse: 		[	serviceProcess terminate.			serviceProcess := nil		].	serviceSocket notNil 		ifTrue: 		[	serviceSocket close.			serviceSocket := nil		].	"release (and thereby store) all clusters in use"	volumeManager notNil 		ifTrue: [ volumeManager shutDown ].	ObjectMemory removeDependent: self class.	OSProcessSignalHandler currentOrNil ifNotNil: [: signalHandler | signalHandler unsubscribe: self ].	self consoleAndLogShow: 'Mediator shutdown finished'.	super release.</body><body package="COASTMediator">shutDown	self removePidFile.	self release.</body><body package="COASTMediator">startMediator	self serverHostName = 'localhost' ifFalse: [ self error: 'cannot start on remote host' ].	serviceSocket := SocketAccessor defaultClass newCoastServerAtPort: self serverPort.	( serviceSocket notNil and: [ serviceSocket isActive ]) ifFalse: [ ^ self basicShutDown ].	self serverPort = IPSocketAddress anyPort ifTrue: [ CoastLog log: 'Actual mediator port: ' , self serviceSocketPort printString ].	volumeManager := self newVolumeManager.	self skipVolumesCheck ifFalse: [ volumeManager checkVolumes ].	serviceSocket listenFor: SocketAccessor coastDefaultListenBacklog.	serviceProcess := self serviceBlock forkAt: Processor lowIOPriority.	serviceProcess name: 'CoastMediator - basic service process'.	self initializeJobs.	self initializeOSSignals.	self writePidFile.	self startSubApplications.	self consoleAndLogShow: 'Mediator started'.</body><body package="COASTMediator">startUpAsService	winService := configuration createWinService.	winService startAsService: 		[	self skipVolumesCheck: true.			self startMediator		]		shutdownBlock: [ self release ].</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>testing</category><body package="COASTMediator">isActive	^serviceSocket notNil and: [serviceSocket isActive]</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>printing</category><body package="COASTMediator">printOn: stream 	self class printOn: stream.	stream nextPutAll: ' at: '.	serviceSocket getName printOn: stream</body><body package="COASTMediator">versionString	^ 'Mediator version: ' , (CoastVersion versionOf: 'COASTMediator') ,	', COAST version: ' , (CoastVersion versionOf: 'COASTCore') , 	', Build: ' , CoastVersion buildString</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>handle requests</category><body package="COASTMediator">handleRequestAt: socketAccessor 	"establish a stream connection for aSocketAccessor and handle incoming requests"	[			[ | coastSocketAccessor receiveStream request |			coastSocketAccessor := CoastSocketAccessor acceptSocketAccessor: socketAccessor securityContext: sslContext.			[	receiveStream := coastSocketAccessor coastBinaryReadStream.				[ | requestId |					requestId := receiveStream next.					requestId isNil 						ifTrue: [ CoastLog logError: 'request to mediator interrupted' ]						ifFalse: 						[	request := self requestDict at: requestId ifAbsent: [ nil ].							request notNil 								ifTrue: 								[										[ request performRequestAt: coastSocketAccessor readStream: receiveStream ] 										on: Error										do: [: ex | CoastLog logException: ex message: 'error while executing a request' ]								]								ifFalse: [ self unknownRequest: requestId at: coastSocketAccessor ]						]				] ifCurtailed: 					[							[ receiveStream close ] on: Error do: [: ex | ]					]			] ifCurtailed: 				[	coastSocketAccessor ~= socketAccessor 						ifTrue: [ [ coastSocketAccessor close ] on: Error do: [: ex | ]]				]		] ifCurtailed: [ [ socketAccessor close ] on: Error do: [: ex | ] ]	] on: Error do: [: ex | CoastLog logError: ex description ].</body><body package="COASTMediator">serviceBlock	"Thread block accepting connections from new clients."	^ [			[ | newSock | 			[	newSock := serviceSocket accept.				"handle requests in a processes of normal priority"				[ self handleRequestAt: newSock ] forkAt: Processor userSchedulingPriority			] on: OsError do: [: ex | CoastLog logWarning: [ 'Could not accept new connection: ' , ex description ]].			true		] whileTrue	]</body><body package="COASTMediator">unknownRequest: request at: aSocketAccessor 	CoastLog logError: 'Unknown request to mediator: ' , request printString.</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>config</category><body package="COASTMediator">configurationClass	^ CoastMediatorConfiguration</body></methods><methods><class-id>COAST.CoastMediator</class-id> <category>security</category><body package="COASTMediator">certificateFilename	^ self iniAccess stringAt: 'certificate' ifAbsent: [ self defaultCertificateDirectory construct: 'server.crt' ]</body><body package="COASTMediator">configureSSL	| useSSL serverCertificateFilename serverPrivateKeyFilename chain keys |	useSSL := self useSSL.	useSSL 		ifTrue: 		[	CoastLog log: 'Using SSL/TLS'.			( serverCertificateFilename := self certificateFilename asFilename ) exists 				ifFalse: [ CoastError raiseSignal: 'Server certificate (' , serverCertificateFilename asString , ') not found' ].			( serverPrivateKeyFilename := self privateKeyFilename asFilename ) exists 				ifFalse: [ CoastError raiseSignal: 'Server key (' , serverPrivateKeyFilename asString , ') not found' ].			sslContext := Xtreams.TLSContext newServerWithDefaults.			chain := Security.X509.CertificateFileReader readFromFile: serverCertificateFilename.			keys := Security.X509.CertificateFileReader readFromFile: serverPrivateKeyFilename.			sslContext certificates certificate: chain key: keys singleElement getKey		].	CoastSocketAccessor useSSL: useSSL.</body><body package="COASTMediator">defaultCertificateDirectory	^ 'certificate' asFilename</body><body package="COASTMediator">defaultKeyDirectory	^ 'private' asFilename</body><body package="COASTMediator">privateKeyFilename	^ self iniAccess category: 'ssl' stringAt: 'privateKey' ifAbsent: [ self defaultKeyDirectory construct: 'server.key' ]</body><body package="COASTMediator">sslContext	^ sslContext</body></methods><methods><class-id>COAST.CoastMediator class</class-id> <category>accessing</category><body package="COASTMediator">default	^ Default</body><body package="COASTMediator">default: aMediator	Default := aMediator</body><body package="COASTMediator">defaultIniFilename	^ 'mediator.ini'</body><body package="COASTMediator">defaultLogFilename	^ 'mediator.log'</body><body package="COASTMediator">defaultServerPort	^ CoastMediatorStub defaultServerPort</body><body package="COASTMediator">defaultSkipVolumesCheck	^ defaultSkipVolumesCheck ifNil: [ true ]</body><body package="COASTMediator">defaultSkipVolumesCheck: aBoolean	defaultSkipVolumesCheck := aBoolean</body><body package="COASTMediator">mediatorVersion	^ CoastVersion major: 5 minor: 5</body></methods><methods><class-id>COAST.CoastMediator class</class-id> <category>instance creation</category><body package="COASTMediator">newAtDefaultPort	^ CoastApplicationConfiguration safeStartupDo: [		(self new)			initialize;			yourself.	].</body><body package="COASTMediator">newAtPort: port	^ CoastApplicationConfiguration safeStartupDo: [		(self new)			serverPort: port;			initialize;			yourself.	].</body></methods><methods><class-id>COAST.CoastMediator class</class-id> <category>system startup</category><body package="COASTMediator">noStartOfMediatorOnStartup	"call this, if the mediator shouldn't be started when the image is loaded."	startMediatorOnStartup := false</body><body package="COASTMediator">returnFromSnapshot	"the mediator should start when the image is loaded!"	self startupHeadlessMediator</body><body package="COASTMediator">shutDown	Default isNil ifTrue: [ ^ self ].	Default release.	Default := nil</body><body package="COASTMediator">shutDownAll	self allInstances do: [ : inst | inst release ].	Default := nil</body><body package="COASTMediator">startMediatorOnStartup	"call this, if the mediator should be started when the image is loaded."	startMediatorOnStartup := true.</body><body package="COASTMediator">startUp	| newInst |	Default notNil		ifTrue: [ self halt: 'mediator already started !'. ^ Default ].	newInst := self newAtDefaultPort.	^newInst isActive 		ifTrue: [ Default := newInst ] 		ifFalse: [ nil ]</body><body package="COASTMediator">startUpWithPassword: password 	| mediator |	mediator := self startUp.	mediator notNil ifTrue: [ mediator remotePassword: password ].	^ mediator</body><body package="COASTMediator">startupHeadlessMediator	CoastLog log: 'Starting Mediator'.	Parcel coastParcelVersionStringsDo: [: string | CoastLog show: string; cr ].	self startUp.	CoastLog log: 'Mediator started'.</body><body package="COASTMediator">update: anAspect	(anAspect == #returnFromSnapshot and: [ startMediatorOnStartup == true ])		ifTrue: [ self returnFromSnapshot].	(#(aboutToSnapshot #aboutToQuit) includes: anAspect)		ifTrue: [ self shutDown ].</body></methods><methods><class-id>COAST.MediatorClassNameManager</class-id> <category>initialize-release</category><body package="COASTMediator">initialize	super initialize.	self registerImplementationClasses.</body><body package="COASTMediator">registerImplementationClasses	name2classDict := Dictionary new.	CatRMMediatorFrame buildImplementationFrameClasses keysAndValuesDo: [ : frameClassSybmol : frameClass |		name2classDict at: frameClassSybmol asString put: frameClass	].</body></methods><methods><class-id>COAST.MediatorClassNameManager</class-id> <category>namespace converting</category><body package="COASTMediator">classForCoastClassName: coastClassName 	" Don't return client implementation classes. in a runtime environment, they won't be available anyway,	therefore, this is unnecessary and may lead to differenct behavior in development images "	^ name2classDict at: coastClassName ifAbsent: [ nil ]</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>requests</category><body package="COASTMediator">answerClusterRequest: aCatRMClusterRequest cluster: aCluster 	| message |	message := aCluster isNil 			ifTrue: [ CatRMErrorMessage description: 'cluster not available for: ' , aCatRMClusterRequest printString ]			ifFalse: 			[ | peerID |				peerID := aCatRMClusterRequest receiverPacketStation peerID.				aCatRMClusterRequest modificationNumber = aCluster modificationNumber 					ifTrue: [ aCluster clusterController cachedClusterOkMessage: peerID clusterLocator: aCluster clusterLocator ]					ifFalse: [ aCluster clusterController clusterForClientMessage: peerID ]			].	aCatRMClusterRequest receiverPacketStation transmitMessage: message</body><body package="COASTMediator">deleteVolume	self volumeManager disconnectStations: self ownPacketStations.	^ super deleteVolume</body><body package="COASTMediator">handleApplicationLogMessage: applicationLogMessage	self addToApplicationLog: applicationLogMessage applicationLog</body><body package="COASTMediator">handleClusterCreateRequest: aCatRMClusterCreateRequest	[ | cluster |		cluster := self createCluster.		self answerClusterRequest: aCatRMClusterCreateRequest cluster: cluster	] 		on: Error		do: 		[: ex |			CoastLog logException: ex message: 'Unable to create cluster'.			self emergencyShutDown		].</body><body package="COASTMediator">handleClusterReleaseMessage: aCatRMClusterReleaseMessage 	| cc |	cc := clusterController at: aCatRMClusterReleaseMessage clusterLocator id ifAbsent: [ nil ].	cc isNil 		ifTrue: 		[	aCatRMClusterReleaseMessage receiverPacketStation 				transmitMessage: ( CatRMErrorMessage description: 'unknown cluster for: ' , aCatRMClusterReleaseMessage printString )		]		ifFalse: 		[ | clientID |			cc handleClusterReleaseMessage: aCatRMClusterReleaseMessage.			aCatRMClusterReleaseMessage receiverPacketStation transmitMessage: CatRMOkMessage new.			clientID := aCatRMClusterReleaseMessage receiverPacketStation peerID.			( clusterController contains: [: yacc | yacc clients includesKey: clientID ]) 				ifFalse: [ self removeLastWishesFor: clientID ]		]</body><body package="COASTMediator">handleClusterRequest: aCatRMClusterRequest	| clusterStub |	clusterStub := self getClusterStub: aCatRMClusterRequest clusterLocator id.	self answerClusterRequest: aCatRMClusterRequest cluster: clusterStub.</body><body package="COASTMediator">handleIndexDownloadRequest: aCatRMIndexDownloadRequest 	| bytes indexAccess str |	indexAccess := self storageInterface indexIniAccess.	frameClassIndex hasUpdates ifTrue: [ frameClassIndex updateIndexIni: indexAccess ].	str := ( String new: 1000 ) writeStream.	indexAccess writeTo: str.	bytes := str contents asByteArray.	aCatRMIndexDownloadRequest receiverPacketStation transmitMessage: ( ( CatRMIndexDownloadResponse new )				bytes: bytes;				yourself ).</body><body package="COASTMediator">handleRPCRequest: aCatRMRPCRequest 	CoastLog 		logDebug: [ 'handle RPC request ' , aCatRMRPCRequest selector , ' for ' , aCatRMRPCRequest recipientFrameLocator printString ]		channel: #coastRPC.	self exclusiveUseDo: 		[ | result recipient slotName |			recipient := self getFrame: aCatRMRPCRequest recipientFrameLocator.			( recipient notNil and: [( slotName := aCatRMRPCRequest slotName ) notNil ]) 				ifTrue: [ recipient := self getFrame: ( recipient at: slotName ) valueFrame ].			recipient isNil 				ifTrue: [ ^ aCatRMRPCRequest receiverPacketStation transmitMessage: ( CatRMErrorMessage description: 'recipient not found' )].			[ | transaction |				transaction := MediatorRPCTransaction new.				transaction volumeManager: self volumeManager.				Processor activeTransaction: transaction.				[	result := recipient perform: aCatRMRPCRequest selector withArguments: aCatRMRPCRequest arguments.					" counter dÃ¼rfen fiese Schreibzugriffe durchfÃ¼hren "					transaction processCreatedFrames				] ensure: [ Processor removeActiveTransaction ]			] 				on: Error				do: 				[: exception |					CoastLog logException: exception message: 'Error in RPC'.					^ aCatRMRPCRequest receiverPacketStation transmitMessage: ( CatRMErrorMessage description: exception description )				].			result := result asCoastRPCResult.			aCatRMRPCRequest receiverPacketStation 				transmitMessage: ( CatRMRPCResultMessage result: result marshaller: self loadSaveMarshaller volume: self volume )		].</body><body package="COASTMediator">handleVolumeIDRequest: aCatRMVolumeIDRequest	aCatRMVolumeIDRequest receiverPacketStation transmitMessage:		(CatRMVolumeIDResponse volumeID: self volumeID).</body><body package="COASTMediator">handleVolumeSaveRequest: aCatRMVolumeSaveRequest 	self saveAllModifiedClusters.	aCatRMVolumeSaveRequest receiverPacketStation transmitMessage: (CatRMOkMessage new).</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>inspecting</category><body package="COASTMediator">cleanup	garbageCollector isNil ifTrue: [ super cleanup ]</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>accessing</category><body package="COASTMediator">clientIPs	^ ( self ownPacketStations collect: [: clientState | clientState ipAdressString ]) asSortedCollection</body><body package="COASTMediator">garbageCollector	^garbageCollector</body><body package="COASTMediator">notifyReadCluster: cluster 	"nope"</body><body package="COASTMediator">ownPacketStations	" return all connected packet stations that are subscribed to at least one cluster "	| allPacketStations ownPacketStations |	allPacketStations := self volumeManager clients asSet.	allPacketStations isEmpty  ifTrue: [ ^ allPacketStations ].	ownPacketStations := Set new.	self clusterController do: [:cc | 		allPacketStations do: [ : ps |			(cc hasClientWithID: ps peerID)				ifTrue: [					ownPacketStations add: ps.				].		].		allPacketStations size = ownPacketStations size 			ifTrue: [ ^ ownPacketStations ].	].	^ownPacketStations</body><body package="COASTMediator">transactionManager	| activeTransaction |	activeTransaction := Processor activeTransaction.	^ activeTransaction notNil 		ifTrue: [ activeTransaction transactionManager ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>exclusive use</category><body package="COASTMediator">exclusiveUseDo: aBlock	| result |	garbageCollector isNil ifFalse: [garbageCollector interruptGC].	[result := super exclusiveUseDo: aBlock]		ensure: [garbageCollector isNil ifFalse: [garbageCollector proceedGC]].	^result</body><body package="COASTMediator">interruptGC	garbageCollector isNil ifFalse: [garbageCollector interruptGC].</body><body package="COASTMediator">proceedGC	garbageCollector isNil ifFalse: [garbageCollector proceedGC]</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>last wish</category><body package="COASTMediator">basicExecuteLastWishesFor: clientID 	"this is VERY basic	we store the loggedAgendas as concatenated byteArrays in a dictionary with key 'clientID'	thus after load, a ClusterManager can execute the last wishes"	| slot stream wishesDict |	slot := self lastWishesSlotOrNil.	slot isNil ifTrue: [ ^ self ].	wishesDict := Dictionary new.	stream := ( slot valueHolder at: clientID ifAbsent: [ ByteArray new ]) readStream.	[			[ stream atEnd ] whileFalse: 			[ | loggedTransactionAgenda |				loggedTransactionAgenda := CatRMLoggedTransactionAgenda new unmarshallAgendaFrom: stream						marshaller: self loadSaveMarshaller						withVolumeManager: self volumeManager.				( wishesDict at: loggedTransactionAgenda transactionID clusterLocator id ifAbsentPut: [ OrderedCollection new ]) add: loggedTransactionAgenda			]	] on: CoastError		do: 		[: ex |			CoastLog log: 'unmarshalling of last wish for ' , clientID printString , ' failed with Error: ' , ex description.			wishesDict := Dictionary new		].	wishesDict keysAndValuesDo: 		[: clusterID : wishes | | cluster |			cluster := self getCluster: clusterID.			cluster clusterController broadcastLastWishes: wishes client: clientID		].	self removeLastWishesFor: clientID.</body><body package="COASTMediator">executeLastWishesFor: clientID 	self basicExecuteLastWishesFor: clientID.	self clusterController do: 	[ :cc | cc clusterStub isNil		ifTrue: [ "woah" self releaseClusterController: cc. ]		ifFalse: [ cc clusterReleaseByClientID: clientID ]	]</body><body package="COASTMediator">newLastWishesFrame	^CatRMMediatorFrame newWithFrameClassName: CatCSClusterAdministrationFrame fullName.</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>cluster contents</category><body package="COASTMediator">getFrameForLoading: aCatFSExternalFrameDefinition 	"A frame has to be loaded. Create a blank frame to continue loading."	^aCatFSExternalFrameDefinition createMediatorFrameForClusterManager: self</body><body package="COASTMediator">getFrameForLoading: frameID clusterID: clusterID frameKey: frameKey 	"A frame has to be loaded. Create a blank frame to continue loading."	| frame frameClassSymbol |	frameClassSymbol := frameKey isCharacters 			ifTrue: [ frameKey ]			ifFalse: [ frameKey frameClassSymbol ].	frame := CatRMMediatorFrame newWithFrameClassName: frameClassSymbol.	frame id: frameID.	^ frame</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>file services</category><body package="COASTMediator">handleFileDownloadRequest: aCatRMFileDownloadRequest 	| message |	message := ( storageInterface blobExists: aCatRMFileDownloadRequest fileID ) 			ifTrue: 			[	CatRMFileDownloadResponse fileID: aCatRMFileDownloadRequest fileID					sourceStore: storageInterface					targetFile: aCatRMFileDownloadRequest targetFile			]			ifFalse: [ CatRMErrorMessage description: 'file not available for: ' , aCatRMFileDownloadRequest printString ].	aCatRMFileDownloadRequest receiverPacketStation transmitMessage: message</body><body package="COASTMediator">handleFileUploadRequest: aCatRMFileUploadRequest 	| result |	result := CatRMFileUploadResponse fileID: aCatRMFileUploadRequest fileID.	aCatRMFileUploadRequest receiverPacketStation transmitMessage: result</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>private</category><body package="COASTMediator">canCaptureFileLock: fileLock 	"my volumeLockInfoString should be a prefix of the storedInfoString"	| readStream |	readStream := self volumeLockInfoString readStream.	fileLock storedInfoString do: 		[: char |			readStream atEnd ifTrue: 				[	"do not capture when the port string is a prefix of the running one"					"proof with space as speparator, skip date, time and PID"					^ char = Character space				].			readStream next = char ifFalse: [ ^ false ]		].	^ false	"strange but saver to fail here - maybe the string is empty???"</body><body package="COASTMediator">classNameManagerClass	^ MediatorClassNameManager</body><body package="COASTMediator">hostDescription	| mediator |	mediator := CoastMediator allInstances 		detect: [: cm | cm volumeManager = self volumeManager ] 		ifNone: [^super hostDescription].	^mediator hostString</body><body package="COASTMediator">volumeAccessDenied: fileLock	"recover old fileLocks"	(self volumeLockInfoString = fileLock storedInfoString		and: [fileLock forceLock. fileLock hasLock]) 		ifTrue: [^self].	"disconnect all clients!"	self volumeManager disconnectStations: self ownPacketStations.		super volumeAccessDenied: fileLock.</body><body package="COASTMediator">volumeLockInfoString	^'CoastMediator on ' , self hostDescription</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>controlling</category><body package="COASTMediator">localControllerClass	^CatRMLazyMediatorCC</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>cluster creation</category><body package="COASTMediator">logStatusToTranscriptReleased: released 	| numberOfLazies |	( released isZero and: [ garbageCollector isNil ]) ifTrue: [ ^ self ].	numberOfLazies := ( self clusterController values select: [: aCC | aCC lazyLoad ]) size.	CoastLog 		log: 'Clusters loaded in volume ' , self volume , ': ' , numberOfLazies printString , ' lazy / ' 				, ( self clusterController size - numberOfLazies ) printString , ' non-lazy / ' 				, released printString , ' released'.	garbageCollector notNil ifTrue: [ CoastLog log: garbageCollector statusString ]</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>release</category><body package="COASTMediator">releaseAllClusters	self exclusiveUseDo: 		[	garbageCollector isNil ifFalse: 				[	CoastLog log: 'Stopping garbage collection...'.					self stopCollectingGarbage.					garbageCollector := nil				]		].	super releaseAllClusters</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>packet stations</category><body package="COASTMediator">transmitMessage: aCatRMMessage to: clientID	volumeManager transmitMessage: aCatRMMessage to: clientID</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>saving</category><body package="COASTMediator">checkAutoSaveAndRelease	"check if it is time for autosave and release all not-yet-released clusters that have no clients anymore"	"we have the exclusive lock for the volume so we can do what we want"	| oldSize toUnload |	CatRMMediatorCC setTimeCheckpoint.	self saveNow 		ifTrue: 		[	toUnload := self lazyCandidates.			self saveAllModifiedClusters.			autosaveTime := nil.			self setLastSaveTime.			self makeClustersLazy: toUnload		].	oldSize := clusterController size.	self privateReleaseClustersIfPossible.	self logStatusToTranscriptReleased: oldSize - clusterController size.</body><body package="COASTMediator">compactFreedMemoryThreshold	" note: refers to cluster size on disk "	^ self volumeManager compactFreedMemoryThreshold</body><body package="COASTMediator">lazyCandidates	"Return all unmodified clusters not used in CoastGC - they will be made lazy later"	"if there ary more than 4 candidates, remove a third of them (the most modified ones)"	| lazyCandidates |	lazyCandidates := clusterController values select: [: cc | cc isLazyCandidate ].	lazyCandidates size &gt; 4 ifTrue: 		[	lazyCandidates := lazyCandidates 					asSortedCollection: [: cc1 : cc2 | cc1 totalChangeCount &lt; cc2 totalChangeCount ].			lazyCandidates size // 3 timesRepeat: [ lazyCandidates removeLast coolDownTotalChangeCount ]		].	lazyCandidates do: [: cc | cc coolDownTotalChangeCount ].	^ lazyCandidates</body><body package="COASTMediator">makeClustersLazy: ccSet 	| count |	count := 0.	ccSet do: 		[: cc |			"do not lazyfy lazyfied ccs (when the last client left the bfs should be open some time longer)"			cc lazyLoad ifFalse: 				[	count := count + 1.					clusterMemoryFreedCounter := clusterMemoryFreedCounter + cc clusterStub approxByteSize.					cc becomeLazy 				] 		].	count &gt; 0 ifTrue: [ CoastLog logDebugDo: [ 'Made ' , count printString , ' cluster lazy ' ] ]</body><body package="COASTMediator">privateReleaseClustersIfPossible	clusterController copy do: 		[: cc | | lazyLoad clusterSize |			lazyLoad := cc lazyLoad.			clusterSize := cc clusterStub approxByteSize.			cc releaseIfPossible 				ifTrue: [ lazyLoad ifFalse: [ clusterMemoryFreedCounter := clusterMemoryFreedCounter + clusterSize ]]		]</body><body package="COASTMediator">quickCompactFreedMemoryThreshold	" note: refers to cluster size on disk "	^ self volumeManager quickCompactFreedMemoryThreshold</body><body package="COASTMediator">saveNow	| now |	( self clusterController contains: [: cc | cc lazyLoad not ]) ifFalse: 		[	"nothing to do"			^ false		].	( self clusterController select: [: cc | cc modified ]) size &gt; self volumeManager maxModifiedClusters ifTrue: 		[	CoastLog logDebugDo: [ 'too many clusters - autosave triggered' ].			^ true		].	self ownPacketStations isEmpty ifTrue: 		[	CoastLog logDebugDo: [ 'no clients - autosave triggered' ].			^ true		].	now := Time secondClock.	^ self autosaveTime &lt;= now and: [ self lastSaveTime + 30 &lt; now ]</body><body package="COASTMediator">setLastSaveTime	lastSaveTime := Time secondClock.</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>messages</category><body package="COASTMediator">broadcastInterrupt: aCatRMMessage	self ownPacketStations		do: [: ps |			ps transmitMessage: aCatRMMessage copy ].</body><body package="COASTMediator">handleMessage: aCatRMMessage	| handler |	handler := aCatRMMessage handlerForClusterManager: self.	handler notNil		ifTrue: [ aCatRMMessage safeInitiateFor: [ handler ] ]		ifFalse: [ self statusError: 'Cannot dispatch message: ', aCatRMMessage printString ].</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>IDs</category><body package="COASTMediator">createCluster	| cluster |	cluster := super createCluster.	CoastLog logDebugDo: [ 'Created cluster ' , self volume displayString , '/' , cluster clusterID printString ].	^ cluster</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>initialize-release</category><body package="COASTMediator">basicEmergencyShutDown	self volumeManager disconnectStations: self ownPacketStations.	super basicEmergencyShutDown.</body><body package="COASTMediator">initialize	super initialize.	clusterMemoryFreedCounter := 0.	testAndSet := CoastTestAndSet new</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>testing</category><body package="COASTMediator">isClusterLoaded: clusterIDInteger 	"true only if the cluster is completely loaded into memory"	| cc |	cc := clusterController at: clusterIDInteger ifAbsent: [ nil ].	^ cc isNil 		ifTrue: [ false ]		ifFalse: [ cc lazyLoad not ]</body><body package="COASTMediator">isMediatorCM	"bingo!"	^ true</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>garbage collection</category><body package="COASTMediator">collectGarbage	" Starts a garbage collection. Returns a CoastStatusResponse "	^ self exclusiveUseDo: 		[	self storageInterface gcEnabled 				ifTrue: 				[	garbageCollector isNil 						ifTrue: 						[	garbageCollector := CatCSGarbageCollector newWithManager: self inVolume: volume.							[	garbageCollector ifNotNil: [: paranoia | paranoia collectGarbage ].								garbageCollector := nil							] forkAt: Processor userBackgroundPriority.							CoastStatusResponse okCode: #gcStarted message: 'Garbage collection started'						]						ifFalse: 						[	garbageCollector ifNotNil: [: paranoia | paranoia wakeUp ].							CoastStatusResponse okCode: #gcResumed message: 'Garbage collection resumed'						]				]				ifFalse: [ CoastStatusResponse failureCode: #gcDisabled message: 'Garbage collection not enabled' ]		]</body><body package="COASTMediator">pauseCollectingGarbage	" Pause the garbage collection. Returns a CoastStatusResponse "	^ self exclusiveUseDo: 		[	garbageCollector isNil 				ifTrue: [ CoastStatusResponse failureCode: CoastStatusResponse codeNoGCRunning message: 'Garbage collection not running' ]				ifFalse: 				[	garbageCollector gotoHibernation.					CoastStatusResponse okCode: #gcPaused message: 'Garbage collection paused'				]		]</body><body package="COASTMediator">stopCollectingGarbage	^ self exclusiveUseDo: 		[	garbageCollector isNil 				ifTrue: [ CoastStatusResponse failureCode: CoastStatusResponse codeNoGCRunning message: 'Garbage collection not running' ]				ifFalse: 				[	garbageCollector stopGC.					CoastStatusResponse okCode: #gcStopped message: 'Garbage collection stopped'				]		]</body><body package="COASTMediator">waitForEndOfGC	garbageCollector ifNotNil: [: cgc | cgc waitForEndOfGC ].</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>test and set</category><body package="COASTMediator">validTestAndSet: key oldValue: oldValue newValue: newValue 	^ testAndSet testAndSet: key oldValue: oldValue newValue: newValue</body></methods><methods><class-id>COAST.CatRMClientState</class-id> <category>concurrency control</category><body package="COASTMediator">addUnseen: aLoggedTransactionAgenda	unseen addLast: aLoggedTransactionAgenda</body><body package="COASTMediator">doAccept: aLoggedTransactionAgenda	"the givem transaction is globally commited, take this into account"	acceptedLocalSeqNum := aLoggedTransactionAgenda transactionID localSeqNum.</body><body package="COASTMediator">reduceUnseenBefore: aGlobalSeqNum	"every transaction that has a smaller or equal global id than aGlobalSeqNum	can be removed from the list of unseen"	unseen isEmpty ifFalse:	[		(unseen first transactionID globalSeqNum &lt;= aGlobalSeqNum)			ifTrue: [ unseen removeFirst. self reduceUnseenBefore: aGlobalSeqNum ].	].</body><body package="COASTMediator">tryAccept: aLoggedTransactionAgenda	"this is the main concurrency control algorithm which decides if a transaction	 is globally commited"	| accept |	accept := self wouldAccept: aLoggedTransactionAgenda.	accept ifTrue: [ self doAccept: aLoggedTransactionAgenda ].	^accept</body><body package="COASTMediator">unseenCommuteWith: aLoggedTransactionAgenda 	"check if all unseen commute with aLoggedTransactionAgenda"	| agenda |	agenda := aLoggedTransactionAgenda agenda.	unseen do: 		[: entry | ( entry agenda isCommutativeTo: agenda loggedAgenda: aLoggedTransactionAgenda ) ifFalse: 				[	aLoggedTransactionAgenda failReasons ifNotNil: [ : reasons | reasons do: [ : reason | reason conflictingAgenda: entry ] ] ifNil: [ aLoggedTransactionAgenda addFailReason: (NotCommutative conflictingAgenda: entry) ].					^ false				]		].	^ true</body><body package="COASTMediator">wouldAccept: aLoggedTransactionAgenda 	"this is the main concurrency control algorithm which decides if a transaction	 would be globally commited"	| tid |	tid := aLoggedTransactionAgenda transactionID.	self reduceUnseenBefore: tid basedOnGlobal.	^ tid basedOnLocal = acceptedLocalSeqNum 		ifTrue: [ unseen isEmpty or: [ self unseenCommuteWith: aLoggedTransactionAgenda ]]		ifFalse: 		[			aLoggedTransactionAgenda addFailReason: (OutOfSequence expectedBaseNumber: acceptedLocalSeqNum wrongBaseNumber: tid basedOnLocal).			false		]</body></methods><methods><class-id>COAST.CatRMClientState</class-id> <category>initialize</category><body package="COASTMediator">initialize	acceptedLocalSeqNum := 0.	unseen := OrderedCollection new.</body></methods><methods><class-id>COAST.CatRMClientState class</class-id> <category>instance creation</category><body package="COASTMediator">new	^super new initialize</body></methods><methods><class-id>COAST.CatRMMediatorPacketStation</class-id> <category>accessing</category><body package="COASTMediator">activate	"start receiving messages"	self initializeProcesses.	connected := true.	self startClientActivityWatchdog.</body><body package="COASTMediator">connectionStartTime	^connectionStartTime ifNil: [connectionStartTime := Timestamp now]</body><body package="COASTMediator">isWaitingForReconnect	^ reconnectProcess notNil</body><body package="COASTMediator">peerDescription	"contains information about the peer that can be used for logging/debugging"	^peerDescription ifNil: [ Dictionary new ]</body><body package="COASTMediator">peerDescriptionString	| stream |	stream := String new writeStream.	self peerDescription associations do: [  : a | a printOn: stream ] separatedBy: [ stream nextPutAll: ', ' ].	^ stream contents</body><body package="COASTMediator">peerID	^peerID.</body><body package="COASTMediator">persistentClientID	^ persistentClientID</body><body package="COASTMediator">printPeerTypeOn: stream 	stream nextPutAll: 'client'.	stream space.	peerID printOn: stream</body><body package="COASTMediator">processNamePrefix	| stream |	stream := String new writeStream.	stream nextPutAll: 'CoastMediator'.	peerID notNil ifTrue: 		[	stream nextPutAll: '[peer '.			peerID printOn: stream.			stream nextPut: $]		].	^ stream contents</body><body package="COASTMediator">reConnectTo: aSocketAccessor receiveStream: newReceiveStream 	"check if the client is OK"	" read client authentication "	| newSendStream |	newSendStream := aSocketAccessor coastBinaryWriteStream.	self class marshallConnectionStatusResponse: ( CoastStatusResponse okCode: #reconnected message: '' ) clientID: peerID on:  newSendStream.	( self checkClientReceiveStream: newReceiveStream sendStream: newSendStream isReconnect: true ) ifFalse: 		[	newSendStream close.			newReceiveStream close.			^ false		].	self terminateReconnect.	self setLastReceiveTime.	socketAccessor := aSocketAccessor.	receiveStream := newReceiveStream.	sendStream := newSendStream.	connected := true.	self restartSendProcess.	self restartReceiveProcess.	self restartClientActivityWatchdog.	^ true</body><body package="COASTMediator">terminateReconnect	reconnectProcess isNil ifTrue: [ ^ self ].	reconnectProcess terminate.	reconnectProcess := nil</body><body package="COASTMediator">waitForReconnectOnFailure: failureBlock	reconnectProcess notNil		ifTrue: [ ^ failureBlock value ].	reconnectProcess := 	[	CoastLog logDebugDo: [ 'Client ', self peerID printString, ' waiting for reconnect' ].		(Delay forSeconds: self class maxReconnectSeconds) wait.		CoastLog logDebugDo: [ 'Client ', self peerID printString, ' reconnect timeout' ].		[ failureBlock value ] fork.	] fork.</body><body package="COASTMediator">waitsForReconnect	^ reconnectProcess notNil</body></methods><methods><class-id>COAST.CatRMMediatorPacketStation</class-id> <category>private: send/receive</category><body package="COASTMediator">deliverReceivedMessage: aCatRMMessage	"deliver the message to the cluster manager"	"in case of requests remember the sending site"	aCatRMMessage isRequest ifTrue: [ aCatRMMessage receiverPacketStation: self ].	super deliverReceivedMessage: aCatRMMessage</body><body package="COASTMediator">handleConnectionLostTo: oldSocket 	"give the client a chance to reconnect"	"suspend everything here so far"	socketAccessor == oldSocket ifFalse: [^ self ].			"socket already replaced"	self connectionLostError.	self terminateClientActivityWatchdog.	self terminateReceiveAndSendViaSocket: oldSocket.	self isWaitingForReconnect		ifFalse: [ self waitForReconnectOnFailure: [ self disconnectIrreversible ]]</body><body package="COASTMediator">logExpected: expectedID received: messageID 	CoastLog log: [ 'Expected message ID ' , expectedID printString , ', received ' , messageID printString , ' from ' , self peerID printString ].</body><body package="COASTMediator">receiveCommandOrMessage	self setLastReceiveTime.	^ super receiveCommandOrMessage</body><body package="COASTMediator">receivedRegularDisconnect	"notify regular peer disconnect"	volumeManager clientRegularDisconnected: peerID.</body><body package="COASTMediator">setLastReceiveTime	lastReceiveTime := Time secondClock.</body></methods><methods><class-id>COAST.CatRMMediatorPacketStation</class-id> <category>private: initialize</category><body package="COASTMediator">checkClient	"check if the client is OK"	" read client authentication "	^ self checkClientReceiveStream: receiveStream sendStream: sendStream isReconnect: false</body><body package="COASTMediator">checkClientReceiveStream: aReceiveStream sendStream: aSendStream isReconnect: isReconnect 	"check if the client is OK"	" read client authentication "	| newPersistentClientID securityFault |	newPersistentClientID := self plausiblePersistentClientIDOrNilForm: aReceiveStream.	newPersistentClientID isNil ifTrue: [ ^ false	"this is radio gaga, not a coast client" ].	peerDescription := self peerDescriptionFrom: aReceiveStream.	peerDescription isNil ifTrue: [ ^ false	"this is radio gaga, not a coast client" ].	isReconnect 		ifTrue: 		[	persistentClientID = newPersistentClientID ifFalse: 				[	CoastLog logError: 'Reconnect failed, persistent client ID differs &lt;' , self peerID printString , '&gt;'.					aSendStream nextPut: CoastConstant authenticationRejected.					aSendStream flush.					^ false				]		]		ifFalse: [ persistentClientID := newPersistentClientID ].	" old style 'authentication' ok "	aSendStream nextPut: CoastConstant authenticationOK.	aSendStream flush.	securityFault := self secureHandshakeWithReceiveStream: aReceiveStream SendStream: aSendStream.	securityFault notNil ifTrue: 		[	CoastLog logError: securityFault.			sendStream nextOptimized32Put: -1.			sendStream nextCoastStringPut: securityFault.			sendStream flush.			^ false		].	isReconnect ifFalse: [ self volumeManager prepareNewConnectedPacketStation: self ].	^ true</body><body package="COASTMediator">clientActivityWatchdogLoop	| lastCheckTime actualWaitTime leapInTime |	lastCheckTime := Time secondClock.	[ connected ] whileTrue: 		[ 	| delta now max |			now := Time secondClock.			delta := now - lastReceiveTime.			" Wenn der mediator selbst eine lange Zeit nicht zugehÃ¶rt hat (z.b. suspend mode),			darf er nicht den Client dafÃ¼r bestrafen "			actualWaitTime := now - lastCheckTime.			lastCheckTime := now.			leapInTime := actualWaitTime - self maxSilentSeconds.			" Timer ist mÃ¶glicherweise nicht sekundengenau, wenn der Prozess nicht sofort nach Ablauf des Timers aktiviert wurde.			Deshalb 3 Sekunden Ungenauigkeit zulassen.			ZeitsprÃ¼nge in die Vergangenheit werden hier nicht betrachtet, die Clients haben dann entsprechend mehr Zeit "			leapInTime &lt;= 3 				ifTrue: 				[	max := self maxSilentSeconds max: actualWaitTime.					delta &gt;= max 						ifTrue: 						[	connected 								ifTrue: 								[	CoastLog logWarning: 'Timeout for client ' , self peerString.									clientActivityWatchdog := nil.									self disconnectIrreversible								]						]						ifFalse: [(self maxSilentSeconds - delta ) seconds wait ]				]				ifFalse: [					" das wird leider das Log ziemlich vollmÃ¼llen, da pro Client "					CoastLog logWarning: 'Leap in time (', leapInTime printString, ' seconds) detected for client ' , self peerString.					self maxSilentSeconds seconds wait.				]		].</body><body package="COASTMediator">disconnectIrreversible	CoastLog logDebugDo: [ 'Client ', self peerString , ' disconnected after ',					(Timestamp now asSeconds - self connectionStartTime asSeconds) printString, 					' seconds, no reconnect possible' ].	super disconnectIrreversible.</body><body package="COASTMediator">initializeForSocketAccessor: aSocketAccessor forPeerID: anInteger receiveStream: aStream volumeManager: volManager 	| ok |	socketAccessor := aSocketAccessor.	sendStream := aSocketAccessor coastBinaryWriteStream.	ok := false.	peerID := anInteger.	receiveStream := aStream.	self volumeManager: volManager.	self class marshallConnectionStatusResponse: ( CoastStatusResponse okCode: #connected message: '' ) clientID: peerID on: sendStream.	"  client ok? "	self checkClient 		ifTrue: 		[	connectionStartTime := Timestamp now.			self setLastReceiveTime.			ok := true		].	^ ok 		ifTrue: [ self ]		ifFalse: 		[	aStream close.			nil		]</body><body package="COASTMediator">maxSilentSeconds	"max amount of seconds silent time (no message from peer) before auto-disconnect is activated"	^ self class maxSilentSeconds</body><body package="COASTMediator">peerDescriptionFrom: aReceiveStream 	self statusLog: [ 'Receiving client description' ].	aReceiveStream next = CatCSDictionary marshallID ifFalse: [ CoastLog logWarning: 'client description defect'. ^nil ].	^(CatCSDictionary unmarshallBinaryArgumentFrom: aReceiveStream marshaller: CatMAMarshallBinary new) ifNotNil: [ : coastCollection | coastCollection value ].</body><body package="COASTMediator">plausiblePersistentClientIDOrNilForm: aReceiveStream 	| newPersistentClientID size |	self statusLog: [ 'Receiving persistent client ID' ].	size := aReceiveStream next = ByteArray marshallID 			ifTrue: [ aReceiveStream nextOptimized32 ]			ifFalse: [ 0 ].	(( CoastVersion defaultCoastVersion isMin: 5 minor: 4 ) 		ifTrue: [ size = Security.MD5 digestSize "late 5.3 clients already do MD5ed PC-ID"]		ifFalse: [ size &gt;= 8 and: [ size &lt; 512 ] "anything else is too fishy"])			ifFalse: 			[	CoastLog logWarning: 'connection abort - broken persistent client id'.				^ nil	"this is raidio gaga, not a coast client"			].	newPersistentClientID := ByteArray new: size.	aReceiveStream next: size into: newPersistentClientID startingAt: 1.	self statusLog: [ 'Received persistent client ID' ].	^ newPersistentClientID</body><body package="COASTMediator">restartClientActivityWatchdog	self terminateClientActivityWatchdog.	self startClientActivityWatchdog.</body><body package="COASTMediator">startClientActivityWatchdog	"values for maxSilentSeconds of 0 or below means that the watchdog process should not start"	clientActivityWatchdog :=		[ self clientActivityWatchdogLoop ] forkAt: Processor userSchedulingPriority.	clientActivityWatchdog name: self processNamePrefix , ' - client activity watchdog'.</body></methods><methods><class-id>COAST.CatRMMediatorPacketStation</class-id> <category>private: accessing</category><body package="COASTMediator">psPrintString	^ 'Mediator PS [', self peerString, ']'</body><body package="COASTMediator">terminateClientActivityWatchdog	clientActivityWatchdog notNil		ifTrue: [			clientActivityWatchdog terminate.			clientActivityWatchdog := nil.		].</body><body package="COASTMediator">terminateProcessesAndStreams	self terminateReconnect.	self terminateClientActivityWatchdog.	super terminateProcessesAndStreams.</body></methods><methods><class-id>COAST.CatRMMediatorPacketStation</class-id> <category>printing</category><body package="COASTMediator">printOn: stream 	connected 		ifTrue: 		[	stream nextPutAll: 'MediatorPS connected to: '.			self peerID printOn: stream		]		ifFalse: [ stream nextPutAll: 'MediatorPS unconnected' ]</body></methods><methods><class-id>COAST.CatRMMediatorPacketStation class</class-id> <category>accessing</category><body package="COASTMediator">maxReconnectSeconds	^ MaxReconnectSeconds ifNil: [ 3600 ]</body><body package="COASTMediator">maxReconnectSeconds: anInteger	MaxReconnectSeconds := anInteger</body><body package="COASTMediator">maxSilentSeconds	"max amount of seconds silent time (no message from peer) before auto-disconnect is activated"	^ MaxSilentSeconds ifNil: [  86400 ]</body><body package="COASTMediator">maxSilentSeconds: anInteger	"max amount of seconds silent time (no message from peer) before auto-disconnect is activated"	MaxSilentSeconds := anInteger</body></methods><methods><class-id>COAST.CatRMMediatorPacketStation class</class-id> <category>instance creation</category><body package="COASTMediator">newWithSocket: aSocketAccessor forPeerID: anInteger receiveStream: aStream volumeManager: volManager 	"this method called by the dispatcher whenever a new client connects"	^self new 		initializeForSocketAccessor: aSocketAccessor		forPeerID: anInteger		receiveStream: aStream		volumeManager: volManager</body></methods><methods><class-id>COAST.CatRMMediatorPacketStation class</class-id> <category>connect</category><body package="COASTMediator">fakeReconnectAndFailFor: clientID from: aReceiveStream to: aSendStream 	"a client packet station wants to re-connect, it's an unknown client"	[	self 			marshallConnectionStatusResponse: ( CoastStatusResponse failureCode: #reconnectFailed message: 'Reconnect failed' )			clientID: clientID			on: aSendStream	] ensure: 		[	aSendStream close.			aReceiveStream close		].</body><body package="COASTMediator">marshallConnectionStatusResponse: statusResponse clientID: clientID on:  sendStream	statusResponse marshallBinaryTo: sendStream.	sendStream nextOptimized32Put: clientID.	self marshallVersionOn: sendStream.	sendStream flush.</body></methods><methods><class-id>COAST.MediatorRPCTransaction</class-id> <category>accessing</category><body package="COASTMediator">allowRPCWriteAccessesWhile: aBlock 	| old |	old := ignoreWriteAccesses.	ignoreWriteAccesses := true.	^ aBlock ensure: [ ignoreWriteAccesses := old ]</body><body package="COASTMediator">recordAccess: aCatCSCellAccess 	"only dirty reads allowed - don't record anything!"	self ignoreWriteAccesses ifFalse: [ aCatCSCellAccess isWriteAccess ifTrue: [ self error: 'this transaction does not allow write accesses' ] ]</body><body package="COASTMediator">volumeManager	^  volumeManager</body><body package="COASTMediator">volumeManager: aVolumeManager 	volumeManager := aVolumeManager.</body></methods><methods><class-id>COAST.MediatorRPCTransaction</class-id> <category>testing</category><body package="COASTMediator">canWrite	^ false</body><body package="COASTMediator">ignoreWriteAccesses	^ ignoreWriteAccesses ifNil: [ false ]</body></methods><methods><class-id>COAST.CMVersionRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant version</body></methods><methods><class-id>COAST.CMVersionRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream |			CoastStatusResponse requestOk marshallBinaryTo: replyStream.			CoastVersion defaultCoastVersion marshallBinaryTo: replyStream		].</body></methods><methods><class-id>COAST.MediatorTransaction</class-id> <category>initialize - release</category><body package="COASTMediator">initialize	super initialize.	replacedAccesses := OrderedCollection new</body><body package="COASTMediator">replacements	| accesses |	accesses := ( replacedAccesses collect: [: assoc | assoc value ]) asSet.	^ accesses isEmpty 		ifTrue: [ nil ]		ifFalse: 		[ | agenda |			agenda := CatRMSimpleAgenda cluster: rollingAgenda cluster.			accesses do: [: access | agenda addSlotWriteAccess: access ].			agenda		]</body></methods><methods><class-id>COAST.MediatorTransaction</class-id> <category>accessing</category><body package="COASTMediator">addPendingChanges: clusterManager to: aCatRMMediatorAgenda	self combinedAgenda simpleAgendas do: 		[: simpleAgenda | | cc loggedAgenda tid |			simpleAgenda isEmpty 				ifFalse: [					loggedAgenda := CatRMLoggedTransactionAgenda new.					loggedAgenda agenda: simpleAgenda.					cc := clusterManager clusterController at: simpleAgenda clusterLocator id.					tid := cc fakedTransactionIDFor: simpleAgenda.					loggedAgenda transactionID: tid.					cc checkForCGCLoggedAgenda: loggedAgenda.					cc doAccept: loggedAgenda.					aCatRMMediatorAgenda addMediatorAgenda: loggedAgenda.				].		].</body><body package="COASTMediator">privateRollingAgenda: newRollingAgenda 	rollingAgenda := newRollingAgenda</body><body package="COASTMediator">recordAccess: aCatCSCellAccess 	"Add the access to the agenda. Also store the cell value for rollbacks 	if aCatCSCellAccess is the first access in this transaction	(some demons might be interested, too) "	"some proxy accesses have to be replaced by the *one* access introducing the proxy reference frame"	| replacementRemote |	replacementRemote := aCatCSCellAccess asRemoteSlotAccess.	replacementRemote notNil		ifTrue: [			replacedAccesses do: [ :assoc | assoc key = replacementRemote ifTrue: [ assoc value: replacementRemote. ^self ] ].		].	combinedAgenda addAccess: aCatCSCellAccess</body><body package="COASTMediator">recordCellCreation: aCatCSCell 	"the creation of new cell instances has to be recorded."	combinedAgenda addCellCreation: aCatCSCell.</body><body package="COASTMediator">reduceRollingAgenda	rollingAgenda isNil ifTrue: [ ^ self ].	replacedAccesses do: 		[: accessAssoc | | replacementRemoteAccess originalRemoteAccess |			originalRemoteAccess := accessAssoc key.			replacementRemoteAccess := accessAssoc value.			rollingAgenda replaceSlotWriteAccess: originalRemoteAccess with: replacementRemoteAccess		].	"replacedAccesses := OrderedCollection new"</body><body package="COASTMediator">removeProxyAccess: access 	" remember that the access will be either replaced or removed "	| remoteAccess |	remoteAccess := access asRemoteSlotAccess.	(replacedAccesses anySatisfy: [ : assoc | assoc key = remoteAccess ])		ifFalse: [ replacedAccesses add: (remoteAccess -&gt; nil) ]</body><body package="COASTMediator">volumeManager	^ rollingAgenda volumeManager</body></methods><methods><class-id>COAST.MediatorTransaction class</class-id> <category>instance creation</category><body package="COASTMediator">rollingAgenda: agenda 	^ ( self new )		privateRollingAgenda: agenda;		yourself</body></methods><methods><class-id>COAST.CatRMBackupJob</class-id> <category>accessing</category><body package="COASTMediator">backupsToKeep	^backupsToKeep</body><body package="COASTMediator">backupsToKeep: aValue	backupsToKeep := aValue</body></methods><methods><class-id>COAST.CatRMBackupJob</class-id> <category>action</category><body package="COASTMediator">basicDoJobFor: aMediator 	| volumeManager volumesToBackup |	volumeManager := aMediator volumeManager.	volumeManager exclusiveUseDo: 		[	volumesToBackup := self matchingVolumesForVolumeManager: volumeManager.			volumesToBackup notEmpty 				ifTrue: 				[	volumesToBackup do: 						[: volumeToBackup | ( volumeManager clusterManagerForVolume: volumeToBackup )								backupVolumeAndKeep: self backupsToKeep						]				]				ifFalse: [ self logNoMatchingVolumes ]		].</body><body package="COASTMediator">doBackupJobFor: aMediator	self doJobFor: aMediator</body></methods><methods><class-id>COAST.CatRMBackupJob class</class-id> <category>instance creation</category><body package="COASTMediator">fromIniDictionary: iniDict volume: aVolume 	| newInst timeString interval |	newInst := super fromIniDictionary: iniDict volume: aVolume.	timeString := iniDict 				category: aVolume				at: 'backupTime'				ifAbsent: [ ^ nil ].	interval := iniDict 				category: aVolume				numberAt: 'backupInterval'				ifAbsent: [ 1 ].	interval &lt; 1 ifTrue: [ ^ nil ].	newInst jobTime: (Time readFrom: (ReadStream on: timeString)).	newInst jobInterval: interval.	newInst backupsToKeep: (iniDict 				category: aVolume				numberAt: 'backupsToKeep'				ifAbsent: [ 3 ]).	^ newInst</body></methods><methods><class-id>COAST.CatRMBackupJob class</class-id> <category>constants</category><body package="COASTMediator">type	^'backup'</body></methods><methods><class-id>COAST.CatRMGarbageCollectJob</class-id> <category>action</category><body package="COASTMediator">basicDoJobFor: aMediator 	| volumesToGC |	volumesToGC := self matchingVolumesForVolumeManager: aMediator volumeManager.	volumesToGC notEmpty 		ifTrue: 		[	volumesToGC do: 				[: volumeToGC | | clusterManager |					clusterManager := aMediator volumeManager clusterManagerForVolume: volumeToGC.					clusterManager collectGarbage.					clusterManager waitForEndOfGC				]		]		ifFalse: [ self logNoMatchingVolumes ].</body></methods><methods><class-id>COAST.CatRMGarbageCollectJob class</class-id> <category>instance creation</category><body package="COASTMediator">fromIniDictionary: iniDict volume: aVolume	| newInst timeString |	newInst := super fromIniDictionary: iniDict volume: aVolume.	timeString := iniDict category: aVolume at: 'garbageCollectTime' ifAbsent: [ ^nil ].	newInst jobTime: (Time readFrom: (ReadStream on: timeString)).	newInst jobInterval: (iniDict category: aVolume numberAt: 'garbageCollectInterval' ifAbsent: [ 1 ]).	^newInst</body></methods><methods><class-id>COAST.CatRMGarbageCollectJob class</class-id> <category>constants</category><body package="COASTMediator">type	^'garbage collect'</body></methods><methods><class-id>COAST.CatRMLazyMediatorCC</class-id> <category>lazify</category><body package="COASTMediator">becomeLazy	lazy := true.	self clusterStub breakReferences.	self clusterStub valueHolder: nil</body></methods><methods><class-id>COAST.CatRMLazyMediatorCC</class-id> <category>accessing</category><body package="COASTMediator">cluster	"load the cluster first if necessary"	self lazyLoad ifTrue: 		[ | modNum |			lazy := false.			modNum := self clusterStub isNil 					ifTrue: [ nil ]					ifFalse: [ self clusterStub modificationNumber ].	"keep mod num, may be already modified"			self loadCluster: self clusterStub id.			self clusterStub modificationNumber: modNum		].	^ self clusterStub</body></methods><methods><class-id>COAST.CatRMLazyMediatorCC</class-id> <category>cluster creation</category><body package="COASTMediator">createCluster: clusterIDInteger	"create the Cluster specified by clusterIDInteger"	lazy := false.	^super createCluster: clusterIDInteger</body></methods><methods><class-id>COAST.CatRMLazyMediatorCC</class-id> <category>testing</category><body package="COASTMediator">isNewCluster	^ self lazyLoad not and: [ super isNewCluster ]</body><body package="COASTMediator">lazyLoad	^lazy ifNil: [ true ]</body><body package="COASTMediator">modified	| mod |	mod := super modified.	mod ifFalse: [^false].	self lazyLoad		ifTrue: 			[self statusError: 'warning: cluster ' , self clusterStub id printString , ' marked as modified but is lazy'.			^false].	^true</body></methods><methods><class-id>COAST.CatRMLazyMediatorCC</class-id> <category>replication</category><body package="COASTMediator">clusterForClientMessage: aClientID 	"create a CatRMClusterForClientMessage that is needed to replicate	the cluster this CC controls"	^self lazyLoad 		ifTrue: 			[	| message |				message := CatRMStreamingClusterForClientMessage new.				message cluster: self clusterStub.				message storageInterface: self clusterManager storageInterface.				message globalSeqNum: globalSeqNum.				message prepare.				clients at: aClientID put: CatRMClientState new.	"immidiately register the new client"				message			]		ifFalse: [super clusterForClientMessage: aClientID]</body></methods><methods><class-id>COAST.CMSynchTimeRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant synchTime</body></methods><methods><class-id>COAST.CMSynchTimeRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | | time byteArray bIndex |			CoastStatusResponse requestOk marshallBinaryTo: replyStream.			time := Timestamp coastRightNow asMilliseconds.			byteArray := ByteArray new: 8.			bIndex := 1.			[ time = 0 ] whileFalse: 				[	byteArray at: bIndex put: time \\ 256.					time := time // 256.					bIndex := bIndex + 1				].			byteArray do: [: x | replyStream nextPut: x ]		].</body></methods><methods><class-id>COAST.CMVolumeListRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant volumes.</body></methods><methods><class-id>COAST.CMVolumeListRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self requestFrom: receiveStream socketAccessor: aSocketAccessor replyStreamDo: [: replyStream | self listVolumesOn: replyStream ].</body><body package="COASTMediator">listVolumesOn: replyStream 	| storedVolumes |	storedVolumes := self volumeInterface storedVolumes.	CoastStatusResponse ok marshallBinaryTo: replyStream.	replyStream nextOptimized32Put: storedVolumes size.	^ storedVolumes do: [: each | replyStream nextCoastStringPut: each ]</body></methods><methods><class-id>COAST.CMVolumeListRequest class</class-id> <category>testing</category><body package="COASTMediator">isAbstractRequest	^ false</body></methods><methods><class-id>COAST.CMCreateVolumeRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | | newVolume password statusResponse |			password := receiveStream nextCoastString.			statusResponse := ( self mediator matchesRemotePassword: password ) 					ifTrue: 					[	newVolume := receiveStream nextCoastString.						[	self volumeManager exclusiveUseDo: [ self volumeManager clusterManagerForVolume: newVolume ].							CoastStatusResponse okCode: #createdVolume message: 'Created volume ' , newVolume						] on: Error do: [: ex | CoastStatusResponse failureCode: #couldNotCreateVolume message: ex description ]					]					ifFalse: [ CoastStatusResponse accessDenied ].			statusResponse marshallBinaryTo: replyStream		].</body><body package="COASTMediator">requestId	^CoastConstant createVolumeID</body></methods><methods><class-id>COAST.CMChangePasswordRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | | oldPWD newPWD statusResponse message |			oldPWD := receiveStream nextCoastString.			statusResponse := ( self mediator matchesRemotePassword: oldPWD ) 					ifTrue: 					[	newPWD := receiveStream nextCoastString.						self mediator remotePassword: newPWD.						message := 'Mediator password changed'.						CoastLog logWarning: message.						CoastStatusResponse okCode: #mediatorPasswordChanged message: message					]					ifFalse: [ CoastStatusResponse failureCode: #mediatorPasswordChangeRejected message: 'Mediator password change rejected' ].			statusResponse marshallBinaryTo: replyStream		].</body></methods><methods><class-id>COAST.CMChangePasswordRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant changeRemotePasswordID</body></methods><methods><class-id>COAST.CMBackupOperationRequest</class-id> <category>private</category><body package="COASTMediator">descriptionForBackupVolume: backupVolume version: backupVersion	^ backupVolume , ' / ' ,  (CatCSVolumeManager descriptionForBackupVersion: backupVersion ) , ' (' , ( backupVersion ) , ')'</body></methods><methods><class-id>COAST.CMBackupOperationRequest class</class-id> <category>testing</category><body package="COASTMediator">isAbstractRequest	^ self = CMBackupOperationRequest</body></methods><methods><class-id>COAST.CMFrameClassIndexRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^ CoastConstant getFrameClassIndex</body></methods><methods><class-id>COAST.CMFrameClassIndexRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream |			volume := receiveStream nextCoastString.			classIndex := receiveStream nextOptimized32.			self exclusiveUseDo: 				[ | clusterManager error frameSlotIndex |					clusterManager := self mediator clusterManagerForExistingVolume: volume ifAbsent: [ nil ].					error := nil.					clusterManager isNil 						ifTrue: [ error := 'illegal volume' ]						ifFalse: 						[								[ frameSlotIndex := clusterManager frameSlotIndexForIndex: classIndex ] on: Error do: [: ex | error := ex description ]						].					error notNil 						ifTrue: [( CoastStatusResponse failureCode: #frameClassIndexFailed message: error ) marshallBinaryTo: replyStream ]						ifFalse: 						[	CoastStatusResponse requestOk marshallBinaryTo: replyStream.							frameSlotIndex marshallArgumentBinaryTo: replyStream						]				]		].</body></methods><methods><class-id>COAST.CMEvaluateRequest</class-id> <category>accessing</category><body package="COASTMediator">enabled	^enabled ifNil: [ enabled := Notifier isDevelopment ]</body><body package="COASTMediator">requestId	^ CoastConstant evaluateID</body></methods><methods><class-id>COAST.CMEvaluateRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | | smalltalkCode statusResponse |			smalltalkCode := receiveStream nextCoastString.			CoastLog logWarning: 'Request to evaluate: ' , smalltalkCode.			statusResponse := ( self mediator matchesRemotePassword: receiveStream nextCoastString ) 					ifTrue: 					[							[ | result |							result := ( Compiler evaluate: smalltalkCode ) printString.							CoastStatusResponse okCode: #evaluatedCode message: result						] on: Error do: [: ex | CoastStatusResponse failureCode: #couldNotEvaluateCode message: ex description ]					]					ifFalse: [ CoastStatusResponse accessDenied ].			CoastLog log: [ 'Evaluate result: ' , statusResponse printString ].			statusResponse marshallBinaryTo: replyStream		].</body></methods><methods><class-id>COAST.CMReconnectRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	^ self timeoutDo: [ self volumeManager clientReConnectionAt: aSocketAccessor receiveStream: receiveStream ]</body></methods><methods><class-id>COAST.CMReconnectRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant clientReConnection</body></methods><methods><class-id>COAST.CMDownloadLogRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | ( self mediator matchesRemotePassword: receiveStream nextCoastString ) 				ifTrue: 				[	( CoastStatusResponse okCode: #log message: 'Log' ) marshallBinaryTo: replyStream.					self exclusiveUseDo: 						[ | logFilename |							logFilename := self mediator configuration logFilename ifNotNil: [ : l | l asFilename ].							(logFilename isNil or: [ logFilename exists not ])								ifTrue: [ self copyTranscriptTo: replyStream ]								ifFalse: [ self copyLogfile: logFilename to: replyStream ]						]				]				ifFalse: [ CoastStatusResponse accessDenied marshallBinaryTo: replyStream ]		].</body><body package="COASTMediator">copyLogfile: filename to: replyStream 	| readStream bytes |	readStream := filename readStream binary.	[	bytes := filename fileSize.		replyStream nextUnsigned32Put: bytes.		replyStream nextPutAll: readStream contents	] ensure: [ readStream close ].</body><body package="COASTMediator">copyTranscriptTo: replyStream 	| ba |	ba := Transcript value asString asByteArray.	replyStream nextUnsigned32Put: ba size.	replyStream nextPutAll: ba.</body></methods><methods><class-id>COAST.CMDownloadLogRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant downloadLogID</body></methods><methods><class-id>COAST.CMConnectRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	^ self timeoutDo: [ self volumeManager newClientConnectionAt: aSocketAccessor receiveStream: receiveStream ]</body><body package="COASTMediator">requestId	^CoastConstant clientConnection</body></methods><methods><class-id>COAST.CMBlobOrClusterSizeRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	| volume clusterID result |	self requestFrom: receiveStream socketAccessor: aSocketAccessor replyStreamDo:  [ : replyStream |		volume := receiveStream nextCoastString.		clusterID := receiveStream nextOptimized32.		result := self volumeInterface sizeOfBlobOrCluster: clusterID in: volume.		CoastStatusResponse requestOk marshallBinaryTo: replyStream.		replyStream nextUnsigned32Put: result.	].</body><body package="COASTMediator">requestId	^ CoastConstant blobOrClusterSize</body></methods><methods><class-id>COAST.CMListConnectionsRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^ CoastConstant listConnections</body></methods><methods><class-id>COAST.CMListConnectionsRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream |			self volumeManager exclusiveUseDo: 				[ | packetStationsToVolumesDict sortedStations |					CoastStatusResponse requestOk marshallBinaryTo: replyStream.					packetStationsToVolumesDict := self packetStationsToVolumesDict.					replyStream nextOptimized32Put: packetStationsToVolumesDict size.					sortedStations := packetStationsToVolumesDict keys sortedBy: [: packetStation | packetStation peerID ].					sortedStations do: 						[: packetStation | | connectedVolumes |							connectedVolumes := packetStationsToVolumesDict at: packetStation.							replyStream nextOptimized32Put: packetStation peerID.							replyStream nextCoastStringPut: packetStation ipAdressString.							replyStream nextOptimized32Put: connectedVolumes size.							connectedVolumes do: [: volume | replyStream nextCoastStringPut: volume ]						]				]		].</body><body package="COASTMediator">packetStationsToVolumesDict	"we have vomume-&gt;packetStations. we will invert to ps-&gt;volumes"	| volumesDict allPacketStations |	allPacketStations := self volumeManager packetStations.	volumesDict := Dictionary new.	allPacketStations do: [: ps | volumesDict at: ps put: SortedCollection new ].	self volumeManager clusterManagers 		do: [: clusterManager | clusterManager ownPacketStations do: [: ps | ( volumesDict at: ps ) add: clusterManager volume ]].	^ volumesDict</body></methods><methods><class-id>COAST.CMShutdownRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant shutDownMediator.</body></methods><methods><class-id>COAST.CMShutdownRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	| sender password replyStream statusResponse |	password := receiveStream nextCoastString.	sender :=		[ aSocketAccessor getPeer ] on: OsError do: [: ex | 'unknown host' ].	statusResponse := self mediator shutDownWithPassword: password from: sender.	[	replyStream := aSocketAccessor writeStream binary.		statusResponse marshallBinaryTo: replyStream.		replyStream flush.		receiveStream close.		replyStream close.		aSocketAccessor close	] on: Error do: [: ex | CoastLog logException: ex message: 'Unable to shut down' ].	statusResponse ok 		ifTrue: [ self mediator basicShutDown ].</body></methods><methods><class-id>COAST.CMVolumeExistsRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant volumeExists</body></methods><methods><class-id>COAST.CMVolumeExistsRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | | volumeName response |			volumeName := receiveStream nextCoastString.			response := ( self volumeInterface volumeExists: volumeName ) 					ifTrue: [ CoastStatusResponse requestOk ]					ifFalse: [ CoastStatusResponse volumeDoesNotExist: volumeName ].			response marshallBinaryTo: replyStream		].</body></methods><methods><class-id>COAST.CMBuildInfoRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant buildInfoID</body></methods><methods><class-id>COAST.CMBuildInfoRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	| buildInfo |	buildInfo := self volumeManager applicationDescription.	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | | marshaller |			marshaller := CatMAMarshallBinary new.			CoastStatusResponse requestOk marshallBinaryTo: replyStream.			replyStream nextOptimized32Put: buildInfo size.			buildInfo keysAndValuesDo: 				[: key : val |					marshaller marshallValue: key to: replyStream.					marshaller marshallValue: val to: replyStream.				]		].</body></methods><methods><class-id>COAST.CMPasswordProtectedVolumesListRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | ( self mediator matchesRemotePassword: receiveStream nextCoastString ) 				ifTrue: [ self listVolumesOn: replyStream ]				ifFalse: [ CoastStatusResponse accessDenied marshallBinaryTo: replyStream ]		].</body></methods><methods><class-id>COAST.CMPasswordProtectedVolumesListRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^ CoastConstant volumesPasswordProtected</body></methods><methods><class-id>COAST.CMVolumeDownloadRequest</class-id> <category>action</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | | password volume |			password := receiveStream nextCoastString.			( self mediator matchesRemotePassword: password ) 				ifTrue: 				[	volume := receiveStream nextCoastString.					self copyAndDownload: volume to: replyStream peer: aSocketAccessor getPeer				]				ifFalse: [ CoastStatusResponse accessDenied marshallBinaryTo: replyStream ]		].</body><body package="COASTMediator">copyAndDownload: volume to: replyStream peer: peerSocketAddress	[ | clusterManager tempStorageAccessor statusResponse message |		CoastLog log: [ 'Downloading volume "' , volume , '" to client ' , peerSocketAddress addressPrintString ] channel: #audit.		[	self exclusiveUseDo: [ clusterManager := self mediator existingClusterManagerForVolume: volume ].			tempStorageAccessor := clusterManager copyVolumeForDownload		] ensure: 			[	clusterManager notNil 					ifTrue: [ self exclusiveUseDo: [ clusterManager cleanup ]]			].		tempStorageAccessor startUpStorageAccessorFrom: clusterManager.		message := 'Volume "' , volume , '" downloaded'.		statusResponse := CoastStatusResponse okCode: #volumeDownloaded message: message.		statusResponse marshallBinaryTo: replyStream.		[ tempStorageAccessor sendVolumeTo: replyStream ] ensure: 			[	tempStorageAccessor shutDown.				tempStorageAccessor deleteVolumeNoBackup			].		CoastLog log: message	] on: Error do: [: ex | ( CoastStatusResponse failureCode: #volumeDownloadFiled message: ex description ) marshallBinaryTo: replyStream ].</body><body package="COASTMediator">downloadFrom: receiveStream to: replyStream 	| clusterManager volume |	volume := receiveStream nextCoastString.	self exclusiveUseDo: 		[				[					[	clusterManager := self mediator existingClusterManagerForVolume: volume.					clusterManager saveAllModifiedClusters.					clusterManager storageInterface sendVolumeTo: replyStream				] ensure: [ clusterManager cleanup ]			] on: CoastError do: [: ex | replyStream nextCoastStringPut: ex description ]		]</body></methods><methods><class-id>COAST.CMVolumeDownloadRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant downloadVolumeID</body></methods><methods><class-id>COAST.CMBackupDeleteRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant deleteBackupVolumeID.</body></methods><methods><class-id>COAST.CMBackupDeleteRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: readStream 	self 		validPasswordFromStream: readStream		do: 		[: receiveStream | | backupVolume backupVersion message |			backupVolume := receiveStream nextCoastString.			backupVersion := receiveStream nextCoastString.			[ | backupDescription |				backupDescription := self descriptionForBackupVolume: backupVolume version: backupVersion.				CoastLog log: [ 'Deleting backup ' , backupDescription, ', client ', aSocketAccessor getPeer addressPrintString ] channel: #audit.				self volumeManager deleteBackup: backupVolume version: backupVersion.				message := 'Deleted backup ' , backupDescription.				CoastLog log: message.				CoastStatusResponse okCode: #backupDeleted message: message			] 				on: Error				do: 				[: ex |					CoastLog logException: ex message: 'Unable to delete backup ' , backupVolume.					CoastStatusResponse failureCode: #couldNotDeleteBackup message: ex description				]		]		to: aSocketAccessor.</body></methods><methods><class-id>COAST.CMRecoverableVolumesRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant recoverableVolumes</body></methods><methods><class-id>COAST.CMRecoverableVolumesRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: receiveStream 	self 		requestFrom: receiveStream		socketAccessor: aSocketAccessor		replyStreamDo: 		[: replyStream | | recoverableVolumes |			recoverableVolumes := self volumeInterface recoverableVolumes.			CoastStatusResponse requestOk marshallBinaryTo: replyStream.			replyStream nextOptimized32Put: recoverableVolumes size.			recoverableVolumes keysAndValuesDo: 				[: vol : times |					replyStream nextCoastStringPut: vol.					replyStream nextOptimized32Put: times size.					times do: [: time | replyStream nextCoastStringPut: time ]				]		].</body></methods><methods><class-id>COAST.CMVolumeDeleteRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant deleteVolumeID</body></methods><methods><class-id>COAST.CMVolumeDeleteRequest</class-id> <category>actions</category><body package="COASTMediator">actionFor: clusterManager with: parameters 	clusterManager saveAllModifiedClusters.	^ clusterManager deleteVolume</body></methods><methods><class-id>COAST.CMVolumeDeleteRequest class</class-id> <category>accessing</category><body package="COASTMediator">operationName	^ 'Delete'</body></methods><methods><class-id>COAST.CMWaitForBackupFinishedRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^ CoastConstant blockUntilBackupIsDone</body></methods><methods><class-id>COAST.CMWaitForBackupFinishedRequest</class-id> <category>actions</category><body package="COASTMediator">actionFor: clusterManager with: parameters 	^ clusterManager blockUntilBackupIsDone</body><body package="COASTMediator">hasValidPasswordFromStream: stream 	^ true	"no password included / none is required"</body></methods><methods><class-id>COAST.CMWaitForBackupFinishedRequest class</class-id> <category>accessing</category><body package="COASTMediator">operationName	^ 'Wait for backup'</body><body package="COASTMediator">shouldLogOperation	^ false</body></methods><methods><class-id>COAST.CMVolumeBackupRequest</class-id> <category>actions</category><body package="COASTMediator">actionFor: clusterManager with: parameters 	clusterManager saveAllModifiedClusters.	^ clusterManager backupVolume</body></methods><methods><class-id>COAST.CMVolumeBackupRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant backupVolumeID</body></methods><methods><class-id>COAST.CMVolumeBackupRequest class</class-id> <category>accessing</category><body package="COASTMediator">operationName	^ 'Backup'</body></methods><methods><class-id>COAST.CMRecoverToVolumeRequest</class-id> <category>accessing</category><body package="COASTMediator">requestId	^CoastConstant recoverToVolumeID.</body></methods><methods><class-id>COAST.CMRecoverToVolumeRequest</class-id> <category>actions</category><body package="COASTMediator">basicPerformRequestAt: aSocketAccessor readStream: readStream 	self 		validPasswordFromStream: readStream		do: 		[: receiveStream | | backupVolume backupVersion targetVolume result message |			backupVolume := receiveStream nextCoastString.			backupVersion := receiveStream nextCoastString.			targetVolume := receiveStream nextCoastString.			result :=				[	targetVolume isValidVolumeString 						ifTrue: 						[ | backupDescription |							backupDescription := self descriptionForBackupVolume: backupVolume version: backupVersion.							CoastLog log: [ 'Recovering volume "' , backupDescription , '" to "' , targetVolume , '", client ', aSocketAccessor getPeer addressPrintString ] channel: #audit.							self volumeManager recoverToVolume: targetVolume fromVolume: backupVolume version: backupVersion.							message := 'Recovered volume "' , backupDescription , '" to "' , targetVolume , '"'.							CoastLog log: message.							CoastStatusResponse okCode: #volumeRecovered message: message						]						ifFalse: [ CoastStatusResponse failureCode: #invalidTargetVolume message: 'Invalid target volume: "' , targetVolume , '"' ]				] 					on: Error					do: 					[: ex |						CoastLog logException: ex message: 'Could not recover volume ' , backupVolume.						CoastStatusResponse failureCode: #couldNotRecoverVolume message: ex description					].			result		]		to: aSocketAccessor.</body></methods><methods><class-id>COAST.CatRMMessage</class-id> <category>execution</category><body package="COASTMediator">handlerForClusterManager: mediatorClusterManager	^ mediatorClusterManager clusterController 		at: self  receiver id 		ifAbsent: [			mediatorClusterManager statusError: 'Message for unknown cluster '				, self  receiver id printString.			nil 		].</body><body package="COASTMediator">safeInitiateFor: aMessageHandlerBlock 	self initiateFor: aMessageHandlerBlock value</body></methods><methods><class-id>COAST.CatRMVolumeSaveRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler		aMessageHandler handleVolumeSaveRequest: self</body></methods><methods><class-id>Core.Set</class-id> <category>accessing</category><body package="COASTMediator">asCoastRPCResult	^ ( self notEmpty and: [ self allSatisfy: [: e | e isCoastFrame ]]) 		ifTrue: 		[( COAST.CompactSet clusterManager: self anyElement clusterManager )				addAll: self;				yourself		]		ifFalse: [ self ]</body></methods><methods><class-id>COAST.CatRMLastWishMessage</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleLastWishMessage: self</body></methods><methods><class-id>COAST.CatRMConnectionsRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleConnectionsRequest: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="COASTMediator">asCoastRPCResult	^ self</body></methods><methods><class-id>COAST.CatRMRPCRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler 	aMessageHandler handleRPCRequest: self</body></methods><methods><class-id>COAST.CoastIndexSegment</class-id> <category>accessing</category><body package="COASTMediator">rpcIndexOfKey: key value: value 	^ ( self at: #compactCollection ) insertionIndexOf: key -&gt; value</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="COASTMediator">asCoastRPCResult	^ ( self notEmpty and: [ self allSatisfy: [: e | e isCoastFrame ]]) 		ifTrue: 		[( COAST.CompactRPCResultCollection clusterManager: self anyElement clusterManager )				addAll: self;				yourself		]		ifFalse: [ self ]</body></methods><methods><class-id>COAST.CatRMAliveMessage</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleAliveMessage: self</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>accessing</category><body package="COASTMediator">replaceSlotWriteAccess: originalAccess with: replacementAccessOrNil 	replacementAccessOrNil notNil 		ifTrue: [ slotWriteAccesses replaceAll: originalAccess with: replacementAccessOrNil ]		ifFalse: [ slotWriteAccesses := slotWriteAccesses reject: [: access | access = originalAccess ]].</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>accessing</category><body package="COASTMediator">gcEnabled	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>private</category><body package="COASTMediator">useGCKey	^ 'useGarbageCollection'</body></methods><methods><class-id>COAST.CatRMClusterCreateRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleClusterCreateRequest: self</body></methods><methods><class-id>COAST.CatRMClusterReleaseMessage</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleClusterReleaseMessage: self</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="COASTMediator">asCoastRPCResult	^ self</body></methods><methods><class-id>COAST.CatRMApplicationLogMessage</class-id> <category>execution</category><body package="COASTMediator">handlerForClusterManager: mediatorClusterManager	^ mediatorClusterManager</body><body package="COASTMediator">initiateFor: meditatorClusterManager	meditatorClusterManager handleApplicationLogMessage: self</body></methods><methods><class-id>COAST.CatRMRequestMessage</class-id> <category>execution</category><body package="COASTMediator">safeInitiateFor: aMessageHandlerBlock 	[self initiateFor: aMessageHandlerBlock value] on: Error		do: 			[:ex |			self receiverPacketStation 				transmitMessage: (CatRMErrorMessage description: ex description).			ex pass]</body></methods><methods><class-id>COAST.CatRMMultiPartUpdateMessage</class-id> <category>accessing</category><body package="COASTMediator">allSortedTransactionIDs: aCollectionOfTransactionIDs 	" sort to guarantee that the 'first' ID is deterministic "	allTransactionIDs := aCollectionOfTransactionIDs</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>converting</category><body package="COASTMediator">asCoastRPCResult	^ self</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>accessing</category><body package="COASTMediator">resolveFrameReference: aCatFSFrameReference 	"do not resolve frame refs by default"	^ aCatFSFrameReference</body><body package="COASTMediator">resolveFrameReferenceCursor: frameReference 	^ frameReference copy</body></methods><methods><class-id>COAST.CatRMTestAndSetRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler 	| result |	result := aMessageHandler testAndSet: keyFrame oldValue: oldValue newValue: newValue.	self receiverPacketStation transmitMessage: ( CatRMTestAndSetResultMessage result: result volume: volume ).</body></methods><methods><class-id>COAST.CatRMTryAndTell</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler 	[ aMessageHandler handleTryAndTellMessage: self ] on: Error		do: 		[: ex | | clusterManager |			clusterManager := aMessageHandler clusterManager.			clusterManager clusterController 				do: [: e | e modified: false	"be *very* sure nothing will be saved" ].			CoastLog logException: ex message: 'bug in TryAndTell'.			CoastLog log: 'Fatal Error -&gt; emergency shutdown'.			clusterManager emergencyShutDown 		]</body></methods><methods><class-id>COAST.CoastSegmentedIndex</class-id> <category>accessing</category><body package="COASTMediator">rpcAtIndex: elementIndex 	| assoc |	assoc := self atIndex: elementIndex.	^ assoc notNil 		ifTrue: [ Array with: assoc key with: assoc value ]		ifFalse: [ assoc ]</body><body package="COASTMediator">rpcIndexOfKey: key value: value 	| size segment indexOfSegment indexOfElement |	size := self numberOfSegments.	size = 0 ifTrue: [ ^ nil ].	indexOfSegment := self segmentIndexForKey: key value: value min: 1 max: size.	segment := self segmentAtIndex: indexOfSegment.	indexOfElement := segment rpcIndexOfKey: key value: value.	1 to: indexOfSegment - 1 do: [: segInx | indexOfElement := indexOfElement + ( self at: #sizes atIndex: segInx )].	^ indexOfElement</body></methods><methods><class-id>COAST.CatRMVolumeIDRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleVolumeIDRequest: self</body></methods><methods><class-id>COAST.CatRMFileUploadRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleFileUploadRequest: self</body><body package="COASTMediator">safeInitiateFor: aMessageHandlerBlock 	[self initiateFor: aMessageHandlerBlock value] on: Error		do: 			[:ex | 			self receiverPacketStation 				transmitMessage: (CatRMErrorMessage description: ex description).			ex pass]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="COASTMediator">asCoastRPCResult	| valueIsFrame result |	self isEmpty ifTrue: [ ^ self ].	result := nil.	valueIsFrame := nil.	self keysAndValuesDo: 		[: k : v |			k isCoastFrame ifFalse: [ ^ self ].			result isNil 				ifTrue: 				[	result := (( valueIsFrame := v isCoastFrame ) 							ifTrue: [ COAST.CompactDictionary ]							ifFalse: [ COAST.CompactKeyDictionary ]) clusterManager: k clusterManager				]				ifFalse: [ valueIsFrame = v isCoastFrame ifFalse: [ ^ self ]].			result at: k put: v		].	^ result</body></methods><methods><class-id>COAST.CatRMTryMessage</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	COAST.CoastLog logDebug: [ 'try ', self loggedTransactionAgenda transactionID printString ].	aMessageHandler handleTryMessage: self</body></methods><methods><class-id>COAST.CatRMClusterRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleClusterRequest: self</body></methods><methods><class-id>COAST.CatRMFileDownloadRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleFileDownloadRequest: self</body></methods><methods><class-id>COAST.CatFSFrameReference</class-id> <category>empty frame creation</category><body package="COASTMediator">createMediatorFrameForClusterManager: aClusterManager	| frame |	frame := CatRMMediatorFrame newWithFrameClassName: self frameClassSymbol.	frame id: self frameID.	^frame</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>accessing</category><body package="COASTMediator">gcEnabled	^ self volumeIniAccess booleanAt: self useGCKey ifAbsent: true</body></methods><methods><class-id>COAST.CatRMVolumesRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleVolumesRequest: self</body></methods><methods><class-id>COAST.CatRMInterruptMessage</class-id> <category>execution</category><body package="COASTMediator">handlerForClusterManager: mediatorClusterManager	^ mediatorClusterManager</body><body package="COASTMediator">initiateFor: aMessageHandler	^ aMessageHandler broadcastInterrupt: self</body></methods><methods><class-id>COAST.CatRMIndexDownloadRequest</class-id> <category>execution</category><body package="COASTMediator">initiateFor: aMessageHandler	aMessageHandler handleIndexDownloadRequest: self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CatRMMessage</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMRequestMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiverPacketStation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMClusterRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterLocator modificationNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMRPCRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume selector arguments recipientFrameLocator slotName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMTryMessage</name><environment>COAST</environment><super>COAST.CatRMMessageWithAgenda</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applicationLog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMFileUploadRequest</name><environment>COAST</environment><super>COAST.CatRMFileTransfer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume receiverPacketStation bytes fileID sourceStream uploadSucceeded </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatCSStorageAccessor</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumeAccessor applicationLoggers volume volumeLockInfoString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatRMClusterReleaseMessage</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterLocator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMIndexDownloadRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMSimpleAgenda</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameCreations frameRemoves slotCreations slotRemoves unpreparedReadAccesses slotWriteAccesses slotReadAccesses clusterLocator cluster slotAccessList isPrepared </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>CatCSClusterController</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cluster clusterID modified changeCount clusterManager lastSaveTime byteArrayFilename oldStyleFrameDetected </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatRMVolumeSaveRequest</name><environment>COAST</environment><super>COAST.CatRMVolumeAdministrationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMApplicationLogMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applicationLog volume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMVolumeIDRequest</name><environment>COAST</environment><super>COAST.CatRMVolumeAdministrationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CompactCollection</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>addedFrames removedFrames clusterManager frameIDs clusterIDs classIndices frameClassArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSVolumeManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManagers volumeInterface exclusiveLock currentLoadedClusterID packetStations autoSaveTimeInterval maxModifiedClusters segmentSplitSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatRMPacketStation</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sendQueue sendProcess receiveProcess sendStream receiveStream socketAccessor connected volumeManager trySendMessage lastSendID lastReceiveID isInShutdown ipAdressString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSClusterManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterController autoSaveInterval volume volumeManager volumeID storageInterface autosaveTime lastSaveTime frameClassIndex nextClusterID tempBytesPool classNameManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatRMConnectionsRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>CatRMFileDownloadRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileID volume targetFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMMultiPartUpdateMessage</name><environment>COAST</environment><super>COAST.CatRMUpdateMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>allTransactionIDs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMTestAndSetRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume keyFrame oldValue newValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMLastWishMessage</name><environment>COAST</environment><super>COAST.CatRMTryMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMClusterCreateRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CatRMVolumesRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CoastIndexSegment</name><environment>COAST</environment><super>COAST.CoastCollectionSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatRMInterruptMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume data target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMAliveMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>globalSeqNum clientID receiver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CoastApplicationConfiguration</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iniAccess infoString infoDict defaultLogFilename logFilename needsIni serviceName serviceAction winService iniFilename defaultIniFilename maxMemory preConfigurationBlocks parentConfiguration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class><class><name>CatCSFileStorageAccessor</name><environment>COAST</environment><super>COAST.CatCSAbstractDiskStorageAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileLock workingDirectory filesPerSubDir lastFilename lastID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastSegmentedIndex</name><environment>COAST</environment><super>COAST.CoastSegmentedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>ClassNameManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultNameSpaces class2nameDict name2classDict </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COBase</package></attributes></class><class><name>CoastApplication</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration winService startAction subApplications </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class><class><name>CatRMTryAndTell</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loggedTransactionAgendas applicationLog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSTransaction</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context rolledBack composedCells composedCellsLock inDisplayPhase outstandingCompositions combinedAgenda endDemons postDemons failureBlocks inInvalidationPhase ownerProcess transactionManager isFastRead oldValuesDict commitBlocks endBlocks applicationLog delegationContexts invalidationSuppressed delayedCompositions postViewUpdateBlocks failureReason </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatFSFrameReference</name><environment>COAST</environment><super>COAST.CatCSFrameLocator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClassOrSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class></st-source>