<?xml version="1.0"?><st-source><!-- Name: COASTEditorsNotice: The MIT LicenseCopyright (c) 2013 intelligent views GmbHPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DevelopmentPrerequisites: #(#(#any 'COASTViews' '') #(#any 'COASTClient' '') #(#any 'COASTCore' ''))KSignature: #('definedClasses' 26 'definedClassesHash' 30128524922 'extendedClasses' 2 'extendedClassesHash' 842738176)KSignatureV2: #('definedClasses' 26 'definedClassesHash' 818801496420931228157127959277739402736918401683 'extendedClasses' 2 'extendedClassesHash' 143395738038856873750437792744034453875752908421)PackageName: COASTEditorsPackageName:: COASTEditorsPackageVersion: (4.4.1,scholz)Parcel: #('COASTEditors')ParcelDirectory: COASTEditorsPrerequisiteDescriptions: #(#(#name 'COASTViews') #(#name 'COASTClient' #componentType #package) #(#name 'COASTCore' #componentType #bundle))PrerequisiteParcels: #(#('COASTViews' '') #('COASTClient' '') #('COASTCore' ''))Version: 5.4.14 - VW8.0 - 2Post-Load Block: 	[:pkg | ]Date: 1:47:51 PM July 26, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jul14.3) of 25. Juli 2014 on 26. Juli 2014 at 13:47:51</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CoastWidgetModel</name><environment>COAST</environment><super>COAST.CatFSVirtualFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastSimpleEditor</name><environment>COAST</environment><super>COAST.CatFSVirtualFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastWidget</name><environment>COAST</environment><super>COAST.CoastView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>widgetState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastLabeledListView</name><environment>COAST</environment><super>COAST.ListView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastButtonController</name><environment>COAST</environment><super>COAST.CoastController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastComputedEditorList</name><environment>COAST</environment><super>COAST.CatFSVirtualFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastTextWidgetController</name><environment>COAST</environment><super>UI.TextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastSimpleEditorView</name><environment>COAST</environment><super>COAST.CoastCompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastInputBoxController</name><environment>COAST</environment><super>UI.InputFieldController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastUserListWidget</name><environment>COAST</environment><super>COAST.CoastLocalApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastStringWidgetModel</name><environment>COAST</environment><super>COAST.CoastWidgetModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastBooleanEditor</name><environment>COAST</environment><super>COAST.CoastSimpleEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastStringEditor</name><environment>COAST</environment><super>COAST.CoastSimpleEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastButtonWidget</name><environment>COAST</environment><super>COAST.CoastWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastButtonWidgetModel</name><environment>COAST</environment><super>COAST.CoastWidgetModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastStringWidget</name><environment>COAST</environment><super>COAST.CoastWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastSimpleEditorListView</name><environment>COAST</environment><super>COAST.CoastLabeledListView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastDragHandleController</name><environment>COAST</environment><super>COAST.CoastButtonController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastChoiceEditor</name><environment>COAST</environment><super>COAST.CoastSimpleEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastCheckBoxWidget</name><environment>COAST</environment><super>COAST.CoastWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastCheckBoxWidgetModel</name><environment>COAST</environment><super>COAST.CoastWidgetModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastDragHandleWidget</name><environment>COAST</environment><super>COAST.CoastButtonWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastDragHandleWidgetModel</name><environment>COAST</environment><super>COAST.CoastButtonWidgetModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastInputFieldWidget</name><environment>COAST</environment><super>COAST.CoastStringWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastTextWidget</name><environment>COAST</environment><super>COAST.CoastStringWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scrollOffset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><class><name>CoastInputFieldWidgetModel</name><environment>COAST</environment><super>COAST.CoastStringWidgetModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTEditors</category><attributes><package>COASTEditors</package></attributes></class><shared-variable><name>InsertionPoint</name><environment>COAST.CoastStringWidget</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>COASTEditors</package></attributes></shared-variable><methods><class-id>COAST.CoastUserListWidget class</class-id> <category>resources</category><body package="COASTEditors">menu	"MenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'inspect user' 				#value: #inspectUser ) 			#(#{UI.MenuItem} 				#rawLabel: 'add user...' 				#value: #addUser ) 			#(#{UI.MenuItem} 				#rawLabel: 'remove user' 				#value: #removeUser ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>COAST.CoastUserListWidget class</class-id> <category>interface specs</category><body package="COASTEditors">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 904 676 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{COAST.CoastSequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragEnterSelector 						#dropOver: #dragStartSelector 						#dragStart: #dragOkSelector 						#dragOK: #dropSelector 						#dropTarget: #dragOverSelector 						#dropOver: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#flags: 5 					#model: #list 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #doubleClickAction ) 					#tabable: false 					#menu: #menu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>COAST.CoastWidgetModel</class-id> <category>accessing</category><body package="COASTEditors">minSize	^ nil</body></methods><methods><class-id>COAST.CoastSimpleEditor</class-id> <category>accessing</category><body package="COASTEditors">additionalWidgetOffset	^self at: #additionalWidgetOffset</body><body package="COASTEditors">defaultViewClass	^CoastSimpleEditorView</body><body package="COASTEditors">label	^(self at: #labelBlock) value</body><body package="COASTEditors">readBlock	^ self at: #readBlock</body><body package="COASTEditors">readBlock: aBlock	self at: #readBlock set: aBlock</body><body package="COASTEditors">value	^(self at: #newValue) ifNil: [ (self at: #readBlock) value ]</body><body package="COASTEditors">value: aValue	(self at: #deferWrite)		ifTrue: [ self at: #newValue set: aValue ]		ifFalse: [ (self at: #writeBlock) value: aValue ]</body><body package="COASTEditors">writeBack	self transactionDo:	[		(self at: #deferWrite)			ifTrue: [ | newVal | newVal := self at: #newValue. newVal notNil ifTrue: [ (self at: #writeBlock) value: newVal ] ]	].</body><body package="COASTEditors">writeBlock	^ self at: #writeBlock</body><body package="COASTEditors">writeBlock: aBlock	self at: #writeBlock set: aBlock</body></methods><methods><class-id>COAST.CoastSimpleEditor</class-id> <category>private</category><body package="COASTEditors">newValue	^self at: #newValue</body></methods><methods><class-id>COAST.CoastSimpleEditor class</class-id> <category>slot description</category><body package="COASTEditors">additionalWidgetOffsetSlot	^self slotSingleValue		defaultValue: 0</body><body package="COASTEditors">deferWriteSlot	^self slotSingleValue</body><body package="COASTEditors">labelBlockSlot	^self slotSingleValue</body><body package="COASTEditors">newValueSlot	^self slotSingleValue</body><body package="COASTEditors">readBlockSlot	^self slotSingleValue</body><body package="COASTEditors">writeBlockSlot	^self slotSingleValue</body></methods><methods><class-id>COAST.CoastSimpleEditor class</class-id> <category>instance creation</category><body package="COASTEditors">labelAccessBlock: labelBlock valueReadBlock: readBlock valueWriteBlock: writeBlock deferWrite: aBoolean	^self labelAccessBlock: labelBlock valueReadBlock: readBlock valueWriteBlock: writeBlock deferWrite: aBoolean additionalWidgetOffset: 0</body><body package="COASTEditors">labelAccessBlock: labelBlock valueReadBlock: readBlock valueWriteBlock: writeBlock deferWrite: aBoolean additionalWidgetOffset: anInteger	^self new		at: #labelBlock set: labelBlock;		at: #readBlock set: readBlock;		at: #writeBlock set: writeBlock;		at: #deferWrite set: aBoolean;		at: #additionalWidgetOffset set: anInteger;		yourself</body></methods><methods><class-id>COAST.CoastWidget</class-id> <category>private</category><body package="COASTEditors">backgroundColor	^self isEnabled		ifTrue:	[self specificBackgroundColor]		ifFalse:	[self specificInactiveBackgroundColor]</body><body package="COASTEditors">displayBackgroundIfNeededOn: aGraphicsContext	self displayBackgroundIfNeededOn: aGraphicsContext in: self clippingBox</body><body package="COASTEditors">displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle	(self widgetState isOpaque or: [self widgetState hasBackgroundColor]) ifFalse: [^self].	self displayBackgroundOn: aGraphicsContext in: aRectangle</body><body package="COASTEditors">displayBackgroundOn: aGraphicsContext in: aRectangle 	"Display the background of the receiver on aGraphicsContext in aRectangle."	aGraphicsContext copy		paint: self backgroundColor;		displayRectangle: aRectangle.</body><body package="COASTEditors">setForegroundPaintOn: aGraphicsContext	"Set the foreground color for the display of the receiver's label."	aGraphicsContext paint: self foregroundColor</body><body package="COASTEditors">specificBackgroundColor	"Answer the receiver's widget-specific background color."	^SymbolicPaint background</body><body package="COASTEditors">specificInactiveBackgroundColor	"Answer the receiver's widget-specific inactive background color."	^SymbolicPaint inactiveBackground</body></methods><methods><class-id>COAST.CoastWidget</class-id> <category>accessing</category><body package="COASTEditors">bounds: aRectangle 	self transactionManager bestIndependentDisplayDo: [ self widgetBounds: ( 0 @ 0 extent: aRectangle extent )].	super bounds: aRectangle.</body><body package="COASTEditors">helpText	^ self at: #helpText</body><body package="COASTEditors">helpText: aString 	aString = ( self fastAt: #helpText ) ifFalse: [ self at: #helpText set: aString ]</body><body package="COASTEditors">isEnabled	^ self widgetState isEnabled and: [ self parent isEnabled ]</body><body package="COASTEditors">widgetBounds	^ self at: #widgetBounds</body><body package="COASTEditors">widgetBounds: aRectangle	self at: #widgetBounds set: aRectangle</body><body package="COASTEditors">widgetState	^ widgetState</body></methods><methods><class-id>COAST.CoastWidget</class-id> <category>initialize-release</category><body package="COASTEditors">initialize	super initialize.	" temp hack - please COASTifiy the widget state... "	widgetState := WidgetState new.</body></methods><methods><class-id>COAST.CoastWidget</class-id> <category>focus accessing</category><body package="COASTEditors">desiresFocus	^ self isEnabled</body><body package="COASTEditors">takeFocusWithEvent: aCharEvent	self controller activate</body></methods><methods><class-id>COAST.CoastWidget class</class-id> <category>slots</category><body package="COASTEditors">helpTextSlot	^ self slotSingleValue		range: CharacterArray</body><body package="COASTEditors">widgetBoundsSlot	^self slotSingleValue defaultValue: (0@0 extent: 0@0)</body></methods><methods><class-id>COAST.CoastLabeledListView</class-id> <category>computing</category><body package="COASTEditors">computeLabelWidth	^ self components inject: 0 into: [ :width :wrapper | | w |		(w := wrapper component requiredLabelWidth) notNil			ifTrue: [ w max: width ]			ifFalse: [ width ] ].</body></methods><methods><class-id>COAST.CoastLabeledListView</class-id> <category>private</category><body package="COASTEditors">labelWidth	^ self at: #labelWidth</body></methods><methods><class-id>COAST.CoastLabeledListView</class-id> <category>accessing</category><body package="COASTEditors">requiredLabelWidth	^ self labelWidth</body><body package="COASTEditors">width	^self at: #width</body></methods><methods><class-id>COAST.CoastLabeledListView class</class-id> <category>slots</category><body package="COASTEditors">labelWidthSlot	^ (self slotComputedEagerBy: [ :view | view computeLabelWidth ])</body><body package="COASTEditors">widthSlot	^self slotComputedBy: [:view | view computeWidth ].</body></methods><methods><class-id>COAST.CoastButtonController</class-id> <category>private tracker</category><body package="COASTEditors">mouseMoveJob: event	self transactionManager displayDo:	[		(self view containsPoint: (self cursorPointFor: event))			ifTrue: [ view hasCursor: true ]			ifFalse: [ view hasCursor: false ]	].</body><body package="COASTEditors">redButtonPressedJob: event	self transactionManager displayDo: [ view inTransition: true ].</body><body package="COASTEditors">redButtonReleasedJob: event	self transactionManager displayDo: [ view inTransition: false ].	(self view containsPoint: (self cursorPointFor: event))		ifTrue: [ self view buttonPress ].</body></methods><methods><class-id>COAST.CoastButtonController</class-id> <category>events</category><body package="COASTEditors">enterEvent: event	self transactionManager displayDo: [ view hasCursor: true ].	^super enterEvent: event</body><body package="COASTEditors">redButtonPressedEvent: event 	| tracker |	tracker := CoastConfigurableTracker on: self.	tracker		redButtonPressedJob: [: anEvent | self redButtonPressedJob: anEvent ];		mouseMovedJob: [: anEvent | self mouseMoveJob: anEvent ];		redButtonReleasedJob: [: anEvent | self redButtonReleasedJob: anEvent ];		exitJob: [: anEvent | self exitEvent: anEvent ].	self installTracker: tracker.	tracker handleEvent: event.</body></methods><methods><class-id>COAST.CoastButtonController</class-id> <category>event driven</category><body package="COASTEditors">exitEvent: anEvent 	self transactionManager displayDo: [ view hasCursor: false ].	^ super exitEvent: anEvent</body></methods><methods><class-id>COAST.CoastComputedEditorList</class-id> <category>accessing</category><body package="COASTEditors">components	^self at: #components</body></methods><methods><class-id>COAST.CoastComputedEditorList</class-id> <category>computing</category><body package="COASTEditors">computeComponents	^(self at: #componentsComputingBlock) value</body></methods><methods><class-id>COAST.CoastComputedEditorList class</class-id> <category>instance creation</category><body package="COASTEditors">componentsComputingBlock: aBlock	^self new at: #componentsComputingBlock set: aBlock; yourself</body></methods><methods><class-id>COAST.CoastComputedEditorList class</class-id> <category>slots</category><body package="COASTEditors">componentsComputingBlockSlot	^self slotSingleValue</body><body package="COASTEditors">componentsSlot	^self slotComputedBy: #computeComponents</body></methods><methods><class-id>COAST.CoastTextWidgetController</class-id> <category>event driven</category><body package="COASTEditors">cursorPointFor: anEvent	^ self view globalPointToLocal: anEvent point</body><body package="COASTEditors">updateSelectionWith: currentBlock usingPivot: pivotBlock on: aGraphicsContext 	currentBlock stringIndex &lt;= pivotBlock stringIndex		ifTrue: [ self view startBlock: currentBlock stopBlock: pivotBlock ]		ifFalse: [ self view startBlock: pivotBlock stopBlock: currentBlock ]</body><body package="COASTEditors">viewHasCursorWithEvent: event 	"Answer true if the cursor point of the receiver's sensor lies within 	the display box of the receiver's view. "	view == nil ifTrue: [^false].	event hasPoint ifFalse: [^false].	view bounds isNil ifTrue: [ ^false ].	^view bounds containsPoint: (self sensor mousePointForEvent: event)</body></methods><methods><class-id>COAST.CoastTextWidgetController</class-id> <category>accessing</category><body package="COASTEditors">model	^self view notNil		ifTrue: [self view model]		ifFalse: [super model]</body><body package="COASTEditors">selectionStartIndex	^view selectionStartIndex</body><body package="COASTEditors">selectionStopIndex	^view selectionStopIndex</body></methods><methods><class-id>COAST.CoastTextWidgetController</class-id> <category>private</category><body package="COASTEditors">replaceFrom: start to: stop with: aText	" also update the markup text "	self view replaceTextFrom: start to: stop with: aText.</body><body package="COASTEditors">replaceSelectionWith: aText saveSelectionForUndo: aBoolean	| start stop |	readOnly ifTrue: [^self].	self view transactionManager transactionDo: [		accepted := false.		start := self selectionStartIndex.		stop := self selectionStopIndex - 1.		aBoolean ifTrue: [self undoSelection: self selection].		self			replaceFrom: start			to: stop			with: aText.		self view basicSelectionStartIndex: start stopIndex: start + aText size.		continuousAccept ifTrue: [self accept].	].</body></methods><methods><class-id>COAST.CoastTextWidgetController</class-id> <category>transactions</category><body package="COASTEditors">transactionDo: aBlock	^ self model transactionDo: aBlock</body><body package="COASTEditors">transactionManager	^ self model transactionManager</body></methods><methods><class-id>COAST.CoastSimpleEditorView</class-id> <category>computing</category><body package="COASTEditors">composeComponents	| components |	self transactionManager withoutDependenciesDo: 		[	components := OrderedCollection 					with: ( oldComponentDictionary at: #widget ifAbsentPut: [ ComposedTranslatingWrapper in: self on: self widget computedBy: [ self widgetTranslation ]]).			self label ifNotNil: 				[: label |					components add: ( oldComponentDictionary at: #label								ifAbsentPut: 								[( TranslatingWrapper on: label at: self labelTranslation )										container: self;										yourself								])				]		].	self transactionManager activeTransaction 		ifNotNil: [: transaction | transaction addFailureBlock: [ oldComponentDictionary := oldComponentDictionary species new ]].	^ components</body><body package="COASTEditors">computeHeight	| height components |	height := self labelBounds height.	(components := self components) notNil		ifTrue: [ components do: [ :c |			height isNil				ifTrue: [ height := c height ]				ifFalse: [ height := height max: c height ]]].	^ height</body><body package="COASTEditors">computeLabel	^ self model label ifNotNil: [: label | label asText asComposedText ]</body><body package="COASTEditors">computeLabelBounds	^0@0 corner: (self labelWidth @ self labelHeight)</body><body package="COASTEditors">computeLabelWidth	| label layoutWidth |	label := self label.	^ label notNil 		ifTrue: 		[	layoutWidth := self labelWidthComputingBlock value: label.			layoutWidth max: label width		]		ifFalse: [ 0 ]</body><body package="COASTEditors">computePreferredBounds	^(0@0) corner: (self width @ self height)</body><body package="COASTEditors">computeWidget	^ self model defaultWidgetClass model: self model in: self</body><body package="COASTEditors">computeWidth	| components |	^ (components := self components) notNil 		ifTrue: [ 			components inject: 0 into: [ :width :c | 				width max: (self computeWidthFor: c).			].		]		ifFalse: [ 0 ]</body><body package="COASTEditors">computeWidthFor: aComponent	^ aComponent width + aComponent translation x.</body></methods><methods><class-id>COAST.CoastSimpleEditorView</class-id> <category>accessing</category><body package="COASTEditors">height	^self at: #height</body><body package="COASTEditors">label	^self at: #label</body><body package="COASTEditors">labelBounds	^self at: #labelBounds</body><body package="COASTEditors">labelHeight	| l |	^(l := self label) notNil		ifTrue: [ l height ]		ifFalse: [ 0 ].</body><body package="COASTEditors">labelWidth	^self at: #labelWidth</body><body package="COASTEditors">labelWidthComputingBlock	^self at: #labelWidthComputingBlock</body><body package="COASTEditors">labelWidthComputingBlock: aBlock	self at: #labelWidthComputingBlock set: aBlock</body><body package="COASTEditors">requiredLabelWidth	" returns the width required for my label for layout, or nil if I don't care "	^ self label ifNotNil: [: label | label width ]</body><body package="COASTEditors">widget	^self at: #widget</body><body package="COASTEditors">widgetTranslation	^ (self labelWidth + 5 + self model additionalWidgetOffset) @ self widgetYOffset</body><body package="COASTEditors">width	^self at: #width</body></methods><methods><class-id>COAST.CoastSimpleEditorView</class-id> <category>private</category><body package="COASTEditors">labelTranslation	^ 2@0</body><body package="COASTEditors">widgetYOffset	^0</body></methods><methods><class-id>COAST.CoastSimpleEditorView</class-id> <category>focus accessing</category><body package="COASTEditors">takeFocusWithEvent: aCharEvent	self widget takeFocusWithEvent: aCharEvent</body></methods><methods><class-id>COAST.CoastSimpleEditorView class</class-id> <category>slots</category><body package="COASTEditors">heightSlot	^self slotComputedBy: #computeHeight</body><body package="COASTEditors">labelBoundsSlot	^self slotComputedBy: #computeLabelBounds</body><body package="COASTEditors">labelSlot	^self slotComputedBy: #computeLabel</body><body package="COASTEditors">labelWidthComputingBlockSlot	^self slotSingleValue		defaultValue: [ :labelText | labelText width ];		yourself</body><body package="COASTEditors">labelWidthSlot	^self slotComputedBy: #computeLabelWidth</body><body package="COASTEditors">widgetSlot	^self slotComputedBy: #computeWidget</body><body package="COASTEditors">widthSlot	^self slotComputedBy: #computeWidth</body></methods><methods><class-id>COAST.CoastInputBoxController</class-id> <category>editing</category><body package="COASTEditors">cursorDownKey: aCharEvent	"pass the focus to the next view below me if possible"	self view passFocusDownWithEvent: aCharEvent fromView: self view</body><body package="COASTEditors">cursorUpKey: aCharEvent	"pass the focus to the next view above me if possible"	self view passFocusUpWithEvent: aCharEvent fromView: self view</body><body package="COASTEditors">processTabKey: aCharEvent 	"The user has typed a &lt;tab&gt;. 	Carry out the action defined by tabBlock."	"For some strange reason, we saw this method called with no 	keyboardProcessor present. In this case, just ignore the event."	^self keyboardProcessor isNil		ifTrue: [nil]		ifFalse: [super processTabKey: aCharEvent]</body></methods><methods><class-id>COAST.CoastInputBoxController</class-id> <category>event driven</category><body package="COASTEditors">trackSelectionFrom: currentBlock to: newPoint pivotBlock: pivotBlock showingCaret: aBoolean 	" copied from TextEditorController, removed all display stuff "	| showingCaret gc  pt delta nextBlock |	showingCaret := aBoolean.	gc := view graphicsContext.	pt := newPoint.	(delta := self deltaForPoint: pt) ~= Point zero		ifTrue: 			[delta y = 0 ifFalse: [delta y abs &lt; view lineGrid					ifTrue: [delta y: delta y sign * view lineGrid]					ifFalse: [delta y: (delta y truncateTo: view lineGrid)]].			view scrollBy: delta negated.			gc translateBy: delta negated.			delta y &lt; 0				ifTrue: [pt y: view bounds top]				ifFalse: [delta y &gt; 0 ifTrue: [pt y: view bounds bottom]].			delta x &lt; 0				ifTrue: [pt x: view bounds left]				ifFalse: [delta x &gt; 0 ifTrue: [pt x: view bounds right]].			self checkForEvents].	nextBlock := view characterBlockAtPoint: pt.	nextBlock = currentBlock		ifFalse: 			[			showingCaret				ifTrue: 					[view hideInsertionPointFor: pivotBlock on: gc copy.					showingCaret := false].			self				updateSelectionWith: nextBlock				usingPivot: pivotBlock				on: gc copy.	].	^showingCaret</body></methods><methods><class-id>COAST.CoastInputBoxController</class-id> <category>private</category><body package="COASTEditors">replaceFrom: start to: stop with: aText	"Replace the receiver's text starting at position start, stopping at stop, 	by the characters in aText."	self textHasChanged: true.	self view transactionManager transactionDo:	[		self view replaceTextFrom: start to: stop with: aText.	].</body><body package="COASTEditors">replaceSelectionWith: aText saveSelectionForUndo: aBoolean	| start stop |	readOnly ifTrue: [^self].	accepted := false.	start := self selectionStartIndex.	stop := self selectionStopIndex - 1.	aBoolean ifTrue: [self undoSelection: self selection].	self		replaceFrom: start		to: stop		with: aText.	self selectionStartIndex: start stopIndex: start + aText size.	continuousAccept ifTrue: [self accept].</body><body package="COASTEditors">updateSelectionWith: currentBlock usingPivot: pivotBlock on: aGraphicsContext 	currentBlock stringIndex &lt;= pivotBlock stringIndex		ifTrue: [ self view startBlock: currentBlock stopBlock: pivotBlock ]		ifFalse: [ self view startBlock: pivotBlock stopBlock: currentBlock ]</body></methods><methods><class-id>COAST.CoastUserListWidget</class-id> <category>accessing</category><body package="COASTEditors">acceptDrop	^self at: #acceptDrop</body><body package="COASTEditors">acceptDrop: boolean	^self at: #acceptDrop set: boolean</body><body package="COASTEditors">addUserActionBlock: aBlock	self at: #addUserActionBlock set: aBlock</body><body package="COASTEditors">doubelClickActionBlock: aBlock	self at: #doubleClickActionBlock set: aBlock</body><body package="COASTEditors">removeUserActionBlock: aBlock	self at: #removeUserActionBlock set: aBlock</body><body package="COASTEditors">selectedUsers	^self at: #selectedUsers</body><body package="COASTEditors">showInactiveUser	^(self at: #showInactiveUser) == true</body><body package="COASTEditors">showInactiveUser: boolean	^self at: #showInactiveUser set: boolean</body><body package="COASTEditors">userList	^self at: #userList</body></methods><methods><class-id>COAST.CoastUserListWidget</class-id> <category>actions</category><body package="COASTEditors">addUser	| aBlock users |	self displayDo: [aBlock := self at: #addUserActionBlock. users := self at: #selectedUsers].	aBlock isNil ifFalse: [aBlock value: users].</body><body package="COASTEditors">doubleClickAction	| aBlock users |	self displayDo: [aBlock := self at: #doubleClickActionBlock. users := self at: #selectedUsers].	aBlock isNil ifFalse: [aBlock value: users].</body><body package="COASTEditors">inspectUser	(self displayDo: [self selectedUsers]) do: [: u | u inspect ]</body><body package="COASTEditors">removeUser	| aBlock users |	self displayDo: [aBlock := self at: #removeUserActionBlock. users := self at: #selectedUsers].	aBlock isNil ifFalse: [aBlock value: users].</body></methods><methods><class-id>COAST.CoastUserListWidget</class-id> <category>computing</category><body package="COASTEditors">computeSelectedUsers	| result userList |	result := OrderedCollection new.	userList := self at: #userList.	(self at: #listSelection) do: [: i | userList size &lt; i ifFalse: [result add: (userList at: i)]].	^result</body><body package="COASTEditors">computeUserList	| result |	result := self sharedApplicationModel notNil 			ifTrue: [ self sharedApplicationModel interestedUsers ]			ifFalse: [ self localUser clusterManager namedModels select: [: e | e isKindOf: CoastUser ]].	self showInactiveUser ifFalse: [ result := result select: [: u | u isActive ]].	^ result asSortedCollection: 		[: a : b |			a isActive = b isActive 				ifTrue: [ a name &lt; b name ]				ifFalse: [ a isActive ]		]</body><body package="COASTEditors">computeUserNameList	^((self at: #userList) collect: [: u | u name ]) asList</body></methods><methods><class-id>COAST.CoastUserListWidget</class-id> <category>drag drop</category><body package="COASTEditors">dragOK: aController 	| selectedUsers |	selectedUsers := self displayDo: [ self selectedUsers ].	^ ( selectedUsers isNil or: [ selectedUsers isEmpty ]) not</body><body package="COASTEditors">dragStart: aController 	| users data dropSource dragDropManager |	self displayDo: [ users := self selectedUsers ].	( users isNil or: [ users isEmpty ]) ifTrue: [ ^ nil ].	data := DragDropData new.	data key: #coastUsers.	data contextWindow: self builder window.	data contextWidget: aController view.	data contextApplication: self.	data clientData: IdentityDictionary new.	data clientData at: #model put: users.	dropSource := DropSource new.	dragDropManager := DragDropManager withDropSource: dropSource withData: data.	dragDropManager doDragDrop</body><body package="COASTEditors">dropOver: ddContext 	^(((self displayDo: [self acceptDrop])		and: [ddContext sourceData key = #coastUsers])		and: [| myUser |			myUser := self displayDo: [self userList].			(ddContext sourceData clientData at: #model) contains: [:u | (myUser includes: u) not]])		ifTrue: [#dropEffectCopy]		ifFalse: [#dropEffectNone]</body><body package="COASTEditors">dropTarget: ddContext 	| users |	(( self displayDo: [ self acceptDrop ]) and: [ ddContext sourceData key = #coastUsers ]) ifTrue: 		[	users := ddContext sourceData clientData at: #model.			self transactionDo: [ users do: [: user | self sharedApplicationModel openFor: user ]]		]</body></methods><methods><class-id>COAST.CoastUserListWidget</class-id> <category>aspects</category><body package="COASTEditors">list	"This method was generated by CatESDefiner.  Any edits made here	may be lost whenever methods are automatically defined. Do not	assign a value to the aspect here, instead initialize the shared	application model."	^list isNil		ifTrue:			[list := CoastMultiSelectionInList				accessListBlock: [ self at: #userNameList ]				accessSelectionBlock: [ self at: #listSelection ]				assignSelectionBlock: [ :newValue | self at: #listSelection set: newValue ]				application: self.]		ifFalse:			[list]</body></methods><methods><class-id>COAST.CoastUserListWidget class</class-id> <category>slots</category><body package="COASTEditors">acceptDropSlot	^self slotSingleValue		range: Boolean;		defaultValue: true;		yourself</body><body package="COASTEditors">addUserActionBlockSlot	^self slotSingleValue</body><body package="COASTEditors">doubleClickActionBlockSlot	^self slotSingleValue</body><body package="COASTEditors">listSelectionSlot	^self slotOfType: #set</body><body package="COASTEditors">removeUserActionBlockSlot	^self slotSingleValue</body><body package="COASTEditors">selectedUsersSlot	^self slotComputedBy: #computeSelectedUsers</body><body package="COASTEditors">showInactiveUserSlot	^self slotSingleValue		range: Boolean;		defaultValue: true;		yourself</body><body package="COASTEditors">userListSlot	^self slotComputedBy: #computeUserList</body><body package="COASTEditors">userNameListSlot	^self slotComputedBy: #computeUserNameList</body></methods><methods><class-id>COAST.CoastStringWidgetModel</class-id> <category>accessing</category><body package="COASTEditors">defaultViewClass	^CoastStringWidget</body><body package="COASTEditors">enabled: aBoolean	self at: #enabled set: aBoolean</body><body package="COASTEditors">isEnabled	^self at: #enabled</body><body package="COASTEditors">model	^self at: #model</body><body package="COASTEditors">model: aModel	self at: #model set: aModel</body><body package="COASTEditors">text	^self at: #text</body><body package="COASTEditors">text: aText	self at: #text set: aText</body><body package="COASTEditors">value	^self model isNil		ifTrue: [ self text ]		ifFalse: [ self model value ]</body><body package="COASTEditors">value: aText	self model isNil		ifTrue: [ self text: aText ]		ifFalse: [ self model value: aText asString ].</body><body package="COASTEditors">writeBack"do nothing, since all changes take effect immediately"</body></methods><methods><class-id>COAST.CoastStringWidgetModel class</class-id> <category>slots</category><body package="COASTEditors">enabledSlot	^self slotSingleValue		defaultValue: true;		yourself</body><body package="COASTEditors">modelSlot	^self slotSingleValue</body><body package="COASTEditors">textSlot	^self slotSingleValue</body></methods><methods><class-id>COAST.CoastStringWidgetModel class</class-id> <category>instance creation</category><body package="COASTEditors">model: aModel	^self new model: aModel; yourself</body><body package="COASTEditors">readOnlyText: aText 	^(self new) 		text: aText; 		enabled: false; 		yourself</body><body package="COASTEditors">text: aText	^self new text: aText; yourself</body></methods><methods><class-id>COAST.CoastBooleanEditor</class-id> <category>accessing</category><body package="COASTEditors">defaultWidgetClass	^CoastCheckBoxWidget</body><body package="COASTEditors">value: aValue	"my controller is no coast controller :-("	"need a transaction here"	self transactionDo:	[		(self at: #deferWrite)			ifTrue: [ self at: #newValue set: aValue ]			ifFalse: [ (self at: #writeBlock) value: aValue ]	].</body></methods><methods><class-id>COAST.CoastBooleanEditor</class-id> <category>testing</category><body package="COASTEditors">isEnabled	^true</body></methods><methods><class-id>COAST.CoastStringEditor</class-id> <category>accessing</category><body package="COASTEditors">defaultWidgetClass	^CoastInputFieldWidget</body></methods><methods><class-id>COAST.CoastStringEditor</class-id> <category>testing</category><body package="COASTEditors">isEnabled	^(self at: #writeBlock) notNil</body></methods><methods><class-id>COAST.CoastButtonWidget</class-id> <category>actions</category><body package="COASTEditors">buttonPress	| actionBlock |	actionBlock := self model buttonPressActionBlock.	actionBlock notNil ifTrue:	[		actionBlock value.	].</body></methods><methods><class-id>COAST.CoastButtonWidget</class-id> <category>controller accessing</category><body package="COASTEditors">defaultControllerClass	"Answer the class of the default controller for the receiver."	^CoastButtonController</body></methods><methods><class-id>COAST.CoastButtonWidget</class-id> <category>displaying</category><body package="COASTEditors">composeDisplayOn: aGraphicsContext 	"Display the receiver according to the current state of the model."	| pixmapPos gc |	pixmapPos := self borderWidth @ self borderWidth.	gc := aGraphicsContext copy.	gc paint: ColorValue black.	self hasCursor 		ifTrue: 		[				self inTransition 				ifTrue: 				[	self displayTransitionBorderOn: gc.					pixmapPos := pixmapPos + ( 1 @ 1 )				]				ifFalse: [ self displayBorderOn: gc ]		].	gc paint: ColorValue white.	self image displayOn: gc at: pixmapPos.</body><body package="COASTEditors">displayBorderOn: aGraphicsContext 	^ BeveledBorder raised displayOn: aGraphicsContext forDisplayBox: self bounds using: self</body><body package="COASTEditors">displayTransitionBorderOn: aGraphicsContext	"no border looks better"</body></methods><methods><class-id>COAST.CoastButtonWidget</class-id> <category>accessing</category><body package="COASTEditors">borderWidth	^ 2</body><body package="COASTEditors">hasCursor	^self at: #hasCursor</body><body package="COASTEditors">hasCursor: aBoolean	((self at: #hasCursor) ~= aBoolean) ifTrue:		[ self at: #hasCursor set: aBoolean ]</body><body package="COASTEditors">image	^self at: #image</body><body package="COASTEditors">inTransition	^self at: #inTransition</body><body package="COASTEditors">inTransition: aBoolean	((self at: #inTransition) ~= aBoolean) ifTrue:		[ self at: #inTransition set: aBoolean ]</body></methods><methods><class-id>COAST.CoastButtonWidget</class-id> <category>computing</category><body package="COASTEditors">computeImage	| imageOrText |	imageOrText := self model imageComputingBlock value.	^ ( imageOrText respondsTo: #asCachedImage ) 		ifTrue: [ imageOrText asCachedImage ]		ifFalse: [ imageOrText ]</body><body package="COASTEditors">computePreferredBounds	| int |	int := self borderWidth * 2.	^ self image bounds expandedBy: ( 0 @ 0 corner: int @ int )</body></methods><methods><class-id>COAST.CoastButtonWidget class</class-id> <category>slots</category><body package="COASTEditors">hasCursorSlot	^self slotSingleValue		defaultValue: false</body><body package="COASTEditors">imageSlot	^self slotComputedBy: #computeImage</body><body package="COASTEditors">inTransitionSlot	^self slotSingleValue		defaultValue: false</body></methods><methods><class-id>COAST.CoastButtonWidgetModel</class-id> <category>accessing</category><body package="COASTEditors">buttonPressActionBlock	^self at: #buttonPressActionBlock</body><body package="COASTEditors">buttonPressActionBlock: aBlock	self at: #buttonPressActionBlock set: aBlock</body><body package="COASTEditors">defaultViewClass	^CoastButtonWidget</body><body package="COASTEditors">imageComputingBlock	^self at: #imageComputingBlock</body><body package="COASTEditors">imageComputingBlock: aBlock	self at: #imageComputingBlock set: aBlock</body></methods><methods><class-id>COAST.CoastButtonWidgetModel class</class-id> <category>slots</category><body package="COASTEditors">buttonPressActionBlockSlot	^self slotSingleValue</body><body package="COASTEditors">imageComputingBlockSlot	^self slotSingleValue</body></methods><methods><class-id>COAST.CoastButtonWidgetModel class</class-id> <category>instance creation</category><body package="COASTEditors">imageBlock: imageBlock actionBlock: actionBlock	| newInst |	newInst := self new.	newInst buttonPressActionBlock: actionBlock.	newInst imageComputingBlock: imageBlock.	^newInst</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>selection</category><body package="COASTEditors">basicSelectionStartIndex: aStartIndex stopIndex: aStopIndex		self at: #selectionStartIndex set: aStartIndex.		self at: #selectionStopIndex set: aStopIndex</body><body package="COASTEditors">characterBlockAtPoint: aPoint	"Answer a CharacterBlock for characters in the text at point aPoint." 	| blk translation pt|	pt := aPoint + self displayOrigin negated.	blk := self text characterBlockAtPoint: pt.	translation := self displayOrigin.	blk origin: (blk origin translatedBy: translation) corner: (blk corner translatedBy: translation).	^blk</body><body package="COASTEditors">characterBlockForIndex: startIndex	"Answer a CharacterBlock for character in the text at targetIndex."	| blk translation |	translation := self displayOrigin.	blk := self text characterBlockForIndex: startIndex.	blk origin: (blk origin translatedBy: translation) corner: (blk corner translatedBy: translation).	^blk</body><body package="COASTEditors">deselect	self selectionShowing: false</body><body package="COASTEditors">hideInsertionPointFor: aCharacterBlock on: aGraphicsContext 	"Remove the insertion point on aGraphicsContext for aCharacterBlock."	self deselect.	"| r clipRect gc |	clipRect := aGraphicsContext clippingBounds.	r := self insertionPointBoundingBoxFor: aCharacterBlock.	(r intersects: clipRect) ifFalse: [^self].	gc := aGraphicsContext copy.	gc intersectClip: r.	gc paint: self backgroundColor.	gc displayRectangle: r.	gc paint: self foregroundColor.	self text displayOn: gc at: self displayOrigin"</body><body package="COASTEditors">placeSelectionPointAt: characterIndex 	"Place the character before the character at position characterIndex.  Make	certain the selection is in the view but does not display any thing (ie. assumes 	no selection is showing).	This is used by the TextEditor during typing"	| delta |	self		selectionStartIndex: characterIndex		stopIndex: characterIndex.	delta := self findSelectionDelta.	delta ~= 0 ifTrue: [self scrollBy: 0@delta negated].</body><body package="COASTEditors">resetSelections	"Relocate the receiver's selection blocks."	self startBlock: (self characterBlockForIndex: self startBlock stringIndex).	self stopBlock: (self characterBlockForIndex: self stopBlock stringIndex).</body><body package="COASTEditors">scrollTo: aPoint	" can't "</body><body package="COASTEditors">select	self selectionShowing: true</body><body package="COASTEditors">selectAndScroll	"Scroll until the selection is in the view and then show it."	| delta |	delta := self findSelectionDelta.	delta ~= 0 ifTrue: [self scrollBy: 0@delta negated].	self select</body><body package="COASTEditors">selectAt: characterIndex 	"Place the caret before the character at position characterIndex.  Make	certain the selection is in the view."	self		selectionStartIndex: characterIndex		stopIndex: characterIndex.	self selectAndScroll</body><body package="COASTEditors">selectionAnchorIndex	^ self at: #selectionAnchorIndex</body><body package="COASTEditors">selectionAnchorIndex: anIndex	self transactionManager displayDo: [		self at: #selectionAnchorIndex set: anIndex	].</body><body package="COASTEditors">selectionIndex: index	self transactionManager displayDo: [		self basicSelectionStartIndex: index stopIndex: index	].</body><body package="COASTEditors">selectionShowing: aBoolean 	"Set whether the selection is showing to aBoolean."	self selectionShowing ~= aBoolean ifTrue: 		[	self transactionManager bestIndependentDisplayDo: [ self at: #selectionShowing set: aBoolean ].			aBoolean ifTrue: 				[ | topComponent |					topComponent := self topComponent.					topComponent notNil ifTrue: [ topComponent keyboardProcessor setActive: self controller ]				]		]</body><body package="COASTEditors">selectionStartIndex	^ self at: #selectionStartIndex</body><body package="COASTEditors">selectionStartIndex: anIndex	self transactionManager bestIndependentDisplayDo: [		self at: #selectionStartIndex set: anIndex	].</body><body package="COASTEditors">selectionStartIndex: aStartIndex stopIndex: aStopIndex 	self transactionManager bestIndependentDisplayDo: [ self basicSelectionStartIndex: aStartIndex stopIndex: aStopIndex ]</body><body package="COASTEditors">selectionStopIndex	^ self at: #selectionStopIndex</body><body package="COASTEditors">selectionStopIndex: anIndex	self transactionManager bestIndependentDisplayDo: [		self at: #selectionStopIndex set: anIndex	].</body><body package="COASTEditors">startBlock	^self at: #startBlock</body><body package="COASTEditors">startBlock: aCharacterBlock	self selectionStartIndex: aCharacterBlock stringIndex.</body><body package="COASTEditors">startBlock: aCharacterBlock stopBlock: aCharacterBlock2	self		selectionStartIndex: aCharacterBlock stringIndex		stopIndex: aCharacterBlock2 stringIndex</body><body package="COASTEditors">stopBlock	^self at: #stopBlock</body><body package="COASTEditors">stopBlock: aCharacterBlock	self selectionStopIndex: aCharacterBlock stringIndex.</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>demons</category><body package="COASTEditors">checkStartIndex: slotAccess	| ts |	(self at: #selectionStartIndex) &gt; (ts := self displayContents text size + 1)		ifTrue: [ self at: #selectionStartIndex set: ts ].</body><body package="COASTEditors">checkStopIndex: slotAccess	| ts |	(self at: #selectionStopIndex) &gt; (ts := self displayContents text size + 1)		ifTrue: [ self at: #selectionStopIndex set: ts ].</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>computing</category><body package="COASTEditors">computeCharacterBlockForIndex: index	self bounds.		" doh :-) "	^  self displayContents text isEmpty		ifTrue: [ self emptyCharacterBlock ]		ifFalse: [ self characterBlockForIndex: index ]</body><body package="COASTEditors">computePreferredBounds	| b ms |	b := self text bounds.	b extent: b extent + (2 * self displayOrigin).	ms := self minSize.	ms notNil ifTrue: 		[	b width: ( b width max: ms x ).			b height: ( b height max: ms y )		].	^ b</body><body package="COASTEditors">computeStartBlock	^ self computeCharacterBlockForIndex: (self at: #selectionStartIndex)</body><body package="COASTEditors">computeStopBlock	^ self computeCharacterBlockForIndex: (self at: #selectionStopIndex)</body><body package="COASTEditors">computeText	| value text |	value := self model value ifNil: [ '' ].	text := [ value asText ] on: Error do: [ : ex | ex return: value displayString asText ].	^ InputFieldComposedText withText: text</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>displaying</category><body package="COASTEditors">coastDisplayInsertionPointFor: aCharacterBlock on: aGraphicsContext 	"Display the insertion point on aGraphicsContext for aCharacterBlock."	| r clipRect gc |	( self selectionShowing and: [ self selectionStartIndex = self selectionStopIndex ]) ifFalse: [ ^ self ].	clipRect := aGraphicsContext clippingBounds.	r := self insertionPointBoundingBoxFor: aCharacterBlock.	( r intersects: clipRect ) ifFalse: 		[	"position is out of visible area"			InputManager default updateView: self type: #cursor.			^ self		].	self insertionPointManager displayInsertionPointFor: aCharacterBlock in: self on: aGraphicsContext.	gc := aGraphicsContext copy.	gc paint: self foregroundColor.	InputManager default setSpot: ( aCharacterBlock topLeft corner: aCharacterBlock right @ ( aCharacterBlock top + self textStyle baseline )) on: self gc: gc.</body><body package="COASTEditors">composeDisplayOn: aGraphicsContext 	| gc |	gc := aGraphicsContext copy.	gc paint: self foregroundColor.	self displayTextOn: gc.	self coastDisplayInsertionPointFor: self startBlock on: gc.	self displaySelectionsOn: gc.</body><body package="COASTEditors">displayFromCharacter: start to: stop startX: x on: aGraphicsContext	"Display the character from start to stop on aGraphicsContext.  The	first character starts at x position x.  Useful for displaying selections."	self displayContents displayFromCharacter: start to: stop startX: x					forTranslation: self displayOrigin on: aGraphicsContext</body><body package="COASTEditors">displayFromSelectionBlock: cBlock1 toSelectionBlock: cBlock2 on: aGraphicsContext fColor: fColor bColor: bColor within: aRectangle	"Hilite area between the two character blocks given as arguments."	| start stop left first last lineRange leftX rightX gc |	(cBlock1 = cBlock2 or: [self displayContents numberOfLines = 0]) ifTrue: [^self].	cBlock1 &lt; cBlock2		ifTrue: [start := cBlock1. stop := cBlock2]		ifFalse: [start := cBlock2. stop := cBlock1].	start top &gt; aRectangle bottom ifTrue: [^self].	stop bottom &lt; aRectangle top ifTrue: [^self].	gc := aGraphicsContext copy.	gc paint: bColor.	start top = stop top		ifTrue: [gc displayRectangle: ((start origin corner: stop bottomLeft) intersect: aRectangle).				gc paint: fColor.				^self displayFromCharacter: start stringIndex to: stop stringIndex - 1 startX: start left on: gc].	left := start left.	(start top &gt;= aRectangle top and: [stop bottom &lt;= aRectangle bottom])		ifTrue: [first := start stringIndex.				last := stop stringIndex - 1]		ifFalse: [lineRange := self displayContents lineRangeFor: (aRectangle translatedBy: self displayOrigin negated).				first  := (self displayContents lineAt: lineRange first) first.				last := (self displayContents lineAt: lineRange last) last.				start stringIndex &gt; first					ifTrue: [first := start stringIndex].				stop stringIndex - 1 &lt; last					ifTrue: [last := stop stringIndex - 1]].	leftX := self displayOrigin x.	rightX := leftX + self displayObject bounds right.	gc displayRectangle: ((start origin corner: rightX @ start bottom) intersect: aRectangle).	gc displayRectangle: ((leftX@start bottom corner: rightX@stop top) intersect: aRectangle).	gc displayRectangle: ((leftX@stop top corner: stop bottomLeft) intersect: aRectangle).	gc paint: fColor.	self displayFromCharacter: first to: last startX: left on: gc</body><body package="COASTEditors">displayInsertionPointFor: aCharacterBlock on: aGraphicsContext 	"Display the insertion point on aGraphicsContext for aCharacterBlock."	self startBlock: aCharacterBlock</body><body package="COASTEditors">displaySelectionFrom: strtBlock to: stpBlock on: aGraphicsContext	"kept for compatibility - some old trackers want to modify me directly *sigh*"</body><body package="COASTEditors">displaySelectionsOn: aGraphicsContext 	self displaySelection 		ifFalse: [ ^ self ].	self showSelectionFrom: self startBlock to: self stopBlock on: aGraphicsContext copy within: self bounds.</body><body package="COASTEditors">displayTextOn: aGraphicsContext	self text displayOn: aGraphicsContext at: self displayOrigin.</body><body package="COASTEditors">showSelectionFrom: characterBlock1 to: characterBlock2 on: gc within: aRectangle 	"Hilite area between the two character blocks given as arguments."	self		displayFromSelectionBlock: characterBlock1		toSelectionBlock: characterBlock2		on: gc		fColor: self selectionForegroundColor		bColor: self selectionBackgroundColor		within: aRectangle</body><body package="COASTEditors">updateDisplayContents	"kept for compatibility - some old trackers want to modify me directly *sigh*"</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>accessing</category><body package="COASTEditors">backgroundColor	^ self isEnabled 		ifTrue: [ SymbolicPaint background ]		ifFalse: [ ColorValue brightness: 0.95 ]</body><body package="COASTEditors">bounds: newBounds	super bounds: newBounds.	self transactionManager bestIndependentDisplayDo:	[		self resetSelections.	].</body><body package="COASTEditors">displayContents	"better do not return nil"	| text |	text := self text.	^ text notNil 		ifTrue: [ text ]		ifFalse: [ String new asComposedText ]</body><body package="COASTEditors">displayObject	"Answer the receiver's display object."	^self text</body><body package="COASTEditors">displaySelection	"Answer whether selections will be shown."	^self at: #displaySelection</body><body package="COASTEditors">displaySelection: aBoolean	"Set whether selections will be shown.  Make the visual state consistant."	self displaySelection = aBoolean ifTrue: [^self].	self transactionManager bestIndependentDisplayDo:	[		self at: #displaySelection set: aBoolean.		"(self isOpen and: [self selectionShowing])			ifTrue: [ self at: #selectionShowing set: aBoolean ]."	].</body><body package="COASTEditors">fixedCompositionWidth	^self preferredBounds width</body><body package="COASTEditors">inset	^6</body><body package="COASTEditors">lineGrid	^self text lineGrid</body><body package="COASTEditors">minSize	^ self at: #minSize</body><body package="COASTEditors">minSize: aPoint	self at: #minSize set: aPoint</body><body package="COASTEditors">paragraphInset	"Answer the amount to inset the paragraph from the border."	^6@0 corner: 6@0</body><body package="COASTEditors">replaceTextFrom: start to: stop with: aText	self text coastReplaceFrom: start to: stop with: aText.	self model value: self text asString.</body><body package="COASTEditors">scrollFactor	^ 1</body><body package="COASTEditors">selectionShowing	^self at: #selectionShowing</body><body package="COASTEditors">text	^self at: #text</body><body package="COASTEditors">textStyle	"Answer the receiver's TextAttributes."	^self text textStyle</body><body package="COASTEditors">textStyle: aTextStyle	"Set the receiver's TextAttributes to be aTextStyle."	self text textStyle: aTextStyle</body><body package="COASTEditors">updateSpot: type	"Update IM spot position and attributes."	InputManager default updateView: self type: type</body><body package="COASTEditors">wordWrap: aBoolean 	"Set whether the receiver uses word wrapping."	| width |	aBoolean 		ifTrue: [ width := self wrappingBox width ]		ifFalse: [ width := SmallInteger maxVal ].	( self text isComposed and: [ self text numberOfLines &gt; 0 ]) 		ifTrue: 		[ | topLine topChar |			topLine := self displayObject lineIndexOfTop: self clippingBox top.			topChar := ( self text lineAt: topLine ) first.			self text wordWrap: aBoolean compositionWidth: width.			topLine := self text lineIndexOfCharacterIndex: topChar.			self positionTo: 0 @ ( self text topAtLineIndex: topLine ) negated		]		ifFalse: [ self text wordWrap: aBoolean compositionWidth: width ].	self resetSelections.	self invalidate</body><body package="COASTEditors">wrappingBox	"Answer the receiver's composition width."	^self clippingBox insetBy: self paragraphInset</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>region accessing</category><body package="COASTEditors">displayOrigin	"Answer the origin of the receiver's scrolled coordinate system."	^6@0</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>private</category><body package="COASTEditors">emptyCharacterBlock	" returns the character block used when text is empty "	^ CharacterBlock stringIndex: 1 character: nil boundingRectangle: ( self displayOrigin extent: 0 @ self textStyle lineGrid )</body><body package="COASTEditors">findSelectionDelta	"Answer the delta that should be added to the offset in order to make theselection visible."	| lineHeight deltaY clippingBox currentStopBlock |	lineHeight := self displayContents textStyle lineGrid.	clippingBox := self clippingBox.	currentStopBlock := self stopBlock.	deltaY := currentStopBlock top - clippingBox top.	deltaY &gt;= 0 		ifTrue: [deltaY := currentStopBlock bottom - clippingBox bottom max: 0].	^deltaY = 0 		ifTrue: [0]		ifFalse: [(deltaY abs + lineHeight - 1 truncateTo: lineHeight) * deltaYsign]</body><body package="COASTEditors">hideSelectionFrom: strtBlock to: stpBlock on: aGraphicsContext	"Remove the selection in strtBlock to stpBlock on aGraphicsContext."	self startBlock: strtBlock stopBlock: stpBlock</body><body package="COASTEditors">insertionPointBoundingBoxFor: aCharacterBlock	"Answer the bounding box for the receiver's insertion point."	| ipex |	ipex := InsertionPoint extent.	^(aCharacterBlock left - (ipex x // 2))@(aCharacterBlock top + self textStyle baseline) extent: ipex</body><body package="COASTEditors">insertionPointManager	"Return the object that implements the correct insertion point behavior."	^self widgetPolicy insertionPointManager</body><body package="COASTEditors">turnSelectionOff: aGraphicsContext within: aRectangle	"If the text selection is visible on the screen, remove it."	self selectionShowing: false.</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>not yet implemented</category><body package="COASTEditors">hasEditValue	^false</body><body package="COASTEditors">positionTo: aPoint	"Position the view to a particular place without affecting the display"	"scrollOffset valueWithoutDisplaying: (self validateScrollPosition: aPoint)"</body><body package="COASTEditors">scrollBy: offset	"Transcript show: offset printString; cr"</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>focus accessing</category><body package="COASTEditors">hasFocus: aBoolean	aBoolean ifFalse: [ self model  writeBack ]</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>controller access</category><body package="COASTEditors">resetController	"Make sure the receiver's controller knows the receiver's display contents."  	(controller notNil and: [controller isKindOf: ParagraphEditor])		ifTrue: [controller resetState]</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>line accessing</category><body package="COASTEditors">topAtLineIndex: aNumber	"Answer the top of the line indexed by aNumber."	^self displayObject topAtLineIndex: aNumber</body></methods><methods><class-id>COAST.CoastStringWidget</class-id> <category>controller accessing</category><body package="COASTEditors">defaultControllerClass	^self isEnabled ifTrue: [ CoastInputBoxController ] ifFalse: [ NoController ]</body></methods><methods><class-id>COAST.CoastStringWidget class</class-id> <category>slots</category><body package="COASTEditors">displaySelectionSlot	^self slotSingleValue defaultValue: true</body><body package="COASTEditors">minSizeSlot	^(self slotSingleValue)		range: Point;		yourself</body><body package="COASTEditors">selectionAnchorIndexSlot	^ self slotSingleValue		defaultValue: 1</body><body package="COASTEditors">selectionShowingSlot	^self slotSingleValue defaultValue: false</body><body package="COASTEditors">selectionStartIndexSlot	^ self slotSingleValue		defaultValue: 1;		afterModificationDemon: #checkStartIndex:</body><body package="COASTEditors">selectionStopIndexSlot	^ self slotSingleValue		defaultValue: 1;		afterModificationDemon: #checkStopIndex:</body><body package="COASTEditors">startBlockSlot	^ self slotComputedEagerBy: [: textView | textView computeStartBlock ]</body><body package="COASTEditors">stopBlockSlot	^ self slotComputedEagerBy: #computeStopBlock</body><body package="COASTEditors">textSlot	^self slotComputedBy: #computeText</body></methods><methods><class-id>COAST.CoastStringWidget class</class-id> <category>class initialization</category><body package="COASTEditors">initialize	"CoastStringWidget initialize."	InsertionPoint := CachedImage on: (Image		extent: 5@4		depth: 1		palette: CoveragePalette monoMaskPalette		bits: #[				2r00100000				2r01110000				2r11111000				2r11111000]		pad: 8)</body></methods><methods><class-id>COAST.CoastSimpleEditorListView</class-id> <category>accessing</category><body package="COASTEditors">alignment	^#vertical</body><body package="COASTEditors">effectiveLabelWidth	^(self at: #overrideLabelWidthComputingBlock) isNil		ifTrue: [ self at: #labelWidth ]		ifFalse: [ (self at: #overrideLabelWidthComputingBlock) value ]</body><body package="COASTEditors">height	^self at: #height</body><body package="COASTEditors">overrideLabelWidthComputingBlock: aBlock	self at: #overrideLabelWidthComputingBlock set: aBlock</body></methods><methods><class-id>COAST.CoastSimpleEditorListView</class-id> <category>computing</category><body package="COASTEditors">computeHeight	"simply sum up all the heights"	^self components inject: 0 into: [ :h :c | h + c height ]</body><body package="COASTEditors">computePreferredBounds	^ 0 @ 0 corner: self width @ self height</body><body package="COASTEditors">computeWidth	^self container isBounded		ifTrue: [ self container width ]		ifFalse: [ self components inject: 0 into: [ :max :c | max max: c width ] ]</body></methods><methods><class-id>COAST.CoastSimpleEditorListView</class-id> <category>private</category><body package="COASTEditors">createViewForModel: aModel	| newView |	newView := super createViewForModel: aModel.	newView component labelWidthComputingBlock:  [ :labelText | self effectiveLabelWidth ].	^newView</body></methods><methods><class-id>COAST.CoastSimpleEditorListView class</class-id> <category>slots</category><body package="COASTEditors">heightSlot	^self slotComputedBy: #computeHeight</body><body package="COASTEditors">overrideLabelWidthComputingBlockSlot	^self slotSingleValue</body></methods><methods><class-id>COAST.CoastDragHandleController</class-id> <category>events</category><body package="COASTEditors">redButtonPressedEvent: event 	| data ds dm |	data := DragDropData new.	data key: self model dragKey.	data contextWindow: self view topComponent.	data contextWidget: self view.	data clientData: IdentityDictionary new.	data clientData at: #model put: self model dragModel.	ds := DropSource new.	dm := DragDropManager withDropSource: ds withData: data.	dm doDragDrop</body></methods><methods><class-id>COAST.CoastCheckBoxWidget</class-id> <category>private</category><body package="COASTEditors">buttonPartBackgroundColor	^ self isEnabled 		ifTrue: [ SymbolicPaint checkBoxBackground ]		ifFalse: [ SymbolicPaint background ]</body><body package="COASTEditors">buttonPartForegroundColor	^SymbolicPaint checkBoxForeground</body><body package="COASTEditors">displayButtonOn: aGraphicsContext	"Display the button part of the receiver according to the current state of the model."	| image position |	image := self isSelected ifTrue: [ self class onImage ] ifFalse: [ self class offImage ].	position := 1 @ 5.	( aGraphicsContext copy )		paint: self buttonPartBackgroundColor;		display: self class maskImage at: position;		paint: self buttonPartForegroundColor;		display: image at: position</body><body package="COASTEditors">displayTraversalHiliteOn: aGraphicsContext	"Display indication that the receiver has keyboard focus."	| labelBox |	labelBox := Rectangle origin: 1@5 extent: self class onImage extent.	( aGraphicsContext copy )		 paint: SymbolicPaint checkBoxTraversalHilite;		displayInteriorRectangularBorder: (labelBox expandedBy: 2@2).</body></methods><methods><class-id>COAST.CoastCheckBoxWidget</class-id> <category>controller accessing</category><body package="COASTEditors">defaultControllerClass	^ self model isEnabled ifTrue: [ CoastButtonController ] ifFalse: [ NoController ]</body></methods><methods><class-id>COAST.CoastCheckBoxWidget</class-id> <category>accessing</category><body package="COASTEditors">getReferenceValue	^self transactionManager displayDo: [ self model value ]</body><body package="COASTEditors">hasFocus: aBoolean	self transactionManager displayDo:	[		self at: #hasFocus set: aBoolean	].</body><body package="COASTEditors">isInTransition: aBoolean	"ignore"</body><body package="COASTEditors">isSelected	^self model value == true</body><body package="COASTEditors">label	^nil</body></methods><methods><class-id>COAST.CoastCheckBoxWidget</class-id> <category>testing</category><body package="COASTEditors">hasFocus	^self at: #hasFocus</body></methods><methods><class-id>COAST.CoastCheckBoxWidget</class-id> <category>focus accessing</category><body package="COASTEditors">loseFocus	self hasFocus: false</body><body package="COASTEditors">takeFocus	self hasFocus: true</body></methods><methods><class-id>COAST.CoastCheckBoxWidget</class-id> <category>displaying</category><body package="COASTEditors">composeDisplayOn: aGraphicsContext 	"Display the receiver according to the current state of the model."	| gc |	self displayButtonOn: aGraphicsContext.	gc := aGraphicsContext copy.	gc paint: self foregroundColor.	self hasFocus ifTrue: [ self displayTraversalHiliteOn: gc ].</body></methods><methods><class-id>COAST.CoastCheckBoxWidget</class-id> <category>display box accessing</category><body package="COASTEditors">computePreferredBounds	self hasFocus. "create a dependency"	^ self class onImage bounds translatedBy: 1 @ 5</body></methods><methods><class-id>COAST.CoastCheckBoxWidget class</class-id> <category>slots</category><body package="COASTEditors">hasFocusSlot	^self slotSingleValue defaultValue: false</body></methods><methods><class-id>COAST.CoastCheckBoxWidget class</class-id> <category>resource accessing</category><body package="COASTEditors">maskImage	^CachedImage on: (Image extent: 13@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 248 0 0 255 248 0 0 255 248 0 0 255 248 0 0 255 248 0 0 255 248 0 0 255 248 0 0 255 248 0 0 255 248 0 0 255 248 0 0 255 248 0 0 255 248 0 0 255 248 0 0]).</body><body package="COASTEditors">offImage	| offImage offImageMask |	offImage := CachedImage on: (Image extent: 13@13 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); yourself)) usingBits: #[85 85 85 128 64 0 3 128 74 170 171 128 74 170 171 128 74 170 171 128 74 170 171 128 74 170 171 128 74 170 171 128 74 170 171 128 74 170 171 128 74 170 171 128 127 255 255 128 170 170 170 128]).	offImageMask := CachedImage on: (Image extent: 13@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 240 0 0 255 240 0 0 192 16 0 0 192 16 0 0 192 16 0 0 192 16 0 0 192 16 0 0 192 16 0 0 192 16 0 0 192 16 0 0 192 16 0 0 255 240 0 0 0 0 0 0]).	offImage := OpaqueImage					figure: offImage					shape:offImageMask.	^offImage</body><body package="COASTEditors">onImage	| onImage onImageMask |	onImage := CachedImage on: (Image extent: 13@13 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); yourself)) usingBits: #[85 85 85 128 64 0 3 128 74 170 171 128 74 170 139 128 74 170 11 128 72 168 11 128 72 32 43 128 72 0 171 128 74 2 171 128 74 138 171 128 74 170 171 128 127 255 255 128 170 170 170 128]).	onImageMask := CachedImage on: (Image extent: 13@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 240 0 0 255 240 0 0 192 16 0 0 192 80 0 0 192 208 0 0 209 208 0 0 219 144 0 0 223 16 0 0 206 16 0 0 196 16 0 0 192 16 0 0 255 240 0 0 0 0 0 0]).	onImage := OpaqueImage					figure: onImage					shape:onImageMask.	^onImage</body></methods><methods><class-id>COAST.CoastCheckBoxWidgetModel</class-id> <category>accessing</category><body package="COASTEditors">defaultViewClass	^CoastCheckBoxWidget</body></methods><methods><class-id>COAST.CoastDragHandleWidget</class-id> <category>controller accessing</category><body package="COASTEditors">defaultControllerClass	"Answer the class of the default controller for the receiver."	^CoastDragHandleController</body></methods><methods><class-id>COAST.CoastDragHandleWidgetModel</class-id> <category>accessing</category><body package="COASTEditors">defaultViewClass	^CoastDragHandleWidget</body><body package="COASTEditors">dragKey	^ self at: #dragKey</body><body package="COASTEditors">dragKey: aSymbol	self at: #dragKey set: aSymbol</body><body package="COASTEditors">dragModel	^ self at: #dragModel</body><body package="COASTEditors">dragModel: aModel	self at: #dragModel set: aModel</body></methods><methods><class-id>COAST.CoastDragHandleWidgetModel class</class-id> <category>slots</category><body package="COASTEditors">dragKeySlot	^self slotSingleValue</body><body package="COASTEditors">dragModelSlot	^self slotSingleValue</body></methods><methods><class-id>COAST.CoastDragHandleWidgetModel class</class-id> <category>instance creation</category><body package="COASTEditors">imageBlock: imageBlock dragKey: aSymbol dragModel: aModel	| newInst |	newInst := self new.	newInst dragKey: aSymbol.	newInst dragModel: aModel.	newInst imageComputingBlock: imageBlock.	^newInst</body></methods><methods><class-id>COAST.CoastInputFieldWidget</class-id> <category>displaying</category><body package="COASTEditors">composeDisplayOn: aGraphicsContext 	super composeDisplayOn: aGraphicsContext.	self frameVisible ifTrue: [ self displayFrameOn: aGraphicsContext ].</body><body package="COASTEditors">displayFrameOn: aGraphicsContext 	| gc |	gc := aGraphicsContext copy.	gc paint: self foregroundColor.	( self bounds insetOriginBy: 0 @ 0 cornerBy: 1 @ 1 ) displayStrokedOn: gc.</body><body package="COASTEditors">frameVisible	^ self model isEnabled</body></methods><methods><class-id>COAST.CoastTextWidget</class-id> <category>scrolling</category><body package="COASTEditors">changePositionBy: aPoint	"Translate the view without affecting the display"	| p |	p := (aPoint isKindOf: Point)		ifTrue:	[aPoint]		ifFalse:	[0@aPoint].	self positionTo: scrollOffset value + p.</body><body package="COASTEditors">positionTo: aPoint	"Position the view to a particular place without affecting the display"	scrollOffset valueWithoutDisplaying: (self validateScrollPosition: aPoint)</body><body package="COASTEditors">scrollBy: aPoint	"Translate the view, updating the display"	| p |	p := (aPoint isKindOf: Point)		ifTrue:	[aPoint]		ifFalse:	[0@aPoint].	self scrollTo: scrollOffset value + p.</body><body package="COASTEditors">scrollOffset	^ scrollOffset value</body><body package="COASTEditors">scrollTo: aPoint	"Position the view to a particular place, updating the display"	| p1 p |	p := scrollOffset value.	(p x  = aPoint x and: [p y = aPoint y]) ifTrue: [^self].	p1 := self validateScrollPosition: aPoint.	(p x  = p1 x and: [p y = p1 y])		ifFalse: [scrollOffset value: p1]</body><body package="COASTEditors">scrollableExtent	"Answer the extent of the receiver's display object bounding box."	^ self bounds extent</body><body package="COASTEditors">validateScrollPosition: aPoint	"Make sure that this is a legal scroll offset for us to occupy"	| p bounds |	bounds := self preferredBounds.	p := aPoint negated min: self scrollableExtent - self visibleExtent.	p := p max: bounds origin - scrollOffset extraSpace origin.	p := p grid: scrollOffset grid.	^p negated</body><body package="COASTEditors">visibleExtent	"Answer the extent of the receiver's clipping box."	^(self widgetBounds extent truncateTo: scrollOffset grid) max: scrollOffset grid</body></methods><methods><class-id>COAST.CoastTextWidget</class-id> <category>controller accessing</category><body package="COASTEditors">defaultControllerClass	^self model isEnabled ifTrue: [ CoastTextWidgetController ] ifFalse: [ NoController ]</body></methods><methods><class-id>COAST.CoastTextWidget</class-id> <category>computing</category><body package="COASTEditors">computeText	| ct |	ct := ComposedText withText: self getContents style: nil compositionWidth: self widgetBounds width.	^ ct</body><body package="COASTEditors">getContents	^ self model value asText</body></methods><methods><class-id>COAST.CoastTextWidget</class-id> <category>initialize-release</category><body package="COASTEditors">initialize	super initialize.	self scrollOffsetHolder: ScrollValueHolder new</body><body package="COASTEditors">scrollOffsetHolder: aValueHolder	scrollOffset := aValueHolder</body></methods><methods><class-id>COAST.CoastTextWidget</class-id> <category>selection</category><body package="COASTEditors">positionToSelection	"Set the offset so the selection is visible.  Nothing is displayed."	| delta |	delta := self findSelectionDelta.	delta ~= 0 		ifTrue: [self changePositionBy: 0@delta negated].</body><body package="COASTEditors">selectionInterval	" returns the start/stop-index interval of the selection "	| start stop |	start := self startBlock stringIndex.	stop := self stopBlock stringIndex.	^ start &lt;= stop		ifTrue: [ start to: stop - 1 ]		ifFalse: [ stop to: start - 1 ].</body><body package="COASTEditors">selectionInterval: anInterval	self deselect.	anInterval notNil		ifTrue: [			self				selectionStartIndex: anInterval first				stopIndex: anInterval last + 1.			self positionToSelection.		].</body></methods><methods><class-id>COAST.CoastTextWidget</class-id> <category>accessing</category><body package="COASTEditors">clippingBox	^ self widgetBounds translatedBy: self scrollOffset negated</body></methods><methods><class-id>COAST.CoastTextWidget</class-id> <category>displaying</category><body package="COASTEditors">displayTextOn: aGraphicsContext	| first last  ss es x  lineRange displayContents aRectangle gc |	displayContents := self displayContents.	(displayContents isNil or: [ displayContents numberOfLines = 0 ])		ifTrue: [ ^ self ].	aRectangle := aGraphicsContext clippingBounds.	gc := aGraphicsContext copy.	gc paint: self foregroundColor.	lineRange := displayContents lineRangeFor: (aRectangle translatedBy: self displayOrigin negated).	first  := (displayContents lineAt: lineRange first) first.	last := (displayContents lineAt: lineRange last) last.	x :=  self displayOrigin x.	ss := self startBlock stringIndex.	es := self stopBlock stringIndex.	(self displaySelection not or: [ ((ss &gt; last or: [es &lt; first]) or: [ss = es]) ])		ifTrue: [ ^ self displayObject displayOn: gc copy at: self displayOrigin ].	ss &gt; first		ifTrue: [gc paint: self foregroundColor.				self displayFromCharacter: first to: ss-1 startX: x on: gc.				first := ss.				x := self startBlock left].	gc paint: self selectionForegroundColor.	last &lt; es		ifTrue: [self displayFromCharacter: first to: last startX: x on: gc]		ifFalse: [self displayFromCharacter: first to: es - 1 startX: x on: gc.				gc paint: self foregroundColor.				x := self stopBlock left.				self displayFromCharacter: es to: last startX: x on: gc]</body></methods><methods><class-id>COAST.CoastInputFieldWidgetModel</class-id> <category>accessing</category><body package="COASTEditors">defaultViewClass	^CoastInputFieldWidget</body><body package="COASTEditors">writeBack	self model writeBack</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>bounds accessing</category><body package="COASTEditors">height	^self bounds height</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>focus accessing</category><body package="COASTEditors">passFocusDownWithEvent: aCharEvent fromView: aView	self container notNil ifTrue: [ self container passFocusDownWithEvent: aCharEvent fromView: self ]</body><body package="COASTEditors">passFocusUpWithEvent: aCharEvent fromView: aView	self container notNil ifTrue: [ self container passFocusUpWithEvent: aCharEvent fromView: self ]</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>bounds accessing</category><body package="COASTEditors">preferredHeight	^self preferredBounds height</body><body package="COASTEditors">preferredWidth	^self preferredBounds width</body><body package="COASTEditors">width	^self bounds width</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>accessing</category><body package="COASTEditors">coastReplaceFrom: start to: stop with: aText	^ self text isEmpty		ifTrue: [ self text: aText asText]		ifFalse: [ self replaceFrom: start to: stop with: aText ]</body></methods><initialize><class-id>COAST.CoastStringWidget</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>CatFSVirtualFrame</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>AutomaticVisualPart</name><environment>COAST</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>viewState subjects valid isOpen </inst-vars><class-inst-vars>viewStatePrototype </class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastView</name><environment>COAST</environment><super>COAST.CoastDependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastCompositeView</name><environment>COAST</environment><super>COAST.CoastView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldComponentDictionary subViewClassComputingBlock keyboardProcessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>ListView</name><environment>COAST</environment><super>COAST.OrderedCompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>ComposedText</name><environment>Graphics</environment><super>Graphics.TextLines</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text compositionWidth compositionHeight wordWrap fontPolicy lineTable fitWidth </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Graphics-Text Support</category><attributes><package>Graphics-Text Support</package></attributes></class><class><name>CoastController</name><environment>COAST</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trackers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIControllers</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastLocalApplicationModel</name><environment>COAST</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sharedApplicationModel viewState localUser coastDialog closedLocally </inst-vars><class-inst-vars>viewStatePrototype </class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>TextEditorController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown keyboardHook readOnly accepted autoAccept continuousAccept tabMeansNextField tabRequiresControl dispatcher selectable maxChars nextUndoBlock currentUndo </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>InputFieldController</name><environment>UI</environment><super>UI.TextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tabBlock crBlock </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class></st-source>