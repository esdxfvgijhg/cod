<?xml version="1.0"?><st-source><!-- Name: SudokuModelsDevelopmentPrerequisites: #(#(#any 'COASTCore' ''))PackageName: SudokuModelsParcel: #('SudokuModels')ParcelDirectory: SudokuModelsPrerequisiteDescriptions: #(#(#name 'COASTCore' #componentType #bundle))PrerequisiteParcels: #(#('COASTCore' ''))Version: 1.29Date: 1:48:39 PM July 26, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jul14.3) of 25. Juli 2014 on 26. Juli 2014 at 13:48:39</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Sudoku</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Suzdoku</category><attributes><package>SudokuModels</package></attributes></name-space><class><name>Grid</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rows columns boxes possibleValues height width </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuModels</package></attributes></class><class><name>SimpleCell</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y row column value boxIndex grid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuModels</package></attributes></class><class><name>Candidates</name><environment>Sudoku</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>SudokuModels</package></attributes></class><class><name>FastGrid</name><environment>Sudoku</environment><super>Sudoku.Grid</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuModels</package></attributes></class><class><name>FastCell</name><environment>Sudoku</environment><super>Sudoku.SimpleCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuModels</package></attributes></class><methods><class-id>Sudoku.Grid</class-id> <category>accessing</category><body package="SudokuModels">boxes	boxes isNil ifTrue: 		[	boxes := rows collect: [: row | OrderedCollection new: row size ].			self cellsDo: [: cell | ( boxes at: cell boxIndex ) add: cell ].			boxes beImmutable		].	^ boxes</body><body package="SudokuModels">columns	columns isNil ifTrue: 		[	columns := ( 1 to: rows size ) collect: [: i | rows collect: [: row | row at: i ]].			columns beImmutable		].	^ columns</body><body package="SudokuModels">copyAsFastGrid	| copy |	copy := FastGrid width: width height: height.	self with: copy do: [: my : other | other given: my givenOrNil ].	^ copy</body><body package="SudokuModels">gridCandidates	^ 1 to: self gridMaxValue</body><body package="SudokuModels">gridMaxValue	^ self height * self width</body><body package="SudokuModels">height	^ height</body><body package="SudokuModels">height: int 	height := int.</body><body package="SudokuModels">housesDo: block 	self boxes do: block.	self rows do: block.	self columns do: block.</body><body package="SudokuModels">isFastGrid	^ false</body><body package="SudokuModels">rows	^ rows</body><body package="SudokuModels">width	^ width</body><body package="SudokuModels">width: int 	width := int.</body><body package="SudokuModels">with: grid do: block 	rows with: grid rows do: [: row1 : row2 | row1 with: row2 do: block ].</body></methods><methods><class-id>Sudoku.Grid</class-id> <category>copying</category><body package="SudokuModels">postCopy	super postCopy.	rows := rows collect: 			[: row |				row collect: 					[: cell | ( cell copy )							grid: self;							yourself					]			].	boxes := columns := nil.</body></methods><methods><class-id>Sudoku.Grid</class-id> <category>initialize-release</category><body package="SudokuModels">buildRow: y sized: size 	^ ( 1 to: size ) collect: 		[: x | | cell |			cell := self initialCell.			cell x: x;				y: y;				grid: self.			cell		]</body><body package="SudokuModels">cellAtX: x y: y 	^ ( rows at: y ) at: x</body><body package="SudokuModels">fillFromRows: somRows 	self rows with: somRows		do: 		[: sudokuRow : ocs |			sudokuRow with: ocs				do: 				[: cell : oc |					oc notEmpty ifTrue: 						[	oc size = 1 								ifTrue: [ cell given: oc singleElement ]								ifFalse: [ cell given: oc ]						]				]		].</body><body package="SudokuModels">initAtX: x y: y given: value 	( self cellAtX: x y: y ) given: value.</body><body package="SudokuModels">initialCell	^ SimpleCell new</body><body package="SudokuModels">initialize	| size |	size := self height * self width.	possibleValues := ( 1 to: size ) asOrderedCollection.	possibleValues beImmutable.	rows := ( 1 to: size ) collect: [: y | self buildRow: y sized: size ].	rows beImmutable.</body></methods><methods><class-id>Sudoku.Grid</class-id> <category>transforming</category><body package="SudokuModels">swapRow: i with: j 	| row |	row := rows at: i.	rows at: i put: ( rows at: j ).	rows at: j put: row.</body></methods><methods><class-id>Sudoku.Grid</class-id> <category>iterating</category><body package="SudokuModels">cellsDo: block 	rows do: [: row | row do: block ].</body></methods><methods><class-id>Sudoku.Grid</class-id> <category>printing</category><body package="SudokuModels">asString	| stream |	stream := String new writeStream.	self simpleStringOn: stream.	^ stream contents</body><body package="SudokuModels">fullString	| stream |	stream := String new writeStream.	self fullStringOn: stream.	^ stream contents</body><body package="SudokuModels">fullStringOn: stream 	| max |	max := 1.	self cellsDo: [: cell | max := max max: cell candidates size ].	self printLineMax: stream on: max.	rows keysAndValuesDo: 		[: rowIndex : row |			self printRow: max max: row on: stream.			rowIndex \\ height = 0 ifTrue: [ self printLineMax: stream on: max ]		].</body><body package="SudokuModels">printLineMax: stream on: max 	stream nextPutAll: '+'.	1 to: height * width		do: 		[: columIndex | ( columIndex - 1 ) \\ width = 0 ifTrue: [ stream nextPutAll: '-' ].			max + 1 timesRepeat: [ stream nextPutAll: '-' ].			columIndex \\ width = 0 ifTrue: [ stream nextPutAll: '+' ]		].	stream cr.</body><body package="SudokuModels">printOn: stream 	self fullStringOn: stream.	self simpleStringOn: stream.</body><body package="SudokuModels">printRow: max max: row on: stream 	stream nextPutAll: '|'.	row keysAndValuesDo: 		[: columIndex : cell | ( columIndex - 1 ) \\ width = 0 ifTrue: [ stream space ].			( max + 1 - cell candidates size ) // 2 timesRepeat: [ stream space ].			cell candidates do: [: c | stream nextPut: ( Character digitValue: c )].			( max + 2 - cell candidates size ) // 2 timesRepeat: [ stream space ].			columIndex \\ width = 0 ifTrue: [ stream nextPutAll: '|' ]		].	stream cr.</body><body package="SudokuModels">simpleString	| stream |	stream := String new writeStream.	self simpleStringOn: stream.	^ stream contents</body><body package="SudokuModels">simpleStringOn: stream 	self cellsDo: 		[: cell | | value |			value := cell givenOrNil.			stream nextPut: ( value notNil 						ifTrue: [ Character digitValue: value ]						ifFalse: [ $. ])		].</body></methods><methods><class-id>Sudoku.Grid</class-id> <category>parsing</category><body package="SudokuModels">fromSimpleString: string 	| stream |	stream := string readStream.	self cellsDo: 		[: cell | | value |			value := stream atEnd 					ifTrue: [ 0 ]					ifFalse: [ stream next digitValue ].			value &gt; 0 ifTrue: [ cell given: value ]		].</body></methods><methods><class-id>Sudoku.Grid class</class-id> <category>instance creation</category><body package="SudokuModels">fromFullString: string do: block 	| rows row candidates width height inst |	rows := OrderedCollection new.	row := OrderedCollection new.	candidates := Candidates new.	width := height := nil.	string do: 		[: c | | digitValue |			digitValue := c digitValue.			digitValue &gt; 0 				ifTrue: [ candidates add: digitValue ]				ifFalse: 				[	candidates notEmpty ifTrue: 						[	row add: candidates.							candidates := Candidates new						].					( c = $| and: [ row notEmpty and: [ width isNil ]]) ifTrue: [ width := row size ].					( row notEmpty and: [ c isSeparator and: [( c = Character space ) not ]]) ifTrue: 						[	width isNil ifTrue: [ ^ self	"malformed" ].							height isNil ifTrue: [ height := row size // width ].							width * height = row size ifFalse: [ ^ self	"malformed" ].							rows add: row.							row := OrderedCollection new						]				]		].	candidates notEmpty ifTrue: [ row add: candidates ].	row notEmpty ifTrue: 		[	width * height = row size 				ifTrue: [ rows add: row ]				ifFalse: [ ^ self	"malformed" ]		].	rows size = ( width * height ) ifTrue: 		[	inst := self width: width height: height.			inst fillFromRows: rows.			block value: inst.			^ self		].</body><body package="SudokuModels">fromSimpleString: string do: block 	| inst size |	size := string size sqrtRounded.	size * size = string size ifTrue: 		[	2 to: size // 2				do: 				[: width | | height |					height := size // width.					height * width = size ifTrue: 						[	inst := self width: width height: height.							inst fromSimpleString: string.							block value: inst						]				]		].</body><body package="SudokuModels">fromString: string 	self fromString: string do: [: newInst | ^ newInst ].	^ nil</body><body package="SudokuModels">fromString: string do: block 	"try to read a long or short string"	[	( string includes: $| ) ifTrue: [ self fromFullString: string do: block ].		self fromSimpleString: ( string select: [: c | c digitValue &gt; 0 or: [ '.0' includes: c ]]) do: block	] on: Error do: [: ex | self haltOrContinue: ex description ].</body><body package="SudokuModels">new	^ self width: 3 height: 3</body><body package="SudokuModels">width: width height: height 	^ ( self basicNew )		width: width;		height: height;		initialize;		yourself</body></methods><methods><class-id>Sudoku.SimpleCell</class-id> <category>accessing</category><body package="SudokuModels">boxIndex	boxIndex isNil ifTrue: 		[ | bigColum bigRow |			bigColum := self boxX.	"1..width"			bigRow := self boxY.	"1..heigt"			boxIndex := bigColum + (( bigRow - 1 ) * grid height )		].	^ boxIndex</body><body package="SudokuModels">boxX	^ ( x - 1 ) // grid width + 1</body><body package="SudokuModels">boxY	^ ( y - 1 ) // grid height + 1</body><body package="SudokuModels">boxes	^ grid boxes</body><body package="SudokuModels">candidatesDo: block 	value isInteger 		ifTrue: [ block value: value ]		ifFalse: 		[	value notNil 				ifTrue: [ value do: block ]				ifFalse: [ grid gridCandidates do: block ]		].</body><body package="SudokuModels">candidatesIncludes: candidate 	^ value isInteger not and: [ value isNil or: [ value includes: candidate ]]</body><body package="SudokuModels">columns	^ grid columns</body><body package="SudokuModels">given: number 	value := number.</body><body package="SudokuModels">givenOrNil	^ value isInteger 		ifTrue: [ value ]		ifFalse: 		[( value notNil and: [ value size = 1 ]) 				ifTrue: [ value anyElement ]				ifFalse: [ nil ]		]</body><body package="SudokuModels">grid	^ grid</body><body package="SudokuModels">grid: aGrid 	row := column := nil.	grid := aGrid.</body><body package="SudokuModels">hasCandidates	^ value isInteger not</body><body package="SudokuModels">rows	^ grid rows</body><body package="SudokuModels">sudokuCellPosition	^ x @ y</body><body package="SudokuModels">value: aValue 	1 haltOrContinue.	self given: aValue.</body><body package="SudokuModels">x	^ x</body><body package="SudokuModels">x: aX 	x := aX.</body><body package="SudokuModels">y	^ y</body><body package="SudokuModels">y: aY 	y := aY.</body></methods><methods><class-id>Sudoku.SimpleCell</class-id> <category>iterating</category><body package="SudokuModels">box	^ grid boxes at: self boxIndex</body><body package="SudokuModels">column	column isNil ifTrue: [ column := grid columns at: x ].	^ column</body><body package="SudokuModels">row	row isNil ifTrue: [ row := grid rows at: y ].	^ row</body></methods><methods><class-id>Sudoku.SimpleCell</class-id> <category>initialize-release</category><body package="SudokuModels">candidates	^ value isNil 		ifTrue: [ Candidates withAll: self gridCandidates ]		ifFalse: 		[	value isInteger 				ifTrue: [ Candidates with: value ]				ifFalse: [ value ]		]</body><body package="SudokuModels">gridCandidates	^ grid gridCandidates</body><body package="SudokuModels">gridMaxValue	^ grid gridMaxValue</body></methods><methods><class-id>Sudoku.SimpleCell</class-id> <category>copying</category><body package="SudokuModels">postCopy	super postCopy.	value := value copy.	row := column := nil.</body></methods><methods><class-id>Sudoku.Candidates</class-id> <category>enumerating</category><body package="SudokuModels">collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for which	aBlock evaluates to true.  Answer the new collection."	| newCollection |	newCollection := Set new: self size.	self do: [: each | ( aBlock value: each ) ifTrue: [ newCollection add: each ]].	^ newCollection</body><body package="SudokuModels">fixCollisionsFrom: int 	"nothing to do"</body><body package="SudokuModels">select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for which	aBlock evaluates to true.  Answer the new collection."	| newCollection |	newCollection := self copy.	self do: [: each | ( aBlock value: each ) ifFalse: [ newCollection remove: each ]].	^ newCollection</body></methods><methods><class-id>Sudoku.Candidates</class-id> <category>private</category><body package="SudokuModels">findElementOrNil: integer 	"Answer the index of the argument anObject or answer nil."	"Copied from Set with equality check changed to identity."	^ integer &gt; self basicSize 		ifTrue: [ self grow findElementOrNil: integer ]		ifFalse: [ integer ]</body><body package="SudokuModels">first	1 to: self basicSize		do: 		[: index | | elem |			( elem := self basicAt: index ) == nil ifFalse: [ ^ elem ]		].	^ nil</body><body package="SudokuModels">last	self basicSize to: 1		by: -1		do: 		[: index | | elem |			( elem := self basicAt: index ) == nil ifFalse: [ ^ elem ]		].	^ nil</body></methods><methods><class-id>Sudoku.Candidates</class-id> <category>comparing</category><body package="SudokuModels">= object 	^ self == object 		or: [ object class == self class and: [ object size = self size and: [ object allSatisfy: [: candidate | self includes: candidate ]]]]</body></methods><methods><class-id>Sudoku.Candidates</class-id> <category>converting</category><body package="SudokuModels">asSet	^ self copy</body></methods><methods><class-id>Sudoku.Candidates class</class-id> <category>private</category><body package="SudokuModels">goodSizeFrom: integer 	^ integer + 1</body></methods><methods><class-id>Sudoku.FastGrid</class-id> <category>initialize-release</category><body package="SudokuModels">initialCell	^ FastCell new</body></methods><methods><class-id>Sudoku.FastGrid</class-id> <category>accessing</category><body package="SudokuModels">copyAsFastGrid	^ self copy</body><body package="SudokuModels">isFastGrid	^ true</body></methods><methods><class-id>Sudoku.FastCell</class-id> <category>accessing</category><body package="SudokuModels">given: aValue 	aValue isNil ifTrue: [ ^ self ].	super given: aValue.	self row do: [: sake | sake removeCandidate: aValue ].	self column do: [: sake | sake removeCandidate: aValue ].	self box do: [: sake | sake removeCandidate: aValue ].</body><body package="SudokuModels">removeCandidate: aValue 	| result |	result := super removeCandidate: aValue.	result notNil ifTrue: [ value size = 1 ifTrue: [ self given: value anyElement ]].	^ result</body></methods><methods><class-id>Core.Point</class-id> <category>accessing</category><body package="SudokuModels">sudokuCellPosition^self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class></st-source>