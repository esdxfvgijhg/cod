<?xml version="1.0"?><st-source><!-- Name: SudokuSolvingDevelopmentPrerequisites: #(#(#any 'SudokuModels' '') #(#any 'COASTCore' ''))KSignature: #('definedClasses' 59 'definedClassesHash' 28495469455 'extendedClasses' 6 'extendedClassesHash' 2730252864)KSignatureV2: #('definedClasses' 59 'definedClassesHash' 39827410019465971790588738624312585799980097071 'extendedClasses' 6 'extendedClassesHash' 598974554777654768888289220290566661088487912724)PackageName: SudokuSolvingParcel: #('SudokuSolving')ParcelDirectory: SudokuSolvingPrerequisiteDescriptions: #(#(#name 'SudokuModels') #(#name 'COASTCore' #componentType #bundle))PrerequisiteParcels: #(#('SudokuModels' '') #('COASTCore' ''))Version: 2.1Date: 1:48:36 PM July 26, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jul14.3) of 25. Juli 2014 on 26. Juli 2014 at 13:48:36</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SolvingStrategy</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuSolving</package></attributes></class><class><name>ReduceCandidates</name><environment>Sudoku</environment><super>Sudoku.SolvingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><comment><class-id>Sudoku.ReduceCandidates</class-id><body>ImpliedHint	do some implications, try to find a simple hintInstance Variables:	hint	&lt;SolvingStrategy&gt;	description of hint</body></comment><class><name>WithCells</name><environment>Sudoku</environment><super>Sudoku.ReduceCandidates</super><private>false</private><indexed-type>none</indexed-type><inst-vars>positions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>WithCellsFromTuple</name><environment>Sudoku</environment><super>Sudoku.WithCells</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tuple type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>HiddenTuple</name><environment>Sudoku</environment><super>Sudoku.WithCellsFromTuple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>HiddenTriples</name><environment>Sudoku</environment><super>Sudoku.HiddenTuple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>WithCellsAndNumber</name><environment>Sudoku</environment><super>Sudoku.WithCells</super><private>false</private><indexed-type>none</indexed-type><inst-vars>number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>AbstractYWing</name><environment>Sudoku</environment><super>Sudoku.WithCellsAndNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>YWing</name><environment>Sudoku</environment><super>Sudoku.AbstractYWing</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>AlignedPairExclusion</name><environment>Sudoku</environment><super>Sudoku.WithCells</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>ExtendedAlignedPairExclusion</name><environment>Sudoku</environment><super>Sudoku.AlignedPairExclusion</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>ChainedAlignedPairExclusion</name><environment>Sudoku</environment><super>Sudoku.ExtendedAlignedPairExclusion</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>NakedTuple</name><environment>Sudoku</environment><super>Sudoku.WithCellsFromTuple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>NakedQuads</name><environment>Sudoku</environment><super>Sudoku.NakedTuple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>NakedPair</name><environment>Sudoku</environment><super>Sudoku.NakedTuple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>HiddenQuads</name><environment>Sudoku</environment><super>Sudoku.HiddenTuple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>FreeAlignedPairExclusion</name><environment>Sudoku</environment><super>Sudoku.ChainedAlignedPairExclusion</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>Normalizer</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>permBoxX permXArray permGiven grid movedRows swapped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>CellAdornment</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>background colors backgroundColor cellPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuSolving</package></attributes></class><class><name>SolvingContext</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>strategies maxDifficulty randomOrNil </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuSolving</package></attributes></class><class><name>GridFactory</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>level dimension nextGrid timeout random </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuSolving</package></attributes></class><class><name>AlmostLockedSet</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cells joinedCandidates </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuSolving</package></attributes></class><class><name>SolvingLevel</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name minorLevel directStrategies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuSolving</package></attributes></class><class><name>GridAdornment</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string cellAdornments nextAdornment previousAdornment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuSolving</package></attributes></class><class><name>FinalStateDetection</name><environment>Sudoku</environment><super>Sudoku.SolvingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><comment><class-id>Sudoku.FinalStateDetection</class-id><body>FinalHint	there is nothing to do - either the grid is completed or there is no solution (dead end)Instance Variables:	valid	&lt;Boolean&gt;	valid or dead end</body></comment><class><name>Scramble</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>permXArray permYArray permGiven swap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuSolving</package></attributes></class><class><name>HintToCell</name><environment>Sudoku</environment><super>Sudoku.SolvingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellPos given </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><comment><class-id>Sudoku.HintToCell</class-id><body>HintToCell	any Hint with a associated cellInstance Variables:	position	&lt;Point&gt;	position of cell</body></comment><class><name>InferenceChain</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>links cells continuous </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuSolving</package></attributes></class><class><name>ForkedGridFactory</name><environment>Sudoku</environment><super>Sudoku.GridFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars>process semaphores recursionLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>Todo</name><environment>Sudoku</environment><super>Sudoku.SolvingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>Fish</name><environment>Sudoku</environment><super>Sudoku.ReduceCandidates</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type number indices positions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>UsingALS</name><environment>Sudoku</environment><super>Sudoku.ReduceCandidates</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alsSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>AbstractChain</name><environment>Sudoku</environment><super>Sudoku.ReduceCandidates</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>HiddenSingle</name><environment>Sudoku</environment><super>Sudoku.HintToCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars>positions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><comment><class-id>Sudoku.HiddenSingle</class-id><body>HiddenSingles	The olny cell to take a given number within a box, colum or row</body></comment><class><name>CoverdByNeighbours</name><environment>Sudoku</environment><super>Sudoku.ReduceCandidates</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><comment><class-id>Sudoku.CoverdByNeighbours</class-id><body>CoverdByNeighbours	remove all candidates already taken by sakes of each cell</body></comment><class><name>NakedSingle</name><environment>Sudoku</environment><super>Sudoku.HintToCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><comment><class-id>Sudoku.NakedSingle</class-id><body>SingleCandidate	look for a cell with only one candidateInstance Variables:	cellPos		&lt;Point&gt;	the cell position witch allows only one value</body></comment><class><name>Done</name><environment>Sudoku</environment><super>Sudoku.FinalStateDetection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>DeadEndAhead</name><environment>Sudoku</environment><super>Sudoku.FinalStateDetection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>number cellPositions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>Duplicates</name><environment>Sudoku</environment><super>Sudoku.FinalStateDetection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellPositions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>DeadEnd</name><environment>Sudoku</environment><super>Sudoku.FinalStateDetection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>Backtracking</name><environment>Sudoku</environment><super>Sudoku.HintToCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars>solution </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>UniqueRectangle</name><environment>Sudoku</environment><super>Sudoku.WithCells</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>XWing</name><environment>Sudoku</environment><super>Sudoku.Fish</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>AlmostLockedSetXZ</name><environment>Sudoku</environment><super>Sudoku.UsingALS</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x z </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>SwordFish</name><environment>Sudoku</environment><super>Sudoku.Fish</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>MultivalueXWing</name><environment>Sudoku</environment><super>Sudoku.WithCells</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>AbstractChainByNumber</name><environment>Sudoku</environment><super>Sudoku.AbstractChain</super><private>false</private><indexed-type>none</indexed-type><inst-vars>number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>AlmostLockedSetXYWing</name><environment>Sudoku</environment><super>Sudoku.UsingALS</super><private>false</private><indexed-type>none</indexed-type><inst-vars>y z x </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>JellyFish</name><environment>Sudoku</environment><super>Sudoku.Fish</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>SquirmBag</name><environment>Sudoku</environment><super>Sudoku.Fish</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>NiceLoops</name><environment>Sudoku</environment><super>Sudoku.AbstractChain</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellPositions links </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>DeathBlossom</name><environment>Sudoku</environment><super>Sudoku.UsingALS</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stern </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>MultiColouring</name><environment>Sudoku</environment><super>Sudoku.AbstractChainByNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pointsA pointsB </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>IntersectionRemoval</name><environment>Sudoku</environment><super>Sudoku.WithCellsAndNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>SingleChain</name><environment>Sudoku</environment><super>Sudoku.AbstractChainByNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars>chainPoints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>WXYZWing</name><environment>Sudoku</environment><super>Sudoku.WithCellsAndNumber</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hingePos </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuModels</category><attributes><package>SudokuSolving</package></attributes></class><class><name>XYChain</name><environment>Sudoku</environment><super>Sudoku.AbstractYWing</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>NakedTriples</name><environment>Sudoku</environment><super>Sudoku.NakedTuple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><class><name>HiddenPair</name><environment>Sudoku</environment><super>Sudoku.HiddenTuple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuSolving</category><attributes><package>SudokuSolving</package></attributes></class><methods><class-id>Sudoku.SolvingStrategy</class-id> <category>accessing</category><body package="SudokuSolving">canModifyGrid	^ self class canModifyGrid</body><body package="SudokuSolving">difficulty	^ self class difficulty</body><body package="SudokuSolving">isSingleSolutionFor: grid context: context 	^ true</body><body package="SudokuSolving">modifyGrid: grid 	self solveGrid: grid.	^ true</body><body package="SudokuSolving">niceName	^ self class niceName</body><body package="SudokuSolving">solveGrid: grid 	self subclassResponsibility.</body><body package="SudokuSolving">valid	^ true</body></methods><methods><class-id>Sudoku.SolvingStrategy</class-id> <category>testing</category><body package="SudokuSolving">isSudokuSolvingStrategy	^true</body><body package="SudokuSolving">needsCandidates	^ true</body></methods><methods><class-id>Sudoku.SolvingStrategy</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	^ GridAdornment string: self niceName</body></methods><methods><class-id>Sudoku.SolvingStrategy</class-id> <category>printing</category><body package="SudokuSolving">displayString	^ self class niceName</body></methods><methods><class-id>Sudoku.SolvingStrategy class</class-id> <category>testing</category><body package="SudokuSolving">canModifyGrid	^ true</body><body package="SudokuSolving">isForValidation	^ false</body><body package="SudokuSolving">needsSingleSolution	^ false</body></methods><methods><class-id>Sudoku.SolvingStrategy class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	"	SolvingStrategy withAllSubclasses groupedBy: [: c | c difficulty ifNil: [ 0 ]].	"	^ nil</body><body package="SudokuSolving">niceName	| stream |	stream := String new writeStream.	self name do: 		[: c | ( c isUppercase and: [ stream notEmpty ]) ifTrue: [ stream space ].			stream nextPut: c		].	^ stream contents</body></methods><methods><class-id>Sudoku.SolvingStrategy class</class-id> <category>instance creation</category><body package="SudokuSolving">tipsIn: grid context: context do: block</body></methods><methods><class-id>Sudoku.ReduceCandidates</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	self subclassResponsibility.</body><body package="SudokuSolving">solveGrid: grid 	^ self modifyGrid: grid</body></methods><methods><class-id>Sudoku.ReduceCandidates</class-id> <category>explain</category><body package="SudokuSolving">addModifiedCellsIn: grid to: gridAdornments 	| copy removed gridAdornment |	removed := Candidates new.	copy := grid copy.	self modifyGrid: copy.	gridAdornment := GridAdornment new.	copy with: grid		do: 		[: m : o | | remaining |			remaining := m candidates.			o candidates size = remaining size ifFalse: 				[	o candidates do: 						[: candidate | ( remaining includes: candidate ) ifFalse: 								[	removed add: candidate.									gridAdornment position: o sudokuCellPosition removeCandidate: candidate								]						]				]		].	removed notEmpty ifTrue: 		[	gridAdornment string: (( #sudokuRemoveMarks1s &gt;&gt; 'Remove marks &lt;1s&gt;' ) asString expandMacrosWith: removed sudokuValuesSting ).			gridAdornments nextAdornment: gridAdornment		].</body></methods><methods><class-id>Sudoku.ReduceCandidates class</class-id> <category>instance creation</category><body package="SudokuSolving">pairsIn: grid 	| pairs |	pairs := OrderedCollection new.	grid cellsDo: [: cell | ( cell hasCandidates and: [ cell candidates size = 2 ]) ifTrue: [ pairs add: cell ]].	^ pairs</body><body package="SudokuSolving">pairsIn: grid context: context 	^ self pairsIn: grid</body></methods><methods><class-id>Sudoku.WithCells</class-id> <category>accessing</category><body package="SudokuSolving">positions: pointArray 	positions := pointArray.</body></methods><methods><class-id>Sudoku.WithCells</class-id> <category>explain</category><body package="SudokuSolving">addPositionsIn: grid to: gridAdornments 	gridAdornments nextAdornment: ( GridAdornment focusOnCells: ( positions collect: [: p | grid cellAtX: p x y: p y ])).	self addModifiedCellsIn: grid to: gridAdornments.	self addModifiedCellsIn: grid to: gridAdornments.</body><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments |	gridAdornments := super adornmentsIn: grid.	self addPositionsIn: grid to: gridAdornments.	^ gridAdornments</body></methods><methods><class-id>Sudoku.WithCells class</class-id> <category>instance creation</category><body package="SudokuSolving">cells: cells 	^ ( self new )		positions: ( cells collect: [: cell | cell sudokuCellPosition ]);		yourself</body></methods><methods><class-id>Sudoku.WithCellsFromTuple</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	| house cells |	cells := positions collect: [: cell | grid cellAtX: cell x y: cell y ].	house := type = #row 			ifTrue: [ cells anyElement row ]			ifFalse: 			[	type = #column 					ifTrue: [ cells anyElement column ]					ifFalse: [ cells anyElement box ]			].	cells := house select: [: cell | cell hasCandidates and: [ cell candidates contains: [: value | tuple includes: value ]]].	cells size &gt; self class tupleSize ifTrue: [ ^ false	"does not apply" ].	( positions allSatisfy: [: pos | cells contains: [: cell | pos x = cell x and: [ pos y = cell y ]]]) ifFalse: [ ^ false	"does not apply" ].	^ self class modifyCells: cells tuple: tuple	"apply rule"</body><body package="SudokuSolving">tuple: numbers 	tuple := numbers.</body><body package="SudokuSolving">type: symbol 	type := symbol.</body></methods><methods><class-id>Sudoku.WithCellsFromTuple</class-id> <category>explain</category><body package="SudokuSolving">addPositionsIn: grid to: gridAdornments 	gridAdornments nextAdornment: ( GridAdornment string: (( #sudokuFocusOn1s &gt;&gt; 'Focus on' ) asString expandMacrosWith: tuple sudokuValuesSting )).	gridAdornments nextAdornment: ( GridAdornment focusOnCells: positions candidates: tuple ).	self addModifiedCellsIn: grid to: gridAdornments.</body></methods><methods><class-id>Sudoku.WithCellsFromTuple class</class-id> <category>accessing</category><body package="SudokuSolving">isForValidation	^ true</body><body package="SudokuSolving">tupleSize	" subclassResponsibility "	^ nil</body></methods><methods><class-id>Sudoku.WithCellsFromTuple class</class-id> <category>instance creation</category><body package="SudokuSolving">cells: cells tuple: tuple 	^ ( self cells: cells )		tuple: tuple;		yourself</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	self tipsInHouse: grid rows grid: grid type: #row tupleSize: self tupleSize context: context do: block.	self tipsInHouse: grid columns grid: grid type: #column tupleSize: self tupleSize context: context do: block.	self tipsInHouse: grid boxes grid: grid type: #box tupleSize: self tupleSize context: context do: block.</body><body package="SudokuSolving">tipsInHouse: houses grid: grid type: type tupleSize: tupleSize context: context do: block 	self subclassResponsibility.</body><body package="SudokuSolving">type: aType cells: cells tuple: tuple 	^ ( self cells: cells tuple: tuple )		type: aType;		yourself</body></methods><methods><class-id>Sudoku.HiddenTuple</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	| cells |	cells := positions collect: [: p | grid cellAtX: p x y: p y ].	^ self class modifyCells: cells tuple: tuple	"apply rule"</body></methods><methods><class-id>Sudoku.HiddenTuple class</class-id> <category>modify</category><body package="SudokuSolving">modifyCells: cells tuple: tuple 	| modified |	modified := false.	cells do: 		[: cell |			cell candidates copy do: 				[: number | ( tuple includes: number ) ifFalse: 						[	cell removeCandidate: number.							modified := true						]				]		].	^ modified</body></methods><methods><class-id>Sudoku.HiddenTuple class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	"medium - check all sakes"	| tupleSize |	tupleSize := self tupleSize.	^ tupleSize notNil 		ifTrue: [ tupleSize * 100 - 5 ]		ifFalse: [ nil ]</body></methods><methods><class-id>Sudoku.HiddenTuple class</class-id> <category>instance creation</category><body package="SudokuSolving">tipsInHouse: houses grid: grid type: type tupleSize: tupleSize context: context do: block 	houses keysAndValuesDo: 		[: index : house | | cellTuple candidates |			candidates := Candidates new.			house do: [: cell | cell hasCandidates ifTrue: [ candidates addAll: cell candidates ]].			candidates asArray subCollectionsSized: tupleSize				do: 				[: tuple | | modified |					cellTuple := house select: [: cell | cell hasCandidates and: [ cell candidates contains: [: value | tuple includes: value ]]].					modified := cellTuple size &lt;= tupleSize and: [ self modifyCells: cellTuple tuple: tuple	"apply rule" ].					modified ifTrue: [ block value: ( self type: type cells: cellTuple tuple: tuple )]				]		].</body></methods><methods><class-id>Sudoku.HiddenTriples class</class-id> <category>accessing</category><body package="SudokuSolving">tupleSize	^ 3</body></methods><methods><class-id>Sudoku.WithCellsAndNumber</class-id> <category>accessing</category><body package="SudokuSolving">number: int 	number := int.</body></methods><methods><class-id>Sudoku.WithCellsAndNumber</class-id> <category>explain</category><body package="SudokuSolving">addPositionsIn: grid to: gridAdornments 	gridAdornments nextAdornment: ( GridAdornment focusOnCandidate: number ).	gridAdornments nextAdornment: ( GridAdornment focusOnCells: positions candidate: number ).	self addModifiedCellsIn: grid to: gridAdornments.</body></methods><methods><class-id>Sudoku.WithCellsAndNumber class</class-id> <category>instance creation</category><body package="SudokuSolving">cells: cells number: number 	^ ( self cells: cells )		number: number;		yourself</body></methods><methods><class-id>Sudoku.AbstractYWing</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	| pairs pass |	pairs := positions collect: [: c | grid cellAtX: c x y: c y ].	( pairs allSatisfy: [: c | c hasCandidates and: [ c candidates size = 2 ]]) ifFalse: [ ^ false ].	pass := pairs inject: number			into: 			[: other : cell |				cell candidates first = other 					ifTrue: [ cell candidates last ]					ifFalse: 					[	cell candidates last = other 							ifTrue: [ cell candidates first ]							ifFalse: [ nil ]					]			].	pass isNil ifTrue: [ ^ false	"chain broken" ].	^ self class modifyCells: pairs number: number</body></methods><methods><class-id>Sudoku.AbstractYWing class</class-id> <category>instance creation</category><body package="SudokuSolving">cellsWith: a from: cellA with: b to: cellB using: pairs do: block 	self subclassResponsibility.</body><body package="SudokuSolving">modifyCells: cells number: number 	| modified |	modified := false.	cells first allSakesDo: 		[: sake | ( sake hasCandidates and: [( cells last isSake: sake ) and: [( sake removeCandidate: number ) notNil ]]) ifTrue: [ modified := true ]		].	^ modified</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	| pairs dict max |	pairs := self pairsIn: grid context: context.	dict := Dictionary new.	max := grid gridMaxValue.	1 to: max		do: 		[: n |			dict isEmpty ifFalse: [ dict := Dictionary new ].			pairs do: 				[: cell | ( cell hasCandidates and: [ cell candidates size = 2 and: [ cell candidatesIncludes: n ]]) 						ifTrue: [( dict at: ( cell candidates detect: [: m | m ~= n ]) ifAbsentPut: [ OrderedCollection new ]) add: cell ]				].			dict size &gt; 1 ifTrue: 				[	1 to: max - 1						do: 						[: b | ( dict at: b ifAbsent: [ #( )]) do: 								[: cellB |									b + 1 to: max										do: 										[: c | ( dict at: c ifAbsent: [ #( )]) do: 												[: cellC |													self cellsWith: c														from: cellC														with: b														to: cellB														using: pairs														do: 														[: chain | ( self modifyCells: chain number: n ) ifTrue: [ block value: ( self cells: chain number: n )]														]												]										]								]						]				]		].</body></methods><methods><class-id>Sudoku.YWing</class-id> <category>explain</category><body package="SudokuSolving">addPositionsIn: grid to: gridAdornments 	| gridAdornment |	gridAdornment := GridAdornment focusOnCandidate: number.	gridAdornment yWing: ( positions collect: [: pos | grid cellAtX: pos x y: pos y ]) candidate: number.	gridAdornments nextAdornment: gridAdornment.	self addModifiedCellsIn: grid to: gridAdornments.</body></methods><methods><class-id>Sudoku.YWing class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 199</body></methods><methods><class-id>Sudoku.YWing class</class-id> <category>instance creation</category><body package="SudokuSolving">cellsWith: a from: cellA with: b to: cellB using: pairs do: block 	pairs do: 		[: cell | (( cell candidatesIncludes: a ) and: [( cell candidatesIncludes: b ) and: [( cell isSake: cellA ) and: [ cell isSake: cellB ]]]) 				ifTrue: [ block value: ( Array with: cellA with: cell with: cellB )	"rule applies" ]		].</body></methods><methods><class-id>Sudoku.AlignedPairExclusion</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	| cells |	cells := positions collect: [: c | grid cellAtX: c x y: c y ].	^ self class removeCombinationsFrom: cells first alignedWith: cells last</body></methods><methods><class-id>Sudoku.AlignedPairExclusion</class-id> <category>explain</category><body package="SudokuSolving">addCombinationReducton: combinations cellX: cellX cellY: cellY to: gridAdornments 	cellX candidates do: [: xCandy | cellY candidates do: [: yCandy | xCandy = yCandy ifFalse: [ combinations add: xCandy @ yCandy ]]].	self class reduceCombinationsByPairs: combinations		from: cellX		aglingnedTo: cellY		do: 		[: string : cells | | gridAdornment |			gridAdornment := GridAdornment remainingCombinations: combinations prefix: string.			self addModifyingCells: cells to: gridAdornment.			gridAdornments nextAdornment: gridAdornment		].</body><body package="SudokuSolving">addModifyingCells: cells to: gridAdornment 	cells do: [: cell | cell candidates do: [: candidate | gridAdornment position: cell sudokuCellPosition candidate: candidate color: #modifyingSake2 ]].</body><body package="SudokuSolving">addPositionsIn: grid to: gridAdornments 	| cellX cellY combinations gridAdornment |	cellX := grid cellAtX: positions first x y: positions first y.	cellY := grid cellAtX: positions last x y: positions last y.	combinations := Set new.	cellX candidates do: [: xCandy | cellY candidates do: [: yCandy | xCandy = yCandy ifFalse: [ combinations add: xCandy @ yCandy ]]].	gridAdornment := GridAdornment remainingCombinations: combinations prefix: 'Initial'.	gridAdornment addAlphabetic: positions.	gridAdornments nextAdornment: gridAdornment.	self addCombinationReducton: combinations cellX: cellX cellY: cellY to: gridAdornments.	self addModifiedCellsIn: grid to: gridAdornments.</body></methods><methods><class-id>Sudoku.AlignedPairExclusion class</class-id> <category>modify</category><body package="SudokuSolving">combinationsWith: cellX with: cellY 	| combinations |	combinations := Set new.	cellX candidatesDo: [: xCandy | cellY candidatesDo: [: yCandy | xCandy = yCandy ifFalse: [ combinations add: xCandy @ yCandy ]]].	^ combinations</body><body package="SudokuSolving">modifyWithCombinations: combinations from: cellX alignedWith: cellY 	| modified px py |	modified := false.	px := Candidates new.	py := Candidates new.	combinations do: 		[: pair |			px add: pair x.			py add: pair y		].	cellX candidates size = px size ifFalse: 		[	cellX candidates copy do: 				[: candidate | ( px includes: candidate ) ifFalse: 						[	cellX removeCandidate: candidate.							modified := true						]				]		].	cellY candidates size = py size ifFalse: 		[	cellY candidates copy do: 				[: candidate | ( py includes: candidate ) ifFalse: 						[	cellY removeCandidate: candidate.							modified := true						]				]		].	^ modified</body><body package="SudokuSolving">reduceCombinations: combinations from: cellX aglingnedTo: cellY 	"type 1"	| oldSize |	oldSize := combinations size.	self reduceCombinationsByPairs: combinations from: cellX aglingnedTo: cellY do: nil.	^ oldSize ~= combinations size</body><body package="SudokuSolving">reduceCombinationsByPairs: combinations from: cellX aglingnedTo: cellY do: blockOrNil 	"type 1"	| modified |	cellX allSakesDo: 		[: sake | | candidates |			( sake hasCandidates and: 				[	candidates := sake candidates.					candidates size = 2 and: [ sake isSake: cellY ]				]) ifTrue: 				[	modified := false.					( combinations remove: candidates first @ candidates last ifAbsent: nil ) notNil ifTrue: [ modified := true ].					( combinations remove: candidates last @ candidates first ifAbsent: nil ) notNil ifTrue: [ modified := true ].					( modified and: [ blockOrNil notNil ]) ifTrue: [ blockOrNil value: '-' , candidates sudokuValuesSting value: ( Array with: sake )]				]		].</body><body package="SudokuSolving">removeCombinationsFrom: cellX alignedWith: cellY 	| combinations |	combinations := self combinationsWith: cellX with: cellY.	( self reduceCombinations: combinations from: cellX aglingnedTo: cellY ) 		ifTrue: [( self modifyWithCombinations: combinations from: cellX alignedWith: cellY ) ifTrue: [ ^ true ]].	^ false</body></methods><methods><class-id>Sudoku.AlignedPairExclusion class</class-id> <category>instance creation</category><body package="SudokuSolving">tipsIn: grid context: context do: block 	grid boxes do: 		[: box |			1 to: box size - 1				do: 				[: x | | cellX |					cellX := box at: x.					cellX hasCandidates ifTrue: 						[	x + 1 to: box size								do: 								[: y | | cellY |									cellY := box at: y.									cellY hasCandidates ifTrue: 										[( self removeCombinationsFrom: cellX alignedWith: cellY ) ifTrue: [ ^ block value: ( self cells: ( Array with: cellX with: cellY ))]										]								]						]				]		].</body></methods><methods><class-id>Sudoku.AlignedPairExclusion class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 200</body></methods><methods><class-id>Sudoku.ExtendedAlignedPairExclusion</class-id> <category>explain</category><body package="SudokuSolving">addCombinationReducton: combinations cellX: cellX cellY: cellY to: gridAdornments 	super addCombinationReducton: combinations cellX: cellX cellY: cellY to: gridAdornments.	self class reduceCombinationsByTriples: combinations		from: cellX		aglingnedTo: cellY		do: 		[: string : cells | | gridAdornment |			gridAdornment := GridAdornment remainingCombinations: combinations prefix: string.			self addModifyingCells: cells to: gridAdornment.			gridAdornments nextAdornment: gridAdornment		].</body></methods><methods><class-id>Sudoku.ExtendedAlignedPairExclusion class</class-id> <category>modify</category><body package="SudokuSolving">reduceCombinations: combinations from: cellX aglingnedTo: cellY 	"type 2"	| oldSize |	oldSize := combinations size.	super reduceCombinations: combinations from: cellX aglingnedTo: cellY.	self reduceCombinationsByTriples: combinations from: cellX aglingnedTo: cellY do: nil.	^ oldSize ~= combinations size</body><body package="SudokuSolving">reduceCombinationsByTriples: combinations from: cellX aglingnedTo: cellY do: blockOrNil 	"type 2"	cellX allSakesDo: 		[: sake | | candidates spreadCandidates modified |			( sake hasCandidates and: 				[	candidates := sake candidates.					candidates size &lt;= 3 and: [ cellY isSake: sake ]				]) ifTrue: 				[	cellX allSakesDo: 						[: otherSake | ( otherSake ~= sake and: 								[	otherSake hasCandidates and: 										[	otherSake candidates size &lt;= 3 and: 												[	spreadCandidates := otherSake candidates asSet.													spreadCandidates addAll: candidates.													spreadCandidates size &lt;= 3 and: [( cellY isSake: otherSake ) and: [ sake isSake: otherSake ]]												]										]								]) 								ifTrue: 								[	modified := false.									spreadCandidates := spreadCandidates asArray.									1 to: spreadCandidates size - 1										do: 										[: i |											i + 1 to: spreadCandidates size												do: 												[: j | ( combinations remove: ( spreadCandidates at: i ) @ ( spreadCandidates at: j ) ifAbsent: nil ) notNil ifTrue: [ modified := true ].													( combinations remove: ( spreadCandidates at: j ) @ ( spreadCandidates at: i ) ifAbsent: nil ) notNil ifTrue: [ modified := true ]												]										].									( modified and: [ blockOrNil notNil ]) ifTrue: [ blockOrNil value: ExtendedAlignedPairExclusion niceName value: ( Array with: sake with: otherSake )]								]						]				]		].</body></methods><methods><class-id>Sudoku.ExtendedAlignedPairExclusion class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 300</body></methods><methods><class-id>Sudoku.ChainedAlignedPairExclusion</class-id> <category>explain</category><body package="SudokuSolving">addCombinationReducton: combinations cellX: cellX cellY: cellY to: gridAdornments 	super addCombinationReducton: combinations cellX: cellX cellY: cellY to: gridAdornments.	self class reduceCombinationsWithChains: combinations		grid: cellX grid		from: cellX		aglingnedTo: cellY		do: 		[: string : cells | | gridAdornment |			gridAdornment := GridAdornment remainingCombinations: combinations prefix: string.			self addModifyingCells: cells to: gridAdornment.			gridAdornments nextAdornment: gridAdornment		].</body></methods><methods><class-id>Sudoku.ChainedAlignedPairExclusion class</class-id> <category>modify</category><body package="SudokuSolving">reduceCombinations: combinations from: cellX aglingnedTo: cellY 	| oldSize |	oldSize := combinations size.	super reduceCombinations: combinations from: cellX aglingnedTo: cellY.	self reduceCombinationsWithChains: combinations grid: cellX grid from: cellX aglingnedTo: cellY do: nil.	^ oldSize ~= combinations size</body><body package="SudokuSolving">reduceCombinations: combinations remove: point withChainsFrom: pairs from: cellX to: cellY do: block 	XYChain cellsWith: point x		from: cellX		with: point y		to: cellY		using: pairs		do: 		[: chain | ( chain size even or: [ true ]) ifTrue: 				[	combinations remove: point ifAbsent: nil.					block notNil ifTrue: 						[ | stream subChain |							subChain := chain copyFrom: 2 to: chain size - 1.							stream := String new writeStream.							stream nextPutAll: XYChain niceName.							stream space.							subChain inject: point x								into: 								[: other : cell |									other printOn: stream.									stream nextPut: $-.									cell candidates detect: [: v | v ~= other ]								].							point y printOn: stream.							block value: stream contents value: subChain						].					^ self				]		].</body><body package="SudokuSolving">reduceCombinationsWithChains: combinations grid: grid from: cellX aglingnedTo: cellY do: block 	| pairs |	pairs := OrderedCollection new.	cellX grid cellsDo: [: c | ( c hasCandidates and: [ cellX ~= c and: [ cellY ~= c and: [ c candidates size = 2 ]]]) ifTrue: [ pairs add: c ]].	combinations copy do: [: point | self reduceCombinations: combinations remove: point withChainsFrom: pairs from: cellX to: cellY do: block ].</body></methods><methods><class-id>Sudoku.ChainedAlignedPairExclusion class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 400</body></methods><methods><class-id>Sudoku.NakedTuple</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	| cells house |	cells := positions collect: [: p | grid cellAtX: p x y: p y ].	house := type = #row 			ifTrue: [ cells anyElement row ]			ifFalse: 			[	type = #column 					ifTrue: [ cells anyElement column ]					ifFalse: [ cells anyElement box ]			].	^ self class modifyHouse: house tuple: tuple of: cells	"apply rule"</body></methods><methods><class-id>Sudoku.NakedTuple class</class-id> <category>modify</category><body package="SudokuSolving">modifyHouse: house tuple: tuple of: cells 	| modified |	modified := false.	house 		do: [: cell | ( cells includes: cell ) not ifTrue: [ tuple do: [: value | ( cell removeCandidate: value ) notNil ifTrue: [ modified := true ]]]].	^ modified</body></methods><methods><class-id>Sudoku.NakedTuple class</class-id> <category>instance creation</category><body package="SudokuSolving">tipsInHouse: houses grid: grid type: type tupleSize: tupleSize context: context do: block 	houses keysAndValuesDo: 		[: index : house | | cellTuple |			cellTuple := house select: [: cell | cell hasCandidates and: [ cell candidates size &lt;= tupleSize ]].			cellTuple subCollectionsSized: tupleSize				do: 				[: subCollection | | tuple modified |					tuple := Set new.					subCollection do: [: cell | tuple addAll: cell candidates ].					modified := tuple size &lt;= tupleSize and: [ self modifyHouse: house tuple: tuple of: subCollection	"apply rule" ].					modified ifTrue: [ block value: ( self type: type cells: subCollection tuple: tuple )]				]		].</body></methods><methods><class-id>Sudoku.NakedTuple class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	"medium - check all sakes"	| tupleSize |	tupleSize := self tupleSize.	^ tupleSize notNil 		ifTrue: [( tupleSize - 1 ) * 100 - 13 ]		ifFalse: [ nil ]</body></methods><methods><class-id>Sudoku.NakedQuads class</class-id> <category>accessing</category><body package="SudokuSolving">tupleSize	^ 4</body></methods><methods><class-id>Sudoku.NakedPair class</class-id> <category>accessing</category><body package="SudokuSolving">tupleSize	^ 2</body></methods><methods><class-id>Sudoku.HiddenQuads class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	"Hidden Quads are rare and can normally be by-passed by other strategies" 	^ 1000</body><body package="SudokuSolving">tupleSize	^ 4</body></methods><methods><class-id>Sudoku.FreeAlignedPairExclusion class</class-id> <category>modify</category><body package="SudokuSolving">combinationsWith: cellX with: cellY 	| combinations |	combinations := Set new.	cellX candidatesDo: 		[: xCandy |			cellY candidatesDo: [: yCandy | ( xCandy = yCandy or: [( cellX isSake: cellY ) not ]) ifFalse: [ combinations add: xCandy @ yCandy ]]		].	^ combinations</body></methods><methods><class-id>Sudoku.FreeAlignedPairExclusion class</class-id> <category>instance creation</category><body package="SudokuSolving">tipsIn: grid context: context do: block 	| cells |	cells := OrderedCollection new.	grid cellsDo: 		[: cellX |			cellX hasCandidates ifTrue: 				[	cells do: 						[: cellY | ( self removeCombinationsFrom: cellX alignedWith: cellY ) ifTrue: [ ^ block value: ( self cells: ( Array with: cellX with: cellY ))]						].					cells add: cellX				]		].</body></methods><methods><class-id>Sudoku.FreeAlignedPairExclusion class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 500</body></methods><methods><class-id>Sudoku.Normalizer</class-id> <category>compare</category><body package="SudokuSolving">comparableForCells: cells 	| positionsUsed result |	result := Array new: cells size.	positionsUsed := Candidates new.	cells do: 		[: cell | | givenOrNil newX |			givenOrNil := cell givenOrNil.			givenOrNil notNil ifTrue: 				[	newX := ( permXArray at: cell x ) detect: [: x | ( positionsUsed includes: x ) not ].					positionsUsed add: newX.					result at: newX put: ( permGiven at: givenOrNil )				]		].	^ result reverse</body><body package="SudokuSolving">comparableForRow: row 	| positionsUsed result |	result := Array new: row size.	positionsUsed := Candidates new.	row do: 		[: cell | | givenOrNil newX |			givenOrNil := cell givenOrNil.			givenOrNil notNil ifTrue: 				[	newX := self bestX: cell notIn: positionsUsed.					positionsUsed add: newX.					result at: newX put: ( permGiven at: givenOrNil )				]		].	^ result</body><body package="SudokuSolving">compareCandidateArray: r1 with: r2 	r1 with: r2		do: 		[: candidatesA : candidatesB |			candidatesA isNil 				ifTrue: [ candidatesB notNil ifTrue: [ ^ -1 ]]				ifFalse: 				[	candidatesB isNil ifTrue: [ ^ 1 ].					( candidatesA first &lt; candidatesB first and: [( candidatesA includes: candidatesB first ) not ]) ifTrue: [ ^ -1 ].					( candidatesB first &lt; candidatesA first and: [( candidatesB includes: candidatesA first ) not ]) ifTrue: [ ^ 1 ]				]		].	^ 0</body><body package="SudokuSolving">compareCell: cell1 with: cell2 	| a b |	a := permBoxX at: cell1 boxX.	b := permBoxX at: cell2 boxX.	a first &lt; b first ifTrue: [ ^ -1 ].	b first &lt; a first ifTrue: [ ^ 1 ].	a := permXArray at: cell1 x.	b := permXArray at: cell2 x.	( a first &lt; b first and: [( a includes: b first ) not ]) ifTrue: 		[	^ cell1 boxX = cell2 boxX 				ifTrue: [ -1 ]				ifFalse: [ 1 ]		].	( b first &lt; a first and: [( b includes: a first ) not ]) ifTrue: 		[	^ cell1 boxX = cell2 boxX 				ifTrue: [ 1 ]				ifFalse: [ -1 ]		].	a := permGiven at: cell1 givenOrNil.	b := permGiven at: cell2 givenOrNil.	( a first &lt; b first and: [( a includes: b first ) not ]) ifTrue: 		[	^ cell1 boxX = cell2 boxX 				ifTrue: [ 1 ]				ifFalse: [ -1 ]		].	( b first &lt; a first and: [( b includes: a first ) not ]) ifTrue: 		[	^ cell1 boxX = cell2 boxX 				ifTrue: [ -1 ]				ifFalse: [ 1 ]		].	cell1 boxX = cell2 boxX ifTrue: [ ^ 0 ].	a := 0.	b := 0.	cell1 row do: 		[: c |			c givenOrNil notNil ifTrue: 				[	c boxX = cell1 boxX 						ifTrue: [( self compareCell: cell1 with: c ) = 0 ifTrue: [ a := a + 1 ]]						ifFalse: [ c boxX = cell2 boxX ifTrue: [( self compareCell: c with: cell2 ) = 0 ifTrue: [ b := b + 1 ]]]				]		].	^ a = b 		ifTrue: [ 0 ]		ifFalse: 		[	a &lt; b 				ifTrue: [ -1 ]				ifFalse: [ 1 ]		]</body><body package="SudokuSolving">compareCell: cell1 withSameBoxX: cell2 	| a b |	a := permXArray at: cell1 x.	b := permXArray at: cell2 x.	( a first &lt; b first and: [( a includes: b first ) not ]) ifTrue: [ ^ -1 ].	( b first &lt; a first and: [( b includes: a first ) not ]) ifTrue: [ ^ 1 ].	a := permGiven at: cell1 givenOrNil.	b := permGiven at: cell2 givenOrNil.	( a first &lt; b first and: [( a includes: b first ) not ]) ifTrue: [ ^ 1 ].	( b first &lt; a first and: [( b includes: a first ) not ]) ifTrue: [ ^ -1 ].	^ 0</body><body package="SudokuSolving">compareTo: carnonicalScramble 	movedRows with: carnonicalScramble movedRows		do: 		[: r1 : r2 | | cmp1 cmp2 result |			cmp1 := self comparableForRow: r1.			cmp2 := carnonicalScramble comparableForRow: r2.			result := self compareCandidateArray: cmp1 with: cmp2.			0 == result ifFalse: [ ^ result ]		].	^ 0</body><body package="SudokuSolving">findBestComparedTo: result 	| rows newResult best boxYOrNil |	rows := grid rows.	boxYOrNil := movedRows size \\ grid height = 0 			ifTrue: [ nil ]			ifFalse: [ movedRows last anyElement boxY ].	newResult := result.	best := result anyElement.	rows do: 		[: row | | copy cmp |			(( movedRows includes: row ) not and: [ boxYOrNil isNil or: [ boxYOrNil = row anyElement boxY ]]) ifTrue: 				[	copy := self copy.					copy addNextRow: row.					cmp := best isNil 							ifTrue: [ 1 ]							ifFalse: [ best compareTo: copy ].					cmp &lt; 0 ifFalse: 						[	cmp = 0 ifFalse: 								[	best := copy.									newResult := OrderedCollection new								].							newResult add: copy						]				]		].	^ newResult</body></methods><methods><class-id>Sudoku.Normalizer</class-id> <category>adding</category><body package="SudokuSolving">addNextRow: row 	movedRows := movedRows copyWith: row.	self fullMinimizeWeight.</body></methods><methods><class-id>Sudoku.Normalizer</class-id> <category>accessing</category><body package="SudokuSolving">bestX: cell notIn: used 	( permBoxX at: cell boxX ) do: 		[: boxX | | base |			base := ( boxX - 1 ) * grid height.			( permXArray at: cell x ) do: 				[: x | | result |					result := base + x.					( used includes: result ) ifFalse: [ ^ result ]				]		].	^ 0</body><body package="SudokuSolving">grid	^ grid</body><body package="SudokuSolving">grid: aGrid 	grid := aGrid.</body><body package="SudokuSolving">movedRows	^ movedRows</body><body package="SudokuSolving">scramble	| xArray yArray used gArray |	used := Candidates new.	xArray := Array new: grid gridMaxValue.	grid rows first do: 		[: cell | | newX |			newX := self bestX: cell notIn: used.			used add: newX.			xArray at: cell x put: newX		].	yArray := Scramble reverseArray: ( movedRows collect: [: row | row first y ]).	used := Candidates new.	gArray := Array new: grid gridMaxValue.	permGiven keysAndValuesDo: 		[: given : candidates | | next |			next := candidates detect: [: c | ( used includes: c ) not ].			used add: next.			gArray at: given put: next		].	^ swapped 		ifTrue: [ Scramble permXArray: yArray permYArray: xArray permGiven: gArray swap: swapped ]		ifFalse: [ Scramble permXArray: xArray permYArray: yArray permGiven: gArray swap: swapped ]</body><body package="SudokuSolving">swapped: boolean 	swapped := boolean.</body></methods><methods><class-id>Sudoku.Normalizer</class-id> <category>copying</category><body package="SudokuSolving">postCopy	super postCopy.	permGiven := permGiven copy.	permBoxX := permBoxX copy.	permXArray := permXArray copy.</body></methods><methods><class-id>Sudoku.Normalizer</class-id> <category>minimize</category><body package="SudokuSolving">fullMinimizeWeight	( movedRows contains: [: row | self maximizeBoxPosInRow: row ]) ifTrue: [ ^ self fullMinimizeWeight ].	( movedRows contains: [: row | self maximizePosInEachBox: row ]) ifTrue: [ ^ self fullMinimizeWeight ].	( movedRows contains: [: row | self minimizeGivenInEachBox: row ]) ifTrue: [ ^ self fullMinimizeWeight ].</body><body package="SudokuSolving">maximizeBoxPosInRow: row 	| subRows boxDict changed |	( permBoxX contains: [: cand | cand size &gt; 1 ]) ifFalse: [ ^ false ].	subRows := row groupedBy: [: cell | cell boxX ].	boxDict := Dictionary new.	changed := false.	subRows keysAndValuesDo: [: boxX : cells | boxDict at: boxX put: ( self comparableForCells: cells )].	[ boxDict isEmpty ] whileFalse: 		[ | rowsNext biggest cmp |			rowsNext := biggest := nil.			boxDict keysAndValuesDo: 				[: boxX : comparable |					cmp := biggest isNil 							ifTrue: [ -1 ]							ifFalse: [ self compareCandidateArray: biggest with: comparable ].					cmp &lt; 0 ifTrue: 						[	biggest := comparable.							rowsNext := OrderedCollection new						].					cmp &gt; 0 ifFalse: [ rowsNext add: boxX ]				].			rowsNext do: 				[: boxX | | range |					range := permBoxX at: boxX.					range size &gt; rowsNext size ifTrue: 						[	changed := true.							range := range copy.							rowsNext size + 1 to: range size do: [: i | range remove: range first ].							permBoxX at: boxX put: range.							permBoxX keysAndValuesDo: [: i : r | ( rowsNext includes: i ) ifFalse: [ permBoxX at: i put: r - range ]]						].					boxDict removeKey: boxX				]		].	^ changed</body><body package="SudokuSolving">maximizePosInEachBox: row 	| modified |	( row contains: [: cell | ( permXArray at: cell x ) size &gt; 1 ]) ifFalse: [ ^ false ].	modified := false.	1 to: permBoxX size		do: 		[: boxX | | cellsToPlace |			cellsToPlace := row select: [: cell | cell givenOrNil notNil and: [ cell boxX = boxX ]].			[ cellsToPlace contains: [: cell | ( permXArray at: cell x ) size &gt; 1 ]] whileTrue: 				[ | nextToPlace best |					best := nextToPlace := nil.					cellsToPlace do: 						[: cell | | cmp |							cmp := best notNil 									ifTrue: [ self compareCell: cell withSameBoxX: best ]									ifFalse: [ -1 ].							cmp &lt; 0 ifTrue: 								[	best := cell.									nextToPlace := Candidates new								].							cmp &gt; 0 ifFalse: [ nextToPlace add: cell x ]						].					nextToPlace do: 						[: x | | range |							range := permXArray at: x.							range size &gt; nextToPlace size ifTrue: 								[	range := range copy.									nextToPlace size + 1 to: range size do: [: i | range remove: range first ].									row do: 										[: cell |											cell boxX = boxX ifTrue: 												[( nextToPlace includes: cell x ) 														ifTrue: [ permXArray at: cell x put: range ]														ifFalse: [ permXArray at: cell x put: ( permXArray at: cell x ) - range ]												]										].									modified := true								]						].					cellsToPlace := cellsToPlace reject: [: cell | nextToPlace includes: cell x ]				]		].	^ modified</body><body package="SudokuSolving">minimizeGivenInEachBox: row 	| cellsToPlace |	cellsToPlace := row select: [: cell | cell givenOrNil notNil ].	[ cellsToPlace contains: [: cell | ( permGiven at: cell givenOrNil ) size &gt; 1 ]] whileTrue: 		[ | givensToMinimize best range |			best := givensToMinimize := nil.			cellsToPlace do: 				[: cell | | minX |					minX := self bestX: cell notIn: #( ).					( best isNil or: [ minX &lt; best ]) ifTrue: 						[	best := minX.							givensToMinimize := Candidates new						].					minX = best ifTrue: [ givensToMinimize add: cell givenOrNil ]				].			range := permGiven at: givensToMinimize anyElement.			range size &gt; givensToMinimize size ifTrue: 				[	range := range copy.					givensToMinimize size + 1 to: range size do: [: i | range remove: range last ].					permGiven keysAndValuesDo: 						[: given : r | ( givensToMinimize includes: given ) 								ifTrue: [ permGiven at: given put: range ]								ifFalse: [ permGiven at: given put: r - range ]						].					^ true				].			cellsToPlace := cellsToPlace reject: [: cell | givensToMinimize includes: cell givenOrNil ]		].	^ false</body></methods><methods><class-id>Sudoku.Normalizer</class-id> <category>initialize-release</category><body package="SudokuSolving">initialize	swapped := false.	movedRows := #( ).	permGiven := ( 1 to: grid gridMaxValue ) collect: [: i | Candidates withAll: ( 1 to: grid gridMaxValue )].	permBoxX := ( 1 to: grid height ) collect: [: i | Candidates withAll: ( 1 to: grid width )].	permXArray := ( 1 to: grid gridMaxValue ) collect: [: i | Candidates withAll: ( 1 to: grid height )].</body></methods><methods><class-id>Sudoku.Normalizer class</class-id> <category>initialize-release</category><body package="SudokuSolving">canonicalScramble: grid 	| result new |	result := OrderedCollection with: ( Normalizer grid: grid ) with: ( Normalizer swapped: grid ).	[	new := result inject: OrderedCollection new into: [: r : c | c findBestComparedTo: r ].		new isEmpty	] whileFalse: [ result := new ].	^ (( result collect: [: e | e scramble ]) sortedBy: [: scramble | ( scramble scrambleGrid: grid ) simpleString ]) first</body><body package="SudokuSolving">grid: grid 	^ ( self new )		grid: grid;		initialize;		yourself</body></methods><methods><class-id>Sudoku.Normalizer class</class-id> <category>utility</category><body package="SudokuSolving">swapped: grid 	| scramble |	scramble := Scramble unionWidth: grid width height: grid height.	scramble swap: true.	^ ( self grid: ( scramble scrambleGrid: grid ))		swapped: true;		yourself</body></methods><methods><class-id>Sudoku.CellAdornment</class-id> <category>accessing</category><body package="SudokuSolving">background	^ background</body><body package="SudokuSolving">background: aBackground 	background := aBackground.</body><body package="SudokuSolving">backgroundColor	^ backgroundColor</body><body package="SudokuSolving">backgroundColor: aColor 	backgroundColor:= aColor</body><body package="SudokuSolving">candidate: candidate color: color 	colors size &lt; candidate ifTrue: 		[ | newArray |			newArray := colors species withSize: candidate.			newArray replaceFrom: 1 to: colors size with: colors startingAt: 1.			colors := newArray		].	colors at: candidate put: color.</body><body package="SudokuSolving">colorAt: i 	^ ( colors isNil or: [ colors size &lt; i ]) 		ifTrue: [ nil ]		ifFalse: [ colors at: i ]</body><body package="SudokuSolving">colors	^ colors</body><body package="SudokuSolving">colors: newColors 	colors := newColors.</body><body package="SudokuSolving">defaultGivenValue	^ colors indexOf: #setCandidate ifAbsent: [ nil ]</body><body package="SudokuSolving">defaultRemoveValue	^ colors indexOf: #removeCandidate ifAbsent: [ nil ]</body><body package="SudokuSolving">modifyGrid: grid 	colors keysAndValuesDo: 		[: candidate : colorSymbol |			colorSymbol == #setCandidate ifTrue: [( grid cellAtX: cellPosition x y: cellPosition y ) given: candidate ].			colorSymbol == #removeCandidate ifTrue: [( grid cellAtX: cellPosition x y: cellPosition y ) removeCandidate: candidate ]		].</body><body package="SudokuSolving">position: aPosition 	cellPosition := aPosition.</body><body package="SudokuSolving">sudokuCellPosition	^ cellPosition</body></methods><methods><class-id>Sudoku.CellAdornment</class-id> <category>copying</category><body package="SudokuSolving">copyAdronmentFrom: celAdornment 	background isNil ifTrue: [ background := celAdornment background ].	celAdornment colors 		keysAndValuesDo: [: candidate : colorSymbol | ( self colorAt: candidate ) isNil ifTrue: [ self candidate: candidate color: colorSymbol ]].</body><body package="SudokuSolving">postCopy	super postCopy.	colors := colors copy</body></methods><methods><class-id>Sudoku.CellAdornment class</class-id> <category>instance creation</category><body package="SudokuSolving">position: position 	^ ( self new )		position: position;		colors: #( );		yourself</body></methods><methods><class-id>Sudoku.SolvingContext</class-id> <category>accessing</category><body package="SudokuSolving">maxDifficulty	maxDifficulty isNil ifTrue: [ self maxDifficulty: Backtracking difficulty - 1 ].	^ maxDifficulty</body><body package="SudokuSolving">maxDifficulty: integer 	maxDifficulty := integer.	strategies notNil ifTrue: [ strategies := strategies select: [: c | c difficulty &lt;= maxDifficulty ]].</body><body package="SudokuSolving">randomOrNil	^ randomOrNil</body><body package="SudokuSolving">randomOrNil: random 	randomOrNil := random.</body><body package="SudokuSolving">strategies	strategies isNil ifTrue: [ self strategies: ( SolvingStrategy allSubclasses select: [: c | c difficulty notNil ])].	^ strategies</body><body package="SudokuSolving">strategies: aStrategies 	strategies := aStrategies asSortedCollection: [: c1 : c2 | c1 difficulty &lt; c2 difficulty ].	maxDifficulty notNil ifTrue: [ strategies := strategies select: [: c | c difficulty &lt;= maxDifficulty ]].</body></methods><methods><class-id>Sudoku.SolvingContext</class-id> <category>solving</category><body package="SudokuSolving">nextTipFor: grid 	self tipsIn: grid do: [: tip | ^ tip ].	^ nil</body><body package="SudokuSolving">solveGrid: grid 	| tip | 	[	tip := self nextTipFor: grid.		tip notNil and: [ tip canModifyGrid ]	] whileTrue: [ tip solveGrid: grid ].	^ tip notNil and: [ tip valid ]</body><body package="SudokuSolving">solveUnique: grid 	| tip | 	[	tip := self nextTipFor: grid.		( tip notNil and: [ tip isSingleSolutionFor: grid context: self ]) ifFalse: [ ^ false ].		tip canModifyGrid	] whileTrue: [ tip solveGrid: grid ].	^ tip valid</body><body package="SudokuSolving">tipsIn: grid do: block 	self strategies do: [: class | class tipsIn: grid context: self do: block ].</body></methods><methods><class-id>Sudoku.SolvingContext class</class-id> <category>instance creation</category><body package="SudokuSolving">forValidation	^ self strategies: ( SolvingStrategy allSubclasses select: [: c | c isForValidation and: [ c difficulty notNil ]])</body><body package="SudokuSolving">maxDifficulty: integer 	^ ( self new )		maxDifficulty: integer;		yourself</body><body package="SudokuSolving">strategies: strategies 	^ ( self new )		strategies: strategies;		yourself</body><body package="SudokuSolving">usingManualStrategies	^ self maxDifficulty: Backtracking difficulty - 1</body></methods><methods><class-id>Sudoku.SolvingContext class</class-id> <category>utility</category><body package="SudokuSolving">nextTipFor: grid 	^ self new nextTipFor: grid</body><body package="SudokuSolving">solveGrid: grid 	^ self new solveGrid: grid</body></methods><methods><class-id>Sudoku.GridFactory</class-id> <category>actions</category><body package="SudokuSolving">cellsToFill: probe solution: solution 	| allCells |	allCells := OrderedCollection new.	probe cellsDo: [: c | allCells add: random next -&gt; c ].	allCells := allCells asSortedCollection: [: assoc1 : assoc2 | assoc1 key &lt;= assoc2 key ].	^ allCells collect: [: assoc | assoc value ]</body><body package="SudokuSolving">createNewGrid	| max initialGrid bestGrid bestLevel solution |	max := timeout notNil 			ifTrue: [ Time microsecondClock + timeout ]			ifFalse: [ nil ].	bestGrid := bestLevel := nil.	[ | grid solvableWith |		initialGrid := ( Scramble newWidth: dimension x height: dimension y random: random ) scrambleGrid: self initialGrid.		solution := self solutionFor: initialGrid.		grid := self createNewGridFrom: initialGrid solution: solution.		solvableWith := self class levelFor: grid.		( solvableWith notNil and: [ bestLevel isNil or: [ solvableWith &gt; bestLevel ]]) ifTrue: 			[	bestLevel := solvableWith.				bestGrid := grid			].		bestGrid isNil or: [( max isNil or: [ max &gt; Time microsecondClock ]) and: [ bestLevel isNil or: [ level &gt; bestLevel ]]]	] whileTrue.	^ bestGrid</body><body package="SudokuSolving">createNewGridFrom: initialGrid solution: solution 	"SolvingContext forValidation solveUnique: grid copy "	| probe allCells solvingContext grid needingSingleSolution |	needingSingleSolution := level strategies select: [: e | e needsSingleSolution ].	solvingContext := needingSingleSolution notEmpty 			ifTrue: [ SolvingContext strategies: ( level strategies reject: [: e | e needsSingleSolution ])]			ifFalse: [ SolvingContext strategies: level strategies ].	[	grid := initialGrid copy.		probe := grid copy.		allCells := self cellsToFill: probe solution: solution.		[ solvingContext solveGrid: probe ] whileFalse: 			[ | cellToCopy |				cellToCopy := allCells detect: [: c | c hasCandidates ].				cellToCopy copyFrom: solution to: grid.				cellToCopy copyFrom: solution to: probe.				( needingSingleSolution notEmpty and: [ SolvingContext forValidation solveUnique: grid copy ]) ifTrue: 					[	needingSingleSolution := #( ).						solvingContext := SolvingContext strategies: level strategies					]			].		probe isValid and: [ SolvingContext forValidation solveUnique: grid copy ]	] whileFalse.	^ grid</body><body package="SudokuSolving">initialGrid	^ dimension = ( 3 @ 3 ) 		ifTrue: [ self class defaultInitialGrid ]		ifFalse: [ Grid width: dimension x height: dimension y ]</body><body package="SudokuSolving">solutionFor: initialGrid 	| solution forValidation |	solution := initialGrid copyAsFastGrid.	forValidation := SolvingContext forValidation.	( forValidation solveGrid: solution ) ifFalse: [ forValidation error: 'can not solve ' , initialGrid asString ].	^ solution</body></methods><methods><class-id>Sudoku.GridFactory</class-id> <category>accessing</category><body package="SudokuSolving">dimension	^ dimension</body><body package="SudokuSolving">dimension: aDimension 	dimension := aDimension.</body><body package="SudokuSolving">grid	^ self createNewGrid</body><body package="SudokuSolving">level	^ level</body><body package="SudokuSolving">level: newLevel 	level := newLevel.</body><body package="SudokuSolving">random: aRandom 	random := aRandom.</body><body package="SudokuSolving">timeout	^ timeout</body><body package="SudokuSolving">timeout: aTimeout 	timeout := aTimeout.</body></methods><methods><class-id>Sudoku.GridFactory</class-id> <category>initialize-release</category><body package="SudokuSolving">initialize	random := Random new.</body></methods><methods><class-id>Sudoku.GridFactory class</class-id> <category>instance creation</category><body package="SudokuSolving">defaultInitialGrid	^ Grid fromString: '7.8...3.....2.1...5.........4.....263...8.......1...9..9.6....4....7.5...........'</body><body package="SudokuSolving">dimension: point 	^ self dimension: point level: self defaultLevel</body><body package="SudokuSolving">dimension: point level: level 	^ ( self new )		dimension: point;		level: level;		initialize;		yourself</body><body package="SudokuSolving">level: level 	^ self dimension: 3 @ 3 level: level</body></methods><methods><class-id>Sudoku.GridFactory class</class-id> <category>utility</category><body package="SudokuSolving">defaultLevel	"self defaultLevel"	| level |	level := SolvingLevel name: #sudokuEasyLevel &gt;&gt; 'Easy'			strategies: ( ( OrderedCollection new )					add: HiddenSingle;					add: Done;					add: CoverdByNeighbours;					yourself )			minor: nil.	^ SolvingLevel name: #sudokuNormalLevel &gt;&gt; 'Normal'		strategies: ( ( OrderedCollection new )				add: NakedSingle;				add: NakedPair;				add: IntersectionRemoval;				yourself )		minor: level</body><body package="SudokuSolving">defaultLevels	"self defaultLevels"	| level |	level := SolvingLevel name: #sudokuAdvancedLevel &gt;&gt; 'Advanced'			strategies: ( ( OrderedCollection new )					add: HiddenPair;					add: NakedQuads;					add: HiddenTriples;					add: NakedTriples;					add: YWing;					add: XWing;					add: UniqueRectangle;					yourself )			minor: self defaultLevel.	level := SolvingLevel name: #sudokuExtremeLevel &gt;&gt; 'Extreme'			strategies: ( ( OrderedCollection new )					add: AlignedPairExclusion;					add: SingleChain;					add: HiddenQuads;					add: SwordFish;					add: XYChain;					yourself )			minor: level.	level := SolvingLevel name: #sudokuEvilLevel &gt;&gt; 'Evil'			strategies: ( ( OrderedCollection new )					add: ExtendedAlignedPairExclusion;					add: JellyFish;					add: SquirmBag;					add: WXYZWing;					add: NiceLoops;					add: MultivalueXWing;					add: MultiColouring;					yourself )			minor: level.	level := SolvingLevel name: #sudokuImpossibleLevel &gt;&gt; 'Impossible'			strategies: ( ( OrderedCollection new )					add: ChainedAlignedPairExclusion;					add: FreeAlignedPairExclusion;					add: AlmostLockedSetXYWing;					add: AlmostLockedSetXZ;					add: DeathBlossom;					yourself )			minor: level.	^ level levels</body><body package="SudokuSolving">levelFor: grid 	| probe |	probe := grid copy.	^ self defaultLevels 		detect: [: level | ( SolvingContext strategies: level strategies ) solveGrid: probe ]		ifNone: [ nil ]</body></methods><methods><class-id>Sudoku.AlmostLockedSet</class-id> <category>printing</category><body package="SudokuSolving">printOn: stream 	stream nextPut: $(.	cells 		do: [: cell | cell printOn: stream ]		separatedBy: [ stream space ].	joinedCandidates notNil ifTrue: 		[	stream space.			stream nextPut: ${.			joinedCandidates 				do: [: candidate | candidate printOn: stream ]				separatedBy: [ stream space ].			stream nextPut: $}		].	stream nextPut: $).</body></methods><methods><class-id>Sudoku.AlmostLockedSet</class-id> <category>accessing</category><body package="SudokuSolving">buildJoinedCandidates	| set |	set := Candidates new.	cells do: [: cell | set addAll: cell candidates ].	^ set</body><body package="SudokuSolving">cells	^ cells</body><body package="SudokuSolving">cells: aCells 	cells := aCells.</body><body package="SudokuSolving">commonSakesAt: candidate 	| oc first |	oc := OrderedCollection new.	first := cells first.	first allSakesDo: 		[: sake | ( sake hasCandidates and: 				[( sake candidatesIncludes: candidate ) 						and: [ cells allSatisfy: [: cell | cell = first or: [( cell candidatesIncludes: candidate ) not or: [ cell isSake: sake ]]]]				]) 				ifTrue: [ oc add: sake ]		].	^ oc</body><body package="SudokuSolving">includes: cell 	^ cells includes: cell</body><body package="SudokuSolving">joinedCandidates	joinedCandidates isNil ifTrue: [ joinedCandidates := self buildJoinedCandidates ].	^ joinedCandidates</body><body package="SudokuSolving">size	^ cells size</body></methods><methods><class-id>Sudoku.AlmostLockedSet class</class-id> <category>instance creation</category><body package="SudokuSolving">cells: cells 	^ ( self new )		cells: cells copy;		yourself	"sortedBy: [: cell | cell x + ( cell y / 10 )]"</body></methods><methods><class-id>Sudoku.SolvingLevel</class-id> <category>accessing</category><body package="SudokuSolving">levels	| collection |	collection := OrderedCollection new.	self levelsTo: collection.	^ collection</body><body package="SudokuSolving">levelsTo: collection 	minorLevel notNil ifTrue: [ minorLevel levelsTo: collection ].	collection add: self.</body><body package="SudokuSolving">minorLevel	^ minorLevel</body><body package="SudokuSolving">name	^ name</body><body package="SudokuSolving">name: string strategies: someStrategies minor: aLevel 	name := string.	directStrategies := someStrategies sortedBy: [: strategy | strategy difficulty ].	minorLevel := aLevel.</body><body package="SudokuSolving">strategies	| collection |	collection := OrderedCollection new.	self strategiesTo: collection.	^ collection</body><body package="SudokuSolving">strategiesTo: collection 	minorLevel notNil ifTrue: [ minorLevel strategiesTo: collection ].	collection addAll: directStrategies.</body></methods><methods><class-id>Sudoku.SolvingLevel</class-id> <category>printing</category><body package="SudokuSolving">displayString	^ name asString</body><body package="SudokuSolving">printOn: stream 	self class printOn: stream.	stream space.	stream nextPutAll: name asString.	stream nextPutAll: ' ('.	directStrategies 		do: 		[: strategy |			stream nextPutAll: strategy niceName.			stream nextPutAll: ': '.			strategy difficulty printOn: stream		]		separatedBy: [ stream space ].	stream nextPutAll: ')'.</body></methods><methods><class-id>Sudoku.SolvingLevel</class-id> <category>comparing</category><body package="SudokuSolving">&lt; level 	^ ( self &gt;= level ) not</body><body package="SudokuSolving">&lt;= level 	^ ( self &gt; level ) not</body><body package="SudokuSolving">= level 	^ self == level or: [ level class = self class and: [ self strategies = level strategies ]]</body><body package="SudokuSolving">&gt; level 	^ minorLevel notNil and: [ minorLevel &gt;= level ]</body><body package="SudokuSolving">&gt;= level 	^ self = level or: [ self &gt; level ]</body></methods><methods><class-id>Sudoku.SolvingLevel class</class-id> <category>instance creation</category><body package="SudokuSolving">name: string strategies: someStrategies minor: aLevel 	^ ( self new )		name: string strategies: someStrategies minor: aLevel;		yourself</body></methods><methods><class-id>Sudoku.GridAdornment</class-id> <category>accessing</category><body package="SudokuSolving">addAlphabetic: positions 	positions keysAndValuesDo: 		[: i : p | ( self getAdornmentAt: p )				backgroundColor: #modifyingSake1;				background: ( String with: ( Character value: 64 + i ))		].</body><body package="SudokuSolving">addFishX: xIn y: yIn candidate: number 	xIn do: [: x | yIn do: [: y | ( self position: x @ y candidate: number color: #modifyingSake1 ) background: 'X' ]].</body><body package="SudokuSolving">adornmentAt: cellPos ifAbsent: abentBlock 	^ cellAdornments 		detect: [: cellAdornment | cellAdornment sudokuCellPosition = cellPos ]		ifNone: abentBlock</body><body package="SudokuSolving">bestAdornmentAt: cellPos 	^ self adornmentAt: cellPos		ifAbsent: 		[	previousAdornment notNil 				ifTrue: [ previousAdornment bestAdornmentAt: cellPos ]				ifFalse: [ nil ]		]</body><body package="SudokuSolving">chain: chainString positions: positions candidate: candidate 	positions keysAndValuesDo: 		[: i : p | | color |			color := i odd 					ifTrue: [ #modifyingSake1 ]					ifFalse: [ #modifyingSake2 ].			( self position: p candidate: candidate color: color ) background: chainString		].</body><body package="SudokuSolving">copyAdronmentFrom: gridAdornment 	cellAdornments do: 		[: cellAdornment | | otherOrNil |			otherOrNil := gridAdornment bestAdornmentAt: cellAdornment sudokuCellPosition.			otherOrNil notNil ifTrue: [ cellAdornment copyAdronmentFrom: otherOrNil ]		].</body><body package="SudokuSolving">getAdornmentAt: cellPos 	^ self adornmentAt: cellPos ifAbsent: [ cellAdornments add: (CellAdornment position: cellPos) ]</body><body package="SudokuSolving">modifyGrid: grid 	nextAdornment notNil 		ifTrue: [ nextAdornment modifyGrid: grid ]		ifFalse: [ cellAdornments do: [: cellAdornment | cellAdornment modifyGrid: grid ]].</body><body package="SudokuSolving">nextAdornment	^ nextAdornment</body><body package="SudokuSolving">nextAdornment: adornment 	nextAdornment notNil 		ifTrue: [ nextAdornment nextAdornment: adornment ]		ifFalse: 		[	nextAdornment := adornment.			adornment previousAdornment: self		].</body><body package="SudokuSolving">position: position candidate: candidate color: color 	^ ( self getAdornmentAt: position )		candidate: candidate color: color;		yourself</body><body package="SudokuSolving">position: cellPos removeCandidate: candidate 	^ self position: cellPos candidate: candidate color: #removeCandidate</body><body package="SudokuSolving">position: cellPos setCandidate: given 	^ self position: cellPos candidate: given color: #setCandidate</body><body package="SudokuSolving">previousAdornment	^ previousAdornment</body><body package="SudokuSolving">previousAdornment: gridAdornment 	previousAdornment := gridAdornment.	self copyAdronmentFrom: gridAdornment.</body><body package="SudokuSolving">string	^ string</body><body package="SudokuSolving">string: aString 	string := aString.</body><body package="SudokuSolving">xyChain: cells candidate: initialCandidate 	self xyChain: cells candidate: initialCandidate stringBlock: [: i | String with: ( Character value: 64 + i )].</body><body package="SudokuSolving">xyChain: cells candidate: initialCandidate stringBlock: stringBlock 	| c1 |	c1 := initialCandidate.	cells keysAndValuesDo: 		[: i : cell | | color c2 |			cell candidates do: 				[: candidate |					color := candidate = c1 							ifTrue: [ #modifyingSake2 ]							ifFalse: 							[	c2 := candidate.								#modifyingSake1							].					( self position: cell sudokuCellPosition candidate: candidate color: color ) background: ( stringBlock value: i )				].			c1 := c2		].</body><body package="SudokuSolving">yWing: cells candidate: initialCandidate 	self xyChain: cells candidate: initialCandidate stringBlock: [: i | #( 'AC' 'AB' 'BC' ) at: i ].</body></methods><methods><class-id>Sudoku.GridAdornment</class-id> <category>copying</category><body package="SudokuSolving">postCopy	super postCopy.	cellAdornments := cellAdornments collect: [: cellAdornment | cellAdornment copy ]</body></methods><methods><class-id>Sudoku.GridAdornment</class-id> <category>initialize-release</category><body package="SudokuSolving">initialize	cellAdornments := OrderedCollection new.</body></methods><methods><class-id>Sudoku.GridAdornment class</class-id> <category>instance creation</category><body package="SudokuSolving">als: als index: i 	| alsName stream inst color |	color := #modifyingSake3.	i = 1 ifTrue: [ stream := #modifyingSake1 ].	i = 2 ifTrue: [ color := #modifyingSake2 ].	alsName := String with: ( Character value: 64 + i ).	stream := String new writeStream.	stream nextPutAll: 'ALS '.	stream nextPutAll: alsName.	inst := self string: stream contents.	als do: 		[: cell | ( inst getAdornmentAt: cell )				backgroundColor: color;				background: alsName		].	^ inst</body><body package="SudokuSolving">checkThisCell: position candidate: candidate 	^ (self string: #sudokuCheckThisCell &gt;&gt; 'Check this cell')		position: position setCandidate: candidate;		yourself</body><body package="SudokuSolving">focusOnCandidate: candidate 	^ self string: ((#sudokuFocusOn1s &gt;&gt; 'Focus on') asString expandMacrosWith: candidate printString)</body><body package="SudokuSolving">focusOnCells: cells 	^ self focusOnCells: cells candidates: nil</body><body package="SudokuSolving">focusOnCells: cells candidate: candidate 	^ self focusOnCells: cells candidates: ( Array with: candidate )</body><body package="SudokuSolving">focusOnCells: cells candidates: candidatesOrNil 	^ self focusOnCells: cells candidates: candidatesOrNil color: #modifyingSake1</body><body package="SudokuSolving">focusOnCells: cells candidates: candidatesOrNil color: color 	| adornment |	adornment := self string: #sudokuFocusOnTheseCells &gt;&gt; 'Focus on these Cells'.	cells do: 		[: cell | | candidates |			candidates := candidatesOrNil notNil 					ifTrue: [ candidatesOrNil ]					ifFalse: [ cell candidates ].			candidates do: [: candidate | adornment position: cell sudokuCellPosition candidate: candidate color: color ]		].	^ adornment</body><body package="SudokuSolving">new	^ (super new)		initialize;		yourself</body><body package="SudokuSolving">placeCandidate: candidate 	^ self string: ((#sudokuPlace1sHere &gt;&gt; 'Focus on') asString expandMacrosWith: candidate printString)</body><body package="SudokuSolving">remainingCombinations: combinations prefix: stringOrNil 	| string |	string := #sudokuPossibleCombiantions &gt;&gt; '' expandMacrosWith: combinations sudokuCombinationsString.	stringOrNil notNil ifTrue: [ string := stringOrNil , ' ' , string ].	^ self string: string</body><body package="SudokuSolving">string: string 	^ (self new)		string: string;		yourself</body></methods><methods><class-id>Sudoku.FinalStateDetection</class-id> <category>accessing</category><body package="SudokuSolving">solveGrid: grid 	"nope"</body><body package="SudokuSolving">valid	^ false</body></methods><methods><class-id>Sudoku.FinalStateDetection class</class-id> <category>accessing</category><body package="SudokuSolving">niceName	^ ( #sudokuNotSolvable &gt;&gt; 'Not solvable!' ) asString , ' - ' , super niceName</body></methods><methods><class-id>Sudoku.FinalStateDetection class</class-id> <category>testing</category><body package="SudokuSolving">canModifyGrid	^ false</body><body package="SudokuSolving">isForValidation	^ true</body></methods><methods><class-id>Sudoku.Scramble</class-id> <category>private</category><body package="SudokuSolving">basicReverse	| tmp |	permXArray := self class reverseArray: permXArray.	permYArray := self class reverseArray: permYArray.	permGiven := self class reverseArray: permGiven.	swap ifTrue: 		[	tmp := permXArray.			permXArray := permYArray.			permYArray := tmp		].</body><body package="SudokuSolving">linePermutation: random groupSize: gSize groupCount: count 	| permArray pos |	permArray := Array new: gSize * count.	pos := 0.	(( 1 to: count ) sortedBy: [: yy | random next ]) do: 		[: baseY |			"bigRow"			(( 1 to: gSize ) sortedBy: [: y | random next ]) do: 				[: offsetY |					pos := pos + 1.					permArray at: pos put: ( baseY - 1 ) * gSize + offsetY				]		].	^ permArray</body><body package="SudokuSolving">reverseArray: array 	^ ( 1 to: array size ) collect: [: i | array indexOf: i ]</body></methods><methods><class-id>Sudoku.Scramble</class-id> <category>initialize-release</category><body package="SudokuSolving">height: height width: width random: random 	"permutate "	permXArray := self linePermutation: random groupSize: width groupCount: height.	"6x6x6 x6 combinations"	permYArray := self linePermutation: random groupSize: height groupCount: width.	"6x6x6 x6 combinations"	permGiven := ( 1 to: height * width ) sortedBy: [: v | random next ].	"9! Kombinations"	swap := height = width and: [ random next &lt; 0.5 ].	"2 kombinations"</body><body package="SudokuSolving">permXArray: array1 permYArray: array2 permGiven: array3 swap: boolean 	permXArray := array1.	permYArray := array2.	permGiven := array3.	swap := boolean.</body><body package="SudokuSolving">unionWidth: width height: height 	"permutate "	permXArray := permYArray := permGiven := ( 1 to: height * width ) asArray.	swap := false.</body></methods><methods><class-id>Sudoku.Scramble</class-id> <category>accessing</category><body package="SudokuSolving">reverse	^ ( self copy )		basicReverse;		yourself</body><body package="SudokuSolving">scrambleCell: cell 	| result pos candidates |	result := SimpleCell new.	pos := self scramblePos: cell.	result x: pos x.	result y: pos y.	cell hasCandidates 		ifTrue: 		[	candidates := Candidates new.			cell candidates do: [: e | candidates add: ( self scrambleGiven: e )].			result given: candidates		]		ifFalse: [ result given: ( self scrambleGiven: cell givenOrNil )].	^ result</body><body package="SudokuSolving">scrambleGiven: givenOrNil 	^ givenOrNil notNil 		ifTrue: [ permGiven at: givenOrNil ]		ifFalse: [ givenOrNil ]</body><body package="SudokuSolving">scrambleGrid: grid 	| result |	result := swap 			ifTrue: [ grid species width: grid height height: grid width ]			ifFalse: [ grid species width: grid width height: grid height ].	grid cellsDo: [: cell | ( self scrambleCell: cell ) copyTo: result ].	^ result</body><body package="SudokuSolving">scramblePos: pos 	^ swap 		ifTrue: [( permYArray at: pos y ) @ ( permXArray at: pos x )]		ifFalse: [( permXArray at: pos x ) @ ( permYArray at: pos y )]</body><body package="SudokuSolving">swap	^ swap</body><body package="SudokuSolving">swap: aSwap 	swap := aSwap.</body></methods><methods><class-id>Sudoku.Scramble class</class-id> <category>initialize-release</category><body package="SudokuSolving">new	^ self newWidth: 3 height: 3</body><body package="SudokuSolving">newWidth: width height: height 	^ self newWidth: width height: height random: Random new</body><body package="SudokuSolving">newWidth: width height: height random: random 	^ ( self basicNew )		height: height width: width random: random;		yourself</body><body package="SudokuSolving">permXArray: array1 permYArray: array2 permGiven: array3 swap: boolean 	^ ( self basicNew )		permXArray: array1 permYArray: array2 permGiven: array3 swap: boolean;		yourself</body><body package="SudokuSolving">scrambleGrid: grid 	^ ( self newWidth: grid width height: grid height ) scrambleGrid: grid</body><body package="SudokuSolving">unionWidth: width height: height 	^ ( self basicNew )		unionWidth: width height: height;		yourself</body></methods><methods><class-id>Sudoku.Scramble class</class-id> <category>private</category><body package="SudokuSolving">reverseArray: array 	^ ( 1 to: array size ) collect: [: i | array indexOf: i ]</body></methods><methods><class-id>Sudoku.HintToCell</class-id> <category>accessing</category><body package="SudokuSolving">cellPosition: point 	cellPos := point.</body><body package="SudokuSolving">given: aValue 	given := aValue.</body></methods><methods><class-id>Sudoku.HintToCell</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments |	gridAdornments := super adornmentsIn: grid.	self explainTo: gridAdornments.	^ gridAdornments</body><body package="SudokuSolving">explainTo: gridAdornments 	gridAdornments nextAdornment: (GridAdornment checkThisCell: cellPos candidate: given).	gridAdornments nextAdornment: (GridAdornment placeCandidate: given)</body></methods><methods><class-id>Sudoku.HintToCell class</class-id> <category>instance creation</category><body package="SudokuSolving">cell: cell 	^ ( self new )		cellPosition: cell x @ cell y;		yourself</body><body package="SudokuSolving">cell: cell given: given 	^ ( self cell: cell )		given: given;		yourself</body></methods><methods><class-id>Sudoku.HintToCell class</class-id> <category>testing</category><body package="SudokuSolving">isForValidation	^ true</body></methods><methods><class-id>Sudoku.InferenceChain</class-id> <category>accessing</category><body package="SudokuSolving">cellSize	^ cells size</body><body package="SudokuSolving">cells	^ cells</body><body package="SudokuSolving">cells: someCells links: someLinks 	cells := someCells.	links := someLinks.</body><body package="SudokuSolving">continuous	^ continuous == true</body><body package="SudokuSolving">continuous: boolean 	continuous := boolean.</body><body package="SudokuSolving">firstCandidate	^ links first linkCandidate</body><body package="SudokuSolving">firstCell	^ cells first</body><body package="SudokuSolving">firstLink	^ links first</body><body package="SudokuSolving">lastCandidate	^ links last linkCandidate</body><body package="SudokuSolving">lastCell	^ cells last</body><body package="SudokuSolving">lastLink	^ links last</body><body package="SudokuSolving">links	^ links</body></methods><methods><class-id>Sudoku.InferenceChain</class-id> <category>chaining</category><body package="SudokuSolving">addLink: link cell: cell 	cells := cells copyWith: cell.	links := links copyWith: link.</body><body package="SudokuSolving">firstWeakLink: candidate cell: cell 	| newCells newLinks |	newCells := cells asOrderedCollection.	newCells addFirst: cell.	newLinks := links asOrderedCollection.	newLinks addFirst: candidate asWeakLink.	^ self species cells: newCells links: newLinks</body><body package="SudokuSolving">strongLink: candidate cell: cell 	^ ( self copy )		addLink: candidate asStrongLink cell: cell;		continuous: ( self continuous or: [ self lastLink isStrongLink and: [ self lastCell candidates size &gt; 2 ]]);		yourself</body><body package="SudokuSolving">weakLink: candidate cell: cell 	^ ( self copy )		addLink: candidate asWeakLink cell: cell;		yourself</body></methods><methods><class-id>Sudoku.InferenceChain</class-id> <category>modify</category><body package="SudokuSolving">modifyGridByNiceLoops	| cell first last modified |	first := self firstLink.	last := self lastLink.	cell := self firstCell.	"= chain last"	( first isStrongLink or: [ last isStrongLink ]) ifFalse: 		[	"TYPE 1 If the first cell has two weak links for the same candidate, that candidate can be eliminated from the cell."			first = last ifTrue: 				[	cell removeCandidate: first linkCandidate.					^ true				].			^ false		].	( first isStrongLink and: [ last isStrongLink ]) ifTrue: 		[	"TYPE 2 If the first cell has two strong links with the same candidate, then it can be solved with the links' candidate."			first = last ifTrue: 				[	cell given: first linkCandidate.					^ true				].			^ false		].	first linkCandidate = last linkCandidate ifFalse: 		[	"TYPE 3 If the first cell has a weak link and a strong link with different candidates, then the weak link's candidate can be eliminated from the cell. "			first isStrongLink 				ifTrue: [ cell removeCandidate: last linkCandidate ]				ifFalse: [ cell removeCandidate: first linkCandidate ].			^ true		].	"Continuous Nice Loop"	modified := false.	"If a cell has two strong links with different candidates, then all candidates except those two can be eliminated from the cell."	2 to: self cellSize - 1		do: 		[: i | | left right |			(( left := links at: i - 1 ) isStrongLink and: [( right := links at: i ) isStrongLink and: [( cell := cells at: i ) candidates size &gt; 2 ]]) ifTrue: 				[	modified := true.					cell candidatesDo: [: c | ( left linkCandidate ~~ c and: [ right linkCandidate ~~ c ]) ifTrue: [ cell removeCandidate: c ]]				]		].	"If two cells are joined by a weak link, then the link's candidate can be eliminated from any cells that are related to both of them"	links keysAndValuesDo: 		[: i : link |			link isStrongLink ifFalse: 				[	cell := cells at: i.					( cells at: i + 1 ) allSakesDo: 						[: sake | (( sake candidatesIncludes: link linkCandidate ) and: [ cell isSake: sake ]) ifTrue: 								[	modified := true.									sake removeCandidate: link linkCandidate								]						]				]		].	^ modified</body></methods><methods><class-id>Sudoku.InferenceChain</class-id> <category>printing</category><body package="SudokuSolving">printCellPos: i ion: stream 	| cell |	stream nextPut: $[.	cell := cells at: i.	stream nextPut: $R.	cell y printOn: stream.	stream nextPut: $C.	cell x printOn: stream.	stream nextPut: $].</body><body package="SudokuSolving">printOn: stream 	| c |	c := self lastLink isStrongLink ~= self firstLink isStrongLink and: [ self lastCandidate = self firstCandidate ].	c ifTrue: [ stream nextPut: $- ].	1 to: cells size - 1		do: 		[: i |			self printCellPos: i ion: stream.			( links at: i ) printLinkOn: stream		].	self printCellPos: cells size ion: stream.	c ifTrue: [ stream nextPut: $= ].</body></methods><methods><class-id>Sudoku.InferenceChain class</class-id> <category>instance creation</category><body package="SudokuSolving">cells: someCells links: someLinks 	^ ( self new )		cells: someCells links: someLinks;		yourself</body><body package="SudokuSolving">strongLinked: cells candidate: candidate 	^ self cells: cells links: ( Array with: candidate asStrongLink )</body></methods><methods><class-id>Sudoku.ForkedGridFactory</class-id> <category>accessing</category><body package="SudokuSolving">dimension: aDimension 	self restartProcessFor: [ super dimension: aDimension ].</body><body package="SudokuSolving">grid	| sem |	process notNil ifTrue: 		[	sem := Semaphore new.			recursionLock critical: 				[	process notNil 						ifTrue: [ semaphores add: sem ]						ifFalse: [ sem signal ]				].			sem wait		].	^ [ nextGrid ] ensure: [ self startProcess ]</body><body package="SudokuSolving">level: newLevel 	self restartProcessFor: [ super level: newLevel ].</body></methods><methods><class-id>Sudoku.ForkedGridFactory</class-id> <category>actions</category><body package="SudokuSolving">abortProcess	process notNil ifTrue: [ process terminate ].</body><body package="SudokuSolving">isDone	^ process isNil and: [ nextGrid notNil ]</body><body package="SudokuSolving">startProcess	self abortProcess.	( level notNil and: [ dimension notNil ]) ifTrue: 		[	process :=				[ | sem |					nextGrid := self createNewGrid.					process = Processor activeProcess ifTrue: 						[	recursionLock critical: 								[	process := nil.									[	recursionLock critical: [ sem := semaphores anyElement ].										sem notNil									] whileTrue: 										[	sem signal.											semaphores remove: sem										]								]						]				] forkAt: Processor userBackgroundPriority		].</body></methods><methods><class-id>Sudoku.ForkedGridFactory</class-id> <category>initialize-release</category><body package="SudokuSolving">initialize	super initialize.	recursionLock := RecursionLock new.	semaphores := Set new.	self startProcess.</body><body package="SudokuSolving">restartProcessFor: block 	self abortProcess.	block value.	self startProcess.</body></methods><methods><class-id>Sudoku.ForkedGridFactory</class-id> <category>copying</category><body package="SudokuSolving">postCopy	super postCopy.	process := nil.	self initialize.</body></methods><methods><class-id>Sudoku.Todo</class-id> <category>dummy</category><body package="SudokuSolving">solveGrid: grid 	self shouldNotImplement.</body></methods><methods><class-id>Sudoku.Fish</class-id> <category>accessing</category><body package="SudokuSolving">indices: newIndices 	indices := newIndices.</body><body package="SudokuSolving">modifyGrid: grid 	| rowsOrColumns |	rowsOrColumns := type = #column 			ifTrue: [ grid columns	"column" ]			ifFalse: [ grid rows	"row" ].	rowsOrColumns keysAndValuesDo: 		[: i : rowOrColumn | ( indices includes: i ) ifTrue: 				[	rowOrColumn 						keysAndValuesDo: [: j : cell | (( positions includes: j ) not and: [ cell candidatesIncludes: number ]) ifTrue: [ ^ false	"passt nicht" ]]				]		].	^ self class modifyIn: rowsOrColumns number: number indizes: indices cellPositions: positions</body><body package="SudokuSolving">number: int 	number := int.</body><body package="SudokuSolving">positions: newPositions 	positions := newPositions.</body><body package="SudokuSolving">type: newType 	type := newType.</body></methods><methods><class-id>Sudoku.Fish</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments gridAdornment xIn yIn |	gridAdornments := super adornmentsIn: grid.	gridAdornments nextAdornment: ( GridAdornment focusOnCandidate: number ).	gridAdornment := GridAdornment focusOnCandidate: number.	type = #column 		ifTrue: 		[	xIn := indices.			yIn := positions		]		ifFalse: 		[	yIn := indices.			xIn := positions		].	gridAdornment addFishX: xIn y: yIn candidate: number.	gridAdornments nextAdornment: gridAdornment.	self addModifiedCellsIn: grid to: gridAdornments.	^ gridAdornments</body></methods><methods><class-id>Sudoku.Fish class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	self = Fish ifTrue: [ ^ nil ].	^ self fishSize * 55</body><body package="SudokuSolving">fishSize	^ self subclassResponsibility</body><body package="SudokuSolving">isForValidation	^ true</body></methods><methods><class-id>Sudoku.Fish class</class-id> <category>modify</category><body package="SudokuSolving">modifyIn: rowsOrColumns number: number indizes: indices cellPositions: cellPositions 	"apply rule"	| modified |	modified := false.	rowsOrColumns keysAndValuesDo: 		[: i : cells | ( indices includes: i ) 				ifFalse: [ cellPositions do: [: pos | (( cells at: pos ) removeCandidate: number ) notNil ifTrue: [ modified := true ]]]		].	^ modified</body></methods><methods><class-id>Sudoku.Fish class</class-id> <category>instance creation</category><body package="SudokuSolving">allIndizesIn: rowsOrColumns indicesDone: indicesDone without: without number: number cellPositions: cellPositions do: block 	| minIndex maxIndex newWithout |	cellPositions size &gt; self fishSize ifTrue: [ ^ self ].	newWithout := without.	minIndex := indicesDone isEmpty 			ifTrue: [ 1 ]			ifFalse: [ indicesDone last + 1 ].	maxIndex := indicesDone size = self fishSize 			ifTrue: [ rowsOrColumns size ]			ifFalse: [ rowsOrColumns size - self fishSize + indicesDone size + 1 ].	minIndex to: maxIndex		do: 		[: index | | rowOrColumn2 newCellPositions |			rowOrColumn2 := rowsOrColumns at: index.			newCellPositions := self rowOrColumn: rowOrColumn2 match: number at: cellPositions without: newWithout.			newCellPositions notNil ifTrue: 				[	indicesDone size = self fishSize ifTrue: [ ^ self ].					self allIndizesIn: rowsOrColumns						indicesDone: ( indicesDone copyWith: index )						without: newWithout						number: number						cellPositions: newCellPositions						do: block.					indicesDone size = newCellPositions size 						ifTrue: [ ^ self ]						ifFalse: 						[	without == newWithout ifTrue: [ newWithout := without copy ].							newCellPositions do: [: pos | ( cellPositions includes: pos ) ifFalse: [ newWithout add: pos ]]						]				]		].	indicesDone size = self fishSize ifTrue: [ ^ block value: indicesDone value: cellPositions ].</body><body package="SudokuSolving">positions: newPositions indices: newIndices number: number type: type 	^ ( self new )		positions: newPositions;		indices: newIndices;		number: number;		type: type;		yourself</body><body package="SudokuSolving">rowOrColumn: rowOrColumn match: number at: cellPositions without: without 	| newPositions noMatch |	noMatch := true.	newPositions := nil.	rowOrColumn keysAndValuesDo: 		[: cellPos : cell | ( cellPositions includes: cellPos ) 				ifTrue: 				[	cell hasCandidates ifTrue: 						[( cell candidatesIncludes: number ) 								ifTrue: [ noMatch := false ]								ifFalse: [ ^ nil ]						]				]				ifFalse: 				[	cell hasCandidates ifTrue: 						[	( without includes: cellPos ) ifTrue: [ ^ nil ].							( cell candidatesIncludes: number ) 								ifTrue: 								[	newPositions size = self fishSize ifTrue: [ ^ nil ].									newPositions notNil 										ifTrue: [ newPositions addLast: cellPos ]										ifFalse: [ newPositions := cellPositions copyWith: cellPos ]								]								ifFalse: [ cell givenOrNil = number ifTrue: [ ^ nil ]]						]				]		].	^ newPositions ifNil: 		[	noMatch 				ifTrue: [ nil ]				ifFalse: [ cellPositions ]		]</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	self tipsInCellGroups: grid rows type: #row grid: grid context: block do: context.	self tipsInCellGroups: grid columns type: #column grid: grid context: block do: context.</body><body package="SudokuSolving">tipsInCellGroups: rowsOrColumns type: type grid: grid context: block do: context 	| without initialPositions |	without := OrderedCollection new.	without beImmutable.	initialPositions := OrderedCollection new.	initialPositions beImmutable.	grid gridCandidates do: 		[: number |			self allIndizesIn: rowsOrColumns				indicesDone: Array new				without: without				number: number				cellPositions: initialPositions				do: 				[: indices : cellPositions | "apply rule"					| modified |					modified := self modifyIn: rowsOrColumns number: number indizes: indices cellPositions: cellPositions.					modified ifTrue: [ block value: ( self positions: cellPositions indices: indices number: number type: type )]				]		].</body></methods><methods><class-id>Sudoku.UsingALS</class-id> <category>accessing</category><body package="SudokuSolving">alsSet: newAlsSet 	alsSet := newAlsSet.</body></methods><methods><class-id>Sudoku.UsingALS</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments |	gridAdornments := super adornmentsIn: grid.	alsSet keysAndValuesDo: [: i : als | gridAdornments nextAdornment: ( GridAdornment als: als index: i )].	self addModifiedCellsIn: grid to: gridAdornments.	^ gridAdornments</body></methods><methods><class-id>Sudoku.UsingALS class</class-id> <category>accessing</category><body package="SudokuSolving">maxAlsSize	^ 5</body><body package="SudokuSolving">minAlsSize	^ 1</body></methods><methods><class-id>Sudoku.UsingALS class</class-id> <category>utility</category><body package="SudokuSolving">alsSized: size cells: cells do: block 	| candidates |	candidates := Candidates new: size.	cells do: [: sake | candidates addAll: sake candidates ].	candidates size = ( size + 1 ) ifFalse: [ ^ self ].	2 to: cells size do: [: i | i + 1 to: cells size do: [: j | (( cells at: i ) isSake: ( cells at: j )) ifFalse: [ ^ self ]]].	block value: ( AlmostLockedSet cells: cells ).</body><body package="SudokuSolving">alsSized: size in: grid do: block 	grid housesDo: 		[: house | ( house select: [: cell | cell hasCandidates and: [ cell candidates size &lt;= size ]]) subCollectionsSized: size				do: [: asl | self alsSized: size cells: asl do: block ]		].</body><body package="SudokuSolving">commonSakesIn: alsSet for: candidate 	^ alsSet inject: nil		into: 		[: cellsOrNil : als |			cellsOrNil notNil 				ifTrue: 				[	cellsOrNil notEmpty 						ifTrue: [ cellsOrNil * ( als commonSakesAt: candidate )]						ifFalse: [ cellsOrNil ]				]				ifFalse: [ als commonSakesAt: candidate ]		]</body><body package="SudokuSolving">isRestrictedCommon: x in: alsSet 	alsSet do: 		[: als1 |			alsSet do: 				[: als2 |					als1 == als2 ifFalse: 						[( als1 cells allSatisfy: 								[: cell | ( cell candidatesIncludes: x ) not or: [ als2 cells allSatisfy: [: sake | ( cell candidatesIncludes: x ) not or: [ cell isSake: sake ]]]								]) 								ifFalse: [ ^ false ]						]				]		].	^ true</body><body package="SudokuSolving">joinedCandidatesOf: alsSet 	"to iterate while modify is bad - but workes fine on Candidates-collections"	| joinedCandidates same |	joinedCandidates := same := nil.	alsSet do: 		[: als |			same notNil 				ifTrue: [ same do: [: c | ( als joinedCandidates includes: c ) ifFalse: [ joinedCandidates remove: c ]]]				ifFalse: [ joinedCandidates := same := als joinedCandidates ]		].	^ joinedCandidates</body></methods><methods><class-id>Sudoku.UsingALS class</class-id> <category>instance creation</category><body package="SudokuSolving">alsSet: alsSet 	"	Transcript		show: self niceName; tab; show: ( alsSet asArray collect: [: e | e size ]) printString; cr."	^ ( self new )		alsSet: ( alsSet collect: [: als | als cells collect: [: e | e sudokuCellPosition ]]);		yourself</body></methods><methods><class-id>Sudoku.UsingALS class</class-id> <category>modify</category><body package="SudokuSolving">tipsIn: grid alsSet: alsSet do: block 	self subclassResponsibility.</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	| old |	old := OrderedCollection new.	self minAlsSize to: self maxAlsSize		do: 		[: size |			self alsSized: size				in: grid				do: 				[: als1 | ( old includes: als1 ) ifFalse: 						[	old do: 								[: als2 | | alsSet |									alsSet := OrderedCollection with: als1 with: als2.									self tipsIn: grid alsSet: alsSet do: block								]						].					old add: als1				]		].	^ old</body></methods><methods><class-id>Sudoku.AbstractChain class</class-id> <category>instance creation</category><body package="SudokuSolving">addPairsIn: house to: allPairsByNumber 	| tmp |	tmp := Dictionary new.	house do: [: cell | cell hasCandidates ifTrue: [ cell candidates do: [: number | ( tmp at: number ifAbsentPut: [ OrderedCollection new ]) add: cell ]]].	tmp keysAndValuesDo: [: number : cells | cells size = 2 ifTrue: [( allPairsByNumber at: number ifAbsentPut: [ Set new ]) add: cells asArray ]].</body><body package="SudokuSolving">allPairsByNumberIn: grid 	| allPairsByNumber |	allPairsByNumber := Dictionary new.	grid housesDo: [: house | self addPairsIn: house to: allPairsByNumber ].	^ allPairsByNumber</body></methods><methods><class-id>Sudoku.HiddenSingle</class-id> <category>testing</category><body package="SudokuSolving">needsCandidates	^ false</body></methods><methods><class-id>Sudoku.HiddenSingle</class-id> <category>accessing</category><body package="SudokuSolving">positions: aPositions 	positions := aPositions.</body><body package="SudokuSolving">solveGrid: grid 	| cell |	cell := grid cellAtX: cellPos x y: cellPos y.	^ cell given: given</body></methods><methods><class-id>Sudoku.HiddenSingle</class-id> <category>explain</category><body package="SudokuSolving">explainTo: gridAdornments 	| nextAdornment |	gridAdornments nextAdornment: (GridAdornment focusOnCandidate: given).	nextAdornment := GridAdornment placeCandidate: given.	positions do: 		[: pos |			pos = cellPos 				ifTrue: [ nextAdornment position: cellPos setCandidate: given ]				ifFalse: [ nextAdornment position: pos removeCandidate: given ] 		].	gridAdornments nextAdornment: nextAdornment</body></methods><methods><class-id>Sudoku.HiddenSingle class</class-id> <category>instance creation</category><body package="SudokuSolving">cell: cell house: house given: given 	^ ( self cell: cell given: given )		positions: ( house collect: [: c | c sudokuCellPosition ]);		yourself</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	self tipsInHouse: grid boxes do: block.	self tipsInHouse: grid rows do: block.	self tipsInHouse: grid columns do: block.</body><body package="SudokuSolving">tipsInHouse: houses do: block 	houses do: 		[: house | | candidateToCells |			candidateToCells := Array new: house size.			house do: 				[: cell |					cell candidatesDo: 						[: candidate | | old |							old := candidateToCells at: candidate.							old isNil 								ifTrue: [ candidateToCells at: candidate put: cell ]								ifFalse: [ candidateToCells at: candidate put: #multi ]						]				].			candidateToCells keysAndValuesDo: 				[: candidate : cellOrNil | ( cellOrNil notNil and: [ #multi ~~ cellOrNil and: [ cellOrNil hasCandidates ]]) 						ifTrue: [ block value: ( self cell: cellOrNil house: house given: candidate )]				]		].</body></methods><methods><class-id>Sudoku.HiddenSingle class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	"easy to find - check the numbers"	^ 5</body></methods><methods><class-id>Sudoku.CoverdByNeighbours</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	| context |	context := SolvingContext new.	context strategies: #( ).	self class tipsIn: grid context: context do: [: tip | ^ true ].	^ true</body></methods><methods><class-id>Sudoku.CoverdByNeighbours</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments |	gridAdornments := super adornmentsIn: grid.	self addModifiedCellsIn: grid to: gridAdornments.	^ gridAdornments</body></methods><methods><class-id>Sudoku.CoverdByNeighbours class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	"medium - check all sakes"	^ 50</body><body package="SudokuSolving">niceName	^ ( #sudokuRemoveMarksFromSakes &gt;&gt; 'Remove marks from sakes' ) asString</body></methods><methods><class-id>Sudoku.CoverdByNeighbours class</class-id> <category>testing</category><body package="SudokuSolving">isForValidation	^ true</body></methods><methods><class-id>Sudoku.CoverdByNeighbours class</class-id> <category>instance creation</category><body package="SudokuSolving">tipsIn: grid context: context do: block 	( self modifyGrid: grid ) ifTrue: [ block value: self new ].</body></methods><methods><class-id>Sudoku.CoverdByNeighbours class</class-id> <category>modify</category><body package="SudokuSolving">modifyGrid: grid 	| modified |	grid isFastGrid ifTrue: [ ^ false ].	modified := false.	grid cellsDo: 		[: cell |			cell hasCandidates ifTrue: 				[	cell allSakesDo: [: sake | sake hasCandidates ifFalse: [( cell removeCandidate: sake givenOrNil ) notNil ifTrue: [ modified := true ]]]				]		].	^ modified</body></methods><methods><class-id>Sudoku.NakedSingle</class-id> <category>accessing</category><body package="SudokuSolving">explainTo: gridAdornments 	gridAdornments nextAdornment: (GridAdornment checkThisCell: cellPos candidate: given ).</body><body package="SudokuSolving">solveGrid: grid 	| cell |	cell := grid cellAtX: cellPos x y: cellPos y.	^ cell given: cell givenOrNil</body></methods><methods><class-id>Sudoku.NakedSingle class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	"medium - check all sakes"	^ 51</body></methods><methods><class-id>Sudoku.NakedSingle class</class-id> <category>instance creation</category><body package="SudokuSolving">tipsIn: grid context: context do: block 	grid isFastGrid ifFalse: 		[	grid cellsDo: 				[: cell | ( cell hasCandidates and: [ cell candidates size = 1 ]) ifTrue: [ block value: ( self cell: cell given: cell givenOrNil )]				]		].</body></methods><methods><class-id>Sudoku.Done</class-id> <category>accessing</category><body package="SudokuSolving">valid	^ true</body></methods><methods><class-id>Sudoku.Done</class-id> <category>testing</category><body package="SudokuSolving">needsCandidates	^ false</body></methods><methods><class-id>Sudoku.Done class</class-id> <category>instance creation</category><body package="SudokuSolving">difficulty	"elementary"	^ 2</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	grid cellsDo: [: cell | cell hasCandidates ifTrue: [ ^ self ]].	block value: self new.</body></methods><methods><class-id>Sudoku.Done class</class-id> <category>accessing</category><body package="SudokuSolving">niceName	^ ( #sudokuDone &gt;&gt; 'Done' ) asString</body></methods><methods><class-id>Sudoku.DeadEndAhead</class-id> <category>accessing</category><body package="SudokuSolving">cellPositions: positions 	cellPositions := positions.</body><body package="SudokuSolving">number: aNumber 	number := aNumber.</body></methods><methods><class-id>Sudoku.DeadEndAhead</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments gridAdornment |	gridAdornments := super adornmentsIn: grid.	gridAdornments nextAdornment: ( GridAdornment focusOnCandidate: number ).	gridAdornment := GridAdornment focusOnCells: cellPositions candidates: #( ).	cellPositions do: 		[: pos | ( gridAdornment getAdornmentAt: pos )				backgroundColor: #badCandidate;				background: 'X'		].	gridAdornments nextAdornment: gridAdornment.	^ gridAdornments</body></methods><methods><class-id>Sudoku.DeadEndAhead class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 8</body></methods><methods><class-id>Sudoku.DeadEndAhead class</class-id> <category>instance creation</category><body package="SudokuSolving">house: house number: v 	^ ( self new )		cellPositions: ( house collect: [: c | c x @ c y ]);		number: v;		yourself</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	grid housesDo: [: house | self tipsInHouse: house of: grid do: block ].</body><body package="SudokuSolving">tipsInHouse: house of: grid do: block 	grid gridCandidates do: 		[: v | ( house contains: 				[: c |					c hasCandidates 						ifTrue: [ c candidatesIncludes: v ]						ifFalse: [ c givenOrNil = v ]				]) 				ifFalse: [ block value: ( self house: house number: v )]		].</body></methods><methods><class-id>Sudoku.Duplicates</class-id> <category>testing</category><body package="SudokuSolving">needsCandidates	^ false</body></methods><methods><class-id>Sudoku.Duplicates</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments gridAdornment |	gridAdornments := super adornmentsIn: grid.	gridAdornment := GridAdornment focusOnCells: cellPositions candidates: #( ).	cellPositions do: 		[: pos | ( gridAdornment getAdornmentAt: pos )				backgroundColor: #badCandidate;				background: 'X'		].	gridAdornments nextAdornment: gridAdornment.	^ gridAdornments</body></methods><methods><class-id>Sudoku.Duplicates</class-id> <category>accessing</category><body package="SudokuSolving">cellPositions: pointArray 	cellPositions := pointArray.</body></methods><methods><class-id>Sudoku.Duplicates class</class-id> <category>instance creation</category><body package="SudokuSolving">cells: cells 	^ ( self new )		cellPositions: ( cells collect: [: c | c x @ c y ]);		yourself</body><body package="SudokuSolving">checkCells: cells do: block 	1 to: cells size - 1		do: 		[: i | | v |			v := ( cells at: i ) givenOrNil.			v notNil ifTrue: 				[	i + 1 to: cells size						do: 						[: j |							v == ( cells at: j ) givenOrNil ifTrue: [ block value: ( self cells: ( Array with: ( cells at: i ) with: ( cells at: j )))]						]				]		].</body><body package="SudokuSolving">difficulty	"elementary"	^ 1</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	grid housesDo: [: house | self checkCells: house do: block ].</body></methods><methods><class-id>Sudoku.DeadEnd</class-id> <category>accessing</category><body package="SudokuSolving">position: aPosition 	position := aPosition.</body></methods><methods><class-id>Sudoku.DeadEnd</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments gridAdornment |	gridAdornments := super adornmentsIn: grid.	gridAdornment := GridAdornment focusOnCells: ( Array with: position ) candidates: #( ).	( gridAdornment getAdornmentAt: position )		backgroundColor: #badCandidate;		background: 'X'.	gridAdornments nextAdornment: gridAdornment.	^ gridAdornments</body></methods><methods><class-id>Sudoku.DeadEnd class</class-id> <category>instance creation</category><body package="SudokuSolving">cell: cell 	^ ( self new )		position: cell x @ cell y;		yourself</body><body package="SudokuSolving">difficulty	"elementary"	^ 0</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	grid cellsDo: [: cell | ( cell hasCandidates and: [ cell candidates isEmpty ]) ifTrue: [ block value: ( self cell: cell )]].</body></methods><methods><class-id>Sudoku.Backtracking</class-id> <category>accessing</category><body package="SudokuSolving">isSingleSolutionFor: grid context: context 	| copy cell |	cell := grid cellAtX: cellPos x y: cellPos y.	( context randomOrNil isNil and: [ cell candidates last = given ]) ifFalse: 		[	"verify other combinations are no solution"			copy := grid copyAsFastGrid.			cell := copy cellAtX: cellPos x y: cellPos y.			cell removeCandidate: given.			( context solveGrid: copy ) ifTrue: [ ^ false ]		].	"do not allow non implied variations"	copy := grid copyAsFastGrid.	cell := copy cellAtX: cellPos x y: cellPos y.	cell given: given.	^ context solveUnique: copy</body><body package="SudokuSolving">modifyGrid: grid 	| cell |	cell := grid cellAtX: cellPos x y: cellPos y.	^ cell given: given</body><body package="SudokuSolving">solution: aSolution 	solution := aSolution.</body><body package="SudokuSolving">solveGrid: grid 	solution with: grid do: [: cell1 : cell2 | cell2 given: cell1 givenOrNil ].</body></methods><methods><class-id>Sudoku.Backtracking class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	"only as last means"	^ 10000</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	| candiate |	candiate := nil.	grid cellsDo: 		[: cell | ( cell hasCandidates and: [ candiate isNil or: [ candiate candidates size &gt; cell candidates size ]]) ifTrue: [ candiate := cell ]		].	self try: candiate in: grid context: context do: block.</body><body package="SudokuSolving">try: cell in: grid context: context do: block 	cell candidates do: 		[: candidate | | copy |			copy := grid copyAsFastGrid.			copy initAtX: cell x y: cell y given: candidate.			( SolvingContext forValidation solveGrid: copy ) ifTrue: [ ^ block value: ( self cell: cell given: candidate solution: copy )]		]		randomOrNil: context randomOrNil.	block value: DeadEnd new.</body></methods><methods><class-id>Sudoku.Backtracking class</class-id> <category>instance creation</category><body package="SudokuSolving">cell: cell given: given solution: solution 	^ ( self cell: cell given: given )		solution: solution;		yourself</body></methods><methods><class-id>Sudoku.UniqueRectangle</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	^ self modifyGrid: grid onModifyDo: nil</body><body package="SudokuSolving">modifyGrid: grid onModifyDo: blockOrNil 	| cellSet floor1 floor2 candidates |	cellSet := positions collect: [: p | grid cellAtX: p x y: p y ].	( cellSet allSatisfy: [: c | c hasCandidates ]) ifFalse: [ ^ false ].	floor1 := cellSet at: 1.	candidates := floor1 candidates.	candidates size = 2 ifFalse: [ ^ false ].	floor2 := cellSet at: 2.	floor2 candidates size = 2 ifFalse: [ ^ false ].	( cellSet allSatisfy: [: c | candidates allSatisfy: [: v | c candidatesIncludes: v ]]) ifFalse: [ ^ false ].	^ self class modifyRoof1: ( cellSet at: 3 )		roof2: ( cellSet at: 4 )		floor1: floor1		floor2: floor2		floorInBox: ( floor1 box includes: floor2 )		onModifyDo: blockOrNil</body></methods><methods><class-id>Sudoku.UniqueRectangle</class-id> <category>explain</category><body package="SudokuSolving">addModifiedCellsIn: grid to: gridAdornments 	| old copy |	old := grid.	copy := old copy.	self modifyGrid: copy		onModifyDo: 		[: type | | gridAdornment stream removed |			gridAdornment := GridAdornment new.			removed := Candidates new.			copy with: grid				do: 				[: m : o | | remaining |					remaining := m candidates.					o candidates size = remaining size ifFalse: 						[	o candidates do: 								[: candidate | ( remaining includes: candidate ) ifFalse: 										[	removed add: candidate.											gridAdornment position: o sudokuCellPosition removeCandidate: candidate										]								]						]				].			stream := String new writeStream.			stream nextPutAll: self niceName; nextPutAll: ' Type '.			type printOn: stream.			stream nextPutAll: ' - '.			stream nextPutAll: (( #sudokuRemoveMarks1s &gt;&gt; 'Remove marks &lt;1s&gt;' ) asString expandMacrosWith: removed sudokuValuesSting ).			gridAdornment string: stream contents.			gridAdornments nextAdornment: gridAdornment.			old := copy copy		].</body><body package="SudokuSolving">addPositionsIn: grid to: gridAdornments 	gridAdornments nextAdornment: ( GridAdornment focusOnCells: ( positions collect: [: p | grid cellAtX: p x y: p y ])).	self addModifiedCellsIn: grid to: gridAdornments.</body></methods><methods><class-id>Sudoku.UniqueRectangle class</class-id> <category>modify</category><body package="SudokuSolving">modifyRoof1: roof1 roof2: roof2 floor1: floor1 floor2: floor2 floorInBox: floorInBox 	^ self modifyRoof1: roof1 roof2: roof2 floor1: floor1 floor2: floor2 floorInBox: floorInBox onModifyDo: nil</body><body package="SudokuSolving">modifyRoof1: roof1 roof2: roof2 floor1: floor1 floor2: floor2 floorInBox: floorInBox onModifyDo: block 	| candidates |	candidates := floor1 candidates copy.	"Type 1"	roof1 candidates size = 2 ifTrue: [ ^ self type1Roof: roof2 candidates: candidates onModifyDo: block ].	roof2 candidates size = 2 ifTrue: [ ^ self type1Roof: roof1 candidates: candidates onModifyDo: block ].	"Type 2"	( roof1 candidates size = 3 and: [ roof1 candidates = roof2 candidates ]) 		ifTrue: [( self type2Roof1: roof1 roof2: roof2 candidates: candidates floorInBox: floorInBox onModifyDo: block ) ifTrue: [ ^ true ]].	"Type 3 (exclude special case - Type 2 - from above)"	( self type3Roof1: roof1 roof2: roof2 candidates: candidates floorInBox: floorInBox onModifyDo: block ) ifTrue: [ ^ true ].	"Type 4"	^ self type4Roof1: roof1 roof2: roof2 candidates: candidates floorInBox: floorInBox onModifyDo: block	"  Uniqueness Test 5Uniqueness Test 5 is very similar to Uniqueness Test 2, and can be stated as follows:    Suppose exactly two cells in the rectangle have exactly one extra candidate X, and both cells are located diagonally across each other in the rectangle. Then X can be eliminated from the cells seen by both of these cells. However, it appears that no example has been found for this test.Some players will also call the following variant as Uniqueness Test 5:    Suppose exactly three cells in the rectangle have exactly one extra candidate X. Then X can be eliminated from the cells seen by all three cells. Uniqueness Test 6Uniqueness Test 6 is very similar to Uniqueness Test 4, and can be stated as follows:    Suppose exactly two cells in the rectangle contain extra candidates, and they are located diagonally across each other in the rectangle. Suppose the common candidates are U and V, and none of the other cells in the two rows and two columns containing the rectangle contain U. Then V can be eliminated from these two cells. "</body><body package="SudokuSolving">roofIn: grid floor1: floor1 floor2: floor2 context: context do: block 	| floorInBox rc1 rc2 |	floorInBox := floor1 box includes: floor2.	floor1 x = floor2 x 		ifTrue: 		[	rc1 := floor1 row.			rc2 := floor2 row		]		ifFalse: 		[	rc1 := floor1 column.			rc2 := floor2 column		].	rc1 with: rc2		do: 		[: roof1 : roof2 |			"check for a roof"			( roof1 ~= floor1 and: 				[( floorInBox or: [ floor1 box includes: roof1 ]) and: 						[	roof1 hasCandidates and: 								[	roof2 hasCandidates and: 										[	floor1 candidates allSatisfy: [: v | ( roof1 candidatesIncludes: v ) and: [ roof2 candidatesIncludes: v ]]										]								]						]				]) 				ifTrue: 				[	"take a closer look to the roof"					( self modifyRoof1: roof1 roof2: roof2 floor1: floor1 floor2: floor2 floorInBox: floorInBox ) 						ifTrue: [ block value: ( self cells: ( Array with: floor1 with: floor2 with: roof1 with: roof2 ))]				]		].</body></methods><methods><class-id>Sudoku.UniqueRectangle class</class-id> <category>modify type1</category><body package="SudokuSolving">type1Roof: roof candidates: candidates onModifyDo: block 	"Type 1"	| modified |	modified := false.	candidates do: [: v | ( roof removeCandidate: v ) notNil ifTrue: [ modified := true ]].	modified and: [ block notNil ifTrue: [ block value: 1 ]].	^ modified</body></methods><methods><class-id>Sudoku.UniqueRectangle class</class-id> <category>modify type2</category><body package="SudokuSolving">type2Roof1: roof1 roof2: roof2 candidates: candidates floorInBox: floorInBox onModifyDo: block 	"Type 2"	| modified extra house |	modified := false.	extra := roof1 candidates 			detect: [: v | ( candidates includes: v ) not ]			ifNone: [ nil ].	house := roof1 x = roof2 x 			ifTrue: [ roof1 column ]			ifFalse: [ roof1 row ].	( self type2Roof1: roof1 roof2: roof2 candidates: candidates house: house extra: extra ) ifTrue: [ modified := true ].	floorInBox ifTrue: [( self type2Roof1: roof1 roof2: roof2 candidates: candidates house: roof1 box extra: extra ) ifTrue: [ modified := true ]].	modified and: [ block notNil ifTrue: [ block value: 2 ]].	^ modified</body><body package="SudokuSolving">type2Roof1: roof1 roof2: roof2 candidates: candidates house: house extra: extra 	"Type 2"	| modified |	modified := false.	house do: [: sake | ( sake ~= roof1 and: [ sake ~= roof2 and: [( sake removeCandidate: extra ) notNil ]]) ifTrue: [ modified := true ]].	^ modified</body></methods><methods><class-id>Sudoku.UniqueRectangle class</class-id> <category>modify type4</category><body package="SudokuSolving">type4Roof1: roof1 roof2: roof2 candidates: candidates floorInBox: floorInBox onModifyDo: block 	"Type 2"	| modified house |	modified := false.	house := roof1 x = roof2 x 			ifTrue: [ roof1 column ]			ifFalse: [ roof1 row ].	( self type4Roof1: roof1 roof2: roof2 candidates: candidates house: house ) ifTrue: [ modified := true ].	floorInBox ifTrue: [( self type4Roof1: roof1 roof2: roof2 candidates: candidates house: roof1 box ) ifTrue: [ modified := true ]].	modified and: [ block notNil ifTrue: [ block value: 4 ]].	^ modified</body><body package="SudokuSolving">type4Roof1: roof1 roof2: roof2 candidates: candidates house: house 	"Type 4"	| modified |	modified := false.	candidates do: 		[: conjugate | | removeable |			( house contains: [: sake | sake ~= roof1 and: [ sake ~= roof2 and: [ sake candidatesIncludes: conjugate ]]]) ifFalse: 				[	removeable := candidates detect: [: c | c ~= conjugate ].					roof1 removeCandidate: removeable.					roof2 removeCandidate: removeable.					modified := true				]		].	^ modified</body></methods><methods><class-id>Sudoku.UniqueRectangle class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 89</body></methods><methods><class-id>Sudoku.UniqueRectangle class</class-id> <category>testing</category><body package="SudokuSolving">needsSingleSolution	^ true</body></methods><methods><class-id>Sudoku.UniqueRectangle class</class-id> <category>instance creation</category><body package="SudokuSolving">tipsIn: grid context: context do: block 	| pairs |	pairs := self pairsIn: grid context: context.	1 to: pairs size - 1		do: 		[: i | | floor1 |			floor1 := pairs at: i.			i + 1 to: pairs size				do: 				[: j | | floor2 |					floor2 := pairs at: j.					(( floor1 x = floor2 x or: [ floor1 y = floor2 y ]) and: [ floor1 candidates = floor2 candidates ]) 						ifTrue: [ self roofIn: grid floor1: floor1 floor2: floor2 context: context do: block ]				]		].</body></methods><methods><class-id>Sudoku.UniqueRectangle class</class-id> <category>modify type3</category><body package="SudokuSolving">type3Roof1: roof1 roof2: roof2 candidates: candidates floorInBox: floorInBox onModifyDo: block 	"Type 3"	"Suppose exactly two cells in the rectangle, both located on the one side of the rectangle, have extra candidates."	"By treating these two cells as one node, find k - 1 other cells (as nodes) in the same house as these two cells so that the union of the candidates for these k cells has exactly k unique digits."	"Then the Naked Subset rule can be applied eliminate these k digits from the other cells in the house."	| extraCandidates house modified |	modified := false.	extraCandidates := Candidates new: 4.	extraCandidates addAll: roof1 candidates.	extraCandidates addAll: roof2 candidates.	extraCandidates removeAll: candidates.	house := roof1 x = roof2 x 			ifTrue: [ roof1 column ]			ifFalse: [ roof1 row ].	( self type3Roof1: roof1 roof2: roof2 extraCandidates: extraCandidates house: house ) ifTrue: [ modified := true ].	floorInBox ifTrue: [( self type3Roof1: roof1 roof2: roof2 extraCandidates: extraCandidates house: roof1 box ) ifTrue: [ modified := true ]].	modified and: [ block notNil ifTrue: [ block value: 3 ]].	^ modified</body><body package="SudokuSolving">type3Roof1: roof1 roof2: roof2 extraCandidates: extraCandidates house: house 	"Type 3"	| allValues modified |	modified := false.	allValues := Set withAll: extraCandidates.	house do: [: cell | ( roof1 ~= cell and: [ roof2 ~= cell and: [ cell hasCandidates ]]) ifTrue: [ allValues addAll: cell candidates ]].	3 to: allValues size		do: 		[: tupleSize | | usableCells |			usableCells := house select: [: cell | roof1 ~= cell and: [ roof2 ~= cell and: [ cell hasCandidates and: [ cell candidates size &lt;= tupleSize ]]]].			usableCells subCollectionsSized: tupleSize - 1				do: 				[: sakes | | tupleCells tuple |					tuple := Candidates withAll: extraCandidates.					sakes do: [: cell | tuple addAll: cell candidates ].					tuple size &lt;= tupleSize ifTrue: 						[	tupleCells := OrderedCollection withAll: sakes.							tupleCells add: roof1.							tupleCells add: roof2.							( NakedTuple modifyHouse: house tuple: tuple of: tupleCells ) ifTrue: [ modified := true ]						]				]		].	^ modified</body></methods><methods><class-id>Sudoku.XWing class</class-id> <category>accessing</category><body package="SudokuSolving">fishSize	^ 2</body></methods><methods><class-id>Sudoku.AlmostLockedSetXZ</class-id> <category>accessing</category><body package="SudokuSolving">x: candidate 	x := candidate.</body><body package="SudokuSolving">z: candidate 	z := candidate.</body></methods><methods><class-id>Sudoku.AlmostLockedSetXZ</class-id> <category>modify</category><body package="SudokuSolving">addModifiedCellsIn: grid to: gridAdornments 	| stream gridAdornment |	stream := String new writeStream.	stream nextPutAll: 'resticted AB (x= '.	x printOn: stream.	stream nextPutAll: ') common AB (z= '.	z printOn: stream.	stream nextPut: $).	gridAdornment := GridAdornment string: stream contents.	gridAdornments nextAdornment: gridAdornment.	super addModifiedCellsIn: grid to: gridAdornments.</body><body package="SudokuSolving">modifyGrid: grid 	^ self class modifyWithAlsSet: ( alsSet collect: [: als | AlmostLockedSet cells: ( als collect: [: p | grid cellAtX: p x y: p y ])]) x: x z: z</body></methods><methods><class-id>Sudoku.AlmostLockedSetXZ class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 550</body><body package="SudokuSolving">minAlsSize	^ 2</body><body package="SudokuSolving">niceName	^ 'Almos Locked Set XZ'</body></methods><methods><class-id>Sudoku.AlmostLockedSetXZ class</class-id> <category>instance creation</category><body package="SudokuSolving">alsSet: alsSet x: x z: z 	^ ( self alsSet: alsSet )		x: x;		z: z;		yourself</body></methods><methods><class-id>Sudoku.AlmostLockedSetXZ class</class-id> <category>modify</category><body package="SudokuSolving">modifyWithAlsSet: alsSet x: x z: z 	| cells |	cells := self commonSakesIn: alsSet for: z.	cells do: [: cell | cell removeCandidate: z ].	^ cells notEmpty</body><body package="SudokuSolving">tipsIn: grid alsSet: alsSet do: block 	| commonCandidates |	commonCandidates := self joinedCandidatesOf: alsSet.	commonCandidates size &gt; 1 ifTrue: 		[	commonCandidates do: 				[: x | ( self isRestrictedCommon: x in: alsSet ) ifTrue: 						[	commonCandidates do: 								[: z |									x ~= z ifTrue: 										[( self modifyWithAlsSet: alsSet x: x z: z ) ifTrue: [ ^ block value: ( self alsSet: alsSet x: x z: z )]										]								]						]				]		].</body></methods><methods><class-id>Sudoku.SwordFish class</class-id> <category>accessing</category><body package="SudokuSolving">fishSize	^ 3</body></methods><methods><class-id>Sudoku.MultivalueXWing</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	| cells |	cells := positions collect: [: p | grid cellAtX: p x y: p y ].	^ self class modifyCells: cells</body></methods><methods><class-id>Sudoku.MultivalueXWing class</class-id> <category>instance creation</category><body package="SudokuSolving">commonValueOf: f3 with: f1 	^ ( f1 isSake: f3 ) 		ifTrue: [ f1 commonCandidatesWith: f3 ]		ifFalse: [ nil ]</body><body package="SudokuSolving">modifyCells: cells 	"	c1	---	c2	 |		|	c3	---	c4 	"	| c1 c2 c3 c4 modified v12 v13 v42 v43 |	c1 := cells at: 1.	c2 := cells at: 2.	c3 := cells at: 3.	c4 := cells at: 4.	v12 := self commonValueOf: c1 with: c2.	v12 isNil ifTrue: [ ^ false ].	v13 := self commonValueOf: c1 with: c3.	v13 isNil ifTrue: [ ^ false ].	v42 := self commonValueOf: c4 with: c2.	v42 isNil ifTrue: [ ^ false ].	v43 := self commonValueOf: c4 with: c3.	v43 isNil ifTrue: [ ^ false ].	modified := false.	c1 allSakesDo: 		[: c | (( c isSake: c2 ) and: [( c removeCandidate: v12 ) notNil ]) ifTrue: [ modified := true ].			(( c isSake: c3 ) and: [( c removeCandidate: v13 ) notNil ]) ifTrue: [ modified := true ]		].	c4 allSakesDo: 		[: c | (( c isSake: c2 ) and: [( c removeCandidate: v42 ) notNil ]) ifTrue: [ modified := true ].			(( c isSake: c3 ) and: [( c removeCandidate: v43 ) notNil ]) ifTrue: [ modified := true ]		].	^ modified</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	| pairs v12 v13 v34 v24 |	pairs := self pairsIn: grid context: context.	pairs do: 		[: c1 |			pairs do: 				[: c2 | ( v12 := self commonValueOf: c1 with: c2 ) notNil ifTrue: 						[	"try to find f3 &amp; f4 "							pairs do: 								[: c3 | ( c2 ~= c3 and: [( v13 := self commonValueOf: c3 with: c1 ) notNil and: [ v12 ~= v13 ]]) ifTrue: 										[	pairs do: 												[: c4 | | cells |													( c1 ~= c4 and: 														[( v34 := self commonValueOf: c3 with: c4 ) notNil and: 																[	v34 ~= v13 and: 																		[( v24 := self commonValueOf: c2 with: c4 ) notNil and: [ v24 ~= v12 and: [ v24 ~= v34 ]]																		]																]														]) 														ifTrue: 														[	cells := Array with: c1 with: c2 with: c3 with: c4.															( self modifyCells: cells ) ifTrue: [ block value: ( self cells: cells )]														]												]										]								]						]				]		].</body></methods><methods><class-id>Sudoku.MultivalueXWing class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 312</body></methods><methods><class-id>Sudoku.AbstractChainByNumber</class-id> <category>accessing</category><body package="SudokuSolving">number: aNumber 	number := aNumber.</body></methods><methods><class-id>Sudoku.AbstractChainByNumber class</class-id> <category>instance creation</category><body package="SudokuSolving">chainsIn: pairs current: chain do: block 	self chainsIn: pairs current: chain last: nil hide: Set new do: block.</body><body package="SudokuSolving">chainsIn: pairs current: chain last: last hide: hidden do: block 	chain notEmpty 		ifTrue: 		[	self chainsIn: pairs current: #( ) last: nil hide: hidden do: block.			( chain size &gt; 2 and: [ chain size even ]) ifTrue: 				[	hidden add: last.					block value: chain				].			pairs do: 				[: pair | | cell newPairs |					( pair includes: chain last ) ifTrue: 						[	cell := pair last == chain last 									ifTrue: [ pair first ]									ifFalse: [ pair last ].							newPairs := pairs reject: [: e | pair = e ].							self chainsIn: newPairs current: ( chain copyWith: cell ) last: pair hide: hidden do: block						]				]		]		ifFalse: 		[	pairs size &lt; 4 ifTrue: [ ^ self ].			pairs do: 				[: newChain | | newPairs |					(( hidden includes: newChain ) not and: [ pairs allSatisfy: [: other | newChain = other or: [( other includes: newChain first ) not ]]]) ifTrue: 						[	newPairs := pairs reject: [: other | newChain = other ].							hidden add: newChain.							self chainsIn: newPairs current: newChain last: newChain hide: hidden do: block						].					(( hidden includes: newChain ) not and: [ pairs allSatisfy: [: other | newChain = other or: [( other includes: newChain last ) not ]]]) ifTrue: 						[	newPairs := pairs reject: [: other | newChain = other ].							hidden add: newChain.							self chainsIn: newPairs current: newChain reverse last: newChain hide: hidden do: block						]				]		].</body><body package="SudokuSolving">number: number 	^ ( self new )		number: number;		yourself</body></methods><methods><class-id>Sudoku.AlmostLockedSetXYWing</class-id> <category>accessing</category><body package="SudokuSolving">x: candidate 	x := candidate.</body><body package="SudokuSolving">y: candidate 	y := candidate.</body><body package="SudokuSolving">z: candidate 	z := candidate.</body></methods><methods><class-id>Sudoku.AlmostLockedSetXYWing</class-id> <category>modify</category><body package="SudokuSolving">modifyGrid: grid 	| a b c array |	a := AlmostLockedSet cells: (( alsSet at: 1 ) collect: [: cPos | grid cellAtX: cPos x y: cPos y ]).	b := AlmostLockedSet cells: (( alsSet at: 2 ) collect: [: cPos | grid cellAtX: cPos x y: cPos y ]).	c := AlmostLockedSet cells: (( alsSet at: 3 ) collect: [: cPos | grid cellAtX: cPos x y: cPos y ]).	array := Array with: a with: b with: c.	self class modifyWithAlsSet: array x: x y: y z: z.</body></methods><methods><class-id>Sudoku.AlmostLockedSetXYWing</class-id> <category>explain</category><body package="SudokuSolving">addModifiedCellsIn: grid to: gridAdornments 	| stream gridAdornment |	stream := String new writeStream.	stream nextPutAll: 'resticted AC (y= '.	y printOn: stream.	stream nextPutAll: ') restricted BC (z= '.	z printOn: stream.	stream nextPutAll: ') common AB (x= '.	x printOn: stream.	stream nextPut: $).	gridAdornment := GridAdornment string: stream contents.	gridAdornments nextAdornment: gridAdornment.	super addModifiedCellsIn: grid to: gridAdornments.</body></methods><methods><class-id>Sudoku.AlmostLockedSetXYWing class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 700</body><body package="SudokuSolving">niceName	^ 'Almos Locked Set XY-Wing'</body></methods><methods><class-id>Sudoku.AlmostLockedSetXYWing class</class-id> <category>modify</category><body package="SudokuSolving">ab: ab c: c yIn: rAC zIn: rBC xIn: cAB do: block 	| array |	rAC do: 		[: y |			rBC do: 				[: z |					y = z ifFalse: 						[	array := ab copyWith: c.							cAB do: [: x | ( self modifyWithAlsSet: array x: x y: y z: z ) ifTrue: [ block value: ( self alsSet: array x: x y: y z: z )]]						]				]		].</body><body package="SudokuSolving">modifyWithAlsSet: alsSet x: x y: y z: z 	^ x ~= y and: 		[	x ~= z and: 				[ | victims |					victims := self commonSakesIn: ( alsSet copyFrom: 1 to: 2 ) for: x.					victims := victims reject: [: cell | alsSet last cells includes: cell ].					victims do: [: cell | cell removeCandidate: x ].					victims notEmpty				]		]</body><body package="SudokuSolving">tipsIn: grid alsSet: alsSet do: block 	self shouldNotImplement.</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	| old |	old := OrderedCollection new.	self minAlsSize to: self maxAlsSize		do: 		[: size |			self alsSized: size				in: grid				do: 				[: a | ( old includes: a ) ifFalse: 						[	1 to: old size - 1								do: 								[: i | | b ab cAB rAB |									b := old at: i.									ab := Array with: a with: b.									cAB := self joinedCandidatesOf: ab.									cAB isEmpty ifFalse: 										[	rAB := cAB select: [: y | self isRestrictedCommon: y in: ab ].											i + 1 to: old size												do: 												[: j | | c cAC cBC rAC rBC ac bc |													c := old at: j.													ac := Array with: a with: c.													cAC := self joinedCandidatesOf: ac.													cAC isEmpty ifFalse: 														[	rAC := cAC select: [: y | self isRestrictedCommon: y in: ac ].															( rAB isEmpty and: [ rAC isEmpty ]) ifFalse: 																[	bc := Array with: b with: c.																	cBC := self joinedCandidatesOf: bc.																	cBC isEmpty ifFalse: 																		[	rBC := cBC select: [: y | self isRestrictedCommon: y in: bc ].																			self ab: ab c: c yIn: rAC zIn: rBC xIn: cAB do: block.																			self ab: ac c: b yIn: rAB zIn: rBC xIn: cAC do: block.																			self ab: bc c: a yIn: rAB zIn: rAC xIn: cBC do: block																		]																]														]												]										]								].							old add: a						]				]		].	^ old</body></methods><methods><class-id>Sudoku.AlmostLockedSetXYWing class</class-id> <category>instance creation</category><body package="SudokuSolving">alsSet: alsSet x: x y: y z: z 	^ ( self alsSet: alsSet )		x: x;		y: y;		z: z;		yourself</body></methods><methods><class-id>Sudoku.JellyFish class</class-id> <category>accessing</category><body package="SudokuSolving">fishSize	^ 4</body></methods><methods><class-id>Sudoku.SquirmBag class</class-id> <category>accessing</category><body package="SudokuSolving">fishSize	^ 5</body></methods><methods><class-id>Sudoku.NiceLoops</class-id> <category>accessing</category><body package="SudokuSolving">cellPositions: aCellPositions 	cellPositions := aCellPositions.</body><body package="SudokuSolving">links	^ links</body><body package="SudokuSolving">links: someLinks 	links := someLinks.</body><body package="SudokuSolving">modifyGrid: grid 	| cells |	cells := cellPositions collect: [: pos | grid cellAtX: pos x y: pos y ].	^ ( InferenceChain cells: cells links: links ) modifyGridByNiceLoops</body></methods><methods><class-id>Sudoku.NiceLoops</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments |	gridAdornments := super adornmentsIn: grid.	links keysAndValuesDo: 		[: i : link | | gridAdornment |			gridAdornment := GridAdornment 					string: ( InferenceChain cells: ( cellPositions copyFrom: 1 to: i + 1 ) links: ( links copyFrom: 1 to: i )) printString.			link isStrongLink 				ifTrue: 				[	gridAdornment position: ( cellPositions at: i ) candidate: link linkCandidate color: #modifyingSake2.					gridAdornment position: ( cellPositions at: i + 1 ) candidate: link linkCandidate color: #modifyingSake1				]				ifFalse: 				[	gridAdornment position: ( cellPositions at: i ) candidate: link linkCandidate color: #modifyingSake1.					gridAdornment position: ( cellPositions at: i + 1 ) candidate: link linkCandidate color: #modifyingSake2				].			gridAdornments nextAdornment: gridAdornment		].	self addModifiedCellsIn: grid to: gridAdornments.	^ gridAdornments</body></methods><methods><class-id>Sudoku.NiceLoops class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 398</body></methods><methods><class-id>Sudoku.NiceLoops class</class-id> <category>instance creation</category><body package="SudokuSolving">cells: cells links: links 	^ ( self new )		cellPositions: ( cells collect: [: cell | cell sudokuCellPosition ]);		links: links;		yourself</body><body package="SudokuSolving">chainsIn: allPairsByNumber startingAt: number do: block 	( allPairsByNumber at: number ) do: 		[: pair | | chain |			chain := InferenceChain strongLinked: pair candidate: number.			self strongCompleteChain: chain using: allPairsByNumber skip: Set new do: block.			chain := InferenceChain strongLinked: pair reverse candidate: number.			self strongCompleteChain: chain using: allPairsByNumber skip: Set new do: block		].</body><body package="SudokuSolving">strongCompleteChain: chain using: allPairsByNumber skip: strongImpliedToSkip do: block 	"chain last has given candidate - try to reach start"	| cell candidate newChain |	cell := chain lastCell.	chain firstCell = cell ifTrue: [ ^ self checkChain: chain do: block ].	candidate := chain lastCandidate.	strongImpliedToSkip add: cell.	cell allSakesDo: 		[: sake | (( sake candidatesIncludes: candidate ) 				and: [( strongImpliedToSkip includes: sake ) not and: [ sake ~~ chain firstCell or: [ chain cellSize &gt; 2 and: [ chain continuous ]]]]) ifTrue: 				[	newChain := chain weakLink: candidate cell: sake.					self weakCompleteChain: newChain using: allPairsByNumber skip: strongImpliedToSkip do: block				]		].	allPairsByNumber keysAndValuesDo: 		[: number : pairs |			pairs do: 				[: pair |					number = candidate ifFalse: 						[	"when the last cell has not number the paired cell one has"							( pair first == cell and: 								[( strongImpliedToSkip includes: pair last ) not 										and: [ pair last ~~ chain firstCell or: [ chain cellSize &gt; 2 and: [ chain firstCandidate = number ]]]								]) 								ifTrue: 								[	newChain := chain strongLink: number cell: pair last.									self strongCompleteChain: newChain using: allPairsByNumber skip: strongImpliedToSkip do: block								].							( pair last == cell and: 								[( strongImpliedToSkip includes: pair first ) not 										and: [ pair first ~~ chain firstCell or: [ chain cellSize &gt; 2 and: [ chain firstCandidate = number ]]]								]) 								ifTrue: 								[	newChain := chain strongLink: number cell: pair first.									self strongCompleteChain: newChain using: allPairsByNumber skip: strongImpliedToSkip do: block								]						]				]		].</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	| allPairsByNumber |	allPairsByNumber := self allPairsByNumberIn: grid.	allPairsByNumber keysDo: [: number | self chainsIn: allPairsByNumber startingAt: number do: block ].</body><body package="SudokuSolving">weakCompleteChain: chain using: allPairsByNumber skip: strongImpliedToSkip do: block 	"chain last has given candidate - try to reach start"	| candidate cell newChain skip |	cell := chain lastCell.	chain firstCell = cell ifTrue: [ ^ self checkChain: chain do: block ].	skip := strongImpliedToSkip copy.	skip add: cell.	candidate := chain lastCandidate.	( chain cellSize &gt; 2 		and: [ chain firstCandidate = candidate and: [( chain firstCell candidatesIncludes: candidate ) and: [ chain firstCell isSake: cell ]]]) ifTrue: 		[	newChain := chain firstWeakLink: candidate cell: cell.			self checkChain: newChain do: block		].	cell candidates size = 2 ifTrue: 		[	"If a square has two weak links, then it must be bivalue (two candidates) and the link candidates must be different."			cell candidates do: 				[: other |					other == candidate ifFalse: 						[	cell allSakesDo: 								[: sake | (( sake candidatesIncludes: other ) and: 										[( skip includes: sake ) not and: [ sake ~~ chain firstCell or: [ chain cellSize &gt; 2 and: [ chain continuous ]]]										]) 										ifTrue: 										[	newChain := chain weakLink: other cell: sake.											strongImpliedToSkip add: sake.											self weakCompleteChain: newChain using: allPairsByNumber skip: skip do: block										]								]						]				]		].	( allPairsByNumber at: candidate ifAbsent: [ #( )]) do: 		[: pair |			"If a square has one strong and one weak link (in either combination), then the link candidates must be the same."			( pair first == cell and: 				[( skip includes: pair last ) not and: [ pair last ~~ chain firstCell or: [ chain cellSize &gt; 2 and: [ chain firstCandidate = candidate ]]]				]) 				ifTrue: 				[	newChain := chain strongLink: candidate cell: pair last.					self strongCompleteChain: newChain using: allPairsByNumber skip: skip do: block				].			( pair last == cell and: 				[( skip includes: pair first ) not and: [ pair first ~~ chain firstCell or: [ chain cellSize &gt; 2 and: [ chain firstCandidate = candidate ]]]				]) 				ifTrue: 				[	newChain := chain strongLink: candidate cell: pair first.					self strongCompleteChain: newChain using: allPairsByNumber skip: skip do: block				]		].</body></methods><methods><class-id>Sudoku.NiceLoops class</class-id> <category>modify</category><body package="SudokuSolving">checkChain: chain do: block 	chain cellSize &gt; 2 ifFalse: [ ^ self haltOrContinue ].	chain modifyGridByNiceLoops ifTrue: [ block value: ( self cells: chain cells links: chain links )].</body></methods><methods><class-id>Sudoku.DeathBlossom</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	^ self class modifyWithStern: ( grid cellAtX: stern x y: stern y )		alsSet: ( alsSet collect: [: als | AlmostLockedSet cells: ( als collect: [: p | grid cellAtX: p x y: p y ])])</body><body package="SudokuSolving">stern: aStern 	stern := aStern.</body></methods><methods><class-id>Sudoku.DeathBlossom class</class-id> <category>modify</category><body package="SudokuSolving">isStern: stern alsSet: alsSet 	| partition |	( stern hasCandidates and: [ stern candidates size = alsSet size and: [ alsSet allSatisfy: [: als | ( als includes: stern ) not ]]]) 		ifFalse: [ ^ false ].	partition := Dictionary new.	stern candidates do: 		[: candidate | | matching |			matching := alsSet select: [: als | self stern: stern candiate: candidate coversBy: als ].			matching isEmpty ifTrue: [ ^ false ].			partition at: candidate put: matching		].	^ self isValidPartition: partition</body><body package="SudokuSolving">isValidPartition: partition 	| min |	partition size = 1 ifTrue: [ ^ true ].	min := nil.	partition do: [: alsSet | ( min isNil or: [ alsSet size &lt; min size ]) ifTrue: [ min := alsSet ]].	min do: 		[: als | | copy |			copy := Set new.			partition do: [: alsSet | alsSet = min ifFalse: [ copy add: ( alsSet copyWithout: als )]].			( copy size = ( partition size - 1 ) and: [( copy allSatisfy: [: alsSet | alsSet notEmpty ]) and: [ self isValidPartition: copy ]]) 				ifTrue: [ ^ true ]		].	^ false</body><body package="SudokuSolving">modifyWithStern: stern alsSet: alsSet 	( self joinedCandidatesOf: alsSet ) do: 		[: candidate | ( stern candidatesIncludes: candidate ) ifFalse: 				[ | cells |					cells := self commonSakesIn: alsSet for: candidate.					cells notEmpty ifTrue: 						[	cells do: [: cell | cell removeCandidate: candidate ].							^ true						]				]		].	^ false</body><body package="SudokuSolving">stern: stern candiate: candidate coversBy: als 	^ ( als joinedCandidates includes: candidate ) 		and: [ als cells allSatisfy: [: cell | ( cell candidatesIncludes: candidate ) not or: [ cell isSake: stern ]]]</body><body package="SudokuSolving">sternIn: grid alsSet: alsSet 	| joinedCandidates cells |	cells := Set new.	joinedCandidates := nil.	alsSet do: 		[: als |			joinedCandidates := joinedCandidates notNil 					ifTrue: [ joinedCandidates * als joinedCandidates ]					ifFalse: [ als joinedCandidates ].			joinedCandidates isEmpty ifTrue: [ ^ nil ].			( cells * als cells ) notEmpty ifTrue: [ ^ nil ].			cells addAll: als cells		].	grid cellsDo: [: stern | (( self isStern: stern alsSet: alsSet ) and: [ self modifyWithStern: stern alsSet: alsSet ]) ifTrue: [ ^ stern ]].	^nil</body><body package="SudokuSolving">tipsIn: grid alsSet: alsSet do: block 	| stern |	stern := self sternIn: grid alsSet: alsSet.	stern notNil ifTrue: [ ^ block value: ( self alsSet: alsSet stern: stern )].</body></methods><methods><class-id>Sudoku.DeathBlossom class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 600</body><body package="SudokuSolving">minAlsSize	^ 3</body></methods><methods><class-id>Sudoku.DeathBlossom class</class-id> <category>instance creation</category><body package="SudokuSolving">alsSet: alsSet stern: stern 	^ ( self alsSet: alsSet )		stern: stern sudokuCellPosition;		yourself</body></methods><methods><class-id>Sudoku.MultiColouring</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	| chainA chainB |	chainA := pointsA collect: [: point | grid cellAtX: point x y: point y ].	chainB := pointsB collect: [: point | grid cellAtX: point x y: point y ].	^ self class modifyChainA: chainA chainB: chainB number: number</body><body package="SudokuSolving">pointsA: pointArray 	pointsA := pointArray.</body><body package="SudokuSolving">pointsB: pointArray 	pointsB := pointArray.</body></methods><methods><class-id>Sudoku.MultiColouring</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments gridAdornment |	gridAdornments := super adornmentsIn: grid.	gridAdornments nextAdornment: ( GridAdornment focusOnCandidate: number ).	gridAdornment := GridAdornment focusOnCandidate: number.	gridAdornment chain: 'A' positions: pointsA candidate: number.	gridAdornment chain: 'B' positions: pointsB candidate: number.	gridAdornments nextAdornment: gridAdornment.	self addModifiedCellsIn: grid to: gridAdornments.	^ gridAdornments</body></methods><methods><class-id>Sudoku.MultiColouring class</class-id> <category>instance creation</category><body package="SudokuSolving">chainA: chainA chainB: chainB number: number 	^ ( self number: number )		pointsA: ( chainA collect: [: c | c x @ c y ]);		pointsB: ( chainB collect: [: c | c x @ c y ]);		yourself</body><body package="SudokuSolving">chainsIn: pairs current: chain last: last hide: hidden do: block 	( chain size = 2 or: [ chain size odd ]) ifTrue: 		[	hidden add: last.			block value: chain		].	^ super chainsIn: pairs current: chain last: last hide: hidden do: block</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	| allPairsByNumber |	allPairsByNumber := self allPairsByNumberIn: grid.	allPairsByNumber keysAndValuesDo: 		[: number : pairs | | allChains |			allChains := OrderedCollection new.			self chainsIn: pairs current: #( ) do: [: chain | allChains addChainRemoveSubchains: chain ].			1 to: allChains size - 1				do: 				[: a |					a + 1 to: allChains size						do: 						[: b | | chainA chainB |							chainA := allChains at: a.							chainB := allChains at: b.							"It is important they don't link up"							(( pairs contains: [: pair | ( chainA contains: [: c | pair includes: c ]) and: [ chainB contains: [: c | pair includes: c ]]]) not 								and: [ self modifyChainA: chainA chainB: chainB number: number ]) ifTrue: [ block value: ( self chainA: chainA chainB: chainB number: number )]						]				]		].</body></methods><methods><class-id>Sudoku.MultiColouring class</class-id> <category>accessing</category><body package="SudokuSolving">checkCellA: cellA chainA: chainA cellB: cellB chainB: chainB number: number odds: array 	"array:	oddA oddB both"	| a b |	(( chainB includes: cellA ) or: [ chainA includes: cellB ]) ifTrue: [ ^ false ].	b := chainB indexOf: cellB ifAbsent: nil.	^ b notNil and: 		[	a := chainA indexOf: cellA.			( array at: 1 ) notNil 				ifTrue: 				[	a odd = ( array at: 1 ) 						ifTrue: 						[	b odd = ( array at: 2 ) not and: 								[	"not valid in chainA"									( cellA removeCandidate: number ) notNil								]						]						ifFalse: 						[	b odd = ( array at: 2 ) not and: 								[	array at: 3 put: true.									false								]						]				]				ifFalse: 				[	array at: 1 put: a odd.					array at: 2 put: b odd.					false				]		]</body><body package="SudokuSolving">difficulty	^ 320</body><body package="SudokuSolving">modifyChainA: chainA chainB: chainB number: number 	| array modified sakesOdd sakesEven inChain oddA oddB |	array := Array with: nil with: nil with: false.	"oddA oddB both"	modified := false.	chainA do: 		[: cellA |			cellA allSakesDo: 				[: cellB | ( self checkCellA: cellA chainA: chainA cellB: cellB chainB: chainB number: number odds: array ) ifTrue: [ modified := true ]				]		].	( array first isNil or: [ array last ]) ifTrue: [ ^ false ].	oddA := array first.	oddB := array at: 2.	sakesOdd := Set new.	sakesEven := Set new.	inChain := Set new.	inChain addAll: chainA.	inChain addAll: chainB.	"Bouns check"	chainA keysAndValuesDo: 		[: index : cellA |			index odd 				ifTrue: [ oddA not ifTrue: [ cellA allSakesDo: [: sake | sakesOdd add: sake ]]]				ifFalse: [ oddA ifTrue: [ cellA allSakesDo: [: sake | sakesEven add: sake ]]]		].	chainB keysAndValuesDo: 		[: index : cellB |			index odd 				ifTrue: 				[	oddB not ifTrue: 						[	cellB allSakesDo: 								[: sake | (( inChain includes: sake ) not and: [( sakesOdd includes: sake ) and: [( sake removeCandidate: number ) notNil ]]) 										ifTrue: [ modified := true ]								]						]				]				ifFalse: 				[	oddB ifTrue: 						[	cellB allSakesDo: 								[: sake | (( inChain includes: sake ) not and: [( sakesEven includes: sake ) and: [( sake removeCandidate: number ) notNil ]]) 										ifTrue: [ modified := true ]								]						]				]		].	^ modified</body></methods><methods><class-id>Sudoku.IntersectionRemoval</class-id> <category>accessing</category><body package="SudokuSolving">modifyGrid: grid 	| miniRC columnOrRow |	miniRC := positions collect: [: p | grid cellAtX: p x y: p y ].	columnOrRow := miniRC first x = miniRC last x 			ifTrue: [ miniRC first column ]			ifFalse: [ miniRC first row ].	^ self class modifyMiniRC: miniRC box: miniRC first box number: number against: columnOrRow</body></methods><methods><class-id>Sudoku.IntersectionRemoval</class-id> <category>testing</category><body package="SudokuSolving">needsCandidates	^ false</body></methods><methods><class-id>Sudoku.IntersectionRemoval</class-id> <category>explain</category><body package="SudokuSolving">addPositionsIn: grid to: gridAdornments 	| miniRC cellsToShow |	gridAdornments nextAdornment: ( GridAdornment focusOnCandidate: number ).	miniRC := positions collect: [: p | grid cellAtX: p x y: p y ].	cellsToShow := miniRC first x = miniRC last x 			ifTrue: [ miniRC first column ]			ifFalse: [ miniRC first row ].	( cellsToShow allSatisfy: [: cell | ( miniRC includes: cell ) or: [ cell givenOrNil notNil or: [( cell candidatesIncludes: number ) not ]]]) 		ifFalse: [ cellsToShow := miniRC first box ].	gridAdornments nextAdornment: ( GridAdornment focusOnCells: cellsToShow candidate: number ).	self addModifiedCellsIn: grid to: gridAdornments.</body></methods><methods><class-id>Sudoku.IntersectionRemoval class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 55</body><body package="SudokuSolving">isForValidation	^ true</body></methods><methods><class-id>Sudoku.IntersectionRemoval class</class-id> <category>instance creation</category><body package="SudokuSolving">check: columnOrRow against: box grid: grid context: context block: block 	| cells |	cells := Array new: grid width * grid height.	box do: 		[: cell | ( cell hasCandidates and: [ columnOrRow includes: cell ]) ifTrue: 				[	cell candidates do: 						[: number | | old |							old := cells at: number.							cells at: number put: ( old asDependentsWith: cell )						]				]		].	cells keysAndValuesDo: 		[: number : miniRC | | modified |			miniRC size &gt; 1 ifTrue: 				[	modified := self modifyMiniRC: miniRC box: box number: number against: columnOrRow.					modified ifTrue: [ block value: ( self cells: miniRC number: number )]				]		].</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	grid boxes do: 		[: box |			box first x to: box first x + grid width - 1				do: 				[: x | | column |					column := grid columns at: x.					self check: column against: box grid: grid context: context block: block				].			box first y to: box first y + grid height - 1				do: 				[: y | | row |					row := grid rows at: y.					self check: row against: box grid: grid context: context block: block				]		].</body></methods><methods><class-id>Sudoku.IntersectionRemoval class</class-id> <category>modify</category><body package="SudokuSolving">modifyMiniRC: miniRC box: box number: number against: columnOrRow 	| modified |	modified := false.	( box allSatisfy: [: c | ( miniRC includes: c ) or: [ c hasCandidates not or: [( c candidatesIncludes: number ) not ]]]) ifTrue: 		[	"remove number from intersecting columnOrRow"			columnOrRow do: [: c | (( miniRC includes: c ) not and: [( c removeCandidate: number ) notNil ]) ifTrue: [ modified := true ]]		].	( columnOrRow allSatisfy: [: c | ( miniRC includes: c ) or: [ c hasCandidates not or: [( c candidatesIncludes: number ) not ]]]) ifTrue: 		[	"remove number from intersecting box"			box do: [: c | (( miniRC includes: c ) not and: [( c removeCandidate: number ) notNil ]) ifTrue: [ modified := true ]]		].	^ modified</body></methods><methods><class-id>Sudoku.SingleChain</class-id> <category>accessing</category><body package="SudokuSolving">chainPoints: pointArray 	chainPoints := pointArray.</body><body package="SudokuSolving">modifyGrid: grid 	| chain |	chain := chainPoints collect: [: p | grid cellAtX: p x y: p y ].	^ self class modifyIn: chain number: number</body></methods><methods><class-id>Sudoku.SingleChain</class-id> <category>explain</category><body package="SudokuSolving">adornmentsIn: grid 	| gridAdornments gridAdornment |	gridAdornments := super adornmentsIn: grid.	gridAdornments nextAdornment: ( GridAdornment focusOnCandidate: number ).	gridAdornment := GridAdornment focusOnCandidate: number.	gridAdornment chain: 'A' positions: chainPoints candidate: number.	gridAdornments nextAdornment: gridAdornment.	self addModifiedCellsIn: grid to: gridAdornments.	^ gridAdornments</body></methods><methods><class-id>Sudoku.SingleChain class</class-id> <category>instance creation</category><body package="SudokuSolving">cells: cells number: number 	^ ( self number: number )		chainPoints: ( cells collect: [: c | c x @ c y ]);		yourself</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	| allPairsByNumber |	allPairsByNumber := self allPairsByNumberIn: grid.	allPairsByNumber keysAndValuesDo: 		[: number : pairs |			self chainsIn: pairs				current: #( )				do: 				[: chain | | modified |					modified := self modifyIn: chain number: number.					modified ifTrue: [ block value: ( self cells: chain number: number )]				]		].</body></methods><methods><class-id>Sudoku.SingleChain class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 198</body></methods><methods><class-id>Sudoku.SingleChain class</class-id> <category>modify</category><body package="SudokuSolving">bonusCheck: chain number: number 	| modified |	modified := false.	chain keysAndValuesDo: 		[: index : cell |			cell allSakesDo: 				[: sake | | sakeIndex |					sakeIndex := chain indexOf: sake.					( sakeIndex &gt; index and: [ sakeIndex odd = index odd ]) ifTrue: 						[	cell removeCandidate: number.							modified := true						]				]		].	^ modified</body><body package="SudokuSolving">modifyIn: chain number: number 	"first &amp; last hide number in all common sakes"	| modified |	modified := false.	chain last allSakesDo: 		[: cell | (( chain first isSake: cell ) and: [( chain includes: cell ) not and: [( cell removeCandidate: number ) notNil ]]) 				ifTrue: [ modified := true ]		].	"Bouns check"	^ modified or: [ self bonusCheck: chain number: number ]</body></methods><methods><class-id>Sudoku.WXYZWing</class-id> <category>accessing</category><body package="SudokuSolving">hingePos: aHinge 	hingePos := aHinge.</body><body package="SudokuSolving">modifyGrid: grid 	| hinge sakes |	hinge := grid cellAtX: hingePos x y: hingePos y.	( hinge hasCandidates and: [ hinge candidates size = 4 ]) ifFalse: [ ^ false ].	sakes := positions collect: [: cell | grid cellAtX: cell x y: cell y ].	( sakes allSatisfy: 		[: sake |			sake hasCandidates and: [ sake candidates size = 2 and: [ sake candidates allSatisfy: [: v | hinge candidates includes: v ]]]		]) 		ifFalse: [ ^ false ].	^ self class modifyFrom: hinge sakes: ( positions collect: [: cell | grid cellAtX: cell x y: cell y ]) number: number</body></methods><methods><class-id>Sudoku.WXYZWing</class-id> <category>explain</category><body package="SudokuSolving">addPositionsIn: grid to: gridAdornments 	| gridAdornment |	gridAdornments nextAdornment: ( GridAdornment focusOnCells: positions candidate: number ).	gridAdornment := GridAdornment focusOnCandidate: number.	gridAdornments position: hingePos candidate: number color: #modifyingSake2.	gridAdornments nextAdornment: gridAdornment.	self addModifiedCellsIn: grid to: gridAdornments.</body></methods><methods><class-id>Sudoku.WXYZWing class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 311</body><body package="SudokuSolving">niceName	^ 'WXYZ Wing'</body></methods><methods><class-id>Sudoku.WXYZWing class</class-id> <category>instance creation</category><body package="SudokuSolving">hinge: hinge cells: cells number: number 	^ ( self cells: cells number: number )		hingePos: hinge x @ hinge y;		yourself</body><body package="SudokuSolving">modifyFrom: hinge sakes: sakesByNumber number: n 	| modified |	modified := false.	hinge allSakesDo: 		[: sake | ( sake hasCandidates and: 				[( sake candidates includes: n ) and: 						[( hinge candidates allSatisfy: [: v | n = v or: [ sakesByNumber contains: [: c | ( c candidatesIncludes: v ) and: [ c isSake: sake ]]]]) 								and: [( sake removeCandidate: n ) notNil ]						]				]) 				ifTrue: [ modified := true ]		].	^ modified</body><body package="SudokuSolving">tipsIn: grid context: context do: block 	grid cellsDo: 		[: hinge | | sakesByMate |			( hinge hasCandidates and: [ hinge candidates size = 4 ]) ifTrue: 				[	sakesByMate := Dictionary new: 4.					hinge allSakesDo: 						[: sake |							sake hasCandidates ifTrue: 								[( sake candidates size = 2 and: [ sake candidates allSatisfy: [: v | hinge candidates includes: v ]]) 										ifTrue: [ sake candidatesDo: [: v | ( sakesByMate at: v ifAbsentPut: [ OrderedCollection new ]) add: sake ]]								]						].					sakesByMate size = 4 ifTrue: 						[	sakesByMate keysAndValuesDo: 								[: n : sakesByNumber | ( self modifyFrom: hinge sakes: sakesByNumber number: n ) 										ifTrue: [ block value: ( self hinge: hinge cells: sakesByNumber number: n )]								]						]				]		].</body></methods><methods><class-id>Sudoku.XYChain</class-id> <category>explain</category><body package="SudokuSolving">addPositionsIn: grid to: gridAdornments 	| gridAdornment |	gridAdornment := GridAdornment focusOnCandidate: number.	gridAdornment xyChain: ( positions collect: [: pos | grid cellAtX: pos x y: pos y ]) candidate: number.	gridAdornments nextAdornment: gridAdornment.	self addModifiedCellsIn: grid to: gridAdornments.</body></methods><methods><class-id>Sudoku.XYChain class</class-id> <category>accessing</category><body package="SudokuSolving">difficulty	^ 205</body><body package="SudokuSolving">niceName	^ 'XY Chains'</body></methods><methods><class-id>Sudoku.XYChain class</class-id> <category>instance creation</category><body package="SudokuSolving">cellsWith: a from: cellA with: b to: cellB using: pairs do: block 	self fillChain: ( OrderedCollection with: cellA ) value: a to: cellB value: b using: pairs do: block.</body><body package="SudokuSolving">fillChain: chain value: a to: cellB value: b using: pairs do: block 	pairs do: 		[: cell | | newValue |			( cellB ~= cell and: 				[	cell hasCandidates and: 						[	cell candidates size = 2 and: [( cell candidates includes: a ) and: [( chain includes: cell ) not and: [ cell isSake: chain last ]]]						]				]) 				ifTrue: 				[( a ~= b and: [( cell candidates includes: b ) and: [ cell isSake: cellB ]]) 						ifTrue: 						[	block value: ( ( chain copy )										add: cell;										add: cellB;										yourself )	"rule applies"						]						ifFalse: 						[	"extend chain"							newValue := cell candidates detect: [: n | n ~= a ].							self fillChain: ( chain copyWith: cell ) value: newValue to: cellB value: b using: pairs do: block						]				]		].</body></methods><methods><class-id>Sudoku.NakedTriples class</class-id> <category>accessing</category><body package="SudokuSolving">tupleSize	^ 3</body></methods><methods><class-id>Sudoku.HiddenPair class</class-id> <category>accessing</category><body package="SudokuSolving">tupleSize	^ 2</body></methods><methods><class-id>Core.Integer</class-id> <category>accessing</category><body package="SudokuSolving">asStrongLink	^ self</body><body package="SudokuSolving">asWeakLink	^ self negated</body></methods><methods><class-id>Core.Integer</class-id> <category>testing</category><body package="SudokuSolving">isStrongLink	^ self &gt; 0</body></methods><methods><class-id>Core.Integer</class-id> <category>accessing</category><body package="SudokuSolving">linkCandidate	^ self abs</body></methods><methods><class-id>Core.Integer</class-id> <category>printing</category><body package="SudokuSolving">printLinkOn: stream 	self isStrongLink 		ifTrue: [ stream nextPut: $= ]		ifFalse: [ stream nextPut: $- ].	self linkCandidate printOn: stream.	self isStrongLink 		ifTrue: [ stream nextPut: $= ]		ifFalse: [ stream nextPut: $- ].</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>adding</category><body package="SudokuSolving">addChainRemoveSubchains: chain 	self copy do: 		[: oldChain | (( chain indexOfSubCollection: oldChain startingAt: 1 ) &gt; 0 or: [( chain indexOfSubCollection: oldChain reverse startingAt: 1 ) &gt; 0 ]) 				ifTrue: [ self remove: oldChain ]		].	self add: chain.</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="SudokuSolving">subCollectionsSized: size do: block 	self size &lt; size ifTrue: [ ^ self ].	self subCollectionsSized: size startingAt: 1 as: 1 to: ( Array new: size ) do: block.</body><body package="SudokuSolving">subCollectionsSized: size startingAt: index as: newIndex to: sample do: block 	newIndex &gt; size 		ifTrue: [ block value: sample ]		ifFalse: 		[	index to: self size + newIndex - size				do: 				[: i |					sample at: newIndex put: ( self at: i ).					self subCollectionsSized: size startingAt: i + 1 as: newIndex + 1 to: sample do: block				]		].</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SudokuSolving">do: block randomOrNil: randomOrNil 	randomOrNil notNil 		ifTrue: 		[ | values |			values := self collect: [: value | randomOrNil next -&gt; value ].			values := values asSortedCollection: [: assoc1 : assoc2 | assoc1 key &lt;= assoc2 key ].			values do: [: assoc | block value: assoc value ]		]		ifFalse: [ self do: block ].</body><body package="SudokuSolving">sudokuCombinationsString	| stream |	stream := String new writeStream.	stream nextPut: $(.	( self asSortedCollection: 		[: p1 : p2 |			p1 x = p2 x 				ifTrue: [ p1 y &lt; p2 y ]				ifFalse: [ p1 x &lt; p2 x ]		]) 		do: 		[: v |			v x printOn: stream.			stream nextPut: $+.			v y printOn: stream		]		separatedBy: [ stream space ].	stream nextPut: $).	^ stream contents</body><body package="SudokuSolving">sudokuValuesSting	| stream |	stream := String new writeStream.	stream nextPut: $(.	self asSortedCollection 		do: [: v | v printOn: stream ]		separatedBy: [ stream space ].	stream nextPut: $).	^ stream contents</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SudokuSolving">isSudokuSolvingStrategy	^false</body></methods><methods><class-id>Sudoku.SimpleCell</class-id> <category>accessing</category><body package="SudokuSolving">allSakesDo: block 	self row do: [: c | c = self ifFalse: [ block value: c ]].	self column do: [: c | c = self ifFalse: [ block value: c ]].	self box do: [: c | ( c x = x or: [ c y = y ]) ifFalse: [ block value: c ]].</body><body package="SudokuSolving">commonCandidatesWith: cell 	^ ( self hasCandidates and: [ cell hasCandidates ]) 		ifTrue: 		[	cell candidates 				detect: [: v | value isNil or: [ value includes: v ]]				ifNone: nil		]		ifFalse: [ nil ]</body><body package="SudokuSolving">copyFrom: sourceArray to: targetArray 	| givenOrNil |	givenOrNil := ( sourceArray cellAtX: x y: y ) givenOrNil.	givenOrNil notNil ifTrue: [( targetArray cellAtX: x y: y ) given: givenOrNil ].</body><body package="SudokuSolving">copyTo: targetArray 	( targetArray cellAtX: x y: y ) given: value.</body><body package="SudokuSolving">isSake: cell 	^ self ~~ cell and: [ cell x == x or: [ cell y == y or: [ self boxIndex == cell boxIndex ]]]</body></methods><methods><class-id>Sudoku.SimpleCell</class-id> <category>solving</category><body package="SudokuSolving">isValid	| given |	given := self givenOrNil.	given isNil ifTrue: [ ^ false ].	^ (( self row contains: [: cell | cell givenOrNil == given and: [ cell ~~ self ]]) or: 		[( self column contains: [: cell | cell givenOrNil == given and: [ cell ~~ self ]]) 				or: [ self box contains: [: cell | cell givenOrNil == given and: [ cell ~~ self ]]]		]) 		not</body></methods><methods><class-id>Sudoku.SimpleCell</class-id> <category>accessing</category><body package="SudokuSolving">removeCandidate: number 	^ value isInteger 		ifTrue: [ nil ]		ifFalse: 		[	value isNil ifTrue: [ value := Candidates withAll: grid gridCandidates ].			value remove: number ifAbsent: nil		]</body><body package="SudokuSolving">resetCandidates	value isInteger ifFalse: [ value := nil ].</body><body package="SudokuSolving">resetGivenOrCandidates	value := nil.</body></methods><methods><class-id>Sudoku.Grid</class-id> <category>accessing</category><body package="SudokuSolving">invalidCell	rows do: [: row | row do: [: cell | cell isValid ifFalse: [ ^ cell ]]].	^ nil</body><body package="SudokuSolving">isValid	^ self invalidCell isNil</body><body package="SudokuSolving">resetCandidates	self cellsDo: [: cell | cell resetCandidates ].</body><body package="SudokuSolving">solve	| context |	context := SolvingContext forValidation.	^ context solveUnique: self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Grid</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rows columns boxes possibleValues height width </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuModels</package></attributes></class><class><name>SimpleCell</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y row column value boxIndex grid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuModels</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>