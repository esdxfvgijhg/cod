<?xml version="1.0"?><st-source><!-- Name: COASTViewsNotice: The MIT LicenseCopyright (c) 2013 intelligent views GmbHPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DevelopmentPrerequisites: #(#(#any 'COASTClient' '') #(#any 'COASTCore' ''))PackageName: COASTViewsParcel: #('COASTViews')ParcelDirectory: COASTViewsPrerequisiteDescriptions: #(#(#name 'COASTClient' #componentType #package) #(#name 'COASTCore' #componentType #bundle))PrerequisiteParcels: #(#('COASTClient' '') #('COASTCore' ''))Version: 5.4.42Date: 11:13:27 AM July 18, 2014 --><time-stamp>From VisualWorksÂ®, 7.10.1 of 6. Februar 2014 on 18. Juli 2014 at 11:13:27</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CoastAspectAdaptor</name><environment>COAST</environment><super>COAST.CatFSVirtualFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frame slot writeBlock useBlock updateBlock dependents standByMode changesCompareBlock initialComputing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastListSelectionAspectAdaptor</name><environment>COAST</environment><super>COAST.CoastAspectAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>AutomaticVisualPart</name><environment>COAST</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>viewState subjects valid isOpen </inst-vars><class-inst-vars>viewStatePrototype </class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>SimpleWrapperView</name><environment>COAST</environment><super>COAST.AutomaticVisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastDependentPart</name><environment>COAST</environment><super>COAST.AutomaticVisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model modelComputationBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastListAspectAdaptor</name><environment>COAST</environment><super>COAST.CoastAspectAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionAdaptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastMultiSelectionInList</name><environment>COAST</environment><super>UI.MultiSelectionInList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastDifferentialMultiSelectionInList</name><environment>COAST</environment><super>COAST.CoastMultiSelectionInList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastSelectionTracker</name><environment>COAST</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstPosition sensor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIControllers</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastConfigurableTracker</name><environment>COAST</environment><super>COAST.CoastSelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blueButtonPressedJob blueButtonReleasedJob doubleClickJob enterJob exitJob mouseMovedJob redButtonPressedJob redButtonReleasedJob unknownJob windowEnterJob windowExitJob yellowButtonPressedJob yellowButtonReleasedJob </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIControllers</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastBlockAdaptor</name><environment>COAST</environment><super>COAST.CoastAspectAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readOnlyBlock subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastComboBoxAdaptor</name><environment>COAST</environment><super>COAST.CoastAspectAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>displayStringBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>KBaseUI</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastController</name><environment>COAST</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trackers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIControllers</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastNoController</name><environment>COAST</environment><super>COAST.CoastController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIControllers</category><attributes><package>COASTViews</package></attributes></class><class><name>ComboBoxText</name><environment>COAST</environment><super>Core.Text</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wrappedComboBoxObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>COASTViews</package></attributes></class><comment><class-id>COAST.ComboBoxText</class-id><body>ComboBoxText </body></comment><class><name>CoastLocalApplicationModel</name><environment>COAST</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sharedApplicationModel viewState localUser coastDialog closedLocally </inst-vars><class-inst-vars>viewStatePrototype </class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastNotifierLocal</name><environment>COAST</environment><super>COAST.CoastLocalApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastEagerAspectAdaptor</name><environment>COAST</environment><super>COAST.CoastAspectAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastDifferentialListAspectAdaptor</name><environment>COAST</environment><super>COAST.CoastAspectAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elementValuesBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTViews</category><attributes><package>COASTViews</package></attributes></class><class><name>PersonalizedValueHolder</name><environment>COAST</environment><super>COAST.CoastModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><comment><class-id>COAST.PersonalizedValueHolder</class-id><body>CoastPersonalizedValueHolder provides transparent access to otherwise shared values. This is useful for visualization of awareness information such as remote selection.</body></comment><class><name>CoastPersonalizedValueHolder</name><environment>COAST</environment><super>COAST.PersonalizedValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>ComposedTranslatingWrapper</name><environment>COAST</environment><super>COAST.SimpleWrapperView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>translationBlock translationForInvalidation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastView</name><environment>COAST</environment><super>COAST.CoastDependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastCompositeView</name><environment>COAST</environment><super>COAST.CoastView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldComponentDictionary subViewClassComputingBlock keyboardProcessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>WrapperView</name><environment>COAST</environment><super>COAST.CoastView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastWidgetCompositeView</name><environment>COAST</environment><super>COAST.CoastCompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>BoundedCompositeView</name><environment>COAST</environment><super>COAST.CoastCompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>BorderView</name><environment>COAST</environment><super>COAST.WrapperView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>NonCoastViewWrapper</name><environment>COAST</environment><super>COAST.WrapperView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>OrderedCompositeView</name><environment>COAST</environment><super>COAST.BoundedCompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>ListView</name><environment>COAST</environment><super>COAST.OrderedCompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>MatrixView</name><environment>COAST</environment><super>COAST.OrderedCompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>AlignedCompositeView</name><environment>COAST</environment><super>COAST.OrderedCompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cachedMaximumExtent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastSelectionInList</name><environment>COAST</environment><super>UI.SelectionInList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>NonmodalNotifier</name><environment>COAST</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastSubjectAdaptor</name><environment>COAST</environment><super>COAST.CatFSVirtualFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFramesystem</category><attributes><package>COASTViews</package></attributes></class><class><name>ViewState</name><environment>COAST</environment><super>COAST.CatFSVirtualFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>view prototype isActive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastSequenceViewSpec</name><environment>COAST</environment><super>UI.SequenceViewSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>avoidScrolling </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastInvalidViewStateError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COASTViews</package></attributes></class><class><name>TransactionWrapper</name><environment>COAST</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transactionManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastSimpleLocalApplicationModel</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sharedApplicationModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastDropSource</name><environment>COAST</environment><super>UI.DropSource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIControllers</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastWidgetCompositeModel</name><environment>COAST</environment><super>COAST.CoastModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface</category><attributes><package>COASTViews</package></attributes></class><class><name>MultiSelectionSequenceViewAvoidScrolling</name><environment>COAST</environment><super>UI.MultiSelectionSequenceView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>MediatorLostApp</name><environment>COAST</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>VirtualAlignedListAdaptor</name><environment>COAST</environment><super>COAST.CatFSVirtualFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>SequenceViewAvoidScrolling</name><environment>COAST</environment><super>UI.SequenceView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>COASTViews</package></attributes></class><class><name>WidgetStateAdaptor</name><environment>COAST</environment><super>COAST.CatFSVirtualFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>widgetWrapper isEnabledBlock isVisibleBlock labelStringBlock layoutBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastInputFieldSpec</name><environment>COAST</environment><super>UI.InputFieldSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastScrollValueHolder</name><environment>COAST</environment><super>UI.ScrollValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frame slot writeBlock useBlock updateBlock listener recursionLock readOnly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>EagerInterestsObserver</name><environment>COAST</environment><super>COAST.CoastEagerDifferencesObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>monitoredUser applicationDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSEagerObservers</category><attributes><package>COASTViews</package></attributes></class><class><name>VirtualAlignedList</name><environment>COAST</environment><super>COAST.CatFSVirtualFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastArbitraryComponentSpec</name><environment>COAST</environment><super>UI.ArbitraryComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastSimpleDialog</name><environment>COAST</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>embeddedApp embeddedBuilder embeddedBounds windowType transactionManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>COASTViews</package></attributes></class><class><name>WidgetTransactionWrapper</name><environment>COAST</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastApplicationClientWithUI</name><environment>COAST</environment><super>COAST.CoastApplicationClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><methods><class-id>COAST.CoastController class</class-id> <category>resources</category><body package="COASTViews">devopmentMenu	"MenuEditor new openOnClass: self andSelector: #devopmentMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: 'inspect' 				#value: #inspect ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>COAST.CoastLocalApplicationModel class</class-id> <category>resources</category><body package="COASTViews">windowIcon	"UIMaskEditor new openOnClass: self andSelector: #windowIcon"	&lt;resource: #image&gt;	^(Image extent: 32@32 depth: 7 bitsPerPixel: 8 palette: (MappedPalette withColors: ((Array new: 100) at: 1 put: (ColorValue scaledRed: 4756 scaledGreen: 2113 scaledBlue: 792); at: 2 put: (ColorValue scaledRed: 3699 scaledGreen: 2378 scaledBlue: 1585); at: 3 put: (ColorValue scaledRed: 5812 scaledGreen: 5020 scaledBlue: 4491); at: 4 put: (ColorValue scaledRed: 7926 scaledGreen: 7662 scaledBlue: 7398); at: 5 put: (ColorValue scaledRed: 3963 scaledGreen: 2378 scaledBlue: 1321); at: 6 put: (ColorValue scaledRed: 3170 scaledGreen: 1585 scaledBlue: 792); at: 7 put: (ColorValue scaledRed: 3434 scaledGreen: 2378 scaledBlue: 1849); at: 8 put: (ColorValue scaledRed: 5020 scaledGreen: 4227 scaledBlue: 3963); at: 9 put: (ColorValue scaledRed: 3434 scaledGreen: 1585 scaledBlue: 528); at: 10 put: (ColorValue scaledRed: 7398 scaledGreen: 6869 scaledBlue: 6605); at: 11 put: (ColorValue scaledRed: 1849 scaledGreen: 1056 scaledBlue: 528); at: 12 put: (ColorValue scaledRed: 6869 scaledGreen: 3170 scaledBlue: 1056); at: 13 put: (ColorValue scaledRed: 5284 scaledGreen: 4227 scaledBlue: 3699); at: 14 put: (ColorValue scaledRed: 5548 scaledGreen: 2642 scaledBlue: 792); at: 15 put: (ColorValue scaledRed: 6077 scaledGreen: 5548 scaledBlue: 5020); at: 16 put: (ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 7926); at: 17 put: (ColorValue scaledRed: 4227 scaledGreen: 2113 scaledBlue: 528); at: 18 put: (ColorValue scaledRed: 3170 scaledGreen: 2113 scaledBlue: 1585); at: 19 put: (ColorValue scaledRed: 5548 scaledGreen: 4756 scaledBlue: 4227); at: 20 put: (ColorValue scaledRed: 7662 scaledGreen: 7398 scaledBlue: 7134); at: 21 put: (ColorValue scaledRed: 2642 scaledGreen: 1321 scaledBlue: 792); at: 22 put: (ColorValue scaledRed: 5020 scaledGreen: 3963 scaledBlue: 3434); at: 23 put: (ColorValue scaledRed: 7134 scaledGreen: 6605 scaledBlue: 6341); at: 24 put: (ColorValue scaledRed: 6605 scaledGreen: 5812 scaledBlue: 5548); at: 25 put: (ColorValue scaledRed: 5020 scaledGreen: 2378 scaledBlue: 792); at: 26 put: (ColorValue scaledRed: 7926 scaledGreen: 7926 scaledBlue: 7662); at: 27 put: (ColorValue scaledRed: 3170 scaledGreen: 1849 scaledBlue: 1056); at: 28 put: (ColorValue scaledRed: 5284 scaledGreen: 4491 scaledBlue: 3963); at: 29 put: (ColorValue scaledRed: 5020 scaledGreen: 4491 scaledBlue: 4227); at: 30 put: (ColorValue scaledRed: 7398 scaledGreen: 7134 scaledBlue: 6869); at: 31 put: (ColorValue scaledRed: 1849 scaledGreen: 1321 scaledBlue: 792); at: 32 put: (ColorValue scaledRed: 7134 scaledGreen: 3434 scaledBlue: 1056); at: 33 put: (ColorValue scaledRed: 4491 scaledGreen: 3699 scaledBlue: 3434); at: 34 put: (ColorValue scaledRed: 6869 scaledGreen: 6341 scaledBlue: 6077); at: 35 put: (ColorValue scaledRed: 7134 scaledGreen: 6341 scaledBlue: 5812); at: 36 put: (ColorValue scaledRed: 4227 scaledGreen: 2906 scaledBlue: 2378); at: 37 put: (ColorValue scaledRed: 6605 scaledGreen: 5548 scaledBlue: 5020); at: 38 put: (ColorValue scaledRed: 6341 scaledGreen: 5548 scaledBlue: 5284); at: 39 put: (ColorValue scaledRed: 6077 scaledGreen: 2642 scaledBlue: 792); at: 40 put: (ColorValue scaledRed: 4491 scaledGreen: 2113 scaledBlue: 792); at: 41 put: (ColorValue scaledRed: 7662 scaledGreen: 7662 scaledBlue: 7398); at: 42 put: (ColorValue scaledRed: 3170 scaledGreen: 1585 scaledBlue: 528); at: 43 put: (ColorValue scaledRed: 4756 scaledGreen: 4227 scaledBlue: 3963); at: 44 put: (ColorValue scaledRed: 6605 scaledGreen: 3170 scaledBlue: 1056); at: 45 put: (ColorValue scaledRed: 4491 scaledGreen: 3434 scaledBlue: 2906); at: 46 put: (ColorValue scaledRed: 6605 scaledGreen: 6077 scaledBlue: 5812); at: 47 put: (ColorValue scaledRed: 5548 scaledGreen: 2378 scaledBlue: 792); at: 48 put: (ColorValue scaledRed: 5284 scaledGreen: 2642 scaledBlue: 792); at: 49 put: (ColorValue scaledRed: 8191 scaledGreen: 7926 scaledBlue: 7926); at: 50 put: (ColorValue scaledRed: 4227 scaledGreen: 1849 scaledBlue: 528); at: 51 put: (ColorValue scaledRed: 3170 scaledGreen: 2113 scaledBlue: 1321); at: 52 put: (ColorValue scaledRed: 2906 scaledGreen: 2113 scaledBlue: 1585); at: 53 put: (ColorValue scaledRed: 3963 scaledGreen: 1849 scaledBlue: 792); at: 54 put: (ColorValue scaledRed: 2378 scaledGreen: 1321 scaledBlue: 792); at: 55 put: (ColorValue scaledRed: 4756 scaledGreen: 3963 scaledBlue: 3434); at: 56 put: (ColorValue scaledRed: 7398 scaledGreen: 3434 scaledBlue: 1321); at: 57 put: (ColorValue scaledRed: 4227 scaledGreen: 3170 scaledBlue: 2642); at: 58 put: (ColorValue scaledRed: 6605 scaledGreen: 5812 scaledBlue: 5284); at: 59 put: (ColorValue scaledRed: 6341 scaledGreen: 2906 scaledBlue: 792); at: 60 put: (ColorValue scaledRed: 3434 scaledGreen: 2642 scaledBlue: 1849); at: 61 put: (ColorValue scaledRed: 3170 scaledGreen: 2642 scaledBlue: 2113); at: 62 put: (ColorValue scaledRed: 5812 scaledGreen: 5020 scaledBlue: 4756); at: 63 put: (ColorValue scaledRed: 7926 scaledGreen: 7662 scaledBlue: 7662); at: 64 put: (ColorValue scaledRed: 3963 scaledGreen: 2378 scaledBlue: 1585); at: 65 put: (ColorValue scaledRed: 2642 scaledGreen: 1849 scaledBlue: 1321); at: 66 put: (ColorValue scaledRed: 7134 scaledGreen: 3170 scaledBlue: 1056); at: 67 put: (ColorValue scaledRed: 4756 scaledGreen: 3699 scaledBlue: 2906); at: 68 put: (ColorValue scaledRed: 5812 scaledGreen: 2642 scaledBlue: 792); at: 69 put: (ColorValue scaledRed: 6077 scaledGreen: 5548 scaledBlue: 5284); at: 70 put: ColorValue white; at: 71 put: (ColorValue scaledRed: 3963 scaledGreen: 2113 scaledBlue: 1056); at: 72 put: (ColorValue scaledRed: 3699 scaledGreen: 2113 scaledBlue: 1321); at: 73 put: (ColorValue scaledRed: 4491 scaledGreen: 2113 scaledBlue: 528); at: 74 put: (ColorValue scaledRed: 7926 scaledGreen: 7398 scaledBlue: 7134); at: 75 put: (ColorValue scaledRed: 5548 scaledGreen: 4756 scaledBlue: 4491); at: 76 put: (ColorValue scaledRed: 7662 scaledGreen: 7398 scaledBlue: 7398); at: 77 put: (ColorValue scaledRed: 4227 scaledGreen: 2113 scaledBlue: 792); at: 78 put: (ColorValue scaledRed: 7398 scaledGreen: 6605 scaledBlue: 6341); at: 79 put: (ColorValue scaledRed: 4491 scaledGreen: 3434 scaledBlue: 2642); at: 80 put: (ColorValue scaledRed: 4227 scaledGreen: 3434 scaledBlue: 2906); at: 81 put: (ColorValue scaledRed: 6869 scaledGreen: 6077 scaledBlue: 5284); at: 82 put: (ColorValue scaledRed: 3963 scaledGreen: 3434 scaledBlue: 3170); at: 83 put: (ColorValue scaledRed: 4227 scaledGreen: 2642 scaledBlue: 1585); at: 84 put: (ColorValue scaledRed: 5284 scaledGreen: 2378 scaledBlue: 792); at: 85 put: (ColorValue scaledRed: 5812 scaledGreen: 5284 scaledBlue: 5020); at: 86 put: (ColorValue scaledRed: 7926 scaledGreen: 7926 scaledBlue: 7926); at: 87 put: (ColorValue scaledRed: 3434 scaledGreen: 1849 scaledBlue: 1056); at: 88 put: (ColorValue scaledRed: 3699 scaledGreen: 1849 scaledBlue: 792); at: 89 put: (ColorValue scaledRed: 5284 scaledGreen: 4491 scaledBlue: 4227); at: 90 put: (ColorValue scaledRed: 3963 scaledGreen: 1849 scaledBlue: 528); at: 91 put: (ColorValue scaledRed: 2642 scaledGreen: 2113 scaledBlue: 1585); at: 92 put: (ColorValue scaledRed: 2906 scaledGreen: 2906 scaledBlue: 2642); at: 93 put: (ColorValue scaledRed: 2113 scaledGreen: 1321 scaledBlue: 792); at: 94 put: (ColorValue scaledRed: 7398 scaledGreen: 3434 scaledBlue: 1056); at: 95 put: (ColorValue scaledRed: 2378 scaledGreen: 1321 scaledBlue: 528); at: 96 put: (ColorValue scaledRed: 6077 scaledGreen: 5284 scaledBlue: 4756); at: 97 put: (ColorValue scaledRed: 7134 scaledGreen: 6341 scaledBlue: 6077); at: 98 put: (ColorValue scaledRed: 6077 scaledGreen: 2906 scaledBlue: 792); at: 99 put: (ColorValue scaledRed: 6341 scaledGreen: 5812 scaledBlue: 5284); at: 100 put: (ColorValue scaledRed: 3963 scaledGreen: 3170 scaledBlue: 2642); yourself)) usingBits: (ByteArray fromPackedString: 'QTUEQTUEQTUEQTUEQQX^D$UEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEV@4QLDUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTT6B4YIQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQT9AFB5EQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUET%5!M$UEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQSAGWU5GFTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUE@4Y]WTL=QTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTTVI55]WPP&gt;QTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQR5SWU5]RAYEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEKP5]WU5SX$UEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTT-K%5]WTLBQTUEQTUEQTUEQTUEQTUEC1$]GQ4]FP=EQRD@WU5]XPIEQTT&gt;XBP$NU@"SR!EO$(;U5$''T2]FH0\]@4Y]WU5C@#9TN@T1K5MSF@@PWA4&lt;R@-]WU5]WU5ACPUB@P-]WPAOU! KM55]WU4KP2\FR5MAN"-]WU5]WU5]WS(HP55]DE$KWU5]WU5AD@YJE#AENB0*TPT:WU5]WU5]WU5]WU5]WU5]WU4+@C0!LDUEQTUEQTUEBU)YG55]WU5]WU5]WU5]WU5]T3UDUTUEQTUEQTUEQTUELBU#AD0@@E5]WU5]WU5]T40 @4UEQTUEQTUEQTUEQTUEQTT&gt;GR5^WU5]WU5]WU4JEQ%EQTUEQTUEQTUEQTUEQTUEQTUE@%M]WU5]WU5]WQ&lt;XL$QEQTUEQTUEQTUEQTUEQTUEQTT,J55]P2$KWU5]WU5ABC5EQTUEQTUEQTUEQTUEQTUEQR0KWU5HF19!M55]WU4_U6IEQTUEQTUEQTUEQTUEQTUEER-]WT0(GU,ET3)AWU5ADPMEQTUEQTUEQTUEQTUEQTTLN%5]T#AEQQ4-F482SB-HE4UEQTUEQTUEQTUEQTUEQP0+WR-QQTUEQTUEQS@!L048QTUEQTUEQTUEQTUEQTUES0-]S@%EQTUEQTUEQTT]MS=EQTUEQTUEQTUEQTUEQQ$ZWRX,QTUEQTUEQTUEQTT\S4UEQTUEQTUEQTUEQTUEC!!AE@%EQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQT-@B3Q_QTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEIT!LUDUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTU AQUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTUEQTT]LDUEQTUEQTUEQTUEQTUEQTUEQTUEQP@a'))</body><body package="COASTViews">windowIconMask	"UIMaskEditor new openOnClass: self andSelector: #windowIconMask"	&lt;resource: #image&gt;	^(Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255])</body></methods><methods><class-id>COAST.CoastNotifierLocal class</class-id> <category>interface specs</category><body package="COASTViews">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Notifier' 			#max: #(#{Core.Point} 790 122 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 889 554 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -25 1 0.5 0 ) 					#model: #ok 					#label: 'ok' 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -30 1 ) 					#name: #COASTTextEditor1 					#isOpaque: true 					#model: #message 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) ) ) )</body></methods><methods><class-id>COAST.NonmodalNotifier class</class-id> <category>interface specs</category><body package="COASTViews">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Notifier' 			#max: #(#{Core.Point} 790 121 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 948 553 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 69 0 0.5 0 ) 					#model: #closeRequest 					#label: 'ok' 					#defaultable: true ) 				#(#{COAST.CoastInputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 12 0 -15 1 32 0 ) 					#flags: 0 					#model: #message 					#tabable: false 					#alignment: #center 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>COAST.CoastSequenceViewSpec class</class-id> <category>interface specs</category><body package="COASTViews">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 300 206 ) 			#max: #(#{Core.Point} 300 206 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 876 638 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: 'COAST List View' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 55 0 0 1 ) 					#label: 'Aspect:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 118 0 0 1 ) 					#label: 'ID:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 86 0 0 1 ) 					#label: 'Menu:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 29 0 -10 1 54 0 ) 					#model: #model 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 60 0 -10 1 85 0 ) 					#model: #menu 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 92 0 -10 1 117 0 ) 					#model: #name 					#menu: #fieldMenu ) ) ) )</body><body package="COASTViews">detailsEditSpec	"Tools.UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 235 229 ) 			#max: #(#{Core.Point} 256 333 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1056 933 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 28 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #FontC 						#defaultString: 'Font:' 						#catalogID: #UIPainter ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 50 0 -10 1 97 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ScrollBars 						#defaultString: 'Scroll Bars' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 291 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #SelectionType 						#defaultString: 'Selection Type:' 						#catalogID: #UIPainter ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 55 0 28 0 -10 1 52 0 ) 					#name: #fontMenu 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 17 69 ) 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Horizontal 						#defaultString: 'Horizontal' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 132 69 ) 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Vertical 						#defaultString: 'Vertical' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 99 ) 					#model: #hasBorder 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Bordered 						#defaultString: 'Bordered' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 120 ) 					#model: #isOpaque 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Opaque 						#defaultString: 'Opaque' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 141 ) 					#model: #tabable 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #CanTab 						#defaultString: 'Can Tab' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 162 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InitiallyInvisible 						#defaultString: 'Initially Invisible' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 183 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InitiallyDisabled 						#defaultString: 'Initially Disabled' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 204 ) 					#model: #multipleSelections 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #MultiSelect 						#defaultString: 'Multi Select' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 225 ) 					#model: #useModifierKeys 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #GenKey20 						#defaultString: 'Use Modifier Keys For Multi Select' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 246 ) 					#name: #CheckBox1 					#model: #autoSelect 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #AutoSelectOnKeyNavigation 						#defaultString: 'Auto Select on Key Navigation' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 267 ) 					#name: #CheckBox2 					#model: #avoidScrolling 					#label: 'Avoid Scrolling on List Change' ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 291 0 -10 1 315 0 ) 					#model: #selectionType 					#menu: #selectionTypeMenu ) ) ) )</body></methods><methods><class-id>COAST.CoastSequenceViewSpec class</class-id> <category>resources</category><body package="COASTViews">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 0 scaledGreen: 5020 scaledBlue: 8191); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 7134); at: 5 put: (ColorValue scaledRed: 5000 scaledGreen: 5000 scaledBlue: 8000); at: 6 put: (ColorValue scaledRed: 3699 scaledGreen: 3699 scaledBlue: 3699); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@H"H"H"H"H"H"H"H%@@@@@BQDQDQDQDQDQDQDQP@@@@@$QDQDQDQDQDQDQDT@@@@@ID@@@@@@@@@@@@QE@@@@@BQ@H"H"H"H"HBHDQP@@@@@$PBH"H"H"H"@"ADT@@@@@ID@ @@@@@@H @@QE@@@@@BQ@H"H"H"H"HADDQP@@@@@$PBH"H"H"H"@QADT@@@@@ID@3L3L3L3L DPQE@@@@@BQ@L2H"H"H3HADDQP@@@@@$PCL3L3L3L2@QADT@@@@@ID@"H"H"H"H DPQE@@@@@BQ@H"H"H"H"HADDQP@@@@@$PB@@@@@@@"@QADT@@@@@ID@"H"H"H"H DPQE@@@@@BQ@H"H"H"H"HADDQP@@@@@$PB@@@@@@@"@@ADT@@@@@ID@"H"H"H"H H QE@@@@@BQ@H"H"H"H"HBHDQP@@@@@$P@@@@@@@@@@@ADT@@@@@IDQDQDQDQDQDQDQE@@@@@BQDQDQDQDQDQDQDQP@@@@AUUUUUUUUUUUUUUUT@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body></methods><methods><class-id>COAST.MediatorLostApp class</class-id> <category>interface specs</category><body package="COASTViews">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'COAST-Fehler' 			#bounds: #(#{Graphics.Rectangle} 576 432 874 497 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 14 7 ) 					#label: 'Die Verbindung zum Server wurde abgebrochen' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 123 30 171 55 ) 					#model: #closeRequest 					#label: 'Schade' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>COAST.CoastInputFieldSpec class</class-id> <category>interface specs</category><body package="COASTViews">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 300 357 ) 			#max: #(#{Core.Point} 300 357 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 876 789 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 114 0 0 1 ) 					#label: 'ID:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 54 0 0 1 ) 					#label: 'Aspect:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 140 0 0 1 ) 					#label: 'Type:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: 'COAST Input Field' ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 118 0 -10 1 140 0 ) 					#model: #type 					#menu: #typeMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 83 0 0 1 ) 					#label: 'Menu:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 28 0 -10 1 53 0 ) 					#model: #model 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 58 0 -10 1 83 0 ) 					#model: #menu 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 88 0 -10 1 113 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 148 0 -10 1 173 0 ) 					#name: #formatEditor 					#model: #formatString 					#menu: #fieldMenu 					#isReadOnly: false 					#comboList: #defaultFormats ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 174 0 0 1 ) 					#name: #formatLabel 					#label: 'Format:' ) ) ) )</body></methods><methods><class-id>COAST.CoastInputFieldSpec class</class-id> <category>resources</category><body package="COASTViews">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: (ColorValue scaledRed: 5000 scaledGreen: 5000 scaledBlue: 8000); at: 4 put: ColorValue white; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@???????=@@C*******$@@N*******P@@:******)@@C*******$@@N*******P@@:******)@@C*******$@@N @@@@@JP@@:O????&lt;)@@C(?&lt;???2$@@N#@0LO?JP@@:L3L3&lt;&lt;)@@C(0LCC@2$@@N#?????JP@@:O????&lt;)@@C(@@@@@B$@@N*******P@@:******)@@C*******$@@N*******P@@:******)@@C*******$@@EUUUUUUUP@@@@@@@@@@@@@@a'))</body></methods><methods><class-id>COAST.CoastArbitraryComponentSpec class</class-id> <category>interface specs</category><body package="COASTViews">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 294 201 ) 			#max: #(#{Core.Point} 294 201 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 870 633 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 30 0 -10 1 55 0 ) 					#model: #component 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 63 0 -10 1 88 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: 'COAST View Holder' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 89 0 0 1 ) 					#label: 'ID:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 56 0 0 1 ) 					#label: 'View:' ) ) ) )</body></methods><methods><class-id>COAST.CoastArbitraryComponentSpec class</class-id> <category>resources</category><body package="COASTViews">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 4079 scaledGreen: 5461 scaledBlue: 8191); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 8191 scaledGreen: 2730 scaledBlue: 2024); at: 6 put: ColorValue blue; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQ@@@@@@@@@@@@DR@@@@@CDPUUUUUUUUUUTAD @@@@@1D@@@@@@@@@@@@QH@@@@@LQ@3L3L3L3L3L0DR@@@@@CDPL@@0@@@0@3LAD @@@@@1DCL3L3L3L3L3@QH@@@@@LQ@0@3L3L3L3L0DR@@@@@CDPL3L3L3L3L3LAD @@@@@1DCL3@@@CL3L3@QH@@@@@LQ@3L@LCLCL3L0DR@@@@@CDPL0@C@3@@L3LAD @@@@@1DC@@@@@@Q@@3@QH@@@@@LQ@0Q@PDPDQ@@0DR@@@@@CDPL@@@@@@@@@LAD @@@@@1DCL@@3L3@@L3@QH@@@@@LQ@3LCL3L3@3L0DR@@@@@CDPL3L3L3L3L3LAD @@@@@1D@@@@@@@@@@@@QH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body></methods><methods><class-id>COAST.CoastSimpleDialog class</class-id> <category>interface specs</category><body package="COASTViews">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#bounds: #(#{Graphics.Rectangle} 640 480 840 680 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #__embeddedSpec 					#flags: 0 ) ) ) )</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures</category><body package="COASTViews">SetWindowPos: hWnd insertAfter: hWndInsertAfter x: X y: Y cx: cx cy: cy flags: uFlags	&lt;C: BOOL SetWindowPos(          HWND hWnd,    HWND hWndInsertAfter,    int X,    int Y,    int cx,    int cy,    UINT uFlags)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>COAST.CoastAspectAdaptor</class-id> <category>private</category><body package="COASTViews">bestDisplayDo: aBlock	^ self transactionManager bestDisplayDo: aBlock</body><body package="COASTViews">bestTransactionDo: aBlock	^ self transactionManager bestTransactionDo: aBlock</body><body package="COASTViews">frame: aFrame	frame := aFrame</body><body package="COASTViews">isActive	^ self standByMode not</body><body package="COASTViews">isValue: oldValue equalTo: newValue 	^ changesCompareBlock notNil 		ifTrue: [ changesCompareBlock value: oldValue value: newValue ]		ifFalse: [ oldValue equalForCoastAspect: newValue ]</body><body package="COASTViews">myDependents	"Answer the receiver's dependents or nil."	^dependents</body><body package="COASTViews">myDependents: dependentsOrNil	"Set the receivers dependents."	dependents := dependentsOrNil</body><body package="COASTViews">privateSetValue: newValue	useBlock notNil		ifTrue: [ useBlock			ifTrue: [ writeBlock value: newValue ]			ifFalse: [ frame at: slot set: newValue ] ].</body><body package="COASTViews">slot: aSlotName	slot := aSlotName</body><body package="COASTViews">standByMode	" true if the aspect adaptor is in standby mode. in standby mode, no updates	are performed "	^ standByMode == true</body><body package="COASTViews">useBlock: aBoolean	useBlock := aBoolean</body><body package="COASTViews">writeBlock: aBlock	writeBlock := aBlock</body></methods><methods><class-id>COAST.CoastAspectAdaptor</class-id> <category>initialize-release</category><body package="COASTViews">aspectAdaptorFinishObservation	" stop observerving "	| myValueSlot |	standByMode := true.	( myValueSlot := self basicSlotNamed: #value ) notNil ifTrue: [ myValueSlot finishObservation ].</body><body package="COASTViews">checkStandBy	self dependents isEmpty		ifTrue: [ self standBy ].</body><body package="COASTViews">standBy	" the aspect adaptor is currently not needed any more. however, it	may be reused "	" stop observerving, but stay alive "	| myValueSlot |	standByMode == true ifTrue: [ ^self ].	standByMode := true.	(myValueSlot := self basicSlotNamed: #value) notNil		ifTrue: [			myValueSlot				flushSubjects;				isValid: false.		].</body></methods><methods><class-id>COAST.CoastAspectAdaptor</class-id> <category>accessing</category><body package="COASTViews">changesCompareBlock	^ changesCompareBlock</body><body package="COASTViews">changesCompareBlock: aChangesCompareBlock 	changesCompareBlock := aChangesCompareBlock.</body><body package="COASTViews">isBuffering	"ValueModels by default do not buffer values, only special subclasses who should reimplement this message for themselves."	^false</body><body package="COASTViews">setValue: newValue	"  ignored "</body><body package="COASTViews">updateBlock: aBlock		updateBlock := aBlock.	self value.</body><body package="COASTViews">value	" returns the adapted value "	" wake up if necessary "	standByMode == true ifTrue: [		standByMode := false.		self bestDisplayDo: [ ( self slotNamed: #value ) invalidate ].	].	^self at: #value</body><body package="COASTViews">value: newValue	" Update the value of this valueholder and the according slot "	| transaction |	transaction := nil.	self bestTransactionDo: [ : t |		transaction := t.		self privateSetValue: newValue coastCopyOrSelfForAspectAdaptor	].	"transaction was not successful - inform classic dependents (ui!)"	(transaction notNil and: [ transaction wasRolledBack ]) ifTrue: [ self changed: #value ].</body></methods><methods><class-id>COAST.CoastAspectAdaptor</class-id> <category>testing</category><body package="COASTViews">isEnabled	^true</body></methods><methods><class-id>COAST.CoastAspectAdaptor</class-id> <category>dependents access</category><body package="COASTViews">addDependent: anObject	"Add anObject as one of the receiver's dependents."	self myDependents: (self myDependents asDependentsWith: anObject).	standByMode == true ifTrue: [ standByMode := false. self bestDisplayDo: [ self at: #value ] ].	^anObject</body><body package="COASTViews">changed: slotName	self isActive		ifTrue: [			[	| win |				[	self transactionManager displayDo:					[						self myDependents coastAsSet do: [ :e |							self value notNil								ifTrue: [ e update: slotName with: nil from: self ].						 ]					].					(win := Window currentWindow) notNil 						ifTrue: [									win controller checkForEvents.						]				]					on: Error					do: [ :ex | CoastLog log: 'Error in ', thisContext printString, ': ', ex description ]			] fork.	]</body><body package="COASTViews">coastInvalidatedSlot: slotName 	| transaction |	self isActive ifFalse: [ ^ self ].	transaction := self transactionManager activeTransactionOfCurrentProcess.	transaction isNil ifTrue: [ ^ self changed: slotName ].</body><body package="COASTViews">notifyDependentsAfterComputation: newValue 	| transaction checkInitialValue |	checkInitialValue := initialComputing == true.	checkInitialValue ifTrue: [ initialComputing := false ].	( self basicSlotNamed: #value ) ifNotNil: 		[: valueSlot | | oldValue |			oldValue := valueSlot basicValueHolderContent.			( oldValue isNil and: [ checkInitialValue ]) ifTrue: [ ^ self	"initial value" ].			( self isValue: oldValue equalTo: newValue ) ifTrue: [ ^ self	"same value" ]		].	transaction := self transactionManager activeTransactionOfCurrentProcess.	transaction isNil ifTrue: [ ^ self ].	self notifyDependentsInTransaction: transaction value: nil.</body><body package="COASTViews">notifyDependentsInTransaction: transaction value: value 	transaction addPostViewUpdateBlock: 		[				[ | deps |				deps := self myDependents coastAsSet.				deps do: [: e | e update: #value with: value from: self. e invalidateFromCoastAspectAdaptor ]			] on: Error do: [: ex | CoastLog log: 'Error in ' , thisContext printString , ': ' , ex description ]		].</body><body package="COASTViews">onChangeSend: aSymbol to: anObject 	"Arrange for anObject to receive a message named aSymbol when 	I signal that my attribute #value has changed."	self		expressInterestIn: #value		for: anObject		sendBack: aSymbol</body><body package="COASTViews">removeDependent: depp	super removeDependent: depp.	self checkStandBy.	^ depp</body><body package="COASTViews">retractInterestsFor: anObject 	"Undo a send of onChangeSend:to:."	self retractInterestIn: #value for: anObject</body></methods><methods><class-id>COAST.CoastAspectAdaptor</class-id> <category>computing</category><body package="COASTViews">computeValue	| newValue |	initialComputing isNil ifTrue: [ initialComputing := true ].	self standByMode ifTrue: [ ^ self value ].	newValue := updateBlock value.	self notifyDependentsAfterComputation: newValue.	^ newValue</body></methods><methods><class-id>COAST.CoastAspectAdaptor class</class-id> <category>instance creation</category><body package="COASTViews">accessBlock: readBlock 	^ self 		accessBlock: readBlock 		assignBlock: [ : dummy | ]</body><body package="COASTViews">accessBlock: readBlock assignBlock: writeBlock 	| newInst |	newInst := self new.	newInst		writeBlock: writeBlock;		updateBlock: readBlock;		useBlock: true.	^ newInst</body><body package="COASTViews">accessBlock: readBlock assignBlock: writeBlock application: aCoastLocalApplicationModel	^ self accessBlock: readBlock assignBlock: writeBlock</body><body package="COASTViews">adaptFrame: aFrame slot: aSlotname	| newInst |	newInst := self new.	newInst bestDisplayDo: [		newInst			updateBlock: [ aFrame at: aSlotname asSymbol ];			frame: aFrame;			slot: aSlotname;			useBlock: false.	].	^ newInst</body><body package="COASTViews">adaptFrame: aFrame slot: aSlotname application: aCoastLocalApplicationModel	^ self adaptFrame: aFrame slot: aSlotname</body><body package="COASTViews">slot: aSlotname application: aCoastLocalApplicationModel	^ self		adaptFrame: aCoastLocalApplicationModel		slot: aSlotname		application: aCoastLocalApplicationModel</body></methods><methods><class-id>COAST.CoastAspectAdaptor class</class-id> <category>accessing</category><body package="COASTViews">widgetEnablementAdaptorClass	^ COAST.CoastAspectAdaptor</body></methods><methods><class-id>COAST.CoastAspectAdaptor class</class-id> <category>slot description</category><body package="COASTViews">valueSlot	^ ( self slotComputedEagerBy: #computeValue)		computeInSequence: false;		yourself</body></methods><methods><class-id>COAST.CoastListSelectionAspectAdaptor</class-id> <category>accessing</category><body package="COASTViews">value	^ super value copy</body></methods><methods><class-id>COAST.CoastListSelectionAspectAdaptor</class-id> <category>initialize-release</category><body package="COASTViews">checkStandBy	" the list is a dependent, don't care "	self dependents size &lt;= 1				ifTrue: [ self standBy ].</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>observer - subject</category><body package="COASTViews">addObserverOnFrame: frame slotName: slotName 	| obsPair |	( self subjects anySatisfy: [: subjectOrPair | 		SlotObserverPair isObserverPair: subjectOrPair equalToObserver: self subject: frame slotName: slotName ]	) 		ifFalse: 		[	obsPair := SlotObserverPair observer: self frame: frame slotName: slotName.			frame addObserver: obsPair.			self addObserverPair: obsPair		].</body><body package="COASTViews">addObserverPair: anObserverPair	self addSubject: anObserverPair</body><body package="COASTViews">addSubject: aCatCSCell	subjects add: aCatCSCell.</body><body package="COASTViews">coastRemoveSubject: aCatCSCell 	subjects remove: aCatCSCell ifAbsent: [ ]</body><body package="COASTViews">flushSubjects	subjects notNil 		ifTrue: 		[	subjects do: [: s | s removeObserver: self ].			self initializeSubjects		].</body><body package="COASTViews">initializeSubjects	subjects := IdentitySet new.</body><body package="COASTViews">subjects	^subjects</body><body package="COASTViews">subjectsDo: aBlock	subjects notNil ifTrue: [ subjects do: aBlock ]</body><body package="COASTViews">subjectsIncludes: anObject	^ subjects notNil and: [subjects  includes: anObject ]</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>testing</category><body package="COASTViews">allowsSlotComputation	"Does it make sense to recalculate any virtual slot of this visual part?"	^true	"Yes, try it. I have no idea why not."</body><body package="COASTViews">isOpen	" is this view visible, or just a corpse lying around in memory? " 	^ isOpen</body><body package="COASTViews">isWeakObserver	^ false</body><body package="COASTViews">mayBeReused	| vh |	^ self viewState notNil and: [ (vh :=self viewState valueHolder) notNil  and:  [ vh isEmpty not ]].</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>slot accessing</category><body package="COASTViews">at: aSymbol	^ self viewState at: aSymbol</body><body package="COASTViews">at: aSymbol add: newValue	^ self viewState at: aSymbol add: newValue</body><body package="COASTViews">at: aSymbol remove: aValue	^ self viewState at: aSymbol remove: aValue</body><body package="COASTViews">at: slotName set: anObject	^ self viewState at: slotName set: anObject</body><body package="COASTViews">at: slotName setAll: collection 	^ self viewState at: slotName setAll: collection</body><body package="COASTViews">fastAt: aSymbol 	^ self viewState fastAt: aSymbol</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>slot accessing / OrderedCollection</category><body package="COASTViews">at: slotName add: anObject after: anotherObject	^ self viewState at: slotName add: anObject after: anotherObject</body><body package="COASTViews">at: slotName add: anObject afterIndex: index	^ self viewState at: slotName add: anObject afterIndex: index</body><body package="COASTViews">at: slotName add: anObject before: anotherObject	^ self viewState at: slotName add: anObject before: anotherObject</body><body package="COASTViews">at: slotName add: anObject beforeIndex: index	^ self viewState at: slotName add: anObject beforeIndex: index</body><body package="COASTViews">at: slotName addFirst: anObject	^ self viewState at: slotName addFirst: anObject</body><body package="COASTViews">at: slotName addLast: anObject	^ self viewState at: slotName addLast: anObject</body><body package="COASTViews">at: slotName after: anObject	^ self viewState at: slotName after: anObject</body><body package="COASTViews">at: slotName atIndex: index	^ self viewState at: slotName atIndex: index</body><body package="COASTViews">at: slotName atIndex: index put: anObject	^ self viewState at: slotName atIndex: index put: anObject</body><body package="COASTViews">at: slotName before: anObject	^ self viewState at: slotName before: anObject</body><body package="COASTViews">at: slotName indexOf: anObject	^ self viewState at: slotName indexOf: anObject</body><body package="COASTViews">at: slotName removeAtIndex: index	^ self viewState at: slotName removeAtIndex: index</body><body package="COASTViews">firstAt: slotName	^ self viewState firstAt: slotName</body><body package="COASTViews">lastAt: slotName	^ self viewState lastAt: slotName</body><body package="COASTViews">removeFirstAt: slotName	^ self viewState removeFirstAt: slotName</body><body package="COASTViews">removeLastAt: slotName	^ self viewState removeLastAt: slotName</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>slot accessing / bag</category><body package="COASTViews">at: slotName add: anObject withOccurrences: anInteger	^ self viewState at: slotName add: anObject withOccurrences: anInteger</body><body package="COASTViews">at: slotName removeAllOccurrences: anObject	^ self viewState at: slotName removeAllOccurrences: anObject</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>slot accessing / Dictionary</category><body package="COASTViews">at: slotName atKey: key	^ self viewState at: slotName atKey: key</body><body package="COASTViews">at: slotName atKey: key put: value	^ self viewState at: slotName atKey: key put: value</body><body package="COASTViews">at: slotName includesKey: key	^ self viewState at: slotName includesKey: key</body><body package="COASTViews">at: slotName keyAtValue: value	^ self viewState at: slotName keyAtValue: value</body><body package="COASTViews">at: slotName removeKey: key	^ self viewState at: slotName removeKey: key</body><body package="COASTViews">keysAt: slotName	^ self viewState keysAt: slotName</body><body package="COASTViews">valuesAt: slotName	^ self viewState valuesAt: slotName</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>slot accessing / collections</category><body package="COASTViews">at: slotName includes: anObject	^ self viewState at: slotName includes: anObject</body><body package="COASTViews">at: slotName occurrencesOf: anObject	^ self viewState at: slotName occurrencesOf: anObject</body><body package="COASTViews">isEmpty: slotName	^ self viewState isEmpty: slotName</body><body package="COASTViews">sizeAt: slotName	^ self viewState sizeAt: slotName</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>invalidation</category><body package="COASTViews">coastInvalidateDisresolved	^ self coastInvalidate</body><body package="COASTViews">coastInvalidateWithAccess: cellAccessOrNil 	" A cell from which we are dependent has changed. Flush all dependencies	and invalidate the area covered by the view "	self isValid 		ifTrue: 		[	self isValid: false.			self flushSubjects.			self transactionManager activeTransaction ifNotNil: [: transaction | transaction addPostViewUpdateBlock: [ self invalidateBoundsArea ]]		].	^ false</body><body package="COASTViews">invalidate	self coastInvalidate.</body><body package="COASTViews">invalidateBoundsArea	self invalidateRectangle: self bounds</body><body package="COASTViews">isValid	" True, if the view is properly displayed, false if it requires a refresh "	^ valid</body><body package="COASTViews">isValid: aBoolean	valid := aBoolean</body><body package="COASTViews">isValidOrComputed	^ valid ~~ false</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>accessing</category><body package="COASTViews">coastObserver	^ self</body><body package="COASTViews">coastSubject	^ self</body><body package="COASTViews">coastTotalByteSize	^ self coastObjectSize + viewState coastTotalByteSize</body><body package="COASTViews">helpText	^ nil</body><body package="COASTViews">isSelected	^ false</body><body package="COASTViews">numberOfAllObservers	^ viewState notNil ifTrue: [ viewState numberOfAllObservers ] ifFalse: [ 0 ]</body><body package="COASTViews">selectedComponents	^ nil</body><body package="COASTViews">slotNamed: aSlotName 	^ viewState notNil 		ifTrue: [ viewState slotNamed: aSlotName ]		ifFalse: [ nil ]</body><body package="COASTViews">transactionManager	^self viewState isNil		ifTrue: [ nil ]		ifFalse: [ self viewState transactionManager ]</body><body package="COASTViews">viewState	" Returns the view-state holding the slots of the visual part "	^ viewState</body><body package="COASTViews">viewState: aCatFSVirtualFrame 	" Sets the view-state holding the slots of the visual part  "	viewState := aCatFSVirtualFrame.	aCatFSVirtualFrame notNil 		ifTrue: [ self transactionManager activeTransaction ifNotNil: [: transaction | transaction recordLocalFrameCreation: aCatFSVirtualFrame ]].</body><body package="COASTViews">withoutWrappers	^self</body><body package="COASTViews">wrappedComponent	" i am not a wrapper so return myself "	^ self</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>displaying</category><body package="COASTViews">composeDisplayOn: aGraphicsContext	" Overwrite this method to provide specific display behaviour "</body><body package="COASTViews">displayOn: aGraphicsContext 	"This method provides functionality to maintain dependencies between the view and 	all related slots. displayOn: sends computeDisplayOn: to the view, and programmers 	should always override composeDisplayOn: to provide specific display behaviour. 	However, when displaying views, displayOn: should be called rather than sending 	composeDisplayOn: directly, otherwise the view is not updated properly."	| t |	t := self transactionManager activeTransactionOfCurrentProcess.	t notNil ifTrue: [ t beginComposing: self ].	[( self intersects: aGraphicsContext clippingBounds ) ifTrue: 			[	self composeDisplayOn: aGraphicsContext.				self isValid: true			]	] ensure: [ t notNil ifTrue: [ t endComposing: self ]].</body><body package="COASTViews">flash	"self isOpen ifTrue: [ self transactionManager bestDisplayDo: [ super flash ]]."</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>slot accessing / general</category><body package="COASTViews">depleteSlot: slotName 	^ self viewState depleteSlot: slotName</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>event driven</category><body package="COASTViews">handlerForMouseEvent: aMouseEvent 	"The receiver is in a control hierarchy and the container is asking 	for an object that wants control. If no control is desired then the 	receiver answers nil. If control is wanted then the receiver answers the 	control object."	| ctrl |	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^Object errorSignal handle: [:ex | nil	]		do: [ctrl handlerForMouseEvent: aMouseEvent]</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>slot inverting</category><body package="COASTViews">invertedSlotNamed: slotName addFrame: aViewState demon: demon 	( self viewState notNil and: [ aViewState notNil ]) 		ifTrue: [ self viewState invertedSlotNamed: slotName addFrame: aViewState view demon: demon ]</body><body package="COASTViews">invertedSlotNamed: slotName removeFrame: aViewState demon: demon 	( self viewState notNil and: [ aViewState notNil ]) 		ifTrue: [ self viewState invertedSlotNamed: slotName removeFrame: aViewState view demon: demon ]</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>initialize-release</category><body package="COASTViews">initialize	super initialize.	isOpen := true.	self initializeSubjects.	self isValid: false.	self viewState: (self class prototypeNeeded deepCopyForView: self).</body><body package="COASTViews">isolate	" remove the references between the view, the view state and the observed subjects "	viewState notNil ifTrue: [		viewState finishObservation.		viewState view: nil ].	viewState := nil.	self flushSubjects.</body><body package="COASTViews">release	isOpen := false.	self flushSubjects.	self viewState release.	super release.</body><body package="COASTViews">releaseWithoutInvalidation	self release.</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>compatibility</category><body package="COASTViews">valueAt: aSymbol	^ self at: aSymbol</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>private</category><body package="COASTViews">compositionBoundsFor: aVisualPart	^ aVisualPart preferredBounds</body><body package="COASTViews">computedBoundsChangedFrom: oldBounds to: newBounds 	| boundsToInvalidate |	boundsToInvalidate := newBounds.	(oldBounds notNil and: [ oldBounds extent &gt; ( 0 @ 0 ) ])		ifTrue: [ boundsToInvalidate := boundsToInvalidate merge: oldBounds ].	self invalidateRectangle: boundsToInvalidate.</body><body package="COASTViews">createUnwrappedViewForModel: aModel 	^ ( self viewClassFor: aModel ) model: aModel in: self</body><body package="COASTViews">createViewForModel: aModel 	| wrappedView |	wrappedView := self createWrapperFor: ( self createUnwrappedViewForModel: aModel ).	"ONLY in case a wrapper was added, set container. hs dec 2002"	wrappedView container = self 		ifFalse: [ wrappedView container: self ].	^ wrappedView</body><body package="COASTViews">viewClassFor: aModel	^ aModel defaultViewClass</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>computing</category><body package="COASTViews">computeBounds	^ container == nil 		ifTrue: [ Rectangle zero ]		ifFalse: [ container compositionBoundsFor: self ]</body><body package="COASTViews">computePreferredBounds	^ 0@0 extent: 0@0</body><body package="COASTViews">computeTooltip	| helptext |	helptext := self helpText.	self tooltip: helptext.	^ helptext</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>view creation</category><body package="COASTViews">createWrapperFor: aView	^ aView</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>bounds accessing</category><body package="COASTViews">preferredBounds	^ self at: #preferredBounds</body><body package="COASTViews">preferredExtent	^ self preferredBounds extent</body></methods><methods><class-id>COAST.AutomaticVisualPart class</class-id> <category>slot description - accessing</category><body package="COASTViews">allLazySlotNames	^self allLazySlotSelectors collect: [ :sel | (sel copyFrom: 1 to: (sel size - 4)) asSymbol ]</body><body package="COASTViews">allLazySlotSelectors	| cl slotSelectors |	slotSelectors := IdentitySet new.	cl := self.	[slotSelectors addAll: cl lazySlotSelectors.	 (cl := cl superclass) == VisualPart] whileFalse: [].	^slotSelectors</body><body package="COASTViews">lazySlotNames	^self lazySlotSelectors collect: [ :sel | (sel copyFrom: 1 to: (sel size - 4)) asSymbol ]</body><body package="COASTViews">lazySlotSelectors	^self class selectors select: [ :s | '*Slot' match: s asString ]</body></methods><methods><class-id>COAST.AutomaticVisualPart class</class-id> <category>demons</category><body package="COASTViews">boundsDemon	" without this demon, the view system would only invalidate the 'old' bounds "	^(CatFSDemon update)		postTransactionJob: [:demon :slotAccess :cell |			self checkBoundsForDemon: demon access: slotAccess];		name: #boundsDemon;		argument: nil;		yourself</body><body package="COASTViews">checkBoundsForDemon: demon access: slotAccess	| oldBounds newBounds view |	oldBounds := slotAccess differencesToBeginOfTransaction removed singleElementOrNil.	newBounds := slotAccess cell cellValue.	oldBounds = newBounds ifFalse:	[		view := slotAccess cellFrame view.		view isNil ifFalse: [ view computedBoundsChangedFrom: oldBounds to: newBounds ].	]</body></methods><methods><class-id>COAST.AutomaticVisualPart class</class-id> <category>accessing</category><body package="COASTViews">emptyPrototype	self viewStatePrototype: nil.</body><body package="COASTViews">prototype	^ viewStatePrototype</body><body package="COASTViews">prototypeNeeded	viewStatePrototype isNil ifTrue: [ self initializeSlotDescription ].	^ viewStatePrototype</body><body package="COASTViews">viewStatePrototype	^ viewStatePrototype</body><body package="COASTViews">viewStatePrototype: aCatDMViewState	viewStatePrototype := aCatDMViewState</body></methods><methods><class-id>COAST.AutomaticVisualPart class</class-id> <category>slot description</category><body package="COASTViews">initializeSlotDescription	"CatCSTransactionManager current transactionDo: [ self withAllSubclassesDo: [ :c |  c initializeSlotDescription] ]"	| aSlotOrSomething |	self viewStatePrototype: ViewState newPrototype.	self allLazySlotNames do: [ :slotName | aSlotOrSomething := self perform: (slotName , 'Slot') asSymbol.											(self prototype valueHolder at: slotName asSymbol) isNil ifTrue: [viewStatePrototype slot: slotName with: aSlotOrSomething ]].</body><body package="COASTViews">slot: aSlotName	^self viewStatePrototype slotNamed: aSlotName</body></methods><methods><class-id>COAST.AutomaticVisualPart class</class-id> <category>slot creation</category><body package="COASTViews">slotComputedBy: aBlockOrSelector 	^ self slotComputedBy: aBlockOrSelector slotClass: CatFSVirtualSlot</body><body package="COASTViews">slotComputedBy: aBlockOrSelector slotClass: slotClass 	| composingMethod |	composingMethod := ( aBlockOrSelector isSymbol 				ifTrue: 				[						[: viewState |						( viewState isNil or: [ viewState view isNil ]) 								ifTrue: [ CoastInvalidViewStateError raiseSignal ].							viewState view perform: aBlockOrSelector					]				]				ifFalse: 				[						[: viewState |						( viewState isNil or: [ viewState view isNil ]) 								ifTrue: [ CoastInvalidViewStateError raiseSignal ].							aBlockOrSelector value: viewState view					]				]).	^  slotClass computedBy: composingMethod.</body><body package="COASTViews">slotComputedEagerBy: aBlockOrSelector	^ self slotComputedBy: aBlockOrSelector slotClass: CatFSEagerVirtualSlot</body><body package="COASTViews">slotOfType: aType 	^CatFSSlot newPrototypeOfType: aType.</body><body package="COASTViews">slotSingleValue	^self slotOfType: #singleValue</body></methods><methods><class-id>COAST.AutomaticVisualPart class</class-id> <category>slots</category><body package="COASTViews">preferredBoundsSlot	^ (self slotComputedEagerBy: #computePreferredBounds)		demon: self boundsDemon;		yourself</body><body package="COASTViews">tooltipSlot	^ self slotComputedEagerBy: #computeTooltip</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>testing</category><body package="COASTViews">allowsSlotComputation	"Does it make sense to recalculate any virtual slot of this visual part?"	^ self component notNil and: [ self component allowsSlotComputation ]</body><body package="COASTViews">containsPoint: aPoint	"Answer whether aPoint lies within the receiver's display box."	^self component containsPoint: aPoint</body><body package="COASTViews">intersects: aRectangle	"Answer whether the receiver's display box intersects aRectangle."	^self component intersects: aRectangle</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>accessing</category><body package="COASTViews">bounds: newBounds	self component bounds: newBounds</body><body package="COASTViews">component	"Answer the receiver's component."	^component</body><body package="COASTViews">component: aVisualComponent	"Set the receiver's component to be aVisualComponent.  If the receiver is open, propagate damage.	This is so wrappers can have dynamically changing components."	component == nil ifFalse: [component container: nil].	self setComponent: aVisualComponent.	self isOpen		ifTrue: [ self invalidate ]</body><body package="COASTViews">extent	^self width@self height</body><body package="COASTViews">height	^self component height</body><body package="COASTViews">isSelected	^ self component isSelected</body><body package="COASTViews">scrollFactor	"pixels to scroll when scrollbutton pressed"	^ component notNil 		ifTrue: [ component scrollFactor ]		ifFalse: [ TextAttributes defaultNoCopy lineGrid ]</body><body package="COASTViews">selectedComponents	^ self component selectedComponents</body><body package="COASTViews">setComponent: aVisualComponent	component := aVisualComponent.	component == nil ifFalse: [component container: self]</body><body package="COASTViews">width	^self component width</body><body package="COASTViews">withoutWrappers	^self component isNil		ifTrue: [self]		ifFalse: [self component withoutWrappers]</body><body package="COASTViews">wrappedComponent	^ self component notNil		ifTrue: [ self component wrappedComponent ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>displaying</category><body package="COASTViews">composeDisplayOn: aGraphicsContext	"Display the receiver's component on aGraphicsContext."	self component displayOn: aGraphicsContext.</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>broadcast</category><body package="COASTViews">downcastEvent: aKey with: aParameter from: anInitiator	"This is a message passed down the view structure to all subparts."	component == nil		ifFalse: [component downcastEvent: aKey with: aParameter from: anInitiator]</body><body package="COASTViews">downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator 	"This is a message passed down the view structure to some single 	part. Answer true if we accepted the event, or false if it should be 	passed on to whatever's behind us."	component == nil		ifFalse: [^component			downcastLocalEvent: aKey			with: aParameter			at: aPoint			from: anInitiator].	^super		downcastLocalEvent: aKey		with: aParameter		at: aPoint		from: anInitiator</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>event driven</category><body package="COASTViews">handlerForMouseEvent: aMouseEvent 	"Forward the control polling message to the receiver's component."	^self component handlerForMouseEvent: aMouseEvent</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>bounds accessing</category><body package="COASTViews">newBounds: newBounds containingBounds: containingBounds	"The receiver's new bounds is to be newBounds which is a rectangle relative to	containingBounds."	self bounds: newBounds</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>controller accessing</category><body package="COASTViews">newControllerClassFor: aComponent	^ self container newControllerClassFor: aComponent</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>layout</category><body package="COASTViews">rectangleRelativeTo: containingBoundingBox	"Answer a rectangle for the receiver relative to the containingBoundingBox."	^self component rectangleRelativeTo: containingBoundingBox</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>initialize-release</category><body package="COASTViews">release	"Forward release to the receiver's component."	component removeDependent: self.	component release.	super release</body><body package="COASTViews">scrollOffsetHolder: aValueHolder 	"Accept notification that we will be scrolled, and cache the value holder 	that contains the offset, if desired"	self component scrollOffsetHolder: aValueHolder</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>focus accessing</category><body package="COASTViews">takeFocusWithEvent: aCharEvent	self component takeFocusWithEvent: aCharEvent</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>input management</category><body package="COASTViews">updateSpot: type	"Forward this message to my component."	component updateSpot: type</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>composing</category><body package="COASTViews">computePreferredBounds	^self component preferredBounds</body></methods><methods><class-id>COAST.SimpleWrapperView</class-id> <category>events</category><body package="COASTViews">dispatchEventFromComponent: event	self container dispatchEventFromComponent: event</body></methods><methods><class-id>COAST.SimpleWrapperView class</class-id> <category>instance creation</category><body package="COASTViews">in: aContainer on: aVisualComponent	"Create a new instance of the receiver on aVisualComponent."	^(self on: aVisualComponent)		container: aContainer;		yourself.</body><body package="COASTViews">on: aVisualComponent	"Create a new instance of the receiver on aVisualComponent."	^ (self new)		component: aVisualComponent;		yourself.</body><body package="COASTViews">on: aContainer on: aVisualComponent	"Create a new instance of the receiver on aVisualComponent."	^(self on: aVisualComponent)		container: aContainer;		yourself.</body><body package="COASTViews">privateIn: aContainer on: aVisualComponent	"Create a new instance of the receiver on aVisualComponent."	^(self on: aVisualComponent)		container: aContainer;		yourself.</body></methods><methods><class-id>COAST.CoastDependentPart</class-id> <category>testing</category><body package="COASTViews">allowsSlotComputation	"Does it make sense to recalculate any virtual slot of this visual part?"	^self model notNil and: [ self model allowsSlotComputation ]	"as long as my model is healthy, I agree"</body></methods><methods><class-id>COAST.CoastDependentPart</class-id> <category>computing</category><body package="COASTViews">computeModel	| m |	m := modelComputationBlock value: self.	self modelChanged: m.	^ m</body></methods><methods><class-id>COAST.CoastDependentPart</class-id> <category>accessing</category><body package="COASTViews">displayDebugBounds	^ false</body><body package="COASTViews">model	self modelIsComputed		ifTrue: [ ^ self at: #computedModel ]		ifFalse: [ ^ model ]</body></methods><methods><class-id>COAST.CoastDependentPart</class-id> <category>accessing-private</category><body package="COASTViews">model: aModel		model := aModel.	self modelChanged: aModel.</body><body package="COASTViews">modelChanged: aModel	" hook: the model has changed "	" note: beware of computed models "</body><body package="COASTViews">modelComputationBlock: aBlock	modelComputationBlock := aBlock</body><body package="COASTViews">modelIsComputed	^ modelComputationBlock notNil</body></methods><methods><class-id>COAST.CoastDependentPart class</class-id> <category>slot description</category><body package="COASTViews">computedModelSlot	^self slotComputedBy: #computeModel</body></methods><methods><class-id>COAST.CoastDependentPart class</class-id> <category>instance creation</category><body package="COASTViews">model: anObject	^ (self new)		model: anObject;		yourself</body><body package="COASTViews">model: anObject in: aContainerView	^ (self model: anObject)		container: aContainerView;		yourself.</body><body package="COASTViews">modelComposingBlock: aBlock	CoastLog logDebug: 'Obsolete --- send #modelComputingBlock: instead of #modelComposingBlock:'.	^ (self new)		modelComputationBlock: aBlock;		yourself.</body><body package="COASTViews">modelComposingBlock: aBlock in: aContainerView	CoastLog logDebug: 'Obsolete --- send modelComputingBlock:in: instead'.	^ (self modelComposingBlock: aBlock)		container: aContainerView;		yourself.</body><body package="COASTViews">modelComputingBlock: aBlock	^ (self new)		modelComputationBlock: aBlock;		yourself.</body><body package="COASTViews">modelComputingBlock: aBlock in: aContainerView	^ (self modelComposingBlock: aBlock)		container: aContainerView;		yourself.</body></methods><methods><class-id>COAST.CoastListAspectAdaptor</class-id> <category>initialize-release</category><body package="COASTViews">checkStandBy	" the list is a dependent, don't care "	self dependents size &lt;= 1				ifTrue: [ self standBy ].</body></methods><methods><class-id>COAST.CoastListAspectAdaptor</class-id> <category>accessing</category><body package="COASTViews">selectionAdaptor	^ selectionAdaptor</body><body package="COASTViews">selectionAdaptor: aSelectionAdaptor 	selectionAdaptor := aSelectionAdaptor.</body></methods><methods><class-id>COAST.CoastListAspectAdaptor</class-id> <category>dependents access</category><body package="COASTViews">notifyDependentsAfterComputation: newValue 	"always send update, properties of list elements may have changed but list not"	| transaction selection |	newValue isNil 		ifTrue: [ ^ self ].	transaction := self transactionManager activeTransaction.	transaction isNil 		ifTrue: [ ^ self ].	selection := self transactionManager withoutDependenciesDo: [ self selectionAdaptor value ].	self notifyDependentsInTransaction: transaction value: selection.</body></methods><methods><class-id>COAST.CoastListAspectAdaptor class</class-id> <category>accessing</category><body package="COASTViews">accessBlock: readBlock assignBlock: writeBlock selectionAdaptor: selectionAdaptor 	^ ( self accessBlock: readBlock assignBlock: writeBlock )		selectionAdaptor: selectionAdaptor;		yourself</body></methods><methods><class-id>COAST.CoastMultiSelectionInList</class-id> <category>accessing</category><body package="COASTViews">aspectAdaptorFinishObservation	" stop observerving "	listHolder aspectAdaptorFinishObservation.	selectionIndexHolder aspectAdaptorFinishObservation.</body><body package="COASTViews">listHolderClass	^ CoastListAspectAdaptor</body><body package="COASTViews">selection	^ listHolder value isNil 		ifTrue: [ nil ]		ifFalse: [ self selections singleElementOrNil ]</body></methods><methods><class-id>COAST.CoastMultiSelectionInList</class-id> <category>updating</category><body package="COASTViews">update: anAspect with: aParameter from: anObject</body></methods><methods><class-id>COAST.CoastMultiSelectionInList</class-id> <category>initialize-release</category><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock 	self listHolder: ( self listHolderClass 				accessBlock: readListBlock				assignBlock: writeListBlock ).	self selectionIndexHolder: ( CoastListSelectionAspectAdaptor 				accessBlock: readSelectionBlock				assignBlock: writeSelectionBlock ).</body><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock application: aCoastLocalApplicationModel	self listHolder:		(self listHolderClass			accessBlock: readListBlock			assignBlock: writeListBlock			application: aCoastLocalApplicationModel).	self selectionIndexHolder:		(CoastListSelectionAspectAdaptor			accessBlock: readSelectionBlock			assignBlock: writeSelectionBlock			application: aCoastLocalApplicationModel).</body><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionFromIndexBlock: readSelectionBlock assignSelectionFromIndexBlock: writeSelectionBlock application: aCoastLocalApplicationModel	self listHolder:		(self listHolderClass			accessBlock: readListBlock			assignBlock: writeListBlock			application: aCoastLocalApplicationModel).	self selectionIndexHolder:		(CoastListSelectionAspectAdaptor			accessBlock: 			[ | list selections |				list := self listHolder value.				selections := readSelectionBlock value.				(( 1 to: list size ) select: [: index | selections includes: (list at: index) ]) asSet.			]			assignBlock: 			[: indexes | | list selections |				list := self listHolder value.				selections := indexes collect: [: index | list at: index ].				writeSelectionBlock value: selections.			]			application: aCoastLocalApplicationModel).</body></methods><methods><class-id>COAST.CoastMultiSelectionInList class</class-id> <category>instance creation</category><body package="COASTViews">accessListBlock: readListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock 	^ (self new)		accessListBlock: readListBlock		assignListBlock: [:dummy ]		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock		yourself</body><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock	^ (self new)		accessListBlock: readListBlock		assignListBlock: writeListBlock		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock		yourself</body><body package="COASTViews">adapt: aFrame accessListBlock: readListBlock selectionSlot: slotName	^ (self new)		accessListBlock: readListBlock		assignListBlock: [:dummy ]		accessSelectionBlock: [ aFrame at: slotName ]		assignSelectionBlock: [ :sel | aFrame at: slotName set: sel ]		yourself</body><body package="COASTViews">listBlock: readListBlock getSelectionBlock: readSelectionBlock setSelectionBlock: writeSelectionBlock 	" real selections, not bloody selection indexes "	| inst |	inst := self new.	inst		accessListBlock: readListBlock		assignListBlock: [ :dummy ]		accessSelectionBlock: [ (readSelectionBlock value collect: [ : sel | inst list indexOf: sel ]) coastAsSetOrYourself ]		assignSelectionBlock: [ : idxs | writeSelectionBlock value: (idxs collect: [ : i |  inst list at: i]) ].	^ inst</body></methods><methods><class-id>COAST.CoastMultiSelectionInList class</class-id> <category>instance creation - compatibility</category><body package="COASTViews">accessListBlock: readListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock application: aCoastLocalApplicationModel	^ (self new)		accessListBlock: readListBlock		assignListBlock: [:dummy ]		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock		application: aCoastLocalApplicationModel;		yourself</body><body package="COASTViews">accessListBlock: readListBlock accessSelectionFromIndexBlock: readSelectionBlock assignSelectionFromIndexBlock: writeSelectionBlock application: aCoastLocalApplicationModel	^ (self new)		accessListBlock: readListBlock		assignListBlock: [:dummy ]		accessSelectionFromIndexBlock: readSelectionBlock		assignSelectionFromIndexBlock: writeSelectionBlock		application: aCoastLocalApplicationModel;		yourself</body><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock application: aCoastLocalApplicationModel	^ (self new)		accessListBlock: readListBlock		assignListBlock: writeListBlock		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock		application: aCoastLocalApplicationModel;		yourself</body><body package="COASTViews">adapt: somethingWithSlots listSlot: listSlotSymbol application: aCoastLocalApplicationModel	| selectionHolder |	selectionHolder := 0 asValue.	^ self 		accessListBlock: [ somethingWithSlots at: listSlotSymbol ]		assignListBlock: [ :list | somethingWithSlots at: listSlotSymbol set: list ]		accessSelectionBlock: [ selectionHolder value ]		assignSelectionBlock: [ :sel | selectionHolder value: sel ]		application: aCoastLocalApplicationModel</body><body package="COASTViews">adapt: somethingWithSlots listSlot: listSlotSymbol selectionSlot: selectionSlotSymbol application: aCoastLocalApplicationModel	^ self 		accessListBlock: [ somethingWithSlots at: listSlotSymbol ]		assignListBlock: [ :list | somethingWithSlots at: listSlotSymbol set: list ]		accessSelectionBlock: [ somethingWithSlots at: selectionSlotSymbol ]		assignSelectionBlock: [ :sel | somethingWithSlots at: selectionSlotSymbol set: sel ]		application: aCoastLocalApplicationModel</body><body package="COASTViews">listSlot: listSlotSymbol application: aCoastLocalApplicationModel	^ self		adapt:aCoastLocalApplicationModel		listSlot: listSlotSymbol		application: aCoastLocalApplicationModel</body><body package="COASTViews">listSlot: listSlotSymbol selectionSlot: selectionSlotSymbol application: aCoastLocalApplicationModel	^ self		adapt:aCoastLocalApplicationModel		listSlot: listSlotSymbol		selectionSlot: selectionSlotSymbol 		application: aCoastLocalApplicationModel</body></methods><methods><class-id>COAST.CoastDifferentialMultiSelectionInList</class-id> <category>accessing</category><body package="COASTViews">listHolderClass	^ CoastDifferentialListAspectAdaptor</body></methods><methods><class-id>COAST.CoastDifferentialMultiSelectionInList</class-id> <category>initialize-release</category><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock elementValuesBlock: elementValuesBlock	self accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock.	self listHolder elementValuesBlock: elementValuesBlock</body></methods><methods><class-id>COAST.CoastDifferentialMultiSelectionInList class</class-id> <category>instance creation</category><body package="COASTViews">accessListBlock: readListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock elementValuesBlock: elementValuesBlock	^ (self new)		accessListBlock: readListBlock		assignListBlock: [:dummy ]		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock		elementValuesBlock: elementValuesBlock		yourself</body></methods><methods><class-id>COAST.CoastSelectionTracker</class-id> <category>events</category><body package="COASTViews">closeEvent: anEvent	"The window is about to close, let go of the mouse and the controller."	self release.	^nil</body><body package="COASTViews">handleEvent: anEvent	controller isNil ifTrue: [		" no controller -&gt; don't handle events "		^ nil ].	firstPosition isNil		ifTrue: [ firstPosition := anEvent globalPoint ].	^ super handleEvent: anEvent.</body><body package="COASTViews">passControlToContainer: event	self controller abortAndDispatchToContainer: event.</body></methods><methods><class-id>COAST.CoastSelectionTracker</class-id> <category>accessing</category><body package="COASTViews">displayDo: aBlock	^self transactionManager displayDo: aBlock</body><body package="COASTViews">transactionDo: aBlock	^ self transactionManager transactionDo: aBlock</body><body package="COASTViews">transactionManager	^ self model transactionManager</body></methods><methods><class-id>COAST.CoastSelectionTracker</class-id> <category>private</category><body package="COASTViews">finishSelectionFor: aPoint	self release.	super finishSelectionFor: aPoint.</body><body package="COASTViews">sensor	^sensor ifNil: [ sensor := controller sensor ]</body><body package="COASTViews">setController: aController	super setController: aController.	sensor := aController sensor.</body></methods><methods><class-id>COAST.CoastSelectionTracker</class-id> <category>initialize-release</category><body package="COASTViews">finishTracking	" Finishes tracking and returns the control to the controller "	self release</body><body package="COASTViews">release	controller notNil		ifTrue: [			self sensor ungrabMouseEventFor: self.			controller removeCurrentTracker.			controller := nil.	].		super release</body></methods><methods><class-id>COAST.CoastSelectionTracker</class-id> <category>testing</category><body package="COASTViews">mouseHasMovedWithEvent: event	" True, if the mouse was moved since the activation of the tracker "	^ (firstPosition dist: event globalPoint) &gt;= self sensitivity</body><body package="COASTViews">sensitivity	" Returns the number of pixels the mouse must move until	#mouseHasMovedWithEvent: returns true. "	^  3</body></methods><methods><class-id>COAST.CoastSelectionTracker</class-id> <category>error handling</category><body package="COASTViews">shutdownBecauseOfError	"ungrab mouse in case of error"	self release</body></methods><methods><class-id>COAST.CoastConfigurableTracker</class-id> <category>events</category><body package="COASTViews">blueButtonPressedEvent: aMouseButtonEvent 	self blueButtonPressedJob isNil		ifTrue: [ ^ super blueButtonPressedEvent: aMouseButtonEvent]		ifFalse: [ self blueButtonPressedJob value: aMouseButtonEvent.			^ nil]</body><body package="COASTViews">blueButtonReleasedEvent: aMouseButtonEvent 	self blueButtonReleasedJob isNil		ifTrue: [ ^ super blueButtonReleasedEvent: aMouseButtonEvent]		ifFalse: [ self blueButtonReleasedJob value: aMouseButtonEvent.			^ nil]</body><body package="COASTViews">doubleClickEvent: event 	self doubleClickJob isNil		ifTrue: [ ^ super doubleClickEvent: event]		ifFalse: [ self doubleClickJob value: event.			^ nil]</body><body package="COASTViews">enterEvent: event 	self enterJob isNil		ifTrue: [ ^ super enterEvent: event]		ifFalse: [ self enterJob value: event.			^ nil]</body><body package="COASTViews">exitEvent: event 	self exitJob isNil		ifTrue: [ ^ super exitEvent: event]		ifFalse: [ self exitJob value: event.			^ nil]</body><body package="COASTViews">keyPressedEvent: event	self controller keyPressedEvent: event</body><body package="COASTViews">keyReleasedEvent: event	self controller keyReleasedEvent: event</body><body package="COASTViews">mouseMovedEvent: event 	self mouseMovedJob isNil		ifTrue: [ ^ super mouseMovedEvent: event]		ifFalse: [ self mouseMovedJob value: event.			^ nil]</body><body package="COASTViews">redButtonPressedEvent: aMouseButtonEvent 	| retVal |	controller isNil ifTrue: [ ^nil ].	retVal := super redButtonPressedEvent: aMouseButtonEvent.	self redButtonPressedJob notNil		ifTrue: [ self redButtonPressedJob value: aMouseButtonEvent.			^ nil].	^ retVal</body><body package="COASTViews">redButtonReleasedEvent: aMouseButtonEvent 	controller isNil ifTrue: [ ^nil ].	self redButtonReleasedJob notNil		ifTrue: [ self redButtonReleasedJob value: aMouseButtonEvent ].	controller notNil ifTrue: [^super redButtonReleasedEvent: aMouseButtonEvent.] ifFalse: [^nil].</body><body package="COASTViews">unknownEvent: anEvent	^nil</body><body package="COASTViews">windowEnterEvent: event 	self windowEnterJob isNil		ifTrue: [ ^ super windowEnterEvent: event]		ifFalse: [ self windowEnterJob value: event.			^ nil]</body><body package="COASTViews">windowExitEvent: event 	self windowExitJob isNil		ifTrue: [ ^ super windowExitEvent: event]		ifFalse: [ self windowExitJob value: event.			^ nil]</body><body package="COASTViews">yellowButtonPressedEvent: aMouseButtonEvent 	self blueButtonPressedJob isNil		ifTrue: [ ^ super yellowButtonPressedEvent: aMouseButtonEvent]		ifFalse: [ self yellowButtonPressedJob value: aMouseButtonEvent.			^ nil]</body><body package="COASTViews">yellowButtonReleasedEvent: aMouseButtonEvent 	self blueButtonReleasedJob isNil		ifTrue: [ ^ super yellowButtonReleasedEvent: aMouseButtonEvent]		ifFalse: [ self yellowButtonReleasedJob value: aMouseButtonEvent.			^ nil]</body></methods><methods><class-id>COAST.CoastConfigurableTracker</class-id> <category>jobs accessing</category><body package="COASTViews">blueButtonPressedJob	^ blueButtonPressedJob</body><body package="COASTViews">blueButtonPressedJob: aJob	blueButtonPressedJob := aJob</body><body package="COASTViews">blueButtonReleasedJob	^ blueButtonReleasedJob</body><body package="COASTViews">blueButtonReleasedJob: aJob	blueButtonReleasedJob := aJob</body><body package="COASTViews">doubleClickJob	^ doubleClickJob</body><body package="COASTViews">doubleClickJob: aJob	doubleClickJob := aJob</body><body package="COASTViews">enterJob	^ enterJob</body><body package="COASTViews">enterJob: aJob	enterJob := aJob</body><body package="COASTViews">exitJob	^ exitJob</body><body package="COASTViews">exitJob: aJob	exitJob := aJob</body><body package="COASTViews">mouseMovedJob	^ mouseMovedJob</body><body package="COASTViews">mouseMovedJob: aJob	mouseMovedJob := aJob</body><body package="COASTViews">redButtonPressedJob	^ redButtonPressedJob</body><body package="COASTViews">redButtonPressedJob: aJob	redButtonPressedJob := aJob</body><body package="COASTViews">redButtonReleasedJob	^ redButtonReleasedJob</body><body package="COASTViews">redButtonReleasedJob: aJob	redButtonReleasedJob := aJob</body><body package="COASTViews">unknownJob	^ unknownJob</body><body package="COASTViews">unknownJob: aJob	unknownJob := aJob</body><body package="COASTViews">windowEnterJob	^ windowEnterJob</body><body package="COASTViews">windowEnterJob: aJob	 windowEnterJob := aJob</body><body package="COASTViews">windowExitJob	^ windowExitJob</body><body package="COASTViews">windowExitJob: aJob	windowExitJob := aJob</body><body package="COASTViews">yellowButtonPressedJob	^ yellowButtonPressedJob</body><body package="COASTViews">yellowButtonPressedJob: aJob	yellowButtonPressedJob := aJob</body><body package="COASTViews">yellowButtonReleasedJob	^ yellowButtonReleasedJob</body><body package="COASTViews">yellowButtonReleasedJob: aJob	yellowButtonReleasedJob := aJob</body></methods><methods><class-id>COAST.CoastBlockAdaptor</class-id> <category>accessing</category><body package="COASTViews">allSubjects	^ self at: #allSubjects.</body><body package="COASTViews">allSubjectsAdd: aSubject	| adaptor |	adaptor := CoastSubjectAdaptor subject: aSubject blockAdaptor: self .	self at: #allSubjects atKey: aSubject put: adaptor.	^ adaptor</body><body package="COASTViews">aragonModelReadOnly	^ ( readOnlyBlock notNil and: [ subject notNil ]) 		ifTrue: [ readOnlyBlock value: subject ]		ifFalse: [ false ]</body><body package="COASTViews">readOnlyBlock: aBlock	readOnlyBlock := aBlock</body><body package="COASTViews">subject	"Answer the current subject."	^subject</body><body package="COASTViews">subject: anObject 	"Set the subject to be anObject.  Send an update since the value has	probably changed too."	subject := anObject.	( self includesSubject: subject ) 		ifFalse: [ self transactionManager bestDisplayDo: [ self allSubjectsAdd: subject ]].	dependents update: #value with: nil from: self.</body><body package="COASTViews">value	"Answer the value returned by sending the receiver's retrieval (get) 	selector to the receiver's target."	^subject isNil ifTrue: [ nil ] ifFalse: [ self valueUsingSubject: subject ]</body><body package="COASTViews">value: newValue 	" Set the currently stored value, and notify dependents. "	subject notNil ifTrue: 		[	writeBlock isNil ifFalse: [ writeBlock value: subject value: newValue ].			self transactionManager bestDisplayDo: 				[( self includesSubject: subject ) 						ifTrue: 						[	( self slotNamed: #value ) invalidate.							standByMode := false						]						ifFalse: [ self allSubjectsAdd: subject ]				].			self changed: #value		].	^ newValue</body><body package="COASTViews">valueUsingSubject: aSubject 	| adaptor |	( self includesSubject: aSubject ) 		ifFalse: [ self transactionManager bestDisplayDo: [ self allSubjectsAdd: aSubject ]].	adaptor := self at: #allSubjects atKey: aSubject ifAbsent: nil.	^ adaptor ~~ nil 		ifTrue: [ adaptor value ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CoastBlockAdaptor</class-id> <category>dependents access</category><body package="COASTViews">aragonBlockAdaptorAddDependent: column	"Add anObject as one of the receiver's dependents."	^self addDependent: column</body><body package="COASTViews">notifyDependentsInTransaction: transaction value: value 	" dont update more than once "	| adaptorDict notifiedDependents dependentsToNotify |	adaptorDict := transaction transactionContextAt: self class ifAbsentPut: [ Dictionary new ].	notifiedDependents := adaptorDict at: self ifAbsentPut: [ Set new ].	dependentsToNotify := Set new.	self myDependents coastAsSet do: 		[: dep | ( notifiedDependents includes: dep ) 				ifFalse: 				[	notifiedDependents add: dep.					dependentsToNotify add: dep				]		].	dependentsToNotify notEmpty 		ifTrue: 		[	transaction addPostViewUpdateBlock: 				[						[ dependentsToNotify do: [: e | e update: #value with: value from: self ]] 						on: Error						do: [: ex | CoastLog log: 'Error in ' , thisContext printString , ': ' , ex description ]				]		].</body></methods><methods><class-id>COAST.CoastBlockAdaptor</class-id> <category>private</category><body package="COASTViews">includesSubject: aSubject 	^ self at: #allSubjects includesKey: aSubject</body><body package="COASTViews">privateSetValue: newValue	useBlock notNil		ifTrue: [ useBlock			ifTrue: [ subject notNil ifTrue: [ writeBlock value: subject value: newValue ] ]			ifFalse: [ frame at: slot set: newValue ] ].</body></methods><methods><class-id>COAST.CoastBlockAdaptor</class-id> <category>testing</category><body package="COASTViews">isProtocolAdaptor	"Answer as to whether the receiver transduces protocol into ValueModel protocol."	^true</body></methods><methods><class-id>COAST.CoastBlockAdaptor</class-id> <category>computing</category><body package="COASTViews">computeValue	" all done by CoastSubjectAdaptor "	^ nil</body><body package="COASTViews">computeValueForSubject: aSubject	^ updateBlock value: aSubject</body></methods><methods><class-id>COAST.CoastBlockAdaptor</class-id> <category>initialize-release</category><body package="COASTViews">aspectAdaptorFinishObservation	super aspectAdaptorFinishObservation.	self allSubjects do: [ : subj | subj aspectAdaptorFinishObservation ]</body></methods><methods><class-id>COAST.CoastBlockAdaptor class</class-id> <category>slots</category><body package="COASTViews">allSubjectsSlot	^ (self slotOfType: #dictionary)</body></methods><methods><class-id>COAST.CoastComboBoxAdaptor</class-id> <category>private - blocks</category><body package="COASTViews">getBlockWithSubjectFor: accessBlock 	^ [ : subj | | val comboText |		val := accessBlock value: subj.		comboText := self wrapValue: val.		comboText		]</body><body package="COASTViews">getBlockWithoutSubjectFor: accessBlock 	^ [ | val comboText |		val := accessBlock value.		comboText := self wrapValue: val.		comboText		]</body><body package="COASTViews">setBlockWithSubjectFor: assignBlock 	^ [ : subj : newValText | | val |		val := self unwrapValueFrom: newValText.		assignBlock value: subj value: val		]</body><body package="COASTViews">setBlockWithoutSubjectFor: assignBlock 	^ [ : newValText | | val |		val := self unwrapValueFrom: newValText.		assignBlock value: val		]</body></methods><methods><class-id>COAST.CoastComboBoxAdaptor</class-id> <category>accessing</category><body package="COASTViews">displayStringBlock	^ displayStringBlock</body><body package="COASTViews">displayStringBlock: aDisplayStringBlock 	displayStringBlock := aDisplayStringBlock.</body><body package="COASTViews">renderTextFor: aValue 	^ aValue class = ComboBoxText 		ifTrue: [ aValue ]		ifFalse: [ self wrapValue: aValue ]</body><body package="COASTViews">updateBlock: accessBlock 	updateBlock := accessBlock numArgs = 1 						ifTrue:	[ self getBlockWithSubjectFor: accessBlock ]						ifFalse:	[ self getBlockWithoutSubjectFor: accessBlock ].</body></methods><methods><class-id>COAST.CoastComboBoxAdaptor</class-id> <category>private</category><body package="COASTViews">displayStringFor: val 	^ self displayStringBlock notNil 		ifTrue:	[ self displayStringBlock value: val ]		ifFalse:	[	val notNil 						ifTrue:	[ val displayString ]						ifFalse:	[ '' ]				]</body><body package="COASTViews">unwrapValueFrom: newValText 	^ newValText wrappedComboBoxObject</body><body package="COASTViews">wrapValue: val 	| text comboText |	text := self displayStringFor: val.	comboText := text asComboBoxText.	comboText wrappedComboBoxObject: val.	^ comboText</body><body package="COASTViews">writeBlock: assignBlock 	writeBlock := assignBlock numArgs = 2 					ifTrue:	[ self setBlockWithSubjectFor: assignBlock ]					ifFalse:	[ self setBlockWithoutSubjectFor: assignBlock ].</body></methods><methods><class-id>COAST.CoastController</class-id> <category>tracker</category><body package="COASTViews">abortAllTrackers	" Aborts all trackers that are on the trackers-stack " 	[ self currentTracker notNil ] whileTrue:		[ self abortCurrentTracker ]</body><body package="COASTViews">abortCurrentTracker	" Aborts and removes the currently active tracker. "	self currentTracker finishTracking."	self removeCurrentTracker."</body><body package="COASTViews">currentTracker	" Returns the currently active tracker or nil "	^ trackers notEmpty 		ifTrue: [ trackers last ]		ifFalse: [ nil ]</body><body package="COASTViews">installTracker: aTracker 	" Installs the given tracker. The tracker is pushed on the stack of trackers. 	All subsequent events will be handled by the tracker until it finishes tracking. "	^ trackers addLast: aTracker</body><body package="COASTViews">installTrackerOfClass: trackerClass	" Installs a tracker of the given class. All subsequent events will be handled 	by the tracker until it finishes tracking.  "		| tr |	tr := trackerClass on: self.	self installTracker: tr.	^ tr.</body><body package="COASTViews">installTrackerOfClass: trackerClass andHandleEvent: event	" Installs a tracker of the given class. The given event and all subsequent 	events will be handled by the tracker until it finishes tracking.  "	| tr |	tr := self installTrackerOfClass: trackerClass.	tr handleEvent: event.	^ tr</body><body package="COASTViews">removeCurrentTracker	^ trackers notEmpty 		ifTrue: [ trackers removeLast ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CoastController</class-id> <category>event dispatching</category><body package="COASTViews">abortAndDispatch: event to: anotherController	self abortCurrentTracker.	event dispatchTo: anotherController.</body><body package="COASTViews">abortAndDispatchToContainer: event	self abortCurrentTracker.	self dispatchEventToContainer: event</body><body package="COASTViews">dispatchEventToContainer: event	self view container dispatchEventFromComponent: event</body></methods><methods><class-id>COAST.CoastController</class-id> <category>drag and drop source</category><body package="COASTViews">canBeDroppedOn: targetController at: aPoint	"This is sent be the target controller to the source controller 	(or any other sourceObject on which a CatCODropSource is created).	If a new object should be created when dropped, a controller class is	used instead of the controller, as a new object has no controller yet.	aPoint is a local point,	targetController is the controller this one should be dropped on to.	(ps/00/03)"	"This could be s.th. like		targetController acceptDropOf***: self at: aPoint	per default: ask the class"	^ self class canBeDroppedOn: targetController at: aPoint</body></methods><methods><class-id>COAST.CoastController</class-id> <category>event driven</category><body package="COASTViews">cursorPointFor: anEvent	^ self sensor mousePointForEvent: anEvent</body><body package="COASTViews">handleEvent: event 	" When a tracker is currently active, the event is dispatched to the tracker, 	otherwise to the controller. "		(self currentTracker notNil and: [ event isWindowEvent not] )			ifTrue: [ self currentTracker handleEvent: event ]			ifFalse: [ super handleEvent: event ].</body><body package="COASTViews">lostMouseControlEvent: aMouseEvent	" we do not have control any more "	^ nil</body><body package="COASTViews">processEvent: event	" An event was received from the CoastEventManager. Handle the event if it happened within	my bounds "	(self viewHasCursorWithEvent: event)		ifTrue: [ self handleEvent: event ].</body><body package="COASTViews">viewHasCursorWithEvent: event 	"Answer true if the cursor point of the receiver's sensor lies within 	the display box of the receiver's view. "	view == nil ifTrue: [^false].	event hasPoint ifFalse: [^false].	view bounds isNil ifTrue: [ ^false ].	^view bounds containsPoint: (self cursorPointFor: event)</body></methods><methods><class-id>COAST.CoastController</class-id> <category>initialize-release</category><body package="COASTViews">initialize	super initialize.	trackers := OrderedCollection new.</body><body package="COASTViews">release	self abortAllTrackers.	super release.</body></methods><methods><class-id>COAST.CoastController</class-id> <category>accessing</category><body package="COASTViews">isTracking	" True if a tracker is currently active "	^ trackers isEmpty not</body><body package="COASTViews">menu	^self class menu</body><body package="COASTViews">model	^self view notNil		ifTrue: [self view model]		ifFalse: [super model]</body></methods><methods><class-id>COAST.CoastController</class-id> <category>transactions</category><body package="COASTViews">transactionDo: aBlock	^ self transactionManager bestTransactionDo: aBlock</body><body package="COASTViews">transactionManager	^ self model transactionManager</body></methods><methods><class-id>COAST.CoastController class</class-id> <category>drag and drop source</category><body package="COASTViews">canBeDroppedOn: targetController at: aPoint	"This is sent be the target controller to the source controller 	(or any other sourceObject on which a CatCODropSource is created).	If a new object should be created when dropped, a controller class is	used instead of the controller, as a new object has no controller yet.	aPoint is a local point,	targetController is the controller this one should be dropped on to.	(ps/00/03)"	"This should be s.th. like		targetController acceptDropOf***Class: self at: aPoint	per default: don't drop on anything!"	^ false</body></methods><methods><class-id>COAST.CoastController class</class-id> <category>resources</category><body package="COASTViews">menu	^Notifier isDevelopment		ifTrue: [self devopmentMenu]		ifFalse: [nil]</body></methods><methods><class-id>COAST.CoastController class</class-id> <category>testing</category><body package="COASTViews">isDeveloper	^ false</body></methods><methods><class-id>COAST.CoastNoController</class-id> <category>event dispatching</category><body package="COASTViews">handlerForMouseEvent: aMouseEvent	^ nil</body></methods><methods><class-id>COAST.CoastNoController</class-id> <category>event driven</category><body package="COASTViews">viewHasCursor	^ false</body><body package="COASTViews">viewHasCursorWithEvent: event 	^ false</body></methods><methods><class-id>COAST.ComboBoxText</class-id> <category>accessing</category><body package="COASTViews">wrappedComboBoxObject	^ wrappedComboBoxObject</body><body package="COASTViews">wrappedComboBoxObject: aWrappedComboBoxObject 	wrappedComboBoxObject := aWrappedComboBoxObject.</body></methods><methods><class-id>COAST.ComboBoxText</class-id> <category>printing</category><body package="COASTViews">printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the receiver.	The format is 		Text for sequence-of-characters."	aStream nextPutAll: (#TextFor &lt;&lt; #dialogs &gt;&gt; 'CoastComboBoxText for ') asString.	string printOn: aStream</body></methods><methods><class-id>COAST.ComboBoxText</class-id> <category>converting</category><body package="COASTViews">asComboBoxText	^ self</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>drag drop</category><body package="COASTViews">acceptDrop: aDragDropContext into: aView 	^(self dropTargetFor: aDragDropContext into: aView) notNil</body><body package="COASTViews">drop: aDragDropContext into: subView dropAction: aBlock "Execute the drop, return true if a drop target was found, false otherwise"	| returnValue |	self transactionDo: 			[| target dropPosition |			dropPosition := aDragDropContext mousePoint 						- self builder window globalOrigin.			target := subView coastDropTargetFor: aDragDropContext at: dropPosition.			target isNil ifTrue: [ "Drop did not succeed"					returnValue := false ]				ifFalse: 					[aBlock 						value: target						value: (aDragDropContext sourceData clientData at: #model)						value: dropPosition.						returnValue := true]].	^returnValue</body><body package="COASTViews">dropTargetFor: aDragDropContext into: aView 	^aView coastDropTargetFor: aDragDropContext		at: aDragDropContext mousePoint - self builder window globalOrigin</body><body package="COASTViews">sequenceDrop: aDragDropContext into: subView dropAction: aBlock 	| transactionManager target dropPosition |	transactionManager := self transactionManager.	transactionManager isNil ifTrue: [ ^ nil ].	transactionManager transactionSequenceDo: [		transactionManager sequenceDo: 			[	dropPosition := aDragDropContext mousePoint - self builder window globalOrigin.				target := subView coastDropTargetFor: aDragDropContext at: dropPosition			].		target isNil 			ifFalse: [ aBlock value: target value: ( aDragDropContext sourceData clientData at: #model ) value: dropPosition ].	].	^ target</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>testing</category><body package="COASTViews">allowsSlotComputation	"Does it make sense to recalculate any virtual slot of this local application model?"	^true</body><body package="COASTViews">areSlotsInactive	^ viewState isNil or: [ viewState allowsSlotComputation not ]</body><body package="COASTViews">closedLocally	^ closedLocally</body><body package="COASTViews">isClosedByObserver	" NOTE: sending this method is ONLY valid during a changeRequest "	^ self sharedApplicationModel isNil</body><body package="COASTViews">isEmbedded	" returns true if this app's interface is embedded into another app's interface "	^ self builder windowSpec isNil</body><body package="COASTViews">isMainApplication	" true falls diese App das Hauptmodell des Fensters ist. "	^ self builder notNil 		ifTrue: [ self builder bindings at: #'__isMainApplication' ifAbsent: [ super isMainApplication ]]		ifFalse: [ false ]</body><body package="COASTViews">isWeakObserver	^ false</body><body package="COASTViews">rememberWindowBounds	" return true if the window bounds should be remembered when closing the window "	^ self class rememberWindowBounds</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>slot accessing</category><body package="COASTViews">at: aSymbol 	| result badViewState |	badViewState := viewState isNil.	result :=		[	badViewState 				ifTrue: [ nil ]				ifFalse: [ viewState at: aSymbol ]		] 			on: CoastInvalidViewStateError			do: 			[: ex |				CoastLog logWarning: 'Bad view state of app ' , self class fullName , ' detected'.				badViewState := true.				ex return: nil			].	^ badViewState 		ifTrue: 		[	" fieses Gestocher fÃ¼r halb abgebaute Apps"			( self class viewStatePrototype ifNotNil: [: vsp | vsp basicSlotNamed: aSymbol ]) ifNotNil: [: s | s resolvedCellValue ]		]		ifFalse: [ result ]</body><body package="COASTViews">at: aSymbol add: newValue	^ self viewState at: aSymbol add: newValue</body><body package="COASTViews">at: aSymbol remove: aValue	^ self viewState at: aSymbol remove: aValue</body><body package="COASTViews">at: slotName set: anObject	^ self viewState at: slotName set: anObject</body><body package="COASTViews">at: slotName setAll: aCollection 	^ self viewState at: slotName setAll: aCollection</body><body package="COASTViews">slotNamed: aSlotName 	^ viewState notNil 		ifTrue: [ viewState slotNamed: aSlotName ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>slot accessing / OrderedCollection</category><body package="COASTViews">at: slotName add: anObject after: anotherObject	^ self viewState at: slotName add: anObject after: anotherObject</body><body package="COASTViews">at: slotName add: anObject afterIndex: index	^ self viewState at: slotName add: anObject afterIndex: index</body><body package="COASTViews">at: slotName add: anObject before: anotherObject	^ self viewState at: slotName add: anObject before: anotherObject</body><body package="COASTViews">at: slotName add: anObject beforeIndex: index	^ self viewState at: slotName add: anObject beforeIndex: index</body><body package="COASTViews">at: slotName addFirst: anObject	^ self viewState at: slotName addFirst: anObject</body><body package="COASTViews">at: slotName addLast: anObject	^ self viewState at: slotName addLast: anObject</body><body package="COASTViews">at: slotName after: anObject	^ self viewState at: slotName after: anObject</body><body package="COASTViews">at: slotName atIndex: index	^ self viewState at: slotName atIndex: index</body><body package="COASTViews">at: slotName atIndex: index put: anObject	^ self viewState at: slotName atIndex: index put: anObject</body><body package="COASTViews">at: slotName before: anObject	^ self viewState at: slotName before: anObject</body><body package="COASTViews">at: slotName indexOf: anObject	^ self viewState at: slotName indexOf: anObject</body><body package="COASTViews">at: slotName removeAtIndex: index	^ self viewState at: slotName removeAtIndex: index</body><body package="COASTViews">firstAt: slotName	^ self viewState firstAt: slotName</body><body package="COASTViews">lastAt: slotName	^ self viewState lastAt: slotName</body><body package="COASTViews">removeFirstAt: slotName	^ self viewState removeFirstAt: slotName</body><body package="COASTViews">removeLastAt: slotName	^ self viewState removeLastAt: slotName</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>slot accessing / bag</category><body package="COASTViews">at: slotName add: anObject withOccurrences: anInteger	^ self viewState at: slotName add: anObject withOccurrences: anInteger</body><body package="COASTViews">at: slotName removeAllOccurrences: anObject	^ self viewState at: slotName removeAllOccurrences: anObject</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>slot accessing / Dictionary</category><body package="COASTViews">at: slotName atKey: key	^ self viewState at: slotName atKey: key</body><body package="COASTViews">at: slotName atKey: key put: value	^ self viewState at: slotName atKey: key put: value</body><body package="COASTViews">at: slotName includesKey: key	^ self viewState at: slotName includesKey: key</body><body package="COASTViews">at: slotName keyAtValue: value	^ self viewState at: slotName keyAtValue: value</body><body package="COASTViews">at: slotName removeKey: key	^ self viewState at: slotName removeKey: key</body><body package="COASTViews">keysAt: slotName	^ self viewState keysAt: slotName</body><body package="COASTViews">valuesAt: slotName	^ self viewState valuesAt: slotName</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>slot accessing / collections</category><body package="COASTViews">at: slotName includes: anObject	^ self viewState at: slotName includes: anObject</body><body package="COASTViews">at: slotName occurrencesOf: anObject	^ self viewState at: slotName occurrencesOf: anObject</body><body package="COASTViews">isEmpty: slotName	^ self viewState isEmpty: slotName</body><body package="COASTViews">sizeAt: slotName	^ self viewState sizeAt: slotName</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>actions</category><body package="COASTViews">bringWindowToTop	| window |	builder isNil ifTrue: [^self].	(window := self builder window) notNil		ifTrue: [ window bringWindowToTop  ]</body><body package="COASTViews">closeRequest	^ coastDialog notNil		ifTrue: [ coastDialog closeRequest ]		ifFalse: [ super closeRequest ]</body><body package="COASTViews">dialogCancelled	"me was embedded in a dialog which was cancelled"</body><body package="COASTViews">invalidateSlot: aSlotName afterMilliseconds: milliseconds 	| block args tm |	milliseconds isNil 		ifTrue: [ ^ nil ].	tm := self areSlotsInactive 			ifTrue: [ nil ]			ifFalse: [ self viewState transactionManager ].	args := Array with: Time millisecondClockValue with: milliseconds with: aSlotName.	block :=	[: startTime : delay : slot | | toWait win |		( toWait := Time millisecondClockValue - startTime ) &lt; delay 			ifTrue: [( Delay forMilliseconds: delay - toWait ) wait ].		tm isNil 			ifFalse: 			[	tm displayDo: 					[(						[ self builder window isOpen not or: [ self areSlotsInactive ]] valueOnUnwindDo: [ true ]) 							ifFalse: 							[	( self viewState slotNamed: slot ) invalidate.								( win := Window currentWindow ) notNil 									ifTrue: [ win sensor noteEvent ]							]					]			]	].	tm startPendingProcess: block withArgs: args.</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>private</category><body package="COASTViews">basicSlotNamed: slotName	^ self viewState ifNotNil: [: vs | vs basicSlotNamed: slotName ] ifNil: [ #( )]</body><body package="COASTViews">basicSlots	^ self viewState ifNotNil: [: vs | vs basicSlots ] ifNil: [ #( )]</body><body package="COASTViews">changeRequest	"The local application window wants to be closed. Close 	the shared counterparts."	| sharedApp |	( sharedApp := self sharedApplicationModel ) notNil ifTrue: 		[ | tm |			tm := sharedApp transactionManager.			( tm notNil and: [ tm active ]) ifTrue: 				[ | failed |					failed := false.					sharedApp transactionManager closeRequestTransactionDo: 						[	self prepareClose.							sharedApp closeSharedOnly.							closedLocally := true.						]						onFailure: [ failed := true ].					failed ifTrue: [ ^ false ]				]		].	^ super changeRequest</body><body package="COASTViews">closeLocalOnly	sharedApplicationModel notNil		ifTrue: [ sharedApplicationModel localApplicationModel: nil ].	sharedApplicationModel := nil.		self builder notNil ifTrue: [ self closeAndUnschedule ].</body><body package="COASTViews">prepareClose	self updatePersistentWindowBounds.</body><body package="COASTViews">screenBoundsAround: aPoint	"Bounds des Desktops, der den Punkt enthÃ¤lt.	Also OHNE irgendwelche gespeicherten Positionen zu berÃ¼cksichtigen "	| screenBounds |	screenBounds := Screen default boundsAround: aPoint.	^ screenBounds ifNil: [ Screen default bounds ]</body><body package="COASTViews">screenBoundsAroundOpenLocation	"Bounds des Desktops, wo das Fenster ursprÃ¼nglich aufgehen sollte.	Also OHNE irgendwelche gespeicherten Positionen zu berÃ¼cksichtigen "	^ self screenBoundsAround: InputState default mousePoint</body><body package="COASTViews">updatePersistentWindowBounds	" the app is about to close. do what is necessary.	node this method is called inside a pessimistic transaction "	(self class rememberWindowBounds and: [ self sharedApplicationModel notNil ]) ifTrue: [		self builder ifNotNil: [ : b |			b window ifNotNil: [ : win |				self sharedApplicationModel persistentWindowBounds: (win globalOrigin extent: win extent)				].			].		].</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>accessing</category><body package="COASTViews">coastDialog	^ coastDialog</body><body package="COASTViews">coastDialog: aCoastSimpleDialog	coastDialog := aCoastSimpleDialog</body><body package="COASTViews">coastObserver	^ self</body><body package="COASTViews">coastSubject	^ self</body><body package="COASTViews">createLocalApp	" for compatibility with shared apps "	^ self</body><body package="COASTViews">createSharedApp	^ CoastUniversalLocalApplicationModel localApplicationModel: self</body><body package="COASTViews">domainModel	| sa |	^ (self at: #domainModel) 		ifNil: [ 			(sa := self sharedApplicationModel) notNil 				ifTrue: [ sa domainModel ] 				ifFalse: [ nil ]]</body><body package="COASTViews">domainModel: aCoastModel	self at: #domainModel set: aCoastModel</body><body package="COASTViews">fetchLocalUser	"the old and complicated way"	| lu win |	lu := nil.	(self builder isNil or: [ (win := self builder window) isNil ])		ifFalse: [			self transactionManager localInterestObservers do: 				[:io | 					"use 'self builder window model' instead of 'self' to make it work in sub-apps as well"					((io localAppModels includes: self) or: [io localAppModels includes: win model])							ifTrue: [lu := io monitoredUser]].		].	^lu notNil		ifTrue: [ lu sharedCopy ]		ifFalse: [ self transactionManager localUser ]</body><body package="COASTViews">localApplicationModel	^ self</body><body package="COASTViews">localUser	^localUser ifNil: [ localUser := self fetchLocalUser sharedCopy ].</body><body package="COASTViews">localUser: aCoastUser	" even though this method is called localUser:, we actually mean the sharedCopy of the the local user! "	localUser := aCoastUser sharedCopy</body><body package="COASTViews">model	"ViewState might ask for this"	^self sharedApplicationModel</body><body package="COASTViews">prototype 	^self class prototype</body><body package="COASTViews">sharedApplicationModel	^ sharedApplicationModel</body><body package="COASTViews">sharedApplicationModel: aModel	sharedApplicationModel := aModel.	aModel isNil ifFalse: [ aModel localApplicationModel: self ].</body><body package="COASTViews">transactionManager	viewState notNil ifTrue: 		[ | transactionManager |			transactionManager := viewState transactionManager.			transactionManager notNil ifTrue: [ ^ transactionManager ]		].	"try harder"	^ localUser notNil 		ifTrue: [ localUser transactionManager ]		ifFalse: [ nil ]</body><body package="COASTViews">viewState	" Returns the view-state holding the slots of the visual part "	^ viewState</body><body package="COASTViews">viewState: aCatFSVirtualFrame	" Sets the view-state holding the slots of the visual part  "	viewState := aCatFSVirtualFrame.</body><body package="COASTViews">windowLabelForEmbeddedDialogSpec: fullSpec	^ fullSpec window label asString</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>slot accessing / general</category><body package="COASTViews">depleteSlot: slotName 	^ self viewState depleteSlot: slotName</body><body package="COASTViews">invalidateSlot: slotName 	^ (self viewState slotNamed: slotName) ifNotNil: [: slot | slot invalidate ]</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>transactions</category><body package="COASTViews">displayDo: aBlock 	| transactionManager |	transactionManager := self transactionManager.	^ transactionManager notNil 		ifTrue: [ transactionManager displayDo: aBlock ]		ifFalse: [ nil ]</body><body package="COASTViews">sequenceDo: aBlock 	| transactionManager |	transactionManager := self transactionManager.	^ transactionManager notNil 		ifTrue: [ transactionManager sequenceDo: aBlock ]		ifFalse: [ nil ]</body><body package="COASTViews">transactionDo: aBlock 	| transactionManager |	transactionManager := self transactionManager.	^ transactionManager notNil 		ifTrue: [ transactionManager transactionDo: aBlock ]		ifFalse: [ nil ]</body><body package="COASTViews">transactionSequenceDo: aBlock 	| transactionManager |	transactionManager := self transactionManager.	^ transactionManager notNil 		ifTrue: [ transactionManager transactionSequenceDo: aBlock ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>initialize-release</category><body package="COASTViews">finishObservation	1 to: self class instSize do: [: i | ( self instVarAt: i ) aspectAdaptorFinishObservation ].	viewState notNil 		ifTrue: [ viewState deactivate ].	self sharedApplicationModel notNil 		ifTrue: [ self sharedApplicationModel unsubscribe: self ].</body><body package="COASTViews">initialize	super initialize.	self class viewStatePrototype isNil ifTrue:	[		self class initializeSlotDescription.	].	self viewState: (self class viewStatePrototype deepCopyForView: self).	closedLocally := false</body><body package="COASTViews">noticeOfWindowClose: aWindow 	self finishObservation.	sharedApplicationModel := nil.	super noticeOfWindowClose: aWindow .</body><body package="COASTViews">postBuildMainWith: aBuilder	" sent after the main builder of the application (not a subbuilder) has finished "</body><body package="COASTViews">postBuildWith: aBuilder	super postBuildWith: aBuilder.	aBuilder windowSpec notNil		ifTrue: [self setIconWith: aBuilder ].	(self builder == aBuilder and: [ (builder bindings at: #__mainBuild ifAbsent: [ false ]) not ])		ifTrue: [ 			builder bindings at: #__mainBuild put: true.			self postBuildMainWith: aBuilder 		].</body><body package="COASTViews">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed 	window."	super postOpenWith: aBuilder.	self bringWindowToTop</body><body package="COASTViews">release	self finishObservation.	super release.</body><body package="COASTViews">setIconWith: aBuilder	| win |	(win := aBuilder window) notNil		ifTrue: [win icon: (Icon new figure: self class windowIcon shape: self class windowIconMask)].</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>slot inverting</category><body package="COASTViews">invertedSlotNamed: slotName addFrame: aViewState demon: demon 	( self viewState notNil and: [ aViewState notNil ]) 		ifTrue: [ self viewState invertedSlotNamed: slotName addFrame: aViewState view demon: demon ]</body><body package="COASTViews">invertedSlotNamed: slotName removeFrame: aViewState demon: demon 	( self viewState notNil and: [ aViewState notNil ]) 		ifTrue: [ self viewState invertedSlotNamed: slotName removeFrame: aViewState view demon: demon ]</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>interface opening</category><body package="COASTViews">openFor: aCoastUser 	^ self sharedApplicationModel openFor: aCoastUser</body><body package="COASTViews">openForAll: someCoastUsers 	self sharedApplicationModel openForAll: someCoastUsers</body><body package="COASTViews">openForLocalUser	self sharedApplicationModel openFor: self transactionManager localUser</body><body package="COASTViews">openInterface: aSymbol withPolicy: aPolicy inSession: anApplicationContext 	"Open the ApplicationModel's user interface, using the specification 	named and the given look policy and application context."	| spec |	builder := aPolicy newBuilder.	uiSession := anApplicationContext.	builder source: self.	spec := self class interfaceSpecFor: aSymbol.	builder bindings at: #__specName put: aSymbol.	builder bindings at: #__isMainApplication put: true.	self preBuildWith: builder.	self hookUpWindow: self defaultWindowClassOrNil spec: spec builder: builder.	builder add: spec.	self postBuildWith: builder.	builder window model: self.	self openWindowWith: builder spec: spec.	builder window displayPendingInvalidation.	self postOpenWith: builder.	^ builder</body><body package="COASTViews">openWindowWith: aBuilder spec: spec	| wb |	wb := self preferredWindowBounds.	(wb notNil and: [ wb extent &gt; (20@20) ])		ifTrue: [ aBuilder openWithExtent: wb extent ]		ifFalse: [  aBuilder openWithExtent: spec window bounds extent ]</body><body package="COASTViews">preferredModalWindowBounds	^ self preferredWindowBounds</body><body package="COASTViews">preferredWindowBounds	| wb clipRect |	( self rememberWindowBounds and: [ self sharedApplicationModel notNil and: [( wb := self sharedApplicationModel persistentWindowBounds ) notNil ]]) 		ifTrue: 		[	clipRect := Screen default preferredRectangleToConstrain: ( 0 @ 0 extent: wb extent ).			wb extent: ( wb extent min: clipRect extent )		].	^ wb</body></methods><methods><class-id>COAST.CoastLocalApplicationModel class</class-id> <category>slot description - accessing</category><body package="COASTViews">allLazySlotNames	^self allLazySlotSelectors collect: [ :sel | (sel copyFrom: 1 to: (sel size - 4)) asSymbol ]</body><body package="COASTViews">allLazySlotSelectors	| cl slotSelectors |	slotSelectors := IdentitySet new.	cl := self.	[slotSelectors addAll: cl lazySlotSelectors.	 (cl := cl superclass) == ApplicationModel] whileFalse: [].	^slotSelectors</body><body package="COASTViews">lazySlotNames	^self lazySlotSelectors collect: [ :sel | (sel copyFrom: 1 to: (sel size - 4)) asSymbol ]</body><body package="COASTViews">lazySlotSelectors	^self class selectors select: [ :s | '*Slot' match: s asString ]</body></methods><methods><class-id>COAST.CoastLocalApplicationModel class</class-id> <category>interface opening</category><body package="COASTViews">domainModel: aCoastModel	^ self new		domainModel: aCoastModel;		yourself</body><body package="COASTViews">onSharedApplication: aSharedApplicationModel	| newInst |	newInst := self new.	newInst sharedApplicationModel: aSharedApplicationModel.	^ newInst</body><body package="COASTViews">openOnSharedApplication: aSharedApplicationModel	| newInst |	newInst := self new.	newInst sharedApplicationModel: aSharedApplicationModel.	self openOn: newInst.	^ newInst</body><body package="COASTViews">openUniversalAppOn: domainModel	| sharedApp |	sharedApp := self universalAppOn: domainModel.	sharedApp open.	^ sharedApp</body><body package="COASTViews">rememberWindowBounds	" return true if the window bounds should be remembered when closing the window "	^ false</body><body package="COASTViews">universalAppOn: domainModel	" returns an universal app model "	| sharedApp |	sharedApp := CoastUniversalLocalApplicationModel newLocal.	sharedApp 		domainModel: domainModel;		localApplicationModelClass: self.	^ sharedApp</body><body package="COASTViews">withUniversalAppOn: domainModel	" returns an instance of myself "	^ (self universalAppOn: domainModel) createLocalApp</body></methods><methods><class-id>COAST.CoastLocalApplicationModel class</class-id> <category>slots</category><body package="COASTViews">domainModelSlot	^ self slotSingleValue</body></methods><methods><class-id>COAST.CoastLocalApplicationModel class</class-id> <category>slot description</category><body package="COASTViews">initializePrototype	self initializeSlotDescription.</body><body package="COASTViews">initializeSlotDescription	"CatCSTransactionManager current transactionDo: [ self withAllSubclassesDo: [ :c |  c initializeSlotDescription] ]"	| aSlotOrSomething |	self viewStatePrototype: ViewState newPrototype.	self allLazySlotNames do: [ :slotName | 		aSlotOrSomething := self perform: (slotName , 'Slot') asSymbol.		(aSlotOrSomething notNil and: [ (self prototype valueHolder at: slotName) isNil ])			ifTrue: [viewStatePrototype slot: slotName with: aSlotOrSomething ]].</body><body package="COASTViews">slot: aSlotName	^self viewStatePrototype slotNamed: aSlotName</body></methods><methods><class-id>COAST.CoastLocalApplicationModel class</class-id> <category>instance creation</category><body package="COASTViews">newLocal	" for compatibility with shared apps "	^ self new</body></methods><methods><class-id>COAST.CoastLocalApplicationModel class</class-id> <category>accessing</category><body package="COASTViews">editorReuseKey	^ nil</body><body package="COASTViews">emptyPrototype	self viewStatePrototype: nil.</body><body package="COASTViews">prototype	^ viewStatePrototype</body><body package="COASTViews">prototypeNeeded	viewStatePrototype isNil ifTrue: [ self initializeSlotDescription ].	^ viewStatePrototype</body><body package="COASTViews">viewStatePrototype	^ viewStatePrototype</body><body package="COASTViews">viewStatePrototype: aCatDMViewState	viewStatePrototype := aCatDMViewState</body></methods><methods><class-id>COAST.CoastLocalApplicationModel class</class-id> <category>slot creation</category><body package="COASTViews">slotComputedBy: aBlockOrSelector 	^ self slotComputedBy: aBlockOrSelector slotClass: CatFSVirtualSlot</body><body package="COASTViews">slotComputedBy: aBlockOrSelector slotClass: slotClass	| composingMethod |	composingMethod := aBlockOrSelector isSymbol		ifTrue: [			[ : viewState |				( viewState isNil or: [ viewState view isNil ]) ifTrue: [ CoastInvalidViewStateError raiseSignal ].				viewState view perform: aBlockOrSelector			]		]		ifFalse: [			[ : viewState |				( viewState isNil or: [ viewState view isNil ]) ifTrue: [ CoastInvalidViewStateError raiseSignal ].				aBlockOrSelector value: viewState view			]		].	^ slotClass computedBy: composingMethod.</body><body package="COASTViews">slotComputedEagerBy: aBlockOrSelector 	^ self slotComputedBy: aBlockOrSelector slotClass: CatFSEagerVirtualSlot</body><body package="COASTViews">slotOfType: aType 	^CatFSSlot newPrototypeOfType: aType.</body><body package="COASTViews">slotSingleValue	^self slotOfType: #singleValue</body></methods><methods><class-id>COAST.CoastNotifierLocal</class-id> <category>aspects</category><body package="COASTViews">message	"This method was generated by CatESDefiner.  Any edits made here	may be lost whenever methods are automatically defined. Do not	assign a value to the aspect here, instead initialize the shared	application model."	^message isNil		ifTrue:			[message := CoastAspectAdaptor				accessBlock: [ self sharedApplicationModel at: #message ]				assignBlock: [ :newValue | self sharedApplicationModel at: #message set: newValue ]				application: self.]		ifFalse:			[message]</body></methods><methods><class-id>COAST.CoastNotifierLocal</class-id> <category>actions</category><body package="COASTViews">ok	self closeRequest</body></methods><methods><class-id>COAST.CoastEagerAspectAdaptor class</class-id> <category>slot description</category><body package="COASTViews">valueSlot	^ self slotComputedEagerBy: [:f | f computeValue]</body></methods><methods><class-id>COAST.CoastDifferentialListAspectAdaptor</class-id> <category>computing</category><body package="COASTViews">computeElementValues	| transaction existingValues newValues |	self standByMode ifTrue: [ ^ #() ].	transaction := self transactionManager activeTransaction.	transaction isNil ifTrue: [ ^ self ].	existingValues := ( self basicSlotNamed: #elementValues ) ifNotNil: [: valueSlot | valueSlot basicValueHolderContent ].	newValues := self value collectAsOrderedCollection: [ : element | elementValuesBlock value: element ].	(existingValues notNil and: [ existingValues size = newValues size ]) ifTrue:	[		1 to: existingValues size do: [ : idx | (existingValues at: idx) = (newValues at: idx) ifFalse: [ self notifyChange: (self at: #value) at: idx transaction: transaction ] ].	].	^newValues</body><body package="COASTViews">computeValue	| newValue existingList lastVal |	self standByMode ifTrue: [ ^ self value ].	existingList := ( self basicSlotNamed: #value ) ifNotNil: [: valueSlot | valueSlot basicValueHolderContent ].	newValue := updateBlock value.	existingList isNil 		ifTrue: [ existingList := newValue asList ]		ifFalse: 		[	existingList asSet do: [: e | ( newValue includes: e ) ifFalse: [ existingList remove: e ]].			lastVal := nil.			newValue do: 				[: e |					( existingList includes: e ) ifFalse: 						[	lastVal isNil 								ifTrue: [ existingList addFirst: e ]								ifFalse: [ existingList add: e after: lastVal ]						].					lastVal := e				]		].	^ existingList</body></methods><methods><class-id>COAST.CoastDifferentialListAspectAdaptor</class-id> <category>dependents access</category><body package="COASTViews">notifyChange: list at: index transaction: transaction	transaction addPostViewUpdateBlock: 		[				[ | deps |				deps := self myDependents coastAsSet.				deps do: [: e | e update: #at: with: index from: list ]			] on: Error do: [: ex | CoastLog log: 'Error in ' , thisContext printString , ': ' , ex description ]		].</body><body package="COASTViews">notifyDependentsAfterComputation: newValue 	"done by valueAdded:removed:"</body><body package="COASTViews">valueAdded: added removed: removed 	| transaction updateSymbol updateArg |	transaction := self transactionManager activeTransaction.	updateSymbol := #value.	updateArg := nil.	( added size = 1 and: [ removed size = 0 ]) ifTrue: 		[	updateSymbol := #add.			updateArg := ( self basicSlotNamed: #value ) basicValueHolderContent indexOf: added singleElement		].	transaction addPostViewUpdateBlock: 		[				[ | deps listView updateOrigin |				deps := self myDependents coastAsSet.				listView := deps detect: [ : e | e class ~= CoastMultiSelectionInList ].				updateOrigin := listView sequence.				updateSymbol = #add ifTrue: [ updateOrigin add: added singleElement ] ifFalse: [				deps do: [: e | e update: updateSymbol with: updateArg from: self ] ]			] on: Error do: [: ex | CoastLog log: 'Error in ' , thisContext printString , ': ' , ex description ]		].</body></methods><methods><class-id>COAST.CoastDifferentialListAspectAdaptor</class-id> <category>initialize-release</category><body package="COASTViews">checkStandBy	" the list is a dependent, don't care "	self dependents size &lt;= 1				ifTrue: [ self standBy ].</body></methods><methods><class-id>COAST.CoastDifferentialListAspectAdaptor</class-id> <category>accessing</category><body package="COASTViews">elementValuesBlock: aBlock	elementValuesBlock := aBlock</body></methods><methods><class-id>COAST.CoastDifferentialListAspectAdaptor class</class-id> <category>slot description</category><body package="COASTViews">elementValuesSlot	^ self slotComputedEagerBy: [: f | f computeElementValues ]</body></methods><methods><class-id>COAST.PersonalizedValueHolder</class-id> <category>accessing</category><body package="COASTViews">defaultValue	^ self at: #defaultValue</body><body package="COASTViews">defaultValue: anObject	 self at: #defaultValue set: anObject</body><body package="COASTViews">explicitValueForUser: aUser 	"Do not return the defaultValue as fallback"	^ self at: #valuesDictionary atKey: aUser</body><body package="COASTViews">localUser	^self transactionManager localUser</body><body package="COASTViews">remoteValues	^(self users reject: [ :each | each = self localUser ]) collect: [ :u | self valueForUser: u ]</body><body package="COASTViews">removeEntryFor: aUser	^self		at: #valuesDictionary		removeKey: aUser</body><body package="COASTViews">users	^self keysAt: #valuesDictionary</body><body package="COASTViews">value	^self valueForUser: self localUser</body><body package="COASTViews">value: anObject 	self localUser isNil		ifTrue: [self defaultValue: anObject]		ifFalse: [self value: anObject forUser: self localUser]</body><body package="COASTViews">value: anObject forUser: aUser	^self		at: #valuesDictionary		atKey: aUser		put: anObject</body><body package="COASTViews">valueForUser: aUser 	| individualValue |	individualValue := self explicitValueForUser: aUser.	^ individualValue ifNil: [ self defaultValue ]</body><body package="COASTViews">values	^ ( self valuesAt: #valuesDictionary ) copyWith: self defaultValue</body></methods><methods><class-id>COAST.PersonalizedValueHolder class</class-id> <category>instance creation</category><body package="COASTViews">defaultValue: anObject 	^(self new) defaultValue: anObject; yourself</body></methods><methods><class-id>COAST.PersonalizedValueHolder class</class-id> <category>slot description</category><body package="COASTViews">defaultValueSlot	^self slotOfType:#singleValue</body><body package="COASTViews">valuesDictionarySlot	^self slotOfType: #dictionary</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper</class-id> <category>private</category><body package="COASTViews">absOrigin	"Answer the receiver's absolute origin measured in top window coordinates."	^container localPointToGlobal: self translation</body><body package="COASTViews">changedBounds: oldBounds forComponent: aVisualComponent	"The preferred bounds of aVisualComponent has changed from oldPreferredBounds.	Pass the message up the hierarchy after translation."	container == nil		ifFalse: [oldBounds == nil					ifTrue: [container								changedBounds: oldBounds								forComponent: self]					ifFalse: [container								changedBounds: (oldBounds translatedBy: self translation)								forComponent: self]]</body><body package="COASTViews">changedPreferredBounds: oldPreferredBounds forComponent: aVisualComponent	"The preferred bounds of aVisualComponent has changed from	oldPreferredBounds. Pass the message up the hierarchy after	translation."	container == nil		ifFalse: [oldPreferredBounds == nil					ifTrue: [container								changedPreferredBounds: oldPreferredBounds								forComponent: self]					ifFalse: [container								changedPreferredBounds: (oldPreferredBounds translatedBy: self translation)								forComponent: self]]</body><body package="COASTViews">compositionBoundsFor: aVisualPart	"The receiver is a container for aVisualPart.	An actual bounding rectangle is being searched for by	aVisualPart. Forward to the receiver's container."	^(container compositionBoundsFor: self) translatedBy: self translation negated</body><body package="COASTViews">globalPointToLocal: aPoint	"Convert a point in global (top window relative) coordinates to a point in the receiver's coordinate system."	^ (self container globalPointToLocal: aPoint) translatedBy: self translation negated.</body><body package="COASTViews">graphicsContextFor: aVisualComponent	"Answer a GraphicsContext set-up for aVisualComponent."	| gc |	gc := container graphicsContextFor: self.	gc translateBy: self translation.	^gc</body><body package="COASTViews">invalidateRectangle: aRectangle  repairNow: aBoolean forComponent: aVisualComponent	"Propagate damage up the hierarchy after translating and clipping.	Do not use 'self translation' instead of 'translationForInvalidation', otherwise the	dependencies get screwed up "	| rect |	rect := aRectangle translatedBy: translationForInvalidation.	super invalidateRectangle: rect  repairNow: aBoolean forComponent: self</body><body package="COASTViews">localPointToGlobal: aPoint	"Convert a point in local coordinates to a point in the top window's coordinate system."	"^aPoint translatedBy: self absOrigin"	^self container localPointToGlobal: (aPoint translatedBy: self translation).</body><body package="COASTViews">translationForInvalidation: aPoint	translationForInvalidation := aPoint</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper</class-id> <category>displaying</category><body package="COASTViews">composeDisplayOn: aGraphicsContext	"Display the receiver's component after translating aGraphicsContext."	aGraphicsContext translateBy: self translation.	super composeDisplayOn: aGraphicsContext.</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper</class-id> <category>testing</category><body package="COASTViews">containsPoint: aPoint	"Answer whether aPoint lies within the receiver's display box."	^component containsPoint: (aPoint translatedBy: self translation negated)</body><body package="COASTViews">intersects: aRectangle	"Answer whether the receiver's display box intersects aRectangle."	^component intersects: (aRectangle translatedBy: self translation negated)</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper</class-id> <category>broadcast</category><body package="COASTViews">downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator 	"This is a message passed down the view structure to some single 	part. Answer true if we accepted the event, or false if it should be 	passed on to whatever's behind us."	^super		downcastLocalEvent: aKey		with: aParameter		at: (aPoint translatedBy: translationForInvalidation negated)		from: anInitiator</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper</class-id> <category>bounds accessing</category><body package="COASTViews">extent	^ self component bounds extent</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper</class-id> <category>initialize-release</category><body package="COASTViews">initialize	translationForInvalidation := 0@0.	super initialize.</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper</class-id> <category>layout</category><body package="COASTViews">rectangleRelativeTo: containingBoundingBox	"Answer a rectangle for the receiver relative to the containingBoundingBox."	^(component rectangleRelativeTo: containingBoundingBox)			translatedBy: self translation</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper</class-id> <category>accessing</category><body package="COASTViews">translation	^ (self at: #translation) ifNil: [self composeTranslation]</body><body package="COASTViews">translationBlock: aBlock	translationBlock := aBlock</body><body package="COASTViews">translationComposer: translationComposer	translationBlock := [ translationComposer translationFor: self component ].</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper</class-id> <category>composing</category><body package="COASTViews">composeTranslation	" cache the translation "	translationForInvalidation := translationBlock value.	^ translationForInvalidation</body><body package="COASTViews">computePreferredBounds	"Answer the components bounds translated by the receiver's translation."	^ self component preferredBounds ifNotNil: [: bounds | bounds translatedBy: self translation ]</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper class</class-id> <category>instance creation</category><body package="COASTViews">in: aContainer on: aVisualComponent computedBy: translationBlock	^ (self in: aContainer on: aVisualComponent)		translationBlock: translationBlock;		yourself.</body><body package="COASTViews">in: aContainer on: aVisualComponent translationComposedBy: aComposer	^ (self in: aContainer on: aVisualComponent)		translationComposer: aComposer;		yourself.</body></methods><methods><class-id>COAST.ComposedTranslatingWrapper class</class-id> <category>slot description</category><body package="COASTViews">translationSlot	^ (self slotComputedEagerBy: [ :view | | t | t := view composeTranslation. view translationForInvalidation: t. t ])</body></methods><methods><class-id>COAST.CoastView</class-id> <category>drag drop</category><body package="COASTViews">acceptDropWith: aDragDropContext at: aPoint from: anInitiator	^false</body><body package="COASTViews">coastDropTargetFor: aDragDropContext at: aPoint	self 		downcastLocalEvent: #coastDropTarget		with: aDragDropContext -&gt; [ :target | ^ target ]		at: (self globalPointToLocal: aPoint)		from: self.	^ nil.</body><body package="COASTViews">downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator 	| ctrl |	((aKey == #coastDropTarget and: [self dropSensitiveBounds containsPoint: aPoint])		and: [self				acceptDropWith: aParameter key				at: aPoint				from: anInitiator])		ifTrue: 			["I am the drop target --&gt; non local return"			aParameter value value: self.			^true].	ctrl := self controller.	(ctrl notNil and: [aKey == #interestedInDrop and: [  aParameter key canBeDroppedOn: ctrl at: aPoint ]])		ifTrue: [ "hack ourself into the parameter :-( parcplace is responsible for this"			aParameter value value: ctrl.			^ true ].	^ super downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator</body><body package="COASTViews">dropSensitiveBounds^self bounds</body></methods><methods><class-id>COAST.CoastView</class-id> <category>accessing</category><body package="COASTViews">controller	"Answer the receiver`s current controller. If the receiver's controller 	is nil (the default case), an initialized instance of the receiver's 	default controller is installed and returned."	^self getController</body><body package="COASTViews">controller: aController 	"Set the receiver's controller to aController "	aController notNil		ifTrue: 		[			aController view: self.			aController model: self model.		].	controller := aController</body><body package="COASTViews">defaultController	"Answer an initialized instance of the receiver's default controller.	Subclasses should redefine this message only if the default controller 	instances need to be initialized in a nonstandard way."	^self defaultControllerClass new</body><body package="COASTViews">defaultControllerClass	^CoastController</body></methods><methods><class-id>COAST.CoastView</class-id> <category>events</category><body package="COASTViews">dispatchEventFromComponent: event	event dispatchTo: self controller</body></methods><methods><class-id>COAST.CoastView</class-id> <category>private</category><body package="COASTViews">getController	"Answer the receiver`s current controller. If the receiver's controller 	is nil (the default case), an initialized instance of the receiver's 	default controller is installed and returned."	controller == nil ifTrue: [self controller: self defaultController].	^controller</body></methods><methods><class-id>COAST.CoastView</class-id> <category>timer</category><body package="COASTViews">invalidateSlot: aSlotName afterMilliseconds: milliseconds 	| block args tm |	milliseconds isNil ifTrue: [^nil].	tm := self viewState isNil		ifTrue: [ nil ]		ifFalse: [ self viewState transactionManager ].	args := Array	with: Time millisecondClockValue				with: milliseconds				with: aSlotName.	block := 	[:startTime :delay :slot | 			| toWait win |			(toWait := Time millisecondClockValue - startTime) &lt; delay ifTrue: [(Delay forMilliseconds: delay - toWait) wait].			(self isOpen not or: [tm isNil]) ifFalse: [tm displayDo: 					[(self viewState slotNamed: slot) invalidate.					(win := Window currentWindow) notNil ifTrue: [						win sensor noteEvent]]]].	tm startPendingProcess: block withArgs: args.</body></methods><methods><class-id>COAST.CoastView</class-id> <category>initialize-release</category><body package="COASTViews">releaseController	"Release the receiver's controller."	" The implementation is different to View&gt;&gt;releaseController (because it is buggy: why	create a controller when we want to release it ?!?) "	controller isNil		ifFalse: [controller release.				controller := nil].</body></methods><methods><class-id>COAST.CoastView class</class-id> <category>slots</category><body package="COASTViews">modelSlot	^(self slotSingleValue)		demon: self modelDemon;		yourself</body></methods><methods><class-id>COAST.CoastView class</class-id> <category>demons</category><body package="COASTViews">modelDemon	" inform the controller of the new model "	^ CatFSDemon update		postTransactionJob: [: demon : anAccess : cell | anAccess cellFrame view controller model: ( anAccess frame at: #model )];		name: #modelDemon;		argument: nil;		yourself</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>private</category><body package="COASTViews">basicComponents	^ self model components</body><body package="COASTViews">changedComponents	" do nothing "</body><body package="COASTViews">viewClassFor: aModel	"find the right class for a new subview"	"either use the model's default view class or use the	subViewClassComputingBlock to find it"	^subViewClassComputingBlock isNil		ifTrue: [ self defaultSubviewClassFor: aModel ]		ifFalse: [ subViewClassComputingBlock value: aModel ].</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>accessing</category><body package="COASTViews">bounds: newBounds 	super bounds: newBounds.	self components do:		[:i |	i bounds: newBounds]</body><body package="COASTViews">defaultSubviewClassFor: aModel	^aModel defaultViewClass</body><body package="COASTViews">subViewClassComputingBlock: aBlock	"provide a block that computes the view class for a given model"	"the block expects one argument (the model) and has to return a view class"	subViewClassComputingBlock := aBlock</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>slot accessing</category><body package="COASTViews">components	| c |	^( self viewState notNil and: [( c := self at: #components ) notNil ]) 		ifTrue: [ c ]		ifFalse: [ Array new ]</body><body package="COASTViews">selectedComponents	^ self at: #selectedComponents</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>displaying</category><body package="COASTViews">composeDisplayOn: aGraphicsContext 	" SImply display all components. Checking if a component is inside the clipping rectangle	is done by the component itself "	" don't be dependent from my components, do avoid display updates when the components change "	| components displayDebugBounds |	displayDebugBounds := self displayDebugBounds.	self transactionManager withoutDependenciesDo: 		[	components := self components.			components notNil ifTrue: 				[	components do: 						[: component |							component displayOn: aGraphicsContext copy.							displayDebugBounds 								ifTrue: [ component bounds displayStrokedOn: ( aGraphicsContext copy setPaintToColor: ColorValue red )]						]				]		]</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>composing</category><body package="COASTViews">composeComponents	" compose the views of the models. Create new views for new models "	| basicComponents components activeTransaction oldViews removedModels |	self model isNil 		ifTrue: [ ^ OrderedCollection new ].	self model isBadFrame 		ifTrue: [ ^ OrderedCollection new ].	( basicComponents := self basicComponents ) isNil 		ifTrue: [ ^ OrderedCollection new ].	activeTransaction := self transactionManager activeTransaction.	activeTransaction notNil 		ifTrue: 		[	activeTransaction addFailureBlock: 				[	oldComponentDictionary do: [: oldView | oldView releaseWithoutInvalidation ].					oldComponentDictionary := oldComponentDictionary species new				]		].	components := basicComponents collect: 			[: aModel | | view |				(( view := oldComponentDictionary at: aModel ifAbsent: [ nil ]) notNil and: [ self reuseView: view forModel: aModel ]) 					ifFalse: 					[	view notNil 							ifTrue: [ view releaseWithoutInvalidation ].						" choose a proper view class and create an instance "						view := self transactionManager withoutDependenciesDo: [ self createViewForModel: aModel ].						oldComponentDictionary at: aModel put: view					].				view			].	oldComponentDictionary size &gt; components size 		ifTrue: 		[	removedModels := oldComponentDictionary keys - basicComponents .			oldViews := Set new: removedModels size.			removedModels do: 				[: obsoleteModel | 					oldViews add: ( oldComponentDictionary removeKey: obsoleteModel )				].			activeTransaction notNil 				ifTrue: [ activeTransaction addPostViewUpdateBlock: [ oldViews do: [: oldView | oldView releaseWithoutInvalidation ]]]				ifFalse: [ oldViews do: [: oldView | oldView releaseWithoutInvalidation ]]		].	^ components asOrderedCollection</body><body package="COASTViews">composeSelectedComponents	| selectedComponents sc |	selectedComponents := "List -- I think it should be a O.C. (ps, 25.9.98)" OrderedCollection new.	self components do: [ :component |		(sc := component selectedComponents) notNil			ifTrue: [ selectedComponents addAll: sc ]].	^ selectedComponents</body><body package="COASTViews">computePreferredBounds	^ Screen default bounds</body><body package="COASTViews">reuseView: aView forModel: aModel	^ aView  mayBeReused</body><body package="COASTViews">width	| width components |	(components := self components) notNil		ifTrue: [ components do: [ :c |			width isNil				ifTrue: [ width := c width ]				ifFalse: [ width := width max: c width ]]].	^ width notNil		ifTrue: [ width ]		ifFalse: [ 0 ].</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>controller accessing</category><body package="COASTViews">defaultControllerClass	^CoastNoController</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>events</category><body package="COASTViews">dispatchEventFromComponent: event	self container dispatchEventFromComponent: event</body><body package="COASTViews">handlerForMouseEvent: aMouseEvent 	"The receiver is in a control hierarchy and the container is asking 	for an object that wants control. If no control is desired then the 	receiver answers nil. If control is wanted then the receiver answers the 	control object."	| obj |	Object errorSignal handle: 			[:ex | 			Transcript 				show: 'error in ' , self class printString , '&gt;&gt;handlerForMouseEvent:'.			ex return]		do: 			[self components reverseDo: 					[:c | 					(obj := c handlerForMouseEvent: aMouseEvent) notNil ifTrue: [^obj]].			(obj := super handlerForMouseEvent: aMouseEvent) notNil 				ifTrue: [^obj]].	^nil</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>broadcast</category><body package="COASTViews">downcastEvent: aKey with: aParameter from: anInitiator	super downcastEvent: aKey with: aParameter from: anInitiator.	self components reverseDo: [ :component | component downcastEvent: aKey with: aParameter from: anInitiator ].</body><body package="COASTViews">downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator 	self components reverseDo: [ :component |		(component downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator)			ifTrue: [ ^ true ] ].	^ super downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>hit detection</category><body package="COASTViews">hitDetect: aPoint	"Answer a component that contains point aPoint or nil."	self components reverseDo: [ :c |		(c containsPoint: aPoint)			ifTrue: [^c]].	^nil</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>initialize-release</category><body package="COASTViews">initialize	super initialize.	oldComponentDictionary := IdentityDictionary new.</body><body package="COASTViews">newGraphicsDevice: aGraphicsDevice 	oldComponentDictionary := oldComponentDictionary species new.	super newGraphicsDevice: aGraphicsDevice.</body><body package="COASTViews">release	oldComponentDictionary do: [: component | component == nil ifFalse: [ component releaseWithoutInvalidation ]].	"self components do: [ :aView | aView releaseWithoutInvalidation ]." "do not compute components to release them"	super release.</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>focus accessing</category><body package="COASTViews">passFocusDownWithEvent: aCharEvent fromView: aView	| index upView compSize |	index := self components indexOf: aView ifAbsent: [ ^nil ].	compSize := self components size.	(compSize &gt; 1 and: [ index &lt; compSize ]) ifTrue:	[		upView := self components at: index + 1.		upView takeFocusWithEvent: aCharEvent.	].</body><body package="COASTViews">passFocusUpWithEvent: aCharEvent fromView: aView	| index upView |	index := self components indexOf: aView ifAbsent: [ ^nil ].	index &gt; 1 ifTrue:	[		upView := self components at: index - 1.		upView takeFocusWithEvent: aCharEvent.	].</body></methods><methods><class-id>COAST.CoastCompositeView</class-id> <category>input management</category><body package="COASTViews">updateSpot: aSymbol 	"Forward this message to all components."	oldComponentDictionary isNil ifTrue: [ ^ self ].	"identityDictionary might contain nil"	oldComponentDictionary do: [: cmp | cmp isNil ifFalse: [ cmp updateSpot: aSymbol ]]</body></methods><methods><class-id>COAST.CoastCompositeView class</class-id> <category>slots</category><body package="COASTViews">componentsSlot	^ ( self slotComputedEagerBy: [: view | view composeComponents ])		onDifferencesRead: 			[: frame : added : removed | 				frame view changedComponents			];		yourself</body><body package="COASTViews">selectedComponentsSlot	^self slotComputedBy: [:view | view composeSelectedComponents].</body></methods><methods><class-id>COAST.WrapperView</class-id> <category>accessing</category><body package="COASTViews">component	^ self at: #component</body><body package="COASTViews">isSelected	^ self component isSelected</body><body package="COASTViews">selectedComponents	^ self component selectedComponents</body><body package="COASTViews">withoutWrappers	^self component isNil		ifTrue: [self]		ifFalse: [self component withoutWrappers]</body><body package="COASTViews">wrappedComponent	^ self component notNil		ifTrue: [ self component wrappedComponent ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.WrapperView</class-id> <category>composing</category><body package="COASTViews">composeComponent	| componentModel |	(componentView isNil or: [ (componentView withoutWrappers model ) ~~ ( self model withoutWrappers )])		ifTrue: [ " check if we still have a component. if not, the wrapper			will be isolated soon .... "			(componentModel := self model component) notNil				ifTrue: [ "no view has been created yet , or we have a new component "					componentView := self createViewForModel: componentModel ].			].	^ componentView</body><body package="COASTViews">computePreferredBounds	"Answer the component's bounds."	^self component preferredBounds</body></methods><methods><class-id>COAST.WrapperView</class-id> <category>displaying</category><body package="COASTViews">composeDisplayOn: aGraphicsContext	"Display the receiver's component on aGraphicsContext."	self component displayOn: aGraphicsContext.</body></methods><methods><class-id>COAST.WrapperView</class-id> <category>testing</category><body package="COASTViews">containsPoint: aPoint	"Answer whether aPoint lies within the receiver's display box."	^self component containsPoint: aPoint</body><body package="COASTViews">intersects: aRectangle	"Answer whether the receiver's display box intersects aRectangle."	^self component intersects: aRectangle</body></methods><methods><class-id>COAST.WrapperView</class-id> <category>controller accessing</category><body package="COASTViews">defaultControllerClass	^CoastNoController</body><body package="COASTViews">newControllerClassFor: aComponent	^ self container newControllerClassFor: aComponent</body></methods><methods><class-id>COAST.WrapperView</class-id> <category>broadcast</category><body package="COASTViews">downcastEvent: aKey with: aParameter from: anInitiator	"This is a message passed down the view structure to all subparts."	self component notNil		ifTrue: [self component downcastEvent: aKey with: aParameter from: anInitiator].	super downcastEvent: aKey with: aParameter from: anInitiator.</body><body package="COASTViews">downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator 	|  result component |	result := false.	(component := self component) isNil		ifFalse: [result := component			downcastLocalEvent: aKey			with: aParameter			at: aPoint			from: anInitiator].	^ result		ifTrue: [ true ]		ifFalse: [ super			downcastLocalEvent: aKey			with: aParameter			at: aPoint			from: anInitiator ].</body></methods><methods><class-id>COAST.WrapperView</class-id> <category>event driven</category><body package="COASTViews">forwardEvent: aMouseEvent	" by default, wrappers forward all events to their component "	^ true</body><body package="COASTViews">handlerForMouseEvent: aMouseEvent 	| handler |	^ ((self forwardEvent: aMouseEvent) and: [ (handler := self component handlerForMouseEvent: aMouseEvent) notNil ])		ifTrue: [ handler ]		ifFalse: [ super handlerForMouseEvent: aMouseEvent ].</body></methods><methods><class-id>COAST.WrapperView</class-id> <category>initialize-release</category><body package="COASTViews">initialize	super initialize.	componentView := nil</body><body package="COASTViews">release	componentView release.	super release.</body></methods><methods><class-id>COAST.WrapperView</class-id> <category>layout</category><body package="COASTViews">rectangleRelativeTo: containingBoundingBox	"Answer a rectangle for the receiver relative to the containingBoundingBox."	^self component rectangleRelativeTo: containingBoundingBox</body></methods><methods><class-id>COAST.WrapperView</class-id> <category>private</category><body package="COASTViews">compositionBoundsFor: aVisualPart 	^ container ifNil: [ aVisualPart preferredBounds ] ifNotNil: [: parent | parent compositionBoundsFor: self ]</body></methods><methods><class-id>COAST.WrapperView class</class-id> <category>slots</category><body package="COASTViews">componentSlot	^self slotComputedBy: [ :view | view composeComponent ].</body></methods><methods><class-id>COAST.CoastWidgetCompositeView</class-id> <category>accessing</category><body package="COASTViews">bounds: aRectangle	self transactionManager displayDo: [		self at: #widgetBounds set: (0@0 extent: aRectangle extent).	]</body><body package="COASTViews">widgetBounds	^ self at: #widgetBounds</body></methods><methods><class-id>COAST.CoastWidgetCompositeView</class-id> <category>composing</category><body package="COASTViews">computePreferredBounds	^ self widgetBounds</body></methods><methods><class-id>COAST.CoastWidgetCompositeView class</class-id> <category>slots</category><body package="COASTViews">widgetBoundsSlot	^self slotSingleValue defaultValue: (0@0 extent: 0@0)</body></methods><methods><class-id>COAST.BoundedCompositeView</class-id> <category>composing</category><body package="COASTViews">computePreferredBounds	| bounds components |	bounds := nil.	(components := self components) notNil		ifTrue: [ components do: [ :c |			bounds isNil				ifTrue: [ bounds := c bounds ]				ifFalse: [ bounds := bounds merge: c preferredBounds ]]].	^ bounds notNil		ifTrue: [ bounds ]		ifFalse: [ 0@0 extent: 0@0 ].</body></methods><methods><class-id>COAST.BorderView</class-id> <category>constants</category><body package="COASTViews">borderSize	^ 1@1</body></methods><methods><class-id>COAST.BorderView</class-id> <category>displaying</category><body package="COASTViews">composeDisplayOn: aGraphicsContext	self displayBorderOn: aGraphicsContext copy.	super composeDisplayOn: aGraphicsContext.</body><body package="COASTViews">displayBorderOn: aGraphicsContext	(self bounds insetBy: 1) displayStrokedOn: aGraphicsContext.</body></methods><methods><class-id>COAST.BorderView</class-id> <category>testing</category><body package="COASTViews">containsPoint: aPoint	"Answer whether aPoint lies within the receiver's display box."	^self bounds containsPoint: aPoint</body><body package="COASTViews">intersects: aRectangle	"Answer whether the receiver's display box intersects aRectangle."	^self bounds intersects: aRectangle</body></methods><methods><class-id>COAST.BorderView</class-id> <category>composing</category><body package="COASTViews">computePreferredBounds	^super computePreferredBounds expandedBy: self borderSize</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>visual properties</category><body package="COASTViews">backgroundColor	"Forward to the component"	^componentView == nil		ifTrue:	[super backgroundColor]		ifFalse:	[componentView backgroundColor]</body><body package="COASTViews">borderColor	"Forward to the component"	^componentView == nil		ifTrue:	[super borderColor]		ifFalse:	[componentView borderColor]</body><body package="COASTViews">foregroundColor	"Forward to the component"	^componentView == nil		ifTrue:	[super foregroundColor]		ifFalse:	[componentView foregroundColor]</body><body package="COASTViews">hiliteColor	"Forward to the component"	^componentView == nil		ifTrue:	[super hiliteColor]		ifFalse:	[componentView hiliteColor]</body><body package="COASTViews">inactiveBackgroundColor	"Forward to the component"	^componentView == nil		ifTrue:	[super inactiveBackgroundColor]		ifFalse:	[componentView inactiveBackgroundColor]</body><body package="COASTViews">inactiveForegroundColor	"Forward to the component"	^componentView == nil		ifTrue:	[super inactiveForegroundColor]		ifFalse:	[componentView inactiveForegroundColor]</body><body package="COASTViews">inactiveSelectionBackgroundColor	"Forward to the component"	^componentView == nil		ifTrue:	[super inactiveSelectionBackgroundColor]		ifFalse:	[componentView inactiveSelectionBackgroundColor]</body><body package="COASTViews">inactiveSelectionForegroundColor	"Forward to the component"	^componentView == nil		ifTrue:	[super inactiveSelectionForegroundColor]		ifFalse:	[componentView inactiveSelectionForegroundColor]</body><body package="COASTViews">primarySymbolicBackground	"Forward to the component."	^self component == nil		ifTrue:	[super primarySymbolicBackground]		ifFalse:	[self component primarySymbolicBackground]</body><body package="COASTViews">primarySymbolicForeground	"Forward to the component."	^self component == nil		ifTrue:	[super primarySymbolicForeground]		ifFalse:	[self component primarySymbolicForeground]</body><body package="COASTViews">selectionBackgroundColor	"Forward to the component"	^componentView == nil		ifTrue:	[super selectionBackgroundColor]		ifFalse:	[componentView selectionBackgroundColor]</body><body package="COASTViews">selectionForegroundColor	"Forward to the component"	^componentView == nil		ifTrue:	[super selectionForegroundColor]		ifFalse:	[componentView selectionForegroundColor]</body><body package="COASTViews">separatorColor	"Forward to the component"	^componentView == nil		ifTrue:	[super separatorColor]		ifFalse:	[componentView separatorColor]</body><body package="COASTViews">shadowColor	"Forward to the component"	^componentView == nil		ifTrue:	[super shadowColor]		ifFalse:	[componentView shadowColor]</body><body package="COASTViews">specificForegroundColor	"Forward to the component"	^componentView == nil		ifTrue:	[super specificForegroundColor]		ifFalse:	[componentView specificForegroundColor]</body><body package="COASTViews">traversalHiliteColor	"Forward to the component"	^componentView == nil		ifTrue:	[super traversalHiliteColor]		ifFalse:	[componentView traversalHiliteColor]</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>displaying</category><body package="COASTViews">bottomComponent	"drill down and answer the receiver's leaf component."	^self component bottomComponent</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>bounds accessing</category><body package="COASTViews">bounds: newBounds	"Set the components bounds based on newBounds extent."	self at: #internalBounds set: newBounds.	self setComponentBoundsTo: newBounds</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>accessing</category><body package="COASTViews">componentView	^componentView</body><body package="COASTViews">componentView: aNonCoastView	| oldContainer |	componentView := aNonCoastView.	oldContainer := componentView container.	oldContainer isNil		ifFalse: 			[(oldContainer respondsTo: #component:)				ifTrue: [oldContainer component: self].			self container: oldContainer].	componentView container: self</body><body package="COASTViews">wrappedComponent	^ self component notNil		ifTrue: [ self component wrappedComponent ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>private</category><body package="COASTViews">composeAndInvalidate	self isOpen		ifTrue: [self bounds: self bounds.				self invalidate]</body><body package="COASTViews">setComponent: aVisualComponent	"Set aVisualComponent to be the the receiver's component.	Set aVisualComponentView's container to be the receiver."	componentView == nil		ifFalse: [componentView removeDependent: self].	componentView := aVisualComponent.	componentView == nil ifFalse: [componentView container: self]</body><body package="COASTViews">setComponentBoundsTo: newBounds	self component bounds: newBounds</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>composing</category><body package="COASTViews">composeComponent	| |	^componentView</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>testing</category><body package="COASTViews">hasBorder	" Answer whether the receiver has a border.	Plain wrappers do not have a border. "	^false</body><body package="COASTViews">hasWidget	"answer whether the receiver has a widget."	^false</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>initialize-release</category><body package="COASTViews">newGraphicsDevice: aGraphicsDevice	"Forward to the receiver's component."	self component newGraphicsDevice: aGraphicsDevice.	super newGraphicsDevice: aGraphicsDevice</body><body package="COASTViews">release	"Forward release to the receiver's component."	componentView removeDependent: self.	componentView release.	super release.</body><body package="COASTViews">scrollOffsetHolder: aValueHolder 	"Accept notification that we will be scrolled, and cache the value holder 	that contains the offset, if desired"	self component scrollOffsetHolder: aValueHolder</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>ET-Internal</category><body package="COASTViews">newLabel: newLabel	"Set the receivers label."	self component isNil ifFalse: [		self component newLabel: newLabel]</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>control</category><body package="COASTViews">quietlySetComponent: aVisualComponent	"Set the receiver's component to be aVisualComponent. Do not propagate damage.	Rely on invalidation from container tree."	componentView == nil ifFalse: [componentView container: nil].	self setComponent: aVisualComponent</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>layout</category><body package="COASTViews">rectangleRelativeTo: containingBoundingBox	"Answer a rectangle for the receiver relative to the containingBoundingBox."	^self component rectangleRelativeTo: containingBoundingBox</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>visual properties-overriding</category><body package="COASTViews">secondarySymbolicBackground	"Forward to the component."	^componentView == nil		ifTrue:	[super secondarySymbolicBackground]		ifFalse:	[componentView secondarySymbolicBackground]</body><body package="COASTViews">secondarySymbolicForeground	"Forward to the component."	^componentView == nil		ifTrue:	[super secondarySymbolicForeground]		ifFalse:	[componentView secondarySymbolicForeground]</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>updating</category><body package="COASTViews">update: anAspect with: anArgument from: anObject	"Since the receiver's component may not be a subclass of VisualPart,	it is possible that dependency is being used to invalidate rectangles	or to notify the hierarchy of a change in bounds or preferred bounds ."	anObject == self component		ifTrue:			[anAspect == #invalidate					ifTrue: [^self								invalidateRectangle: anArgument								repairNow: true								forComponent: self component].			anAspect == #preferredBounds					ifTrue: [^self								changedPreferredBounds: anArgument								forComponent: self component].			anAspect == #bounds					ifTrue: [^self								changedBounds: anArgument								forComponent: self component]].</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>input management</category><body package="COASTViews">updateSpot: type	"Forward this message to my component."	componentView updateSpot: type</body></methods><methods><class-id>COAST.NonCoastViewWrapper</class-id> <category>computing</category><body package="COASTViews">composeDisplayOn: aGraphicsContext	self computePreferredBounds.	^self component displayOn: aGraphicsContext</body><body package="COASTViews">computePreferredBounds	^ self component preferredBounds</body></methods><methods><class-id>COAST.NonCoastViewWrapper class</class-id> <category>slots</category><body package="COASTViews">internalBoundsSlot	^self slotSingleValue</body></methods><methods><class-id>COAST.NonCoastViewWrapper class</class-id> <category>instance creation</category><body package="COASTViews">on: aNonCoastView	| theInst |	theInst := self new.	theInst componentView: aNonCoastView.	^theInst</body></methods><methods><class-id>COAST.OrderedCompositeView</class-id> <category>private</category><body package="COASTViews">componentTranslations	^ self at: #componentTranslations</body><body package="COASTViews">createWrapperFor: aView	^ ComposedTranslatingWrapper		in: self		on: aView		translationComposedBy: self</body></methods><methods><class-id>COAST.OrderedCompositeView</class-id> <category>accessing</category><body package="COASTViews">height	^ self bounds height</body><body package="COASTViews">translationFor: aComponent	| translation trs |	trs := self at: #componentTranslations.	translation := trs isNil ifTrue: [ nil ] ifFalse: [ trs at: aComponent ifAbsent: [ nil ] ].	 ^ translation notNil		ifTrue: [ translation ]		ifFalse: [ 0@0 ]</body><body package="COASTViews">width	^ self bounds width</body></methods><methods><class-id>COAST.OrderedCompositeView</class-id> <category>composing</category><body package="COASTViews">composeBoundsFor: aComponent index: componentIndex previousComponentBounds: aRectangle 	" Returns the bounds of the component "	^ aComponent preferredBounds</body><body package="COASTViews">composeTranslations	| translations previousComponentBounds componentIndex |	translations := IdentityDictionary new.	previousComponentBounds := Rectangle zero.	componentIndex := 1.	self components do: 		[: wrappedComponent | | component componentBounds |			component := wrappedComponent component.			componentBounds := self composeBoundsFor: component index: componentIndex previousComponentBounds: previousComponentBounds.			translations add: component -&gt; componentBounds origin.			previousComponentBounds := componentBounds.			componentIndex := componentIndex + 1.		].	^ translations</body><body package="COASTViews">computePreferredBounds	| extent |	extent := 0 @ 0.	self componentTranslations keysAndValuesDo: [: component : translation | extent := extent max: translation + component preferredBounds extent ].	^ 0 @ 0 extent: extent</body></methods><methods><class-id>COAST.OrderedCompositeView class</class-id> <category>slot description</category><body package="COASTViews">componentTranslationsSlot	^ self slotComputedBy: #composeTranslations</body></methods><methods><class-id>COAST.ListView</class-id> <category>accessing</category><body package="COASTViews">alignment	^self at: #alignment</body><body package="COASTViews">alignment: aSymbol	self at: #alignment set: aSymbol</body><body package="COASTViews">axis	^ self alignment = #horizontal		ifTrue: [ 1@ 0 ]		ifFalse: [ 0@1 ]</body></methods><methods><class-id>COAST.ListView class</class-id> <category>slots</category><body package="COASTViews">alignmentSlot	^self slotSingleValue		defaultValue: #vertical</body></methods><methods><class-id>COAST.ListView class</class-id> <category>instance creation</category><body package="COASTViews">model: aModel alignment: aSymbol	^(self model: aModel) alignment: aSymbol; yourself</body></methods><methods><class-id>COAST.MatrixView</class-id> <category>slot accessing</category><body package="COASTViews">cellHeight	^ self at: #cellHeight</body><body package="COASTViews">cellHeight: aNumber 	self at: #cellHeight set: aNumber.</body><body package="COASTViews">cellWidth	^ self at: #cellWidth</body><body package="COASTViews">cellWidth: aNumber 	self at: #cellWidth set: aNumber.</body><body package="COASTViews">maxRowsColumns	"Maximum number of rows or columns depending on the primary direction"	"a slot value of 0 means: auto adjust width"	| mrc ob |	mrc := self at: #maxRowsColumns.	mrc = 0 ifFalse: [ ^mrc ].	ob := self at: #outerBounds .	^ob notNil		ifTrue: [ (( ob extent x ) // (self cellWidth)) max: 1 ]		ifFalse: [ 1 ]</body><body package="COASTViews">maxRowsColumns: aNumber 	"Maximal number of rows or columns depending on the primary direction"	self at: #maxRowsColumns set: aNumber.</body><body package="COASTViews">primaryDirection	^ self at: #primaryDirection</body><body package="COASTViews">primaryDirection: aDirection 	"horizontal or vertical, depending on the direction the matrix should be filled"	^ self at: #primaryDirection set: aDirection</body></methods><methods><class-id>COAST.MatrixView</class-id> <category>composing</category><body package="COASTViews">composeBoundsFor: aComponent index: componentIndex previousComponentBounds: aRectangle 	^ self shouldNotImplement</body><body package="COASTViews">composeTranslations	| translations maxRC direction currentPosition translation component |	translations := IdentityDictionary new.	maxRC := self maxRowsColumns.	direction := self primaryDirection.	currentPosition := 0 @ 0.	"	self components inspect."	self components keysAndValuesDo: 		[: index : wrappedcomponent |			component := wrappedcomponent component.			"Position means in this context ( 'position in primary direction'@'position in secondary direction')."			translation := ( direction = #horizontal 					ifTrue: [ currentPosition ]					ifFalse: [ currentPosition transpose ]) * ( self cellWidth @ self cellHeight ).			translations add: component -&gt; translation.			currentPosition := currentPosition + ( 1 @ 0 ).			currentPosition x = maxRC ifTrue: [ currentPosition := 0 @ ( currentPosition y + 1 )]		].	^ translations</body></methods><methods><class-id>COAST.MatrixView</class-id> <category>accessing</category><body package="COASTViews">bounds: newBounds 	super bounds: newBounds.	self transactionManager bestIndependentDisplayDo: [ self at: #outerBounds set: newBounds ].</body></methods><methods><class-id>COAST.MatrixView class</class-id> <category>slots</category><body package="COASTViews">cellHeightSlot	^ self slotSingleValue defaultValue: 160</body><body package="COASTViews">cellWidthSlot	^ self slotSingleValue defaultValue: 160</body><body package="COASTViews">maxRowsColumnsSlot	^ self slotSingleValue defaultValue: 0</body><body package="COASTViews">outerBoundsSlot	^ self slotSingleValue</body><body package="COASTViews">primaryDirectionSlot	^ self slotSingleValue defaultValue: #horizontal</body></methods><methods><class-id>COAST.MatrixView class</class-id> <category>instance creation</category><body package="COASTViews">direction: dir rowCols: rowCols cellSize: size 	^ ( self new )		primaryDirection: dir;		maxRowsColumns: rowCols;		cellWidth: size;		cellHeight: size;		yourself</body></methods><methods><class-id>COAST.AlignedCompositeView</class-id> <category>accessing</category><body package="COASTViews">alignment	^ self model alignment</body></methods><methods><class-id>COAST.AlignedCompositeView</class-id> <category>composing</category><body package="COASTViews">composeBoundsFor: aComponent index: componentIndex previousComponentBounds: aRectangle 	| translation |	translation := self composeTranslationFor: aComponent previousComponentBounds: aRectangle.	^ translation extent: aComponent preferredBounds extent</body><body package="COASTViews">composeMaximumExtent	| extent al le |	al := self alignment.	extent := 0 @ 0.	(al = #verticalCentered or: [ al = #horizontalCentered ]) 		ifTrue: 		[( le := self model listExtent ) notNil 				ifTrue: [ extent := le ]		].	self components do: 		[: translatingWrapper |			extent := extent max: translatingWrapper component bounds extent.		].	^ extent</body><body package="COASTViews">composeTranslationFor: aComponent previousComponentBounds: aRectangle	| prevWidth prevHeight alignment  previousTranslation|	prevWidth := aRectangle width.	prevHeight:= aRectangle height.	previousTranslation := aRectangle origin.	alignment := self alignment.	" evil case construct "	(alignment = #top) ifTrue: [ ^ (previousTranslation x + prevWidth)@0 ].	(alignment = #left) ifTrue: [ ^ 0@(previousTranslation y + prevHeight)].	cachedMaximumExtent := self maximumExtent.	(alignment = #bottom) ifTrue: [ ^ (previousTranslation x + prevWidth)@(cachedMaximumExtent y - aComponent bounds height) ].	(alignment = #right) ifTrue: [ ^ (cachedMaximumExtent x - aComponent bounds width)@(previousTranslation y + prevHeight)].	(alignment = #horizontalCentered) ifTrue: [ ^ (previousTranslation x + prevWidth)@((cachedMaximumExtent y - aComponent bounds height) //2) ].	^ ((cachedMaximumExtent x - aComponent bounds width) //2)@(previousTranslation y + prevHeight).</body></methods><methods><class-id>COAST.AlignedCompositeView</class-id> <category>slot accessing</category><body package="COASTViews">maximumExtent	^ self at: #maximumExtent</body></methods><methods><class-id>COAST.AlignedCompositeView class</class-id> <category>slots</category><body package="COASTViews">maximumExtentSlot	^self slotComputedBy: #composeMaximumExtent.</body></methods><methods><class-id>COAST.CoastSelectionInList</class-id> <category>private</category><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock 	^ self accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock observeDisplayString: true</body><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock application: aCoastLocalApplicationModel	self accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock</body><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock observeDisplayString: observeDisplayString 	" observeDisplayString is rather questionable and should be obsoleted as soon as possible "	^ observeDisplayString 		ifTrue: 		[	self 				privateAccessListBlock: 				[ | val |					val := readListBlock value.					"trick to enhance display updating"					val do: [: e | e displayString ].						val				]				assignListBlock: writeListBlock				accessSelectionBlock: readSelectionBlock				assignSelectionBlock: writeSelectionBlock		]		ifFalse: 		[	self 				privateAccessListBlock: readListBlock				assignListBlock: writeListBlock				accessSelectionBlock: readSelectionBlock				assignSelectionBlock: writeSelectionBlock		]</body><body package="COASTViews">privateAccessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock	| selectionAdaptor listAdaptor |	self listHolder:		(listAdaptor := CoastListAspectAdaptor			accessBlock:  readListBlock			assignBlock: writeListBlock).	self selectionIndexHolder:		(selectionAdaptor := CoastListSelectionAspectAdaptor			accessBlock: readSelectionBlock			assignBlock: writeSelectionBlock).	listAdaptor selectionAdaptor: selectionAdaptor.</body><body package="COASTViews">silentAccessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock 	^ self privateAccessListBlock: readListBlock  		assignListBlock: writeListBlock		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock</body><body package="COASTViews">silentAccessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock application: aCoastLocalApplicationModel	^ self silentAccessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock</body></methods><methods><class-id>COAST.CoastSelectionInList</class-id> <category>testing</category><body package="COASTViews">hasDependents	^dependents notNil and: [ dependents isEmpty not ]</body></methods><methods><class-id>COAST.CoastSelectionInList</class-id> <category>accessing</category><body package="COASTViews">aspectAdaptorFinishObservation	" stop observerving "	listHolder aspectAdaptorFinishObservation.	selectionIndexHolder aspectAdaptorFinishObservation.</body><body package="COASTViews">listHolder: aValueModel	"Set the listHolder - do not register as dependent"	listHolder := aValueModel.</body><body package="COASTViews">selectionIndexHolder: aValueModel	"Set the selectionIndexHolder - do not register as dependent"	selectionIndexHolder := aValueModel.</body></methods><methods><class-id>COAST.CoastSelectionInList</class-id> <category>selection in list</category><body package="COASTViews">selection	"Answer the receiver's selection"	^(selectionIndexHolder value) &gt; listHolder value size 		ifTrue: [nil]		ifFalse: [super selection]</body></methods><methods><class-id>COAST.CoastSelectionInList</class-id> <category>updating</category><body package="COASTViews">update: anAspect with: aParameter from: anObject</body></methods><methods><class-id>COAST.CoastSelectionInList class</class-id> <category>instance creation</category><body package="COASTViews">accessListBlock: readListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock 	^ (self new)		accessListBlock: readListBlock		assignListBlock: [:dummy ]		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock;		yourself</body><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock	^ (self new)		accessListBlock: readListBlock		assignListBlock: writeListBlock		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock;		yourself</body><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock observeDisplayString: observeDisplayString 	^ ( self new )		accessListBlock: readListBlock			assignListBlock: writeListBlock			accessSelectionBlock: readSelectionBlock			assignSelectionBlock: writeSelectionBlock			observeDisplayString: observeDisplayString;		yourself</body><body package="COASTViews">adapt: aFrame accessListBlock: readListBlock selectionSlot: slotName	^ (self new)		accessListBlock: readListBlock		assignListBlock: [:dummy ]		accessSelectionBlock: [ aFrame at: slotName ]		assignSelectionBlock: [ :sel | aFrame at: slotName set: sel ];		yourself</body><body package="COASTViews">adapt: somethingWithSlots listSlot: listSlotSymbol selectionSlot: selectionSlotSymbol 	^ self 		accessListBlock: [ somethingWithSlots at: listSlotSymbol ]		assignListBlock: [ :list | somethingWithSlots at: listSlotSymbol set: list ]		accessSelectionBlock: [ somethingWithSlots at: selectionSlotSymbol ]		assignSelectionBlock: [ :sel | somethingWithSlots at: selectionSlotSymbol set: sel ]</body><body package="COASTViews">listBlock: readListBlock	" real selection, not a bloody selection index "	| newInst |	newInst := self listBlock: readListBlock getSelectionBlock: [] setSelectionBlock: [ : sel | ].	newInst selectionIndexHolder: 0 asValue.	^ newInst</body><body package="COASTViews">listBlock: readListBlock getSelectionBlock: readSelectionBlock setSelectionBlock: writeSelectionBlock 	" real selection, not a bloody selection index "	| inst |	inst := self new.	inst		accessListBlock: readListBlock		assignListBlock: [ :dummy ]		accessSelectionBlock: [ inst list indexOf: readSelectionBlock value ]		assignSelectionBlock: [ : i | writeSelectionBlock value: (i &gt; 0 ifTrue: [ inst list at: i] ifFalse: [ nil]) ].	^ inst</body><body package="COASTViews">listBlock: readListBlock getSelectionBlock: readSelectionBlock setSelectionBlock: writeSelectionBlock observeDisplayString: observeDisplayString 	" real selection, not a bloody selection index "	| inst |	inst := self new.	inst		accessListBlock: readListBlock		assignListBlock: [ :dummy ]		accessSelectionBlock: [ inst list indexOf: readSelectionBlock value ]		assignSelectionBlock: [ : i | writeSelectionBlock value: (i &gt; 0 ifTrue: [ inst list at: i] ifFalse: [ nil]) ]		observeDisplayString: observeDisplayString .	^ inst</body><body package="COASTViews">silentAccessListBlock: readListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock 	^ ( self new )		silentAccessListBlock: readListBlock assignListBlock: [: dummy | ] accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock;		yourself</body><body package="COASTViews">silentAccessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock 	^ ( self new )		silentAccessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock;		yourself</body></methods><methods><class-id>COAST.CoastSelectionInList class</class-id> <category>instance creation - compatibility</category><body package="COASTViews">accessListBlock: readListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock application: aCoastLocalApplicationModel	^ (self new)		accessListBlock: readListBlock		assignListBlock: [:dummy ]		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock		application: aCoastLocalApplicationModel;		yourself</body><body package="COASTViews">accessListBlock: readListBlock assignListBlock: writeListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock application: aCoastLocalApplicationModel	^ (self new)		accessListBlock: readListBlock		assignListBlock: writeListBlock		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock		application: aCoastLocalApplicationModel;		yourself</body><body package="COASTViews">adapt: somethingWithSlots listSlot: listSlotSymbol application: aCoastLocalApplicationModel	| selectionHolder |	selectionHolder := 0 asValue.	^ self 		accessListBlock: [ somethingWithSlots at: listSlotSymbol ]		assignListBlock: [ :list | somethingWithSlots at: listSlotSymbol set: list ]		accessSelectionBlock: [ selectionHolder value ]		assignSelectionBlock: [ :sel | selectionHolder value: sel ]		application: aCoastLocalApplicationModel</body><body package="COASTViews">adapt: somethingWithSlots listSlot: listSlotSymbol selectionSlot: selectionSlotSymbol application: aCoastLocalApplicationModel	^ self 		accessListBlock: [ somethingWithSlots at: listSlotSymbol ]		assignListBlock: [ :list | somethingWithSlots at: listSlotSymbol set: list ]		accessSelectionBlock: [ somethingWithSlots at: selectionSlotSymbol ]		assignSelectionBlock: [ :sel | somethingWithSlots at: selectionSlotSymbol set: sel ]		application: aCoastLocalApplicationModel</body><body package="COASTViews">listSlot: listSlotSymbol application: aCoastLocalApplicationModel	^ self		adapt:aCoastLocalApplicationModel		listSlot: listSlotSymbol		application: aCoastLocalApplicationModel</body><body package="COASTViews">listSlot: listSlotSymbol selectionSlot: selectionSlotSymbol application: aCoastLocalApplicationModel	^ self		adapt:aCoastLocalApplicationModel		listSlot: listSlotSymbol		selectionSlot: selectionSlotSymbol 		application: aCoastLocalApplicationModel</body><body package="COASTViews">silentAccessListBlock: readListBlock accessSelectionBlock: readSelectionBlock assignSelectionBlock: writeSelectionBlock application: aCoastLocalApplicationModel	^ (self new)		silentAccessListBlock: readListBlock		assignListBlock: [:dummy ]		accessSelectionBlock: readSelectionBlock		assignSelectionBlock: writeSelectionBlock		application: aCoastLocalApplicationModel;		yourself</body></methods><methods><class-id>COAST.NonmodalNotifier</class-id> <category>aspects</category><body package="COASTViews">message	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^message isNil		ifTrue:			[message := String new asValue]		ifFalse:			[message]</body><body package="COASTViews">title	^title ifNil: ['']</body><body package="COASTViews">title: string	^title := string</body></methods><methods><class-id>COAST.NonmodalNotifier</class-id> <category>bostbuild</category><body package="COASTViews">postBuildWith: aBuilder	builder window label: self title.	super postBuildWith: aBuilder</body></methods><methods><class-id>COAST.NonmodalNotifier class</class-id> <category>As yet unclassified</category><body package="COASTViews">warn: message	| newInst |	newInst := self new.	newInst message value: message.	self openOn: newInst</body></methods><methods><class-id>COAST.NonmodalNotifier class</class-id> <category>open</category><body package="COASTViews">warn: message title: title	| newInst |	newInst := self new.	newInst message value: message.	newInst title: title.	self openOn: newInst</body></methods><methods><class-id>COAST.CoastSubjectAdaptor</class-id> <category>accessing</category><body package="COASTViews">blockAdaptor	^ self at: #blockAdaptor.</body><body package="COASTViews">blockAdaptor: aCoastBlockAdaptor	self at: #blockAdaptor set: aCoastBlockAdaptor.</body><body package="COASTViews">subject	^ self at: #subject.</body><body package="COASTViews">subject: anObject	self at: #subject set: anObject.</body><body package="COASTViews">value	^ self at: #value</body></methods><methods><class-id>COAST.CoastSubjectAdaptor</class-id> <category>computing</category><body package="COASTViews">computeValue	| val |	val := self blockAdaptor computeValueForSubject: self subject.	self blockAdaptor notifyDependentsAfterComputation: nil.	^ val</body></methods><methods><class-id>COAST.CoastSubjectAdaptor</class-id> <category>initialize-release</category><body package="COASTViews">aspectAdaptorFinishObservation	" stop observerving "	| myValueSlot |	( myValueSlot := self basicSlotNamed: #value ) notNil ifTrue: [ myValueSlot finishObservation ].</body></methods><methods><class-id>COAST.CoastSubjectAdaptor class</class-id> <category>slots</category><body package="COASTViews">blockAdaptorSlot	^ self slotSingleValue		range: CoastBlockAdaptor;		yourself</body><body package="COASTViews">subjectSlot	^ self slotSingleValue</body><body package="COASTViews">valueSlot	^ ( self slotComputedEagerBy: #computeValue)		computeInSequence: false;		yourself</body></methods><methods><class-id>COAST.CoastSubjectAdaptor class</class-id> <category>instance creation</category><body package="COASTViews">subject: aSubject blockAdaptor: blockAdaptor 	^ ( self new ) subject: aSubject;		blockAdaptor: blockAdaptor;		yourself</body></methods><methods><class-id>COAST.ViewState</class-id> <category>inspecting</category><body package="COASTViews">classLabel	^ view isNil		ifTrue: [ 'view state without view' ]		ifFalse: [ view class name ]</body></methods><methods><class-id>COAST.ViewState</class-id> <category>copying</category><body package="COASTViews">deepCopyForView: aView	"use deepCopy"	| theCopy |	theCopy := self coastSpawn.	theCopy makeLocal.	theCopy initializeVirtualSlots.	theCopy view: aView.	theCopy initializeAfterDeepCopy.	^theCopy</body></methods><methods><class-id>COAST.ViewState</class-id> <category>accessing</category><body package="COASTViews">deactivate	" do not compute or observe anymore "	self finishObservation.	self release</body><body package="COASTViews">demonPerformer	^view</body><body package="COASTViews">prototype	^prototype</body><body package="COASTViews">prototype: aCatCSCell	prototype := aCatCSCell</body><body package="COASTViews">view	^ view</body><body package="COASTViews">view: aView	view := aView</body></methods><methods><class-id>COAST.ViewState</class-id> <category>printing</category><body package="COASTViews">printOn: stream 	stream nextPutAll: 'ViewState of: '.	view printOn: stream.	stream space.	view hash printOn: stream</body></methods><methods><class-id>COAST.ViewState</class-id> <category>testing</category><body package="COASTViews">allowsSlotComputation	"Does it make sense to recalculate any virtual slot of this frame?"	^view notNil and: [view allowsSlotComputation and: [ self isActive ]]</body></methods><methods><class-id>COAST.ViewState</class-id> <category>private</category><body package="COASTViews">isActive	" if false, then no computations/observations etc. should be made any more "	^ isActive ifNil: [ isActive := true ]</body></methods><methods><class-id>COAST.ViewState</class-id> <category>initialize-release</category><body package="COASTViews">release	isActive := false.	self finishObservation.	super release.</body></methods><methods><class-id>COAST.CoastSequenceViewSpec</class-id> <category>private</category><body package="COASTViews">defaultModel	^self multipleSelections		ifTrue: [ CoastMultiSelectionInList new]		ifFalse: [ CoastSelectionInList new]</body><body package="COASTViews">dispatchTo: policy with: builder		policy coastListView: self into: builder</body></methods><methods><class-id>COAST.CoastSequenceViewSpec</class-id> <category>accessing</category><body package="COASTViews">avoidScrolling	^avoidScrolling == nil		ifTrue: [false]		ifFalse: [avoidScrolling]</body><body package="COASTViews">avoidScrolling: aBoolean 	avoidScrolling := aBoolean.</body></methods><methods><class-id>COAST.CoastSequenceViewSpec</class-id> <category>initialize-release</category><body package="COASTViews">initialize	super initialize.	avoidScrolling := false.</body></methods><methods><class-id>COAST.CoastSequenceViewSpec class</class-id> <category>private-interface building</category><body package="COASTViews">componentName	"Identification of component"	^'COAST List'</body></methods><methods><class-id>COAST.TransactionWrapper</class-id> <category>displaying</category><body package="COASTViews">composeDisplayOn: aGraphicsContext	self component displayOn: aGraphicsContext.</body><body package="COASTViews">displayOn: aGraphicsContext 	"Display the receiver's components. 	Make sure that a display transaction is running.	Avoid blocking "	| activeTransaction |	( self transactionManager notNil and: [ self isOpen ]) ifFalse: [ ^ self ].	[	activeTransaction := transactionManager activeTransactionOfCurrentProcess.		( activeTransaction isNil or: [ activeTransaction mayDisplay ]) 			ifTrue: [ transactionManager displayDo: [ self composeDisplayOn: aGraphicsContext ]]			ifFalse: 			[					[						[ self invalidateRectangle: self bounds repairNow: false ] on: Error						do: [: ex | CoastLog logWarning: 'Could not invalidate display: ' , ex description ]				] fork			]	] on: Error do: [: ex | CoastLog logWarning: 'Could not display: ' , ex description ].</body></methods><methods><class-id>COAST.TransactionWrapper</class-id> <category>events</category><body package="COASTViews">dispatchEventFromComponent: event	" do nothing "</body></methods><methods><class-id>COAST.TransactionWrapper</class-id> <category>accessing</category><body package="COASTViews">handlerForMouseEvent: aMouseEvent 	| activeTransaction |	aMouseEvent key = #coastDisplay ifTrue: 		[	self invalidate.			^ nil		].	activeTransaction := self transactionManager ifNotNil: [: transaction | transaction activeTransactionOfCurrentProcess ].	( activeTransaction isNil or: [ activeTransaction mayDisplay ]) ifFalse: [ ^ nil ].	^ self transactionManager ifNil: [ super handlerForMouseEvent: aMouseEvent ]		ifNotNil: [: tm | tm bestIndependentDisplayDo: [ super handlerForMouseEvent: aMouseEvent ]]</body><body package="COASTViews">layout	^ self component layout</body><body package="COASTViews">layout: aLayout	^ self component layout: aLayout</body><body package="COASTViews">transactionManager: aTM	transactionManager := aTM</body></methods><methods><class-id>COAST.TransactionWrapper</class-id> <category>controller accessing</category><body package="COASTViews">newControllerClassFor: aComponent	^ aComponent defaultControllerClass</body></methods><methods><class-id>COAST.TransactionWrapper</class-id> <category>private</category><body package="COASTViews">transactionManager	transactionManager isNil ifTrue: [ transactionManager := self component transactionManager ].	^transactionManager</body></methods><methods><class-id>COAST.TransactionWrapper</class-id> <category>bounds accessing</category><body package="COASTViews">bounds: newBounds 	"Set the components bounds based on newBounds extent."	| tM |	( tM := self transactionManager ) notNil ifTrue: [ tM bestIndependentDisplayDo: [ super bounds: newBounds ]]</body></methods><methods><class-id>COAST.TransactionWrapper</class-id> <category>broadcast</category><body package="COASTViews">downcastEvent: aKey with: aParameter from: anInitiator	"This is a message passed down the view structure to all subparts."	| activeTransaction |	(aKey = #activate or: [ aKey = #deactivate or: [ aKey = #mouseEnter or: [ aKey = #mouseExit ] ] ]) ifTrue:	[		activeTransaction := self transactionManager ifNotNil: [ : transaction | transaction activeTransactionOfCurrentProcess ].		( activeTransaction isNil or: [ activeTransaction mayDisplay ]) ifFalse: [ ^ nil ].	].	super downcastEvent: aKey with: aParameter from: anInitiator</body></methods><methods><class-id>COAST.CoastSimpleLocalApplicationModel</class-id> <category>initialize-release</category><body package="COASTViews">closeLocalOnly	sharedApplicationModel notNil		ifTrue: [ sharedApplicationModel localApplicationModel: nil ].	sharedApplicationModel := nil.		^ self closeRequest.</body><body package="COASTViews">closeRequest	" do nothing by default "</body><body package="COASTViews">initialize	" no default behaviour "</body><body package="COASTViews">openOnSharedApplication: aSharedApplicationModel	sharedApplicationModel := aSharedApplicationModel</body></methods><methods><class-id>COAST.CoastSimpleLocalApplicationModel</class-id> <category>accessing</category><body package="COASTViews">sharedApplicationModel	^ sharedApplicationModel</body><body package="COASTViews">sharedApplicationModel: aSharedApplicationModel	sharedApplicationModel := aSharedApplicationModel</body></methods><methods><class-id>COAST.CoastSimpleLocalApplicationModel class</class-id> <category>interface opening</category><body package="COASTViews">openOnSharedApplication: aSharedApplicationModel	| newInst |	newInst := self new initialize.	newInst openOnSharedApplication: aSharedApplicationModel.	^ newInst</body></methods><methods><class-id>COAST.CoastDropSource</class-id> <category>query</category><body package="COASTViews">canBeDroppedOn: aView at: aPoint	^ self sourceObject canBeDroppedOn: aView at: aPoint</body></methods><methods><class-id>COAST.CoastDropSource</class-id> <category>action</category><body package="COASTViews">dropOn: aController withContext: aDragDropContext	self sourceObject dropOn: aController withContext: aDragDropContext</body></methods><methods><class-id>COAST.CoastDropSource</class-id> <category>accessing</category><body package="COASTViews">sourceObject	^ sourceObject</body><body package="COASTViews">sourceObject: something	" the givent object tells us if we can continue drag&amp;drop "	sourceObject := something</body></methods><methods><class-id>COAST.CoastDropSource class</class-id> <category>instance creation</category><body package="COASTViews">on: anObject	^ (self new)		sourceObject: anObject;		yourself.</body></methods><methods><class-id>COAST.CoastWidgetCompositeModel</class-id> <category>accessing</category><body package="COASTViews">addComponent: aCoastModel	self at: #components add: aCoastModel</body><body package="COASTViews">components	^ self at: #components</body><body package="COASTViews">removeComponent: aCoastModel	self at: #components remove: aCoastModel</body></methods><methods><class-id>COAST.CoastWidgetCompositeModel</class-id> <category>views</category><body package="COASTViews">defaultViewClass	^ CoastWidgetCompositeView</body></methods><methods><class-id>COAST.CoastWidgetCompositeModel class</class-id> <category>slots</category><body package="COASTViews">componentsSlot	^ self slotOfType: #orderedCollection</body></methods><methods><class-id>COAST.MultiSelectionSequenceViewAvoidScrolling</class-id> <category>updating</category><body package="COASTViews">updateModel	self sequence: model value.	targetIndex := self zeroIndex.	self invalidate.	self elementsInSequenceHaveChanged.	self changedPreferredBounds: nil.</body></methods><methods><class-id>COAST.VirtualAlignedListAdaptor</class-id> <category>slot accessing</category><body package="COASTViews">alignment	^self at: #alignment</body><body package="COASTViews">alignment: anAlignment	self at: #alignment set: anAlignment</body><body package="COASTViews">components	^ self at: #components</body><body package="COASTViews">listExtent	^ self at: #listExtent</body><body package="COASTViews">listExtent: extent	self at: #listExtent set: extent</body><body package="COASTViews">subject	^self at: #subject</body><body package="COASTViews">subject: subject 	self at: #subject set: subject</body></methods><methods><class-id>COAST.VirtualAlignedListAdaptor</class-id> <category>composing</category><body package="COASTViews">composeList	^ (self at: #listComputingBlock) value: self subject</body></methods><methods><class-id>COAST.VirtualAlignedListAdaptor</class-id> <category>defaults</category><body package="COASTViews">defaultViewClass	^ AlignedCompositeView</body><body package="COASTViews">viewClassForCompositeView	^self defaultViewClass</body></methods><methods><class-id>COAST.VirtualAlignedListAdaptor</class-id> <category>accessing</category><body package="COASTViews">listComputingBlock: aBlock	self at: #listComputingBlock set: aBlock</body></methods><methods><class-id>COAST.VirtualAlignedListAdaptor</class-id> <category>actions</category><body package="COASTViews">select: aModel 	self subject select: aModel</body></methods><methods><class-id>COAST.VirtualAlignedListAdaptor class</class-id> <category>slot description</category><body package="COASTViews">alignmentSlot	^self slotOfType: #singleValue.</body><body package="COASTViews">componentsSlot	^ self slotComputedEagerBy: [:frame | frame composeList ]</body><body package="COASTViews">listComputingBlockSlot	^self slotOfType: #singleValue.</body><body package="COASTViews">listExtentSlot	^self slotOfType: #singleValue.</body><body package="COASTViews">subjectSlot	^self slotOfType: #singleValue.</body></methods><methods><class-id>COAST.VirtualAlignedListAdaptor class</class-id> <category>instance creation</category><body package="COASTViews">subject: subject computingBlock: aListComposition 	^self 		subject: subject		computingBlock: aListComposition		alignment: #left</body><body package="COASTViews">subject: subject computingBlock: aListComposition alignment: aSymbol 	"aListComposition is a block with one argument; the subject of this Adaptor"	^(self new)		listComputingBlock: aListComposition;		alignment: aSymbol;		subject: subject;		yourself</body></methods><methods><class-id>COAST.SequenceViewAvoidScrolling</class-id> <category>updating</category><body package="COASTViews">updateModel	self sequence: model value.	targetIndex := self zeroIndex.	self invalidate.	self elementsInSequenceHaveChanged.	self changedPreferredBounds: nil.</body></methods><methods><class-id>COAST.WidgetStateAdaptor</class-id> <category>accessing</category><body package="COASTViews">coastWidgetWrapper	^ widgetWrapper</body><body package="COASTViews">isEnabledBlock	^ isEnabledBlock</body><body package="COASTViews">isEnabledBlock: aBlock	isEnabledBlock := aBlock.	(self slotNamed: #isEnabled) invalidate.</body><body package="COASTViews">isVisibleBlock	^ isVisibleBlock</body><body package="COASTViews">isVisibleBlock: aBlock	isVisibleBlock := aBlock.	(self slotNamed: #isVisible) invalidate.</body><body package="COASTViews">labelStringBlock	^ labelStringBlock</body><body package="COASTViews">labelStringBlock: aBlock	labelStringBlock := aBlock.	(self slotNamed: #labeLString) invalidate.</body><body package="COASTViews">layoutBlock	^ layoutBlock</body><body package="COASTViews">layoutBlock: aBlock	layoutBlock := aBlock.	(self slotNamed: #layout) invalidate.</body><body package="COASTViews">widgetWrapper: aWidgetWrapper	widgetWrapper := aWidgetWrapper</body></methods><methods><class-id>COAST.WidgetStateAdaptor</class-id> <category>computing</category><body package="COASTViews">computeIsEnabled	self isEnabledBlock isNil ifFalse: [ self coastWidgetWrapper isEnabled: self isEnabledBlock value ]</body><body package="COASTViews">computeIsVisible	self isVisibleBlock isNil ifFalse: [ self coastWidgetWrapper isVisible: self isVisibleBlock value ]</body><body package="COASTViews">computeLabelString	self labelStringBlock isNil ifFalse: [ self coastWidgetWrapper labelString: self labelStringBlock value ]</body><body package="COASTViews">computeLayout	| tc |	self layoutBlock isNil ifFalse: 		[	self coastWidgetWrapper newLayout: self isEnabledBlock value.			tc := self coastWidgetWrapper topComponent.			tc notNil ifTrue: [ tc component invalidate ]		]</body></methods><methods><class-id>COAST.WidgetStateAdaptor class</class-id> <category>instance creation</category><body package="COASTViews">on: aWidgetWrapper	^ self new		widgetWrapper: aWidgetWrapper;		yourself.</body></methods><methods><class-id>COAST.WidgetStateAdaptor class</class-id> <category>slots</category><body package="COASTViews">isEnabledSlot	^ self slotComputedEagerBy: #computeIsEnabled</body><body package="COASTViews">isVisibleSlot	^ self slotComputedEagerBy: #computeIsVisible</body><body package="COASTViews">labelStringSlot	^ self slotComputedEagerBy: #computeLabelString</body><body package="COASTViews">layoutSlot	^ self slotComputedEagerBy: #computeLayout</body></methods><methods><class-id>COAST.CoastInputFieldSpec class</class-id> <category>private-interface building</category><body package="COASTViews">componentName	"Identification of component"	^'COAST Input Field'</body></methods><methods><class-id>COAST.CoastScrollValueHolder</class-id> <category>observer - subject</category><body package="COASTViews">finishObservation	listener finishObservation.	super finishObservation.</body></methods><methods><class-id>COAST.CoastScrollValueHolder</class-id> <category>private</category><body package="COASTViews">frame: aFrame	frame := aFrame</body><body package="COASTViews">localValue: aPoint	| old |	recursionLock := true.	old := offset.	offset := aPoint.	self changed: #value with: old.	recursionLock := false.</body><body package="COASTViews">privateSetValue: newValue	useBlock notNil		ifTrue: [ useBlock			ifTrue: [ writeBlock value: newValue ]			ifFalse: [ frame at: slot set: newValue ] ].</body><body package="COASTViews">slot: aSlotName	slot := aSlotName</body><body package="COASTViews">updateValue	" the shared value was write-accessed by a remote machine. now update	the local value "	| newValue |	newValue := updateBlock value.	self localValue: newValue.	^ newValue.</body><body package="COASTViews">useBlock: aBoolean	useBlock := aBoolean</body><body package="COASTViews">writeBlock: aBlock	writeBlock := aBlock</body></methods><methods><class-id>COAST.CoastScrollValueHolder</class-id> <category>initialize-release</category><body package="COASTViews">initialize	readOnly := false.	recursionLock := false.	super initialize.</body></methods><methods><class-id>COAST.CoastScrollValueHolder</class-id> <category>accessing</category><body package="COASTViews">listener: aCatESValueListener	listener := aCatESValueListener</body><body package="COASTViews">makeReadOnly	readOnly := true.</body><body package="COASTViews">updateBlock: aBlock		updateBlock := aBlock</body><body package="COASTViews">value	^ (recursionLock or: [listener isNil or: [offset notNil] ])		ifTrue: [ offset ]		ifFalse: [listener at: #value ]</body><body package="COASTViews">value: newValue 	" Update the value of this valueholder and the according slot.	The new value is copied "	| transactionManager |	readOnly not ifTrue: 		[	transactionManager := frame transactionManager.			transactionManager activeTransactionOfCurrentProcess notNil 				ifTrue: [ self privateSetValue: newValue copy ]				ifFalse: [ transactionManager transactionDo: [ self privateSetValue: newValue copy ]].			super value: newValue		].</body></methods><methods><class-id>COAST.CoastScrollValueHolder class</class-id> <category>instance creation</category><body package="COASTViews">accessBlock: readBlock assignBlock: writeBlock application: aCoastLocalApplicationModel	| newInst |	newInst := self new.	aCoastLocalApplicationModel transactionManager displayDo: [		newInst			writeBlock: writeBlock;			updateBlock: readBlock;			useBlock: true.	].	^ newInst</body><body package="COASTViews">adaptFrame: aFrame slot: aSlotname application: aCoastLocalApplicationModel	| newInst |	newInst := self new.	aCoastLocalApplicationModel transactionManager displayDo: [		newInst			updateBlock: [ aFrame at: aSlotname asSymbol ];			frame: aFrame;			slot: aSlotname;			useBlock: false.	].	^ newInst</body></methods><methods><class-id>COAST.EagerInterestsObserver</class-id> <category>actions</category><body package="COASTViews">added: addedSet removed: removedSet 	"my computed slot has changed, here are the differences to the old value"	addedSet do: 	[: coastAppModel | | localAppModel |		localAppModel := coastAppModel createLocalApp.		localAppModel notNil			ifTrue: [	applicationDict at: coastAppModel put: localAppModel.					localAppModel localUser: monitoredUser.					localAppModel open ]			ifFalse:[ monitoredUser noticeOfUnknownApplication: coastAppModel ]	].	removedSet do: 	[: coastAppModel | | localAppModel |		localAppModel := applicationDict removeKey: coastAppModel ifAbsent: [ nil ].		(localAppModel notNil and: [ localAppModel closedLocally not ])			ifTrue: [	localAppModel closeRequest ].	]</body></methods><methods><class-id>COAST.EagerInterestsObserver</class-id> <category>startup -shutdown</category><body package="COASTViews">closeAllViews	applicationDict values do:		[ :localAppModel |			localAppModel closeLocalOnly.		].</body><body package="COASTViews">prepareForDebugging	"better collapse all opened windows, they may interfer with the debug process"	applicationDict values do:		[ :localAppModel | | win |			win := localAppModel builder window.			win notNil ifTrue: [ win collapse ].		]</body><body package="COASTViews">shutDown	self closeAllViews.	monitoredUser := nil.	super shutDown</body><body package="COASTViews">startUp	applicationDict := IdentityDictionary new.</body></methods><methods><class-id>COAST.EagerInterestsObserver</class-id> <category>computing</category><body package="COASTViews">computeEagerObserverSlot	"this method should compute a value by reading all values I have to observe"	^monitoredUser at: #interests</body></methods><methods><class-id>COAST.EagerInterestsObserver</class-id> <category>testing</category><body package="COASTViews">isInterestsObserver	^true</body></methods><methods><class-id>COAST.EagerInterestsObserver</class-id> <category>accessing</category><body package="COASTViews">localAppModelFor: aCoastApplicationModel	^applicationDict at: aCoastApplicationModel ifAbsent: [ nil ]</body><body package="COASTViews">localAppModels	^applicationDict values</body><body package="COASTViews">monitoredUser		^monitoredUser</body><body package="COASTViews">monitoredUser: aCoastUser		monitoredUser := aCoastUser.</body></methods><methods><class-id>COAST.EagerInterestsObserver class</class-id> <category>instance creation</category><body package="COASTViews">on: aUser	^self new monitoredUser: aUser; yourself</body></methods><methods><class-id>COAST.VirtualAlignedList</class-id> <category>slot accessing</category><body package="COASTViews">alignment	^self at: #alignment</body><body package="COASTViews">alignment: anAlignment	self at: #alignment set: anAlignment</body><body package="COASTViews">components	^ self at: #components</body><body package="COASTViews">listExtent	^ self at: #listExtent</body><body package="COASTViews">listExtent: extent	self at: #listExtent set: extent</body></methods><methods><class-id>COAST.VirtualAlignedList</class-id> <category>composing</category><body package="COASTViews">composeList	^ (self at: #listComputingBlock) value</body></methods><methods><class-id>COAST.VirtualAlignedList</class-id> <category>defaults</category><body package="COASTViews">defaultViewClass	^ AlignedCompositeView</body><body package="COASTViews">viewClassForCompositeView	^self defaultViewClass</body></methods><methods><class-id>COAST.VirtualAlignedList</class-id> <category>accessing</category><body package="COASTViews">listComputingBlock: aBlock	self at: #listComputingBlock set: aBlock</body></methods><methods><class-id>COAST.VirtualAlignedList class</class-id> <category>slot description</category><body package="COASTViews">alignmentSlot	^self slotOfType: #singleValue.</body><body package="COASTViews">componentsSlot	^ self slotComputedEagerBy: [:frame | frame composeList ]</body><body package="COASTViews">listComputingBlockSlot	^self slotOfType: #singleValue.</body><body package="COASTViews">listExtentSlot	^self slotOfType: #singleValue.</body></methods><methods><class-id>COAST.VirtualAlignedList class</class-id> <category>instance creation</category><body package="COASTViews">on: aListComposition	^self on: aListComposition alignment: #left</body><body package="COASTViews">on: aListComposition alignment: anAlignment	^(self new)		listComputingBlock: aListComposition;		alignment: anAlignment;		yourself</body></methods><methods><class-id>COAST.CoastArbitraryComponentSpec</class-id> <category>accessing</category><body package="COASTViews">helpText	^ nil</body></methods><methods><class-id>COAST.CoastArbitraryComponentSpec</class-id> <category>building</category><body package="COASTViews">dispatchTo: policy with: builder 	" wrap the view in a transaction wrapper, so all displays	occur in display transactions "	| c |	component == nil		ifTrue: 			[c := View new.			c controller: NoController new]		ifFalse: [component isSymbol				ifTrue: 					[c := builder arbitraryComponentAt: component.					c == nil						ifTrue: 							[builder isEditing								ifFalse: [c := builder raiseErrorMessage: 'component: &lt;1p&gt; not found!' with: component]								ifTrue: [c := View new]]]].		builder isEditing		ifTrue: [ builder component: c ]		ifFalse: [			builder component: (COAST.TransactionWrapper on:c)		].	policy manufactureGeneralWrapperFor: self into: builder.	builder applyLayout: self layout.	builder wrapWith: (policy			simpleWidgetWrapperOn: builder			spec: self			state: nil)</body></methods><methods><class-id>COAST.CoastArbitraryComponentSpec class</class-id> <category>private-interface building</category><body package="COASTViews">componentName	"Identification of component"	^'COAST View Holder'</body></methods><methods><class-id>COAST.CoastSimpleDialog</class-id> <category>events</category><body package="COASTViews">changeRequest	^ embeddedApp changeRequest</body><body package="COASTViews">dialogCancelled	cancel value ifTrue: [ embeddedApp dialogCancelled ]</body><body package="COASTViews">noticeOfWindowClose: event	^ embeddedApp noticeOfWindowClose: event</body><body package="COASTViews">requestForWindowClose	^ embeddedApp requestForWindowClose</body><body package="COASTViews">simulateEscapeKey	| kp |	kp := self builder window keyboardProcessor.	kp notNil ifTrue: [ kp default: nil ].	embeddedApp changeRequest ifFalse: [ ^ false ].	self builder window controller requestForWindowClose ifFalse: [^false].	embeddedApp dialogCancelled.	self close.	^true</body></methods><methods><class-id>COAST.CoastSimpleDialog</class-id> <category>DNU</category><body package="COASTViews">doesNotUnderstand: aMessage 	CoastLog log: [ 'CoastSimpleDialog does not understand: ' , aMessage printString ].	^ embeddedApp perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>COAST.CoastSimpleDialog</class-id> <category>initialize-release</category><body package="COASTViews">initialize	super initialize.	cancel onChangeSend: #dialogCancelled to: self.</body></methods><methods><class-id>COAST.CoastSimpleDialog</class-id> <category>interface opening</category><body package="COASTViews">openFrom: aSpec 	"Open a dialog based on aSpec"	| rect screenBounds cdiff box |	self allButOpenFrom: aSpec.	self specBuilt.	rect := embeddedApp preferredModalWindowBounds ifNil: [ embeddedBounds ifNil: [ aSpec bounds ]].	screenBounds := self screenBoundsAroundOpenLocation.	rect extent &gt; screenBounds extent 		ifTrue: [ rect := screenBounds ]		ifFalse: 		[	cdiff := screenBounds corner - rect corner.			cdiff x &gt; 0 				ifTrue: [ cdiff x: 0 ].			cdiff y &gt; 0 				ifTrue: [ cdiff y: 0 ].			rect moveBy: cdiff		].	box := 0 @ 0 extent: rect extent.	box := builder coastShouldOpenDialogsAtCursor 			ifTrue: [ box align: box center with: WindowSensor cursorPoint ]			ifFalse: [ box align: box center with: screenBounds center ].	builder openPopUpIn: box type: self windowType.	^ accept value</body><body package="COASTViews">postOpenWith: aBuilder	self transactionManager bestTransactionDo: [		embeddedApp postOpenWith: aBuilder.	].</body><body package="COASTViews">specBuilt	"ok"</body></methods><methods><class-id>COAST.CoastSimpleDialog</class-id> <category>accessing</category><body package="COASTViews">embed: aLocalAppBlock spec: specSymbol builder: aBuilder 	| fullSpec |	embeddedApp notNil 		ifTrue: [ ^ self ].	embeddedBuilder := aBuilder.	self transactionManager bestTransactionDo: 		[	embeddedApp := aLocalAppBlock value.			embeddedApp coastDialog: self.			embeddedApp builder: aBuilder.			aBuilder 				widgetAt: #'__embeddedSpec'				do: 				[: subcanvas | | minSize |					subcanvas client: embeddedApp spec: specSymbol builder: aBuilder.					fullSpec := embeddedApp interfaceSpecFor: specSymbol.					embeddedBounds := fullSpec window bounds.					embeddedApp setLabel: ( self windowLabelFromSpec: fullSpec application: embeddedApp ) ofWindow: aBuilder window.					( minSize := fullSpec window min ) notNil 						ifTrue: [ aBuilder window minimumSize: minSize ]				]		].</body><body package="COASTViews">transactionManager	^ transactionManager</body><body package="COASTViews">transactionManager: aTransactionManager 	transactionManager := aTransactionManager.</body><body package="COASTViews">windowLabelFromSpec: fullSpec application: aCoastLocalApplicationModel 	^ aCoastLocalApplicationModel windowLabelForEmbeddedDialogSpec: fullSpec</body><body package="COASTViews">windowType	^ windowType ifNil: [ #imageModalDialog ]</body><body package="COASTViews">windowType: aWindowType 	windowType := aWindowType.</body></methods><methods><class-id>COAST.CoastSimpleDialog class</class-id> <category>dialog</category><body package="COASTViews">openResizableWith: aLocalAppBlock for: aVisualOrNil transactionManager: transactionManager 	^ self openResizableWith: aLocalAppBlock spec: #windowSpec for: aVisualOrNil transactionManager: transactionManager</body><body package="COASTViews">openResizableWith: aLocalAppBlock spec: spec for: aVisualOrNil transactionManager: transactionManager 	^ self openWith: aLocalAppBlock spec: spec for: aVisualOrNil windowType: #normal transactionManager: transactionManager</body><body package="COASTViews">openWith: aLocalAppBlock for: aVisualOrNil transactionManager: transactionManager 	^ self openWith: aLocalAppBlock for: aVisualOrNil windowType: #imageModalDialog transactionManager: transactionManager</body><body package="COASTViews">openWith: aLocalAppBlock for: aVisualOrNil windowType: windowType transactionManager: transactionManager 	^ self openWith: aLocalAppBlock spec: #windowSpec for: aVisualOrNil windowType: windowType transactionManager: transactionManager</body><body package="COASTViews">openWith: aLocalAppBlock spec: specSymbol for: aVisualOrNil windowType: windowType transactionManager: transactionManager 	| dialog parentWindow |	parentWindow := aVisualOrNil isNil 			ifTrue: 			[	CoastLog log: 'No parent window for embedded dialog specified'.				" jetzt ermiteln, bevor die Transaktionssequenz gestartet wird "				Dialog defaultParentWindow			]			ifFalse: [ aVisualOrNil ].	dialog := self embed: aLocalAppBlock spec: specSymbol windowType: windowType.	dialog transactionManager: transactionManager.	dialog openInterface: #windowSpec for: parentWindow.	^ dialog</body></methods><methods><class-id>COAST.CoastSimpleDialog class</class-id> <category>private - instance creation</category><body package="COASTViews">embed: aLocalAppBlock 	^ self embed: aLocalAppBlock spec: #windowSpec</body><body package="COASTViews">embed: aLocalAppBlock spec: specSymbol	^ self embed: aLocalAppBlock spec: specSymbol windowType: #imageModalDialog</body><body package="COASTViews">embed: aLocalAppOrBlock spec: specSymbol windowType: windowType	| dialog |	dialog := self new.	dialog windowType: windowType.	dialog postBuildBlock: [ : d : builder | d embed: aLocalAppOrBlock spec: specSymbol builder: builder ].	" compatibility - fÃ¼r old style Aufruf braucht man einen TransactionManager, da der Aufrufer davon bisher nichts wusste "	(aLocalAppOrBlock isKindOf: BlockClosure)		ifFalse: [ dialog transactionManager: aLocalAppOrBlock transactionManager ].	^ dialog</body></methods><methods><class-id>COAST.WidgetTransactionWrapper</class-id> <category>accessing</category><body package="COASTViews">handlerForMouseEvent: aMouseEvent 	^ aMouseEvent key = #coastDisplay		ifTrue: [ 			self invalidate.			nil ]		ifFalse: [ super handlerForMouseEvent: aMouseEvent ]</body><body package="COASTViews">widget	^ self component</body></methods><methods><class-id>COAST.WidgetTransactionWrapper</class-id> <category>displaying</category><body package="COASTViews">displayOn: aGraphicsContext	" Start a display action, because displaying the componentmay require	accessing some slots. A transaction manager does not necessarily	exist (e.g. when editing a canvas), therefore it is wise to check if we have one  "	| model tm t |	model := self component model. 	(model notNil and: [ (tm := model transactionManager) notNil ])		ifTrue: [ 			((t := tm activeTransactionOfCurrentProcess) isNil or: [ t inDisplayPhase ])				ifTrue: [ tm displayDo: [ super displayOn: aGraphicsContext ] ]				ifFalse: [					[ 						[							self invalidateRectangle: self bounds repairNow: true 						] on: Error do: [ : ex |							" due to the fork, the window might be closed now "							self isOpen								ifTrue: [ CoastLog logException: ex message: 'Error during view invalidate of a transaction wrapper' ]						].					] fork.				]		]		ifFalse: [ super displayOn: aGraphicsContext ].</body></methods><methods><class-id>COAST.CoastApplicationClientWithUI</class-id> <category>accessing</category><body package="COASTViews">needsIni	^ false</body></methods><methods><class-id>COAST.CoastApplicationClientWithUI</class-id> <category>initialize-release</category><body package="COASTViews">initialize	super initialize.	self transactionManager initializeUIViews.	volumeManager connectionLostBlock: 		[	self release.			ScheduledControllers checkForEvents.			MediatorLostApp open		].	volumeManager generateUniquePersistentClientID.</body></methods><methods><class-id>COAST.CoastApplicationClientWithUI class</class-id> <category>accessing</category><body package="COASTViews">defaultLogFilename	^ nil</body></methods><methods><class-id>COAST.CoastApplicationClientWithUI class</class-id> <category>release</category><body package="COASTViews">emptyPrototypes	super emptyPrototypes.	AutomaticVisualPart withAllSubclasses do: [:s | s emptyPrototype].	CoastLocalApplicationModel withAllSubclasses do: [:s | s emptyPrototype]</body></methods><methods><class-id>UI.ComboBoxView</class-id> <category>accessing</category><body package="COASTViews">model	^editor model</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>accessing</category><body package="COASTViews">bringWindowToTop	self isOpen 		ifTrue: 		[	self isCollapsed 				ifTrue: [ self expand ].			OSSystemSupport concreteClass new coastBringWindowToTop: self.			self becomeActive		].</body></methods><methods><class-id>COAST.CoastNotifierShared</class-id> <category>views</category><body package="COASTViews">localApplicationModelClass	^ CoastNotifierLocal</body></methods><methods><class-id>OS.OSSystemSupport</class-id> <category>accessing</category><body package="COASTViews">coastBringWindowToTop: aWindow	aWindow raise</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>testing</category><body package="COASTViews">isMainApplication	" true falls diese App das Hauptmodell des Fensters ist. "	^ self mainWindow ifNotNil: [: window | window model == self ] ifNil: [ false ]</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>private</category><body package="COASTViews">setLabel: aString ofWindow: aWindow	" Hook "	aWindow label: aString</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>accessing</category><body package="COASTViews">widgetAt: id do: aBlock 	( id isCharacters not and: [ Notifier isDevelopment ])		ifTrue: [ self haltOrContinue: 'Symbol expected' ].	self widgetWrapperAt: id do: [: wrapper | aBlock value: wrapper widget ].</body><body package="COASTViews">widgetsAt: someIDs do: aBlock 	( someIDs isCharacters and: [ Notifier isDevelopment ])		ifTrue: [ self haltOrContinue: 'Array of Symbols expected' ].	someIDs do: [: id | self widgetAt: id do: aBlock ].</body><body package="COASTViews">widgetWrapperAt: id do: aBlock	| wrapper |	self builder notNil		ifTrue: [			wrapper := self builder componentAt: id.			wrapper notNil ifTrue: [ aBlock value: wrapper ].		]</body><body package="COASTViews">widgetWrappersAt: someIDs do: aBlock	someIDs do: [:id |		self widgetWrapperAt: id do: aBlock	].</body></methods><methods><class-id>UI.SimpleDialog</class-id> <category>accessing</category><body package="COASTViews">coastCanAccept	^ true</body><body package="COASTViews">coastCancel	self cancel value: true.	self closeRequest.</body><body package="COASTViews">coastOk	self coastCanAccept ifFalse: [ ^ self ].	self accept value: true.	self closeRequest.</body></methods><methods><class-id>Core.Object</class-id> <category>initialize-release</category><body package="COASTViews">aspectAdaptorFinishObservation	" stop observerving - never started "</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COASTViews">coastCopyOrSelfForAspectAdaptor	^ self copy</body><body package="COASTViews">equalForCoastAspect: value 	^ self = value</body></methods><methods><class-id>Core.Object</class-id> <category>updating</category><body package="COASTViews">invalidateFromCoastAspectAdaptor</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>accessing</category><body package="COASTViews">closeRequestTransactionDo: block onFailure: failureBlock 	"multiple close requests must be catched by marking active transaction as used for changeRequest"	| isNested |	^ volumeManager exclusiveUseDo: 		[	isNested :=  activeTransaction notNil and: [( activeTransaction transactionContextAt: #coastInternalChangeRequestMarker ) notNil ].			( activeTransaction isNil or: [ isNested not ]) 				ifTrue: 				[	"do not continue here if transaction is active! will cause deadlock!!!"					( transactionSequence isNil and: [ activeTransaction isNil ]) 						ifTrue: 						[	self 								pessimisticTransactionDo: 								[: transaction |									transaction transactionContextAt: #coastInternalChangeRequestMarker put: true.									transaction execute: block								]								onFailure: failureBlock						]						ifFalse: [ failureBlock value ]				]				ifFalse: 				[	"nesting closeRequestTransactions - reuse transaction"					failureBlock notNil 						ifTrue: [ activeTransaction addFailureBlock: failureBlock ].					activeTransaction execute: block				]		]</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>initialize - release</category><body package="COASTViews">initializeUIViews	self addUpdateNotificationBlock: [: tm | 		Screen default allScheduledWindowsDo: [: w | w checkForEvents ]	].</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>user management</category><body package="COASTViews">localInterestObservers	^self eagerObservers		select: [ :o | o isInterestsObserver ]</body><body package="COASTViews">localUsers	^self localInterestObservers collect: [ :io | io monitoredUser ]</body><body package="COASTViews">releaseUser: aCoastUser	| obs |	obs :=self localInterestObservers detect: [ :io | io monitoredUser = aCoastUser ] ifNone: [ nil ].	obs isNil ifFalse:	[		self releaseEagerObserver: obs.	].</body><body package="COASTViews">releaseUserNamed: aString	| obs |	obs :=self localInterestObservers detect: [ :io | io monitoredUser name = aString ] ifNone: [ nil ].	obs isNil ifFalse:	[		self releaseEagerObserver: obs.	].</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing</category><body package="COASTViews">defaultViewClass	^nil</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="COASTViews">asComboBoxText	^ COAST.ComboBoxText fromString: self asString</body></methods><methods><class-id>COAST.CoastUser class</class-id> <category>slots</category><body package="COASTViews">defaultWindowExtentSlot	^ (self slotOfType: #dictionary)		range: Point;		keyRange: CharacterArray.</body><body package="COASTViews">defaultWindowOriginSlot	^ (self slotOfType: #dictionary)		range: Point;		keyRange: CharacterArray.</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>register</category><body package="COASTViews">buildInterestsObserver	^self interestsObserverClass on: self.</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>accessing</category><body package="COASTViews">copyPersistentWindowBoundsBoundsTo: user 	#( #defaultWindowExtent #defaultWindowOrigin ) do: 		[: slotname | | dict |			dict := self at: slotname.			dict keysAndValuesDo: [: className : point | ( user at: slotname atKey: className ) = point ifFalse: [ user at: slotname atKey: className put: point ]]		].</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>register</category><body package="COASTViews">deRegister		"inverse to register"	self transactionManager releaseUser: self.	self deActivate.</body><body package="COASTViews">interestsObserverClass	^ EagerInterestsObserver</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>accessing</category><body package="COASTViews">loadLocalPreferences	self sharedCopy copyPersistentWindowBoundsBoundsTo: self localCopy</body><body package="COASTViews">noticeOfUnknownApplication: application	NonmodalNotifier warn: 'Can not open unknown Application: ' , application frameClassName printString title: 'Coast Error'</body><body package="COASTViews">persistentWindowBounds: aRectangle forApplicationClass: aClass 	| className |	self isLocal ifFalse: [ ^ self localCopy persistentWindowBounds: aRectangle forApplicationClass: aClass ].	className := aClass fullName.	self at: #defaultWindowOrigin atKey: className put: aRectangle origin.	self at: #defaultWindowExtent atKey: className put: aRectangle extent.</body><body package="COASTViews">persistentWindowBoundsForApplicationClass: aClass 	| origin extent className classSymbol |	self isLocal ifFalse: [ ^ self localCopy persistentWindowBoundsForApplicationClass: aClass ].	className := aClass fullName.	origin := self at: #defaultWindowOrigin atKey: className.	extent := self at: #defaultWindowExtent atKey: className.	^ ( origin notNil and: [ extent notNil ]) 		ifTrue: [ origin extent: extent ]		ifFalse: 		[	" compatibility "			classSymbol := aClass name asSymbol.			origin := self at: #defaultWindowOrigin atKey: classSymbol.			extent := self at: #defaultWindowExtent atKey: classSymbol.			( origin notNil and: [ extent notNil ]) 				ifTrue: [ origin extent: extent ]				ifFalse: [ nil ]		]</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>register</category><body package="COASTViews">register	"let me be a local user"	"avoid registering twice"	( self transactionManager localUsers includes: self ) ifFalse: 		[	self transactionManager installEagerObserver: self buildInterestsObserver.			self isLocal ifFalse: 				[	self activate.					self loadLocalPreferences.					self transactionManager installEagerObserver: self localCopy buildInterestsObserver				]		].</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>accessing</category><body package="COASTViews">releaseUI	| localApp |	self sharedCopy interests do: 		[: app |			localApp := app localApplicationModel.			localApp notNil ifTrue: [ localApp updatePersistentWindowBounds ]		].	self localCopy interests do: 		[: app |			localApp := app localApplicationModel.			localApp notNil ifTrue: [ localApp updatePersistentWindowBounds ]		].	self saveLocalPreferences</body><body package="COASTViews">saveLocalPreferences	self localCopy copyPersistentWindowBoundsBoundsTo: self sharedCopy</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>accessing</category><body package="COASTViews">scrollWrapper	^ self</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>private</category><body package="COASTViews">sharedOnFrame: aFrame slotName: aSlotSymbol	"transform the scroll wrapper into a shared one"	"the scroll position will be kept in the specified frame/slot"	| app |	app := self topComponent.	origin := COAST.CoastScrollValueHolder adaptFrame: aFrame slot: aSlotSymbol application: app.	origin addDependent: self.</body><body package="COASTViews">sharedOnFrame: aFrame slotName: aSlotSymbol application: aCoastLocalApplicationModel	"transform the scroll wrapper into a shared one"	"the scroll position will be kept in the specified frame/slot"	origin := COAST.CoastScrollValueHolder adaptFrame: aFrame slot: aSlotSymbol application: aCoastLocalApplicationModel.	origin addDependent: self.</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>testing</category><body package="COASTViews">isValid	^ true</body><body package="COASTViews">mayBeReused	^ true</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>initialize-release</category><body package="COASTViews">releaseWithoutInvalidation	self release</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>accessing</category><body package="COASTViews">scrollWrapper	^ nil</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>focus accessing</category><body package="COASTViews">takeFocusWithEvent: aCharEvent</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>accessing</category><body package="COASTViews">transactionManager	^nil</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>open - close</category><body package="COASTViews">close	self closeFor: self localUser</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>private</category><body package="COASTViews">closeSharedOnly	" this method should only be called before closing the local application model "	self localApplicationModel: nil.	self closeFor: self localUser</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>views</category><body package="COASTViews">createLocalApp	"open a new window (on a local application model)"	| cl |	^ (cl := self localApplicationModelClass) notNil		ifTrue: [ cl onSharedApplication: self ]		ifFalse: [ nil ].</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>accessing</category><body package="COASTViews">localApplicationModel	"Delegate it to the main application model"	^self parent isNil		ifTrue:		[ | lam |			lam := nil.			self transactionManager localInterestObservers do:				[ :io | | am | am := io localAppModelFor: self. am notNil ifTrue: [ lam := am ] ].			lam		]		ifFalse: [self parent localApplicationModel]</body><body package="COASTViews">localApplicationModel: aModel		"nothing to do  - backward compatibility only"</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>views</category><body package="COASTViews">localApplicationModelClass	^ nil</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>open - close</category><body package="COASTViews">noticeOfWindowClose	self closeSharedOnly.</body><body package="COASTViews">open	^ self openFor: self localUser</body></methods><methods><class-id>COAST.CoastApplicationModel</class-id> <category>accessing</category><body package="COASTViews">persistentWindowBounds	| u |	u := self localUser.	^ u notNil		ifTrue: [ u persistentWindowBoundsForApplicationClass: self class ]		ifFalse: [ nil ]</body><body package="COASTViews">persistentWindowBounds: aRectangle	| u |	(u := self localUser) isNil ifTrue:  [ ^ self ].	u persistentWindowBounds: aRectangle forApplicationClass: self class.</body><body package="COASTViews">topParent	^self parent isNil		ifTrue: [self]		ifFalse: [self parent topParent]</body></methods><methods><class-id>COAST.CoastUniversalLocalApplicationModel class</class-id> <category>instance creation</category><body package="COASTViews">domainModel: domainModel localApplicationModel: anApplicationModel	| newInst |	newInst := self newLocal.	newInst domainModel: domainModel.	newInst localApplicationModel: anApplicationModel.	^ newInst</body><body package="COASTViews">domainModel: domainModel localClass: localClass 	| newInst |	newInst := self newLocal.	newInst domainModel: domainModel.	newInst localApplicationModelClass: localClass.	^ newInst</body><body package="COASTViews">domainModel: domainModel localClass: localClass openForUser: user	| newInst |	newInst := self newLocal.	newInst domainModel: domainModel.	newInst localApplicationModelClass: localClass.	newInst openFor: user</body><body package="COASTViews">localApplicationModel: anApplicationModel	| newInst |	newInst := self newLocal.	newInst domainModel: anApplicationModel domainModel.	newInst setLocalApplicationModel: anApplicationModel.	^ newInst</body></methods><methods><class-id>COAST.CoastUniversalLocalApplicationModel class</class-id> <category>slot description</category><body package="COASTViews">localApplicationModelClassSlot	^self slotSingleValue</body><body package="COASTViews">localApplicationModelSlot	^ self slotSingleValue		range: CoastLocalApplicationModel;		yourself</body></methods><methods><class-id>COAST.CoastUniversalLocalApplicationModel</class-id> <category>accessing</category><body package="COASTViews">closeSharedOnly	" this method should only be called before closing the local application model "	self localApplicationModel: nil.	self interestedUsers copy do: [: user | self closeFor: user ]</body></methods><methods><class-id>COAST.CoastUniversalLocalApplicationModel</class-id> <category>views</category><body package="COASTViews">createLocalApp	| app |	app := self at: #localApplicationModel.	app isNil		ifTrue: [			app := super createLocalApp.			self at: #localApplicationModel set: app.		].	^ app</body></methods><methods><class-id>COAST.CoastUniversalLocalApplicationModel</class-id> <category>accessing</category><body package="COASTViews">editorReuseKey	^ self localApplicationModelClass ifNotNil: [: localAppClass | localAppClass editorReuseKey ifNotNil: [: localKey | localKey -&gt; self domainModel ]]</body><body package="COASTViews">localApplicationModel	^ (self at: #localApplicationModel) ifNil: [ super localApplicationModel ].</body><body package="COASTViews">localApplicationModelClass	| appClass dm |	appClass := self at: #localApplicationModelClass.	^ appClass notNil 		ifTrue: [ appClass ]		ifFalse: 		[(( dm := self domainModel) notNil and: [ dm respondsTo: #localApplicationModelClass ]) 				ifTrue: [ dm localApplicationModelClass ]				ifFalse: [ super localApplicationModelClass ]		]</body><body package="COASTViews">localApplicationModelClass: aClass	^self at: #localApplicationModelClass set: aClass</body><body package="COASTViews">persistentWindowBounds	| u localAppClass |	^ (localAppClass := self localApplicationModelClass) notNil		ifTrue: [			u := self localUser.			u notNil				ifTrue: [ u persistentWindowBoundsForApplicationClass: localAppClass ]				ifFalse: [ nil ]		]		ifFalse: [ nil ]</body><body package="COASTViews">persistentWindowBounds: aRectangle 	| u localAppClass |	(( localAppClass := self localApplicationModelClass ) notNil and: [( u := self localUser ) notNil ]) 		ifTrue: [ u persistentWindowBounds: aRectangle forApplicationClass: localAppClass ].</body></methods><methods><class-id>COAST.CoastUniversalLocalApplicationModel</class-id> <category>private</category><body package="COASTViews">setLocalApplicationModel: anApplicationModel 	" #localApplicationModel: soll hier nicht Ã¼berschrieben werden "	self at: #localApplicationModel set: anApplicationModel.	anApplicationModel sharedApplicationModel: self.	self localApplicationModelClass: anApplicationModel class.</body></methods><methods><class-id>UI.SelectionView</class-id> <category>updating</category><body package="COASTViews">invalidateFromCoastAspectAdaptor	self invalidate</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>COAST</category><body package="COASTViews">coastListView: spec into: builder 	| lv model menu performer dropSourceCallbacks |	model := spec modelInBuilder: builder.	lv := spec avoidScrolling 			ifTrue: [( spec multipleSelections 					ifTrue: [ COAST.MultiSelectionSequenceViewAvoidScrolling ]					ifFalse: [ COAST.SequenceViewAvoidScrolling ]) new ]			ifFalse: [( spec multipleSelections 					ifTrue: [ self multiSelectionListViewClass ]					ifFalse: [ self listViewClass ]) new ].	lv model: model listHolder.	spec hasHorizontalScrollBar ifTrue: [ lv measureWidth: true ].	lv selectionChannel: model selectionIndexHolder.	spec selectionTypeSelector == nil ifFalse: [ lv perform: spec selectionTypeSelector ].	spec multipleSelections ifTrue: 		[	spec useModifierKeys 				ifTrue: [ lv controller: self compliantMultiSelectControllerClass new ]				ifFalse: [ lv controller: self simpleMultiSelectControllerClass new ]		].	( menu := spec getMenuIn: builder ) == nil ifFalse: [ lv controller menuHolder: menu ].	( performer := spec getPerformerIn: builder ) == nil ifFalse: [ lv controller performer: performer ].	self setStyleOf: lv to: spec style;		setHelpTextFor: spec component: lv in: builder.	self setDispatcherOf: lv fromSpec: spec builder: builder.	spec tabable 		ifTrue: 		[	lv widgetState isTabStop: true.			builder sendKeyboardTo: lv		]		ifFalse: 		[	lv widgetState canTakeFocus: true.			lv controller keyboardProcessor: builder keyboardProcessor		].	lv widgetState isEnabled: spec initiallyEnabled.	spec selectionType == #checkMark 		ifTrue: [ lv controller autoSelect: false ]		ifFalse: [ lv controller autoSelect: spec autoSelect ].	builder isEditing ifFalse: [ lv widgetState isVisible: spec initiallyVisible ].	dropSourceCallbacks := spec dropSourceCallbacksOrNilInBuilder: builder.	dropSourceCallbacks == nil ifFalse: 		[	lv controller dragDropCallbacks: dropSourceCallbacks.			lv controller selectOnDownWithDrag: spec selectOnDownIfDragEnabled		].	builder component: lv.	" MODIFCATION START "	builder wrapWith: COAST.WidgetTransactionWrapper new.	" MODIFICATION END "	self manufactureGeneralWrapperFor: spec into: builder.	builder applyLayout: spec layout.	builder wrapWith: ( self simpleWidgetWrapperOn: builder spec: spec ).</body><body package="COASTViews">coastNativeView: spec into: builder 	| model composite compositeView trWrapper |	model := spec modelInBuilder: builder.	composite := COAST.CoastWidgetCompositeModel new.	composite addComponent: model.	compositeView := composite defaultViewClass model: composite.	builder component: compositeView.	self manufactureGeneralWrapperFor: spec into: builder.	builder applyLayout: spec layout.	trWrapper := COAST.TransactionWrapper new.	trWrapper transactionManager: model transactionManager.	builder wrapWith: trWrapper.</body></methods><methods><class-id>UI.DropSource</class-id> <category>As yet unclassified</category><body package="COASTViews">canBeDroppedOn: aView at: aPoint 	"compatibility with CatCODropSource - to be revisited JS-16.2.01"	^false</body></methods><methods><class-id>UI.UIBuilder class</class-id> <category>policies</category><body package="COASTViews">coastShouldOpenDialogsAtCursor	^ OpenDialogsAtCursor</body></methods><methods><class-id>UI.UIBuilder</class-id> <category>scheduling</category><body package="COASTViews">coastShouldOpenDialogsAtCursor	^ self class coastShouldOpenDialogsAtCursor</body></methods><methods><class-id>UI.UIBuilder</class-id> <category>accessing</category><body package="COASTViews">widgetAt: id	| wr |	wr := self componentAt: id.	^ wr notNil 		ifTrue: [ wr widget ]		ifFalse: [ nil ]</body><body package="COASTViews">widgetAt: id do: aBlock 	( id isCharacters not and: [ Notifier isDevelopment ])		ifTrue: [ self haltOrContinue: 'Symbol expected' ].	self widgetWrapperAt: id do: [: wr | aBlock value: wr widget ].</body><body package="COASTViews">widgetsAt: someIDs do: aBlock 	( someIDs isCharacters and: [ Notifier isDevelopment ]) 		ifTrue: [ self haltOrContinue: 'Array of Symbols expected' ].	someIDs do: [: id | self widgetAt: id do: aBlock ].</body><body package="COASTViews">widgetWrapperAt: id do: aBlock	| wr |	wr := self componentAt: id.	wr notNil ifTrue: [ aBlock value: wr ].</body><body package="COASTViews">widgetWrappersAt: someIDs do: aBlock	someIDs do: [:id |		self widgetWrapperAt: id do: aBlock	].</body></methods><methods><class-id>UI.UIBuilder</class-id> <category>binding</category><body package="COASTViews">wrapWithTransactionWrapper	" buest guess where to find the TM "	| model |	model := self component model.	^ model notNil		ifTrue: [ self wrapWithTransactionWrapper: model transactionManager ]		ifFalse: [ nil ].</body><body package="COASTViews">wrapWithTransactionWrapper: transactionManager	| trWrapper |	trWrapper := COAST.TransactionWrapper new.	trWrapper transactionManager: transactionManager.	self wrapWith: trWrapper.	^ trWrapper</body></methods><methods><class-id>Graphics.BoundedWrapper</class-id> <category>testing</category><body package="COASTViews">isBounded	^true</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>deprecated</category><body package="COASTViews">addKeyboardConsumersTo: aKeyboardProcessor	" deprecated, for compatibility only "</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>accessing</category><body package="COASTViews">boundedContainer	^self isBounded		ifTrue: [ self ]		ifFalse: [ self container isNil ifTrue: [ nil ] ifFalse: [ self container boundedContainer ] ]</body><body package="COASTViews">coastWidgetWrapper	^ container notNil		ifTrue: [ container coastWidgetWrapper ]		ifFalse: [ nil ]</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>testing</category><body package="COASTViews">isBounded	^false</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>accessing</category><body package="COASTViews">scrollWrapper	^ container notNil		ifTrue: [ container scrollWrapper ]		ifFalse: [ nil ]</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>wrapper</category><body package="COASTViews">wrapWithTransactionWrapper: transactionManager	" used for NewDataSetViews, but unmanaged code cannot be extended ... "	| obj cont wrapper |	obj := self container container.	cont := obj container.	wrapper := COAST.TransactionWrapper on: obj.	wrapper transactionManager: transactionManager.	cont setComponent: wrapper.</body></methods><methods><class-id>Core.Text</class-id> <category>converting</category><body package="COASTViews">asComboBoxText	^ COAST.ComboBoxText string: string copy runs: runs copy</body></methods><methods><class-id>Core.Text</class-id> <category>comparing</category><body package="COASTViews">equalForCoastAspect: anotherText 	"modification of runs ==&gt; update aspect..."	^ ( super equalForCoastAspect: anotherText ) and: [ self runs = anotherText runs ]</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>accessing</category><body package="COASTViews">coastCopyOrSelfForAspectAdaptor	^ self</body></methods><methods><class-id>COAST.CatFSUniversalFrame</class-id> <category>open - close</category><body package="COASTViews">createLocalApp	^nil</body><body package="COASTViews">localApplicationModel	^nil</body><body package="COASTViews">openFor: aCoastUser 	aCoastUser noticeOfUnknownApplication: self</body></methods><methods><class-id>UI.WidgetWrapper</class-id> <category>As yet unclassified</category><body package="COASTViews">coastWidgetWrapper	^ self</body><body package="COASTViews">createAdaptor	^ COAST.WidgetStateAdaptor on: self</body></methods><methods><class-id>Graphics.Window</class-id> <category>accessing</category><body package="COASTViews">scrollWrapper	^ nil</body></methods><methods><class-id>UI.ValueHolder</class-id> <category>accessing</category><body package="COASTViews">transactionManager	^ nil</body></methods><methods><class-id>Graphics.Wrapper</class-id> <category>event driven</category><body package="COASTViews">takeFocusWithEvent: aCharEvent	self component takeFocusWithEvent: aCharEvent</body></methods><methods><class-id>Graphics.Wrapper</class-id> <category>accessing</category><body package="COASTViews">width	^self component width</body><body package="COASTViews">wrappedComponent	^ self component notNil		ifTrue: [ self component wrappedComponent ]		ifFalse: [ nil ]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CatCSCell</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container valueHolder observers </inst-vars><class-inst-vars>prototype </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>CatFSFrame</name><environment>COAST</environment><super>COAST.CatCSContainerCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>coastFrameClassSymbol coastFrameClassName </class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastModel</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastApplicationModel</name><environment>COAST</environment><super>COAST.CoastModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastUniversalLocalApplicationModel</name><environment>COAST</environment><super>COAST.CoastApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastTransactionManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activeTransaction transactionSequence eagerObservers developmentMode active rollForwardNotificationBlocks rollBackNotificationBlocks updateNotificationBlocks pendingProcesses volumeManager context outstandingTransactionsCount blockCaches needsFlush localUser </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>InputFieldSpec</name><environment>UI</environment><super>UI.TextEditorSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type formatString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>SelectionView</name><environment>UI</environment><super>UI.ScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequence selectionChannel selectionIndex targetIndex grid textStyle displayStringSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>UILookPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>systemAttributes systemWidgetAttributes useSystemFontOnWidgets systemMenuAttributes </class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>CatFSVirtualFrame</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastEagerDifferencesObserver</name><environment>COAST</environment><super>COAST.CoastEagerObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSEagerObservers</category><attributes><package>COEagerObservers</package></attributes></class><class><name>SequenceView</name><environment>UI</environment><super>UI.SelectionView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visualBlock selectedVisualBlock measureWidth cachedWidth mouseOverIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>SelectionTracker</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>MultiSelectionSequenceView</name><environment>UI</environment><super>UI.SequenceView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selections lastSelectionIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>CoastError</name><environment>COAST</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>SelectionInList</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listHolder selectionIndexHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>MultiSelectionInList</name><environment>UI</environment><super>UI.SelectionInList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Wrapper</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>BoundedWrapper</name><environment>Graphics</environment><super>Graphics.LayoutWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>ControllerWithMenu</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuHolder performer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>Window</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputOrigin creationOrigin sensor iconic windowType effectiveWindowType statusLineHeight allowsStatusLine mapped eventHandlers windowManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ArbitraryComponentSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component dynamism passClicks pushAspect pushMode pushOn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ScrollWrapper</name><environment>UI</environment><super>Graphics.TranslatingWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents preferredBoundsBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>CoastApplicationClient</name><environment>COAST</environment><super>COAST.CoastApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumeManager </inst-vars><class-inst-vars>default active </class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>ScrollValueHolder</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>offset grid extraSpace permitDisplayOutput </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>SequenceViewSpec</name><environment>UI</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multipleSelections style useModifierKeys selectionType autoSelect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>WidgetWrapper</name><environment>UI</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>widget widgetState effectivelyVisible decorator dependents dropTarget </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>UIBuilder</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindings namedComponents labels visuals subCanvasSpecs source policy spec window keyboardProcessor composite component decorator wrapper stack isEditing cacheWhileEditing windowSpec converterClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>OSSystemSupport</name><environment>OS</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.OSSystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-Support</package></attributes></class><class><name>DropSource</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Drag-And-Drop</category><attributes><package>Drag-And-Drop</package></attributes></class><class><name>CatFSUniversalFrame</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClassName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSM</category><attributes><package>COFramesystem</package></attributes></class><class><name>Win32SystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win32SystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>gdi32.dll</item> <item>advapi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-PC</package></attributes></class><class><name>CoastUser</name><environment>COAST</environment><super>COAST.CoastModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>localCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>ComboBoxView</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>editor menuButton </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>ValueHolder</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>CoastNotifierShared</name><environment>COAST</environment><super>COAST.CoastApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTClient</package></attributes></class></st-source>