<?xml version="1.0"?><st-source><!-- Name: COASTDevelopmentDevelopmentPrerequisites: #(#(#any 'COASTCore' '') #(#any 'COASTViews' '') #(#any 'COASTClient' '') #(#any 'COASTGarbageCollection' '') #(#any 'COASTMediator' '') #(#any 'Tools-Trippy' '') #(#any 'UIPainter' '') #(#any 'Browser-BrowserUI' ''))PackageName: COASTDevelopmentPackageName:: COASTDevelopmentParcel: #($t "16r0074")PrerequisiteDescriptions: #(#(#name 'COASTCore' #componentType #bundle) #(#name 'COASTViews' #componentType #package) #(#name 'COASTClient' #componentType #package) #(#name 'COASTGarbageCollection' #componentType #package) #(#name 'COASTMediator' #componentType #package) #(#name 'Tools-Trippy' #componentType #package) #(#name 'UIPainter' #componentType #package) #(#name 'Browser-BrowserUI' #componentType #package))PrerequisiteParcels: #(#('COASTCore' '') #('COASTViews' '') #('COASTClient' '') #('COASTGarbageCollection' '') #('COASTMediator' '') #('Tools-Trippy' '') #('UIPainter' '') #('Browser-BrowserUI' ''))Version: 5.4.40Post-Load Block: 	[:package |	TextEditorController addTransactionDoIt.]Pre-Unload Block: 	[:package |	TextEditorController removeTransactionDoIt.]Date: 1:08:46 PM November 17, 2013 --><time-stamp>From VisualWorksÂ®, 7.10 of 10. Juli 2013 on 17. November 2013 at 13:08:46</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CoastProfilingClient</name><environment>COAST</environment><super>COAST.CoastApplicationClientWithUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>useTimeProfiler </class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastTrippyInspector</name><environment>COAST</environment><super>Tools.Trippy.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>SlotDialog</name><environment>COAST</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameterChoicesAspect accessorsListAspect parameter1Aspect parameter2Aspect slotTypeAspect frameClass slotNameAspect slotCodeDefiner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CatINInspector</name><environment>COAST</environment><super>Tools.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>SlotSelectorNavigatorPart</name><environment>COAST</environment><super>Refactory.Browser.SelectorNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectorDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastGenericLauncher</name><environment>COAST</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>usernameAspect volumeAspect serverAspect applicationClassAspect clientClasses client clientClassAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>DebugClusterInfo</name><environment>COAST</environment><super>COAST.CatCSClusterInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>NiceTextCollector</name><environment>COAST</environment><super>UI.TextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastFileLogger</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastLogControl</name><environment>COAST</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logLevelAspect filterChannelsAspect haltOnExceptionsAspect channelsAspect logFileNameAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastProfilingFrame</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>SlotCodeDefiner</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClass package accessorItemsDictionary selectorDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastSlotAwareBrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>slotToComputingDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CatRMInternalMediatorPacketStation</name><environment>COAST</environment><super>COAST.CatRMMediatorPacketStation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientPacketStation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>Hostlist</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastMediatorRemoteControl</name><environment>COAST</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hostAspect portAspect passwordAspect volumesAspect statusAspect mediatorVersion historyList comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastIconLibrary</name><environment>Tools</environment><super>Tools.IconLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CatCSStatisticGC</name><environment>COAST</environment><super>COAST.CatCSGarbageCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>framesPerCluster frameClasses clusterCount writeStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTGarbageCollection</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CatRMInternalClientPacketStation</name><environment>COAST</environment><super>COAST.CatRMClientPacketStation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mediatorPacketStation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>RecentVolume</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume host timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CatRMClientPacketStationWithLatency</name><environment>COAST</environment><super>COAST.CatRMClientPacketStation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>latency </class-inst-vars><imports></imports><category></category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastDeveloperNotifierLocal</name><environment>COAST</environment><super>COAST.CoastNotifierLocal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTViews</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>IterationCounter</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastDeveloperNotifierShared</name><environment>COAST</environment><super>COAST.CoastNotifierShared</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastTrippyFrameInspector</name><environment>COAST</environment><super>COAST.CoastTrippyInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputField slotValues slotNames displayRange </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastTrippyVolumeManagerInspector</name><environment>COAST</environment><super>COAST.CoastTrippyInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>status volumes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastTrippyClusterManagerInspector</name><environment>COAST</environment><super>COAST.CoastTrippyInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterCount info clusterTableAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>NewSlotDialog</name><environment>COAST</environment><super>COAST.SlotDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>invertedSlotNameAspect isConstituentAspect slotRangeAspect slotTypeChoices slotRangeChoicesAspect defaultValueAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CatINClusterInspector</name><environment>COAST</environment><super>COAST.CatINInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameNames frames sorted </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CatINFrameInspector</name><environment>COAST</environment><super>COAST.CatINInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputField slotValues slotNames displayRange objectHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastTrippyClusterInspector</name><environment>COAST</environment><super>COAST.CoastTrippyInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameNames frames status </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastTrippyFrameLookupInspector</name><environment>COAST</environment><super>COAST.CoastTrippyInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastBFSInfoInspector</name><environment>COAST</environment><super>COAST.CoastTrippyInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>infoTextAspect minBlockAspect maxBlockAspect longString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CatINClusterManagerInspector</name><environment>COAST</environment><super>COAST.CatINInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumes cluster clusterCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastTrippyMediatorFrameInspector</name><environment>COAST</environment><super>COAST.CoastTrippyFrameInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastTrippyMediatorClusterManagerInspector</name><environment>COAST</environment><super>COAST.CoastTrippyClusterManagerInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CatMediatorFrameInspector</name><environment>COAST</environment><super>COAST.CatINFrameInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CoastTrippyViewSlotsInspector</name><environment>COAST</environment><super>COAST.CoastTrippyFrameInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COASTDevelopment</package></attributes></class><class><name>CatINMediatorClusterManagerInspector</name><environment>COAST</environment><super>COAST.CatINClusterManagerInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clients clientsOrCluster clientsOrVolumesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COASTDevelopment</package></attributes></class><shared-variable><name>CollectionDict</name><environment>COAST.IterationCounter</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>Core.IdentityDictionary new</initializer><attributes><package>COASTDevelopment</package></attributes></shared-variable><shared-variable><name>ShouldCheckForCoastInstances</name><environment>Core.SystemEventInterest</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COASTDevelopment</package></attributes></shared-variable><shared-variable><name>AvailableChannels</name><environment>COAST.CoastLogControl</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COASTDevelopment</package></attributes></shared-variable><shared-variable><name>LastParameters</name><environment>COAST.SlotDialog</environment><private>false</private><constant>false</constant><category>Accessing</category><initializer>Set new</initializer><attributes><package>COASTDevelopment</package></attributes></shared-variable><shared-variable><name>LastRanges</name><environment>COAST.NewSlotDialog</environment><private>false</private><constant>false</constant><category>Accessing</category><initializer>Set new</initializer><attributes><package>COASTDevelopment</package></attributes></shared-variable><methods><class-id>COAST.CoastProfilingClient</class-id> <category>private</category><body package="COASTDevelopment">inVolume: volumeName atHost: hostName init: initBlock profile: profileBlock 	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #sentNotImplemented&gt;	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #referenceNonPrerequisiteClass&gt;		| cm tm |	self volumeManager defaultHost: hostName.	cm := self volumeManager clusterManagerForVolume: volumeName.	cm isNil ifTrue: [ ^ self ].	tm := cm transactionManager.	initBlock value: cm value: tm.	self class useTimeProfiler 		ifTrue: 		[	#{TimeProfiler} ifDefinedDo: 				[: profClass | ( profClass new )						howOften: 1;						profile: [ profileBlock value: cm value: tm ]				]		]		ifFalse: 		[	Transcript cr;				show: ( Time millisecondsToRun: [ profileBlock value: cm value: tm ]) printString , ' msec'; cr		].</body></methods><methods><class-id>COAST.CoastTrippyInspector class</class-id> <category>resources</category><body package="COASTDevelopment">coastInspectorFigure	"UIMaskEditor new openOnClass: self andSelector: #coastInspectorFigure"	&lt;resource: #image&gt;	^(Image extent: 32@32 depth: 8 bitsPerPixel: 8 palette: (MappedPalette withColors: ((Array new: 158) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 7420 scaledGreen: 3437 scaledBlue: 1060); at: 3 put: (ColorValue scaledRed: 7709 scaledGreen: 5043 scaledBlue: 3469); at: 4 put: (ColorValue scaledRed: 5107 scaledGreen: 2537 scaledBlue: 963); at: 5 put: (ColorValue scaledRed: 6488 scaledGreen: 3469 scaledBlue: 1638); at: 6 put: (ColorValue scaledRed: 5814 scaledGreen: 5235 scaledBlue: 4850); at: 7 put: (ColorValue scaledRed: 7484 scaledGreen: 3661 scaledBlue: 1445); at: 8 put: (ColorValue scaledRed: 4978 scaledGreen: 2794 scaledBlue: 1509); at: 9 put: (ColorValue scaledRed: 5396 scaledGreen: 4400 scaledBlue: 3790); at: 10 put: (ColorValue scaledRed: 6038 scaledGreen: 4689 scaledBlue: 3854); at: 11 put: (ColorValue scaledRed: 6006 scaledGreen: 4721 scaledBlue: 3854); at: 12 put: (ColorValue scaledRed: 7387 scaledGreen: 5621 scaledBlue: 4561); at: 13 put: (ColorValue scaledRed: 4593 scaledGreen: 3115 scaledBlue: 2248); at: 14 put: (ColorValue scaledRed: 7420 scaledGreen: 3437 scaledBlue: 1092); at: 15 put: (ColorValue scaledRed: 5300 scaledGreen: 4175 scaledBlue: 3469); at: 16 put: (ColorValue scaledRed: 7484 scaledGreen: 3822 scaledBlue: 1638); at: 17 put: (ColorValue scaledRed: 3661 scaledGreen: 3212 scaledBlue: 2762); at: 18 put: (ColorValue scaledRed: 4850 scaledGreen: 3340 scaledBlue: 2441); at: 19 put: (ColorValue scaledRed: 7580 scaledGreen: 5332 scaledBlue: 4015); at: 20 put: (ColorValue scaledRed: 5557 scaledGreen: 4400 scaledBlue: 3661); at: 21 put: (ColorValue scaledRed: 6424 scaledGreen: 2987 scaledBlue: 899); at: 22 put: (ColorValue scaledRed: 7034 scaledGreen: 3276 scaledBlue: 995); at: 23 put: (ColorValue scaledRed: 5010 scaledGreen: 3950 scaledBlue: 3340); at: 24 put: (ColorValue scaledRed: 5139 scaledGreen: 2537 scaledBlue: 995); at: 25 put: (ColorValue scaledRed: 4593 scaledGreen: 3308 scaledBlue: 2762); at: 26 put: (ColorValue scaledRed: 5524 scaledGreen: 3276 scaledBlue: 1863); at: 27 put: (ColorValue scaledRed: 7387 scaledGreen: 3340 scaledBlue: 931); at: 28 put: (ColorValue scaledRed: 7130 scaledGreen: 4657 scaledBlue: 3180); at: 29 put: (ColorValue scaledRed: 4978 scaledGreen: 2441 scaledBlue: 931); at: 30 put: (ColorValue scaledRed: 4721 scaledGreen: 2409 scaledBlue: 1220); at: 31 put: (ColorValue scaledRed: 4400 scaledGreen: 2955 scaledBlue: 1991); at: 32 put: (ColorValue scaledRed: 6970 scaledGreen: 3308 scaledBlue: 1060); at: 33 put: (ColorValue scaledRed: 3758 scaledGreen: 2505 scaledBlue: 1766); at: 34 put: (ColorValue scaledRed: 7644 scaledGreen: 4818 scaledBlue: 3180); at: 35 put: (ColorValue scaledRed: 5043 scaledGreen: 2698 scaledBlue: 1284); at: 36 put: (ColorValue scaledRed: 7612 scaledGreen: 4689 scaledBlue: 3019); at: 37 put: (ColorValue scaledRed: 5557 scaledGreen: 5010 scaledBlue: 4753); at: 38 put: (ColorValue scaledRed: 5524 scaledGreen: 2505 scaledBlue: 674); at: 39 put: (ColorValue scaledRed: 7677 scaledGreen: 5075 scaledBlue: 3565); at: 40 put: (ColorValue scaledRed: 7420 scaledGreen: 3469 scaledBlue: 1124); at: 41 put: (ColorValue scaledRed: 7516 scaledGreen: 4207 scaledBlue: 2280); at: 42 put: (ColorValue scaledRed: 6970 scaledGreen: 4336 scaledBlue: 2698); at: 43 put: (ColorValue scaledRed: 4946 scaledGreen: 3340 scaledBlue: 2409); at: 44 put: (ColorValue scaledRed: 4561 scaledGreen: 3372 scaledBlue: 2762); at: 45 put: (ColorValue scaledRed: 4914 scaledGreen: 3661 scaledBlue: 3115); at: 46 put: (ColorValue scaledRed: 256 scaledGreen: 256 scaledBlue: 256); at: 47 put: (ColorValue scaledRed: 7516 scaledGreen: 4079 scaledBlue: 2087); at: 48 put: (ColorValue scaledRed: 6488 scaledGreen: 2987 scaledBlue: 899); at: 49 put: (ColorValue scaledRed: 7644 scaledGreen: 4850 scaledBlue: 3180); at: 50 put: (ColorValue scaledRed: 3726 scaledGreen: 2569 scaledBlue: 1766); at: 51 put: (ColorValue scaledRed: 7420 scaledGreen: 3597 scaledBlue: 1349); at: 52 put: (ColorValue scaledRed: 5203 scaledGreen: 4368 scaledBlue: 3790); at: 53 put: (ColorValue scaledRed: 7837 scaledGreen: 5557 scaledBlue: 4272); at: 54 put: (ColorValue scaledRed: 3308 scaledGreen: 2087 scaledBlue: 1349); at: 55 put: (ColorValue scaledRed: 4818 scaledGreen: 3051 scaledBlue: 2184); at: 56 put: (ColorValue scaledRed: 3404 scaledGreen: 2409 scaledBlue: 1927); at: 57 put: (ColorValue scaledRed: 6167 scaledGreen: 3661 scaledBlue: 2216); at: 58 put: (ColorValue scaledRed: 7484 scaledGreen: 3854 scaledBlue: 1702); at: 59 put: (ColorValue scaledRed: 5910 scaledGreen: 3244 scaledBlue: 1573); at: 60 put: (ColorValue scaledRed: 7580 scaledGreen: 4561 scaledBlue: 2890); at: 61 put: (ColorValue scaledRed: 5717 scaledGreen: 4946 scaledBlue: 4368); at: 62 put: (ColorValue scaledRed: 5171 scaledGreen: 2409 scaledBlue: 835); at: 63 put: (ColorValue scaledRed: 7484 scaledGreen: 3726 scaledBlue: 1509); at: 64 put: (ColorValue scaledRed: 7709 scaledGreen: 5267 scaledBlue: 4047); at: 65 put: (ColorValue scaledRed: 5781 scaledGreen: 2794 scaledBlue: 835); at: 66 put: (ColorValue scaledRed: 4689 scaledGreen: 3212 scaledBlue: 2505); at: 67 put: (ColorValue scaledRed: 7612 scaledGreen: 4497 scaledBlue: 2601); at: 68 put: (ColorValue scaledRed: 5428 scaledGreen: 4786 scaledBlue: 4497); at: 69 put: (ColorValue scaledRed: 7644 scaledGreen: 4850 scaledBlue: 3212); at: 70 put: (ColorValue scaledRed: 5621 scaledGreen: 3950 scaledBlue: 2826); at: 71 put: (ColorValue scaledRed: 4593 scaledGreen: 3147 scaledBlue: 2344); at: 72 put: (ColorValue scaledRed: 7516 scaledGreen: 3983 scaledBlue: 1895); at: 73 put: (ColorValue scaledRed: 6231 scaledGreen: 6231 scaledBlue: 6231); at: 74 put: (ColorValue scaledRed: 7420 scaledGreen: 3469 scaledBlue: 1188); at: 75 put: (ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 76 put: (ColorValue scaledRed: 4175 scaledGreen: 2730 scaledBlue: 1863); at: 77 put: (ColorValue scaledRed: 7580 scaledGreen: 4625 scaledBlue: 2858); at: 78 put: (ColorValue scaledRed: 7420 scaledGreen: 3372 scaledBlue: 963); at: 79 put: (ColorValue scaledRed: 7644 scaledGreen: 4978 scaledBlue: 3437); at: 80 put: (ColorValue scaledRed: 7773 scaledGreen: 5364 scaledBlue: 3918); at: 81 put: (ColorValue scaledRed: 4818 scaledGreen: 2826 scaledBlue: 1798); at: 82 put: (ColorValue scaledRed: 7484 scaledGreen: 4079 scaledBlue: 2184); at: 83 put: (ColorValue scaledRed: 7580 scaledGreen: 4464 scaledBlue: 2698); at: 84 put: (ColorValue scaledRed: 7452 scaledGreen: 3244 scaledBlue: 738); at: 85 put: (ColorValue scaledRed: 7420 scaledGreen: 3629 scaledBlue: 1381); at: 86 put: (ColorValue scaledRed: 4818 scaledGreen: 2762 scaledBlue: 1541); at: 87 put: (ColorValue scaledRed: 4561 scaledGreen: 2794 scaledBlue: 1766); at: 88 put: (ColorValue scaledRed: 7773 scaledGreen: 5621 scaledBlue: 4336); at: 89 put: (ColorValue scaledRed: 7612 scaledGreen: 4753 scaledBlue: 3051); at: 90 put: (ColorValue scaledRed: 7420 scaledGreen: 3501 scaledBlue: 1188); at: 91 put: (ColorValue scaledRed: 7612 scaledGreen: 5492 scaledBlue: 4304); at: 92 put: (ColorValue scaledRed: 5235 scaledGreen: 3372 scaledBlue: 2184); at: 93 put: (ColorValue scaledRed: 5267 scaledGreen: 3693 scaledBlue: 2826); at: 94 put: (ColorValue scaledRed: 4818 scaledGreen: 2441 scaledBlue: 1220); at: 95 put: (ColorValue scaledRed: 7452 scaledGreen: 3758 scaledBlue: 1573); at: 96 put: (ColorValue scaledRed: 4111 scaledGreen: 2055 scaledBlue: 0); at: 97 put: (ColorValue scaledRed: 5428 scaledGreen: 3147 scaledBlue: 1895); at: 98 put: (ColorValue scaledRed: 7163 scaledGreen: 3308 scaledBlue: 995); at: 99 put: (ColorValue scaledRed: 5749 scaledGreen: 2633 scaledBlue: 770); at: 100 put: (ColorValue scaledRed: 5043 scaledGreen: 3983 scaledBlue: 3437); at: 101 put: (ColorValue scaledRed: 7709 scaledGreen: 5267 scaledBlue: 3790); at: 102 put: (ColorValue scaledRed: 7548 scaledGreen: 4015 scaledBlue: 1895); at: 103 put: (ColorValue scaledRed: 5332 scaledGreen: 4753 scaledBlue: 4368); at: 104 put: (ColorValue scaledRed: 5235 scaledGreen: 3469 scaledBlue: 2441); at: 105 put: (ColorValue scaledRed: 5010 scaledGreen: 2152 scaledBlue: 674); at: 106 put: (ColorValue scaledRed: 6488 scaledGreen: 3661 scaledBlue: 1991); at: 107 put: (ColorValue scaledRed: 7677 scaledGreen: 5139 scaledBlue: 3629); at: 108 put: (ColorValue scaledRed: 6327 scaledGreen: 4079 scaledBlue: 2730); at: 109 put: (ColorValue scaledRed: 7130 scaledGreen: 4336 scaledBlue: 2666); at: 110 put: (ColorValue scaledRed: 7548 scaledGreen: 4272 scaledBlue: 2312); at: 111 put: (ColorValue scaledRed: 7644 scaledGreen: 4625 scaledBlue: 2858); at: 112 put: (ColorValue scaledRed: 7387 scaledGreen: 3404 scaledBlue: 1027); at: 113 put: (ColorValue scaledRed: 4818 scaledGreen: 3790 scaledBlue: 3212); at: 114 put: (ColorValue scaledRed: 4721 scaledGreen: 2890 scaledBlue: 1895); at: 115 put: (ColorValue scaledRed: 6584 scaledGreen: 3404 scaledBlue: 1509); at: 116 put: (ColorValue scaledRed: 5653 scaledGreen: 3533 scaledBlue: 2312); at: 117 put: (ColorValue scaledRed: 7420 scaledGreen: 3276 scaledBlue: 803); at: 118 put: (ColorValue scaledRed: 7644 scaledGreen: 4882 scaledBlue: 3276); at: 119 put: (ColorValue scaledRed: 3918 scaledGreen: 2184 scaledBlue: 1092); at: 120 put: (ColorValue scaledRed: 7709 scaledGreen: 5267 scaledBlue: 3822); at: 121 put: (ColorValue scaledRed: 5749 scaledGreen: 2666 scaledBlue: 770); at: 122 put: (ColorValue scaledRed: 5171 scaledGreen: 4368 scaledBlue: 3950); at: 123 put: (ColorValue scaledRed: 4946 scaledGreen: 3533 scaledBlue: 2698); at: 124 put: (ColorValue scaledRed: 4561 scaledGreen: 2312 scaledBlue: 995); at: 125 put: (ColorValue scaledRed: 7420 scaledGreen: 3533 scaledBlue: 1220); at: 126 put: (ColorValue scaledRed: 7677 scaledGreen: 5139 scaledBlue: 3661); at: 127 put: (ColorValue scaledRed: 4432 scaledGreen: 2698 scaledBlue: 1734); at: 128 put: (ColorValue scaledRed: 4304 scaledGreen: 2730 scaledBlue: 1830); at: 129 put: (ColorValue scaledRed: 7709 scaledGreen: 5139 scaledBlue: 3629); at: 130 put: (ColorValue scaledRed: 4818 scaledGreen: 3340 scaledBlue: 2698); at: 131 put: (ColorValue scaledRed: 7420 scaledGreen: 3404 scaledBlue: 1027); at: 132 put: (ColorValue scaledRed: 7805 scaledGreen: 5396 scaledBlue: 3950); at: 133 put: (ColorValue scaledRed: 5171 scaledGreen: 3212 scaledBlue: 2152); at: 134 put: (ColorValue scaledRed: 7387 scaledGreen: 3276 scaledBlue: 867); at: 135 put: (ColorValue scaledRed: 7452 scaledGreen: 3661 scaledBlue: 1413); at: 136 put: (ColorValue scaledRed: 5749 scaledGreen: 2666 scaledBlue: 803); at: 137 put: (ColorValue scaledRed: 4753 scaledGreen: 3244 scaledBlue: 2216); at: 138 put: (ColorValue scaledRed: 7420 scaledGreen: 3533 scaledBlue: 1252); at: 139 put: (ColorValue scaledRed: 4336 scaledGreen: 2730 scaledBlue: 1830); at: 140 put: (ColorValue scaledRed: 4850 scaledGreen: 4368 scaledBlue: 3983); at: 141 put: (ColorValue scaledRed: 5781 scaledGreen: 4946 scaledBlue: 4464); at: 142 put: (ColorValue scaledRed: 3533 scaledGreen: 2376 scaledBlue: 1670); at: 143 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 144 put: (ColorValue scaledRed: 5878 scaledGreen: 3661 scaledBlue: 2344); at: 145 put: (ColorValue scaledRed: 7612 scaledGreen: 5043 scaledBlue: 3533); at: 146 put: (ColorValue scaledRed: 5203 scaledGreen: 2505 scaledBlue: 867); at: 147 put: (ColorValue scaledRed: 7644 scaledGreen: 5043 scaledBlue: 3501); at: 148 put: (ColorValue scaledRed: 7484 scaledGreen: 3404 scaledBlue: 995); at: 149 put: (ColorValue scaledRed: 4946 scaledGreen: 3276 scaledBlue: 2344); at: 150 put: (ColorValue scaledRed: 4689 scaledGreen: 2473 scaledBlue: 1092); at: 151 put: (ColorValue scaledRed: 6103 scaledGreen: 2987 scaledBlue: 1156); at: 152 put: (ColorValue scaledRed: 6424 scaledGreen: 2955 scaledBlue: 867); at: 153 put: (ColorValue scaledRed: 7612 scaledGreen: 4786 scaledBlue: 3147); at: 154 put: (ColorValue scaledRed: 4946 scaledGreen: 2312 scaledBlue: 674); at: 155 put: (ColorValue scaledRed: 4753 scaledGreen: 2730 scaledBlue: 1445); at: 156 put: (ColorValue scaledRed: 4946 scaledGreen: 2633 scaledBlue: 1349); at: 157 put: (ColorValue scaledRed: 7548 scaledGreen: 4304 scaledBlue: 2376); at: 158 put: (ColorValue scaledRed: 5043 scaledGreen: 3019 scaledBlue: 1863); yourself)) usingBits: (ByteArray fromPackedString: 'R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR @@@@@@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)J@@@@KU=_W0@@@@AJR$)JR$)JR$)JR$)JR$)JR$)J@@@@W5&lt;S 7BN#%=_@@@@R$)JR$)JR$)JR$)JR$)JR @@W5&gt;N#")SUX:N#(9_W0@@R$)JR$)JR$)JR$)JR$(@@E&gt;N#(:NFG4I#(:N#(:NW0@@R$)JR$)JR$)JR$)J@@A_#(:N#(8WST6D#(:N#(:NW0@@R$)JR$)JR$)JR$(@W8:N#(:N#%ANHY6N#(:N#(:NW0AJR$)JR$)JR$)J@@A_#(:N#(:NZB\M!8:N#(:N#$!_@@AJR$)JR$)JR$(@W8:N#(:N#(9]YBM+#(:N#(:N#(9_@D)JR$)JR$)JR A__''(N\VNN# \O!)ZN#''%?Y10"$U&lt;@R$)JR$)JR$(@@E$BK#A4D'' ^#VDA&amp;S\=B4H?N5!"^0@@R$)JR$)JR A_&amp;"VPRUPZ!T&lt;/XPDT[G]QQFTYJ8:NW0AJR$)JR$)J@E&gt;N##U2MD1*F DA@PE&lt;I X:HH:N#(9_@D)JR$)JR$(@W8:N#(0QGTFW@PDA@XH8&amp;4NN#(:N#%&lt;@R$)JR$)JR @@#(:N#(:N"0Q/@PDAW "J#(:N#(:N@@AJR$)JR$)JR A_#(:N#(9FU66OG9"IJE)[L8:N#%&lt;@R$)JR$)JR$)J@E&gt;N#(:N#)R\NX PQV:RL%HJOH:NW0AJR$)JR$)JR$(@@E&gt;N#(:NM#:@KH:NCE13ZYNU#%&lt;@@D)JR$)JR$)JR$(@W8:N#(:A]Q-&amp;#(:N#(8ER4@$W0AJR$)JR$)JR$)JR @@W8:N#%YGXH:N#(:N#(:NLU&lt;@@D)JR$)JR$)JR$)JR @@W8:N@2$V#(:N#(:N#(9_@@@@R$)JR$)JR$)JR$)JR @@W5&lt;U](:N#(:N#(9_W0@@W5&lt;@R$)JR$)JR$)JR$)JR @@@E=_#(:N#(9_W0@@@@A_W5&lt;@R$)JR$)JR$)JR$)JR$(@@@@@W5=_@@@@@D)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR @@@@@@R$)JR$)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W5=JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W0@a'))</body><body package="COASTDevelopment">coastInspectorMask	"UIMaskEditor new openOnClass: self andSelector: #coastInspectorMask"	&lt;resource: #image&gt;	^(Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 255 255 0 1 255 255 128 7 255 255 224 15 255 255 240 31 255 255 248 63 255 255 252 63 255 255 252 127 255 255 254 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 127 255 255 254 63 255 255 252 63 255 255 252 31 255 255 248 15 255 255 240 7 255 255 224 1 255 255 128 0 255 255 0])</body></methods><methods><class-id>COAST.SlotDialog class</class-id> <category>interface specs</category><body package="COASTDevelopment">accessorsSpec	"Tools.UIPainter new openOnClass: self andSelector: #accessorsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#bounds: #(#{Graphics.Rectangle} 640 512 1002 810 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 30 0 -5 1 -60 1 ) 					#name: #List1 					#model: #accessorsListAspect 					#multipleSelections: true 					#selectionType: #checkMark ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 -53 1 -5 1 -30 1 ) 					#name: #ComboBox3 					#model: #parameter1Aspect 					#isReadOnly: false 					#comboList: #parameterChoicesAspect ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 -26 1 -5 1 -3 1 ) 					#name: #ComboBox2 					#model: #parameter2Aspect 					#isReadOnly: false 					#comboList: #parameterChoicesAspect ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 5 ) 					#name: #Label1 					#label: 'Create accessors:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 4 0 -25 1 ) 					#name: #Label2 					#label: 'Parameter 2:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 4 0 -52 1 ) 					#name: #Label3 					#label: 'Parameter 1:' ) ) ) )</body><body package="COASTDevelopment">embeddedSpec	"UIPainter new openOnClass: self andSelector: #embeddedSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 640 480 1002 778 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 5 0 -5 1 28 0 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #slotNameAspect 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 30 0 0 1 0 1 ) 					#name: #Subcanvas1 					#flags: 0 					#minorKey: #accessorsSpec ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 5 ) 					#name: #Label4 					#label: 'Slot name:' ) ) ) )</body><body package="COASTDevelopment">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Slot' 			#min: #(#{Core.Point} 100 200 ) 			#max: #(#{Core.Point} 1280 960 ) 			#bounds: #(#{Graphics.Rectangle} 640 467 990 862 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -35 1 ) 					#name: #Subcanvas1 					#flags: 0 					#minorKey: #embeddedSpec ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -173 1 -30 1 -92 1 -5 1 ) 					#model: #coastOk 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -86 1 -30 1 -5 1 -5 1 ) 					#model: #coastCancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>COAST.CatINInspector class</class-id> <category>resources</category><body package="COASTDevelopment">coastInspectorFigure	"UIMaskEditor new openOnClass: self andSelector: #coastInspectorFigure"	&lt;resource: #image&gt;	^(Image extent: 32@32 depth: 8 bitsPerPixel: 8 palette: (MappedPalette withColors: ((Array new: 158) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 7420 scaledGreen: 3437 scaledBlue: 1060); at: 3 put: (ColorValue scaledRed: 7709 scaledGreen: 5043 scaledBlue: 3469); at: 4 put: (ColorValue scaledRed: 5107 scaledGreen: 2537 scaledBlue: 963); at: 5 put: (ColorValue scaledRed: 6488 scaledGreen: 3469 scaledBlue: 1638); at: 6 put: (ColorValue scaledRed: 5814 scaledGreen: 5235 scaledBlue: 4850); at: 7 put: (ColorValue scaledRed: 7484 scaledGreen: 3661 scaledBlue: 1445); at: 8 put: (ColorValue scaledRed: 4978 scaledGreen: 2794 scaledBlue: 1509); at: 9 put: (ColorValue scaledRed: 5396 scaledGreen: 4400 scaledBlue: 3790); at: 10 put: (ColorValue scaledRed: 6038 scaledGreen: 4689 scaledBlue: 3854); at: 11 put: (ColorValue scaledRed: 6006 scaledGreen: 4721 scaledBlue: 3854); at: 12 put: (ColorValue scaledRed: 7387 scaledGreen: 5621 scaledBlue: 4561); at: 13 put: (ColorValue scaledRed: 4593 scaledGreen: 3115 scaledBlue: 2248); at: 14 put: (ColorValue scaledRed: 7420 scaledGreen: 3437 scaledBlue: 1092); at: 15 put: (ColorValue scaledRed: 5300 scaledGreen: 4175 scaledBlue: 3469); at: 16 put: (ColorValue scaledRed: 7484 scaledGreen: 3822 scaledBlue: 1638); at: 17 put: (ColorValue scaledRed: 3661 scaledGreen: 3212 scaledBlue: 2762); at: 18 put: (ColorValue scaledRed: 4850 scaledGreen: 3340 scaledBlue: 2441); at: 19 put: (ColorValue scaledRed: 7580 scaledGreen: 5332 scaledBlue: 4015); at: 20 put: (ColorValue scaledRed: 5557 scaledGreen: 4400 scaledBlue: 3661); at: 21 put: (ColorValue scaledRed: 6424 scaledGreen: 2987 scaledBlue: 899); at: 22 put: (ColorValue scaledRed: 7034 scaledGreen: 3276 scaledBlue: 995); at: 23 put: (ColorValue scaledRed: 5010 scaledGreen: 3950 scaledBlue: 3340); at: 24 put: (ColorValue scaledRed: 5139 scaledGreen: 2537 scaledBlue: 995); at: 25 put: (ColorValue scaledRed: 4593 scaledGreen: 3308 scaledBlue: 2762); at: 26 put: (ColorValue scaledRed: 5524 scaledGreen: 3276 scaledBlue: 1863); at: 27 put: (ColorValue scaledRed: 7387 scaledGreen: 3340 scaledBlue: 931); at: 28 put: (ColorValue scaledRed: 7130 scaledGreen: 4657 scaledBlue: 3180); at: 29 put: (ColorValue scaledRed: 4978 scaledGreen: 2441 scaledBlue: 931); at: 30 put: (ColorValue scaledRed: 4721 scaledGreen: 2409 scaledBlue: 1220); at: 31 put: (ColorValue scaledRed: 4400 scaledGreen: 2955 scaledBlue: 1991); at: 32 put: (ColorValue scaledRed: 6970 scaledGreen: 3308 scaledBlue: 1060); at: 33 put: (ColorValue scaledRed: 3758 scaledGreen: 2505 scaledBlue: 1766); at: 34 put: (ColorValue scaledRed: 7644 scaledGreen: 4818 scaledBlue: 3180); at: 35 put: (ColorValue scaledRed: 5043 scaledGreen: 2698 scaledBlue: 1284); at: 36 put: (ColorValue scaledRed: 7612 scaledGreen: 4689 scaledBlue: 3019); at: 37 put: (ColorValue scaledRed: 5557 scaledGreen: 5010 scaledBlue: 4753); at: 38 put: (ColorValue scaledRed: 5524 scaledGreen: 2505 scaledBlue: 674); at: 39 put: (ColorValue scaledRed: 7677 scaledGreen: 5075 scaledBlue: 3565); at: 40 put: (ColorValue scaledRed: 7420 scaledGreen: 3469 scaledBlue: 1124); at: 41 put: (ColorValue scaledRed: 7516 scaledGreen: 4207 scaledBlue: 2280); at: 42 put: (ColorValue scaledRed: 6970 scaledGreen: 4336 scaledBlue: 2698); at: 43 put: (ColorValue scaledRed: 4946 scaledGreen: 3340 scaledBlue: 2409); at: 44 put: (ColorValue scaledRed: 4561 scaledGreen: 3372 scaledBlue: 2762); at: 45 put: (ColorValue scaledRed: 4914 scaledGreen: 3661 scaledBlue: 3115); at: 46 put: (ColorValue scaledRed: 256 scaledGreen: 256 scaledBlue: 256); at: 47 put: (ColorValue scaledRed: 7516 scaledGreen: 4079 scaledBlue: 2087); at: 48 put: (ColorValue scaledRed: 6488 scaledGreen: 2987 scaledBlue: 899); at: 49 put: (ColorValue scaledRed: 7644 scaledGreen: 4850 scaledBlue: 3180); at: 50 put: (ColorValue scaledRed: 3726 scaledGreen: 2569 scaledBlue: 1766); at: 51 put: (ColorValue scaledRed: 7420 scaledGreen: 3597 scaledBlue: 1349); at: 52 put: (ColorValue scaledRed: 5203 scaledGreen: 4368 scaledBlue: 3790); at: 53 put: (ColorValue scaledRed: 7837 scaledGreen: 5557 scaledBlue: 4272); at: 54 put: (ColorValue scaledRed: 3308 scaledGreen: 2087 scaledBlue: 1349); at: 55 put: (ColorValue scaledRed: 4818 scaledGreen: 3051 scaledBlue: 2184); at: 56 put: (ColorValue scaledRed: 3404 scaledGreen: 2409 scaledBlue: 1927); at: 57 put: (ColorValue scaledRed: 6167 scaledGreen: 3661 scaledBlue: 2216); at: 58 put: (ColorValue scaledRed: 7484 scaledGreen: 3854 scaledBlue: 1702); at: 59 put: (ColorValue scaledRed: 5910 scaledGreen: 3244 scaledBlue: 1573); at: 60 put: (ColorValue scaledRed: 7580 scaledGreen: 4561 scaledBlue: 2890); at: 61 put: (ColorValue scaledRed: 5717 scaledGreen: 4946 scaledBlue: 4368); at: 62 put: (ColorValue scaledRed: 5171 scaledGreen: 2409 scaledBlue: 835); at: 63 put: (ColorValue scaledRed: 7484 scaledGreen: 3726 scaledBlue: 1509); at: 64 put: (ColorValue scaledRed: 7709 scaledGreen: 5267 scaledBlue: 4047); at: 65 put: (ColorValue scaledRed: 5781 scaledGreen: 2794 scaledBlue: 835); at: 66 put: (ColorValue scaledRed: 4689 scaledGreen: 3212 scaledBlue: 2505); at: 67 put: (ColorValue scaledRed: 7612 scaledGreen: 4497 scaledBlue: 2601); at: 68 put: (ColorValue scaledRed: 5428 scaledGreen: 4786 scaledBlue: 4497); at: 69 put: (ColorValue scaledRed: 7644 scaledGreen: 4850 scaledBlue: 3212); at: 70 put: (ColorValue scaledRed: 5621 scaledGreen: 3950 scaledBlue: 2826); at: 71 put: (ColorValue scaledRed: 4593 scaledGreen: 3147 scaledBlue: 2344); at: 72 put: (ColorValue scaledRed: 7516 scaledGreen: 3983 scaledBlue: 1895); at: 73 put: (ColorValue scaledRed: 6231 scaledGreen: 6231 scaledBlue: 6231); at: 74 put: (ColorValue scaledRed: 7420 scaledGreen: 3469 scaledBlue: 1188); at: 75 put: (ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 76 put: (ColorValue scaledRed: 4175 scaledGreen: 2730 scaledBlue: 1863); at: 77 put: (ColorValue scaledRed: 7580 scaledGreen: 4625 scaledBlue: 2858); at: 78 put: (ColorValue scaledRed: 7420 scaledGreen: 3372 scaledBlue: 963); at: 79 put: (ColorValue scaledRed: 7644 scaledGreen: 4978 scaledBlue: 3437); at: 80 put: (ColorValue scaledRed: 7773 scaledGreen: 5364 scaledBlue: 3918); at: 81 put: (ColorValue scaledRed: 4818 scaledGreen: 2826 scaledBlue: 1798); at: 82 put: (ColorValue scaledRed: 7484 scaledGreen: 4079 scaledBlue: 2184); at: 83 put: (ColorValue scaledRed: 7580 scaledGreen: 4464 scaledBlue: 2698); at: 84 put: (ColorValue scaledRed: 7452 scaledGreen: 3244 scaledBlue: 738); at: 85 put: (ColorValue scaledRed: 7420 scaledGreen: 3629 scaledBlue: 1381); at: 86 put: (ColorValue scaledRed: 4818 scaledGreen: 2762 scaledBlue: 1541); at: 87 put: (ColorValue scaledRed: 4561 scaledGreen: 2794 scaledBlue: 1766); at: 88 put: (ColorValue scaledRed: 7773 scaledGreen: 5621 scaledBlue: 4336); at: 89 put: (ColorValue scaledRed: 7612 scaledGreen: 4753 scaledBlue: 3051); at: 90 put: (ColorValue scaledRed: 7420 scaledGreen: 3501 scaledBlue: 1188); at: 91 put: (ColorValue scaledRed: 7612 scaledGreen: 5492 scaledBlue: 4304); at: 92 put: (ColorValue scaledRed: 5235 scaledGreen: 3372 scaledBlue: 2184); at: 93 put: (ColorValue scaledRed: 5267 scaledGreen: 3693 scaledBlue: 2826); at: 94 put: (ColorValue scaledRed: 4818 scaledGreen: 2441 scaledBlue: 1220); at: 95 put: (ColorValue scaledRed: 7452 scaledGreen: 3758 scaledBlue: 1573); at: 96 put: (ColorValue scaledRed: 4111 scaledGreen: 2055 scaledBlue: 0); at: 97 put: (ColorValue scaledRed: 5428 scaledGreen: 3147 scaledBlue: 1895); at: 98 put: (ColorValue scaledRed: 7163 scaledGreen: 3308 scaledBlue: 995); at: 99 put: (ColorValue scaledRed: 5749 scaledGreen: 2633 scaledBlue: 770); at: 100 put: (ColorValue scaledRed: 5043 scaledGreen: 3983 scaledBlue: 3437); at: 101 put: (ColorValue scaledRed: 7709 scaledGreen: 5267 scaledBlue: 3790); at: 102 put: (ColorValue scaledRed: 7548 scaledGreen: 4015 scaledBlue: 1895); at: 103 put: (ColorValue scaledRed: 5332 scaledGreen: 4753 scaledBlue: 4368); at: 104 put: (ColorValue scaledRed: 5235 scaledGreen: 3469 scaledBlue: 2441); at: 105 put: (ColorValue scaledRed: 5010 scaledGreen: 2152 scaledBlue: 674); at: 106 put: (ColorValue scaledRed: 6488 scaledGreen: 3661 scaledBlue: 1991); at: 107 put: (ColorValue scaledRed: 7677 scaledGreen: 5139 scaledBlue: 3629); at: 108 put: (ColorValue scaledRed: 6327 scaledGreen: 4079 scaledBlue: 2730); at: 109 put: (ColorValue scaledRed: 7130 scaledGreen: 4336 scaledBlue: 2666); at: 110 put: (ColorValue scaledRed: 7548 scaledGreen: 4272 scaledBlue: 2312); at: 111 put: (ColorValue scaledRed: 7644 scaledGreen: 4625 scaledBlue: 2858); at: 112 put: (ColorValue scaledRed: 7387 scaledGreen: 3404 scaledBlue: 1027); at: 113 put: (ColorValue scaledRed: 4818 scaledGreen: 3790 scaledBlue: 3212); at: 114 put: (ColorValue scaledRed: 4721 scaledGreen: 2890 scaledBlue: 1895); at: 115 put: (ColorValue scaledRed: 6584 scaledGreen: 3404 scaledBlue: 1509); at: 116 put: (ColorValue scaledRed: 5653 scaledGreen: 3533 scaledBlue: 2312); at: 117 put: (ColorValue scaledRed: 7420 scaledGreen: 3276 scaledBlue: 803); at: 118 put: (ColorValue scaledRed: 7644 scaledGreen: 4882 scaledBlue: 3276); at: 119 put: (ColorValue scaledRed: 3918 scaledGreen: 2184 scaledBlue: 1092); at: 120 put: (ColorValue scaledRed: 7709 scaledGreen: 5267 scaledBlue: 3822); at: 121 put: (ColorValue scaledRed: 5749 scaledGreen: 2666 scaledBlue: 770); at: 122 put: (ColorValue scaledRed: 5171 scaledGreen: 4368 scaledBlue: 3950); at: 123 put: (ColorValue scaledRed: 4946 scaledGreen: 3533 scaledBlue: 2698); at: 124 put: (ColorValue scaledRed: 4561 scaledGreen: 2312 scaledBlue: 995); at: 125 put: (ColorValue scaledRed: 7420 scaledGreen: 3533 scaledBlue: 1220); at: 126 put: (ColorValue scaledRed: 7677 scaledGreen: 5139 scaledBlue: 3661); at: 127 put: (ColorValue scaledRed: 4432 scaledGreen: 2698 scaledBlue: 1734); at: 128 put: (ColorValue scaledRed: 4304 scaledGreen: 2730 scaledBlue: 1830); at: 129 put: (ColorValue scaledRed: 7709 scaledGreen: 5139 scaledBlue: 3629); at: 130 put: (ColorValue scaledRed: 4818 scaledGreen: 3340 scaledBlue: 2698); at: 131 put: (ColorValue scaledRed: 7420 scaledGreen: 3404 scaledBlue: 1027); at: 132 put: (ColorValue scaledRed: 7805 scaledGreen: 5396 scaledBlue: 3950); at: 133 put: (ColorValue scaledRed: 5171 scaledGreen: 3212 scaledBlue: 2152); at: 134 put: (ColorValue scaledRed: 7387 scaledGreen: 3276 scaledBlue: 867); at: 135 put: (ColorValue scaledRed: 7452 scaledGreen: 3661 scaledBlue: 1413); at: 136 put: (ColorValue scaledRed: 5749 scaledGreen: 2666 scaledBlue: 803); at: 137 put: (ColorValue scaledRed: 4753 scaledGreen: 3244 scaledBlue: 2216); at: 138 put: (ColorValue scaledRed: 7420 scaledGreen: 3533 scaledBlue: 1252); at: 139 put: (ColorValue scaledRed: 4336 scaledGreen: 2730 scaledBlue: 1830); at: 140 put: (ColorValue scaledRed: 4850 scaledGreen: 4368 scaledBlue: 3983); at: 141 put: (ColorValue scaledRed: 5781 scaledGreen: 4946 scaledBlue: 4464); at: 142 put: (ColorValue scaledRed: 3533 scaledGreen: 2376 scaledBlue: 1670); at: 143 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 144 put: (ColorValue scaledRed: 5878 scaledGreen: 3661 scaledBlue: 2344); at: 145 put: (ColorValue scaledRed: 7612 scaledGreen: 5043 scaledBlue: 3533); at: 146 put: (ColorValue scaledRed: 5203 scaledGreen: 2505 scaledBlue: 867); at: 147 put: (ColorValue scaledRed: 7644 scaledGreen: 5043 scaledBlue: 3501); at: 148 put: (ColorValue scaledRed: 7484 scaledGreen: 3404 scaledBlue: 995); at: 149 put: (ColorValue scaledRed: 4946 scaledGreen: 3276 scaledBlue: 2344); at: 150 put: (ColorValue scaledRed: 4689 scaledGreen: 2473 scaledBlue: 1092); at: 151 put: (ColorValue scaledRed: 6103 scaledGreen: 2987 scaledBlue: 1156); at: 152 put: (ColorValue scaledRed: 6424 scaledGreen: 2955 scaledBlue: 867); at: 153 put: (ColorValue scaledRed: 7612 scaledGreen: 4786 scaledBlue: 3147); at: 154 put: (ColorValue scaledRed: 4946 scaledGreen: 2312 scaledBlue: 674); at: 155 put: (ColorValue scaledRed: 4753 scaledGreen: 2730 scaledBlue: 1445); at: 156 put: (ColorValue scaledRed: 4946 scaledGreen: 2633 scaledBlue: 1349); at: 157 put: (ColorValue scaledRed: 7548 scaledGreen: 4304 scaledBlue: 2376); at: 158 put: (ColorValue scaledRed: 5043 scaledGreen: 3019 scaledBlue: 1863); yourself)) usingBits: (ByteArray fromPackedString: 'R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR @@@@@@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)J@@@@KU=_W0@@@@AJR$)JR$)JR$)JR$)JR$)JR$)J@@@@W5&lt;S 7BN#%=_@@@@R$)JR$)JR$)JR$)JR$)JR @@W5&gt;N#")SUX:N#(9_W0@@R$)JR$)JR$)JR$)JR$(@@E&gt;N#(:NFG4I#(:N#(:NW0@@R$)JR$)JR$)JR$)J@@A_#(:N#(8WST6D#(:N#(:NW0@@R$)JR$)JR$)JR$(@W8:N#(:N#%ANHY6N#(:N#(:NW0AJR$)JR$)JR$)J@@A_#(:N#(:NZB\M!8:N#(:N#$!_@@AJR$)JR$)JR$(@W8:N#(:N#(9]YBM+#(:N#(:N#(9_@D)JR$)JR$)JR A__''(N\VNN# \O!)ZN#''%?Y10"$U&lt;@R$)JR$)JR$(@@E$BK#A4D'' ^#VDA&amp;S\=B4H?N5!"^0@@R$)JR$)JR A_&amp;"VPRUPZ!T&lt;/XPDT[G]QQFTYJ8:NW0AJR$)JR$)J@E&gt;N##U2MD1*F DA@PE&lt;I X:HH:N#(9_@D)JR$)JR$(@W8:N#(0QGTFW@PDA@XH8&amp;4NN#(:N#%&lt;@R$)JR$)JR @@#(:N#(:N"0Q/@PDAW "J#(:N#(:N@@AJR$)JR$)JR A_#(:N#(9FU66OG9"IJE)[L8:N#%&lt;@R$)JR$)JR$)J@E&gt;N#(:N#)R\NX PQV:RL%HJOH:NW0AJR$)JR$)JR$(@@E&gt;N#(:NM#:@KH:NCE13ZYNU#%&lt;@@D)JR$)JR$)JR$(@W8:N#(:A]Q-&amp;#(:N#(8ER4@$W0AJR$)JR$)JR$)JR @@W8:N#%YGXH:N#(:N#(:NLU&lt;@@D)JR$)JR$)JR$)JR @@W8:N@2$V#(:N#(:N#(9_@@@@R$)JR$)JR$)JR$)JR @@W5&lt;U](:N#(:N#(9_W0@@W5&lt;@R$)JR$)JR$)JR$)JR @@@E=_#(:N#(9_W0@@@@A_W5&lt;@R$)JR$)JR$)JR$)JR$(@@@@@W5=_@@@@@D)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR @@@@@@R$)JR$)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W5&lt;@R$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W5=JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR$)JR A_W0@a'))</body><body package="COASTDevelopment">coastInspectorMask	"UIMaskEditor new openOnClass: self andSelector: #coastInspectorMask"	&lt;resource: #image&gt;	^(Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 255 255 0 1 255 255 128 7 255 255 224 15 255 255 240 31 255 255 248 63 255 255 252 63 255 255 252 127 255 255 254 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 127 255 255 254 63 255 255 252 63 255 255 252 31 255 255 248 15 255 255 240 7 255 255 224 1 255 255 128 0 255 255 0])</body></methods><methods><class-id>COAST.SlotSelectorNavigatorPart class</class-id> <category>resources</category><body package="COASTDevelopment">slotMenu	"Tools.MenuEditor new openOnClass: self andSelector: #slotMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Create Slot...' 				#value: #createSlot ) 			#(#{UI.MenuItem} 				#rawLabel: 'Create Accessors...' 				#value: #createSlotAccessors 				#enablementSelector: #isSlotSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 'Browse References' 				#value: #browseSlotReferences 				#enablementSelector: #isSlotSelected ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>COAST.CoastGenericLauncher class</class-id> <category>resources</category><body package="COASTDevelopment">coastLogo	"UIMaskEditor new openOnClass: self andSelector: #coastLogo"	&lt;resource: #image&gt;	^(Image extent: 40@40 depth: 5 bitsPerPixel: 8 palette: (MappedPalette withColors: ((Array new: 29) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 528 scaledGreen: 528 scaledBlue: 528); at: 4 put: (ColorValue scaledRed: 3963 scaledGreen: 3963 scaledBlue: 2113); at: 5 put: (ColorValue scaledRed: 1056 scaledGreen: 1056 scaledBlue: 1056); at: 6 put: (ColorValue scaledRed: 6077 scaledGreen: 2642 scaledBlue: 2113); at: 7 put: (ColorValue scaledRed: 8191 scaledGreen: 2642 scaledBlue: 0); at: 8 put: (ColorValue scaledRed: 1585 scaledGreen: 1585 scaledBlue: 1585); at: 9 put: (ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); at: 10 put: (ColorValue scaledRed: 6077 scaledGreen: 3963 scaledBlue: 3963); at: 11 put: (ColorValue scaledRed: 2642 scaledGreen: 2642 scaledBlue: 2642); at: 12 put: (ColorValue scaledRed: 3963 scaledGreen: 2642 scaledBlue: 2113); at: 13 put: (ColorValue scaledRed: 6077 scaledGreen: 2642 scaledBlue: 0); at: 14 put: (ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 15 put: (ColorValue scaledRed: 3699 scaledGreen: 3699 scaledBlue: 3699); at: 16 put: (ColorValue scaledRed: 3963 scaledGreen: 3963 scaledBlue: 3963); at: 17 put: (ColorValue scaledRed: 4491 scaledGreen: 4491 scaledBlue: 4491); at: 18 put: (ColorValue scaledRed: 8191 scaledGreen: 3963 scaledBlue: 2113); at: 19 put: (ColorValue scaledRed: 3963 scaledGreen: 2642 scaledBlue: 0); at: 20 put: (ColorValue scaledRed: 5020 scaledGreen: 5020 scaledBlue: 5020); at: 21 put: (ColorValue scaledRed: 8191 scaledGreen: 5548 scaledBlue: 2113); at: 22 put: (ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 23 put: (ColorValue scaledRed: 6077 scaledGreen: 6077 scaledBlue: 6077); at: 24 put: (ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); at: 25 put: (ColorValue scaledRed: 6077 scaledGreen: 3963 scaledBlue: 2113); at: 26 put: (ColorValue scaledRed: 8191 scaledGreen: 2642 scaledBlue: 2113); at: 27 put: (ColorValue scaledRed: 3963 scaledGreen: 1321 scaledBlue: 0); at: 28 put: (ColorValue scaledRed: 7134 scaledGreen: 7134 scaledBlue: 7134); at: 29 put: (ColorValue scaledRed: 7662 scaledGreen: 7662 scaledBlue: 7662); yourself)) usingBits: (ByteArray fromPackedString: '@@\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\G@@\A@PDA@PDA@PDAF0DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDAE!(A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDA@QTLE DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PDA@PDSFP&lt;A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDAC0TKG@DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDA@P,XCAXA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PDA@PDKDQDC@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDAB0XYB0DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DAGA,[F1,A@P,YDP,A@Q\SD1LSE DA@PDA@PDA@PDA@PDA@PDAA0\\C 0LF@TKAQ@KFP0KEP,EAPTECA([@PDA@PDA@PDA@PDA@PDA@P\GD00LAQDYA!$QF TEF TYDQDEB1L\@PDA@PDA@PDA@PDA@PDA@PDGA10W@QTKFA$YAQ$YFQ$YFQ KE DA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDAGALIB1HXFQ$FC@,SG@DA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@Q\EA!$FA! KD10A@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDPAQDKCAPYF@TMG@DA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PDADA$QCQTKAPTFAP&lt;A@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@P&lt;XFQLAGAXUB0,KF0DA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDPAPT[@PDA@PD[B1TA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PDABPXM@PDA@PDA@QTV@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDAF1HKG@DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@P8KF0DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PD[E DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PD\D0&lt;PEQ0A@Q\PD@&lt;[@PDA@Q,U@PDA@QLOEQ0OD@&lt;PC1@V@P\G@PD[@ \PC0 M@QT@B!TJ@!\A@PDM@A0A@P8DD0 WCP4GA@4MEPDGA0DAA04A@PDAGA\@E0DA@QTBF0D\@ \S@PDMD0DAG@DAD0(A@PDAA0\AF0@\@PDA@PDOB DA@PDAA1TAC04V@ DAD0@O@PDA@QLJ@PDA@P\G@QXG@PDA@PDACP8A@PDA@P(S@PPWG@\V@PDV@ (\@PDSB DA@PDGA0D\@A,A@PDA@QLD@PDA@PDBE!T@A0\DBA0A@Q0DD0DAD0(A@PDAA0\A@P8HE0DAF1T\A@8\@Q0JA0DHEPDA@PHVE!0AB!LA@QLJ@PDA@P\G@PDAC @GA@@U@Q0J@@\@B!0V@ DA@PDNCQ@BA@P[@PDSB DA@PDGA0DA@PD\E!XA@PDA@Q\VF0DAE1\A@PDAGAXAF1XA@PDAF1\A@PDAA0\A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDG@@\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\G@@@a'))</body></methods><methods><class-id>COAST.CoastGenericLauncher class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'COAST Generic Launcher' 			#min: #(#{Core.Point} 363 177 ) 			#max: #(#{Core.Point} 640 177 ) 			#bounds: #(#{Graphics.Rectangle} 841 554 1257 731 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 8 ) 					#name: #clientLabel 					#label: 'Client Class' 					#style: #default ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 94 0 8 0 -95 1 32 0 ) 					#name: #clientClass 					#model: #clientClassAspect 					#style: #default 					#type: #string 					#comboList: #clientClasses ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 36 ) 					#name: #applicationLabel 					#label: 'App. Class' 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 94 0 36 0 -95 1 60 0 ) 					#name: #applicationClassID 					#model: #applicationClassAspect 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 64 ) 					#name: #serverLabel 					#label: 'Mediator' 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 94 0 64 0 -95 1 88 0 ) 					#name: #serverID 					#model: #serverAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateServer ) 					#style: #default ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 64 0 -5 1 87 0 ) 					#name: #checkServerID 					#model: #checkServer 					#label: 'Check...' 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 92 ) 					#name: #volumeLabel 					#label: 'Volume' 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 94 0 92 0 -95 1 116 0 ) 					#name: #volumeID 					#model: #volumeAspect 					#style: #default ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 92 0 -5 1 116 0 ) 					#name: #browseVolumeID 					#model: #browseVolume 					#label: 'Browse...' 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 3 120 ) 					#name: #userLabel 					#label: 'Username' 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 94 0 120 0 -95 1 144 0 ) 					#name: #usernameID 					#model: #usernameAspect 					#style: #default ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 120 0 -5 1 144 0 ) 					#name: #browseUsernameID 					#model: #browseUsername 					#label: 'Browse...' 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 148 88 172 ) 					#name: #openEditorID 					#model: #openEditor 					#label: 'Start Up' 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 148 0 -5 1 172 0 ) 					#name: #shutDownID 					#flags: 40 					#model: #shutDown 					#label: 'Shut Down' 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.LayoutFrame} -50 1 4 0 -5 1 52 0 ) 					#name: #coastLogo 					#flags: 32 					#tabable: false 					#label: #coastLogo 					#hasCharacterOrientedLabel: false 					#defaultable: true ) ) ) )</body></methods><methods><class-id>COAST.CoastLogControl class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'COAST Log Control' 			#min: #(#{Core.Point} 320 280 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 577 512 897 992 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 65 0 ) 					#name: #GroupBox1 					#label: 'Level' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 20 30 ) 					#name: #logLevelsWarning 					#model: #logLevelAspect 					#label: 'Warning' 					#select: 20 ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 95 30 ) 					#name: #logLevelNormal 					#model: #logLevelAspect 					#label: 'Normal' 					#select: 10 ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 165 30 ) 					#name: #logLevelNotify 					#model: #logLevelAspect 					#label: 'Notifiy' 					#select: 5 ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 230 30 ) 					#name: #logLevelDebug 					#model: #logLevelAspect 					#label: 'Debug' 					#select: 3 ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 5 75 ) 					#name: #haltOnExceptionsAspect 					#model: #haltOnExceptionsAspect 					#label: 'Halt on exceptions' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 100 0 -5 1 -35 1 ) 					#name: #GroupBox2 					#label: 'Channels' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 15 125 ) 					#name: #filterChannelsAspect 					#model: #filterChannelsAspect 					#label: 'Filter channels' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -85 1 120 0 -15 1 143 0 ) 					#name: #clearChannels 					#model: #clearChannels 					#label: 'Clear' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 150 0 -15 1 -45 1 ) 					#name: #channelsAspect 					#model: #channelsAspect 					#multipleSelections: true 					#selectionType: #checkMark ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0 -28 1 ) 					#label: 'File' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 -28 1 -5 1 -5 1 ) 					#model: #logFileNameAspect ) ) ) )</body></methods><methods><class-id>COAST.CoastMediatorRemoteControl class</class-id> <category>resources</category><body package="COASTDevelopment">defaultMenu	"Tools.MenuEditor new openOnClass: self andSelector: #defaultMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Volume' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Refresh list' 							#nameKey: #rescanVolumes 							#value: #rescanVolumes ) 						#(#{UI.MenuItem} 							#rawLabel: 'Info' 							#nameKey: #openVolumeInfo 							#value: #openVolumeInfo 							#enablementSelector: #isVolumeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Copy...' 							#nameKey: #copyVolume 							#value: #copyVolume 							#enablementSelector: #isVolumeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compress (BFS only)' 							#nameKey: #compressVolume 							#value: #compressVolume 							#enablementSelector: #isVolumeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Delete' 							#nameKey: #deleteVolume 							#value: #deleteVolume 							#enablementSelector: #isVolumeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Backup' 							#nameKey: #backupVolume 							#value: #backupVolume 							#enablementSelector: #isVolumeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Delete Backup ...' 							#nameKey: #deleteBackup 							#value: #deleteBackup ) 						#(#{UI.MenuItem} 							#rawLabel: 'Restore Backup ...' 							#nameKey: #restoreBackup 							#value: #restoreBackup ) 						#(#{UI.MenuItem} 							#rawLabel: 'Download' 							#nameKey: #downloadVolume 							#value: #downloadVolume 							#enablementSelector: #isVolumeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Upload' 							#nameKey: #uploadVolume 							#value: #uploadVolume ) 						#(#{UI.MenuItem} 							#rawLabel: 'Replace' 							#nameKey: #replaceVolume 							#value: #replaceVolume 							#enablementSelector: #isVolumeSelected ) ) #(2 3 3 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Mediator' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Start local mediator' 							#value: #startMediator 							#enablementSelector: #canStartLocalMediator ) 						#(#{UI.MenuItem} 							#rawLabel: 'Download Log' 							#value: #downloadLog ) 						#(#{UI.MenuItem} 							#rawLabel: 'Shut down' 							#value: #shutDownMediator ) 						#(#{UI.MenuItem} 							#rawLabel: 'Show Connections' 							#value: #showConnections ) ) #(4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Garbage Collect' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Start' 							#nameKey: #startGC 							#value: #startGC 							#enablementSelector: #isVolumeSelected 							#labelImage: #(#{UI.ResourceRetriever} #{CoastMediatorRemoteControl} #startImage ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Pause' 							#nameKey: #pauseGC 							#value: #pauseGC 							#enablementSelector: #isVolumeSelected 							#labelImage: #(#{UI.ResourceRetriever} nil #pauseImage ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Stop' 							#nameKey: #stopGC 							#value: #stopGC 							#enablementSelector: #isVolumeSelected 							#labelImage: #(#{UI.ResourceRetriever} nil #stopImage ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Info' 							#nameKey: #infoGC 							#value: #infoGC 							#enablementSelector: #isVolumeSelected 							#labelImage: #(#{UI.ResourceRetriever} nil #infoImage ) ) ) #(4 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="COASTDevelopment">infoImage	"UIMaskEditor new openOnClass: self andSelector: #infoImage2"	&lt;resource: #image&gt;	^(Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 8 0 0 0 0 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 28 0 0 0 0 0 0 0])</body><body package="COASTDevelopment">pauseImage	"UIMaskEditor new openOnClass: self andSelector: #pauseImage"	&lt;resource: #image&gt;	^(Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 119 0 0 0 119 0 0 0 119 0 0 0 119 0 0 0 119 0 0 0 119 0 0 0 119 0 0 0 0 0 0 0])</body><body package="COASTDevelopment">startImage	"UIMaskEditor new openOnClass: self andSelector: #startImage"	&lt;resource: #image&gt;	^(Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 64 0 0 0 112 0 0 0 124 0 0 0 127 0 0 0 124 0 0 0 112 0 0 0 64 0 0 0 0 0 0 0])</body><body package="COASTDevelopment">stopImage	"UIMaskEditor new openOnClass: self andSelector: #stopImage"	&lt;resource: #image&gt;	^(Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 0 0 0 127 0 0 0 127 0 0 0 127 0 0 0 127 0 0 0 127 0 0 0 127 0 0 0 0 0 0 0])</body></methods><methods><class-id>COAST.CoastMediatorRemoteControl class</class-id> <category>interface specs</category><body package="COASTDevelopment">infoSpec	"Tools.UIPainter new openOnClass: self andSelector: #infoSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #screenCenter #openType #advanced ) 			#label: 'Volume Info' 			#min: #(#{Core.Point} 250 350 ) 			#max: #(#{Core.Point} 1280 960 ) 			#bounds: #(#{Graphics.Rectangle} 640 480 890 830 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -90 1 ) 					#name: #historyListID 					#model: #historyList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0 -85 1 ) 					#name: #addCommentLabel 					#label: 'Add Comment:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -60 1 -5 1 -35 1 ) 					#name: #commentInput 					#model: #comment 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#focusOutSelector: #rescanVolumes 						#valueChangeSelector: #rescanVolumes ) 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -30 1 80 0 -5 1 ) 					#name: #addCommentButton 					#model: #addComment 					#tabable: false 					#label: 'Add' 					#defaultable: true ) ) ) )</body><body package="COASTDevelopment">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #screenCenter #openType #advanced ) 			#label: 'COAST Mediator Remote Control' 			#min: #(#{Core.Point} 250 350 ) 			#max: #(#{Core.Point} 1280 960 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1050 950 ) 			#flags: 4 			#menu: #defaultMenu 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -175 1 ) 					#name: #volumesID 					#model: #volumesAspect 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 60 0 -160 1 -5 1 -135 1 ) 					#name: #host 					#model: #hostAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#focusOutSelector: #rescanVolumes 						#valueChangeSelector: #rescanVolumes ) 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 60 0 -130 1 -5 1 -105 1 ) 					#name: #port 					#model: #portAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #fixPortAspect ) 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 60 0 -100 1 -5 1 -75 1 ) 					#name: #password 					#model: #passwordAspect 					#type: #password ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0 -128 1 ) 					#name: #portLabel 					#label: 'Port:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0 -98 1 ) 					#name: #passwordLabel 					#label: 'Password:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -55 1 -2 0.333333 -30 1 ) 					#name: #rescan 					#model: #rescanVolumes 					#tabable: true 					#label: 'Rescan' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.333333 -55 1 -3 0.666666 -30 1 ) 					#name: #start 					#model: #startMediator 					#tabable: true 					#label: 'Start local' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.666666 -55 1 -5 1 -30 1 ) 					#name: #shutDown 					#model: #shutDownMediator 					#tabable: false 					#label: 'Shutdown' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -26 1 -1 1 -1 1 ) 					#name: #status 					#model: #statusAspect 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -158 1 55 0 -135 1 ) 					#model: #browseServers 					#tabable: false 					#label: 'Server:' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.CoastIconLibrary class</class-id> <category>resources</category><body package="COASTDevelopment">eagerVirtualSlotIcon	"UIMaskEditor new openOnClass: self andSelector: #eagerVirtualSlotIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue yellow; at: 3 put: ColorValue white; at: 4 put: ColorValue lightGray; yourself)) usingBits: #[170 170 170 170 170 170 170 170 170 170 170 170 168 0 0 10 168 85 85 78 168 93 221 78 161 119 117 58 133 221 212 234 135 119 116 234 177 221 221 42 172 119 119 74 168 85 85 78 168 0 0 14 170 255 255 254 170 170 170 170 170 170 170 170])</body><body package="COASTDevelopment">invalidEagerVirtualSlotIcon	"UIMaskEditor new openOnClass: self andSelector: #invalidEagerVirtualSlotIcon"	&lt;resource: #image&gt;		^ CachedImage on: ( Image extent: 16 @ 16 depth: 3 bitsPerPixel: 4 palette: ( MappedPalette withColors: ( ( Array new: 5 ) at: 1 put: ColorValue black; at: 2 put: ColorValue red; at: 3 put: ColorValue yellow; at: 4 put: ColorValue white; at: 5 put: ColorValue lightGray; yourself )) usingBits: #[ 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 48 0 0 0 0 0 51 51 48 33 33 33 33 32 67 51 48 18 18 18 18 16 67 51 1 33 33 33 33 4 51 48 18 18 18 18 16 67 51 48 33 33 33 33 32 67 51 52 2 18 18 18 18 3 51 51 64 33 33 33 33 32 51 51 48 18 18 18 18 16 67 51 48 0 0 0 0 0 67 51 51 68 68 68 68 68 67 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 ])</body><body package="COASTDevelopment">invalidVirtualSlotIcon	"UIMaskEditor new openOnClass: self andSelector: #invalidVirtualSlotIcon"	&lt;resource: #image&gt;		^ CachedImage on: ( Image extent: 16 @ 16 depth: 2 bitsPerPixel: 2 palette: ( MappedPalette withColors: ( ( Array new: 4 ) at: 1 put: ColorValue black; at: 2 put: ColorValue red; at: 3 put: ColorValue white; at: 4 put: ColorValue lightGray; yourself )) usingBits: #[ 170 170 170 170 170 170 170 170 170 170 170 170 168 0 0 10 168 85 85 78 168 110 238 78 161 187 185 58 134 238 228 234 135 187 180 234 177 238 237 42 172 123 187 74 168 85 85 78 168 0 0 14 170 255 255 254 170 170 170 170 170 170 170 170 ])</body><body package="COASTDevelopment">selfIcon	"UIMaskEditor new openOnClass: self andSelector: #selfIcon"	&lt;resource: #image&gt;		^ CachedImage on: ( Image extent: 16 @ 16 depth: 2 bitsPerPixel: 2 palette: ( MappedPalette withColors: ( ( Array new: 3 ) at: 1 put: ColorValue black; at: 2 put: ( ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460 ); at: 3 put: ColorValue white; yourself )) usingBits: #[ 170 170 170 170 170 170 170 170 170 0 0 2 168 170 170 161 162 168 10 161 162 162 22 161 138 168 10 161 138 170 86 161 138 170 170 161 138 168 10 161 138 162 22 161 162 168 10 161 162 170 86 161 168 170 170 161 170 0 0 1 170 149 85 85 ])</body><body package="COASTDevelopment">selfIconMask	"UIMaskEditor new openOnClass: self andSelector: #selfIconMask"	&lt;resource: #image&gt;		^ CachedImage on: ( Image extent: 16 @ 16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[ 0 0 0 0 0 0 0 0 15 254 0 0 31 255 0 0 63 255 0 0 63 255 0 0 127 255 0 0 127 255 0 0 127 255 0 0 127 255 0 0 127 255 0 0 63 255 0 0 63 255 0 0 31 255 0 0 15 255 0 0 7 255 0 0 ])</body><body package="COASTDevelopment">slotIcon	"UIMaskEditor new openOnClass: self andSelector: #slotIcon"	&lt;resource: #image&gt;		^ CachedImage on: ( Image extent: 16 @ 16 depth: 2 bitsPerPixel: 2 palette: ( MappedPalette withColors: ( ( Array new: 3 ) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: ( ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548 ); yourself )) usingBits: #[ 85 85 85 85 85 85 85 85 85 85 85 85 84 0 0 5 84 85 85 73 84 85 85 73 81 85 85 37 69 85 84 149 69 85 84 149 97 85 86 21 88 85 85 133 84 85 85 73 84 0 0 9 85 170 170 169 85 85 85 85 85 85 85 85 ])</body><body package="COASTDevelopment">slotIconMask	"UIMaskEditor new openOnClass: self andSelector: #slotIconMask"	&lt;resource: #image&gt;		^ CachedImage on: ( Image extent: 16 @ 16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[ 0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 31 254 0 0 31 254 0 0 63 252 0 0 127 248 0 0 127 248 0 0 127 248 0 0 63 252 0 0 31 254 0 0 31 254 0 0 15 254 0 0 0 0 0 0 0 0 0 0 ])</body><body package="COASTDevelopment">undefinedSlotIcon	"UIMaskEditor new openOnClass: self andSelector: #undefinedSlotIcon"	&lt;resource: #image&gt;		^ CachedImage on: ( Image extent: 16 @ 16 depth: 2 bitsPerPixel: 2 palette: ( MappedPalette withColors: ( ( Array new: 4 ) at: 1 put: ColorValue black; at: 2 put: ColorValue red; at: 3 put: ColorValue white; at: 4 put: ( ColorValue scaledRed: 5557 scaledGreen: 5557 scaledBlue: 5557 ); yourself )) usingBits: #[ 170 170 170 170 166 170 170 166 165 170 170 150 169 64 0 90 168 90 169 78 168 150 165 142 162 165 150 58 138 169 88 234 138 169 88 234 178 165 151 42 172 150 165 202 168 90 169 78 169 64 0 94 165 255 255 214 166 170 170 166 170 170 170 170 ])</body><body package="COASTDevelopment">virtualSlotIcon	"UIMaskEditor new openOnClass: self andSelector: #virtualSlotIcon"	&lt;resource: #image&gt;		^ CachedImage on: ( Image extent: 16 @ 16 depth: 2 bitsPerPixel: 2 palette: ( MappedPalette withColors: ( ( Array new: 4 ) at: 1 put: ColorValue black; at: 2 put: ColorValue green; at: 3 put: ColorValue white; at: 4 put: ColorValue lightGray; yourself )) usingBits: #[ 170 170 170 170 170 170 170 170 170 170 170 170 168 0 0 10 168 85 85 78 168 110 238 78 161 187 185 58 134 238 228 234 135 187 180 234 177 238 237 42 172 123 187 74 168 85 85 78 168 0 0 14 170 255 255 254 170 170 170 170 170 170 170 170 ])</body><body package="COASTDevelopment">virtualSlotIconMask	"UIMaskEditor new openOnClass: self andSelector: #virtualSlotIconMask"	&lt;resource: #image&gt;		^ CachedImage on: ( Image extent: 16 @ 16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[ 0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 31 254 0 0 31 254 0 0 63 252 0 0 127 248 0 0 127 248 0 0 127 248 0 0 63 252 0 0 31 254 0 0 31 254 0 0 15 254 0 0 0 0 0 0 0 0 0 0 ])</body></methods><methods><class-id>COAST.CatRMInternalClientPacketStation</class-id> <category>private: initialize</category><body package="COASTDevelopment">initializeForInternalConnection	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #referenceNonPrerequisiteClass&gt;		| mediatorClass mediatortoConnectTo |	self initializeProcesses.	mediatorClass := #{COAST.CoastMediator} valueOrDo: [ ^ nil ].	mediatortoConnectTo := mediatorClass allInstances 			detect: [: mediator | mediator isActive and: [ mediator serverPort = connectPort ]]			ifNone: [ ^ nil ].	mediatortoConnectTo volumeManager newInternalClientConnection: self.	connected := true.	^ self	"ready-to-go"</body></methods><methods><class-id>COAST.CoastDeveloperNotifierLocal class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Notifier' 			#max: #(#{Core.Point} 790 122 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 953 634 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -25 1 0.5 0 ) 					#model: #ok 					#label: 'ok' 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -30 1 ) 					#name: #COASTTextEditor1 					#isOpaque: true 					#model: #message 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 5 98 86 121 ) 					#name: #ActionButton1 					#model: #inspectIt 					#label: 'inspect' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>COAST.CoastTrippyFrameInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">detailsSpec	"UIPainter new openOnClass: self andSelector: #detailsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'COAST Frame Inspector' 			#min: #(#{Core.Point} 331 199 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 880 691 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 1 0 -1 1 -60 1 ) 					#name: #slotValuesID 					#model: #slotValues 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #diveIntoField ) 					#menu: #fieldMenuHolder 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -5 1 -5 1 1 1 ) 					#model: #update 					#label: 'Update' 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 -35 1 0 1 ) 					#name: #values 					#model: #displayRange 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSlot ) 					#label: 'values' 					#select: #values ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 -20 1 0 1 ) 					#name: #observers 					#model: #displayRange 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSlot ) 					#label: 'observers' 					#select: #observers ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 -5 1 0 1 ) 					#name: #subjects 					#model: #displayRange 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSlot ) 					#label: 'subjects' 					#select: #subjects ) ) ) )</body><body package="COASTDevelopment">upperspec	"Tools.UIPainter new openOnClass: self andSelector: #upperspec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'COAST Frame Inspector' 			#min: #(#{Core.Point} 331 199 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1008 819 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 177 0 -1 1 ) 					#name: #slotNamesID 					#model: #slotNames 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSlot ) 					#menu: #fieldMenuHolder 					#selectionType: #highlight ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 183 0 0 0 0 1 -1 1 ) 					#name: #details 					#flags: 0 					#minorKey: #detailsSpec ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 178 0 1 0 182 0 -1 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 100 					#aboveWidgets: '#slotNamesID' 					#belowWidgets: '#details' ) ) ) )</body></methods><methods><class-id>COAST.CoastTrippyVolumeManagerInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'a Volume Manager' 			#bounds: #(#{Graphics.Rectangle} 512 384 980 669 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -25 1 ) 					#model: #volumes 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #diveIntoField ) 					#tabable: false 					#menu: #fieldMenuHolder 					#selectionType: #highlight ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -24 1 0 1 -1 1 ) 					#flags: 0 					#model: #status 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>COAST.CoastTrippyClusterManagerInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'a MediatorClusterController' 			#bounds: #(#{Graphics.Rectangle} 160 600 628 885 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{Aragon.NewDataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #allowColumnReordering true #rowLabelsAsButtons false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -25 1 ) 					#name: #clusterTableAspect 					#model: #clusterTableAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectField ) 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #clusterIDAspect 							#label: 'clusterID' 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#type: #number 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #clusterTypeAspect 							#label: 'type' 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #globalSeqNumAspect 							#label: 'globalSeqNum' 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#type: #number 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #approxByteSizeAspect 							#label: 'approxByteSize' 							#labelIsImage: false 							#width: 80 							#editorType: #InputField 							#type: #number 							#noScroll: false 							#formatString: '#,##0' ) ) 					#labelsAsButtons: false 					#showHorizontalLines: true 					#showVerticalLines: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.25 -23 1 -2 1 0 1 ) 					#name: #clusterCount 					#flags: 0 					#model: #clusterCount 					#tabable: false 					#alignment: #right 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 -23 1 -2 0.75 0 1 ) 					#name: #info 					#flags: 0 					#model: #info 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>COAST.NewSlotDialog class</class-id> <category>interface specs</category><body package="COASTDevelopment">embeddedSpec	"UIPainter new openOnClass: self andSelector: #embeddedSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'New slot' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1280 960 ) 			#bounds: #(#{Graphics.Rectangle} 640 482 1002 888 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 160 0 ) 					#name: #Subcanvas2 					#flags: 0 					#minorKey: #slotSpec ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 160 0 0 1 0 1 ) 					#name: #Subcanvas1 					#flags: 0 					#minorKey: #accessorsSpec ) ) ) )</body><body package="COASTDevelopment">slotSpec	"Tools.UIPainter new openOnClass: self andSelector: #slotSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 640 512 1002 810 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 5 0 -5 1 28 0 ) 					#name: #InputField2 					#model: #slotNameAspect ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 80 32 200 55 ) 					#name: #ComboBox1 					#model: #slotTypeAspect 					#type: #string 					#comboList: #slotTypeChoices ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 58 0 -5 1 82 0 ) 					#name: #ComboBox2 					#model: #slotRangeAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #validateSlotRange ) 					#isReadOnly: false 					#comboList: #slotRangeChoicesAspect ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 85 0 -40 1 109 0 ) 					#name: #InputField1 					#model: #invertedSlotNameAspect ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -35 1 85 0 -5 1 109 0 ) 					#name: #ActionButton1 					#model: #chooseInvertedSlot 					#label: '...' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 113 0 -5 1 137 0 ) 					#name: #InputField3 					#model: #defaultValueAspect ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 5 142 ) 					#name: #CheckBox2 					#model: #isConstituentAspect 					#label: 'Constituent' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 5 ) 					#name: #Label1 					#label: 'Slot name:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 32 ) 					#name: #Label2 					#label: 'Type:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 60 ) 					#name: #Label3 					#label: 'Range:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 86 ) 					#name: #Label4 					#label: 'Inverts to:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 113 ) 					#name: #Label5 					#label: 'Default value:' ) ) ) )</body></methods><methods><class-id>COAST.CatINClusterInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'a Cluster' 			#bounds: #(#{Graphics.Rectangle} 576 432 1044 717 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 30 0 -10 1 -50 1 ) 					#model: #frameNames 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectSelectedFrame ) 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -40 1 -10 0.5 -10 1 ) 					#model: #update 					#label: 'update now' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 -40 1 -10 1 -10 1 ) 					#model: #basicInspectCluster 					#label: 'basic inspect' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 8 ) 					#label: 'frames' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 8 0 1 0 ) 					#model: #sorted 					#label: 'sorted' ) ) ) )</body></methods><methods><class-id>COAST.CatINFrameInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">detailsSpec	"UIPainter new openOnClass: self andSelector: #detailsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'COAST Frame Inspector' 			#min: #(#{Core.Point} 331 199 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 944 739 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -60 1 ) 					#name: #slotValuesID 					#model: #slotValues 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectField ) 					#menu: #fieldMenuHolder 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -5 1 -5 1 1 1 ) 					#model: #update 					#label: 'Update' 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 -35 1 0 1 ) 					#name: #values 					#model: #displayRange 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSlot ) 					#label: 'values' 					#select: #values ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 -20 1 0 1 ) 					#name: #observers 					#model: #displayRange 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSlot ) 					#label: 'observers' 					#select: #observers ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 -5 1 0 1 ) 					#name: #subjects 					#model: #displayRange 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSlot ) 					#label: 'subjects' 					#select: #subjects ) ) ) )</body><body package="COASTDevelopment">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'COAST Frame Inspector' 			#min: #(#{Core.Point} 331 199 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1008 819 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -3 0.5 -3 0.75 ) 					#name: #slotNamesID 					#model: #slotNames 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateSlot ) 					#menu: #fieldMenuHolder 					#selectionType: #highlight ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 0.75 ) 					#name: #upperDragBar 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'slotNamesID' 					#belowWidgets: 'details' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.5 0 0 0 1 -1 0.75 ) 					#name: #details 					#flags: 0 					#minorKey: #detailsSpec ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.75 0 1 2 0.75 ) 					#name: #lowerDragBar 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'details slotNamesID upperDragBar' 					#belowWidgets: 'inputField' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 3 0.75 0 1 0 1 ) 					#name: #imputField 					#model: #inputField 					#menu: #textMenuHolder 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>COAST.CoastTrippyClusterInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'a Cluster' 			#bounds: #(#{Graphics.Rectangle} 512 384 980 669 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -25 1 ) 					#model: #frameNames 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #diveIntoField ) 					#tabable: false 					#menu: #fieldMenuHolder 					#selectionType: #highlight ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -24 1 0 1 -1 1 ) 					#flags: 0 					#model: #status 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>COAST.CoastTrippyFrameLookupInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'COAST Frame Inspector' 			#min: #(#{Core.Point} 331 199 ) 			#bounds: #(#{Graphics.Rectangle} 640 480 1008 787 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 3 3 ) 					#name: #Label1 					#label: 'Full frame ID string (IDX_Y):' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 30 0 -3 1 55 0 ) 					#name: #InputField1 					#model: #inputAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedInput ) ) ) ) )</body></methods><methods><class-id>COAST.CoastBFSInfoInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Block File System' 			#min: #(#{Core.Point} 331 199 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1168 907 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -35 1 ) 					#name: #infoTextAspect 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #infoTextAspect 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -29 1 60 0 -6 1 ) 					#name: #update 					#model: #update 					#label: 'Update' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 65 0 -29 1 145 0 -6 1 ) 					#name: #checkFile 					#model: #checkFile 					#label: 'Check File ...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 150 0 -29 1 230 0 -6 1 ) 					#name: #checkBlocks 					#model: #checkBlocks 					#label: 'Check Blocks' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 235 0 -29 1 108 0.5 -6 1 ) 					#name: #minBlockAspect 					#model: #minBlockAspect 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 112 0.5 -29 1 -5 1 -6 1 ) 					#name: #maxBlockAspect 					#model: #maxBlockAspect 					#type: #number ) ) ) )</body></methods><methods><class-id>COAST.CatINClusterManagerInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'a MediatorClusterController' 			#bounds: #(#{Graphics.Rectangle} 576 432 1044 717 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 30 0 -10 1 -10 1 ) 					#model: #cluster 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectCluster ) 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -40 1 -10 0.25 -10 1 ) 					#model: #update 					#label: 'update now' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0.5 8 0 ) 					#label: 'cluster' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 30 0 -10 0.5 -50 1 ) 					#model: #volumes 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #cluster ) 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 8 ) 					#label: 'volumes' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.25 -40 1 -10 0.5 -10 1 ) 					#model: #basicInspectCM 					#label: 'basicInspect' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 57 0.5 5 0 157 0.5 25 0 ) 					#flags: 0 					#model: #clusterCount 					#tabable: false 					#alignment: #right 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>COAST.CoastTrippyMediatorFrameInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">detailsSpec	"UIPainter new openOnClass: self andSelector: #detailsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'COAST Frame Inspector' 			#min: #(#{Core.Point} 331 199 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 880 691 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 1 0 -1 1 -60 1 ) 					#name: #slotValuesID 					#model: #slotValues 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #diveIntoField ) 					#menu: #fieldMenuHolder 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -5 1 -5 1 1 1 ) 					#model: #update 					#label: 'Update' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>COAST.CatMediatorFrameInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">detailsSpec	"UIPainter new openOnClass: self andSelector: #detailsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'COAST Frame Inspector' 			#min: #(#{Core.Point} 331 199 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 944 739 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -40 1 ) 					#name: #slotValuesID 					#model: #slotValues 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectField ) 					#menu: #fieldMenuHolder 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -5 1 -5 1 1 1 ) 					#model: #update 					#label: 'Update' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>COAST.CatINMediatorClusterManagerInspector class</class-id> <category>interface specs</category><body package="COASTDevelopment">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'a MediatorClusterController' 			#bounds: #(#{Graphics.Rectangle} 576 432 1044 717 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 50 0 -10 0.5 -50 1 ) 					#model: #clientsOrVolumesList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #cluster ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0.5 10 0 ) 					#label: 'cluster' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 30 0 -10 1 -50 1 ) 					#model: #cluster 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectCluster ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -40 1 -10 0.5 -10 1 ) 					#model: #update 					#label: 'update now' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 -40 1 -10 1 -10 1 ) 					#model: #basicInspectCM 					#label: 'basic inspect' 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 8 ) 					#name: #clients 					#model: #clientsOrVolumes 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #toggle ) 					#label: 'clients' 					#select: #clients ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 28 ) 					#name: #volumes 					#model: #clientsOrVolumes 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #toggle ) 					#label: 'volumes' 					#select: #volumes ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 60 0.5 5 0 150 0.5 25 0 ) 					#flags: 0 					#model: #clusterCount 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>COAST</category><body package="COASTDevelopment">openLogControl	&lt;menuItem: 'Log control'		icon: nil		nameKey: nil		menu: #(#menuBar #coastTools)		position: 1.2&gt;	COAST.CoastLogControl open</body><body package="COASTDevelopment">coastTools	&lt;submenu: 'COAST'		nameKey: #coastTools		menu: #(#menuBar)		position: 10.045&gt;</body><body package="COASTDevelopment">toolsCoastGenericLauncher	&lt;menuItem: 'Generic Launcher'		icon: #coastLauncherIcon		nameKey: nil		menu: #(#menuBar #coastTools)		position: 1.3&gt;	^COAST.CoastGenericLauncher open</body></methods><methods><class-id>COAST.CatCSVolumeManager class</class-id> <category>defaults</category><body package="COASTDevelopment">autoSettings	&lt;autoSettingsSet: #defaultStorageClass: get: #defaultStorageClass type: #Class&gt;</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart class</class-id> <category>accessing</category><body package="COASTDevelopment">coastSlotsTab	" &gt;= VW 7.7.1 "	&lt;tabDescription: 10&gt;		^ TabPartDescription named: self slotsTabName buildWith: #buildCoastFrameSubcanvas match: #isCoastClassWithSlots: enabled: #isCoastClassWithSlots:</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>private</category><body package="COASTDevelopment">shouldCheckForCoastInstances	&lt;autoSettingsSet: #shouldCheckForCoastInstances: get: #shouldCheckForCoastInstances type: #Boolean&gt;	^  ShouldCheckForCoastInstances ifNil: [ false ]</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>COAST</category><body package="COASTDevelopment">shutDownHost	&lt;menuItem: 'ShutDown Host...'		icon: nil		nameKey: nil		menu: #(#menuBar #coastTools)		position: 2.1&gt;		| host passwd statusResponse |	host := Dialog request: 'host:' initialAnswer: 'localhost'.	host isEmpty 		ifTrue: [ ^ self ].	passwd := Dialog request: 'password: ' initialAnswer: 'c0ast!'.	statusResponse := COAST.CoastMediatorStub shutDownMediatorAtHost: host password: passwd.	Dialog warn: statusResponse message for: self mainWindow.</body></methods><methods><class-id>COAST.CoastLocalApplicationModel class</class-id> <category>resources</category><body package="COASTDevelopment">coastLogo	"UIMaskEditor new openOnClass: self andSelector: #coastLogo"	&lt;resource: #image&gt;	^(Image extent: 40@40 depth: 5 bitsPerPixel: 8 palette: (MappedPalette withColors: ((Array new: 29) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 528 scaledGreen: 528 scaledBlue: 528); at: 4 put: (ColorValue scaledRed: 3963 scaledGreen: 3963 scaledBlue: 2113); at: 5 put: (ColorValue scaledRed: 1056 scaledGreen: 1056 scaledBlue: 1056); at: 6 put: (ColorValue scaledRed: 6077 scaledGreen: 2642 scaledBlue: 2113); at: 7 put: (ColorValue scaledRed: 8191 scaledGreen: 2642 scaledBlue: 0); at: 8 put: (ColorValue scaledRed: 1585 scaledGreen: 1585 scaledBlue: 1585); at: 9 put: (ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); at: 10 put: (ColorValue scaledRed: 6077 scaledGreen: 3963 scaledBlue: 3963); at: 11 put: (ColorValue scaledRed: 2642 scaledGreen: 2642 scaledBlue: 2642); at: 12 put: (ColorValue scaledRed: 3963 scaledGreen: 2642 scaledBlue: 2113); at: 13 put: (ColorValue scaledRed: 6077 scaledGreen: 2642 scaledBlue: 0); at: 14 put: (ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 15 put: (ColorValue scaledRed: 3699 scaledGreen: 3699 scaledBlue: 3699); at: 16 put: (ColorValue scaledRed: 3963 scaledGreen: 3963 scaledBlue: 3963); at: 17 put: (ColorValue scaledRed: 4491 scaledGreen: 4491 scaledBlue: 4491); at: 18 put: (ColorValue scaledRed: 8191 scaledGreen: 3963 scaledBlue: 2113); at: 19 put: (ColorValue scaledRed: 3963 scaledGreen: 2642 scaledBlue: 0); at: 20 put: (ColorValue scaledRed: 5020 scaledGreen: 5020 scaledBlue: 5020); at: 21 put: (ColorValue scaledRed: 8191 scaledGreen: 5548 scaledBlue: 2113); at: 22 put: (ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 23 put: (ColorValue scaledRed: 6077 scaledGreen: 6077 scaledBlue: 6077); at: 24 put: (ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); at: 25 put: (ColorValue scaledRed: 6077 scaledGreen: 3963 scaledBlue: 2113); at: 26 put: (ColorValue scaledRed: 8191 scaledGreen: 2642 scaledBlue: 2113); at: 27 put: (ColorValue scaledRed: 3963 scaledGreen: 1321 scaledBlue: 0); at: 28 put: (ColorValue scaledRed: 7134 scaledGreen: 7134 scaledBlue: 7134); at: 29 put: (ColorValue scaledRed: 7662 scaledGreen: 7662 scaledBlue: 7662); yourself)) usingBits: (ByteArray fromPackedString: '@@\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\G@@\A@PDA@PDA@PDAF0DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDAE!(A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDA@QTLE DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PDA@PDSFP&lt;A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDAC0TKG@DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDA@P,XCAXA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PDA@PDKDQDC@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDAB0XYB0DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DAGA,[F1,A@P,YDP,A@Q\SD1LSE DA@PDA@PDA@PDA@PDA@PDAA0\\C 0LF@TKAQ@KFP0KEP,EAPTECA([@PDA@PDA@PDA@PDA@PDA@P\GD00LAQDYA!$QF TEF TYDQDEB1L\@PDA@PDA@PDA@PDA@PDA@PDGA10W@QTKFA$YAQ$YFQ$YFQ KE DA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDAGALIB1HXFQ$FC@,SG@DA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@Q\EA!$FA! KD10A@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDPAQDKCAPYF@TMG@DA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PDADA$QCQTKAPTFAP&lt;A@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@P&lt;XFQLAGAXUB0,KF0DA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDPAPT[@PDA@PD[B1TA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PDABPXM@PDA@PDA@QTV@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDAF1HKG@DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@P8KF0DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PD[E DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDGA0DA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDAA0\A@PD\D0&lt;PEQ0A@Q\PD@&lt;[@PDA@Q,U@PDA@QLOEQ0OD@&lt;PC1@V@P\G@PD[@ \PC0 M@QT@B!TJ@!\A@PDM@A0A@P8DD0 WCP4GA@4MEPDGA0DAA04A@PDAGA\@E0DA@QTBF0D\@ \S@PDMD0DAG@DAD0(A@PDAA0\AF0@\@PDA@PDOB DA@PDAA1TAC04V@ DAD0@O@PDA@QLJ@PDA@P\G@QXG@PDA@PDACP8A@PDA@P(S@PPWG@\V@PDV@ (\@PDSB DA@PDGA0D\@A,A@PDA@QLD@PDA@PDBE!T@A0\DBA0A@Q0DD0DAD0(A@PDAA0\A@P8HE0DAF1T\A@8\@Q0JA0DHEPDA@PHVE!0AB!LA@QLJ@PDA@P\G@PDAC @GA@@U@Q0J@@\@B!0V@ DA@PDNCQ@BA@P[@PDSB DA@PDGA0DA@PD\E!XA@PDA@Q\VF0DAE1\A@PDAGAXAF1XA@PDAF1\A@PDAA0\A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P\G@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDG@@\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\GA0\G@@@a'))</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>COAST</category><body package="COASTDevelopment">evaluateAtHost	&lt;menuItem: 'Evaluate At Host...'		icon: nil		nameKey: nil		menu: #(#menuBar #coastTools)		position: 2.3&gt;	| host todo passwd statusResponse |	host := Dialog request: 'host:' initialAnswer: 'localhost'.	host isEmpty ifTrue: [^self].	todo := Dialog request: 'execute: ' initialAnswer: 'InputState initialize. Notifier beDevelopment. Object evenMorePrivateKillCoast.'.	todo isEmpty ifTrue: [^self].	passwd := Dialog request: 'password: ' initialAnswer: 'c0ast!'.	statusResponse := COAST.CoastMediatorStub evaluate: todo password: passwd atHost: host.	Dialog warn: statusResponse message for: self mainWindow</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart class</class-id> <category>interface specs</category><body package="COASTDevelopment">coastSlotsWindowSpec	"UIPainter new openOnClass: self andSelector: #coastSlotsWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 640 480 840 680 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 					#name: #protocols 					#flags: 0 					#majorKey: #{Refactory.Browser.SelectorProtocolNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #protocols ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #selectors 					#flags: 0 					#majorKey: #{COAST.SlotSelectorNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #coastSlotSelectors ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'protocols' 					#belowWidgets: 'selectors' ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>resources</category><body package="COASTDevelopment">coastLauncherMask	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears 	to point to an incorrect position in the file. The file may have 	been modified after this method was updated."	&lt;resource: #image&gt;	^Image		extent: 20 @ 20		depth: 1		bitsPerPixel: 1		palette: CoveragePalette monoMaskPalette		usingBits: #[0 192 0 0 0 224 0 0 0 224 0 0 0 240 0 0 0 240 0 0 0 240 0 0 0 240 0 0 124 243 240 0 255 255 240 0 255 255 240 0 191 255 128 0 31 255 0 0 3 255 0 0 3 255 128 0 3 255 128 0 3 223 192 0 3 193 192 0 3 128 192 0 7 128 0 0 7 0 0 0]</body></methods><methods><class-id>COAST.CatBSBlockFileVolumeAccessor class</class-id> <category>accessing</category><body package="COASTDevelopment">autoSettingsDirectory53	&lt;autoSettingsSet: #autoSettingsDirectory53: get: #autoSettingsDirectory53 type: #String&gt;	^ self defaultBaseDirectory ifNotNil: [ : filename | filename asString ] ifNil: [ '' ]</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="COASTDevelopment">checkForCoastInstances	" check if clients / mediators are running "	&lt;triggerAtSystemEvent: #aboutToSnapshot&gt;		| opened originalPriority |	self shouldCheckForCoastInstances 		ifTrue: 		[	opened := self openedCoastInstances.			opened notEmpty 				ifTrue: 				[	opened := nil.					" snapshot sets the priority to 100 and does not restore if if the snapshot stops here "					originalPriority := Processor activePriority.					Processor activeProcess priority: Processor userSchedulingPriority. 					ObjectMemory globalCompactingGC.					opened := self openedCoastInstances.					opened notEmpty 						ifTrue: [ self halt: opened size printString , ' COAST clients / mediators are still active' ].					Processor activeProcess priority: originalPriority.				]		].</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>COAST</category><body package="COASTDevelopment">openMediatorAdministration	&lt;menuItem: 'Mediator Administration'		icon: nil		nameKey: nil		menu: #(#menuBar #coastTools)		position: 1.1&gt;	COAST.CoastMediatorRemoteControl open</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>resources</category><body package="COASTDevelopment">coastLauncherImage	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears 	to point to an incorrect position in the file. The file may have 	been modified after this method was updated."	&lt;resource: #image&gt;	^Image		extent: 20 @ 20		depth: 5		bitsPerPixel: 8		palette: (Graphics.MappedPalette withColors: ((Core.Array new: 23)					at: 1 put: (Graphics.ColorValue						scaledRed: 5020						scaledGreen: 5020						scaledBlue: 5020);					at: 2 put: (Graphics.ColorValue						scaledRed: 3170						scaledGreen: 3170						scaledBlue: 3170);					at: 3 put: Graphics.ColorValue white;					at: 4 put: (Graphics.ColorValue						scaledRed: 4491						scaledGreen: 4491						scaledBlue: 4491);					at: 5 put: (Graphics.ColorValue						scaledRed: 7662						scaledGreen: 7662						scaledBlue: 7662);					at: 6 put: (Graphics.ColorValue						scaledRed: 3963						scaledGreen: 3963						scaledBlue: 3963);					at: 7 put: (Graphics.ColorValue						scaledRed: 3963						scaledGreen: 3963						scaledBlue: 2113);					at: 8 put: (Graphics.ColorValue						scaledRed: 7134						scaledGreen: 7134						scaledBlue: 7134);					at: 9 put: (Graphics.ColorValue						scaledRed: 6077						scaledGreen: 3963						scaledBlue: 2113);					at: 10 put: (Graphics.ColorValue						scaledRed: 6077						scaledGreen: 3963						scaledBlue: 3963);					at: 11 put: (Graphics.ColorValue						scaledRed: 3963						scaledGreen: 2642						scaledBlue: 0);					at: 12 put: (Graphics.ColorValue						scaledRed: 6605						scaledGreen: 6605						scaledBlue: 6605);					at: 13 put: (Graphics.ColorValue						scaledRed: 8191						scaledGreen: 5548						scaledBlue: 2113);					at: 14 put: (Graphics.ColorValue						scaledRed: 8191						scaledGreen: 3963						scaledBlue: 2113);					at: 15 put: (Graphics.ColorValue						scaledRed: 3963						scaledGreen: 2642						scaledBlue: 2113);					at: 16 put: (Graphics.ColorValue						scaledRed: 6077						scaledGreen: 2642						scaledBlue: 0);					at: 17 put: (Graphics.ColorValue						scaledRed: 6077						scaledGreen: 6077						scaledBlue: 6077);					at: 18 put: (Graphics.ColorValue						scaledRed: 6077						scaledGreen: 2642						scaledBlue: 2113);					at: 19 put: (Graphics.ColorValue						scaledRed: 8191						scaledGreen: 2642						scaledBlue: 0);					at: 20 put: (Graphics.ColorValue						scaledRed: 3963						scaledGreen: 1321						scaledBlue: 0);					at: 21 put: (Graphics.ColorValue						scaledRed: 5548						scaledGreen: 5548						scaledBlue: 5548);					at: 22 put: (Graphics.ColorValue						scaledRed: 8191						scaledGreen: 2642						scaledBlue: 2113);					at: 23 put: (Graphics.ColorValue						scaledRed: 3699						scaledGreen: 3699						scaledBlue: 3699); yourself))		usingBits: (ByteArray fromPackedString: '@ HB@ HB@ HPD0HB@ HB@ HB@ HB@ HB@ HB@!POD@HB@ HB@ HB@ HB@ HB@ HB@ATE@ HB@ HB@ HB@ HB@ HB@ HEDP8D@ HB@ HB@ HB@ HB@ HB@ 8HC1@B@ HB@ HB@ HB@ HB@ HBC 4MA HB@ HB@ HB@ HB@ HB@ HND!TN@ HB@ HB@ HBA@\GA0\B@ 8UCP8B@ ,@@@@@DAXOC0 QC!DCC!TOC!PNDQDQDP&lt;SC0&lt;QCQTREP4SDQDSDQTMCQDN@@PK@!PNBATUDQTUEQTUEP ND@HB@ HB@ P@BP8JBATUD &lt;N@@PB@ HB@ HB@ HBB1DREQHRB@8@A@HB@ HB@ HB@ HCDP4NC00UBADAA@HB@ HB@ HB@ LUCPDTC!DQD!DE@ HB@ HB@ HBAP U@@HDDAPNC 8G@ HB@ HB@ HCDQDG@ HB@ HGC!PB@ HB@ HB@ $R@PHB@ HB@ HTD@HB@ HB@ HGB 8D@ HB@ HB@ HB@ HB@ HB@!XNA0HB@ HB@ HB@ HB@ @a')</body></methods><methods><class-id>COAST.CoastProfilingClient</class-id> <category>As yet unclassified</category><body package="COASTDevelopment">createNewClusterAndFrameAndLinkTo: testFrame	| newFrame |	newFrame := CoastProfilingFrame newInVolume: testFrame volume.	testFrame at: #multiValue add: newFrame.		^newFrame</body><body package="COASTDevelopment">createNewFrameAndLinkTo: testFrames maxRefs: slotCount 	| newFrame rnd |	rnd := Random new.	newFrame := CoastProfilingFrame new.	1 to: (rnd next * 10) asInteger		do: 			[:idx | 			| dummySlotName |			dummySlotName := ('dummy' , idx printString) asSymbol.			newFrame at: dummySlotName set: (testFrames at: idx \\ testFrames size + 1)].	(testFrames at: (rnd next * testFrames size + 1) asInteger)		linkTo: newFrame maxRefs: slotCount</body><body package="COASTDevelopment">profileCreateTestVolume: volumeName atHost: hostName numberOfFrames: nFrames numberOfClusters: nClusters maxRefsPerFrame: slotCount 	| testFrame rootFrames |	self		inVolume: volumeName		atHost: hostName		init: 			[:cm :tm | 			tm				transactionDo: 					[testFrame := CoastProfilingFrame newInVolume: volumeName.					rootFrames := OrderedCollection with: testFrame].			1 to: nClusters - 1 do: [ :i | Transcript show: i printString, ' '.  tm transactionDo: [rootFrames add: (self createNewClusterAndFrameAndLinkTo: testFrame)]]]		profile: [:cm :tm | Transcript show: '---------------------------------------'; cr.			1 to: nFrames - nClusters do: [ :i | Transcript show: i printString, ' '. tm transactionDo: [self createNewFrameAndLinkTo: rootFrames maxRefs: slotCount].					(i \\ 10000 = 0 ) ifTrue: [(tm volumeManager clusterManagerForVolume: volumeName ) saveAllModifiedClusters ] ]]</body></methods><methods><class-id>COAST.CoastProfilingClient</class-id> <category>profiling</category><body package="COASTDevelopment">profileFastReadAtHost: hostName accesses: accesses runs: runs	| testFrame |	self		inVolume: 'profiling'		atHost: hostName		init: [ :cm :tm |			tm transactionDo: [ 				testFrame := CoastProfilingFrame newInVolume: 'profiling'.				testFrame singleValue: 42 ] ]		profile: [:cm :tm |			runs timesRepeat: [				tm fastReadTransactionDo: [ 					accesses timesRepeat: [  testFrame singleValue ]]]].</body><body package="COASTDevelopment">profileFrameCreationInVolume: volumeName atHost: hostName clusters: numClusters	| cl |	self		inVolume: volumeName		atHost: hostName		init: [ :cm :tm |		 ]		profile: [:cm :tm |			0 to: numClusters -1 do: [ :i |				tm transactionDo: [					cl := cm loadCluster: i.					CoastProfilingFrame newInCluster: cl.		]]].</body><body package="COASTDevelopment">profileLoadAndUnloadCluster: clusterNumber inVolume: volumeName atHost: hostName runs: runs	| cl |	self		inVolume: volumeName		atHost: hostName		init: [ :cm :tm | ]		profile: [:cm :tm |			runs timesRepeat: [				cl := cm loadCluster: clusterNumber.				cm unloadCluster: cl.				(InputState default ctrlDown and: [ InputState default shiftDown ]) ifTrue: [ ^ self ]]].</body><body package="COASTDevelopment">profileLoadCluster: clusterID inVolume: volumeName atHost: hostName runs: runs 	| loadedClusters |	loadedClusters := OrderedCollection new.	self		inVolume: volumeName		atHost: hostName		init: [:cm :tm | ]		profile: [:cm :tm | (1 to: runs)				do: 					[:i | 					| time cluster |					Transcript show: 'run: ' , i printString; cr.					time := Time millisecondsToRun: [cluster := cm loadCluster: i ].					loadedClusters add: (Array with: i with: time with: cluster )]].	loadedClusters inspect</body><body package="COASTDevelopment">profileSimpleReadAtHost: hostName accesses: accesses runs: runs	| testFrame |	self		inVolume: 'profiling'		atHost: hostName		init: [ :cm :tm |			tm transactionDo: [ 				testFrame := CoastProfilingFrame newInVolume: 'profiling'.				testFrame at: #dummy1Slot put: 1.				testFrame at: #dummy2Slot put: 1.				testFrame at: #dummy3Slot put: 1.				testFrame at: #dummy4Slot put: 1.				testFrame singleValue: 42 ] ]		profile: [:cm :tm |			runs timesRepeat: [				tm transactionDo: [ 					accesses timesRepeat: [  testFrame singleValue ]]]].</body><body package="COASTDevelopment">profileSimpleReadAtHost: hostName runs: runs	| testFrame |	self		inVolume: 'profiling'		atHost: hostName		init: [ :cm :tm |			tm transactionDo: [ 				testFrame := CoastProfilingFrame newInVolume: 'profiling'.				testFrame singleValue: 42 ] ]		profile: [:cm :tm |			tm transactionDo: [ 				runs timesRepeat: [  testFrame singleValue ]]].</body><body package="COASTDevelopment">profileSimpleTransactionAtHost: hostName accesses: accesses runs: runs	| testFrame |	self		inVolume: 'profiling'		atHost: hostName		init: [ :cm :tm |			tm transactionDo: [ 				testFrame := CoastProfilingFrame newInCluster: (self rootClusterInVolume: 'profiling'). ]]		profile: [:cm :tm | 			runs timesRepeat: [	 			tm transactionDo: [					accesses timesRepeat: [						testFrame singleValue.						testFrame singleValue: 42 ]]]].</body><body package="COASTDevelopment">profileSimpleTransactionAtHost: hostName runs: runs	| testFrame |	self		inVolume: 'profiling'		atHost: hostName		init: [ :cm :tm |			tm transactionDo: [ 				testFrame := CoastProfilingFrame newInCluster: (self rootClusterInVolume: 'profiling'). ]]		profile: [:cm :tm | 			runs timesRepeat: [	 			tm transactionDo: [					testFrame singleValue.					testFrame singleValue: 42 ]]].</body><body package="COASTDevelopment">profileSimpleWriteAtHost: hostName runs: runs	| testFrame |	self		inVolume: 'profiling'		atHost: hostName		init: [ :cm :tm |			tm transactionDo: [ 				testFrame := CoastProfilingFrame newInVolume: 'profiling' ]]		profile: [:cm :tm |			tm transactionDo: [ 				runs timesRepeat: [  testFrame singleValue: 42 ]]].</body></methods><methods><class-id>COAST.CoastProfilingClient class</class-id> <category>accessing</category><body package="COASTDevelopment">useTimeProfiler	^ useTimeProfiler == true</body><body package="COASTDevelopment">useTimeProfiler: aBoolean	useTimeProfiler := aBoolean</body></methods><methods><class-id>COAST.CoastTrippyInspector</class-id> <category>actions</category><body package="COASTDevelopment">back	self container back</body><body package="COASTDevelopment">diveTo: value description: aString 	self container diveInto: (Tools.Trippy.DerivedAttribute label: aString value: value).	self update</body><body package="COASTDevelopment">selectAll	"cant do that"</body></methods><methods><class-id>COAST.CoastTrippyInspector</class-id> <category>menu</category><body package="COASTDevelopment">basicFieldMenu	self subclassResponsibility</body></methods><methods><class-id>COAST.CoastTrippyInspector</class-id> <category>private</category><body package="COASTDevelopment">changeRequest	^true</body><body package="COASTDevelopment">copyStateTo: dummy</body><body package="COASTDevelopment">fieldListHolder	"i am asked for this ... don't know why	a new list works fine :-\"	^SelectionInList new</body><body package="COASTDevelopment">refresh	self update</body><body package="COASTDevelopment">update</body></methods><methods><class-id>COAST.CoastTrippyInspector</class-id> <category>aspects</category><body package="COASTDevelopment">fieldMenuHolder	^[self basicFieldMenu]</body></methods><methods><class-id>COAST.CoastTrippyInspector</class-id> <category>initialize-release</category><body package="COASTDevelopment">setLabelWith: aBuilder 	| win |	aBuilder isNil ifTrue: [ ^ nil ].	( win := aBuilder window ) notNil ifTrue: 		[ | printable aString |			aString := object printString.			printable := aString isNil 					ifTrue: [ '' ]					ifFalse: 					[	aString collect: 							[: c |								c asInteger &lt; 256 									ifTrue: [ c ]									ifFalse: [ $# ]							]					].			win label: printable.			win icon: ( Icon constantNamed: #inspector )		].</body><body package="COASTDevelopment">updateLabel	self setLabelWith: self builder</body></methods><methods><class-id>COAST.CoastTrippyInspector class</class-id> <category>resources</category><body package="COASTDevelopment">coastInspectorIcon	| coastIcon |	coastIcon := Icon new figure: self coastInspectorFigure shape: self coastInspectorMask asRetainedMedium.	coastIcon cleanFigure.	^coastIcon</body></methods><methods><class-id>COAST.SlotDialog</class-id> <category>aspects</category><body package="COASTDevelopment">accessorsListAspect	accessorsListAspect isNil		ifTrue: [			accessorsListAspect := MultiSelectionInList new.			self updateAccessors.		].	^ accessorsListAspect</body><body package="COASTDevelopment">parameter1Aspect	parameter1Aspect isNil ifTrue: 		[	parameter1Aspect := self slotName asValue.			parameter1Aspect onChangeSend: #addLastParameter:valueHolder: to: self		].	^ parameter1Aspect</body><body package="COASTDevelopment">parameter2Aspect	parameter2Aspect isNil		ifTrue: [			parameter2Aspect := String new asValue.			parameter2Aspect onChangeSend: #addLastParameter:valueHolder: to: self.		].	^ parameter2Aspect</body><body package="COASTDevelopment">parameterChoicesAspect	^parameterChoicesAspect isNil		ifTrue:			[parameterChoicesAspect := self lastParameters asValue]		ifFalse:			[parameterChoicesAspect]</body><body package="COASTDevelopment">slotNameAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^slotNameAspect isNil		ifTrue:			[slotNameAspect := String new asValue]		ifFalse:			[slotNameAspect]</body><body package="COASTDevelopment">slotTypeAspect	slotTypeAspect isNil		ifTrue: [			slotTypeAspect := #singleValue asValue.			slotTypeAspect onChangeSend: #updateAccessors to: self.		].	^ slotTypeAspect</body></methods><methods><class-id>COAST.SlotDialog</class-id> <category>private</category><body package="COASTDevelopment">accessorItemsDictionary	^ self slotCodeDefiner accessorItemsDictionary</body><body package="COASTDevelopment">addLastParameter: dummy valueHolder: aValueHolder	| param |	(param := aValueHolder value) isEmpty		ifTrue: [ ^ self ].	LastParameters isNil ifTrue: [ LastParameters := Set new ].	LastParameters size &gt; 10		ifTrue: [ LastParameters remove: (LastParameters detect: [ :x | true ]) ].	LastParameters add: param.	self parameterChoicesAspect value: self lastParameters.</body><body package="COASTDevelopment">coastCanAccept	| neededParams |	neededParams := self selectors inject: 0 into: [ : n : sel | n max: (sel occurrencesOf: $:) - 1 ].	(neededParams &gt;= 1 and: [ self parameter1 isNil ])		ifTrue: [ 			Dialog warn: 'Parameter 1 not defined'.			^  false ].	(neededParams &gt;= 2 and: [ self parameter2 isNil ])		ifTrue: [ 			Dialog warn: 'Parameter 2 not defined'.			^  false ].	^ true</body><body package="COASTDevelopment">frameClass: aClass	frameClass := aClass</body><body package="COASTDevelopment">lastParameters	^ LastParameters asSortedCollection asList</body><body package="COASTDevelopment">slotCodeDefiner	slotCodeDefiner isNil 		ifTrue: [ slotCodeDefiner := SlotCodeDefiner frameClass: frameClass ].	^ slotCodeDefiner</body><body package="COASTDevelopment">slotName: aString	self slotNameAspect value: aString</body><body package="COASTDevelopment">updateAccessors	| list |	list := ( self accessorItemsDictionary at: self slotType ) asSortedCollection asList.	self accessorsListAspect list: list.	self accessorsListAspect selections: list</body></methods><methods><class-id>COAST.SlotDialog</class-id> <category>accessing</category><body package="COASTDevelopment">parameter1	| p |	p := self parameter1Aspect value.	^ p isEmpty		ifTrue: [ nil ]		ifFalse: [ p ]</body><body package="COASTDevelopment">parameter2	| p |	p := self parameter2Aspect value.	^ p isEmpty		ifTrue: [ nil ]		ifFalse: [ p ]</body><body package="COASTDevelopment">selectors	^ self accessorsListAspect selections collect: [ : sel | sel asString ]</body><body package="COASTDevelopment">slotName	| n |	n := self slotNameAspect value.	^ ('*Slot' match: n)		ifTrue: [ n copyFrom: 1 to: n size - 4 ]		ifFalse: [ n ].</body><body package="COASTDevelopment">slotType	^ self slotTypeAspect value asSymbol</body><body package="COASTDevelopment">slotType: aSymbol	self slotTypeAspect value: aSymbol asString</body></methods><methods><class-id>COAST.SlotDialog class</class-id> <category>instance creation</category><body package="COASTDevelopment">frameClass: aClass slotName: slotName slotType: slotType	^ self new		frameClass: aClass;		slotName: slotName asText allBold;		slotType: slotType;		yourself</body></methods><methods><class-id>COAST.CatINInspector</class-id> <category>initialize-release</category><body package="COASTDevelopment">postBuildWith: aBuilder 	| win |	self setLabelWith: aBuilder.	(win := aBuilder window) notNil		ifTrue: 			[win icon: self class coastInspectorIcon]</body><body package="COASTDevelopment">setLabelWith: aBuilder	| win |	aBuilder isNil ifTrue:[^nil].	(win := aBuilder window) notNil		ifTrue: [win label: object printString.				win icon: (Icon constantNamed: #inspector)].</body><body package="COASTDevelopment">updateLabel	self setLabelWith: self builder</body></methods><methods><class-id>COAST.CatINInspector class</class-id> <category>resources</category><body package="COASTDevelopment">coastInspectorIcon	| coastIcon |	coastIcon := Icon new figure: self coastInspectorFigure shape: self coastInspectorMask asRetainedMedium.	coastIcon cleanFigure.	^coastIcon</body></methods><methods><class-id>COAST.SlotSelectorNavigatorPart</class-id> <category>menus</category><body package="COASTDevelopment">defaultMenu		| m |	m := self class slotMenu.	m addItemGroup: super defaultMenu menuItems.	^ m</body></methods><methods><class-id>COAST.SlotSelectorNavigatorPart</class-id> <category>private</category><body package="COASTDevelopment">frameClass	| cl |	cl := self navigator selectedClass.	^ cl isMeta		ifTrue: [ cl soleInstance ]		ifFalse: [ cl ]</body><body package="COASTDevelopment">methodDefinitionsFor: protocols in: class 	| defs |	defs := super methodDefinitionsFor: protocols in: class.	^ defs select: [ : def | '*Slot' match: def selector ignoreCase: false ].</body><body package="COASTDevelopment">readAccessors	^ #('at:' 'at:atKey:')</body><body package="COASTDevelopment">selectedSlotName	| s |	s := self selection.	^ s notNil		ifTrue: [ 			s := s selector asString.			s copyFrom: 1 to: s size - 4		] 		ifFalse: [ nil ].</body><body package="COASTDevelopment">selectedSlotProto	| n |	^ (n := self selectedSlotName) notNil		ifTrue: [ self frameClass prototypeNeeded basicSlotNamed: n asSymbol ]		ifFalse: [  nil ].</body><body package="COASTDevelopment">selectedSlotType	| p vhClass |	(p := self selectedSlotProto) notNil		ifTrue: [			p isVirtual ifTrue: [ ^ #virtual ].			vhClass := p valueHolder class. 			CatFSSlot typeDictionary keysAndValuesDo: [ : type : class |				(vhClass  includesBehavior: class)					ifTrue: [ ^ type ].			]		].	^ #singleValue</body><body package="COASTDevelopment">selectorDictionary	selectorDictionary isNil 		ifTrue: 		[	selectorDictionary := Dictionary new.			selectorDictionary				at: #at: put: '&lt;1s&gt;' -&gt; #( 1 );				at: #at:set: put: '&lt;1s&gt;: &lt;2s&gt;' -&gt; #( 1 2 );				at: #at:setAll: put: '&lt;1s&gt;: &lt;6s&gt;' -&gt; #( 1 6 );				at: #at:add: put: 'add&lt;5s&gt;: &lt;2s&gt;' -&gt; #( 1 2 );				at: #at:remove: put: 'remove&lt;5s&gt;: &lt;2s&gt;' -&gt; #( 1 2 );				at: #at:atKey: put: '&lt;1s&gt;At: &lt;2s&gt;' -&gt; #( 1 2 );				at: #at:atKey:put: put: '&lt;1s&gt;At: &lt;2s&gt; put: &lt;3s&gt;' -&gt; #( 1 2 3 );				at: #at:atKey:put: put: '&lt;1s&gt;At: &lt;2s&gt; put: &lt;3s&gt;' -&gt; #( 1 2 3 );				at: #at:atKey:add: put: '&lt;1s&gt;At: &lt;2s&gt; add: &lt;3s&gt;' -&gt; #( 1 2 3 );				at: #at:removeKey: put: '&lt;1s&gt;Remove: &lt;2s&gt;' -&gt; #( 1 2 3 );				at: #at:atKey:remove: put: '&lt;1s&gt;At: &lt;2s&gt; remove: &lt;3s&gt;' -&gt; #( 1 2 3 )		].	^ selectorDictionary</body></methods><methods><class-id>COAST.SlotSelectorNavigatorPart</class-id> <category>testing</category><body package="COASTDevelopment">isSlotSelected	^ self selection notNil</body></methods><methods><class-id>COAST.SlotSelectorNavigatorPart</class-id> <category>actions</category><body package="COASTDevelopment">browseSlotReferences	| selectorEnvironment |	selectorEnvironment := Refactory.Browser.BrowserEnvironment new referencesTo: self selectedSlotName asSymbol.	selectorEnvironment isEmpty 		ifTrue: [ Dialog warn: 'no senders to slot ' , self selectedSlotName ]		ifFalse: [ selectorEnvironment openEditor ]</body><body package="COASTDevelopment">createSlot	| dialog |	dialog := NewSlotDialog frameClass: self frameClass.	dialog open.	dialog accept value		ifTrue: [ 			self 				createSlotNamed: dialog slotName 				type: dialog slotType 				range: dialog slotRange 				invertsTo: dialog invertedSlotName				consituent: dialog isConstituent				defaultValue: dialog defaultValue.			self 				createAccessors: dialog selectors 				for: dialog slotName 				parameter1: dialog parameter1				parameter2: dialog parameter2				protocol: 'accessing'.		].</body><body package="COASTDevelopment">createSlotAccessors	| dialog |	dialog := SlotDialog 				frameClass: self frameClass 				slotName: self selectedSlotName 				slotType: self selectedSlotType.	dialog open.	dialog accept value		ifTrue: [ 			self 				createAccessors: dialog selectors 				for: dialog slotName 				parameter1: dialog parameter1				parameter2: dialog parameter2				protocol: 'accessing'.		].</body></methods><methods><class-id>COAST.SlotSelectorNavigatorPart</class-id> <category>private - code generation</category><body package="COASTDevelopment">createAccessors: accessors for: slotName parameter1: p1 parameter2: p2 protocol: protocol	self slotCodeDefiner createAccessors: accessors for: slotName parameter1: p1 parameter2: p2 protocol: protocol</body><body package="COASTDevelopment">createSlotNamed: slotName type: type range: range invertsTo: invertedSlot consituent: isConsituent defaultValue: defaultValue 	self slotCodeDefiner  createSlotNamed: slotName type: type range: range invertsTo: invertedSlot consituent: isConsituent defaultValue: defaultValue</body><body package="COASTDevelopment">slotCodeDefiner	^ SlotCodeDefiner frameClass: self frameClass package: self navigator package</body></methods><methods><class-id>COAST.CoastGenericLauncher</class-id> <category>actions</category><body package="COASTDevelopment">applicationClass	^ ( QualifiedName pathString: self applicationClassAspect value asString ) valueOrDo: [ nil ]</body><body package="COASTDevelopment">browseUsername	| answer users |	self volumeExists 		ifFalse: [ ^ Dialog warn: 'Volume not created yet' for: self mainWindow ].	self client transactionManager transactionDo: 		[	users := ((( self client volumeManager namedModelsInVolume: self volume ) select: [: frame | frame isUser ]) 					collect: [: user | user name ]) asSortedCollection		].	answer := Dialog choose: 'choose a user' fromList: users values: users lines: 10 cancel: [ nil ].	answer notNil 		ifTrue: [ self usernameAspect value: answer ].</body><body package="COASTDevelopment">browseVolume	| volumes answer |	volumes := self availableVolumes asSortedCollection.	answer := Dialog choose: 'choose a volume' fromList: volumes values: volumes lines: 10 cancel: [ nil ].	answer notNil 		ifTrue: [ self volumeAspect value: answer ].</body><body package="COASTDevelopment">checkServer	| hostname connections serverString socketAddress |	hostname := self server.	hostname isNil 		ifTrue: [ ^ Dialog warn: 'No host specified' ].	[ Cursor wait showWhile: [ connections := self client volumeManager connectionsAtHost: hostname ]] 		on: Error		do: [: ex | ^ Dialog warn: ex description ].	socketAddress := Error handle: [: ex | nil ] do: [ IPSocketAddress hostAddressByName: SocketAccessor defaultClass getHostname ].	connections := connections asBag.	connections remove: socketAddress ifAbsent: [ ].	serverString := 'Clients: ' , connections size printString , '\' withCRs.	connections valuesAndCountsDo: [: c : n | serverString := serverString , '\' withCRs , ( IPSocketAddress hostNameByAddress: c ) , ' (' , n printString , ')' ].	Dialog warn: serverString.</body><body package="COASTDevelopment">exit	[client release] ensure: [client := nil].	(self builder componentAt: #openEditorID) enable</body><body package="COASTDevelopment">openEditor	| appClass serverPassword statusResponse |	appClass := self applicationClass.	appClass isNil 		ifTrue: 		[	Dialog warn: 'Application class not found' for: self mainWindow.			^ nil		].	[	self volumeExists 			ifFalse: 			[	serverPassword := Dialog request: 'Mediator password to create a new volume:' initialAnswer: '' onCancel: [ nil ] for: self mainWindow.				serverPassword isNil 					ifTrue: [ ^ self ].				statusResponse  := CoastMediatorStub createVolume: self volume atHost: self server remotePassword: serverPassword.				statusResponse ok 					ifFalse: [ COAST.CoastError raiseSignal: statusResponse message ]			].		self client transactionManager transactionDo: 			[ | user session |				user := self client registerUser: self username inVolume: self volume.				session := self client volumeManager findOrCreate: appClass named: appClass fullName , '-defaultSession' inVolume: self volume.				session openFor: user			].		( self builder componentAt: #openEditorID ) disable	] on: CoastError , OsError do: [: ex | Dialog warn: ex description for: self mainWindow ].</body><body package="COASTDevelopment">shutDown	[ client release ] ensure: [ client := nil ].	( self builder componentAt: #shutDownID ) disable.	( self builder componentAt: #openEditorID ) enable.</body><body package="COASTDevelopment">volumeExists	^ self availableVolumes includes: self volume</body></methods><methods><class-id>COAST.CoastGenericLauncher</class-id> <category>aspects</category><body package="COASTDevelopment">applicationClassAspect	^applicationClassAspect isNil		ifTrue:			[applicationClassAspect := 'COAST.CoastNotifierShared' asValue]		ifFalse:			[applicationClassAspect]</body><body package="COASTDevelopment">clientClassAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	clientClassAspect isNil		ifTrue: [			clientClassAspect := 'COAST.CoastApplicationClientWithUI' asValue.			clientClassAspect onChangeSend: #changedClientClass to: self.		].	^ clientClassAspect</body><body package="COASTDevelopment">clientClasses	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^clientClasses isNil		ifTrue:			[clientClasses := self availableClientClasses asList asValue]		ifFalse:			[clientClasses]</body><body package="COASTDevelopment">serverAspect	^ serverAspect isNil 		ifTrue: [ serverAspect := 'localhost' asValue ]		ifFalse: [ serverAspect ]</body><body package="COASTDevelopment">usernameAspect	^ usernameAspect isNil 		ifTrue: [ usernameAspect := String new asValue ]		ifFalse: [ usernameAspect ]</body><body package="COASTDevelopment">volumeAspect	^ volumeAspect isNil 		ifTrue: [ volumeAspect := String new asValue ]		ifFalse: [ volumeAspect ]</body></methods><methods><class-id>COAST.CoastGenericLauncher</class-id> <category>accessing</category><body package="COASTDevelopment">client	client isNil ifTrue: [self startClient].	^client</body><body package="COASTDevelopment">server	| hostname |	^ ( hostname := self serverAspect value ) notEmpty 		ifTrue: [ hostname ]		ifFalse: [ nil ]</body><body package="COASTDevelopment">startClient	| clientClass |	clientClass := self clientClass.	clientClass isNil 		ifTrue: [ ^ self ].	client := clientClass new.	( self builder componentAt: #shutDownID ) enable.	self updateServer.</body><body package="COASTDevelopment">username	^ self usernameAspect value</body><body package="COASTDevelopment">volume	^ self volumeAspect value</body></methods><methods><class-id>COAST.CoastGenericLauncher</class-id> <category>private</category><body package="COASTDevelopment">availableClientClasses		| classes |	classes := CoastApplicationClientWithUI allSubclasses.	classes add: CoastApplicationClientWithUI.	classes := classes collect: [ :cl | cl fullyQualifiedReference asString].	^classes asSortedCollection</body><body package="COASTDevelopment">availableVolumes	^ self client volumeManager availableVolumes</body><body package="COASTDevelopment">changedClientClass	| cClass appClass |	((cClass := self clientClass) notNil and: [ (appClass := cClass defaultApplicationClass) notNil ])		ifTrue: [ self applicationClassAspect value: appClass fullName ].</body><body package="COASTDevelopment">clientClass	^  (QualifiedName pathString: self clientClassAspect value asString) valueOrDo: [nil].</body><body package="COASTDevelopment">updateServer	self client volumeManager defaultHost: self server.</body></methods><methods><class-id>COAST.CoastGenericLauncher</class-id> <category>changing</category><body package="COASTDevelopment">changeRequest	self shutDown.	^ super changeRequest.</body></methods><methods><class-id>COAST.DebugClusterInfo</class-id> <category>interface</category><body package="COASTDevelopment">flushHistory	history := #().</body><body package="COASTDevelopment">logAccess	self logOnHistory: #logAccess.	super logAccess</body><body package="COASTDevelopment">logLoad	CoastLog debugDo: 		[	history reverse 				detect: 				[: assoc | ( assoc value = #logUnload )						ifTrue: 							[	CoastLog logDebug: 'cluster reloaded after: ' , ( Timestamp now asSeconds - assoc key asSeconds ) printString									channel: #clusterAnalyse							];						yourself				]				ifNone: nil		].	self logOnHistory: #logLoad.	super logLoad</body><body package="COASTDevelopment">logOnHistory: string 	history add: Timestamp now -&gt; string</body><body package="COASTDevelopment">logUnload	CoastLog debugDo: 		[	history reverse 				detect: 				[: assoc | ( assoc value = #logLoad )						ifTrue: 							[	CoastLog logDebug: 'cluster unloaded after: ' , ( Timestamp now asSeconds - assoc key asSeconds ) printString									channel: #clusterAnalyse							];						yourself				]				ifNone: nil		].	self logOnHistory: #logUnload.	super logUnload</body></methods><methods><class-id>COAST.DebugClusterInfo</class-id> <category>printing</category><body package="COASTDevelopment">printOn: stream 	| firstTime |	stream nextPutAll: 'DebugClusterInfo'.	firstTime := nil.	history do: 		[: assoc | | time |			stream				cr;				tab.			time := firstTime isNil 					ifTrue: [ firstTime := assoc key asTime ]					ifFalse: 					[	stream nextPut: $+.						assoc key asTime subtractTime: firstTime					].			time printOn: stream.			stream				tab;				nextPutAll: assoc value		]</body></methods><methods><class-id>COAST.DebugClusterInfo</class-id> <category>accessing</category><body package="COASTDevelopment">history	^ history</body></methods><methods><class-id>COAST.DebugClusterInfo</class-id> <category>initialize-release</category><body package="COASTDevelopment">initialize	super initialize.	history := OrderedCollection new</body></methods><methods><class-id>COAST.NiceTextCollector</class-id> <category>entry control</category><body package="COASTDevelopment">beginEntry	"To speed up appending information to the receiver, a WriteStream is	maintained.  Initialize it."	entryStream := TextStream on: (String new: 200)</body></methods><methods><class-id>COAST.NiceTextCollector</class-id> <category>private</category><body package="COASTDevelopment">characterLimit	^ 50000</body></methods><methods><class-id>COAST.NiceTextCollector</class-id> <category>accessing</category><body package="COASTDevelopment">nextPutAll: aCollection 	"Append all the characters in aCollection to the text."	^entryStream nextPutAllText: aCollection</body></methods><methods><class-id>COAST.NiceTextCollector class</class-id> <category>instance creation</category><body package="COASTDevelopment">newTranscript	self newTranscript: self new.	VisualLauncher open.</body></methods><methods><class-id>COAST.CoastFileLogger class</class-id> <category>utility</category><body package="COASTDevelopment">cr	| stream |	stream := (Filename named: 'coast.log') appendStream.	stream nextPut: Character cr.	stream close.	Transcript cr.</body><body package="COASTDevelopment">show: aString	| stream |	stream := (Filename named: 'coast.log') appendStream.	stream nextPutAll: aString.	stream close.	Transcript show: aString.</body></methods><methods><class-id>COAST.CoastLogControl</class-id> <category>aspects</category><body package="COASTDevelopment">channelsAspect	| channels selectionAdaptor |	channelsAspect isNil 		ifTrue: 		[	channels := self class availableChannels asSortedCollection.			channelsAspect := MultiSelectionInList with: channels.			selectionAdaptor := self				logAdaptorGet: [: log | log channels collect: [: channel | channels indexOf: channel ]]				put: [: log : channelIndexes | log channels: ( channelIndexes collect: [: idx | channels at: idx ])].			channelsAspect selectionIndexHolder: selectionAdaptor.		].	^ channelsAspect</body><body package="COASTDevelopment">filterChannelsAspect	filterChannelsAspect isNil 		ifTrue: [ filterChannelsAspect := self logAdaptorGet: [: log | log filterChannels ] put: [: log : v | log filterChannels: v ]].	^ filterChannelsAspect</body><body package="COASTDevelopment">haltOnExceptionsAspect	haltOnExceptionsAspect isNil 		ifTrue: [ haltOnExceptionsAspect := self logAdaptorGet: [: log | log haltOnExceptions ] put: [: log : v | log haltOnExceptions: v ] ].	^ haltOnExceptionsAspect</body><body package="COASTDevelopment">logFileNameAspect	logFileNameAspect isNil ifTrue: [ 		logFileNameAspect := self								logAdaptorGet: [ : log | log developFileName ifNil: [ ''] ] 								put: [ : log : v | 									v isEmpty 										ifTrue: [ 	log transcriptFilename: nil; enableFileLog: false. ]										ifFalse: [ log transcriptFilename: v; enableFileLog: true. ].									].		].	^ logFileNameAspect</body><body package="COASTDevelopment">logLevelAspect	logLevelAspect isNil 		ifTrue: [ logLevelAspect := self logAdaptorGet: [: log | log logLevel ] put: [: log : v | log logLevel: v ]].	^ logLevelAspect</body></methods><methods><class-id>COAST.CoastLogControl</class-id> <category>private</category><body package="COASTDevelopment">currentLog	^ COAST.CoastLog singleton</body><body package="COASTDevelopment">logAdaptorGet: getBlock put: putBlock 	^ ( PluggableAdaptor on: self ) 		getBlock: [: control | getBlock value: control currentLog ]		putBlock: [: control : v | putBlock value: control currentLog value: v ]		updateBlock: [: m : a : p | true ]</body></methods><methods><class-id>COAST.CoastLogControl</class-id> <category>actions</category><body package="COASTDevelopment">clearChannels	self channelsAspect selections: Set new</body></methods><methods><class-id>COAST.CoastLogControl class</class-id> <category>accessing</category><body package="COASTDevelopment">availableChannels	^ AvailableChannels ifNil: [ #(#accessLog #balancer #bfs #blockCache #coastCache #coastIO #coastRPC #concurrency #converter #crypto #default #expertQuery #gds #glorp #job #journal #kem #kemRequests #ldap #load #lucene #mail #performance #printing #profile #request #resolving #responseContents #rest #rights #schema #search #simpleSearch #solving #sql #ssl #trigger #unloadStrategy unloadProcess #upgrade #validStructure #views #wsdl) ].</body></methods><methods><class-id>COAST.CoastProfilingFrame</class-id> <category>linking</category><body package="COASTDevelopment">linkTo: aTestFrame maxRefs: slotCount 	| rnd sz |	rnd := Random new.	sz := self sizeAt: #multiValue.	sz &gt; (rnd next * slotCount + 1)		ifTrue: [((self at: #multiValue) asOrderedCollection at: (rnd next * sz + 1) asInteger)				linkTo: aTestFrame maxRefs: slotCount]		ifFalse: [self at: #multiValue add: aTestFrame]</body></methods><methods><class-id>COAST.CoastProfilingFrame</class-id> <category>acccessing</category><body package="COASTDevelopment">singleValue	^ self at: #singleValue</body><body package="COASTDevelopment">singleValue: something	self at: #singleValue set: something</body></methods><methods><class-id>COAST.CoastProfilingFrame class</class-id> <category>slot description</category><body package="COASTDevelopment">dummy10Slot	^ self slotSingleValue</body><body package="COASTDevelopment">dummy1Slot	^ self slotSingleValue</body><body package="COASTDevelopment">dummy2Slot	^ self slotSingleValue</body><body package="COASTDevelopment">dummy3Slot	^ self slotSingleValue</body><body package="COASTDevelopment">dummy4Slot	^ self slotSingleValue</body><body package="COASTDevelopment">dummy5Slot	^ self slotSingleValue</body><body package="COASTDevelopment">dummy6Slot	^ self slotSingleValue</body><body package="COASTDevelopment">dummy7Slot	^ self slotSingleValue</body><body package="COASTDevelopment">dummy8Slot	^ self slotSingleValue</body><body package="COASTDevelopment">dummy9Slot	^ self slotSingleValue</body><body package="COASTDevelopment">multiValueOfSlot	^(self slotOfType: #set)		invertsTo: #multiValue;		yourself</body><body package="COASTDevelopment">multiValueSlot	^(self slotOfType: #set)		invertsTo: #multiValueOf;		yourself</body><body package="COASTDevelopment">singleValueSlot	^ self slotSingleValue</body></methods><methods><class-id>COAST.SlotCodeDefiner</class-id> <category>private</category><body package="COASTDevelopment">accessorItemsDictionary	accessorItemsDictionary isNil		ifTrue: [			accessorItemsDictionary := Dictionary new.			accessorItemsDictionary				at: #singleValue put: #(#at: #at:set:);				at: #virtual put: #(#at:).			#(set orderedCollection ) do: [ : type |				accessorItemsDictionary at: type put: #(#at: #at:add: #at:remove: #at:setAll:)			].			#(bag ) do: [ : type |				accessorItemsDictionary at: type put: #(#at: #at:add: #at:remove:)			].			#(dictionary proxyDictionary compactKeyDictionary compactDictionary indexProxy 			compactIndex compactValueIndex compactKeyIndex) do: [ : type |				accessorItemsDictionary at: type put: #(#at: #at:atKey: #at:atKey:put: #at:removeKey:)			].			#(multiValueDictionary) do: [ : type |				accessorItemsDictionary at: type put: #(#at: #at:atKey: #at:atKey:add: #at:removeKey: #at:atKey:remove:)			].		].	^ accessorItemsDictionary</body><body package="COASTDevelopment">readAccessors	^ #(#at: #at:atKey:)</body><body package="COASTDevelopment">selectorDictionary	selectorDictionary isNil 		ifTrue: 		[	selectorDictionary := Dictionary new.			selectorDictionary				at: #at: put: '&lt;1s&gt;' -&gt; #( 1 );				at: #at:set: put: '&lt;1s&gt;: &lt;2s&gt;' -&gt; #( 1 2 );				at: #at:setAll: put: '&lt;1s&gt;: &lt;6s&gt;' -&gt; #( 1 6 );				at: #at:add: put: 'add&lt;5s&gt;: &lt;2s&gt;' -&gt; #( 1 2 );				at: #at:remove: put: 'remove&lt;5s&gt;: &lt;2s&gt;' -&gt; #( 1 2 );				at: #at:atKey: put: '&lt;1s&gt;At: &lt;2s&gt;' -&gt; #( 1 2 );				at: #at:atKey:put: put: '&lt;1s&gt;At: &lt;2s&gt; put: &lt;3s&gt;' -&gt; #( 1 2 3 );				at: #at:atKey:put: put: '&lt;1s&gt;At: &lt;2s&gt; put: &lt;3s&gt;' -&gt; #( 1 2 3 );				at: #at:atKey:add: put: '&lt;1s&gt;At: &lt;2s&gt; add: &lt;3s&gt;' -&gt; #( 1 2 3 );				at: #at:removeKey: put: '&lt;1s&gt;Remove: &lt;2s&gt;' -&gt; #( 1 2 3 );				at: #at:atKey:remove: put: '&lt;1s&gt;At: &lt;2s&gt; remove: &lt;3s&gt;' -&gt; #( 1 2 3 )		].	^ selectorDictionary</body><body package="COASTDevelopment">setPackage: aPackage while: aBlock 	| policiesRef |	( aPackage isNil or: [ aPackage isBundle ]) 		ifTrue: [ ^ aBlock value ].	policiesRef := #{Store.Policies}.	policiesRef isDefined 		ifFalse: [ ^ aBlock value ].	policiesRef value packagePolicy forcePackage: aPackage while: aBlock.</body></methods><methods><class-id>COAST.SlotCodeDefiner</class-id> <category>code generation</category><body package="COASTDevelopment">createAccessors: accessors for: slotName parameter1: p1 parameter2: p2 protocol: protocol	| code |	code := self createCodeForAccessors: accessors for: slotName parameter1: p1 parameter2: p2 protocol: protocol.	code notNil ifTrue: [ self fileIn: code ]</body><body package="COASTDevelopment">createCodeForAccessors: accessors for: slotName parameter1: p1 parameter2: p2 protocol: protocol	| codeStream params upperSlotName singularName pluralName |	accessors isEmpty ifTrue: [ ^ nil ].	codeStream := (String new: 64) writeStream.	" class header "	codeStream cr; cr;		nextPut: $!;		nextPutAll: self frameClass fullName asString;		nextPutAll: ' methodsFor: ''', protocol, '''!';		cr;cr.	params := OrderedCollection new.	upperSlotName := slotName copy at: 1 put: slotName first asUppercase; yourself.	singularName := (('*#s' match: upperSlotName) ifTrue: [ upperSlotName copyFrom: 1 to: upperSlotName size - 1] ifFalse: [ upperSlotName ]).	pluralName := 'some', upperSlotName.	params 		add: slotName;		add: p1;		add: p2;		add: upperSlotName;		add: singularName;		add: pluralName.	accessors do: [ : accessor | 		| methodHeader accessorParts methodDef |		methodDef  := (self selectorDictionary at: accessor asSymbol) .		" method header "		methodHeader := methodDef key expandMacrosWithArguments: params.		codeStream nextPutAll: methodHeader; cr; cr; tab.		" method body "		(self readAccessors includes: accessor asSymbol)			ifTrue: [ codeStream nextPutAll: '^ ' ].		codeStream nextPutAll: 'self '.		accessorParts := accessor piecesCutWhere: [ : c1 :c2 | c1 = $: ].		accessorParts keysAndValuesDo: [ : i : part |			i &gt; 1 ifTrue: [ codeStream space ].			codeStream 				nextPutAll: part;				space.			i = 1 ifTrue: [ codeStream nextPut: $# ].			codeStream				nextPutAll: (params at: (methodDef value at: i)).		].		codeStream nextPutAll: '. !';cr;cr.	].	codeStream nextPutAll: ' !';cr.	^ codeStream contents</body><body package="COASTDevelopment">createCodeForSlotNamed: slotName type: type range: range invertsTo: invertedSlot consituent: isConsituent defaultValue: defaultValue	| codeStream hasCascade |	codeStream := (String new: 64) writeStream.	" class header "	codeStream cr; cr;		nextPut: $!;		nextPutAll: self frameClass fullName asString;		nextPutAll: ' class methodsFor: ''slots''!';		cr;cr.	" slot header "	codeStream nextPutAll: slotName; nextPutAll: 'Slot'; cr; cr; tab.	" slot body "	codeStream nextPutAll: '^ '.	type = #singleValue		ifTrue: [ codeStream nextPutAll: 'self slotSingleValue' ]		ifFalse: [ codeStream nextPutAll: '(self slotOfType: '; nextPutAll: type printString; nextPut: $) ].	" demons "	hasCascade := false.	range notNil		ifTrue: [ 			hasCascade := true.			codeStream cr; tab; tab; nextPutAll: 'range: '; nextPutAll:  range; nextPut: $; ].	invertedSlot notNil		ifTrue: [				hasCascade := true.			codeStream cr; tab; tab; nextPutAll: 'invertsTo: '; nextPutAll: invertedSlot asSymbol printString; nextPut: $; ].	isConsituent		ifTrue: [				hasCascade := true.			codeStream cr; tab; tab; nextPutAll: 'constituent'; nextPut: $; ].	defaultValue notNil		ifTrue: [ 			hasCascade := true.			codeStream cr; tab; tab; nextPutAll: 'defaultValue: '; nextPutAll: defaultValue; nextPut: $;		].	hasCascade 		ifTrue: [ codeStream cr; tab; tab; nextPutAll: 'yourself' ].	codeStream nextPutAll: '! !';cr.	^ codeStream contents</body><body package="COASTDevelopment">createSlotNamed: slotName type: type range: range invertsTo: invertedSlot consituent: isConsituent defaultValue: defaultValue 	| code |	code := self createCodeForSlotNamed: slotName type: type range: range invertsTo: invertedSlot consituent: isConsituent defaultValue: defaultValue.	self fileIn: code</body><body package="COASTDevelopment">fileIn: code	self package 		ifNotNil: [: pkg | self setPackage: pkg while: [ code readStream fileIn ]] 		ifNil: [ code readStream fileIn ].</body></methods><methods><class-id>COAST.SlotCodeDefiner</class-id> <category>accessing</category><body package="COASTDevelopment">frameClass	^ frameClass</body><body package="COASTDevelopment">frameClass: aFrameClass 	frameClass := aFrameClass.</body><body package="COASTDevelopment">package	^ package</body><body package="COASTDevelopment">package: aPackage 	package := aPackage.</body></methods><methods><class-id>COAST.SlotCodeDefiner class</class-id> <category>instance creation</category><body package="COASTDevelopment">frameClass: aFrameClass  	^ self new frameClass: aFrameClass ; yourself</body><body package="COASTDevelopment">frameClass: aFrameClass  package: aStorePackage	^ self new frameClass: aFrameClass ; package: aStorePackage; yourself</body></methods><methods><class-id>Refactory.Browser.CoastSlotAwareBrowserNavigator</class-id> <category>menus</category><body package="COASTDevelopment">cacheSlotComputingsFor: slotDefs 	| unknownSlots |	slotToComputingDict isNil 		ifTrue: [ slotToComputingDict := IdentityDictionary new: slotDefs size ].	unknownSlots := slotDefs reject: [: slotDef | slotToComputingDict includesKey: slotDef ].	unknownSlots isEmpty 		ifFalse: 		[	COAST allBehaviorsDo: 				[: fc | | method nextIsComposingMethod messages |					fc isMeta 						ifTrue: 						[	unknownSlots do: 								[: slotDef | ( fc includesSelector: slotDef ) 										ifTrue: 										[	method := fc compiledMethodAt: slotDef ifAbsent: [ nil ].											method notNil 												ifTrue: 												[	messages := slotToComputingDict at: slotDef put: OrderedCollection new.													nextIsComposingMethod := false.													method allSymbolLiteralsDo: 														[: sym |															nextIsComposingMethod 																ifTrue: [ messages add: sym ].															nextIsComposingMethod := #slotComputedBy: == sym or: [ #slotComputedEagerBy: == sym ]														]												]										]								]						]				].			unknownSlots do: 				[: unknownSlot | ( slotToComputingDict includesKey: unknownSlot ) 						ifFalse: [ slotToComputingDict at: unknownSlot put: OrderedCollection new ]				]		].</body><body package="COASTDevelopment">coastSlotComputationActions: slotDefs for: aSymbol 	| messages actions |	messages := Set new: slotDefs size.	self cacheSlotComputingsFor: slotDefs.	slotDefs do: 		[: slotDef |			messages addAll: ( slotToComputingDict at: slotDef						ifAbsent: 						[	"Transcript show: 'oopsy: ' , slotDef; cr."							#( )						])		].	messages isEmpty ifTrue: [ ^ #( )].	messages := messages asSortedCollection.	actions := OrderedCollection new: self maxSentSelectors.	messages size &gt; self maxSentSelectors 		ifTrue: 		[	actions add: ( RBCommand named: 'Slot Computing...'						description: ''						action: 						[ | selector |							selector := self choose: #SelectAMessageC &lt;&lt; #browser &gt;&gt; 'Select a message:' from: messages.							selector notNil 								ifTrue: [ self perform: aSymbol with: selector ]								ifFalse: [ nil ]						]						receiver: #yourself )		]		ifFalse: 		[	actions add: nil.			actions add: ( RBCommand named: 'Slot Computing' asText allItalic description: 'Slot Definitions' action: [ ] receiver: #yourself ).			messages do: 				[: each |					actions add: ( RBCommand named: ( self menuNameFor: each )								description: #SendersImplementors &lt;&lt; #browser &gt;&gt; 'Senders/Implementors'								action: [ self perform: aSymbol with: each ]								receiver: #yourself )				]		].	^ actions</body><body package="COASTDevelopment">coastSlotDefinitionActionsFor: aSymbol 	| messages actions |	messages := OrderedCollection new.	Symbol hasInterned: self selector , 'Slot' ifTrue: [: sym | messages add: sym ].	self sentSelectors do: [: sel | Symbol hasInterned: sel , 'Slot' ifTrue: [: sym | messages add: sym ]].	messages isEmpty ifTrue: [ ^ #( )].	actions := OrderedCollection new: self maxSentSelectors.	actions add: nil.	messages size &gt; self maxSentSelectors 		ifTrue: 		[	actions add: ( RBCommand named: 'Slot Definitions...'						description: ''						action: 						[ | selector |							selector := self choose: #SelectAMessageC &lt;&lt; #browser &gt;&gt; 'Select a message:' from: messages.							selector notNil 								ifTrue: [ self perform: aSymbol with: selector ]								ifFalse: [ nil ]						]						receiver: #yourself )		]		ifFalse: 		[	actions add: ( RBCommand named: 'Slot Definitions:' asText allItalic description: 'Slot Definitions' action: [ ] receiver: #yourself ).			messages do: 				[: each |					actions add: ( RBCommand named: ( self menuNameFor: each )								description: #SendersImplementors &lt;&lt; #browser &gt;&gt; 'Senders/Implementors'								action: [ self perform: aSymbol with: each ]								receiver: #yourself )				]		].	actions add: nil.	^ ( self coastSlotComputationActions: messages for: aSymbol ) , actions</body><body package="COASTDevelopment">globalImplementorsActions	^ ( self coastSlotDefinitionActionsFor: #browseGlobalImplementorsOf: ) , ( self sendersImplementorsActionsFor: #browseGlobalImplementorsOf: )</body><body package="COASTDevelopment">hierarchyImplementorsActions	^ ( self coastSlotDefinitionActionsFor: #browseHierarchyImplementorsOf: ) 		, ( self sendersImplementorsActionsFor: #browseHierarchyImplementorsOf: )</body></methods><methods><class-id>COAST.CatRMInternalMediatorPacketStation</class-id> <category>private: initialize</category><body package="COASTDevelopment">initializeForPacketStation: aCatRMInternalClientPacketStation forPeerID: anInteger	peerID := anInteger.	clientPacketStation := aCatRMInternalClientPacketStation.	clientPacketStation mediatorPacketStation: self.	clientPacketStation ownID: anInteger.</body><body package="COASTDevelopment">startClientActivityWatchdog	self setLastReceiveTime.	^ super startClientActivityWatchdog</body></methods><methods><class-id>COAST.CatRMInternalMediatorPacketStation</class-id> <category>state acessing</category><body package="COASTDevelopment">closeConnection	connected ifFalse: [ ^nil ].	Object errorSignal		handle: [ :ex | ex return ]		do:		[			receiveProcess terminate.			sendProcess terminate.		].	self unsetConnected.	clientPacketStation unsetConnected.</body></methods><methods><class-id>COAST.CatRMInternalMediatorPacketStation</class-id> <category>private: send/receive</category><body package="COASTDevelopment">receiveBlock	^ []</body><body package="COASTDevelopment">send: aCatRMMessage	" a transmitted message consists of the classname and the marshalled message "	aCatRMMessage transportsCluster		ifTrue:		[ | marshall writeStream |			marshall := CatMAMarshallBinary new.			writeStream := WriteStream on: (ByteArray new: 1024).			writeStream nextCoastStringPut: aCatRMMessage messageClassName.			marshall marshall: aCatRMMessage to: writeStream.			clientPacketStation deliverMarshalledMessage: writeStream contents.		]			ifFalse: [ clientPacketStation deliverReceivedMessage: aCatRMMessage ].	^connected</body></methods><methods><class-id>COAST.CatRMInternalMediatorPacketStation class</class-id> <category>instance creation</category><body package="COASTDevelopment">newWithPacketStation: aCatRMInternalClientPacketStation forPeerID: anInteger	^self new initializeForPacketStation: aCatRMInternalClientPacketStation forPeerID: anInteger</body></methods><methods><class-id>COAST.Hostlist class</class-id> <category>accessing</category><body package="COASTDevelopment">addRecentHostAndPort: hostAndPort 	| recentHostAndPorts writeStream |	hostAndPort = 'localhost' ifTrue: [ ^ self ].	recentHostAndPorts := self recentHostAndPorts.	( recentHostAndPorts includes: hostAndPort ) ifTrue: [ ^ self ].	writeStream := self hostFile appendStream.	[	writeStream			nextPutAll: hostAndPort;			cr	] ensure: [ writeStream close ]</body><body package="COASTDevelopment">addRecentHostAndPort: hostAndPort volumes: volumeNames 	| writeStream recentVolumes |	recentVolumes := self recentVolumes.	volumeNames do: [: vol | recentVolumes add: ( RecentVolume host: hostAndPort volume: vol )].	writeStream := self volumesFile writeStream.	[	recentVolumes do: 			[: recentVolume |				recentVolume writeOn: writeStream.				writeStream cr			]	] ensure: [ writeStream close ].</body><body package="COASTDevelopment">hostFile	^ 'hostlist.txt' asFilename</body><body package="COASTDevelopment">recentHostAndPorts	| readStream recentHostAndPorts hostFile |	recentHostAndPorts := Set new.	hostFile := self hostFile.	hostFile definitelyExists ifFalse: [ ^ recentHostAndPorts ].	readStream := hostFile readStream.	[			[ readStream atEnd ] whileFalse: 			[ | string |				string := readStream nextLine.				string isEmpty ifFalse: [ recentHostAndPorts add: string ]			]	] ensure: [ readStream close ].	^ recentHostAndPorts</body><body package="COASTDevelopment">recentVolumes	| readStream recentVolumes volumesFile |	recentVolumes := Set new.	volumesFile := self volumesFile.	volumesFile definitelyExists 		ifFalse: [ ^ recentVolumes ].	readStream := volumesFile readStream text.	[			[ readStream atEnd ] whileFalse: 			[ | recentVolume |				recentVolume := RecentVolume fromString: readStream nextLine.				recentVolume notNil					ifTrue: [ recentVolumes add: recentVolume ]			]	] ensure: [ readStream close ].	^ recentVolumes</body><body package="COASTDevelopment">volumesFile	^ 'volumeslist.txt' asFilename</body></methods><methods><class-id>COAST.Hostlist class</class-id> <category>utility</category><body package="COASTDevelopment">chooseHostAndVolume	"self chooseHostAndVolume"	| volumesAndHostNames selectedHostNameAndVolume hostAndVolumeTokenizer hostAndVolume dialog |	volumesAndHostNames := OrderedCollection new.	self recentVolumes do:  [: recentVolume | volumesAndHostNames add: recentVolume volume , ' @ ' , recentVolume host ].	hostAndVolumeTokenizer := [: string | ( string tokensBasedOn: $@ ) collect: [: s | s trimBlanks ]].	volumesAndHostNames := volumesAndHostNames asSortedCollection.	dialog := IncrementalSearchDialog 			forRequestWithSuggestions: volumesAndHostNames			filterBlock: 			[: entry : volumeAndHost | | volumeTokens entryPatterns |				volumeTokens := hostAndVolumeTokenizer value: volumeAndHost.				entryPatterns := ( entry tokensBasedOn: Character space) collect: [: s | '*', s trimBlanks, '*' ].				entryPatterns allSatisfy: [: pattern | volumeTokens anySatisfy: [: token | pattern match: token ignoreCase: true ]]			].	dialog 		firstLabel: 'Volume @ host:';		secondLabel: 'Recent volumes:'.	selectedHostNameAndVolume := dialog request.	^ selectedHostNameAndVolume notNil 		ifTrue: 		[	hostAndVolume := ( selectedHostNameAndVolume tokensBasedOn: $@ ) collect: [: s | s trimBlanks ].			hostAndVolume size = 2 				ifTrue: [( hostAndVolume at: 2 ) -&gt; ( hostAndVolume at: 1 )]				ifFalse: [ nil ]		]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CoastMediatorRemoteControl</class-id> <category>private</category><body package="COASTDevelopment">beOffline	self statusAspect value: 'Not connected'.	self volumes: List new.	mediatorVersion := String new</body><body package="COASTDevelopment">checkCoastVersionForTransfer	| minVersion |	mediatorVersion isEmpty ifTrue: [ ^ false ].	minVersion := CoastClientClusterManager minCoastTransferVersion.	^ (CoastVersion fromString: mediatorVersion) &gt;= minVersion</body><body package="COASTDevelopment">fixPortAspect	self portAspect value = 0 ifTrue: [ self portAspect value: self defaultServerPort ].</body><body package="COASTDevelopment">noVolumeSelected	Dialog warn: 'no volume selected' for: self mainWindow.</body><body package="COASTDevelopment">requestNewVolumeName	^ self requestNewVolumeName: 'NewVolume'</body><body package="COASTDevelopment">requestNewVolumeName: initialName	^ Dialog		request: 'New volume name:'		initialAnswer: initialName		windowLabel: 'Enter volume Name'		for: nil.</body><body package="COASTDevelopment">showWaitWhile: block onError: errorBlock 	^Cursor wait showWhile: [block on: Error do: [:ex | errorBlock value: ex]]</body><body package="COASTDevelopment">updateServerStatus	| hostAndPort mediatorCoastVersion statusStream status |	hostAndPort := self hostAndPort.	statusStream := ( String new: 64 ) writeStream.	( hostAndPort isEmpty or: [ hostAndPort isNil ]) 		ifTrue: [ ^ Dialog warn: 'No host specified' for: self mainWindow ].	[	mediatorCoastVersion := CoastMediatorStub versionAtHost: hostAndPort.		mediatorVersion := mediatorCoastVersion printString.		statusStream nextPutAll: 'Version: '; nextPutAll: mediatorVersion.		Hostlist addRecentHostAndPort: hostAndPort.		"can crash mediator - tmp disabled by HS 10.4.03		mediatorCoastVersion &lt;= CoastVersion defaultCoastVersion ifTrue: 			[ | client ownSocketAddress connections |				client := CoastApplicationClient new.				client volumeManager defaultHost: hostAndPort.				[ connections := ( client volumeManager connectionsAtHost: hostAndPort ) asSet ] ensure: [ client release ].				ownSocketAddress := IPSocketAddress hostAddressByName: CoastSocketAccessor concreteClass getHostname.				connections remove: ownSocketAddress ifAbsent: [ nil ].				connections := connections reject: [: ip | ip = #[ 127 0 0 1 ]].				statusStream					nextPutAll: ', Connections:  ';					nextPutAll: connections size printString			]."		status := statusStream contents	] on: Error do: [: ex | status := 'Error: ' , ex description ].	self statusAspect value: status.</body><body package="COASTDevelopment">withAdminFrameDo: block 	| vm cm cluster0 |	vm := CoastClientVolumeManager new.	cm := vm clusterManagerForVolume: self selectedVolume host: self hostAndPort.	cluster0 := cm rootClusterNeeded.	vm transactionManager transactionDo: [ block value: cluster0 administrationFrame ].	vm shutDown</body></methods><methods><class-id>COAST.CoastMediatorRemoteControl</class-id> <category>aspects</category><body package="COASTDevelopment">comment	comment isNil ifTrue: [ comment := '' asValue ].	^ comment</body><body package="COASTDevelopment">commentAspect	hostAspect isNil ifTrue: [ hostAspect := '' asValue ].	^ hostAspect</body><body package="COASTDevelopment">defaultServerPort	^ CoastMediator defaultServerPort</body><body package="COASTDevelopment">historyList	historyList isNil ifTrue: [		historyList := SelectionInList new.		historyList listHolder value: self volumeInfoList.		].	^  historyList</body><body package="COASTDevelopment">hostAspect	hostAspect isNil ifTrue: [ hostAspect := 'localhost' asValue ].	^ hostAspect</body><body package="COASTDevelopment">passwordAspect	passwordAspect isNil ifTrue: [ passwordAspect := 'c0ast!' asValue ].	^ passwordAspect</body><body package="COASTDevelopment">portAspect	portAspect isNil ifTrue: [ portAspect := self defaultServerPort asValue ].	^ portAspect</body><body package="COASTDevelopment">statusAspect	statusAspect isNil ifTrue: 		[	statusAspect := String new asValue.			self canStartLocalMediator 				ifTrue: [ self beOffline ]				ifFalse: [ self rescanVolumes ]		].	^ statusAspect</body><body package="COASTDevelopment">volumesAspect	volumesAspect isNil ifTrue: [ volumesAspect := SelectionInList new ].	^ volumesAspect</body></methods><methods><class-id>COAST.CoastMediatorRemoteControl</class-id> <category>resources</category><body package="COASTDevelopment">defaultMenu	^ self class defaultMenu</body></methods><methods><class-id>COAST.CoastMediatorRemoteControl</class-id> <category>testing</category><body package="COASTDevelopment">canStartLocalMediator	^ ( CoastMediator activeMediatorAtPort: self portAspect value ) isNil</body><body package="COASTDevelopment">hasConnections	^ self connections notEmpty</body><body package="COASTDevelopment">isListedVolume: volume 	^ self volumesAspect list includes: volume</body><body package="COASTDevelopment">isRemoteMediator	^ self hostAspect value ~= 'localhost'</body><body package="COASTDevelopment">isVolumeSelected	^ self selectedVolume notNil</body></methods><methods><class-id>COAST.CoastMediatorRemoteControl</class-id> <category>accessing</category><body package="COASTDevelopment">connections	^ COAST.CoastMediatorStub connectionsAtHost: self hostAndPort</body><body package="COASTDevelopment">hostAndPort	| tokens hostName port stream |	tokens := self hostAspect value tokensBasedOn: $:.	hostName := tokens first.	tokens size = 2 		ifTrue: 		[	port := ( tokens at: 2 ) asInteger.			port = 0 ifTrue: [ port := self defaultServerPort ].			self hostAspect value: hostName.			self portAspect value: port		]		ifFalse: [ port := self portAspect value ].	stream := String new writeStream.	stream nextPutAll: hostName; nextPut: $:.	port printOn: stream.	^ stream contents</body><body package="COASTDevelopment">remotePassword	^ self passwordAspect value</body><body package="COASTDevelopment">selectedVolume	^ self volumesAspect selection</body><body package="COASTDevelopment">selectedVolume: selection 	^ self volumesAspect selection: selection</body><body package="COASTDevelopment">volumes: list 	self volumesAspect list: list</body></methods><methods><class-id>COAST.CoastMediatorRemoteControl</class-id> <category>actions</category><body package="COASTDevelopment">addComment	| string |	string := self comment value.	string isEmpty ifTrue: [ ^ self ].	self withAdminFrameDo: [ : adminFrame | adminFrame volumeInfo: string ].	self historyList listHolder value: self volumeInfoList.</body><body package="COASTDevelopment">browseServers	| list newHost |	list := Hostlist recentHostAndPorts.	( CoastMediator allInstances select: [: mediator | mediator isActive ]) 		do: [: mediator | list add: 'localhost:' , mediator serverPort printString ].	list := list asSortedCollection.	newHost := Dialog choose: 'Choose host' fromList: list values: list lines: 8 cancel: [ ^ self ].	self hostAspect value: newHost.	self rescanVolumes</body><body package="COASTDevelopment">downloadLog	| file |	file := Dialog requestFileName: '' default: 'mediator.log' version: #new.	file notEmpty 		ifTrue: 		[	self 				showWaitWhile: [ CoastMediatorStub downloadLogFromHost: self hostAndPort toFilename: file remotePassword: self remotePassword ]				onError: [: ex | Dialog warn: ex description for: self mainWindow ]		].</body><body package="COASTDevelopment">openVolumeInfo	"self readVolumeInfo."	self openInterface: #infoSpec</body><body package="COASTDevelopment">rescanVolumes	| host oldSelection |	host := self hostAndPort.	oldSelection := self selectedVolume.	host = '' 		ifTrue: [ self volumes: List new ]		ifFalse: 		[	self showWaitWhile: [ self volumes: ( CoastClientVolumeManager volumesAtHost: host ) asSortedCollection asList ]				onError: 				[: ex |					self beOffline.					^ self statusAspect value: 'Could not connect: ' , ex description				]		].	self selectedVolume: oldSelection.	( Delay forMilliseconds: 10 ) wait.	self updateServerStatus.</body><body package="COASTDevelopment">showConnections	| ocStrings |	ocStrings := self connections collect: [ : item | item printString ].	Dialog choose: 'Active Connections' fromList: ocStrings values: ocStrings lines: 20 cancel: [ #noChoice ]</body><body package="COASTDevelopment">shutDownMediator	| host statusResponse |	host := self hostAndPort.	host = '' 		ifTrue: [ ^ self ].	( self isRemoteMediator not or: [ Dialog confirm: 'Shut down mediator?' ]) 		ifFalse: [ ^ self ].	( self hasConnections and: [( Dialog confirm: 'Mediator has connections, shut down anyway?' ) not ]) 		ifTrue: [ ^ self ].	[	statusResponse := Cursor wait showWhile: [ CoastMediatorStub shutDownMediatorAtHost: host password: self remotePassword ].		Dialog warn: statusResponse message for: self mainWindow.		self beOffline	] on: Error do: [: ex | self statusAspect value: ex description ].</body><body package="COASTDevelopment">startMediator	self canStartLocalMediator 		ifFalse: [ ^ Dialog warn: 'Mediator already running on this port!' for: self mainWindow ].	Cursor wait showWhile: 		[ | mediator |			mediator := CoastMediator newAtPort: self portAspect value.			mediator notNil 				ifTrue: 				[	mediator remotePassword: self passwordAspect value.					self hostAspect value = 'localhost' 						ifTrue: [ self rescanVolumes ]				]		].</body><body package="COASTDevelopment">volumeInfoList	| collection tsDict |	collection := SortedCollection new.	self withAdminFrameDo: [: adminFrame | tsDict := adminFrame volumeInfo ].	tsDict keysAndValuesDo: [: key : value | collection add: key coastIniPrintString , ': ' , value ].	^ collection asList</body></methods><methods><class-id>COAST.CoastMediatorRemoteControl</class-id> <category>actions volume</category><body package="COASTDevelopment">backupVolume	| host selectedVolume statusResponse stream |	host := self hostAndPort.	selectedVolume := self selectedVolume.	( host ~= '' and: [ selectedVolume notNil ]) 		ifFalse: [ ^ self ].	statusResponse := self 			showWaitWhile: [ CoastMediatorStub backupVolume: selectedVolume atHost: host remotePassword: self remotePassword ]			onError: [: ex | CoastStatusResponse failureCode: CoastStatusResponse codeUnhandledError message: ex description ].	statusResponse code = CoastStatusResponse codeBackupStarted 		ifTrue: 		[	stream := String new writeStream.			stream nextPutAll: statusResponse message; cr.			stream nextPutAll: 'Wait until Finished?'.			( Dialog confirm: stream contents asText for: self mainWindow ) 				ifTrue: 				[	statusResponse := self 							showWaitWhile: [ CoastMediatorStub blockUntilBackupIsDoneVolume: selectedVolume atHost: host ]							onError: [: ex | CoastStatusResponse failureCode: CoastStatusResponse codeUnhandledError message: ex description ].					Dialog warn: statusResponse message for: self mainWindow				]		]		ifFalse: [ Dialog warn: statusResponse message for: self mainWindow ].</body><body package="COASTDevelopment">compressVolume	| host volume statusResponse |	host := self hostAndPort.	volume := self selectedVolume.	( host ~= '' and: [ volume notNil ]) 		ifFalse: [ ^ self ].	statusResponse := self 			showWaitWhile: [ COAST.CoastMediatorStub compressVolume: volume atHost: host remotePassword: self remotePassword ]			onError: [: ex | CoastStatusResponse failureCode: CoastStatusResponse codeUnhandledError message: ex description ].	self rescanVolumes.	Dialog warn: statusResponse message for: self mainWindow.</body><body package="COASTDevelopment">copyVolume	| host volume targetVolume statusResponse |	host := self hostAndPort.	volume := self selectedVolume.	( host ~= '' and: [ volume notNil ]) 		ifFalse: [ ^ self ].	targetVolume := Dialog request: 'Target volume' initialAnswer: volume onCancel: [ nil ].	( targetVolume isNil or: [ targetVolume isEmpty ]) 		ifTrue: [ ^ self ].	statusResponse := self 			showWaitWhile: [ CoastClientVolumeManager copyVolume: volume to: targetVolume atHost: host remotePassword: self remotePassword ]			onError: [: ex | CoastStatusResponse failureCode: CoastStatusResponse codeUnhandledError message: ex return ].	self rescanVolumes.	Dialog warn: statusResponse message for: self mainWindow.</body><body package="COASTDevelopment">deleteBackup	| host recoverableVolumes backupVolume choices version statusResponse |	host := self hostAndPort.	recoverableVolumes := host = '' 			ifTrue: [ Dictionary new ]			ifFalse: 			[	self 					showWaitWhile: [ CoastClientVolumeManager recoverableVolumesAtHost: host ]					onError: [: ex | ^ Dialog warn: 'Server can not be reached!' for: self mainWindow ]			].	recoverableVolumes keys isEmpty 		ifTrue: [ ^ Dialog warn: 'No backups available!' for: self mainWindow ].	choices := recoverableVolumes keys coastSortedBy: [: e | e ].	backupVolume := Dialog choose: 'Select backup to delete' fromList: choices values: choices lines: 5 cancel: [ ^ self ].	choices := ( recoverableVolumes at: backupVolume ) coastSortedBy: [: e | e ].	version := Dialog 			choose: 'Select version to delete'			fromList: ( choices collect: [: possibleVersion | CatCSVolumeManager descriptionForBackupVersion: possibleVersion  ])			values: choices			lines: 5			cancel: [ ^ self ].	statusResponse := CoastClientVolumeManager deleteBackup: backupVolume version: version atHost: host remotePassword: self remotePassword.	Dialog warn: statusResponse message for: self mainWindow.</body><body package="COASTDevelopment">deleteVolume	| host volume statusResponse |	host := self hostAndPort.	volume := self selectedVolume.	( host ~= '' and: [ volume notNil and: [ Dialog confirm: 'OK to delete ' , volume , ' on ' , host , '?' ]]) 		ifFalse: [ ^ self ].	statusResponse := self 			showWaitWhile: [ CoastClientVolumeManager deleteVolume: volume atHost: host remotePassword: self remotePassword ]			onError: [: ex | CoastStatusResponse failureCode: CoastStatusResponse codeUnhandledError message: ex description ].	self rescanVolumes.	Dialog warn: statusResponse message for: self mainWindow.</body><body package="COASTDevelopment">downloadVolume	| host volume localVolume |	self checkCoastVersionForTransfer 		ifFalse: [ ^ Dialog warn: 'Download not supported' for: self mainWindow ].	host := self hostAndPort.	volume := self selectedVolume.	localVolume := self requestNewVolumeName: volume.	( host ~= '' and: [ volume notNil and: [ localVolume ~= '' ]]) 		ifFalse: [ ^ self ].	self 		showWaitWhile: 		[	CoastClientVolumeManager downloadVolume: volume fromHost: host toLocalVolume: localVolume remotePassword: self remotePassword		]		onError: [: ex | Dialog warn: ex description for: self mainWindow ].</body><body package="COASTDevelopment">replaceVolume	| host vm vols localVolume |	self checkCoastVersionForTransfer 		ifFalse: [ ^ Dialog warn: 'Replace not supported' for: self mainWindow ].	self selectedVolume isNil 		ifTrue: [ ^ self ].	host := self hostAndPort.	vm := CoastClientVolumeManager new.	vols := ( vm volumesAtHost: nil ) asSortedCollection.	localVolume := Dialog choose: 'Select local Volume' fromList: vols values: vols lines: 10 cancel: [ nil ].	localVolume isNil 		ifTrue: [ ^ self ].	( Dialog confirm: 'OK to replace remote volume "' , self selectedVolume , '" with local volume "' , localVolume , '"?' ) 		ifFalse: [ ^ self ].	self 		showWaitWhile: 		[ | statusResponse |			statusResponse := CoastMediatorStub replaceVolume: self selectedVolume atHost: host with: localVolume remotePassword: self remotePassword.			Dialog warn: statusResponse message for: self mainWindow		]		onError: [: ex | Dialog warn: ex description for: self mainWindow ].	self rescanVolumes.</body><body package="COASTDevelopment">restoreBackup	| host recoverableVolumes backupVolume choices version volumename statusResponse |	host := self hostAndPort.	recoverableVolumes := host = '' 			ifTrue: [ Dictionary new ]			ifFalse: 			[	self 					showWaitWhile: [ CoastClientVolumeManager recoverableVolumesAtHost: host ]					onError: [: ex | ^ Dialog warn: 'server can not be reached!' for: self mainWindow ]			].	recoverableVolumes keys isEmpty 		ifTrue: [ ^ Dialog warn: 'no backups available' for: self mainWindow ].	choices := recoverableVolumes keys coastSortedBy: [: e | e ].	backupVolume := Dialog choose: 'select backup volume' fromList: choices values: choices lines: 5 cancel: [ ^ self ].	choices := ( recoverableVolumes at: backupVolume ) coastSortedBy: [: e | e ].	version := Dialog 			choose: 'select backup volume'			fromList: ( choices collect: [: possibleVersion | CatCSVolumeManager descriptionForBackupVersion: possibleVersion  ])			values: choices			lines: 5			cancel: [ ^ self ].	volumename := Dialog 			request: 'recover to volume:'			initialAnswer: (( self isListedVolume: backupVolume ) 					ifTrue: [ '' ]					ifFalse: [ backupVolume ]).	volumename isEmpty 		ifTrue: [ ^ self ].	statusResponse := CoastMediatorStub 			recoverToVolume: volumename			fromVolume: backupVolume			version: version			atHost: host			remotePassword: self remotePassword.	Dialog warn: statusResponse message for: self mainWindow.	self rescanVolumes.</body><body package="COASTDevelopment">uploadVolume	| host hostVolume vm vols localVolume |	self checkCoastVersionForTransfer 		ifFalse: [ ^ Dialog warn: 'Upload not supported' for: self mainWindow ].	host := self hostAndPort.	vm := CoastClientVolumeManager new.	vols := ( vm volumesAtHost: nil ) asSortedCollection.	localVolume := Dialog choose: 'Select local volume' fromList: vols values: vols lines: 10 cancel: [ nil ].	localVolume isNil 		ifTrue: [ ^ self ].	hostVolume := self requestNewVolumeName: localVolume.	(( host ~= '' and: [ hostVolume notNil ]) and: [( self isListedVolume: hostVolume ) not ]) 		ifFalse: [ ^ self ].	self 		showWaitWhile: [ CoastClientVolumeManager uploadVolume: localVolume toHost: host toHostVolume: hostVolume remotePassword: self remotePassword ]		onError: [: ex | Dialog warn: ex description for: self mainWindow ].	self rescanVolumes.</body></methods><methods><class-id>COAST.CoastMediatorRemoteControl</class-id> <category>actions GC</category><body package="COASTDevelopment">infoGC	| selectedVolume statusResponse |	selectedVolume := self selectedVolume.	selectedVolume isNil 		ifTrue: [ ^ self noVolumeSelected ].	statusResponse := CoastMediatorStub statusGCAtHost: self hostAndPort volume: selectedVolume remotePassword: self remotePassword.	Dialog warn: statusResponse message for: self mainWindow.</body><body package="COASTDevelopment">pauseGC	| selectedVolume |	selectedVolume := self selectedVolume.	selectedVolume isNil ifTrue: [ ^ self noVolumeSelected ].	CoastMediatorStub pauseGCAtHost: self hostAndPort volume: selectedVolume remotePassword: self remotePassword</body><body package="COASTDevelopment">startGC	| selectedVolume |	selectedVolume := self selectedVolume.	selectedVolume isNil ifTrue: [ ^ self noVolumeSelected ].	CoastMediatorStub startGCAtHost: self hostAndPort volume: selectedVolume remotePassword: self remotePassword</body><body package="COASTDevelopment">stopGC	| selectedVolume |	selectedVolume := self selectedVolume.	selectedVolume isNil ifTrue: [ ^ self noVolumeSelected ].	CoastMediatorStub stopGCAtHost: self hostAndPort volume: selectedVolume remotePassword: self remotePassword</body></methods><methods><class-id>Tools.CoastIconLibrary</class-id> <category>configuration</category><body package="COASTDevelopment">availableIconSizes	"Answer an array of strings with icon sizes currently available in the library."	^#('')</body><body package="COASTDevelopment">defaultIconSize	"Must be listed in #availableIconSizes."	^''</body></methods><methods><class-id>Tools.CoastIconLibrary</class-id> <category>private</category><body package="COASTDevelopment">monoFigureImageSelectorFor: aSymbol	"no *bw methods!"	^self shapeImageSelectorFor: aSymbol</body><body package="COASTDevelopment">shapeImageSelectorFor: aSymbol	^(aSymbol, iconSize, 'Mask') asSymbol</body></methods><methods><class-id>Tools.CoastIconLibrary class</class-id> <category>resources</category><body package="COASTDevelopment">eagerVirtualSlotIconMask	^ self virtualSlotIconMask</body><body package="COASTDevelopment">invalidEagerVirtualSlotIconMask	^self virtualSlotIconMask</body><body package="COASTDevelopment">invalidVirtualSlotIconMask	^self virtualSlotIconMask</body><body package="COASTDevelopment">undefinedSlotIconMask	^ self slotIconMask</body></methods><methods><class-id>COAST.CatCSStatisticGC</class-id> <category>initialize</category><body package="COASTDevelopment">initialize	| stream |	super initialize.	self resetStatistics.	stream := String new writeStream.	stream policy dateAndTimePolicy print: Timestamp now on: stream using: #( #dd $. #mm $. #yyyy '-' #hh #mm #ss ).	stream nextPutAll: ' cgc.csv'.	writeStream := stream contents asFilename writeStream.	writeStream nextPutAll: 'seconds'.	writeStream nextPut: $;.	writeStream nextPutAll: 'liveFramesTodoSize'.	writeStream nextPut: $;.	writeStream nextPutAll: 'fullLiveClustersSize'.	writeStream nextPut: $;.	writeStream nextPutAll: 'avg. FramesPerCluster'.	writeStream nextPut: $;.	writeStream nextPutAll: 'fav. Classes'.	writeStream cr.</body><body package="COASTDevelopment">resetStatistics	framesPerCluster := 0.	frameClasses := Bag new.	clusterCount := 0.</body></methods><methods><class-id>COAST.CatCSStatisticGC</class-id> <category>accessing</category><body package="COASTDevelopment">addReferencedFramesFrom: aFrame 	frameClasses add: aFrame frameClassSymbol.	^ super addReferencedFramesFrom: aFrame</body><body package="COASTDevelopment">clusterCountForStatistic	^ 10000</body><body package="COASTDevelopment">collectGarbage	^ [ super collectGarbage ] ensure: [ writeStream close ]</body><body package="COASTDevelopment">finishedClusterController: clusterController 	clusterCount := clusterCount + 1.	framesPerCluster := framesPerCluster + clusterController cluster numberOfFrames.	^ super finishedClusterController: clusterController</body></methods><methods><class-id>COAST.CatCSStatisticGC</class-id> <category>status</category><body package="COASTDevelopment">statusStringTo: stream 	super statusStringTo: stream.	liveFramesTodo isEmpty ifTrue: [ ^ self ].	Time secondClock - statistic startTime printOn: writeStream.	writeStream nextPut: $;.	liveFramesTodo size printOn: writeStream.	writeStream nextPut: $;.	fullLiveClusters size printOn: writeStream.	clusterCount &gt; self clusterCountForStatistic ifTrue: 		[ | total average |			writeStream nextPut: $;.			framesPerCluster // clusterCount printOn: writeStream.			writeStream nextPut: $;.			total := 0.			frameClasses valuesAndCountsDo: [: symbol : count | total := total + count ].			average := total / frameClasses numberOfKeys.			frameClasses valuesAndCountsDo: 				[: symbol : count |					average &lt; count ifTrue: 						[	writeStream nextPutAll: symbol.							writeStream nextPutAll: ' ('.							count * 1000 // total * 0.1 printOn: writeStream.							writeStream nextPutAll: '%) '						]				].			self resetStatistics		].	writeStream cr.	writeStream flush.</body></methods><methods><class-id>COAST.CatCSStatisticGC</class-id> <category>private</category><body package="COASTDevelopment">logPrefix	^ 'CSGC'</body></methods><methods><class-id>COAST.CatCSStatisticGC class</class-id> <category>setting</category><body package="COASTDevelopment">disableStatistics	DefaultGCClass := CatCSGarbageCollector.</body><body package="COASTDevelopment">enableStatistics 	DefaultGCClass := self</body></methods><methods><class-id>COAST.CatRMInternalClientPacketStation</class-id> <category>state acessing</category><body package="COASTDevelopment">closeConnection	connected ifFalse: [ ^nil ].	Object errorSignal		handle: [ :ex | ex return ]		do:		[			receiveProcess terminate.			sendProcess terminate.		].	connected := false.	mediatorPacketStation closeConnection.</body></methods><methods><class-id>COAST.CatRMInternalClientPacketStation</class-id> <category>private: send/receive</category><body package="COASTDevelopment">deliverMarshalledMessage: aByteArray	| readStream messageClass marshall newMessage messageClassName |	readStream := ReadStream with: aByteArray.	readStream reset.	messageClassName := readStream nextCoastString.	messageClass := self messageClassFor: messageClassName.	marshall := CatMAMarshallBinary new.	newMessage := messageClass new.	newMessage receiverPacketStation: self.	newMessage unmarshallMessageFrom: readStream marshaller: marshall withVolumeManager: volumeManager.	self deliverReceivedMessage: newMessage</body><body package="COASTDevelopment">receiveBlock	^ []</body><body package="COASTDevelopment">send: aCatRMMessage	" a transmitted message consists of the classname and the marshalled message "	connected ifFalse: [ ^false ].	mediatorPacketStation deliverReceivedMessage: aCatRMMessage.	^connected</body></methods><methods><class-id>COAST.CatRMInternalClientPacketStation</class-id> <category>accessing</category><body package="COASTDevelopment">mediatorPacketStation: aCatRMInternalMediatorPacketStation	mediatorPacketStation := aCatRMInternalMediatorPacketStation</body><body package="COASTDevelopment">ownID: anInteger	ownID := anInteger</body></methods><methods><class-id>COAST.CatRMInternalClientPacketStation class</class-id> <category>instance creation</category><body package="COASTDevelopment">connectedToInternalServerAt: port 	^ ( self new )		connectPort: port;		initializeForInternalConnection;		yourself</body></methods><methods><class-id>COAST.RecentVolume</class-id> <category>accessing</category><body package="COASTDevelopment">host	^ host</body><body package="COASTDevelopment">host: aHost 	host := aHost.</body><body package="COASTDevelopment">timestamp	^ timestamp</body><body package="COASTDevelopment">timestamp: aTimestamp 	timestamp := aTimestamp.</body><body package="COASTDevelopment">updateTimestamp	self timestamp: self class currentTimestamp</body><body package="COASTDevelopment">volume	^ volume</body><body package="COASTDevelopment">volume: aVolume 	volume := aVolume.</body><body package="COASTDevelopment">writeOn: aStream 	aStream nextPutAll: (self host ifNil: ['']).	aStream nextPut: $;; nextPutAll: self volume.	aStream nextPut: $;.	self timestamp printOn: aStream.</body></methods><methods><class-id>COAST.RecentVolume</class-id> <category>comparing</category><body package="COASTDevelopment">= anotherRecentVolume	^ self class = anotherRecentVolume class		and: [ self host = anotherRecentVolume host		and: [ self volume = anotherRecentVolume volume ]]</body><body package="COASTDevelopment">hash	^ self volume hash bitXor: self host hash</body></methods><methods><class-id>COAST.RecentVolume</class-id> <category>printing</category><body package="COASTDevelopment">printOn: aStream	aStream nextPutAll: self host.	aStream nextPutAll: ' @ '.	aStream nextPutAll: self volume.</body></methods><methods><class-id>COAST.RecentVolume class</class-id> <category>instance creation</category><body package="COASTDevelopment">fromString: aString 	| entries |	entries := aString tokensBasedOn: $;.	^ entries size = 3 		ifTrue: [ self host: ( entries at: 1 ) volume: ( entries at: 2 ) timestamp: ( entries at: 3 ) asInteger ]		ifFalse: [ nil ]</body><body package="COASTDevelopment">host: aHost volume: aVolume 	^ self host: aHost volume: aVolume timestamp: self currentTimestamp</body><body package="COASTDevelopment">host: aHost volume: aVolume timestamp: aTimestampAsSeconds	^ ( self new )		host: aHost;		volume: aVolume;		timestamp: aTimestampAsSeconds;		yourself</body></methods><methods><class-id>COAST.RecentVolume class</class-id> <category>accessing</category><body package="COASTDevelopment">currentTimestamp	^ Timestamp now asSeconds</body></methods><methods><class-id>COAST.CatRMClientPacketStationWithLatency</class-id> <category>private: send/receive</category><body package="COASTDevelopment">receiveCommandOrMessage	(Delay forMilliseconds: self class latency) wait. 	^ super receiveCommandOrMessage</body><body package="COASTDevelopment">send: aCatRMMessage	(Delay forMilliseconds: self class latency) wait. 	^ super send: aCatRMMessage</body></methods><methods><class-id>COAST.CatRMClientPacketStationWithLatency</class-id> <category>private: initialize</category><body package="COASTDevelopment">initialize	super initialize.	CoastLog logWarning: 'Using ', self class name.</body></methods><methods><class-id>COAST.CatRMClientPacketStationWithLatency class</class-id> <category>accessing</category><body package="COASTDevelopment">latency	"in milliseconds"	^ latency ifNil: [ latency := 20 ]</body><body package="COASTDevelopment">latency: milliseconds	"in milliseconds"	latency := milliseconds.</body></methods><methods><class-id>COAST.CoastDeveloperNotifierLocal</class-id> <category>actions</category><body package="COASTDevelopment">inspectIt	self closeRequest.	self sharedApplicationModel inspect.</body></methods><methods><class-id>COAST.IterationCounter class</class-id> <category>accessing</category><body package="COASTDevelopment">decCounterFor: aCatCSCollection	| value |	value := CollectionDict at: aCatCSCollection ifAbsent: [ nil ].	value ~~ nil		ifTrue: [			value = 1				ifTrue: [ CollectionDict removeKey: aCatCSCollection  ]				ifFalse: [ CollectionDict at: aCatCSCollection put: value - 1 ]		].</body><body package="COASTDevelopment">incCounterFor: aCatCSCollection	| value |	value := ( self iterationCountFor: aCatCSCollection ) + 1.	CollectionDict at: aCatCSCollection put: value</body><body package="COASTDevelopment">iterationCountFor: aCatCSCollection	CollectionDict == nil ifTrue: [ CollectionDict := IdentityDictionary new ].	^CollectionDict at: aCatCSCollection ifAbsent: [ 0 ]</body></methods><methods><class-id>COAST.CoastDeveloperNotifierShared</class-id> <category>views</category><body package="COASTDevelopment">localApplicationModelClass	^ CoastDeveloperNotifierLocal</body></methods><methods><class-id>COAST.CoastDeveloperNotifierShared class</class-id> <category>slots</category><body package="COASTDevelopment">testIndexSlot	^ self slotOfType: #indexProxy</body></methods><methods><class-id>COAST.CoastTrippyFrameInspector</class-id> <category>testing</category><body package="COASTDevelopment">canDeplete	| slot |	^self slotSelected		and: [slot := self frame basicSlotNamed: self slotNames selection.			slot isVirtual not ]</body><body package="COASTDevelopment">canDive	^self canInspect and: [self slotNames selectionIndex ~= 1]</body><body package="COASTDevelopment">canInspect	^self slotNames selectionIndex isZero not</body><body package="COASTDevelopment">canInvalidate	| slot |	^self slotSelected		and: [slot := self frame basicSlotNamed: self slotNames selection.			slot isVirtual ]</body><body package="COASTDevelopment">canRemove	| slot |	^self slotSelected		and: [self canInspect		and: [slot := self frame basicSlotNamed: self slotNames selection.			slot isVirtual not 		and: [slot isSingleValueSlot not]]]</body><body package="COASTDevelopment">canToggle	| slot |	^ self slotSelected and: 		[	slot := self frame basicSlotNamed: self slotNames selection.			slot basicValueHolder value isBoolean		]</body><body package="COASTDevelopment">isViewSelected	^ (self frame isKindOf: ViewState) and: [ self slotNames selectionIndex = 2 ]</body><body package="COASTDevelopment">slotSelected	| slotName |	slotName := self slotNames selection.	^slotName notNil and: [(self frame basicSlotNamed: slotName) notNil]</body><body package="COASTDevelopment">valueIsValid: value	^(value isCell		and: [value isUnresolved]) not</body></methods><methods><class-id>COAST.CoastTrippyFrameInspector</class-id> <category>aspects</category><body package="COASTDevelopment">displayRange	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^displayRange isNil		ifTrue:			[displayRange := #values asValue]		ifFalse:			[displayRange]</body><body package="COASTDevelopment">inputField	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^inputField isNil		ifTrue:			[inputField := 'self transactionDo: [  ]' asValue]		ifFalse:			[inputField]</body><body package="COASTDevelopment">slotNames	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^slotNames isNil		ifTrue:			[slotNames := SelectionInList new]		ifFalse:			[slotNames]</body><body package="COASTDevelopment">slotValues	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^slotValues isNil		ifTrue:			[slotValues := SelectionInList new]		ifFalse:			[slotValues]</body></methods><methods><class-id>COAST.CoastTrippyFrameInspector</class-id> <category>initialize-release</category><body package="COASTDevelopment">initializeSlotValuesView: aSequenceView	aSequenceView lineGrid: ('jAn' asComposedText  height).	aSequenceView visualBlock:		[:v :i | | value |			value := v sequence at: i.			BoundedWrapper on: (Label with: value printString)].	aSequenceView selectedVisualBlock:		[:v :i | | rw  value |			value := v sequence at: i.			rw := ReversingWrapper on: (Label with: value printString).			rw reverse setValue: true.			BoundedWrapper on: rw].</body><body package="COASTDevelopment">initializeSlotView: aSequenceView 	aSequenceView lineGrid: 'jAn' asComposedText height.	aSequenceView		visualBlock: 			[:v :i | | value slot selector icon |			value := v sequence at: i.			selector := i = 1				ifTrue: [ #selfIcon]				ifFalse: 					[slot := self frame basicSlotNamed: value.					slot isNil						ifTrue: [ #undefinedSlotIcon]						ifFalse: [ slot coastInspectorIcon]				].			icon := CoastIconLibrary visualFor: selector.			BoundedWrapper on: ((LabelAndIcon with: value displayString) icon: icon)		].	aSequenceView		selectedVisualBlock: 			[:v :i | | value slot rw selector icon |			value := v sequence at: i.			value := v sequence at: i.			selector := i = 1				ifTrue: [ #selfIcon]				ifFalse: 					[slot := self frame basicSlotNamed: value.					slot isNil						ifTrue: [ #undefinedSlotIcon]						ifFalse: [ slot coastInspectorIcon]				].			icon := CoastIconLibrary visualFor: selector.			rw := ReversingWrapper on: ((LabelAndIcon with: value displayString) icon: icon).			rw reverse setValue: true.			BoundedWrapper on: rw]</body><body package="COASTDevelopment">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self initializeSlotValuesView: (aBuilder componentAt: #slotValuesID) widget.	self initializeSlotView: (aBuilder componentAt: #slotNamesID) widget.</body></methods><methods><class-id>COAST.CoastTrippyFrameInspector</class-id> <category>private</category><body package="COASTDevelopment">fieldValue	^ self canInspect 		ifTrue: [ self slotValues selection ]		ifFalse: [ self frame ]</body><body package="COASTDevelopment">frame	^ object</body><body package="COASTDevelopment">installedWith: aBuilder</body><body package="COASTDevelopment">resetFields	" do nothing by default "</body><body package="COASTDevelopment">specName	"Answer the name of the interface spec to use; some pages select the	interface at runtime based on the properties of the object they inspect."	^#upperspec</body><body package="COASTDevelopment">view	^ self frame view</body></methods><methods><class-id>COAST.CoastTrippyFrameInspector</class-id> <category>actions</category><body package="COASTDevelopment">copySlotname	| slotName |	(slotName := self slotNames selection) isSymbol 		ifTrue: [			ParagraphEditor currentSelection: slotName printString		]</body><body package="COASTDevelopment">deplete	| slotName |	slotName := self slotNames selection.	slotName notNil		ifTrue: [	self frame transactionDo: [self frame depleteSlot: slotName].				self update]</body><body package="COASTDevelopment">diveDescription	| description |	description := displayRange value asString , ' at: #' , self slotNames selection asString.	( displayRange value = #values and: 		[ | slot |			slot := self frame basicSlotNamed: self slotNames selection.			slot isVirtual not and: [ slot isSingleValueSlot ]		]) 		not ifTrue: [ description := description , ' elementAt:' , self slotValues selectionIndex printString ].	^ description</body><body package="COASTDevelopment">diveIntoField	| value |	self canDive ifFalse: [ ^ nil ].	self slotNames selection isSymbol ifFalse: [ ^ self diveTo: self slotValues list anyElement description: 'view of ' , self frame printString ].	self slotValues selectionIndex isZero ifTrue: [ ^ self diveToSlot: self slotNames selection ].	value := self valueForInspect.	( self valueIsValid: value ) ifFalse: [ ^ Dialog warn: 'could not resolve value!' for: self mainWindow ].	( value isCoastFrame not and: [ value isFrameOrFrameReference ]) 		ifTrue: [( Dialog confirm: 'Resolve Frame?' for: self mainWindow ) ifTrue: [ value := value realFrameFrom: self frame clusterManager ]].	self diveTo: value description: self diveDescription.</body><body package="COASTDevelopment">diveSlot	| slotName slot |	self canDive ifFalse: [^nil].	(slotName := self slotNames selection) isSymbol 		ifFalse: [ ^ self ].	slot := self frame basicSlotNamed: slotName.	self diveTo: slot description: slotName printString</body><body package="COASTDevelopment">diveToSlot: aSlot 	self container diveInto: (Tools.Trippy.KeyedElement of: self frame at: aSlot).	self update</body><body package="COASTDevelopment">inspectField	| value |	self canInspect ifFalse: [ ^ nil ].	( self slotNames selection isSymbol not and: [ self slotValues selectionIndex isZero ]) ifTrue: [ ^ self slotValues list anyElement inspect ].	self slotValues selectionIndex isZero ifTrue: [ ^ ( self frame at: self slotNames selection ) inspect ].	value := self valueForInspect.	( self valueIsValid: value ) ifFalse: [ ^ Dialog warn: 'could not resolve value!' ].	value inspect.</body><body package="COASTDevelopment">invalidateSlot	| slot slotName |	slotName := self slotNames selection.	slotName isNil 		ifTrue: [ ^ nil ].	self isViewSelected 		ifTrue: [ ^ self view invalidate ].	slot := self frame basicSlotNamed: slotName.	slot isNil 		ifTrue: [ ^ self ].	slot isVirtual 		ifTrue: [ self frame transactionDo: [ slot invalidate ]].	self update.</body><body package="COASTDevelopment">readAccessSlot	| slotName slot |	slotName := self slotNames selection.	slotName isNil 		ifTrue: [ ^ nil ].	self isViewSelected 		ifTrue: [ ^ self frame transactionManager displayDo: [ self view displayOn: self view graphicsContext ]].	slot := self frame basicSlotNamed: slotName.	self frame transactionDo: [ slot readAccess ].	self update.</body><body package="COASTDevelopment">remove	| slotName value slot |	slotName := self slotNames selection.	value := self slotValues selection.	( slotName notNil and: [ value notNil and: [( slot := self frame slotNamed: slotName ) notNil ]]) ifTrue: 		[	( slot valueHolder isKindOf: CatCSDictionary ) 				ifTrue: [ self frame transactionDo: [ self frame at: slotName removeKey: value key ]]				ifFalse: [ self frame transactionDo: [ self frame at: slotName remove: value ]].			self update		].</body><body package="COASTDevelopment">toggle	| slotName |	slotName := self slotNames selection.	slotName notNil ifTrue: 		[	self frame transactionDo: [ self frame at: slotName set: ( self frame at: slotName ) not ].			self update		].</body><body package="COASTDevelopment">update	| oldSelection aList frame |	oldSelection := self slotNames selection.	aList := List with: 'self'.	frame := self frame.	( frame isKindOf: ViewState ) ifTrue: [ aList add: '&lt;&lt;view&gt;&gt;' ].	aList addAll: (( frame basicSlots ifNil: [ Array new ]) collect: [: slot | slot name ]) asSortedCollection.	self slotNames list: aList.	self slotValues list: List new.	self slotNames selection: oldSelection.	self updateSlot.	self updateLabel.</body><body package="COASTDevelopment">updateSlot	| slot |	slot := self slotNames selection.	slot isNil 		ifTrue: [ self slotValues list: List new ]		ifFalse: 		[	self displayRange value = #values 				ifTrue: [ self updateSlotValues: slot ]				ifFalse: 				[	self displayRange value = #observers 						ifTrue: [ self updateSlotObservers: slot ]						ifFalse: [ self updateSlotSubjects: slot ]				]		].</body><body package="COASTDevelopment">updateSlotObservers: slot 	| observers |	observers :=		[	self isViewSelected 				ifTrue: [ self view observers ]				ifFalse: 				[	self slotNames selectionIndex = 1 						ifTrue: [ self frame observers ]						ifFalse: [( self frame basicSlotNamed: slot ) observers ]				]		] on: Error do: [: ex | #( )].	self slotValues list: observers coastInspectorValueList.</body><body package="COASTDevelopment">updateSlotSubjects: slot 	| subjects |	subjects :=		[	self isViewSelected 				ifTrue: [ self view subjectsForInspector ]				ifFalse: 				[	self slotNames selectionIndex = 1 						ifTrue: [ self frame subjectsForInspector ]						ifFalse: [( self frame basicSlotNamed: slot ) subjectsForInspector ]				]		] on: Error do: [: ex | #( )].	self slotValues list: subjects coastInspectorValueList.</body><body package="COASTDevelopment">updateSlotValues: slot 	| value |	value := self isViewSelected 			ifTrue: [ self view ]			ifFalse: 			[	self slotNames selectionIndex = 1 					ifTrue: [ self frame ]					ifFalse: 					[  self frame transactionManager  volumeManager coastIsBlockedByDebugger  							ifTrue: [ [ ( self frame basicSlotNamed: slot ) resolvedCellValue ] coastValueWithinMilliseconds: 100 orDo: [ List with: '&lt;blocked by debugger&gt;' ] ]							ifFalse: [( self frame basicSlotNamed: slot ) resolvedCellValue ]					]			].	self slotValues list: value coastInspectorValueList.</body><body package="COASTDevelopment">valueForInspect	| value |	value := self slotValues selection."	value hasViewState ifTrue: [ value := value viewState ]."	value isCell ifTrue: 		[	value isSlot ifTrue: [ value := value frame ].			value notNil ifTrue: [ value resolvedValueHolder ]		].	^ value</body></methods><methods><class-id>COAST.CoastTrippyFrameInspector</class-id> <category>field list</category><body package="COASTDevelopment">basicFieldMenu	"Inspector flushMenus"	| m |	self slotSelected 		ifTrue: [m := Menu labels: 'Inspect\Dive\Dive into slot\Copy slot name\Back\Transactions' withCRs values: #(#inspectField #diveIntoField #diveSlot #copySlotname #back nil ).				(m menuItemLabeled: 'Transactions')					submenu: self transactionsMenu]		ifFalse: [m := Menu labels: 'Inspect\Dive\Back' withCRs values: #(#inspectField #diveIntoField #back )].	self container canGoBack ifFalse: [(m menuItemLabeled: 'Back') disable].	self canDive ifFalse: [(m menuItemLabeled: 'Dive') disable].	self canInspect ifFalse: [(m menuItemLabeled: 'Inspect') disable].	^m</body><body package="COASTDevelopment">transactionsMenu	| m |	m := Menu labels: 'ReadAcces\Invalidate\Remove\Deplete\Toggle' withCRs values: #( #readAccessSlot #invalidateSlot #remove #deplete #toggle ).	self canToggle ifFalse: [( m menuItemLabeled: 'Toggle' ) disable ].	self canDeplete ifFalse: [( m menuItemLabeled: 'Deplete' ) disable ].	self canRemove ifFalse: [( m menuItemLabeled: 'Remove' ) disable ].	self canInvalidate ifFalse: [( m menuItemLabeled: 'Invalidate' ) disable ].	^ m</body></methods><methods><class-id>COAST.CoastTrippyFrameInspector class</class-id> <category>aspects</category><body package="COASTDevelopment">tabLabel	^'&amp;Slots'</body></methods><methods><class-id>COAST.CoastTrippyVolumeManagerInspector</class-id> <category>menu</category><body package="COASTDevelopment">basicFieldMenu	| m |	m := Menu labels: 'Inspect\Dive\Back\Update' withCRs values: #(#inspectField #diveIntoField #back #update).	self container canGoBack		ifFalse: [(m menuItemLabeled: 'Back') disable].	self canInspect ifFalse: [		(m menuItemLabeled: 'Dive') disable.		(m menuItemLabeled: 'Inspect') disable].	^m</body></methods><methods><class-id>COAST.CoastTrippyVolumeManagerInspector</class-id> <category>accessing</category><body package="COASTDevelopment">canInspect	^self selectedCM notNil</body><body package="COASTDevelopment">inspectField	self selectedCM inspect</body><body package="COASTDevelopment">selectedCM	| v |	v := self volumes selection.	^v isNil 		ifTrue: []		ifFalse: [self object clusterManagerForVolume: v]</body></methods><methods><class-id>COAST.CoastTrippyVolumeManagerInspector</class-id> <category>actions</category><body package="COASTDevelopment">diveIntoField	| cm |	cm := self selectedCM.	cm notNil ifTrue: [self diveTo: cm description: 'volume ' , cm volume]</body></methods><methods><class-id>COAST.CoastTrippyVolumeManagerInspector</class-id> <category>aspects</category><body package="COASTDevelopment">setVolumeList	self volumes list: self object volumes asSortedCollection</body><body package="COASTDevelopment">status	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^status isNil		ifTrue:			[status := String new asValue]		ifFalse:			[status]</body><body package="COASTDevelopment">update 	self setVolumeList.	^super update.</body><body package="COASTDevelopment">volumes	volumes isNil		ifTrue:			[volumes := SelectionInList new.			self setVolumeList].	^volumes</body></methods><methods><class-id>COAST.CoastTrippyVolumeManagerInspector class</class-id> <category>accessing</category><body package="COASTDevelopment">tabLabel	^'&amp;Volumes'</body></methods><methods><class-id>COAST.CoastTrippyClusterManagerInspector</class-id> <category>menu</category><body package="COASTDevelopment">basicFieldMenu	| m |	m := Menu labels: 'Inspect\Dive\Back\Update' withCRs values: #(#inspectField #diveIntoField #back #update).	self container canGoBack		ifFalse: [(m menuItemLabeled: 'Back') disable].	self canInspect ifFalse: [		(m menuItemLabeled: 'Dive') disable.		(m menuItemLabeled: 'Inspect') disable].	^m</body></methods><methods><class-id>COAST.CoastTrippyClusterManagerInspector</class-id> <category>accessing</category><body package="COASTDevelopment">canInspect	^self selectedCluster notNil</body><body package="COASTDevelopment">clusterManager	^object</body></methods><methods><class-id>COAST.CoastTrippyClusterManagerInspector</class-id> <category>private</category><body package="COASTDevelopment">changeRequest	^true</body></methods><methods><class-id>COAST.CoastTrippyClusterManagerInspector</class-id> <category>aspects</category><body package="COASTDevelopment">approxByteSizeAspect	^ AspectAdaptor forAspect: #approxByteSize</body><body package="COASTDevelopment">clusterCount	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^clusterCount isNil		ifTrue:			[clusterCount := String new asValue]		ifFalse:			[clusterCount]</body><body package="COASTDevelopment">clusterIDAspect	^ AspectAdaptor forAspect: #clusterID</body><body package="COASTDevelopment">clusterTableAspect	clusterTableAspect isNil ifTrue: 		[	clusterTableAspect := SelectionInList new.			self update		].	^ clusterTableAspect</body><body package="COASTDevelopment">clusterTypeAspect	^ AspectAdaptor forAspect: #inspectorClusterType</body><body package="COASTDevelopment">globalSeqNumAspect	^ AspectAdaptor forAspect: #globalSeqNum</body><body package="COASTDevelopment">info	^ info isNil 		ifTrue: [ info := ( 'host: ' , ( self object host ifNil: [ 'nil' ]) , ' - volume: ' , self object volume ) asValue ]		ifFalse: [ info ]</body><body package="COASTDevelopment">update	super update.	info := nil.	self clusterTableAspect list: ( self clusterManager isNil 				ifTrue: [ List new ]				ifFalse: 				[( self clusterManager clusterController values asSortedCollection: [: cc1 : cc2 | cc1 clusterStub id &lt; cc2 clusterStub id ]) asList				]).	self updateStatus.</body><body package="COASTDevelopment">updateStatus	| stream |	stream := String new writeStream.	self clusterManager		ifNil: [ stream nextPutAll: 'no clustermanager' ]		ifNotNil: [ : cm | cm enhancedClusterInfoOn: stream. ].	self clusterCount value: stream contents.</body></methods><methods><class-id>COAST.CoastTrippyClusterManagerInspector</class-id> <category>actions</category><body package="COASTDevelopment">diveIntoField	| c |	c := self selectedCluster.	c notNil ifTrue: [self diveTo: c description: 'cluster ' , c id printString]</body><body package="COASTDevelopment">inspectField	self selectedCluster inspect</body><body package="COASTDevelopment">selectedCluster	^ clusterTableAspect selection ifNotNil: [: cc | ( self clusterManager clusterController at: cc clusterID ) clusterStub ]</body></methods><methods><class-id>COAST.CoastTrippyClusterManagerInspector class</class-id> <category>accessing</category><body package="COASTDevelopment">tabLabel	^'&amp;Cluster'</body></methods><methods><class-id>COAST.NewSlotDialog</class-id> <category>private</category><body package="COASTDevelopment">addLastRange	| range |	(range := self slotRangeAspect value) isEmpty		ifTrue: [ ^ self ].	LastRanges size &gt; 10		ifTrue: [ LastRanges remove: (LastRanges detect: [ :x | true ]) ].	LastRanges add: range.	self slotRangeChoicesAspect value: self lastRanges.</body><body package="COASTDevelopment">changedRange	| range |	(self parameter1 isNil and: [ (range := self slotRange) notNil  ])		ifTrue: [ self parameter1Aspect value: 'a', range ].	self addLastRange.</body><body package="COASTDevelopment">coastCanAccept	| n |	super coastCanAccept		ifFalse: [ ^ false ].	(self slotRange notNil and: [ self slotRangeClassNeeded isNil ])		ifTrue: [^ false ].	(n := self slotName) isEmpty		ifTrue: [ ^ false ].	(frameClass lazySlotNames includes: n)		ifTrue: [ 			Dialog warn: 'Slot ' asText, n asText allBold, ' already exists'. 			^ false ].	^ true</body><body package="COASTDevelopment">lastRanges	^ LastRanges asSortedCollection asList</body><body package="COASTDevelopment">slotRangeClass	| range binding matchingClasses |	range := self slotRangeAspect value.	range isEmpty ifTrue: [ ^ nil ].	binding := range asQualifiedReference.	^ binding		ifDefinedDo: [ : cl |				cl 		] elseDo: [			matchingClasses := Root allNameSpaces asSet collect: [ : ns |				(BindingReference simpleName: range in: ns) bindingOrNil value.			].			matchingClasses singleElementOrNil		].</body><body package="COASTDevelopment">slotRangeClassNeeded	| cl |	^ (cl := self slotRangeClass) notNil		ifTrue: [ cl ]		ifFalse: [ 			Dialog warn: 'None or more than one class found'.			nil		]</body><body package="COASTDevelopment">validateSlotRange	| matchingClasses match range newRange |	(range := self slotRange) isNil ifTrue: [ ^ self ].	matchingClasses := Root allClasses select: [:cls | (range includes: $.)					ifFalse: [range match: cls name]					ifTrue: [range match: cls fullName]].	match := matchingClasses 		singleElementIfNone: [ nil] 		ifMore: [			matchingClasses := matchingClasses sortedBy: [ : cl | cl fullName ].			Dialog 				choose: 'Choose a class:'				fromList: (matchingClasses collect: [ : cl | cl fullName ])				values: matchingClasses				lines: ((3 max: matchingClasses size) min: 8)				cancel: [ nil ].		].	newRange := match notNil		ifTrue: [ 			(BindingReference simpleName: match name asString in: frameClass environment) isDefined				ifTrue: [ match name asString ]				ifFalse: [ match fullName  ].		]		ifFalse: [ range asText emphasizeAllWith: #color -&gt; ColorValue red. ].	newRange = range		ifFalse: [ self slotRangeAspect value: newRange ].	self changedRange</body></methods><methods><class-id>COAST.NewSlotDialog</class-id> <category>actions</category><body package="COASTDevelopment">chooseInvertedSlot	| slotRangeClass names slotName |	(slotRangeClass := self slotRangeClassNeeded) isNil		ifTrue: [ ^ self ].	names := slotRangeClass lazySlotNames asSortedCollection asList.	slotName := Dialog		choose: self slotNameAspect value asText allBold, ' inverts to: '		fromList: names 		values: names 		lines: ((names size min: 3) max: 8)		cancel: [ ^ self ].	self invertedSlotNameAspect value: slotName.</body></methods><methods><class-id>COAST.NewSlotDialog</class-id> <category>accessing</category><body package="COASTDevelopment">defaultValue	| v |	^ (v := self defaultValueAspect value) isEmpty		ifTrue: [ nil ]		ifFalse: [ v ]</body><body package="COASTDevelopment">invertedSlotName	| n |	n := self invertedSlotNameAspect value.	^ n isEmpty		ifTrue: [ nil ]		ifFalse: [ n ].</body><body package="COASTDevelopment">isConstituent	^ self isConstituentAspect value</body><body package="COASTDevelopment">slotRange	| n |	n := self slotRangeAspect value.	^ n isEmpty		ifTrue: [ nil ]		ifFalse: [ n ].</body></methods><methods><class-id>COAST.NewSlotDialog</class-id> <category>aspects</category><body package="COASTDevelopment">defaultValueAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^defaultValueAspect isNil		ifTrue:			[defaultValueAspect := String new asValue]		ifFalse:			[defaultValueAspect]</body><body package="COASTDevelopment">invertedSlotNameAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^invertedSlotNameAspect isNil		ifTrue:			[invertedSlotNameAspect := String new asValue]		ifFalse:			[invertedSlotNameAspect]</body><body package="COASTDevelopment">isConstituentAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^isConstituentAspect isNil		ifTrue:			[isConstituentAspect := false asValue]		ifFalse:			[isConstituentAspect]</body><body package="COASTDevelopment">slotRangeAspect	slotRangeAspect isNil		ifTrue: [			slotRangeAspect := String new asValue.		].	^ slotRangeAspect</body><body package="COASTDevelopment">slotRangeChoicesAspect	^slotRangeChoicesAspect isNil		ifTrue:			[slotRangeChoicesAspect := self lastRanges asValue]		ifFalse:			[slotRangeChoicesAspect]</body><body package="COASTDevelopment">slotTypeChoices	^slotTypeChoices isNil		ifTrue:			[slotTypeChoices := #(singleValue set orderedCollection dictionary bag multiValueDictionary) asList asValue]		ifFalse:			[slotTypeChoices]</body></methods><methods><class-id>COAST.NewSlotDialog class</class-id> <category>instance creation</category><body package="COASTDevelopment">frameClass: aClass 	^ self new		frameClass: aClass;		yourself</body></methods><methods><class-id>COAST.CatINClusterInspector</class-id> <category>actions</category><body package="COASTDevelopment">basicInspectCluster	object basicInspect</body><body package="COASTDevelopment">update	self frames.	self updateFrameNames.	self updateLabel.</body></methods><methods><class-id>COAST.CatINClusterInspector</class-id> <category>private</category><body package="COASTDevelopment">changeRequest	^true</body></methods><methods><class-id>COAST.CatINClusterInspector</class-id> <category>aspects</category><body package="COASTDevelopment">cluster	^object</body><body package="COASTDevelopment">inspectSelectedFrame	| index |	(index := self frameNames selectionIndex) isNil ifTrue:[^self].	(frames at: index) inspect</body><body package="COASTDevelopment">sorted	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sorted isNil		ifTrue:			[sorted := false asValue]		ifFalse:			[sorted]</body></methods><methods><class-id>COAST.CatINClusterInspector</class-id> <category>accessing</category><body package="COASTDevelopment">frameNames	^frameNames isNil		ifTrue:			[frameNames := SelectionInList new]		ifFalse:			[frameNames]</body><body package="COASTDevelopment">frames	frames := self sorted value 				ifTrue: 					[self cluster resolvedCellValue 						asSortedCollection: [:a :b | a printString &lt; b printString]]				ifFalse: [self cluster resolvedCellValue asOrderedCollection].	^frames</body><body package="COASTDevelopment">updateFrameNames	self frameNames list: (frames collect: [:x | x printString])</body></methods><methods><class-id>COAST.CatINClusterInspector</class-id> <category>initialize-release</category><body package="COASTDevelopment">inspect: aCluster	super inspect: aCluster.	self update.</body></methods><methods><class-id>COAST.CatINFrameInspector</class-id> <category>field list</category><body package="COASTDevelopment">basicFieldMenu	"Inspector flushMenus"	| m |	self slotSelected 		ifTrue: [m := Menu labels: 'inspect\dive\pop\transactions\utils' withCRs values: #(#inspectField #diveIntoField #pop nil nil ).				(m menuItemLabeled: 'transactions')					submenu: self transactionsMenu]		ifFalse: [m := Menu labels: 'inspect\dive\pop\utils' withCRs values: #(#inspectField #diveIntoField #pop nil )].	(m menuItemLabeled: 'utils')		submenu: self basicUtilsMenu.	self canPop ifFalse: [(m menuItemLabeled: 'pop') disable].	self canDive ifFalse: [(m menuItemLabeled: 'dive') disable].	self canInspect ifFalse: [(m menuItemLabeled: 'inspect') disable].	^m</body><body package="COASTDevelopment">transactionsMenu	| m |	m := Menu labels: 'readAcces\invalidate\remove\deplete' withCRs values: #(#readAccessSlot #invalidateSlot #remove #deplete).	self canDeplete ifFalse: [(m menuItemLabeled: 'deplete') disable].	self canRemove ifFalse: [(m menuItemLabeled: 'remove') disable].	self canInvalidate ifFalse: [(m menuItemLabeled: 'invalidate') disable].	^m</body></methods><methods><class-id>COAST.CatINFrameInspector</class-id> <category>testing</category><body package="COASTDevelopment">canDeplete	| slot |	^self slotSelected		and: [slot := object basicSlotNamed: self slotNames selection.			slot isVirtual not ]</body><body package="COASTDevelopment">canDive	| toBeInspected |	toBeInspected := self slotValues selection.	^toBeInspected isCell or: [toBeInspected hasViewState]</body><body package="COASTDevelopment">canInspect	^self slotValues selectionIndex isZero not</body><body package="COASTDevelopment">canInvalidate	| slot |	^self slotSelected		and: [slot := object basicSlotNamed: self slotNames selection.			slot isVirtual ]</body><body package="COASTDevelopment">canPop	^self objectHistory isEmpty not</body><body package="COASTDevelopment">canRemove	| slot |	^self slotSelected		and: [self canInspect		and: [slot := object basicSlotNamed: self slotNames selection.			slot isVirtual not 		and: [slot isSingleValueSlot not]]]</body><body package="COASTDevelopment">isViewSelected	^ (object isKindOf: ViewState) and: [ self slotNames selectionIndex = 2 ]</body><body package="COASTDevelopment">slotSelected	| slotName |	slotName := self slotNames selection.	^slotName notNil and: [(object basicSlotNamed: slotName) notNil]</body></methods><methods><class-id>COAST.CatINFrameInspector</class-id> <category>private</category><body package="COASTDevelopment">changeRequest	^true</body><body package="COASTDevelopment">fieldValue	^self canInspect		ifTrue: [self slotValues selection]		ifFalse: [object]</body><body package="COASTDevelopment">resetFields	" do nothing by default "</body></methods><methods><class-id>COAST.CatINFrameInspector</class-id> <category>actions</category><body package="COASTDevelopment">deplete	| slotName |	slotName := self slotNames selection.	slotName notNil		ifTrue: [	object transactionDo: [object depleteSlot: slotName].				self update]</body><body package="COASTDevelopment">diveIntoField	| value |	self canInspect ifFalse: [^nil].	value := self slotValues selection.	value hasViewState ifTrue: [value := value viewState ].	value isCell ifFalse: [^value inspect].	value resolvedValueHolder.	value isUnresolved ifTrue: [^Dialog warn: 'could not resolve value!'].	value isSlot		ifTrue: [self diveTo: value frame andSlot: value name]		ifFalse: [self diveTo: value andSlot: nil]</body><body package="COASTDevelopment">diveTo: value andSlot: aSlot 	self objectHistory addLast: object.	self inspect: value.	self slotNames selection: aSlot.	self update</body><body package="COASTDevelopment">inspectField	| value |	self canInspect ifFalse: [^nil].	value := self slotValues selection.	value hasViewState ifTrue: [value := value viewState ].	value isCell ifFalse: [^value valueForCoastInspector inspect].	value resolvedValueHolder.	value isUnresolved ifTrue: [^Dialog warn: 'could not resolve value!'].	value isSlot		ifTrue: [ value frame inspect ]		ifFalse: [ value inspect ]</body><body package="COASTDevelopment">invalidateSlot	| slot slotName |	slotName := self slotNames selection.	slotName isNil ifTrue: [ ^ nil ].	self isViewSelected ifTrue: [ ^ object view invalidate ].	slot := object basicSlotNamed: slotName.	slot isNil ifTrue: [^self].	slot isVirtual ifTrue: [ object transactionDo: [ slot invalidate ] ].	self update.</body><body package="COASTDevelopment">pop	self canPop ifFalse:[^nil].	self inspect: self objectHistory removeLast.	self update.</body><body package="COASTDevelopment">readAccessSlot	| slotName slot |	slotName := self slotNames selection.	slotName isNil ifTrue: [ ^ nil ].	self isViewSelected ifTrue: [ ^ object transactionManager displayDo: [		object view displayOn: object view graphicsContext ] ].	slot := object basicSlotNamed: slotName.	object transactionDo: [ slot readAccess ].	self update.</body><body package="COASTDevelopment">remove	| slotName value slot |	slotName := self slotNames selection.	value := self slotValues selection.	(slotName notNil and: [value notNil and: [(slot := object slotNamed: slotName) notNil]]) 		ifTrue: [ (slot valueHolder isKindOf: CatCSDictionary)					ifTrue: [object transactionDo: [object at: slotName removeKey: value key]]					ifFalse: [object transactionDo: [object at: slotName remove: value]].				self update]</body><body package="COASTDevelopment">update	| oldSelection aList |	oldSelection := self slotNames selection.	aList := List with: #self.	(object isKindOf: ViewState) ifTrue: [		aList add: '&lt;&lt;view&gt;&gt;'	].	object basicSlots notNil ifTrue: [ object basicSlots do: [ :s | aList add: s name ]].	self slotNames list: aList.	self slotValues list: List new.	self slotNames selection: oldSelection.	self updateSlot.	self updateLabel.</body><body package="COASTDevelopment">updateSlot	| slot |	slot := self slotNames selection.	slot isNil		ifTrue: [self slotValues list: List new]		ifFalse: [self displayRange value = #values				ifTrue: [self updateSlotValues: slot]				ifFalse: [self displayRange value = #observers						ifTrue: [self updateSlotObservers: slot]						ifFalse: [self updateSlotSubjects: slot]]]</body><body package="COASTDevelopment">updateSlotObservers: slot 	| observers |	observers := self isViewSelected 			ifTrue: [ object view observers ]			ifFalse: 			[	self slotNames selectionIndex = 1 					ifTrue: [ object observers ]					ifFalse: [( object basicSlotNamed: slot ) observers ]			].	self slotValues list: observers coastInspectorValueList.</body><body package="COASTDevelopment">updateSlotSubjects: slot 	| subjects |	subjects := self isViewSelected 			ifTrue: [ object view subjectsForInspector ]			ifFalse: 			[	self slotNames selectionIndex = 1 					ifTrue: [ object subjectsForInspector ]					ifFalse: [( object basicSlotNamed: slot ) subjectsForInspector ]			].	self slotValues list: subjects coastInspectorValueList.</body><body package="COASTDevelopment">updateSlotValues: slot 	| value |	value := self isViewSelected 			ifTrue: [ object view ]			ifFalse: 			[	self slotNames selectionIndex = 1 					ifTrue: [ object ]					ifFalse: [( object basicSlotNamed: slot ) resolvedCellValue ]			].	self slotValues list: value coastInspectorValueList.</body></methods><methods><class-id>COAST.CatINFrameInspector</class-id> <category>aspects</category><body package="COASTDevelopment">displayRange	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^displayRange isNil		ifTrue:			[displayRange := #values asValue]		ifFalse:			[displayRange]</body><body package="COASTDevelopment">fieldMenuHolder	^[self basicFieldMenu]</body><body package="COASTDevelopment">inputField	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^inputField isNil		ifTrue:			[inputField := 'self transactionDo: [  ]' asValue]		ifFalse:			[inputField]</body><body package="COASTDevelopment">objectHistory	objectHistory isNil ifTrue:[objectHistory := OrderedCollection new].	^objectHistory</body><body package="COASTDevelopment">slotNames	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^slotNames isNil		ifTrue:			[slotNames := SelectionInList new]		ifFalse:			[slotNames]</body><body package="COASTDevelopment">slotValues	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^slotValues isNil		ifTrue:			[slotValues := SelectionInList new]		ifFalse:			[slotValues]</body></methods><methods><class-id>COAST.CatINFrameInspector</class-id> <category>initialize-release</category><body package="COASTDevelopment">initializeSlotValuesView: aSequenceView	aSequenceView lineGrid: ('jAn' asComposedText  height).	aSequenceView visualBlock:		[:v :i | | value |			value := v sequence at: i.			BoundedWrapper on: (Label with: value printString)].	aSequenceView selectedVisualBlock:		[:v :i | | rw  value |			value := v sequence at: i.			rw := ReversingWrapper on: (Label with: value printString).			rw reverse setValue: true.			BoundedWrapper on: rw].</body><body package="COASTDevelopment">initializeSlotView: aSequenceView 	aSequenceView lineGrid: 'jAn' asComposedText height.	aSequenceView		visualBlock: 			[:v :i | | value slot selector icon |			value := v sequence at: i.			selector := i = 1				ifTrue: [ #selfIcon]				ifFalse: 					[slot := object basicSlotNamed: value.					slot isNil						ifTrue: [ #undefinedSlotIcon]						ifFalse: [ slot coastInspectorIcon]				].			icon := CoastIconLibrary visualFor: selector.			BoundedWrapper on: ((LabelAndIcon with: value displayString) icon: icon)		].	aSequenceView		selectedVisualBlock: 			[:v :i | | value slot rw selector icon |			value := v sequence at: i.			value := v sequence at: i.			selector := i = 1				ifTrue: [ #selfIcon]				ifFalse: 					[slot := object basicSlotNamed: value.					slot isNil						ifTrue: [ #undefinedSlotIcon]						ifFalse: [ slot coastInspectorIcon]				].			icon := CoastIconLibrary visualFor: selector.			rw := ReversingWrapper on: ((LabelAndIcon with: value displayString) icon: icon).			rw reverse setValue: true.			BoundedWrapper on: rw]</body><body package="COASTDevelopment">inspect: aFrame	super inspect: aFrame valueForCoastInspector.	self update.</body><body package="COASTDevelopment">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self initializeSlotValuesView: (aBuilder componentAt: #slotValuesID) widget.	self initializeSlotView: (aBuilder componentAt: #slotNamesID) widget.</body></methods><methods><class-id>COAST.CatINFrameInspector class</class-id> <category>instance creation</category><body package="COASTDevelopment">canInspect: anObject 	^ anObject isKindOf: CatFSFrame</body><body package="COASTDevelopment">inspect: anObject	(self canInspect: anObject)		ifTrue: [ ^ super inspect: anObject ]		ifFalse: [ ^ Inspector inspect: anObject ].</body></methods><methods><class-id>COAST.CoastTrippyClusterInspector</class-id> <category>menu</category><body package="COASTDevelopment">basicFieldMenu	| m |	m := Menu labels: 'Inspect\Dive\Back\Sort\Update' withCRs values: #(#inspectField #diveIntoField #back nil #update).	(m menuItemLabeled: 'Sort')		submenu: self sortMenu.	self container canGoBack		ifFalse: [(m menuItemLabeled: 'Back') disable].	self canInspect ifFalse: [		(m menuItemLabeled: 'Dive') disable.		(m menuItemLabeled: 'Inspect') disable].	^m</body><body package="COASTDevelopment">sortMenu	^Menu labels: 'By Name\By ID' withCRs values: #(#sortByName #sortByID).</body></methods><methods><class-id>COAST.CoastTrippyClusterInspector</class-id> <category>accessing</category><body package="COASTDevelopment">canInspect	^self selectedFrame notNil</body><body package="COASTDevelopment">cluster	^object</body><body package="COASTDevelopment">frameNames	frameNames isNil ifTrue: 		[	frameNames := SelectionInList new.			self updateFrameNames		].	^ frameNames</body><body package="COASTDevelopment">frames	^ frames</body><body package="COASTDevelopment">selectedFrame	| index |	^ ( index := self frameNames selectionIndex ) isZero 		ifTrue: [ nil ]		ifFalse: [ frames at: index ]</body><body package="COASTDevelopment">updateFrameNames	frames isNil ifTrue: [ ^ self ].	self frameNames 		list: ( frames collect: [: x | ( x id printStringPaddedWith: $0 to: 9 base: 10 ) , ' ' , x class name ])</body></methods><methods><class-id>COAST.CoastTrippyClusterInspector</class-id> <category>actions</category><body package="COASTDevelopment">diveIntoField	| f |	(f := self selectedFrame) notNil ifTrue: [self diveTo: f description: 'frame ', f id printString]</body><body package="COASTDevelopment">inspectField	| f |	(f := self selectedFrame) notNil ifTrue: [f inspect]</body><body package="COASTDevelopment">sortByID	Cursor wait showWhile: [frames := frames coastSortedBy: [: a | a id ]].	self updateFrameNames</body><body package="COASTDevelopment">sortByName	Cursor wait showWhile: [frames := frames coastSortedBy: [: x | x class name, ' ', x id printString ]].	self updateFrameNames</body><body package="COASTDevelopment">update	self cluster resolvedCellValue isNil ifTrue: [ ^ self ].	frames := self cluster resolvedCellValue asOrderedCollection.	self status value: frames size printString , ' frames'.	self updateFrameNames.	^ self</body></methods><methods><class-id>COAST.CoastTrippyClusterInspector</class-id> <category>aspects</category><body package="COASTDevelopment">status	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^status isNil		ifTrue:			[status := String new asValue]		ifFalse:			[status]</body></methods><methods><class-id>COAST.CoastTrippyClusterInspector class</class-id> <category>accessing</category><body package="COASTDevelopment">tabLabel	^'&amp;Frames'</body></methods><methods><class-id>COAST.CoastTrippyFrameLookupInspector</class-id> <category>menu</category><body package="COASTDevelopment">basicFieldMenu	^ nil</body></methods><methods><class-id>COAST.CoastTrippyFrameLookupInspector</class-id> <category>notification</category><body package="COASTDevelopment">changedInput	| frame |	Cursor wait showWhile: [ frame := self object frameForString: self inputAspect value ].	frame notNil 		ifTrue: [ frame inspect ]		ifFalse: [ Dialog warn: 'Not found' ]</body></methods><methods><class-id>COAST.CoastTrippyFrameLookupInspector</class-id> <category>aspects</category><body package="COASTDevelopment">inputAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^inputAspect isNil		ifTrue:			[inputAspect := String new asValue]		ifFalse:			[inputAspect]</body></methods><methods><class-id>COAST.CoastTrippyFrameLookupInspector class</class-id> <category>accessing</category><body package="COASTDevelopment">tabLabel	^'&amp;Lookup'</body></methods><methods><class-id>COAST.CoastBFSInfoInspector</class-id> <category>aspects</category><body package="COASTDevelopment">infoTextAspect	^ infoTextAspect ifNil: [ 		infoTextAspect := String new asValue.		self update.		infoTextAspect	].</body><body package="COASTDevelopment">maxBlockAspect	^ maxBlockAspect isNil 		ifTrue: [ maxBlockAspect := self bfs numberOfBlocks asValue ]		ifFalse: [ maxBlockAspect ]</body><body package="COASTDevelopment">minBlockAspect	^ minBlockAspect isNil 		ifTrue: [ minBlockAspect := 1 asValue ]		ifFalse: [ minBlockAspect ]</body></methods><methods><class-id>COAST.CoastBFSInfoInspector</class-id> <category>menu</category><body package="COASTDevelopment">basicFieldMenu	^ nil</body></methods><methods><class-id>COAST.CoastBFSInfoInspector</class-id> <category>private</category><body package="COASTDevelopment">bfs	^ self object</body><body package="COASTDevelopment">ensureStatusOfBlockNumber: blockNumber 	| block |	( self statusAt: blockNumber ) asInteger = 0 ifTrue: 		[	( self bfs freeList isFree: blockNumber ) ifTrue: [ ^ self status: $_ at: blockNumber ].			block := self bfs getBlock: blockNumber.			block notNil ifTrue: [ self ensureStatusOfFileNumber: block fileNumber ].			( self statusAt: block blockNumber ) asInteger = 0 ifTrue: [ self status: $X at: blockNumber ]		].</body><body package="COASTDevelopment">ensureStatusOfFileNumber: fileNumber 	| block blockFile nextBlockNumber result |	blockFile := self bfs getFile: fileNumber.	blockFile isNil ifTrue: [ ^ #( )].	result := OrderedCollection with: blockFile firstBlockNumber.	block := self bfs getBlock: blockFile firstBlockNumber.	[	nextBlockNumber := block nextBlockNumber.		( self statusAt: block blockNumber ) asInteger = 0 ifTrue: 			[( nextBlockNumber = 0 or: [ nextBlockNumber = ( block blockNumber + 1 )]) 					ifTrue: [ self status: $= at: block blockNumber ]					ifFalse: [ self status: $~ at: block blockNumber ]			].		nextBlockNumber = 0	] whileFalse: 		[	result add: nextBlockNumber.			block := self bfs getBlock: nextBlockNumber		].	^ result</body><body package="COASTDevelopment">status: status at: blockNumber 	( longString notNil and: [ longString size &gt;= blockNumber ]) ifTrue: [ longString at: blockNumber put: status ].</body><body package="COASTDevelopment">statusAt: blockNumber 	^ ( longString isNil or: [ longString size &lt; blockNumber ]) 		ifTrue: [ Character value: 0 ]		ifFalse: [ longString at: blockNumber ]</body><body package="COASTDevelopment">update	| str |	Cursor wait showWhile: 		[	str := TextStream on: String new.			self bfs printInfoTextOn: str.			self infoTextAspect value: str contents		].</body></methods><methods><class-id>COAST.CoastBFSInfoInspector</class-id> <category>actions</category><body package="COASTDevelopment">checkBlocks	| min max |	min := 1 max: self minBlockAspect value.	max := self maxBlockAspect value min: self bfs numberOfBlocks.	self checkBlocksFrom: min to: max.	self infoTextAspect value: ( longString copyFrom: min to: max ).</body><body package="COASTDevelopment">checkBlocksFrom: min to: max 	Cursor wait showWhile: 		[	longString isNil 				ifTrue: [ longString := String new: max ]				ifFalse: [ longString size &lt; max ifTrue: [ longString := longString , ( String new: max - longString size )]].			min to: max do: [: blockNumber | self ensureStatusOfBlockNumber: blockNumber ]		].</body><body package="COASTDevelopment">checkFile	| string range stream fragments |	string := Dialog request: 'File number:' initialAnswer: '0' onCancel: [ ^ self ].	range := self ensureStatusOfFileNumber: string asNumber.	range isEmpty ifTrue: [ ^ Dialog warn: 'No such File!' ].	stream := String new writeStream.	stream nextPutAll: 'File '.	string asNumber printOn: stream.	stream nextPutAll: ' starting at block '.	range first printOn: stream.	stream nextPutAll: ' ending at block '.	range last printOn: stream.	stream nextPutAll: ' using '.	range size printOn: stream.	stream nextPutAll: ' blocks'.	stream cr.	fragments := 1.	range inject: nil		into: 		[: prev : c |			( prev isNil or: [ prev + 1 = c ]) 				ifTrue: [ stream nextPut: $= ]				ifFalse: 				[	fragments := fragments + 1.					( c - prev ) log ceiling timesRepeat: [ stream nextPut: $~ ].					stream nextPut: $=				].			c		].	stream cr.	fragments printOn: stream.	stream nextPutAll: ' fragments, ~ are log'.	self infoTextAspect value: stream contents.</body></methods><methods><class-id>COAST.CoastBFSInfoInspector class</class-id> <category>accessing</category><body package="COASTDevelopment">tabLabel	^'&amp;Info'</body></methods><methods><class-id>COAST.CatINClusterManagerInspector</class-id> <category>actions</category><body package="COASTDevelopment">basicInspectCM	object basicInspect</body><body package="COASTDevelopment">inspectCluster	| selectedCluster aClusterLocator |	selectedCluster := cluster selection.	aClusterLocator := self clusterManager clusterController keys detect: [:cc | cc printString = selectedCluster]				ifNone: [^nil].	^(self clusterManager clusterController at: aClusterLocator) cluster inspect</body><body package="COASTDevelopment">update	self volumes; cluster</body></methods><methods><class-id>COAST.CatINClusterManagerInspector</class-id> <category>private</category><body package="COASTDevelopment">changeRequest	^true</body><body package="COASTDevelopment">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self update.</body></methods><methods><class-id>COAST.CatINClusterManagerInspector</class-id> <category>aspects</category><body package="COASTDevelopment">cluster	| selectedVolume |	cluster isNil ifTrue: [cluster := SelectionInList new].	selectedVolume := self volumes selection.	cluster list: ((self clusterManager isNil or: [selectedVolume isNil])			ifTrue: [List new]			ifFalse: [				(((self clusterManager clusterController values 					select: [: cc | cc cluster volume = selectedVolume]) 					asSortedCollection: [:cc1 :cc2 | cc1 cluster id &lt; cc2 cluster id]) 					collect: [:cc | | s |						s := cc cluster id printString.						cc clusterManager = self clusterManager							ifFalse: [ s := s, ' !No ClusterManager!' ].						s]) asList]).	self clusterCount value: cluster list size printString.	^cluster</body><body package="COASTDevelopment">clusterCount	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^clusterCount isNil		ifTrue:			[clusterCount := String new asValue]		ifFalse:			[clusterCount]</body><body package="COASTDevelopment">volumes	| oldSelection |	volumes isNil ifTrue: [volumes := SelectionInList new].	oldSelection := volumes selection.	volumes list: (self clusterManager isNil			ifTrue: [List new]			ifFalse: [ List with: self clusterManager volume]).	volumes selection: oldSelection.	^volumes</body></methods><methods><class-id>COAST.CatINClusterManagerInspector</class-id> <category>accessing</category><body package="COASTDevelopment">clusterManager	^object</body></methods><methods><class-id>COAST.CoastTrippyMediatorFrameInspector</class-id> <category>testing</category><body package="COASTDevelopment">slotSelected	^false</body><body package="COASTDevelopment">valueIsValid: value	^true</body></methods><methods><class-id>COAST.CoastTrippyMediatorFrameInspector</class-id> <category>actions</category><body package="COASTDevelopment">update	object veryBasicSlots isNil ifFalse: [ super update ]</body></methods><methods><class-id>COAST.CoastTrippyMediatorFrameInspector</class-id> <category>accessing</category><body package="COASTDevelopment">valueForInspect	^ self slotValues selection</body></methods><methods><class-id>COAST.CoastTrippyMediatorFrameInspector class</class-id> <category>instance creation</category><body package="COASTDevelopment">canInspect: anObject	^anObject isKindOf: CatRMMediatorFrame</body></methods><methods><class-id>COAST.CoastTrippyMediatorClusterManagerInspector</class-id> <category>aspects</category><body package="COASTDevelopment">clients	| clientStates |	clientStates := Set new.	self clusterManager isNil ifTrue: [ ^ OrderedCollection new ].	self clusterManager clusterController do: [: cc | clientStates addAll: cc packetStations ].	^ ( clientStates collect: [: clientState | clientState ipAdressString ]) asSortedCollection</body><body package="COASTDevelopment">info	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^info isNil		ifTrue:			[info := ('clients: ', (self clients size printString), ' - volume: ', self object volume) asValue]		ifFalse:			[info]</body><body package="COASTDevelopment">updateStatus	| numFrames |	numFrames := self clusterManager numberOfFrames.	self clusterCount value: 'cluster: ' , self clusterTableAspect list size printString , ' frames: ' , numFrames printString.</body></methods><methods><class-id>COAST.CatMediatorFrameInspector</class-id> <category>actions</category><body package="COASTDevelopment">inspectField	| value |	self canInspect ifFalse: [^nil].	value := self slotValues selection.	value isCell 		ifTrue: [value inspect]		ifFalse: [value valueForCoastInspector inspect].</body></methods><methods><class-id>COAST.CatMediatorFrameInspector</class-id> <category>testing</category><body package="COASTDevelopment">slotSelected	^false</body></methods><methods><class-id>COAST.CatMediatorFrameInspector class</class-id> <category>instance creation</category><body package="COASTDevelopment">canInspect: anObject	^anObject isKindOf: CatRMMediatorFrame</body></methods><methods><class-id>COAST.CoastTrippyViewSlotsInspector</class-id> <category>private</category><body package="COASTDevelopment">frame	^ self view viewState</body><body package="COASTDevelopment">view	^ object</body></methods><methods><class-id>COAST.CatINMediatorClusterManagerInspector</class-id> <category>aspects</category><body package="COASTDevelopment">clients	| aSet |	clients isNil ifTrue: [clients := SelectionInList new].	aSet := Set new.	self clusterManager isNil ifFalse: [aSet addAll: self clusterManager clients].	clients list: aSet asList.	^clients</body><body package="COASTDevelopment">clientsIPList	^ ( clients collect: [: aClient | aClient ipAdressString ]) asList</body><body package="COASTDevelopment">clientsOrVolumes	clientsOrCluster isNil ifTrue:[ clientsOrCluster := #volumes asValue].	^clientsOrCluster</body><body package="COASTDevelopment">clientsOrVolumesList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^clientsOrVolumesList isNil		ifTrue:			[clientsOrVolumesList := SelectionInList new]		ifFalse:			[clientsOrVolumesList]</body><body package="COASTDevelopment">cluster	cluster isNil ifTrue: [cluster := SelectionInList new].	cluster list: (self clientsOrVolumes value = #clients		ifTrue:[ self clusterFromClient ]		ifFalse:[ self clusterFromVolume ]).	self clusterCount value: cluster list size printString, ' (', (cluster list select: [: cc | cc lazyLoad ]) size printString , ' lazy)'.	^cluster</body><body package="COASTDevelopment">clusterFromClient	| peerID |	^(self clusterManager isNil or: [clientsOrVolumesList selection isNil])		ifTrue: [List new]		ifFalse: 			[peerID := (clients at: clientsOrVolumesList selectionIndex) peerID.			((self clusterManager clusterController values 				select: [:cc | cc clients keys includes: peerID]) 				asSortedCollection: [:a :b | a clusterStub volume = b clusterStub volume					ifTrue: [a clusterStub id &lt; b clusterStub id] 					ifFalse: [a clusterStub volume &lt; b clusterStub volume]])]</body><body package="COASTDevelopment">clusterFromVolume	| selectedVolume |	selectedVolume := clientsOrVolumesList selection.	^(self clusterManager isNil or: [selectedVolume isNil])		ifTrue: [List new]		ifFalse: [((self clusterManager clusterController values 			select: [:cc | cc clusterStub volume = selectedVolume]) 			asSortedCollection: [:a :b | a clusterStub id &lt; b clusterStub id]) asList]</body><body package="COASTDevelopment">toggle	self clientsOrVolumes value= #clients 		ifTrue:[self updateClients. clientsOrVolumesList list: self clientsIPList]		ifFalse:[clientsOrVolumesList list: self volumes list].	self cluster.</body><body package="COASTDevelopment">updateClients	clients := self clusterManager volumeManager clients</body></methods><methods><class-id>COAST.CatINMediatorClusterManagerInspector</class-id> <category>actions</category><body package="COASTDevelopment">update	super update.	self updateClients.	(self clientsOrVolumes value = #clients)		ifTrue: [	self clientsOrVolumesList list: self clientsIPList ]		ifFalse:[	self clientsOrVolumesList list: self volumes list ]</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClusterType	self clusterManager isNil ifTrue: [ ^ 'broken?' ].	( self cluster isNil or: [ self cluster frames isEmpty ]) ifTrue: [ ^ 'empty' ].	self cluster frames do: [: frame | frame class environment ~= COAST ifTrue: [ ^ frame class environment name ]].	^ COAST name</body></methods><methods><class-id>COAST.CompactAbstractIndex</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^Array		with: Tools.Trippy.DictionaryInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart</class-id> <category>testing</category><body package="COASTDevelopment">isCoastClassWithSlots: aNavigatorState 	| cl |	( self isClass: aNavigatorState ) 		ifFalse: [ ^ false ].	( cl := aNavigatorState selectedClass ) notNil 		ifFalse: [ ^ false ].	^ [	cl isMeta 			ifTrue: [ cl := cl soleInstance ].		cl isCoastClassWithSlots	] on: Error do: [: ex | false ]</body></methods><methods><class-id>UI.TextEditorController class</class-id> <category>class initialization</category><body package="COASTDevelopment">addTransactionDoIt	| newItem label |	label := self transactionDoItLabel.	( CodeYellowButtonMenu menuItems anySatisfy: [: item | item label = label ]) 		ifFalse: 		[	newItem := MenuItem labeled: 'Transaction do it'.			newItem value: [: paragraphEditor | paragraphEditor transactionDoIt ].			CodeYellowButtonMenu addItem: newItem atPosition: 21		].	^ CodeYellowButtonMenu</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClass	^CatMediatorFrameInspector</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>inspecting</category><body package="COASTDevelopment">inspect	| tti |	tti := #{Tools.Trippy.Inspector} valueOrDo: [nil].	(tti isNil or: [tti useSimpleInspector])		ifTrue: [CatINMediatorClusterManagerInspector openOn: self]		ifFalse: [super inspect]</body></methods><methods><class-id>Core.Object class</class-id> <category>testing</category><body package="COASTDevelopment">isCoastClassWithSlots	^ false</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>testing</category><body package="COASTDevelopment">coastInspectorValueList	^ List with: self</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing</category><body package="COASTDevelopment">numberOfSlotsMatching: matchBlock	| i |	self basicValueHolder isNil ifTrue: [ ^ 0 ].	i := 0.	self basicValueHolder do: [ : slot | 		(matchBlock value: slot) ifTrue: [ i := i + 1 ].	].	^ i</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>user interface</category><body package="COASTDevelopment">inspectorClasses	^ super inspectorClasses copyWith: CoastTrippyViewSlotsInspector</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>printing</category><body package="COASTDevelopment">printBytesNumber: bytes exp: exp on: aStream	| num |	num := ((bytes* 100 /  (1024 raisedTo: exp)) rounded / 100) asFloat.	aStream nextPutAll: (Locale current printAsNumber: num).</body></methods><methods><class-id>COAST.CatRMMediatorCC</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClusterType	self clusterManager isNil ifTrue: [ ^ 'broken?' ].	self lazyLoad ifTrue: [ ^ 'lazy' ].	( self cluster isNil or: [ self cluster frames isEmpty ]) ifTrue: [ ^ 'empty' ].	^ ( self cluster frames contains: [: frame | frame class == CatRMMediatorFrame ]) 		ifTrue: [ 'frames' ]		ifFalse: [ 'index' ]</body></methods><methods><class-id>COAST.CompactAbstractDictionary</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^Array		with: Tools.Trippy.DictionaryInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>COAST.CatBSBlockFileVolumeAccessor class</class-id> <category>accessing</category><body package="COASTDevelopment">autoSettingsDirectory53: aString	(aString notNil and: [ aString notEmpty ])		ifTrue: [ self defaultBaseDirectory: aString asFilename ]</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>observer - subject</category><body package="COASTDevelopment">subjectsForInspector	^ self subjects</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>private</category><body package="COASTDevelopment">shouldCheckForCoastInstances: aBoolean	" self shouldCheckForCoastInstances: true. "	" self shouldCheckForCoastInstances: false"	 ShouldCheckForCoastInstances := aBoolean</body></methods><methods><class-id>COAST.CoastApplicationConfiguration class</class-id> <category>accessing</category><body package="COASTDevelopment">resetCommandLine	CommandLineOverride := nil.</body></methods><methods><class-id>Core.LookupKey</class-id> <category>accessing</category><body package="COASTDevelopment">valueForCoastInspector	(self key isCell and: [self value isCell not])		ifTrue: [^self key].	(self key isCell not and: [self value isCell])		ifTrue: [^self value].	^self</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart</class-id> <category>private</category><body package="COASTDevelopment">buildCoastFrameSubcanvas	| subcanvases |	type := #class.	subcanvases := self components.	(subcanvases size = 2 and: 			[subcanvases first class = SelectorProtocolNavigatorPart 				and: [subcanvases last class = COAST.SlotSelectorNavigatorPart]]) 		ifFalse: [self installSubcanvas: #coastSlotsWindowSpec using: self]</body></methods><methods><class-id>COAST.CoastArbitraryComponentSpec class</class-id> <category>initialize-release</category><body package="COASTDevelopment">initialize	self coastInstallOnPalette</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>printing</category><body package="COASTDevelopment">printOn: stream 	super printOn: stream.	stream space.	self clusterID printOn: stream</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>accessing</category><body package="COASTDevelopment">maxObservers	^  (self transactionContextAt: #maxObservers) ifNil: [ 0 ]</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^Array		with: CoastTrippyMediatorFrameInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>resources</category><body package="COASTDevelopment">coastLauncherIcon	^OpaqueImage figure: self coastLauncherImage shape: self coastLauncherMask</body></methods><methods><class-id>UI.TextEditorController class</class-id> <category>class initialization</category><body package="COASTDevelopment">removeTransactionDoIt	| label |	label := self transactionDoItLabel.	CodeYellowButtonMenu menuItems copy do: 		[: item |			item label = label 				ifTrue: [ CodeYellowButtonMenu removeItem: item ]		].</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>accessing</category><body package="COASTDevelopment">numberOfSlotsMatching: matchBlock	^self clusterController inject: 0 into: [ : sum : cc | sum + (cc clusterStub numberOfSlotsMatching: matchBlock) ]</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>accessing</category><body package="COASTDevelopment">browserIcon	^CoastIconLibrary visualFor: #selfIcon</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>testing</category><body package="COASTDevelopment">hasViewState	^true</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>accessing</category><body package="COASTDevelopment">developFileName	^ fileName</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>testing</category><body package="COASTDevelopment">noDuplicatesTest	"self noDuplicatesTest"	| toTest dict |	#( #'caching client services' #'mediator services' #'client authenticaten reply' #'ini labels' ) do: 		[: protocol |			toTest := self class organization listAtCategoryNamed: protocol.			toTest isEmpty ifTrue: [ self halt: protocol , ' is empty!' ].			( dict := toTest groupedBy: [: sel | self perform: sel ]) size = toTest size ifFalse: [ dict haltOrContinue ]		].	#( #'agenda flags' ) do: 		[: protocol |			toTest := self class organization listAtCategoryNamed: protocol.			toTest isEmpty ifTrue: [ self halt: protocol , ' is empty!' ].			toTest inject: 0				into: 				[: all : sel | | pattern |					pattern := self perform: sel.					( all bitAnd: pattern ) = 0 ifFalse: [ self halt: sel ].					all bitOr: pattern				]		].</body></methods><methods><class-id>Tools.IconLibrary class</class-id> <category>utility</category><body package="COASTDevelopment">allIcons	"IconLibrary allIcons"	| icons |	icons := Dictionary new.	self allSubclasses do: [ : iconLib | iconLib icons keysAndValuesDo: [ :key :image | icons at: key put: image ] ].	^icons</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^Array		with: CoastTrippyVolumeManagerInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>COAST.CatFSVirtualSlot class</class-id> <category>accessing</category><body package="COASTDevelopment">browserIcon	^CoastIconLibrary visualFor: #slotIcon</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^super inspectorClasses		copyWith: CoastTrippyFrameInspector</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart class</class-id> <category>accessing</category><body package="COASTDevelopment">slotsTabName	^ 'Slots'</body></methods><methods><class-id>COAST.CoastMediator class</class-id> <category>accessing</category><body package="COASTDevelopment">activeMediatorAtPort: port 	^ self allInstances 		detect: [: mediator | mediator isActive and: [ mediator serverPort = port ]]		ifNone: [ nil ]</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^Array		with: CoastTrippyMediatorClusterManagerInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>accessing</category><body package="COASTDevelopment">unresolvedFrames	^ unresolvedFrames</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>accessing</category><body package="COASTDevelopment">displayString	^self cluster id printString asText</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^ super inspectorClasses , 		(Array with: CoastBFSInfoInspector)</body></methods><methods><class-id>COAST.CatRMMediatorFrame</class-id> <category>slots</category><body package="COASTDevelopment">veryBasicSlots	^slots</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>enhanced - New Widgets</category><body package="COASTDevelopment">coastInstallOnPalette	| specsList ref |	ref := self fullyQualifiedReference.	specsList := (Smalltalk at: #UIPalette ifAbsent: [^self]) activeSpecsList.	(specsList includes: ref) ifFalse: [specsList add: ref].</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu messages</category><body package="COASTDevelopment">transactionDoIt	self maybeSelectCurrentLine.	self hasRangeSelection ifTrue: 		[				[ | code result |				code := self compileTransactionSelection.				result := Cursor execute showWhile: [ self evaluateCompiled: code ].				self doItValue: result.				SourceFileManager default logChange: self selection string.				^ result			] on: self class compilationErrorSignal do: [: ex | ex return ]		]</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>private</category><body package="COASTDevelopment">coastInspectorValueList	| list |	list := List new: self size.	self referencesElementsCursorDo: [: ref | list add: ref copyForRefCursor ].	^ list</body></methods><methods><class-id>COAST.CoastApplicationConfiguration class</class-id> <category>accessing</category><body package="COASTDevelopment">addCommandLine: commandParam 	"self addCommandLine: '-showBuildID'"	| stream |	CommandLineOverride isNil ifTrue: [ CommandLineOverride := OrderedCollection new ].	CommandLineOverride addLast: commandParam.	stream := String new writeStream.	CommandLineOverride do: [: string | stream nextPutAll: string ] separatedBy: [ stream space ].	CoastLog log: 'Developer-CmdLine: ' , stream contents.</body></methods><methods><class-id>Core.Collection</class-id> <category>private</category><body package="COASTDevelopment">isRangeForClass: aClass 	^ self contains: [: each | each isRangeForClass: aClass ]</body></methods><methods><class-id>COAST.CatCSFrameSlotIndex</class-id> <category>printing</category><body package="COASTDevelopment">printOn: aStream	aStream nextPutAll: 'fsi &lt;'.	aStream nextPutAll: self frameClassSymbol.	aStream nextPut: $&gt;</body></methods><methods><class-id>COAST.CoastLocalApplicationModel</class-id> <category>testing</category><body package="COASTDevelopment">hasViewState	^ true</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>accessing</category><body package="COASTDevelopment">numAddedObservers	^  (self transactionContextAt: #numAddedObservers) ifNil: [ 0 ]</body></methods><methods><class-id>COAST.CompactSet</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^Array		with: Tools.Trippy.SetInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>COAST.CatRMMediatorClusterManager</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorExtraAttributes	^Array with: (Tools.Trippy.TextAttribute 		label: 'clients' 		textBlock: [| clientsString |			clientsString := ''.			self clientIPs 				do: [:cip | clientsString := clientsString , cip]				separatedBy: [clientsString := clientsString , '\'].			clientsString withCRs])</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>testing</category><body package="COASTDevelopment">isCoastClassWithSlots	^ true</body></methods><methods><class-id>COAST.AutomaticVisualPart class</class-id> <category>testing</category><body package="COASTDevelopment">isCoastClassWithSlots	^ true</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>printing</category><body package="COASTDevelopment">printBytesCount: int on: aStream 	int printOn: aStream.	int &lt; 1024		ifTrue: [			^ self		].	aStream nextPutAll: ' Bytes ('.	int &lt; (1024 raisedTo: 2)		ifTrue: [			self printBytesNumber: int exp: 1 on: aStream.			^ aStream nextPutAll: ' KB)'.		].	int &lt; (1024 raisedTo: 3)		ifTrue: [			self printBytesNumber: int exp: 2 on: aStream.			^ aStream nextPutAll: ' MB)'.		].	self printBytesNumber: int exp: 3 on: aStream.	^ aStream nextPutAll: ' GB)'.</body></methods><methods><class-id>COAST.CatRMMediatorVolumeManager</class-id> <category>packet stations</category><body package="COASTDevelopment">newInternalClientConnection: aCatRMInternalClientPacketStation		| newPacketStation idForNewPeer |		self exclusiveUseDo:	[		idForNewPeer := self calculateNewID.		newPacketStation := CatRMInternalMediatorPacketStation				newWithPacketStation: aCatRMInternalClientPacketStation				forPeerID: idForNewPeer.		(newPacketStation isNil)		ifTrue:		[			self statusError: 'packet station is unable to connect to new client'.		]		ifFalse:		[			packetStations at: idForNewPeer put: newPacketStation.			newPacketStation volumeManager: self.			newPacketStation activate.			self statusLog: 'Client [', idForNewPeer printString, '] registered internal'.		].	].</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COASTDevelopment">valueForCoastInspector	^self</body></methods><methods><class-id>Tools.IconLibrary class</class-id> <category>utility</category><body package="COASTDevelopment">icons	"IconLibrary icons"	| icons |	icons := Dictionary new.	self class selectors do: [ :sel | ('*Icon' match: sel asString) ifTrue: [ icons at: sel put: (self visualFor: sel) ]].	^icons</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>printing</category><body package="COASTDevelopment">enhancedClusterInfoOn: stream 	| lazyRatio numFrames |	numFrames := self numberOfFrames.	lazyRatio := numFrames &gt; 0 			ifTrue:	[ self numberOfLazyFrames / numFrames ]			ifFalse:	[ 0 ].	stream nextPutAll: 'cluster: '.	self numberOfClustersLoaded printOn: stream.	stream nextPutAll: ' frames: '.	numFrames  printOn: stream.	stream nextPutAll: ' lazy: '.	((lazyRatio * 10000) rounded / 100) asFloat printOn: stream.	stream nextPut: $%.</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>inspecting</category><body package="COASTDevelopment">inspectorClasses	^Array		with: Tools.Trippy.BasicInspector		with: CoastTrippyClusterInspector</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="COASTDevelopment">coastInspectorValueList	^ List withAll: self associations</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="COASTDevelopment">coastInspectorValueList	^ List withAll: self</body></methods><methods><class-id>COAST.CatCSAbstractClientClusterManager</class-id> <category>printing</category><body package="COASTDevelopment">enhancedClusterInfoOn: stream 	super enhancedClusterInfoOn: stream.	stream nextPutAll: ' unresolved: '.	self unresolvedFrames exactNumberOfFrames printOn: stream.</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing</category><body package="COASTDevelopment">nextFrom: todo 	| best |	best := nil.	todo do: 		[: f |			f isUnresolved ifFalse: [ ^ f ].			( best isNil or: [ f clusterID &lt; best clusterID ]) ifTrue: [ best := f ]		].	^ best</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>demon description</category><body package="COASTDevelopment">hasRangeDemonFor: aSuperclass 	self allDemonsDo: [: demon | ( demon name = #range and: [ demon argument isRangeForClass: aSuperclass ]) ifTrue: [ ^ true ]].	^ false</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>accessing</category><body package="COASTDevelopment">coastInspectorIcon	^ #default</body></methods><methods><class-id>COAST.CoastApplicationClient class</class-id> <category>instance creation</category><body package="COASTDevelopment">startUpWithCommandLine: cmdLineArray 	^ CoastApplicationConfiguration overrideCommandLine: cmdLineArray while: [ self startUp ]</body></methods><methods><class-id>COAST.CoastWeakSet</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^Array		with: Tools.Trippy.SetInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>menu messages</category><body package="COASTDevelopment">compileTransactionSelection	"Compile the current text selection as an expression and answer	the resulting method. Signal CompilationError if compilation fails."	| compiler readStream |	compiler := self doItReceiver class evaluatorClass new.	readStream := ReadStream 			on: 'self transactionManager transactionDo: [' 					, ( self text copyFrom: self selectionStartIndex to: self selectionStopIndex - 1 ) , ' ]'.	^ compiler 		compile: readStream		in: self doItContext		allowReceiver: self doItReceiverAllowed		class: self doItReceiver class		environment: self doItEnvironment		noPattern: true		notifying: self		ifFail: [ self class compilationErrorSignal raise ]		handler: ( self doItHandlerFor: compiler )</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>private</category><body package="COASTDevelopment">touchAllOldClusters	self clusterController do: [ : cc | cc cluster unmarshaller loadCoastVersion = CoastVersion defaultCoastVersion ifFalse: [ cc modified: true ]].</body></methods><methods><class-id>COAST.CatCSCellValueHolder class</class-id> <category>accessing</category><body package="COASTDevelopment">browserIcon	^CoastIconLibrary visualFor: #slotIcon</body></methods><methods><class-id>COAST.CatFSSlot class</class-id> <category>accessing</category><body package="COASTDevelopment">browserIcon	^CoastIconLibrary visualFor: #slotIcon</body></methods><methods><class-id>COAST.AbstractMultiValueDictionary</class-id> <category>accessing</category><body package="COASTDevelopment">coastInspectorValueList	| list |	list := List new.	self associationsDo: [: a | list add: a ].	^ list</body></methods><methods><class-id>COAST.CompactRPCResultCollection</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^ Array with: Tools.Trippy.SequenceInspector with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Core.List</class-id> <category>accessing</category><body package="COASTDevelopment">coastComputedValueBeImmutableIfNeeded</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>accessing</category><body package="COASTDevelopment">navigatorClass	^ CoastSlotAwareBrowserNavigator</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>inspectiong</category><body package="COASTDevelopment">inspect	| tti |	tti := #{Tools.Trippy.Inspector} valueOrDo: [nil].	(tti isNil or: [tti useSimpleInspector])		ifTrue: [CatINClusterInspector openOn: self]		ifFalse: [super inspect]</body></methods><methods><class-id>COAST.CoastExitCode class</class-id> <category>util</category><body package="COASTDevelopment">explain: errorCode	" COAST.CoastExitCode explain: CoastExitCode scheduledShutdown "	| stream |	stream := String new writeStream.	( Pragma allNamed: #errorCodeName:description: in: self class ) do: 		[: pragma |			errorCode = ( self perform: pragma selector ) ifTrue: 				[	stream notEmpty ifTrue: 						[	stream								cr;								tab; nextPutAll: 'OR'; cr						].					stream nextPutAll: ( pragma argumentAt: 1 ); nextPutAll: ': '; nextPutAll: ( pragma argumentAt: 2 )				]		].	^ stream notEmpty 		ifTrue: [ stream contents ]		ifFalse: [ 'vm error code: see exError.h of the used VisualWorks version' ]</body></methods><methods><class-id>COAST.CatRMMediatorSlot</class-id> <category>accessing</category><body package="COASTDevelopment">icon	^ #slotIcon</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="COASTDevelopment">coastComputedValueBeImmutableIfNeeded	self beImmutable</body></methods><methods><class-id>Core.Integer</class-id> <category>printing</category><body package="COASTDevelopment">printStringPaddedWith: pad to: to base: base 	| aStream |	aStream := String new writeStream.	self negative ifTrue: [ aStream nextPut: $- ].	self abs printOn: aStream paddedWith: pad to: to base: base.	^ aStream contents</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>accessing</category><body package="COASTDevelopment">observers	^ Array new</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>accessing</category><body package="COASTDevelopment">iterationCount	"self iterationCount ~~ 0 &lt;==&gt; i am currently iterated!"	^IterationCounter iterationCountFor: self</body></methods><methods><class-id>Core.Interval</class-id> <category>testing</category><body package="COASTDevelopment">coastInspectorValueList	^ List with: self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COASTDevelopment">hasViewState	^false</body></methods><methods><class-id>COAST.CatRMLazyMediatorCC</class-id> <category>accessing</category><body package="COASTDevelopment">displayString	^self lazyLoad 		ifTrue: [self clusterStub id printString asText emphasizeAllWith: #italic]		ifFalse: [super displayString ]</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>private</category><body package="COASTDevelopment">touchAllClusters	self clusterController do: [ : cc |  cc modified: true ].</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>accessing</category><body package="COASTDevelopment">coastInspectorIcon	^ self isEager 		ifTrue: 		[	self isValid 				ifTrue: [ #eagerVirtualSlotIcon ]				ifFalse: [ #invalidEagerVirtualSlotIcon ]		]		ifFalse: 		[	self isValid 				ifTrue: [ #virtualSlotIcon ]				ifFalse: [ #invalidVirtualSlotIcon ]		]</body></methods><methods><class-id>COAST.CoastSequenceViewSpec class</class-id> <category>initialize-release</category><body package="COASTDevelopment">initialize	self coastInstallOnPalette</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>private</category><body package="COASTDevelopment">openedCoastInstances	| opened |	opened := Set new.	COAST.CoastMediator allGeneralInstancesDo: [: mediator | opened add: mediator ].	COAST.CatCSAbstractClientClusterManager allGeneralInstancesDo: [: clientClusterManager | opened add: clientClusterManager ].	^  opened</body></methods><methods><class-id>COAST.AbstractMultiValueDictionary</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^Array		with: Tools.Trippy.DictionaryInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>user interface</category><body package="COASTDevelopment">inspectorClasses	^Array		with: CoastTrippyFrameInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>COAST.CoastLocalApplicationModel class</class-id> <category>testing</category><body package="COASTDevelopment">isCoastClassWithSlots	^ true</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>observer - subject</category><body package="COASTDevelopment">subjectsForInspector	^List new</body></methods><methods><class-id>COAST.CatRMMediatorSlot class</class-id> <category>accessing</category><body package="COASTDevelopment">browserIcon	^CoastIconLibrary visualFor: #slotIcon</body></methods><methods><class-id>COAST.CatCSEndCell</class-id> <category>accessing</category><body package="COASTDevelopment">coastInspectorIcon	^ #slotIcon</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorClasses	^Array		with: CoastTrippyClusterManagerInspector		with: CoastTrippyFrameLookupInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>COAST.AutomaticVisualPart</class-id> <category>observer - subject</category><body package="COASTDevelopment">subjectsForInspector	^ subjects</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>accessing</category><body package="COASTDevelopment">checkBeforeAccess: aWriteAccess 	"when modifying the collection, try to prevent the most famous bug		&lt;&lt;modifying while iterating the same collection&gt;&gt;"	"self iterationCount ~~ 0 &lt;==&gt; i am currently iterated!"	self iterationCount == 0 ifFalse: 		[	COAST.CoastTransactionManager allInstances 				do: [: transactionManager | transactionManager localInterestObservers do: [: interestObserver | interestObserver prepareForDebugging ]].			self halt: 'access while iterating collection'		].	super checkBeforeAccess: aWriteAccess</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COASTDevelopment">coastInspectorValueList	^ List with: self</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>tests</category><body package="COASTDevelopment">printShortNameOn: stream 	self name keysAndValuesDo: [: i : c | i &gt; 5 ifTrue: [ stream nextPut: c ]].</body></methods><methods><class-id>Core.Object class</class-id> <category>private</category><body package="COASTDevelopment">isRangeForClass: aClass 	^ self isKindOf: aClass class</body></methods><methods><class-id>UI.TextEditorController class</class-id> <category>class initialization</category><body package="COASTDevelopment">transactionDoItLabel	^ 'Transaction do it'</body></methods><methods><class-id>COAST.CoastInputFieldSpec class</class-id> <category>initialize-release</category><body package="COASTDevelopment">initialize	self coastInstallOnPalette</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart</class-id> <category>accessing</category><body package="COASTDevelopment">coastSlotSelectors	| selectors |	selectors := self componentNamed: #selectors.	selectors isNil 		ifTrue: 			[selectors := COAST.SlotSelectorNavigatorPart new.			navigator notNil ifTrue: [selectors navigator: navigator].			self componentNamed: #selectors put: selectors].	^selectors</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing</category><body package="COASTDevelopment">inspectorExtraAttributes	^ OrderedCollection 		with: ( Tools.Trippy.DerivedAttribute label: 'transactionManager' value: self transactionManager )		with: ( Tools.Trippy.DerivedAttribute label: 'clusterManager' value: self clusterManager )		with: ( Tools.Trippy.DerivedAttribute label: 'volumeManager' value: self volumeManager )		with: ( Tools.Trippy.DerivedAttribute label: 'idForExport' value: self fullIDString )</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>printing</category><body package="COASTDevelopment">printInfoTextOn: aStream	| tfs tbs wasted |	aStream emphasis: #bold; nextPutAll: 'Name: '; emphasis: nil.	aStream nextPutAll: self coreName; cr.	aStream emphasis: #bold; nextPutAll: 'Directory: '; emphasis: nil.	aStream nextPutAll: self workingDirectory asString; cr.	self isOpen		ifFalse: [			aStream cr; nextPutAll: 'Block file system is closed'.			^ self.		].	aStream emphasis: #bold; nextPutAll: 'Number of files: '; emphasis: nil.	aStream nextPutAll: self numberOfFiles displayString; cr.	aStream emphasis: #bold; nextPutAll: 'Total file size: '; emphasis: nil.	self printBytesCount: (tfs := self totalFileSize) on: aStream.	aStream cr.	aStream emphasis: #bold; nextPutAll: 'Number of blocks: '; emphasis: nil.	aStream nextPutAll: self numberOfBlocks displayString; cr.	aStream emphasis: #bold; nextPutAll: 'Total block size: '; emphasis: nil.	self printBytesCount: (tbs := self totalBlockSize) on: aStream.	aStream cr.	tbs &gt; 0		ifTrue: [ 				wasted := 100 - (tfs * 100 / tbs) rounded.			aStream emphasis: #bold; nextPutAll: 'Space wasted: '; emphasis: nil.			aStream nextPutAll: wasted displayString; nextPut: $% ; cr.		].</body></methods><methods><class-id>COAST.CatRMMediatorFrame class</class-id> <category>accessing</category><body package="COASTDevelopment">browserIcon	^CoastIconLibrary visualFor: #selfIcon</body></methods><methods><class-id>COAST.CoastClientVolumeManager</class-id> <category>accessing</category><body package="COASTDevelopment">coastIsBlockedByDebugger	| proc |	^ (Notifier isDevelopment and: [ (proc := self exclusiveLockOwner) notNil and: [ proc isUnderDebug ]])</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>inspecting</category><body package="COASTDevelopment">inspect	| tti |	tti := #{Tools.Trippy.Inspector} valueOrDo: [nil].	(tti isNil or: [tti useSimpleInspector])		ifTrue: [CatINClusterManagerInspector openOn: self]		ifFalse: [super inspect]</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>accessing</category><body package="COASTDevelopment">hasRangeDemonFor: aSuperclass 	^ false</body></methods><methods><class-id>COAST.CoastSequenceViewSpec class</class-id> <category>private-interface building</category><body package="COASTDevelopment">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #avoidScrolling put: (self adapt: inst forAspect: #avoidScrolling channel: aChannel).</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>experimental collection protocol</category><body package="COASTDevelopment">iteratingDo: aBlock	"every time we iterate the collection, increase the counter while doing so"	| result |	"self iterationCount ~~ 0 &lt;==&gt; i am currently iterated!"	IterationCounter incCounterFor: self.	[ result := aBlock value ] ensure: [ IterationCounter decCounterFor: self ].	^result</body></methods><methods><class-id>COAST.CoastApplicationConfiguration class</class-id> <category>accessing</category><body package="COASTDevelopment">overrideCommandLine: cmdLineArray while: aBlock 	| oldCmdLine |	oldCmdLine := CommandLineOverride.	^ [	CommandLineOverride := cmdLineArray.		aBlock value	] ensure: [ CommandLineOverride := oldCmdLine ]</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COASTDevelopment">logInvalidStructureRepair: repair log: string do: repairBlock 	"this error can be repaired on the fly"	repair 		ifFalse: [ self error: string ].	COAST.CoastLog log: string channel: #validStructure.	self haltOrContinue: 'Proceed to repair?'.	repairBlock value.</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>tests</category><body package="COASTDevelopment">printCSVTableTo: stream 	"file out"	"	| stream  |		stream :=  'accesses.csv' asFilename writeStream.		[ self printCSVTableTo: stream ] ensure: [ stream close ]	"	| allConcrete allWriters |	self initializeAccesses.	allConcrete:= ( COAST.CatCSCellAccess allSubclasses select: [: c | c id ~= -1 ]) sortedBy: [: c | c name ].	allWriters := allConcrete select: [: class | class isWriteAccess ].	allWriters do: 		[: class |			stream nextPut: $;.			class printShortNameOn: stream		].	stream cr.	allConcrete do: 		[: class1 | | table |			class1 printShortNameOn: stream.			table := class1 commAccesses collect: 					[: e | | s |						s := Set new.						e == true ifTrue: [ s add: $X ].						s					].			class1 commDifferentAccesses keysAndValuesDo: [: i : e | e == true ifTrue: [( table at: i ) add: $D ]].			class1 commEqualAccesses keysAndValuesDo: [: i : e | e == true ifTrue: [( table at: i ) add: $E ]].			allConcrete do: 				[: class2 |					class2 id = class1 id ifFalse: 						[	"complete the table"							( class2 commAccesses at: class1 id ) == true ifTrue: [( table at: class2 id ) add: $X ].							( class2 commDifferentAccesses at: class1 id ) == true ifTrue: [( table at: class2 id ) add: $D ].							( class2 commEqualAccesses at: class1 id ) == true ifTrue: [( table at: class2 id ) add: $E ]						]				].			table := allWriters collect: [: class2 | table at: class2 id ].			table do: 				[: s |					stream nextPut: $;.					s do: [: c | stream nextPut: c ]				].			stream cr		].</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>accessing</category><body package="COASTDevelopment">numberOfSlotsMatching: matchBlock	^self frames inject: 0 into: [:sum :f | 		sum + (f numberOfSlotsMatching: matchBlock)	]</body></methods><initialize><class-id>COAST.CoastArbitraryComponentSpec</class-id></initialize><initialize><class-id>COAST.CoastInputFieldSpec</class-id></initialize><initialize><class-id>COAST.CoastSequenceViewSpec</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CatCSCell</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container valueHolder observers </inst-vars><class-inst-vars>prototype </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>CatCSCluster</name><environment>COAST</environment><super>COAST.CatCSContainerCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterController modificationNumber unmarshaller approxByteSize clusterStream mayHaveNonWeakObserver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatCSEndCell</name><environment>COAST</environment><super>COAST.CatCSCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definition </inst-vars><class-inst-vars>typeDictionary </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>CatFSVirtualSlot</name><environment>COAST</environment><super>COAST.CatCSEndCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars>valid subjects subjectObserverPairs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatFSSlot</name><environment>COAST</environment><super>COAST.CatCSEndCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>IconLibrary</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>icons iconSize lastColorDepth </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Resources</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>CatCSGarbageCollector</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManager fullLiveClusters liveFramesTodo garbageFramesLeft synchronizer statistic maintenance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTGarbageCollection</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CompactCollection</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>addedFrames removedFrames clusterManager frameIDs clusterIDs classIndices frameClassArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSCollection</name><environment>COAST</environment><super>COAST.CatCSCellValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CoastLog</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logLevel channelLogLevels notifiers name prefixes prefixBlocks haltOnExceptions multiTranscript exceptionLogSize channels filterChannels fileName minTime maxLogSize logExceptionBlock timestampFormat logQueue logProcess </inst-vars><class-inst-vars>singleton logs </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COUtilities</package></attributes></class><class><name>CompactAbstractIndex</name><environment>COAST</environment><super>COAST.CompactCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>Inspector</name><environment>Tools.Trippy</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object container </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LookupKey</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>CompactSet</name><environment>COAST</environment><super>COAST.CompactSimpleCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>AbstractMultiValueDictionary</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COBase</package></attributes></class><class><name>CatCSVolumeManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManagers volumeInterface exclusiveLock currentLoadedClusterID packetStations autoSaveTimeInterval maxModifiedClusters segmentSplitSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSClusterManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterController autoSaveInterval volume volumeManager volumeID storageInterface autosaveTime lastSaveTime frameClassIndex nextClusterID tempBytesPool classNameManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CompactRPCResultCollection</name><environment>COAST</environment><super>COAST.CompactSimpleCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSFrameSlotIndex</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClassIndex key slotArray slotDict frameClass frameClassSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CompactAbstractDictionary</name><environment>COAST</environment><super>COAST.CompactSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>CoastWeakSet</name><environment>COAST</environment><super>Core.WeakArray</super><private>false</private><indexed-type>weak</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports>			Set.*			</imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>List</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents collection limit collectionSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>CatCSClusterController</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cluster clusterID modified changeCount clusterManager lastSaveTime byteArrayFilename oldStyleFrameDetected </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSClusterInfo</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loadTime accessTime accessCount loadFromMediatorCount loadFromCacheCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>NameSpaceItemTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type showProtocols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>CatRMMediatorVolumeManager</name><environment>COAST</environment><super>COAST.CatCSVolumeManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestQueue requestProcess nextClientID persistentClients clusterReleaseDelay compactFreedMemoryThreshold quickCompactFreedMemoryThreshold </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>SelectorNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolItemNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>CatRMMediatorCC</name><environment>COAST</environment><super>COAST.CatCSClusterController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clients globalSeqNum totalChangeCount wasUsedInGC lastRead </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMMediatorFrame</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClassSymbol slots frameID cluster byteArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatBFBlockFileSystem</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bfsFileHandle isLocked lockInfoString seekPosition accessLock numberOfBlocks blockSize patchMode lastModification version modificationNumber processID headerBuffer availableBuffers buffers openWriteStreams openReadStreams workingDirectory coreName directory freeList nextClusterID uniqueVolumeID lockFile backupCopyInfo backgroundCopyInfos growSizeInBytes backgroundOperationProcessPriority readOnly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatRMMediatorSlot</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id container valueHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>Inspector</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object field fieldList properties history showAllFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>CatRMMediatorClusterManager</name><environment>COAST</environment><super>COAST.CatCSClusterManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>garbageCollector clusterMemoryFreedCounter testAndSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatRMMediatorPacketStation</name><environment>COAST</environment><super>COAST.CatRMPacketStation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>peerID lastReceiveTime clientActivityWatchdog connectionStartTime persistentClientID reconnectProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>CatCSTransaction</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context rolledBack composedCells composedCellsLock inDisplayPhase outstandingCompositions combinedAgenda endDemons postDemons failureBlocks inInvalidationPhase ownerProcess transactionManager isFastRead oldValuesDict commitBlocks endBlocks applicationLog delegationContexts invalidationSuppressed delayedCompositions postViewUpdateBlocks failureReason </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMLazyMediatorCC</name><environment>COAST</environment><super>COAST.CatRMMediatorCC</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lazy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTMediator</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>CatFSFrame</name><environment>COAST</environment><super>COAST.CatCSContainerCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>coastFrameClassSymbol coastFrameClassName </class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastClientVolumeManager</name><environment>COAST</environment><super>COAST.CatCSVolumeManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultHost connectionLostBlock responseQueue transactionManager requestTimeout interruptProtect persistentClientID defaultUnloadStrategy useProxyValueHolder reconnectAttempts </inst-vars><class-inst-vars>defaultServerPort </class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastApplicationClientWithUI</name><environment>COAST</environment><super>COAST.CoastApplicationClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>TextEditorController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown keyboardHook readOnly accepted autoAccept continuousAccept tabMeansNextField tabRequiresControl dispatcher selectable maxChars nextUndoBlock currentUndo </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>CatCSAbstractClientClusterManager</name><environment>COAST</environment><super>COAST.CatCSClusterManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unloadStrategy unresolvedFrames clustersWithStreams volumeContext unloadProcessHandler reusableClusters blockCaches statistics </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CatRMClientPacketStation</name><environment>COAST</environment><super>COAST.CatRMPacketStation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ownID host connectPort reconnectSemaphore lastSendTime keepAliveProcess inReconnectPhase </inst-vars><class-inst-vars>connectTimeout </class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>AutomaticVisualPart</name><environment>COAST</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>viewState subjects valid isOpen </inst-vars><class-inst-vars>viewStatePrototype </class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastLocalApplicationModel</name><environment>COAST</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sharedApplicationModel viewState localUser coastDialog closedLocally </inst-vars><class-inst-vars>viewStatePrototype </class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>BrowserEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>CoastNotifierShared</name><environment>COAST</environment><super>COAST.CoastApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTClient</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>CoastNotifierLocal</name><environment>COAST</environment><super>COAST.CoastLocalApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>TextCollector</name><environment>UI</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entryStream characterLimit writeSequencer nextEntry autoFlush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class></st-source>