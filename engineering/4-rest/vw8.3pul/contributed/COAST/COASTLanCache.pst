<?xml version="1.0"?><st-source><!-- Name: COASTLanCacheDevelopmentPrerequisites: #(#(#any 'COASTClient' '') #(#any 'COASTMediator' '') #(#any 'WinService' ''))PackageName: COASTLanCacheParcel: #($e "16r0065")PrerequisiteDescriptions: #(#(#name 'COASTClient' #componentType #package) #(#name 'COASTMediator' #componentType #package) #(#name 'WinService' #componentType #package))PrerequisiteParcels: #(#('COASTClient' '') #('COASTMediator' '') #('WinService' ''))Version: 5.3.10Date: 11:34:16 AM November 16, 2013 --><time-stamp>From VisualWorksÂ®, 7.10 of 10. Juli 2013 on 16. November 2013 at 11:34:16</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CoastLanCachingCC</name><environment>COAST</environment><super>COAST.CatRMClientCC</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CoastLanCache</category><attributes><package>COASTLanCache</package></attributes></class><class><name>CoastLanCacheClusterManager</name><environment>COAST</environment><super>COAST.CoastClientClusterManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CoastLanCache</category><attributes><package>COASTLanCache</package></attributes></class><class><name>CoastLanCacheClientVolumeManager</name><environment>COAST</environment><super>COAST.CoastClientVolumeManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CoastLanCache</category><attributes><package>COASTLanCache</package></attributes></class><class><name>CoastLanCache</name><environment>COAST</environment><super>COAST.CoastApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>coastApplicationClient serviceSocket serviceProcess cachePort </inst-vars><class-inst-vars>singleton </class-inst-vars><imports></imports><category>CoastLanCache</category><attributes><package>COASTLanCache</package></attributes></class><methods><class-id>COAST.CoastLanCache</class-id> <category>headless</category><body package="COASTLanCache">parsePort: stream	&lt;	commandlineParameter: #port		canPerform: nil		aliases: nil		usage: 'port {port number}'		help: 'listen on tcp/ip {port number}'		&gt;	| port |	port := stream next ifNotNil: [ : s | s asInteger ] ifNil: [ self errorInCommandLine: 'Cache port not specified' ].	self cachePort: port.</body><body package="COASTLanCache">parseStop: stream	&lt;	commandlineParameter: #stop		canPerform: nil		aliases: nil		usage: 'stop'		help: 'stop a lan cache running on the same host'		&gt;	self startAction: [ 		self shutDownRemoteCache. 		Notifier isDevelopment ifFalse: [ ObjectMemory quit. ].		].</body></methods><methods><class-id>COAST.CoastLanCachingCC</class-id> <category>cluster</category><body package="COASTLanCache">cluster	self clusterStub valueHolder isNil ifTrue: 		[| marshaller |		marshaller := self clusterManager loadSaveMarshaller copy.		marshaller clusterController: self.		self basicCluster: ( marshaller loadCluster: self clusterStub id fromStore: self clusterManager storageAccessor )].	^self clusterStub</body></methods><methods><class-id>COAST.CoastLanCachingCC</class-id> <category>frame creation</category><body package="COASTLanCache">createFrame: aCatRMFrameCreation	| newFrame |	newFrame := CatRMMediatorFrame newWithFrameClassName: aCatRMFrameCreation frameClassName.	newFrame id: aCatRMFrameCreation frameID.	self cluster directTableAccessAt: newFrame id put: newFrame.	newFrame cluster: self cluster</body></methods><methods><class-id>COAST.CoastLanCacheClusterManager</class-id> <category>controlling</category><body package="COASTLanCache">controllerClass	^CoastLanCachingCC</body></methods><methods><class-id>COAST.CoastLanCacheClusterManager</class-id> <category>frame creation</category><body package="COASTLanCache">getFrameForLoading: aCatFSExternalFrameDefinition 	"A frame has to be loaded. Create a blank frame to continue loading."	^aCatFSExternalFrameDefinition createMediatorFrameForClusterManager: self</body><body package="COASTLanCache">resolveFrameReference: aCatFSFrameReference 	"do not resolve frame refs by default"	^ aCatFSFrameReference</body></methods><methods><class-id>COAST.CoastLanCacheClusterManager</class-id> <category>accessing</category><body package="COASTLanCache">purgeClusters	| unloadableClusters |	( self unloadStrategy notNil and: [ self unloadStrategy clusterUnloadNeeded ]) 		ifTrue: 		[	unloadableClusters := self unloadStrategy unloadableClustersWithout: #( ).			clusterController do: 				[: cc | ( cc clusterStub valueHolder notNil and: [ unloadableClusters includes: cc clusterStub id ]) 						ifTrue: 						[	self cacheAccessor writeBackClusterController: cc.							cc clusterStub valueHolder: nil						]				].			self unloadStrategy clusterUnloadFinished: unloadableClusters notEmpty		].</body><body package="COASTLanCache">storageAccessor	^self cacheAccessor storageAccessor</body><body package="COASTLanCache">volume: aString	 volume := aString.</body></methods><methods><class-id>COAST.CoastLanCacheClientVolumeManager</class-id> <category>accessing</category><body package="COASTLanCache">clusterManagerClass	^CoastLanCacheClusterManager</body><body package="COASTLanCache">newClusterManagerForVolume: aVolume host: aHost 	| cm | 	[	cm := CoastLanCacheClusterManager new.		cm host: aHost.		self initializeClusterManager: cm forVolume: aVolume	] on: Error do: [: ex |		self removeClusterManager: aVolume.		cm := nil.		ex pass	].	^ cm</body></methods><methods><class-id>COAST.CoastLanCache</class-id> <category>private</category><body package="COASTLanCache">cacheAccessorFor: clusterManager 	^LocalCacheAccessor directory: 'lancache' asFilename clusterManager: clusterManager</body><body package="COASTLanCache">clusterManagers	^self volumeManager volumes collect: [: volume |		(self volumeManager clusterManagerForVolume: volume) ]</body><body package="COASTLanCache">serviceBlock	"Thread block accepting connections from new clients."		^	[[	| newSock |			[				newSock := serviceSocket accept.				[ self handleRequestAt: newSock ] forkAt: (Processor lowIOPriority - 1).			] on: Error do: [ :ex |				CoastLog logError: 'CoastLanCache: ', ex description.				Transcript show: (self callStackStringOfSize: 40);cr.				[ newSock close ] on: Error do: [ :x | ].			].		] repeat ]</body></methods><methods><class-id>COAST.CoastLanCache</class-id> <category>accessing</category><body package="COASTLanCache">cachePort	^cachePort ifNil: [ self iniAccess numberAt: 'port' ifAbsent: [ CoastVersion defaultCachePort ]]</body><body package="COASTLanCache">cachePort: port	^cachePort := port</body><body package="COASTLanCache">statistic	| totalAccesses localCacheHits mediatorClusterLoads result clusterLoaded lazyClusters |	totalAccesses := 0.	localCacheHits := 0.	mediatorClusterLoads := 0.	clusterLoaded := 0.	lazyClusters := 0.	self clusterManagers do: [: e |		clusterLoaded := clusterLoaded + e clusterController size.		lazyClusters := lazyClusters + (e clusterController select: [: cc | cc clusterStub valueHolder isNil ]) size.		e unloadStrategy accessTable do: [: clusterInfo |			totalAccesses := clusterInfo accessCountForLanCache + totalAccesses.			localCacheHits := clusterInfo loadFromCacheCount + localCacheHits.			mediatorClusterLoads := clusterInfo loadFromMediatorCount + mediatorClusterLoads.			]].	result := Dictionary new.	result at: #totalAccesses put: totalAccesses.	result at: #localCacheHits put: localCacheHits.		result at: #mediatorClusterLoads put: mediatorClusterLoads.	result at: #clusterLoaded put: clusterLoaded.	result at: #lazyClusters put: lazyClusters.	^result</body><body package="COASTLanCache">volumeManager	^coastApplicationClient volumeManager</body></methods><methods><class-id>COAST.CoastLanCache</class-id> <category>basic actions</category><body package="COASTLanCache">clearCache	self clusterManagers do: [: clusterManager | | volume |		volume := clusterManager volume.		clusterManager releaseAllClusters; shutDown.		self volumeManager removeClusterManager: volume.]</body><body package="COASTLanCache">clusterManagerForVolume: volume host: host 	^ self volumeManager 		clusterManagerForVolume: volume		ifAbsent: 		[ | newClusterManager | 			[	newClusterManager := self volumeManager newClusterManagerForVolume: volume host: host.				newClusterManager cacheAccessor: ( self cacheAccessorFor: newClusterManager ).				newClusterManager unloadStrategy keepSize: 30.				newClusterManager unloadStrategy unloadSize: 60			] 				on: Error				do: 				[: ex |					self volumeManager removeClusterManager: volume.					ex pass				].			newClusterManager		]</body><body package="COASTLanCache">getBlob: blobLocator from: clusterManager 	| blob |	( clusterManager cacheAccessor hasBytesAtID: blobLocator id)		ifTrue: [ CoastLog logDebug: 'Access to loaded blob ' , blobLocator printString ]		ifFalse: [ CoastLog logDebug: 'Access to unloaded blob ' , blobLocator printString ].	blob := clusterManager loadFromID: blobLocator id toLocalFile: ''.	clusterManager unloadStrategy notifyExternalFileLoad: blobLocator id.	^blob</body><body package="COASTLanCache">getClusterController: clusterLocator atHost: host 	| clusterManager clusterControllerOrNil volume |	clusterControllerOrNil := nil.		[	volume := clusterLocator volume.		volume isValidVolumeString			ifTrue: [	clusterManager := self clusterManagerForVolume: volume host: host.					clusterManager host = host 						ifTrue: [ clusterControllerOrNil := self getClusterController: clusterLocator from: clusterManager  ] ]	] on: Error do: 	[: ex | 		CoastLog logException: ex message: 'error in LanCache for getCluster: ' , clusterLocator printString , ' atHost: ' , host printString.		clusterManager notNil ifTrue: [ clusterManager releaseAllClusters ].		clusterControllerOrNil := nil ].	^clusterControllerOrNil</body><body package="COASTLanCache">getClusterController: clusterLocator from: clusterManager 	| clusterController |	( clusterManager hasCluster: clusterLocator id)		ifTrue: [ CoastLog logDebug: [ 'Access to loaded cluster ' , clusterLocator printString ]]		ifFalse: [ CoastLog logDebug: [ 'Access to unloaded cluster ' , clusterLocator printString ].				clusterManager getCluster: clusterLocator id].	clusterController := clusterManager clusterController at: clusterLocator id.	clusterManager unloadStrategy notifyClusterAccess: clusterLocator id.	clusterManager purgeClusters.	^clusterController</body><body package="COASTLanCache">shutDown	self = self class singleton ifTrue: [ ^ self class shutDown ].	self clearCache.	serviceProcess terminate.	serviceSocket close.	self volumeManager connectionLostBlock: nil.	self volumeManager shutDown.	coastApplicationClient := nil.	CoastLog log: 'CoastLanCache stopped'.	#{HeadlessImage} ifDefinedDo: [ :headlessImage |		headlessImage default isHeadless ifTrue: [			ObjectMemory quit.			].		].</body><body package="COASTLanCache">sizeAndStreamFor: clusterLocator controller: clusterController	^clusterController clusterStub valueHolder isNil		ifTrue: [ self sizeAndStreamForCached: clusterLocator id controller: clusterController ]		ifFalse: [ self sizeAndStreamForLoaded: clusterLocator id controller: clusterController ]</body><body package="COASTLanCache">sizeAndStreamForCached: clusterIDInteger controller: clusterController	| size stream |	size := clusterController clusterManager storageAccessor storageSizeForCluster: clusterIDInteger.	stream := clusterController clusterManager storageAccessor readStreamOnCluster: clusterIDInteger.	^Array with: size with: stream</body><body package="COASTLanCache">sizeAndStreamForLoaded: clusterID controller: clusterController	| size stream internalStream |	internalStream := ReadWriteStream on: (ByteArray new: 1024).	clusterController cluster marshallBinaryTo: internalStream marshaller: clusterController clusterManager loadSaveMarshaller copy.	size := internalStream writePosition.	stream := internalStream contents readStream.	internalStream close.	^Array with: size with: stream</body></methods><methods><class-id>COAST.CoastLanCache</class-id> <category>services</category><body package="COASTLanCache">clearCacheRequestAt: aSocketAccessor readStream: receiveStream 	| replyStream |	replyStream := aSocketAccessor writeStream binary.	self volumeManager exclusiveUseDo: [self clearCache].	replyStream nextPut: 1.	replyStream flush.	receiveStream close.	replyStream close</body><body package="COASTLanCache">getBlobRequestAt: aSocketAccessor readStream: receiveStream 	| replyStream blobLocator blob host clusterManager |	blobLocator := CatCSClusterLocator unmarshallBinaryFrom: receiveStream marshaller: nil.	host := receiveStream nextCoastString.	replyStream := aSocketAccessor writeStream binary.	CoastLog logDebugDo: 		[	'blog request for ' , blobLocator printString , ' on host ' , host printString , ' from client ' 				, aSocketAccessor getPeer hostAddress printString		].	self volumeManager exclusiveUseDo: 		[	clusterManager := self clusterManagerForVolume: blobLocator volume host: host.			blob := self getBlob: blobLocator from: clusterManager.			blob notNil 				ifTrue: 				[	replyStream nextUnsigned32Put: 1.					replyStream nextUnsigned32Put: blob size.					replyStream nextPutAll: blob				]				ifFalse: [ replyStream nextUnsigned32Put: 0 ]		].	replyStream flush.	receiveStream close.	replyStream close.</body><body package="COASTLanCache">getClusterRequestAt: aSocketAccessor readStream: receiveStream 	| replyStream clusterLocator clusterController host |	clusterLocator := CatCSClusterLocator unmarshallBinaryFrom: receiveStream marshaller: nil.	host := receiveStream nextCoastString.	replyStream := aSocketAccessor writeStream binary.	CoastLog logDebugDo: 		[	'cluster request for ' , clusterLocator printString , ' on host ' , host printString , ' from client ' 				, aSocketAccessor getPeer hostAddress printString		].	self volumeManager exclusiveUseDo: 		[	clusterController := self getClusterController: clusterLocator atHost: host.			clusterController notNil 				ifTrue: 				[ | sizeAndStream |					sizeAndStream := self sizeAndStreamFor: clusterLocator controller: clusterController.					replyStream nextUnsigned32Put: clusterController globalSeqNum.					replyStream nextUnsigned32Put: sizeAndStream first.					replyStream nextPutAll: sizeAndStream last contents.					sizeAndStream last close				]				ifFalse: [ replyStream nextUnsigned32Put: 0 ]		].	replyStream flush.	receiveStream close.	replyStream close.</body><body package="COASTLanCache">handleRequestAt: aSocketAccessor 	"establish a stream connection for aSocketAccessor and handle incoming requests"	| receiveStream request |	receiveStream := aSocketAccessor readStream binary.	request := receiveStream next.	request = CoastConstant getCachedCluster ifTrue: [ self getClusterRequestAt: aSocketAccessor readStream: receiveStream ].	request = CoastConstant getCachedBlob ifTrue: [ self getBlobRequestAt: aSocketAccessor readStream: receiveStream ].	request = CoastConstant putBlobToCache ifTrue: [ self putBlobRequestAt: aSocketAccessor readStream: receiveStream ].	request = CoastConstant clearCache ifTrue: [ self clearCacheRequestAt: aSocketAccessor readStream: receiveStream ].	request = CoastConstant version ifTrue: [ self versionRequestAt: aSocketAccessor readStream: receiveStream ].	request = CoastConstant shutDownCache ifTrue: [ self shutDownRequestAt: aSocketAccessor readStream: receiveStream ].</body><body package="COASTLanCache">putBlobRequestAt: aSocketAccessor readStream: receiveStream 	| replyStream blobLocator blob host clusterManager blobSize |	blobLocator := CatCSClusterLocator unmarshallBinaryFrom: receiveStream marshaller: nil.	host := receiveStream nextCoastString.	blobSize := receiveStream nextUnsigned32.	blob := receiveStream next: blobSize.	CoastLog logDebugDo: 		[	'blob update for ' , blobLocator printString , ' on host ' , host printString , ' from client ' 				, aSocketAccessor getPeer hostAddress printString		].	replyStream := aSocketAccessor writeStream binary.	self volumeManager exclusiveUseDo: 		[	clusterManager := self clusterManagerForVolume: blobLocator volume host: host.			clusterManager cacheAccessor writeBytes: blob blobID: blobLocator id.			replyStream nextUnsigned32Put: 1		].	replyStream flush.	receiveStream close.	replyStream close.</body><body package="COASTLanCache">shutDownRequestAt: aSocketAccessor readStream: receiveStream 	| replyStream |	CoastLog log: 'shut down request from client ' , aSocketAccessor getPeer hostAddress printString.	replyStream := aSocketAccessor writeStream binary.	self volumeManager		exclusiveUseDo: 			["no more service"			self shutDown].	replyStream nextPut: 1.	replyStream flush.	receiveStream close.	replyStream close</body><body package="COASTLanCache">versionRequestAt: aSocketAccessor readStream: receiveStream	"this is a version request"	| replyStream |	replyStream := aSocketAccessor writeStream binary.	CoastLog logDebugDo: [ 'version request from client ' , aSocketAccessor getPeer hostAddress printString ].	CoastVersion defaultCoastVersion marshallBinaryTo: replyStream marshaller: nil.	replyStream flush.	receiveStream close.	replyStream close.	^self</body></methods><methods><class-id>COAST.CoastLanCache</class-id> <category>initialize</category><body package="COASTLanCache">initialize	self configureApplication.	self configuration createMemoryPolicy.	self startAction 		ifNotNil: [ : action | action value ]		ifNil: [ self startClientAndSocket ]</body><body package="COASTLanCache">startClient	CoastLog log: 'CoastLanCache: Starting client...'.	coastApplicationClient := CoastApplicationClient new.	coastApplicationClient volumeManager: CoastLanCacheClientVolumeManager new.	self volumeManager connectionLostBlock: [ 		[	CoastLog log: 'CoastLanCache: Lost connection to mediator'.			self clearCache.			(Delay forSeconds: 10) wait.			self startClient.		] fork	].	CoastLog log: 'CoastLanCache: Client started'.</body><body package="COASTLanCache">startClientAndSocket	self startClient.		serviceSocket := SocketAccessor defaultClass newCoastServerAtPort: self cachePort.	serviceSocket isActive		ifTrue: 			[CoastLog log: 'Running on port ' , self cachePort printString.			serviceSocket listenFor: SocketAccessor coastDefaultListenBacklog.			serviceProcess := self serviceBlock forkAt: Processor lowIOPriority].	CoastLog log: 'CoastLanCache: initialization done'.</body></methods><methods><class-id>COAST.CoastLanCache</class-id> <category>headless</category><body package="COASTLanCache">shutDownRemoteCache	| aSocketAccessor |	aSocketAccessor := nil.	[ | sendStream | 		sendStream := nil.		aSocketAccessor := 		[	SocketAccessor defaultClass newTCPclientToHost: 'localhost' port: self cachePort		] on: Error do: [ : ex | CoastLog logDebug: 'could not reach peer'. nil ].		(aSocketAccessor notNil and: [ aSocketAccessor isActive ]) ifTrue: [ 				[	sendStream := aSocketAccessor writeStream binary.					sendStream nextPut: CoastConstant shutDownCache.					sendStream flush.				] ensure: [ sendStream isNil ifFalse: [ sendStream close. ]. ].			]	] ensure: [ aSocketAccessor isNil ifFalse: [ aSocketAccessor close. ]. ].</body><body package="COASTLanCache">startUpAsService	winService := configuration createWinService.	winService startAsService: [ self startClientAndSocket ] shutdownBlock: [ self shutDown ].</body></methods><methods><class-id>COAST.CoastLanCache class</class-id> <category>accessing</category><body package="COASTLanCache">defaultIniFilename	^ 'cache.ini'</body><body package="COASTLanCache">defaultLogFilename	^ 'lancache.log'</body></methods><methods><class-id>COAST.CoastLanCache class</class-id> <category>instance creation</category><body package="COASTLanCache">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>COAST.CoastLanCache class</class-id> <category>singelton</category><body package="COASTLanCache">shutDown	self singleton notNil ifTrue: [ | inst |		inst := singleton.		singleton := nil.		inst shutDown.		].</body><body package="COASTLanCache">singleton	^ singleton</body><body package="COASTLanCache">startUp	self singleton isNil ifTrue: [		singleton := self new.		].</body></methods><methods><class-id>COAST.LocalCacheAccessor</class-id> <category>accessing</category><body package="COASTLanCache">storageAccessor	^storageAccessor</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>CoastClientVolumeManager</name><environment>COAST</environment><super>COAST.CatCSVolumeManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultHost connectionLostBlock responseQueue transactionManager requestTimeout interruptProtect persistentClientID defaultUnloadStrategy useProxyValueHolder reconnectAttempts </inst-vars><class-inst-vars>defaultServerPort </class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastClientClusterManager</name><environment>COAST</environment><super>COAST.CatCSAbstractClientClusterManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageQueue messageProcess waitingMultiParts requiredMultiParts timeManager host cacheAccessor interruptHandlers waitingSingleParts criticalLoadTimeLimit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>LocalCacheAccessor</name><environment>COAST</environment><super>COAST.CacheAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storageAccessor expireAge maxCacheSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COASTClient</package></attributes></class><class><name>CatRMClientCC</name><environment>COAST</environment><super>COAST.CatCSClusterController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>log packetStation localSeqNum localBase acceptedLocalBase acknowledgedGlobalSeqNum globalSeqNum outstandingGlobalSeqNums localRolledBack unloadStrategyInformation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastApplication</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration winService startAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class></st-source>