<?xml version="1.0"?><st-source><!-- Name: COASTGarbageCollectionNotice: The MIT LicenseCopyright (c) 2013 intelligent views GmbHPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DevelopmentPrerequisites: #(#(#bundle 'COASTCore' ''))PackageName: COASTGarbageCollectionParcel: #('COASTGarbageCollection')ParcelDirectory: COASTGarbageCollectionPrerequisiteParcels: #(#('COASTCore' ''))Version: 5.4.11Date: 11:13:05 AM July 18, 2014 --><time-stamp>From VisualWorksÂ®, 7.10.1 of 6. Februar 2014 on 18. Juli 2014 at 11:13:05</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AntiSet</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>set </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTGarbageCollection</package></attributes></class><comment><class-id>COAST.AntiSet</class-id><body>AntiSet 	to maintain subcollections of large collections, this AntiSet keeps track of all removed objects	it can be handled like a normal Set (add: remove: etc) except it can not iterateInstance Variables:	set	&lt;Collection&gt;	the removed objects</body></comment><class><name>GCSlotReference</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>slotName frameReference </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTGarbageCollection</package></attributes></class><class><name>GCHelper</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTGarbageCollection</package></attributes></class><class><name>GCSynchronizer</name><environment>COAST</environment><super>COAST.GCHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>status waitForFreeMemory hibernateSemaphore clusterManager statusSemaphores </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTGarbageCollection</package></attributes></class><comment><class-id>COAST.GCSynchronizer</class-id><body>GCSynchronizer coordinates the GC process with the running mediatorInstance Variables:	clusterManager		&lt;ClusterManager&gt;	to access the exclusive lock	hibernateSemaphore	&lt;Semaphore&gt;		the GC process will wait here when sent to sleep	waitForFreeMemory	&lt;Boolean&gt;			when no low memory is detected, the memory notices from ObjectMemory are ignored	ignoreScavenges	&lt;Boolean&gt;			while trying to reclaim ST memory, memory notices from ObjectMemory are ignored	status				&lt;Symbol&gt;			the current state of the GC process (NOT mark or reclaim but interrupted or paused)		#proceedGC	the GC process is in normal state		#interruptGC	the GC process is interrupted (e.g. cluster request)		#hibernateGC	the GC process is explicit paused, but may resume later		#stopGC		the GC process is stopped (aborted, about to terminate)		#finishedGC		the GC process is finished</body></comment><class><name>CSStatistic</name><environment>COAST</environment><super>COAST.GCHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startTime framesDoneCounter largestClusterID removedSlotsCount estimatedNumberOfClusters obsoleteClustersLeft </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTGarbageCollection</package></attributes></class><comment><class-id>COAST.CSStatistic</class-id><body>CSStatistic	groups a bunch of statistic variablesInstance Variables:	estimatedNumberOfClusters	&lt;Integer&gt;	how many clusters does the volume hold	framesDoneCounter			&lt;Integer&gt;	how many frames did we pass	largestClusterID				&lt;Integer&gt;	the largest clusterID at begin of GC ==&gt; higher clusterIDs will not be reclaimed ...	obsoleteClustersLeft			&lt;Integer&gt;	used only while removing clusters to give statusStrings for long operations	removedSlotsCount			&lt;Integer&gt;	how many nil/empty Slots have been removed from frames	startTime					&lt;Time&gt;		the start time</body></comment><class><name>GCMaintenance</name><environment>COAST</environment><super>COAST.GCHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>framesToSearch badFrames badSlots frameReferences blobRelocationMap slotToSearch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTGarbageCollection</package></attributes></class><comment><class-id>COAST.GCMaintenance</class-id><body>GCMaintenance helps th GC to relocate blobs and track down bad referencesInstance Variables:	badFrames			&lt; Set of FrameLocator &gt;				for frames referenced but not contained in a cluster	framesToSearch		&lt; Set of CatCSFrameLocator &gt;		usualy, frames previously marked as bad. might be used later to track down other frames, too	frameReferences	&lt; Dictionary of FrameLocator-&gt;Slot &gt;	if a frameToSearch is found, the referening slot is kept for loging	blobRelocationMap	&lt; Dictionary of Integer-&gt;Integer &gt;		blobs with a blobID where a cluster with the same clusterID exist must be moved (repair code for ancient coast bug)</body></comment><class><name>CatCSGarbageCollector</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManager fullLiveClusters liveFramesTodo garbageFramesLeft synchronizer statistic maintenance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTGarbageCollection</package></attributes></class><comment><class-id>COAST.CatCSGarbageCollector</class-id><body>CatCSGarbageCollector	a mark and sweap GC for volumes. all frames to keep are called "live"Instance Variables:	clusterManager		&lt;CatCSClusterManager&gt;	to access the volume	frameClassIndex	&lt;CatCSFrameClassIndex&gt;	new FrameClassIndex for not yet indexed Frameclasses and slots	fullLiveClusters		&lt;Collection&gt;				list of fully checked clusterIDs - there is no garbage in those to reclaim	garbageFramesLeft	&lt;(GCIntegerKeyDictionary of: (Integer | CatCOIntegerKeySet))&gt;														Dictionary from clusterID to a collection of frames not referenced (moved to liveFramesTodo when a reference is found)	liveFramesTodo		&lt;(GCIntegerKeyDictionary of: (Integer | CatCOIntegerKeySet))&gt;														Dictionary from clusterID to a collection of live frames to process	maintenance		&lt;GCMaintenance&gt;			keeps relocatable blobIDs and bad frames. Usable to track previous bad frames	statistic				&lt;CSStatistic&gt;				holds a bunch of statistical variables	synchronizer		&lt;CatCSGarbageCollector&gt;	used to pause, cancle and stop a GC and to acces critical blocks exclusive</body></comment><class><name>GCIntegerKeyDictionary</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>largeArray tally lowestIndex clusterManager recentCIDs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COASTGarbageCollection</package></attributes></class><shared-variable><name>DefaultGCClass</name><environment>COAST.CatCSGarbageCollector</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>CatCSGarbageCollector</initializer><attributes><package>COASTGarbageCollection</package></attributes></shared-variable><methods><class-id>COAST.AntiSet</class-id> <category>add - remove</category><body package="COASTGarbageCollection">add: elem	set remove: elem ifAbsent: [].	^elem</body><body package="COASTGarbageCollection">buildSetFrom: mainSet	^mainSet - set</body><body package="COASTGarbageCollection">includes: elem	^(set includes: elem) not</body><body package="COASTGarbageCollection">remove: elem	(set includes: elem) ifTrue: [^set notFoundError].	set add: elem.	^elem</body><body package="COASTGarbageCollection">remove: elem ifAbsent: aBlock	(set includes: elem) ifTrue: [^aBlock value].	set add: elem.	^elem</body></methods><methods><class-id>COAST.AntiSet</class-id> <category>initialize</category><body package="COASTGarbageCollection">initialize	set := Set new.</body></methods><methods><class-id>COAST.AntiSet</class-id> <category>testing</category><body package="COASTGarbageCollection">isAntiSet	^true</body><body package="COASTGarbageCollection">isEmpty	^set isEmpty not</body><body package="COASTGarbageCollection">notEmpty	^ self isEmpty not</body></methods><methods><class-id>COAST.AntiSet class</class-id> <category>í®³tance creation</category><body package="COASTGarbageCollection">new	^super new initialize</body></methods><methods><class-id>COAST.GCSlotReference</class-id> <category>accessing</category><body package="COASTGarbageCollection">frameLocator	^ frameReference frameLocator</body><body package="COASTGarbageCollection">frameReference	^ frameReference</body><body package="COASTGarbageCollection">frameReference: aFrameReference 	frameReference := aFrameReference.</body><body package="COASTGarbageCollection">slotName	^ slotName</body><body package="COASTGarbageCollection">slotName: aSlotName 	slotName := aSlotName.</body></methods><methods><class-id>COAST.GCSlotReference</class-id> <category>printing</category><body package="COASTGarbageCollection">basicPrintOn: stream 	stream nextPutAll: frameReference frameClassSymbol.	stream nextPut: $[.	frameReference clusterID printOn: stream.	stream nextPut: $/.	frameReference frameID printOn: stream.	stream nextPut: $].	slotName printOn: stream.</body><body package="COASTGarbageCollection">printOn: stream 	self basicPrintOn: stream.</body></methods><methods><class-id>COAST.GCSlotReference class</class-id> <category>accessing</category><body package="COASTGarbageCollection">slot: slot 	| frame |	frame := slot frame.	^ ( self new )		slotName: slot coastID;		frameReference: frame frameReference;		yourself</body></methods><methods><class-id>COAST.GCHelper</class-id> <category>initialize-release</category><body package="COASTGarbageCollection">clusterManager: clusterManager 	self subclassResponsibility.</body></methods><methods><class-id>COAST.GCHelper class</class-id> <category>instance creation</category><body package="COASTGarbageCollection">clusterManager: clusterManager 	^ ( self new )		clusterManager: clusterManager;		yourself</body></methods><methods><class-id>COAST.GCSynchronizer</class-id> <category>accessing</category><body package="COASTGarbageCollection">clusterManager	^ clusterManager</body><body package="COASTGarbageCollection">exclusiveUseDo: aBlock 	hibernateSemaphore wait.	Processor yield.	[ waitForFreeMemory or: [ status == #interruptGC ]] whileTrue: 		[	self log: 'Waiting'.			( Delay forSeconds: 5 ) wait		].	hibernateSemaphore signal.	^ clusterManager volumeManager gcExclusiveUseDo: aBlock</body><body package="COASTGarbageCollection">garbageCollectionFinished	self signalEndOfGC.	status := #finishedGC.</body><body package="COASTGarbageCollection">gotoHibernation	self inHibernation ifTrue: [ ^ self ].	status := #hibernateGC.	hibernateSemaphore wait.	self log: 'hibernating'.</body><body package="COASTGarbageCollection">inHibernation	^ status = #hibernateGC</body><body package="COASTGarbageCollection">interruptGC	( self inHibernation not and: [ self okToProceed ]) ifTrue: [ status := #interruptGC ].</body><body package="COASTGarbageCollection">okToProceed	^ status ~= #stopGC</body><body package="COASTGarbageCollection">okToProceedNow	^ status = #proceedGC</body><body package="COASTGarbageCollection">proceedGC	( self inHibernation not and: [ self okToProceed ]) ifTrue: [ status := #proceedGC ].</body><body package="COASTGarbageCollection">signalEndOfGC	"neu versuchen, falls parallel gewartet werden soll..."	[ | copy |		copy := statusSemaphores copy.		copy do: 			[: sem |				Transcript show: '*'.				sem signal.				statusSemaphores remove: sem ifAbsent: nil			].		statusSemaphores isEmpty	] whileFalse.</body><body package="COASTGarbageCollection">status	^ status</body><body package="COASTGarbageCollection">stopGC	self signalEndOfGC.	self wakeUp.	status := #stopGC.	self log: 'Stopping GC'.	clusterManager clusterController do: [: clusterController | clusterController usedInGC: false ].</body><body package="COASTGarbageCollection">wakeUp	self inHibernation ifFalse: [ ^ self ].	hibernateSemaphore signal.	status := #proceedGC.	self log: 'return from hibernation'.</body></methods><methods><class-id>COAST.GCSynchronizer</class-id> <category>status</category><body package="COASTGarbageCollection">statusStringTo: stream 	stream nextPutAll: ( self inHibernation 				ifTrue: [ 'hibernating' ]				ifFalse: [ 'running' ]).	stream space.</body></methods><methods><class-id>COAST.GCSynchronizer</class-id> <category>private</category><body package="COASTGarbageCollection">log: aString 	CoastLog log: 'CGC &lt;' , clusterManager volume , '&gt; ' , aString.</body></methods><methods><class-id>COAST.GCSynchronizer</class-id> <category>initialize-release</category><body package="COASTGarbageCollection">clusterManager: aClusterManager 	clusterManager := aClusterManager.	status := #proceedGC.	statusSemaphores := OrderedCollection new.	waitForFreeMemory := false.	hibernateSemaphore := Semaphore new signal.</body><body package="COASTGarbageCollection">waitForEndOfGC	| sem |	( #( #stopGC #finishedGC ) includes: status ) ifTrue: [ ^ self ].	sem := Semaphore new.	statusSemaphores add: sem.	( #( #stopGC #finishedGC ) includes: status ) ifFalse: [ sem wait ].</body></methods><methods><class-id>COAST.CSStatistic</class-id> <category>accessing</category><body package="COASTGarbageCollection">estimatedNumberOfClusters	^ estimatedNumberOfClusters</body><body package="COASTGarbageCollection">framesDoneCounter	^ framesDoneCounter</body><body package="COASTGarbageCollection">incFramesDone	framesDoneCounter := framesDoneCounter + 1.</body><body package="COASTGarbageCollection">largestClusterID	^ largestClusterID</body><body package="COASTGarbageCollection">obsoleteClustersLeft	^ obsoleteClustersLeft</body><body package="COASTGarbageCollection">obsoleteClustersLeft: size 	obsoleteClustersLeft := size.</body><body package="COASTGarbageCollection">removedCluster: basicClusterID 	obsoleteClustersLeft := obsoleteClustersLeft - 1.</body><body package="COASTGarbageCollection">removedSlots: badSlots 	removedSlotsCount := removedSlotsCount + badSlots size.</body><body package="COASTGarbageCollection">removedSlotsCount	^ removedSlotsCount</body><body package="COASTGarbageCollection">startTime	^ startTime</body></methods><methods><class-id>COAST.CSStatistic</class-id> <category>status</category><body package="COASTGarbageCollection">statusStringTo: stream fullLiveClustersSize: fullLiveClustersSize liveFramesTodoSize: liveFramesTodoSize 	| total |	fullLiveClustersSize printOn: stream.	stream nextPutAll: 'c/'.	framesDoneCounter printOn: stream.	stream nextPutAll: 'f ('.	total := liveFramesTodoSize + fullLiveClustersSize max: estimatedNumberOfClusters.	total &gt; 0 		ifTrue: [ fullLiveClustersSize * 1000 // total * 0.1 printOn: stream ]		ifFalse: [ stream nextPutAll: '0' ].	stream nextPutAll: '%) done - '.	liveFramesTodoSize printOn: stream.	stream nextPutAll: 'c todo'.</body><body package="COASTGarbageCollection">statusStringTo: stream garbageFramesLeftSize: garbageFramesLeftSize 	stream nextPutAll: 'reclaiming, '; nextPutAll: ( garbageFramesLeftSize + obsoleteClustersLeft ) printString; nextPutAll: ' clusters to do'.</body></methods><methods><class-id>COAST.CSStatistic</class-id> <category>initialize-release</category><body package="COASTGarbageCollection">clusterManager: clusterManager 	startTime := Time secondClock.	framesDoneCounter := 0.	removedSlotsCount := 0.	estimatedNumberOfClusters := clusterManager storageInterface estimatedNumberOfClusters.	largestClusterID := clusterManager storageInterface highestID.	"highestID at begin of GC"	obsoleteClustersLeft := 0.</body></methods><methods><class-id>COAST.GCMaintenance</class-id> <category>accessing</category><body package="COASTGarbageCollection">badFrame: frameReference 	( frameReferences includesKey: frameReference ) ifFalse: [ framesToSearch add: frameReference ].	badFrames add: frameReference.</body><body package="COASTGarbageCollection">checkSlot: slot 	| slotRef frameReference |	slotToSearch == slot coastID ifTrue: 		[	slotRef := GCSlotReference slot: slot.			badSlots add: slotRef.			frameReference := slotRef frameReference.			( frameReferences includesKey: frameReference ) ifFalse: [ framesToSearch add: frameReference ]			" self badFrame: ( CatCSFrameLocator newFrameID: slot frame frameID clusterID: slot frame clusterID )."		].</body><body package="COASTGarbageCollection">foundClusterID: clusterID frameID: frameID from: slot 	| toRemove |	toRemove := framesToSearch 			detect: [: ref | ref clusterID = clusterID and: [ ref frameID = frameID ]]			ifNone: nil.	toRemove notNil ifTrue: 		[	frameReferences at: toRemove ifAbsentPut: [ GCSlotReference slot: slot ].			framesToSearch remove: toRemove		].</body><body package="COASTGarbageCollection">moveBlobAt: oldID to: newID 	blobRelocationMap at: oldID put: newID.</body><body package="COASTGarbageCollection">newIDForBlob: blobID 	^ blobRelocationMap at: blobID ifAbsent: nil</body><body package="COASTGarbageCollection">numberOfRelocatedBlobs	^ blobRelocationMap size</body><body package="COASTGarbageCollection">relocatedBlobsNewIDsDo: blob 	blobRelocationMap do: blob.</body><body package="COASTGarbageCollection">relocatedBlobsOldIDsDo: blob 	blobRelocationMap keysDo: blob.</body></methods><methods><class-id>COAST.GCMaintenance</class-id> <category>read/write</category><body package="COASTGarbageCollection">logBadFrames: clusterManager 	| badFramesLogFile stream |	badFramesLogFile := clusterManager badFramesFileAccess.	( badFrames isEmpty and: [ badSlots isEmpty and: [ slotToSearch isNil ]]) ifTrue: 		[	( badFramesLogFile exists and: [ badFramesLogFile isWritable ]) ifTrue: 				[	"try to remove the file"					[ badFramesLogFile delete ] on: Error do: [: ex | CoastLog logError: ex description , ' while deleting ' , badFramesLogFile asString ]				].			^ self		].	[	stream := badFramesLogFile writeStream.		self logHeaderOn: stream.		badFrames do: [: badFrame | self printBadObject: badFrame on: stream ].		self logSeperatorOn: stream.		badSlots do: [: badSlot | self printBadObject: badSlot on: stream ]	] ensure: [ stream notNil ifTrue: [ stream close ]].	badFrames isEmpty ifFalse: [ CoastLog logFatalError: 'found ' , badFrames size printString , ' bad frames! see: ' , badFramesLogFile asString ].</body><body package="COASTGarbageCollection">logHeaderOn: stream 	slotToSearch notNil ifTrue: 		[	slotToSearch printOn: stream.			stream cr		].	stream nextPutAll: 'first row can indicate a slotname of frames to search, e.g. #obsolete'; cr.	stream nextPutAll: 'by rerunning the CoastGarbageCollection a full reference path can be obtained'; cr.	stream nextPutAll: 'missing (bad) frames:'.	badFrames isEmpty ifTrue: [ stream nextPutAll: ' none' ].	stream cr.</body><body package="COASTGarbageCollection">logSeperatorOn: stream 	slotToSearch notNil ifTrue: 		[	stream nextPutAll: 'frames found by slot:'.			badSlots isEmpty ifTrue: [ stream nextPutAll: ' none' ].			stream cr		].</body><body package="COASTGarbageCollection">printBadObject: objectWithReference on: stream 	| slotRef frameLocator done |	objectWithReference basicPrintOn: stream.	stream cr.	frameLocator := objectWithReference frameLocator.	done := Set new.	[	slotRef := frameReferences at: frameLocator ifAbsent: nil.		slotRef isNil or: 			[	frameLocator := slotRef frameLocator.				( done includes: frameLocator ) or: [ badFrames includes: frameLocator ]			]	] whileFalse: 		[	stream tab.			slotRef printOn: stream.			stream cr.			done add: frameLocator		].</body><body package="COASTGarbageCollection">readBadFrames: clusterManager 	| badFramesLogFile readStream |	badFramesLogFile := clusterManager badFramesFileAccess.	( badFramesLogFile isNil or: [ badFramesLogFile definitelyExists not ]) ifTrue: [ ^ self ].	[	readStream := badFramesLogFile readStream.		readStream peek = $# ifTrue: 			[	readStream next.				slotToSearch := ( readStream upTo: Character cr ) asSymbol			].		[ readStream atEnd ] whileFalse: 			[ | cid fid |				readStream peek isDigit 					ifTrue: 					[	cid := Integer readFrom: readStream.						fid := $/ == readStream next 								ifTrue: [ Integer readFrom: readStream ]								ifFalse: [ nil ].						( cid ~= 0 or: [ fid notNil ]) ifTrue: 							[	framesToSearch add: ( CatCSFrameLocator newFrameID: fid clusterID: cid ).								readStream skipThrough: Character cr							]					]					ifFalse: [ readStream next ]			]	] ensure: [ readStream notNil ifTrue: [ readStream close ]].</body></methods><methods><class-id>COAST.GCMaintenance</class-id> <category>initialize</category><body package="COASTGarbageCollection">clusterManager: clusterManager 	badFrames := Set new.	badSlots := Set new.	frameReferences := Dictionary new.	framesToSearch := Set new.	slotToSearch := nil.	self readBadFrames: clusterManager.	blobRelocationMap := CatCOIntegerKeyDictionary new.</body></methods><methods><class-id>COAST.CatCSGarbageCollector</class-id> <category>live detection (private)</category><body package="COASTGarbageCollection">aFrameFrom: aClusterController frameID: frameID 	| aFrame |	statistic incFramesDone.	aFrame := aClusterController cluster directTableAccessAt: frameID.	aFrame isNil ifTrue: [ maintenance badFrame: ( CatCSFrameLocator newFrameID: frameID clusterID: aClusterController cluster id )].	^ aFrame</body><body package="COASTGarbageCollection">addLiveClusterID: clusterID frameID: frameID 	| todo |	todo := liveFramesTodo at: clusterID ifAbsentPut: [ CatCOIntegerKeySet new ].	todo add: frameID</body><body package="COASTGarbageCollection">addReferencedFileFrom: aFrame 	| referencedFile newID |	referencedFile := aFrame referencedFile.	referencedFile isNil ifTrue: [ ^ self ].	newID := maintenance newIDForBlob: referencedFile.	newID notNil ifTrue: 		[	self fixOldBlobOf: aFrame with: newID.			referencedFile := aFrame referencedFile		].	self foundFile: referencedFile.</body><body package="COASTGarbageCollection">addReferencedFramesFrom: aFrame	[	aFrame basicSlots do: 			[: slot |				maintenance checkSlot: slot.				slot 					referencedFramesOrLocatorsCursorDo: [: frameOrLocator | self foundClusterID: frameOrLocator clusterID frameID: frameOrLocator frameID from: slot ]			]	] on: FrameNotFoundError		do: 		[: ex |			maintenance badFrame: ex frameLocator.			ex frameLocator isTempShared 				ifTrue: 				[	aFrame cluster clusterController modified: true.					ex resume: nil				]				ifFalse: [ ex resume: ( CatFSFrameID id: ex frameLocator frameID )]	"auto repair"		].</body><body package="COASTGarbageCollection">finishedClusterController: clusterController 	| clusterID |	self trimLargeCollections.	clusterController hasOldStyleFrames ifTrue: [ self markForResave: clusterController ].	clusterID := clusterController clusterID.	liveFramesTodo removeRecentClusterID: clusterID.	(( liveFramesTodo finishedClusterID: clusterID ) not or: [ self hasGarbageAt: clusterID ]) 		ifTrue: [ liveFramesTodo addRecentClusterID: clusterID ]		ifFalse: 		[	clusterController usedInGC: false.			garbageFramesLeft removeKey: clusterID.			fullLiveClusters add: clusterID		].</body><body package="COASTGarbageCollection">fixOldBlobOf: aFrame with: newID 	CoastLog log: 'relocating reference to: ' , aFrame referencedFile printString.	aFrame replaceConflictiongBlobIDWith: newID.</body><body package="COASTGarbageCollection">foundClusterID: clusterID frameID: frameID 	| garbage |	( fullLiveClusters includes: clusterID ) ifTrue: [ ^ self ].	garbage := self garbageFor: clusterID ifAbsentPut: [ AntiSet new ].	( garbage remove: frameID ifAbsent: nil ) == nil ifTrue: [ ^ self ].	self addLiveClusterID: clusterID frameID: frameID.</body><body package="COASTGarbageCollection">foundClusterID: clusterID frameID: frameID from: source 	maintenance foundClusterID: clusterID frameID: frameID from: source.	self foundClusterID: clusterID frameID: frameID.</body><body package="COASTGarbageCollection">foundFile: clusterIDInteger 	"cluster is a blob and is referenced"	fullLiveClusters add: clusterIDInteger</body><body package="COASTGarbageCollection">garbageFor: clusterID ifAbsent: block 	^ garbageFramesLeft at: clusterID ifAbsent: block</body><body package="COASTGarbageCollection">garbageFor: clusterID ifAbsentPut: block 	^ garbageFramesLeft at: clusterID ifAbsentPut: block</body><body package="COASTGarbageCollection">handleFrame: frameID from: clusterController 	| aFrame |	aFrame := self aFrameFrom: clusterController frameID: frameID.	aFrame isNil ifTrue: [ ^ self ].	self addReferencedFramesFrom: aFrame.	self addReferencedFileFrom: aFrame.</body><body package="COASTGarbageCollection">hasGarbageAt: clusterID 	| collection |	collection := garbageFramesLeft at: clusterID ifAbsent: [ #( )].	^ collection isEmpty not</body><body package="COASTGarbageCollection">markForResave: clusterController 	clusterController modified: true.</body><body package="COASTGarbageCollection">missingClusterAt: clusterID 	| frameIDs |	frameIDs := self removeLiveFrameTodoIDsFrom: clusterID.	CoastLog logWarning: 'missing cluster: ' , clusterID printString , ' marking ' , frameIDs size printString , ' frames as bad'.	frameIDs do: 		[: frameID |			statistic incFramesDone.			maintenance badFrame: ( CatCSFrameLocator newFrameID: frameID clusterID: clusterID )		].</body><body package="COASTGarbageCollection">nextClusterID	"while there are unprocessed Clusters left, detect live in each cluster"	^ liveFramesTodo coastBestIDForGC</body><body package="COASTGarbageCollection">removeLiveFrameTodoIDsFrom: clusterID 	^ liveFramesTodo removeKey: clusterID ifAbsent: [ #( )]</body><body package="COASTGarbageCollection">trimLargeCollections	liveFramesTodo trimIfNeeded.	garbageFramesLeft trimIfNeeded.</body><body package="COASTGarbageCollection">updateWithAgenda: agenda 	"first handle slot write accesses, than do frame removes"	"evry write acces will mark argument-frames as live-frames - including frames removed by #atKey:remove or #removeKey: which is not 100% correct but does not harm"	"please note: first handle write accesses, than hande frame removes (because a #atKey:remove might be part of a temp-frames cleanup)"	"slotWriteAccesses"	| clusterID liveFrameIDs deadFrameIDs |	clusterID := agenda cluster clusterID.	agenda slotWriteAccesses do: 		[: slotWriteAccess | slotWriteAccess arguments do: 			[: arg | arg foundByGarbageCollector: self inClusterID: clusterID		]	].	agenda frameRemoves isEmpty ifTrue: [ ^ self	"done" ].	( fullLiveClusters includes: clusterID ) ifTrue: [ ^ self	"frame removes can be ignored" ].	liveFrameIDs := liveFramesTodo at: clusterID ifAbsent: nil.	deadFrameIDs := garbageFramesLeft at: clusterID ifAbsent: nil.	( liveFrameIDs isNil and: [ deadFrameIDs isNil ]) ifTrue: [ ^ self	"gc hasn't seen this cluster, yet - nothing to patch" ].	"patch frames to be processed"	agenda frameRemoves do: 		[: frameRemove |			liveFrameIDs notNil ifTrue: [ liveFrameIDs remove: frameRemove frameID ifAbsent: nil	"do not try to check this frame" ].			deadFrameIDs notNil ifTrue: [ deadFrameIDs remove: frameRemove frameID ifAbsent: nil	"do not try to remove this frame, again" ]		].</body></methods><methods><class-id>COAST.CatCSGarbageCollector</class-id> <category>live detection</category><body package="COASTGarbageCollection">checkAdministrationFrameInClusterController: aClusterController 	"seeking all Frames reachable from the unprocessed live frames in aClusterControllers cluster"	| basicAdministrationFrame |	basicAdministrationFrame := aClusterController cluster valueHolder at: 0.	basicAdministrationFrame notNil 		ifTrue: [ self foundClusterID: basicAdministrationFrame clusterID frameID: basicAdministrationFrame frameID ]</body><body package="COASTGarbageCollection">detectConflicts	| conflictingBlobIDs |	conflictingBlobIDs := clusterManager storageInterface conflictingBlobIDs.	[ synchronizer okToProceed and: [ conflictingBlobIDs isEmpty not ]] whileTrue: [ self fixConflictingBlob: conflictingBlobIDs removeFirst ].</body><body package="COASTGarbageCollection">detectLive	"while there are unprocessed Clusters left, detect live in each cluster"	| unprocessedClusterID |	self log: 'starting live detection.'.	[ synchronizer okToProceed and: [( unprocessedClusterID := self nextClusterID ) notNil ]] whileTrue: 		[	self exclusiveUseDo: 				[	" check again: after passing the exclusive lock, the situation might have changed  "					synchronizer okToProceed 						ifTrue: [ self detectLiveInClusterID: unprocessedClusterID ]				]		].	self log: 'live detection finished.'.</body><body package="COASTGarbageCollection">detectLiveInClusterID: clusterID 	"seeking all Frames reachable from the unprocessed live frames in aClusterControllers cluster"	| clusterController frameIDs |	clusterController := self getClusterController: clusterID.	clusterController isNil ifTrue: [ ^ self missingClusterAt: clusterID ].	clusterController usedInGC: true.	self checkAdministrationFrameInClusterController: clusterController.	[	frameIDs := synchronizer okToProceedNow 				ifTrue: [ self removeLiveFrameTodoIDsFrom: clusterID ]				ifFalse: [ #( )].		frameIDs notEmpty	] whileTrue: 		[	frameIDs do: 				[: frameID |					synchronizer okToProceedNow 						ifTrue: [ self handleFrame: frameID from: clusterController ]						ifFalse: [ self addLiveClusterID: clusterID frameID: frameID	"do it later" ]				]		].	self finishedClusterController: clusterController.</body><body package="COASTGarbageCollection">fixConflictingBlob: oldID 	self exclusiveUseDo: 		[ | newID |			newID := clusterManager newClusterID.			clusterManager storageInterface copyConflictingBlob: oldID to: newID.			CoastLog logWarning: 'replaceing blobID ' , oldID printString , ' with ' , newID printString.			maintenance moveBlobAt: oldID to: newID		].</body><body package="COASTGarbageCollection">getClusterController: clusterID 	| clusterStub garbage clusterController |	clusterStub := clusterManager getClusterStub: clusterID.	clusterStub isNil ifTrue: [ ^ nil ].	clusterController := clusterStub clusterController.	garbage := self garbageFor: clusterID ifAbsentPut: [ clusterController cluster frameIDs ].	garbage isAntiSet ifTrue: [ garbageFramesLeft at: clusterID put: ( garbage buildSetFrom: clusterController cluster frameIDs )].	^ clusterController</body></methods><methods><class-id>COAST.CatCSGarbageCollector</class-id> <category>accessing</category><body package="COASTGarbageCollection">manager: aManager 	clusterManager := aManager</body><body package="COASTGarbageCollection">status	^ synchronizer status</body><body package="COASTGarbageCollection">unprocessedLiveSize	^ liveFramesTodo inject: 0 into: [: sum : frameIDs | frameIDs size + sum ]</body></methods><methods><class-id>COAST.CatCSGarbageCollector</class-id> <category>status</category><body package="COASTGarbageCollection">gotoHibernation	synchronizer gotoHibernation.</body><body package="COASTGarbageCollection">inHibernation	^ synchronizer inHibernation</body><body package="COASTGarbageCollection">interruptGC	synchronizer interruptGC.</body><body package="COASTGarbageCollection">okToProceed	^ synchronizer okToProceed</body><body package="COASTGarbageCollection">okToProceedNow	^ synchronizer okToProceedNow</body><body package="COASTGarbageCollection">proceedGC	synchronizer proceedGC.</body><body package="COASTGarbageCollection">statusString	| stream |	stream := String new writeStream.	self statusStringTo: stream.	^ stream contents</body><body package="COASTGarbageCollection">statusStringTo: stream 	stream nextPutAll: self logPrefix; nextPutAll: ' &lt;'.	stream nextPutAll: clusterManager volume.	stream nextPutAll: '&gt; '.	synchronizer statusStringTo: stream.	liveFramesTodo isEmpty 		ifTrue: [ statistic statusStringTo: stream garbageFramesLeftSize: garbageFramesLeft size ]		ifFalse: [ statistic statusStringTo: stream fullLiveClustersSize: fullLiveClusters size liveFramesTodoSize: liveFramesTodo size ].</body><body package="COASTGarbageCollection">stopGC	synchronizer stopGC.</body><body package="COASTGarbageCollection">wakeUp	synchronizer wakeUp.</body></methods><methods><class-id>COAST.CatCSGarbageCollector</class-id> <category>garbage reclaim</category><body package="COASTGarbageCollection">logBadFrames	maintenance logBadFrames: clusterManager.</body><body package="COASTGarbageCollection">reclaimGarbage	self log: 'removed ' , statistic removedSlotsCount printString , ' slots'.	synchronizer okToProceed 		ifTrue: [ self log: 'starting garbage reclaim.' ]		ifFalse: [ ^ self log: 'skipping garbage reclaim.' ].	self reclaimGarbageFrames.	self reclaimGarbageClusters.</body><body package="COASTGarbageCollection">reclaimGarbageClusters	"goodIDs are all fullLiveClusters combined with the loaded clusterController	(during GC they are only unloaded if they are fullLiveCluster).	bad are all other but those who are generated after live detection is finished. thus no cluster beyond largestID will be deleted"	"find badIDs"	| badIDs goodIDs |	badIDs := OrderedCollection new.	self exclusiveUseDo: 		[	goodIDs := fullLiveClusters copy.			goodIDs addAll: clusterManager clusterController keys.			goodIDs isEmpty ifTrue: [ ^ self ].			clusterManager storageInterface allIDsDo: [: id | (( goodIDs includes: id ) or: [ id &gt; statistic largestClusterID ]) ifFalse: [ badIDs add: id ]].			maintenance relocatedBlobsNewIDsDo: [: id | ( goodIDs includes: id ) ifFalse: [ badIDs add: id ]]		].	"remove bad cluster"	maintenance relocatedBlobsOldIDsDo: 		[: badBlobID |			self exclusiveUseDo: 				[	synchronizer okToProceed ifFalse: [ ^ self log: 'abort garbage reclaim.' ].					clusterManager storageInterface deleteConflictingBlob: badBlobID.					badIDs remove: badBlobID ifAbsent: nil				]		].	maintenance numberOfRelocatedBlobs &gt; 0 ifTrue: [ self log: 'deleted ' , maintenance numberOfRelocatedBlobs printString , ' relocated blobs' ].	badIDs isEmpty ifFalse: 		[	self log: 'removing ' , badIDs size printString , ' clusters'.			statistic obsoleteClustersLeft: badIDs size.			badIDs do: 				[: basicClusterID |					self exclusiveUseDo: 						[	synchronizer okToProceed ifFalse: [ ^ self log: 'abort garbage reclaim.' ].							clusterManager removeCluster: basicClusterID.							statistic removedCluster: basicClusterID						]				].			self log: 'removed ' , badIDs size printString , ' clusters'		].</body><body package="COASTGarbageCollection">reclaimGarbageFrames	"find all clusters with remained garbage and let the clusterController remove it"	| garbageSize clusterCount |	garbageSize := 0.	clusterCount := 0.	[	self exclusiveUseDo: 			[ | repeat clusterID |				( repeat := synchronizer okToProceed ) 					ifTrue: 					[	clusterID := self uncleanedClusterID.						( repeat := clusterID notNil ) 							ifTrue: 							[	clusterCount := clusterCount + 1.								garbageSize := garbageSize + ( self reclaimGarbageFramesIn: clusterID )							]							ifFalse: [ self log: 'reclaimed ' , garbageSize printString , ' frames in ' , clusterCount printString , ' clusters' ]					]					ifFalse: [ self log: 'abort garbage reclaim (done ' , garbageSize printString , 'f/' , clusterCount printString , 'c).' ].				repeat			]	] whileTrue.</body><body package="COASTGarbageCollection">reclaimGarbageFramesIn: clusterID 	"find all clusters with remained garbage and let the clusterController remove it"	| clusterController garbage |	clusterController := self getClusterController: clusterID.	clusterController isNil 		ifTrue: 		[	garbageFramesLeft removeKey: clusterID.			CoastLog logError: 'lost cluster for gc reclaim: ' , clusterID printString.			^ 0		].	garbage := self garbageFor: clusterID ifAbsent: [ Set new ].	clusterController cluster dumpCells: garbage.	"should be saved..."	clusterController modified: true.	garbageFramesLeft removeKey: clusterID.	fullLiveClusters add: clusterID.	^ garbage size</body><body package="COASTGarbageCollection">uncleanedClusterID	"return a clusterController with garbage"	^ clusterManager loadedClusterIDs 		detect: [: clusterID | garbageFramesLeft includesKey: clusterID ]		ifNone: [ garbageFramesLeft coastBestIDForGC ]</body></methods><methods><class-id>COAST.CatCSGarbageCollector</class-id> <category>garbage collection</category><body package="COASTGarbageCollection">collectGarbage	" remember largest cluster ID so that clusters created during GC won't be erased "	self logClusterSizes: 10.	[	self detectConflicts.	"on the fly patching"		self detectLive.		self reclaimGarbage.		self logBadFrames.		self garbageCollectionFinished	] on: Error do: [: ex | self errorDuringGC: ex ].</body><body package="COASTGarbageCollection">garbageCollectionFinished	"all clusterController must forget all logged GC-information"	self log: 'finished (' , fullLiveClusters size printString , ' cluster / ' , statistic framesDoneCounter printString , ' frames)'.	self log: 'time: ' , ( Time fromSeconds: Time secondClock - statistic startTime ) coastDurationPrintString.	ObjectMemory removeFromScavengeNotificationList: self.	synchronizer garbageCollectionFinished.</body><body package="COASTGarbageCollection">logClusterSizes: maxCount 	self log: 'largest clusters'.	 clusterManager storageInterface		largestClusterDo: [: clusterID : byteSize | self log: 'cluster ' , clusterID displayString , ' size ' , byteSize coastShortByteSizePrintString ]		maxCount: maxCount.</body></methods><methods><class-id>COAST.CatCSGarbageCollector</class-id> <category>private</category><body package="COASTGarbageCollection">errorDuringGC: ex 	| volName |	volName := clusterManager notNil 			ifTrue: [ clusterManager volume ]			ifFalse: [ '(unknown volume)' ].	CoastLog logFatalException: ex message: 'Error during garbage collection in volume ' , volName printString.	synchronizer stopGC.</body><body package="COASTGarbageCollection">exclusiveUseDo: aBlock 	^ synchronizer exclusiveUseDo: aBlock</body><body package="COASTGarbageCollection">log: aString 	CoastLog log: self logPrefix , ' &lt;' , clusterManager volume , '&gt; ' , aString.</body><body package="COASTGarbageCollection">logPrefix	^ 'GC'</body><body package="COASTGarbageCollection">waitForEndOfGC	^ synchronizer waitForEndOfGC</body></methods><methods><class-id>COAST.CatCSGarbageCollector</class-id> <category>initialize</category><body package="COASTGarbageCollection">initialize	synchronizer := GCSynchronizer clusterManager: clusterManager.	statistic := CSStatistic clusterManager: clusterManager.	liveFramesTodo := GCIntegerKeyDictionary clusterManager: clusterManager.	self addLiveClusterID: 0 frameID: 0.	fullLiveClusters := CatCOIntegerKeySet new.	garbageFramesLeft := GCIntegerKeyDictionary new.	maintenance := GCMaintenance clusterManager: clusterManager.</body></methods><methods><class-id>COAST.CatCSGarbageCollector class</class-id> <category>instance creation</category><body package="COASTGarbageCollection">newWithManager: aManager inVolume: aVolume 	| newInst |	newInst := DefaultGCClass new.	newInst manager: aManager.	newInst initialize.	^newInst.</body></methods><methods><class-id>COAST.GCIntegerKeyDictionary</class-id> <category>accessing</category><body package="COASTGarbageCollection">addRecentClusterID: clusterID 	| limit |	recentCIDs isNil 		ifTrue: [ recentCIDs := OrderedCollection with: clusterID ]		ifFalse: 		[	recentCIDs add: clusterID.			limit := clusterManager numberOfClustersLoaded max: 200.			recentCIDs size &gt; limit ifTrue: [ recentCIDs := recentCIDs copyFrom: ( recentCIDs size // 2 max: 1 ) to: recentCIDs size ]		].</body><body package="COASTGarbageCollection">anyKey	| start |	self isEmpty ifTrue: [ ^ nil ].	start := lowestIndex ifNil: [ 1 ].	start to: largeArray size		do: 		[: i | | v |			v := largeArray at: i.			v == nil ifFalse: 				[	lowestIndex := i.					^ self keyFor: i				]		].	^ nil</body><body package="COASTGarbageCollection">at: anInteger	| index |	index := self indexFor: anInteger.	^ index &lt;= largeArray size 		ifTrue: [ largeArray at: index ]		ifFalse: [ nil ]</body><body package="COASTGarbageCollection">at: anInteger ifAbsent: absentBlock 	| index |	index := self indexFor: anInteger.	^ index &lt;= largeArray size 		ifTrue: 		[	| val |			val := largeArray at: index.			val notNil 				ifTrue: [ val ]				ifFalse: [ absentBlock value ]		]		ifFalse: [ absentBlock value ]</body><body package="COASTGarbageCollection">at: key ifAbsentPut: valueBlock 	^self at: key ifAbsent: [self at: key put: valueBlock value]</body><body package="COASTGarbageCollection">at: anInteger put: aValue 	| index |	index := self indexFor: anInteger.	aValue isNil ifTrue: 		[	self removeKey: aValue.			^ aValue		].	index &lt;= largeArray size 		ifTrue: [( largeArray at: index ) isNil ifTrue: [ tally := tally + 1 ]]		ifFalse: 		[	largeArray := largeArray coastShallowCopyWithSize: index * 2.			tally := tally + 1		].	largeArray at: index put: aValue.	clusterManager notNil ifTrue: [ self removeRecentClusterID: anInteger; addRecentClusterID: anInteger ].	lowestIndex := lowestIndex notNil 			ifTrue: [ lowestIndex min: index ]			ifFalse: [ index ].	^ aValue</body><body package="COASTGarbageCollection">clusterManager: aClusterManager 	clusterManager := aClusterManager.</body><body package="COASTGarbageCollection">coastBestIDForGC	| id |	self isEmpty ifTrue: [ ^ nil ].	id := self anyLoadedID.	id isNil ifTrue: 		[	id := self nextStoredID.			id isNil ifTrue: [ id := self anyKey ]		].	^ id</body><body package="COASTGarbageCollection">finishedClusterID: clusterID 	^ ( self at: clusterID ) ifNotNil: [: set | set isEmpty ] ifNil: [ true ]</body><body package="COASTGarbageCollection">includesKey: anInteger	| index |	index := self indexFor: anInteger.	^ index &lt;= largeArray size and: [ (largeArray at: index) notNil ]</body><body package="COASTGarbageCollection">keys	| keys |	keys := Set new: tally.	largeArray keysAndValuesDo: [ : i : v | v == nil ifFalse: [ keys add: (self keyFor: i) ]].	^ keys</body><body package="COASTGarbageCollection">removeKey: anInteger 	^ self removeKey: anInteger ifAbsent: [ nil ]</body><body package="COASTGarbageCollection">removeKey: anInteger ifAbsent: absentBlock	| val index |	index := self indexFor: anInteger.	index &lt;= largeArray size		ifFalse: [ ^ absentBlock value ].	val := largeArray at: index.	^ val notNil		ifTrue: [			largeArray at: index put: nil.			tally := tally - 1.			val		]		ifFalse: [ absentBlock value ]</body><body package="COASTGarbageCollection">removeRecentClusterID: clusterID 	recentCIDs notNil ifTrue: [ recentCIDs remove: clusterID ifAbsent: nil ].</body><body package="COASTGarbageCollection">size	^ tally</body><body package="COASTGarbageCollection">trimIfNeeded</body></methods><methods><class-id>COAST.GCIntegerKeyDictionary</class-id> <category>copying</category><body package="COASTGarbageCollection">postCopy	super postCopy.	largeArray := largeArray copy.</body></methods><methods><class-id>COAST.GCIntegerKeyDictionary</class-id> <category>testing</category><body package="COASTGarbageCollection">isEmpty	^ self size == 0</body><body package="COASTGarbageCollection">notEmpty	^ self isEmpty not</body></methods><methods><class-id>COAST.GCIntegerKeyDictionary</class-id> <category>initialize-release</category><body package="COASTGarbageCollection">initializeForSize: size	largeArray := LargeArray new: size.	tally := 0.</body></methods><methods><class-id>COAST.GCIntegerKeyDictionary</class-id> <category>private</category><body package="COASTGarbageCollection">anyLoadedID	( clusterManager notNil and: [ recentCIDs notNil and: [ recentCIDs notEmpty ]]) ifFalse: [ ^ nil ].	recentCIDs size to: 1		by: -1		do: 		[: idx | | cid |			cid := recentCIDs at: idx.			(( self includesKey: cid ) and: [ clusterManager isClusterLoaded: cid ]) ifTrue: 				[	recentCIDs size = idx ifFalse: [ recentCIDs := recentCIDs copyFrom: 1 to: idx - 1 ].					^ cid				]		].	recentCIDs := recentCIDs copyFrom: 1 to: ( 1 min: recentCIDs size ).	^ nil</body><body package="COASTGarbageCollection">indexFor: anInteger	" allow integers &gt;= 0 "	" must match #keyFor:"	^ anInteger + 1</body><body package="COASTGarbageCollection">keyFor: anIndex	" allow integers &gt;= 0 "	" must match #indexFor:"	^ anIndex - 1</body><body package="COASTGarbageCollection">nextStoredID	| cid |	clusterManager notNil ifTrue: 		[	cid := clusterManager nextClusterIDToLoad.			( cid notNil and: [ self includesKey: cid ]) ifTrue: [ ^ cid ].		].	^ nil</body></methods><methods><class-id>COAST.GCIntegerKeyDictionary class</class-id> <category>instance creation</category><body package="COASTGarbageCollection">clusterManager: clusterManager 	^ ( self new: clusterManager basicNextClusterID )		clusterManager: clusterManager;		yourself</body><body package="COASTGarbageCollection">new	^ self new: 1000</body><body package="COASTGarbageCollection">new: size	^ self basicNew initializeForSize: size</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COASTGarbageCollection">foundByGarbageCollector: aGarbageCollector inClusterID: aClusterID	" notify the garbage collection if it has found frames "</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>accessing</category><body package="COASTGarbageCollection">badFramesFileAccess	" needs work "	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>requests</category><body package="COASTGarbageCollection">conflictingBlobIDs	"should not happen"	^ #( )</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>accessing</category><body package="COASTGarbageCollection">copyConflictingBlob: oldID to: newID 	"only file storage has this fault (so far)"	self shouldNotImplement</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>requests</category><body package="COASTGarbageCollection">deleteConflictingBlob: clusterIDInteger 	"only file storage has this fault (so far)"	self shouldNotImplement</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>accessing</category><body package="COASTGarbageCollection">estimatedNumberOfClusters	| count |	count := self nextClusterID.	^ count notNil 		ifTrue: [ count ] 		ifFalse: [ self highestID ]</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor</class-id> <category>accessing</category><body package="COASTGarbageCollection">estimatedNumberOfClusters	"a very close estimation ;-)"	^ self blockFileSystem numberOfFiles</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>IDs</category><body package="COASTGarbageCollection">anyLoadedClusterIDMatching: aBlock	clusterController keysDo: [ : clusterID | (aBlock value: clusterID) ifTrue: [  ^ clusterID ] ].	^ nil</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>directories</category><body package="COASTGarbageCollection">badFramesFileAccess	^self storageInterface badFramesFileAccess</body></methods><methods><class-id>COAST.CatFSFrameID</class-id> <category>accessing</category><body package="COASTGarbageCollection">foundByGarbageCollector: aGarbageCollector inClusterID: aClusterID	aGarbageCollector foundClusterID: aClusterID frameID: self frameID</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="COASTGarbageCollection">coastShallowCopyWithSize: newSize	| newArray |	newArray := self copyEmpty: newSize.	newArray		replaceFrom: 1		to: (self size min: newSize)		with: self.	^ newArray</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>testing</category><body package="COASTGarbageCollection">foundByGarbageCollector: aGarbageCollector inClusterID: aClusterID	aGarbageCollector foundClusterID: self clusterID frameID: self frameID</body></methods><methods><class-id>Core.Dictionary</class-id> <category>private</category><body package="COASTGarbageCollection">trimIfNeeded	self basicSize &gt; ( 2 * ( self class goodSizeFrom: self size )) ifTrue: [ self trim ]</body></methods><methods><class-id>COAST.CoastBinaryContainer</class-id> <category>garbage collect</category><body package="COASTGarbageCollection">replaceConflictiongBlobIDWith: newBlobID 	"fixing code of the GC"	self transactionDo: [ self fileID: newBlobID ]</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>accessing</category><body package="COASTGarbageCollection">usedInGC: bool	" ignored "</body></methods><methods><class-id>COAST.CatCSFrameLocator</class-id> <category>testing</category><body package="COASTGarbageCollection">foundByGarbageCollector: aGarbageCollector inClusterID: aClusterID	aGarbageCollector foundClusterID: self clusterID frameID: self frameID</body></methods><methods><class-id>COAST.CatCSAbstractDiskStorageAccessor</class-id> <category>accessing</category><body package="COASTGarbageCollection">badFramesFileAccess	^self workingDirectory construct: 'badFrames.log'.</body></methods><methods><class-id>COAST.CatCOIntegerKeyDictionary</class-id> <category>accessing</category><body package="COASTGarbageCollection">coastBestIDForGC	| bestID count |	bestID := nil.	count := 0.	"checking all cids would take too much time..."	self keysDo: 		[: id | ( bestID == nil or: [ id &lt; bestID ]) 				ifTrue: [ bestID := id ].			count &lt; 1000 				ifTrue: [ count := count + 1 ]				ifFalse: [ ^ bestID	"smallest yet" ]		].	^ bestID</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>private</category><body package="COASTGarbageCollection">trimIfNeeded	self basicSize &gt; ( 2 * ( self class goodSizeFrom: self size )) ifTrue: [ self trim ]</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>requests</category><body package="COASTGarbageCollection">conflictingBlobIDs	"retreive all available stored clusters, answer a set of cluster IDs"	| result all |	result := OrderedCollection new.	all := Set new.	self allIDsFor: ( Array with: self getClusterExtension with: self getBlobExtension )		do: 		[: id | ( all includes: id ) 				ifTrue: [ result add: id ]				ifFalse: [ all add: id ]		].	^ result</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>accessing</category><body package="COASTGarbageCollection">copyConflictingBlob: oldID to: newID 	| oldBlob |	oldBlob := ( self filenameForBlobID: oldID ) asFilename.	oldBlob copyTo: ( self filenameForBlobID: newID )</body><body package="COASTGarbageCollection">deleteConflictingBlob: clusterID 	| filename |	filename := self filenameForBlobFileID: clusterID.	[	filename definitelyExists 			ifTrue: [ filename delete ]			ifFalse: [ CoastLog logError: 'Unable to delete :"' , filename printString , '" - file not found!' ]	] on: Error do: [: ex | CoastLog logError: 'Unable to delete :"' , filename printString , '"!' ]</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>accessing</category><body package="COASTGarbageCollection">gcExclusiveUseDo: aBlock	^ self exclusiveUseDo: aBlock</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CatFSFrame</name><environment>COAST</environment><super>COAST.CatCSContainerCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>coastFrameClassSymbol coastFrameClassName </class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastBinaryContainer</name><environment>COAST</environment><super>COAST.AbstractBinaryContainer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CatCSClusterManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterController autoSaveInterval volume volumeManager volumeID storageInterface autosaveTime lastSaveTime frameClassIndex nextClusterID tempBytesPool classNameManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSStorageAccessor</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumeAccessor applicationLoggers volume volumeLockInfoString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSAbstractDiskStorageAccessor</name><environment>COAST</environment><super>COAST.CatCSStorageAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSBlockFileStorageAccessor</name><environment>COAST</environment><super>COAST.CatCSAbstractDiskStorageAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockFileSystem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatFSFrameID</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class><class><name>CatCSFrameLocator</name><environment>COAST</environment><super>COAST.CatFSFrameID</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>CatCSClusterController</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cluster clusterID modified changeCount clusterManager lastSaveTime byteArrayFilename oldStyleFrameDetected </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCOIntegerKeyDictionary</name><environment>COAST</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COUtilities</category><attributes><package>COBase</package></attributes></class><class><name>CatCSVolumeManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManagers volumeInterface exclusiveLock currentLoadedClusterID packetStations autoSaveTimeInterval maxModifiedClusters segmentSplitSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSFileStorageAccessor</name><environment>COAST</environment><super>COAST.CatCSAbstractDiskStorageAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileLock workingDirectory filesPerSubDir lastFilename lastID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class></st-source>