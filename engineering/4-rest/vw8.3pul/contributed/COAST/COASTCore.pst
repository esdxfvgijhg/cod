<?xml version="1.0"?><st-source><!-- Name: COASTCoreNotice: The MIT LicenseCopyright (c) 2013 intelligent views GmbHPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.BundleName: COASTCoreBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'CiphersBase' '') #(#any 'DLLCC' '') #(#any 'HashesBase' '') #(#any 'MD5' '') #(#any 'RSA' '') #(#any 'SecurityBase' '') #(#any 'UUID' '') #(#any 'WeakCollections' '') #(#any 'Weaklings' '') #(#any 'WinService' '') #(#any 'X509' '') #(#any 'TLS' '') #(#any 'TLS-Classic' ''))DisregardedPrerequisites: #(#(#name 'Protocols-Common' #componentType #package))Parcel: nilParcelName: COASTCorePrerequisiteDescriptions: #(#(#name 'CiphersBase' #componentType #package) #(#name 'DLLCC' #componentType #package) #(#name 'HashesBase' #componentType #package) #(#name 'MD5' #componentType #package) #(#name 'RSA' #componentType #package) #(#name 'SecurityBase' #componentType #package) #(#name 'UUID' #componentType #package) #(#name 'WeakCollections' #componentType #package) #(#name 'Weaklings' #componentType #package) #(#name 'WinService' #componentType #package) #(#name 'X509' #componentType #package) #(#name 'TLS' #componentType #package) #(#name 'TLS-Classic' #componentType #package))PrerequisiteParcels: #(#('CiphersBase' '') #('DLLCC' '') #('HashesBase' '') #('MD5' '') #('RSA' '') #('SecurityBase' '') #('UUID' '') #('WeakCollections' '') #('Weaklings' '') #('WinService' '') #('X509' '') #('TLS' '') #('TLS-Classic' ''))Version: 5.5.63Date: 11:12:25 AM July 18, 2014 --><time-stamp>From VisualWorksÂ®, 7.10.1 of 6. Februar 2014 on 18. Juli 2014 at 11:12:25</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>COAST</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>COASTNameSpace</category><attributes><package>COASTNameSpace</package></attributes></name-space><class><name>CatCSCell</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container valueHolder observers </inst-vars><class-inst-vars>prototype </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>CatCSContainerCell</name><environment>COAST</environment><super>COAST.CatCSCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars>coastID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>CatFSFrame</name><environment>COAST</environment><super>COAST.CatCSContainerCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>coastFrameClassSymbol coastFrameClassName </class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatFSVirtualFrame</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastEagerObserver</name><environment>COAST</environment><super>COAST.CatFSVirtualFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSEagerObservers</category><attributes><package>COEagerObservers</package></attributes></class><class><name>CoastEagerDifferencesObserver</name><environment>COAST</environment><super>COAST.CoastEagerObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSEagerObservers</category><attributes><package>COEagerObservers</package></attributes></class><class><name>CoastDifferencesProcessingObserver</name><environment>COAST</environment><super>COAST.CoastEagerDifferencesObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestProcess requestQueue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSEagerObservers</category><attributes><package>COEagerObservers</package></attributes></class><class><name>CoastEagerBlockObserver</name><environment>COAST</environment><super>COAST.CoastEagerDifferencesObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>observeBlock updateBlock shutDownBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COEagerObservers</category><attributes><package>COEagerObservers</package></attributes></class><class><name>HuffmanString</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COMarshalling</package></attributes></class><class><name>HuffmanByteString</name><environment>COAST</environment><super>COAST.HuffmanString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COMarshalling</category><attributes><package>COMarshalling</package></attributes></class><class><name>HuffmanSymbol</name><environment>COAST</environment><super>COAST.HuffmanByteString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COMarshalling</category><attributes><package>COMarshalling</package></attributes></class><class><name>CatMAMarshallBinary</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentClusterID clusterManager slotToNumberDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSM</category><attributes><package>COMarshalling</package></attributes></class><class><name>ClusterUnmarshaller</name><environment>COAST</environment><super>COAST.CatMAMarshallBinary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterController loadCoastVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COMarshalling</package></attributes></class><class><name>ClusterUnmarshallerPre44</name><environment>COAST</environment><super>COAST.ClusterUnmarshaller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbolTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COMarshalling</package></attributes></class><class><name>CatRMMessage</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMRequestMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiverPacketStation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMClusterRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterLocator modificationNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMResponseMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMVolumeIDResponse</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumeID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMRPCRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume selector arguments recipientFrameLocator slotName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMClusterForClientMessage</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cluster globalSeqNum byteArray byteSize clusterByteSize isPrepared marshall </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMFileTransfer</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceFile targetStream size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMFileUploadRequest</name><environment>COAST</environment><super>COAST.CatRMFileTransfer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume receiverPacketStation bytes fileID sourceStream uploadSucceeded </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMClusterReleaseMessage</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterLocator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMIndexDownloadRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMConnectionsResponse</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMFileDownloadResponse</name><environment>COAST</environment><super>COAST.CatRMFileTransfer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storageInterface bytes targetFile fileID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMTestAndSetResultMessage</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>result volume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMFileUploadResponse</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMIndexDownloadResponse</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMVolumeAdministrationRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMRPCResultMessage</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultError result marshalledResult volume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMCachedClusterOkMessage</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterLocator marshall </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMVolumesResponse</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMErrorMessage</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMOkMessage</name><environment>COAST</environment><super>COAST.CatRMResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMCommand</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMAliveCommand</name><environment>COAST</environment><super>COAST.CatRMCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMConnectionsRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMFileDownloadRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileID volume targetFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMTestAndSetRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume keyFrame oldValue newValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMClusterCreateRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMVolumesRequest</name><environment>COAST</environment><super>COAST.CatRMRequestMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatRMCloseCommand</name><environment>COAST</environment><super>COAST.CatRMCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>deliverSemaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatCSApplicationLogger</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logIniFile workingDirectory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSAbstractFileApplicationLogger</name><environment>COAST</environment><super>COAST.CatCSApplicationLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename encoding iniAccess backupInterval encoder writeBackImmediately internalStream externalStream hashClass hashInstance </inst-vars><class-inst-vars>defaultFilename </class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastCSVApplicationLogger</name><environment>COAST</environment><super>COAST.CatCSAbstractFileApplicationLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unknownKeys columns columnsDictionary currentRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>AbstractUnloadStrategy</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager keepClusterIDs maxMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSUnloadStrategy</name><environment>COAST</environment><super>COAST.AbstractUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessTable keepSize unloadSize maxUnloadTime unloadClustersFlag systemSupport basicUnloadableClusterIDs maxUnloadSize clusterInfoClass lastAccessTableCompress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>LRUUnloadStrategy</name><environment>COAST</environment><super>COAST.CatCSUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>SCUnloadStrategy</name><environment>COAST</environment><super>COAST.CatCSUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>SeparableFileTranscript</name><environment>COAST</environment><super>OS.FileTranscript</super><private>false</private><indexed-type>none</indexed-type><inst-vars>maxLogSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless</category><attributes><package>COUtilities</package></attributes></class><class><name>CoastXMLApplicationLogger</name><environment>COAST</environment><super>COAST.CatCSAbstractFileApplicationLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entityTable genericKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastMemoryPolicy</name><environment>COAST</environment><super>Kernel.LargeGrainMemoryPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lowSpaceHandlerMargin emergencyLowSpaceBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSUtilities</category><attributes><package>COUtilities</package></attributes></class><class><name>CatCSVolumeStorageAccessor</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSAbstractDiskVolumeAccessor</name><environment>COAST</environment><super>COAST.CatCSVolumeStorageAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseDirectory volumeDirectory backupDirectory </inst-vars><class-inst-vars>defaultBackupDirectory defaultVolumesDirectory defaultBaseDirectory </class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSVolumeFileStorageAccessor</name><environment>COAST</environment><super>COAST.CatCSAbstractDiskVolumeAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastLog</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logLevel channelLogLevels notifiers name prefixes prefixBlocks haltOnExceptions multiTranscript exceptionLogSize channels filterChannels fileName minTime maxLogSize logExceptionBlock timestampFormat logQueue logProcess </inst-vars><class-inst-vars>singleton logs </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COUtilities</package></attributes></class><class><name>CatCSStorageAccessor</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumeAccessor applicationLoggers volume volumeLockInfoString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><comment><class-id>COAST.CatCSStorageAccessor</class-id><body>Subclasses of CatCSStorageAccessor implements storage of a COAST volume on a persistent storage media. Up to now, the only usable storage accessor is CatCSFileStorageAccessor, but that is not sufficient for large volumes containing many (&gt;10000) clusters.Subclasses must implement the following messages:	accessing		storageTypeSymbol	requests		backupVolume		blobIDs		clusterAndBlobIDs		clusterExists:		clusterIDs		deleteCluster:		highestID		readStreamOnCluster:		saveAllClustersFor:		storageSizeForBlob:		storageSizeForCluster:		storeBytes:forCluster:		transferCluster:to:		writeStreamOnCluster:size:	requests-blob		blobExists:		importBlob:fromFile:		readStreamOnBlob:		realSizeForBlobNr:		writeStreamOnBlob:size:Instance Variables:	clusterManager	&lt;CatCSClusterManager&gt;	description of clusterManager	volumeAccessor	&lt;CatCSVolumeFileStorageAccessor&gt;	description of volumeAccessor	workingDirectory	&lt;Filename | LogicalFilename&gt;	description of workingDirectory</body></comment><class><name>CatCSAbstractDiskStorageAccessor</name><environment>COAST</environment><super>COAST.CatCSStorageAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSFileStorageAccessor</name><environment>COAST</environment><super>COAST.CatCSAbstractDiskStorageAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileLock workingDirectory filesPerSubDir lastFilename lastID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>TimeoutInterrupt</name><environment>COAST</environment><super>Core.ControlInterrupt</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>COUtilities</package></attributes></class><class><name>NFUUnloadStrategy</name><environment>COAST</environment><super>COAST.CatCSUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>FileLock</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName infoString randomNumber </inst-vars><class-inst-vars>randomStream </class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>COUtilities</package></attributes></class><class><name>CatBSBlockFileVolumeAccessor</name><environment>COAST</environment><super>COAST.CatCSAbstractDiskVolumeAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastLogReconfig</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logIniFile logIniFileCheck checkerProcess lastModificationTimestamp </inst-vars><class-inst-vars>singleton </class-inst-vars><imports></imports><category></category><attributes><package>COUtilities</package></attributes></class><class><name>CatCSBlockFileStorageAccessor</name><environment>COAST</environment><super>COAST.CatCSAbstractDiskStorageAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockFileSystem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastIniAccess</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultCategory readCategory dictionary categoryStack filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSUtilities</category><attributes><package>COUtilities</package></attributes></class><class><name>CoastError</name><environment>COAST</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>CatBFError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFUnrecoverableError</name><environment>COAST</environment><super>COAST.CatBFError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFUnrecoverableFileError</name><environment>COAST</environment><super>COAST.CatBFUnrecoverableError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>PersistentTextCollector</name><environment>COAST</environment><super>UI.TextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileStream filename maxLogSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COUtilities</package></attributes></class><class><name>CatBFRecoverableError</name><environment>COAST</environment><super>COAST.CatBFError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFBlockFileTooLargeError</name><environment>COAST</environment><super>COAST.CatBFRecoverableError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastNullTextCollector</name><environment>UI</environment><super>UI.TextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>COUtilities</package></attributes></class><comment><class-id>UI.CoastNullTextCollector</class-id><body>This class exists as a TextCollector that effectively ignores its input.The instance variable 'value' is always an empty string.The instance variable 'entryStream' doesn't hold anything.  Methods that would ordinarily insert into it have been stubbed out.The #appendEntry and #update symbols are not broadcast to dependents.</body></comment><class><name>FreeMap</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBlockFileSystem</package></attributes></class><comment><class-id>COAST.FreeMap</class-id><body>FreeMap	use to add/remove integers	get some integers in sequence by length	can not add twice / remove absent	use FreeMapRoot to access interface:		#add: int		#addAll: col		#remove: int		#removeAll: col		#rangeForSize: size (^ interval)		#do: block</body></comment><class><name>FreeMapNonRoot</name><environment>COAST</environment><super>COAST.FreeMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root min max </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBlockFileSystem</package></attributes></class><comment><class-id>COAST.FreeMapNonRoot</class-id><body>FreeMapNonRootInstance Variables:	root:	 the root node (for redister/deregister)</body></comment><class><name>FreeMapLeaf</name><environment>COAST</environment><super>COAST.FreeMapNonRoot</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prevLeafOfSameSize nextLeafOfSameSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBlockFileSystem</package></attributes></class><comment><class-id>COAST.FreeMapLeaf</class-id><body>FreeMapLeafInstance Variables:	range	&lt;Interval&gt;	the range i cover</body></comment><class><name>CoastLogNotifier</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logLevel name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COUtilities</package></attributes></class><class><name>CatBFCorruptSegmentFileError</name><environment>COAST</environment><super>COAST.CatBFRecoverableError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastTestAndSet</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>dictionary recursionLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSUtilities</category><attributes><package>COUtilities</package></attributes></class><class><name>FreeMapNode</name><environment>COAST</environment><super>COAST.FreeMapNonRoot</super><private>false</private><indexed-type>none</indexed-type><inst-vars>left right height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBlockFileSystem</package></attributes></class><comment><class-id>COAST.FreeMapNode</class-id><body>FreeMapNode	this is a AVL balanced BTreeInstance Variables:	height	cached height of this node	left &amp; right	my child nodes.</body></comment><class><name>Version</name><environment>COAST</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>major minor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSM</category><attributes><package>COBase</package></attributes></class><class><name>CatRMRemoteCellAccess</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMAbstractSlotAccess</name><environment>COAST</environment><super>COAST.CatRMRemoteCellAccess</super><private>false</private><indexed-type>none</indexed-type><inst-vars>slotName frameClassSymbol valueHolderIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMSlotAccess</name><environment>COAST</environment><super>COAST.CatRMAbstractSlotAccess</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessClassID accessClass arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CommandLineParameter</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameter receiver selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COBase</package></attributes></class><class><name>CatCSTransaction</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context rolledBack composedCells composedCellsLock inDisplayPhase outstandingCompositions combinedAgenda endDemons postDemons failureBlocks inInvalidationPhase ownerProcess transactionManager isFastRead oldValuesDict commitBlocks endBlocks applicationLog delegationContexts invalidationSuppressed delayedCompositions postViewUpdateBlocks failureReason </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMUpdateTransaction</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMUpdateSingleTransaction</name><environment>COAST</environment><super>COAST.CatRMUpdateTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>simpleAgenda clusterController </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>ArgumentsDictionary</name><environment>COAST</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COBase</package></attributes></class><comment><class-id>COAST.ArgumentsDictionary</class-id><body>ArgumentsDictionary	store each values an Array of arguments	use optimized hashMethod.	optimize for single element</body></comment><class><name>CatRMMessageWithAgenda</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loggedTransactionAgenda </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMUpdateMessage</name><environment>COAST</environment><super>COAST.CatRMMessageWithAgenda</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastExitCode</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class><comment><class-id>COAST.CoastExitCode</class-id><body>Extend the exit code system to seperate vm-errors from coast application errors/* SccsId is @(#)exError.h	61.3 10/24/06 *//************************************************************************ * File: exError.h * * DESCRIPTION *	Define error codes, flags and routines. * * N.B. This file used to be called error.h but this conflicted with e.g. * Windows, which has its own error.h.  Include order can't resolve the problem * since at times both files need to be included. * *	Copyright (C) 1999-2006 Cincom Systems, Inc. *	Santa Clara, California.  All Rights Reserved. * *	UNPUBLISHED, CONFIDENTIAL AND PROPRIETARY. ************************************************************************//* * Error status codes. */#define noError 0L#define errCodeReadImage 1L#define errCodeLoadImage 2L#define errCodeImageType 3L#define errCodeAllocHeap 4L#define errCodeScavengerCrash 5L#define errCodeAlloc	6L#define errCodeCommandLine 7L#define errCodeRtOverflow 8L#define maxErrorCode 9L#define errCodeMask	0xFFL/* error severities */#define errSevNotify	0x100L#define errSevError		0x200L#define errSevFatal		0x400L#define errSevMask		0x700L#define errSevShift		8/* error code is platform defined flag */#define errCodePlats	0x800L/* error locations. Obsolete; doReportError gets filename and line number. */#define errInTran		0x1000L#define errInStack		0x2000L#define errInPrim		0x3000L#define errInMman		0x4000L#define errInDisplay	0x6000L#define errInTimer		0x9000L#define errInInitialize	0xB000L#define errInExtern		0xC000L#define errInMask		0xF000L#define errInPlat		0x10000L	/* this is a separate bit */#define errInShift		12/* error - whose fault */#define errFaultUser	0x20000L#define errFaultPlat	0x40000L#define errFaultUs		0x60000L#define errFaultLimit	0x80000L#define errFaultMask	0xE0000L#define errFaultShift	17/* error addendum - contact distributor */#define errContactUs	0x100000L</body></comment><class><name>CatRMTryResponseMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transactionID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMAcceptMessage</name><environment>COAST</environment><super>COAST.CatRMTryResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastSocketAccessor</name><environment>COAST</environment><super>Xtreams.TLSConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socketAccessor </inst-vars><class-inst-vars>useSSL </class-inst-vars><imports></imports><category>COASTDevelopment</category><attributes><package>COBase</package></attributes></class><class><name>TransactionFailReason</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>NotCommutative</name><environment>COAST</environment><super>COAST.TransactionFailReason</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conflictingAgenda </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>FrameIDCollision</name><environment>COAST</environment><super>COAST.NotCommutative</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conflictingFrameCreation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>CatCOIntegerKeySet</name><environment>COAST</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>collisions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>SlotCreationConflict</name><environment>COAST</environment><super>COAST.NotCommutative</super><private>false</private><indexed-type>none</indexed-type><inst-vars>slotCreation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>CoastMediatorStub</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTSender</category><attributes><package>COBase</package></attributes></class><class><name>CatRMUpdateMultipartTransaction</name><environment>COAST</environment><super>COAST.CatRMUpdateTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>simpleAgendas clusterControllers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastApplicationConfiguration</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iniAccess infoString infoDict defaultLogFilename logFilename needsIni serviceName serviceAction winService iniFilename defaultIniFilename maxMemory preConfigurationBlocks parentConfiguration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class><class><name>AccessConflict</name><environment>COAST</environment><super>COAST.NotCommutative</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conflictingAccess ownAccess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>CatCOIntegerKeyDictionary</name><environment>COAST</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COUtilities</category><attributes><package>COBase</package></attributes></class><class><name>CatRMTryMessage</name><environment>COAST</environment><super>COAST.CatRMMessageWithAgenda</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applicationLog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastConstant</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>CatCSFastReadTransaction</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSUnmanagedTransaction</name><environment>COAST</environment><super>COAST.CatCSFastReadTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>ClassNameManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultNameSpaces class2nameDict name2classDict </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>COASTMediator</category><attributes><package>COBase</package></attributes></class><class><name>CatRMSlotRemove</name><environment>COAST</environment><super>COAST.CatRMAbstractSlotAccess</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastApplication</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration winService startAction subApplications </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class><class><name>CatRMRejectMessage</name><environment>COAST</environment><super>COAST.CatRMTryResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastStatusResponse</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ok code message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COBase</package></attributes></class><class><name>CatRMTryAndHoldResponseMessage</name><environment>COAST</environment><super>COAST.CatRMTryResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>UnknownCommandLineArgument</name><environment>COAST</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>CatRMFrameOperation</name><environment>COAST</environment><super>COAST.CatRMRemoteCellAccess</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMFrameRemove</name><environment>COAST</environment><super>COAST.CatRMFrameOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CommandLineReadStream</name><environment>COAST</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>COBase</package></attributes></class><class><name>CatRMFrameCreation</name><environment>COAST</environment><super>COAST.CatRMFrameOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClassSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSCellValueHolder</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars>indexArray </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>CatCSFastReadWriteTransaction</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSUnmanagedWriteTransaction</name><environment>COAST</environment><super>COAST.CatCSFastReadWriteTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>HashSegmentedDictionary</name><environment>COAST</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>contents bytePos overflow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COBase</package></attributes></class><class><name>CatRMSlotCreation</name><environment>COAST</environment><super>COAST.CatRMAbstractSlotAccess</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>SupervisedSubordinate</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>commandQueue supervisorPort sendStream receiveStream receiveProcess socketAccessor coastApplication </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class><class><name>CatRMVolumeSaveRequest</name><environment>COAST</environment><super>COAST.CatRMVolumeAdministrationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CoastIDAndHashWrapper</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellHashValue coastID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class><class><name>CatRMStreamingClusterForClientMessage</name><environment>COAST</environment><super>COAST.CatRMClusterForClientMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storageInterface </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CoastSortedSet</name><environment>COAST</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COBase</package></attributes></class><class><name>CatRMVolumeIDRequest</name><environment>COAST</environment><super>COAST.CatRMVolumeAdministrationRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>SupervisionMessage</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments commandSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class><class><name>CoastFilteringCSVApplicationLogger</name><environment>COAST</environment><super>COAST.CoastCSVApplicationLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filterKeys validValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>MinAgeLRUUnloadStrategy</name><environment>COAST</environment><super>COAST.LRUUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>minAge unloadInterval lastUnloadAttempt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSSlotDefinition</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prototype demons slotName definedBy responsibleDemons minimizeInvalidation allowRPCs forceRPC clientData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>ReadOnlyBlockFileVolumeAccessor</name><environment>COAST</environment><super>COAST.CatBSBlockFileVolumeAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>ReadOnlyBlockFileStorageAccessor</name><environment>COAST</environment><super>COAST.CatCSBlockFileStorageAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatCSCellValueDifferences</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>added removed </inst-vars><class-inst-vars>emptyDifferencesSingleton </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>DuplicateSlotCreation</name><environment>COAST</environment><super>COAST.SlotCreationConflict</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conflictingType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>AbstractMultiValueDictionary</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COBase</package></attributes></class><class><name>CreateSlotOfUnknownFrame</name><environment>COAST</environment><super>COAST.SlotCreationConflict</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>AbstractSegmentedCollection</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>size diffCollection partialCollections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COBase</package></attributes></class><class><name>CatRMMultiPartUpdateMessage</name><environment>COAST</environment><super>COAST.CatRMUpdateMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>allTransactionIDs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatFSFrameID</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class><class><name>CatRMLastWishMessage</name><environment>COAST</environment><super>COAST.CatRMTryMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastWeakSet</name><environment>COAST</environment><super>Core.WeakArray</super><private>false</private><indexed-type>weak</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports>			Set.*			</imports><category>COBase</category><attributes><package>COBase</package></attributes></class><comment><class-id>COAST.CoastWeakSet</class-id><body>WARNING: Note that CoastWeakSet may not implement some collection methods correctly that are implemented by SequenceableCollection or ArrayedCollection (due to size ~~ capacity)Instance Variables:	tally	&lt;ArithmeticValue&gt;	description of tally	</body></comment><class><name>CatRMDidRejectMessage</name><environment>COAST</environment><super>COAST.CatRMTryAndHoldResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastWinService</name><environment>COAST</environment><super>OS.WinService</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WinService</category><attributes><package>COBase</package></attributes></class><class><name>CatRMSlotAccessForInvalidation</name><environment>COAST</environment><super>COAST.CatRMSlotAccess</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMDidAcceptMessage</name><environment>COAST</environment><super>COAST.CatRMTryAndHoldResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transactionIDs replacementAgendas </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSCellAccess</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>cellOrCellWrapper transaction </inst-vars><class-inst-vars>commAccesses commEqualAccesses commDifferentAccesses accessClassTable </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSCellWrapper</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>protoSlot frame </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CoastServerMemoryPolicy</name><environment>COAST</environment><super>COAST.CoastMemoryPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSUtilities</category><attributes><package>COUtilities</package></attributes></class><class><name>SupervisorCommand</name><environment>COAST</environment><super>COAST.SupervisionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class><comment><class-id>COAST.SupervisorCommand</class-id><body>SupervisorCommand represents a command which is send from the supervisor to the subordinate. It can be marshaled.</body></comment><class><name>SubordinateMessage</name><environment>COAST</environment><super>COAST.SupervisionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COAST</category><attributes><package>COBase</package></attributes></class><class><name>CoastTriedToLoadClusterTwiceError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>CatCSVirtualSlotDefinition</name><environment>COAST</environment><super>COAST.CatCSSlotDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composingMethod releaseOldValueBlock computeInSequence makeImmutable revalidationBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>FrameNotFoundError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>SlotNotFoundError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>CatCSEndCell</name><environment>COAST</environment><super>COAST.CatCSCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definition </inst-vars><class-inst-vars>typeDictionary </class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBase</package></attributes></class><class><name>SecurityFault</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>CatCSCellValueAndDifferences</name><environment>COAST</environment><super>COAST.CatCSCellValueDifferences</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>ClusterNotFoundError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>CoastConnectionLostError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>Index</name><environment>COAST</environment><super>COAST.AbstractMultiValueDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COBase</package></attributes></class><class><name>SegmentedDictionary</name><environment>COAST</environment><super>COAST.AbstractSegmentedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COBase</package></attributes></class><class><name>CoastFatalError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>SegmentedIndex</name><environment>COAST</environment><super>COAST.AbstractSegmentedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COBase</package></attributes></class><class><name>CatCSFrameLocator</name><environment>COAST</environment><super>COAST.CatFSFrameID</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class><class><name>CoastWeakObservers</name><environment>COAST</environment><super>COAST.CoastWeakSet</super><private>false</private><indexed-type>weak</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COBase</package></attributes></class><class><name>CoastInvalidAccessError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>CoastCommandLineError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBase</package></attributes></class><class><name>MultiValueDictionary</name><environment>COAST</environment><super>COAST.AbstractMultiValueDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COBase</package></attributes></class><class><name>CoastVersion</name><environment>COAST</environment><super>COAST.Version</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>buildString rsa trustedPublicKeys </class-inst-vars><imports></imports><category>COASTCore-CSM</category><attributes><package>COBase</package></attributes></class><class><name>VisualWorksVersion</name><environment>COAST</environment><super>COAST.Version</super><private>false</private><indexed-type>none</indexed-type><inst-vars>patch suffix </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COBase</package></attributes></class><class><name>AccessDeniedError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COBase</package></attributes></class><class><name>CatCSReadCellAccess</name><environment>COAST</environment><super>COAST.CatCSCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSWriteCellAccess</name><environment>COAST</environment><super>COAST.CatCSCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>diffs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatFSFrameReference</name><environment>COAST</environment><super>COAST.CatCSFrameLocator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClassOrSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COBase</package></attributes></class><class><name>CatCSKeyIntervalAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSIncludesKeyAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAbstractRemoveAccess</name><environment>COAST</environment><super>COAST.CatCSWriteCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAddAccess</name><environment>COAST</environment><super>COAST.CatCSWriteCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSIndexOfAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAtIndexPutAccess</name><environment>COAST</environment><super>COAST.CatCSWriteCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAtKeyAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSKeyAtValueAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSRemoveAllOccurrencesAccess</name><environment>COAST</environment><super>COAST.CatCSWriteCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSDepleteAccess</name><environment>COAST</environment><super>COAST.CatCSWriteCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSFirstAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSOccurrencesOfAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAtIndexAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSRemoveAccess</name><environment>COAST</environment><super>COAST.CatCSWriteCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSIncludesAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSBeforeAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAfterAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSValueReadAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSIsEmptyAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSKeysAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSValuesAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSExclusiveKeyIntervalAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSSizeAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAbstractAddAccess</name><environment>COAST</environment><super>COAST.CatCSWriteCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSValueWriteAccess</name><environment>COAST</environment><super>COAST.CatCSWriteCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAtKeyPutAccess</name><environment>COAST</environment><super>COAST.CatCSWriteCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAddWithOccurrencesAccess</name><environment>COAST</environment><super>COAST.CatCSWriteCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAtKeyIncludesAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSLastAccess</name><environment>COAST</environment><super>COAST.CatCSReadCellAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAddLastAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractAddAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAddBeforeIndexAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractAddAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSValueUpdateAccess</name><environment>COAST</environment><super>COAST.CatCSValueWriteAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSRemoveFirstAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractRemoveAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSRemoveLastAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractRemoveAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAtKeyAddAccess</name><environment>COAST</environment><super>COAST.CatCSAtKeyPutAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSMaxJournalSizeWriteAccess</name><environment>COAST</environment><super>COAST.CatCSValueWriteAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAddBeforeAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractAddAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAtKeyRemoveAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractRemoveAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSCollectionWriteAccess</name><environment>COAST</environment><super>COAST.CatCSValueWriteAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>collectionCopyForReplication </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSRemoveKeyAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractRemoveAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAddAfterIndexAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractAddAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAddFirstAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractAddAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSRemoveAtIndexAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractRemoveAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSAddAfterAccess</name><environment>COAST</environment><super>COAST.CatCSAbstractAddAccess</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellAccesses</category><attributes><package>COCellAccesses</package></attributes></class><class><name>CatCSSingleValue</name><environment>COAST</environment><super>COAST.CatCSCellValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactTransformation</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>previous </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>SmallIntegerArray</name><environment>COAST</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COCellValueHolder</package></attributes></class><comment><class-id>COAST.SmallIntegerArray</class-id><body>Elements of a SmallIntegerArray can only be SmallIntegers </body></comment><class><name>CompactCollection</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>addedFrames removedFrames clusterManager frameIDs clusterIDs classIndices frameClassArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSAbstractCollection</name><environment>COAST</environment><super>COAST.CatCSCellValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactSimpleCollection</name><environment>COAST</environment><super>COAST.CompactCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSCollection</name><environment>COAST</environment><super>COAST.CatCSAbstractCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactAbstractIndex</name><environment>COAST</environment><super>COAST.CompactCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSProxyValueHolder</name><environment>COAST</environment><super>COAST.CatCSAbstractCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManager </inst-vars><class-inst-vars>defaultValue </class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSDelegatingValueHolder</name><environment>COAST</environment><super>COAST.CatCSAbstractCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>slot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSVirtualValue</name><environment>COAST</environment><super>COAST.CatCSSingleValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactAdd</name><environment>COAST</environment><super>COAST.CompactTransformation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pos elem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactMove</name><environment>COAST</environment><super>COAST.CompactTransformation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop by </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactSet</name><environment>COAST</environment><super>COAST.CompactSimpleCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSKeyedCollection</name><environment>COAST</environment><super>COAST.CatCSCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactKeyIndex</name><environment>COAST</environment><super>COAST.CompactAbstractIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSSet</name><environment>COAST</environment><super>COAST.CatCSCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSProxyIndex</name><environment>COAST</environment><super>COAST.CatCSProxyValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSBag</name><environment>COAST</environment><super>COAST.CatCSCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSProxySet</name><environment>COAST</environment><super>COAST.CatCSProxyValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactRPCResultCollection</name><environment>COAST</environment><super>COAST.CompactSimpleCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSDelegatingProxySet</name><environment>COAST</environment><super>COAST.CatCSDelegatingValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSProxyBag</name><environment>COAST</environment><super>COAST.CatCSProxyValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSProxyDictionary</name><environment>COAST</environment><super>COAST.CatCSProxyValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactValueIndex</name><environment>COAST</environment><super>COAST.CompactAbstractIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSDelegatingProxyIndex</name><environment>COAST</environment><super>COAST.CatCSDelegatingValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSSequenceableCollection</name><environment>COAST</environment><super>COAST.CatCSCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactIndex</name><environment>COAST</environment><super>COAST.CompactAbstractIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars>valueClassIndices valueFrameIDs valueClusterIDs valueFrameClassArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactAbstractDictionary</name><environment>COAST</environment><super>COAST.CompactSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSAbstractIndex</name><environment>COAST</environment><super>COAST.CatCSKeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSDictionary</name><environment>COAST</environment><super>COAST.CatCSSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSCompactBag</name><environment>COAST</environment><super>COAST.CatCSBag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSDelegatingProxyDictionary</name><environment>COAST</environment><super>COAST.CatCSDelegatingProxySet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSMultiValueDictionary</name><environment>COAST</environment><super>COAST.CatCSKeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSSortedSet</name><environment>COAST</environment><super>COAST.CatCSSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSCompactSet</name><environment>COAST</environment><super>COAST.CatCSSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSCompactRPCResultCollection</name><environment>COAST</environment><super>COAST.CatCSSequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSOrderedCollection</name><environment>COAST</environment><super>COAST.CatCSSequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactKeyDictionary</name><environment>COAST</environment><super>COAST.CompactAbstractDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSSlotDictionary</name><environment>COAST</environment><super>COAST.CatCSDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSCompactValueIndex</name><environment>COAST</environment><super>COAST.CatCSAbstractIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSDelegatingProxyBag</name><environment>COAST</environment><super>COAST.CatCSDelegatingProxyDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSCompactKeyDictionary</name><environment>COAST</environment><super>COAST.CatCSDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSFrameDictionary</name><environment>COAST</environment><super>COAST.CatCSDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactDictionary</name><environment>COAST</environment><super>COAST.CompactAbstractDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>valueClassIndices valueFrameIDs valueClusterIDs valueFrameClassArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSCompactKeyIndex</name><environment>COAST</environment><super>COAST.CatCSAbstractIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSCompactIndex</name><environment>COAST</environment><super>COAST.CatCSAbstractIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CompactBag</name><environment>COAST</environment><super>COAST.CompactKeyDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSDefectSlotDictionary</name><environment>COAST</environment><super>COAST.CatCSSlotDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatCSCompactDictionary</name><environment>COAST</environment><super>COAST.CatCSCompactKeyDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSCellValueHolder</category><attributes><package>COCellValueHolder</package></attributes></class><class><name>CatMARepeatedObject</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSM</category><attributes><package>COMarshalling</package></attributes></class><class><name>CoastVirtualInteger</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COMarshalling</package></attributes></class><comment><class-id>COAST.CoastVirtualInteger</class-id><body>CoastVirtualInteger is abstract class to group its subclassessubclasses can be used to read non negative SmallInteger up to 16777215 from a streamNone of these classes should be instanciated!Sublasses are used to determine the size of the integer.	CoastOneByteInteger: used and valid for 0 to 255 (FF)	CoastTwoByteInteger: valid for 0 to 65535 (FFFF), but used only for values &gt; 255	CoastTreeByteInteger: valid for 0 to 16777215 (FFFFFF), but used only for values &gt; 65535See also SmallInteger&gt;&gt;marshallBinaryTo:marshaller: </body></comment><class><name>SizeCalculatingStream</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>COMarshalling</package></attributes></class><class><name>CoastHashStream</name><environment>COAST</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalStream buffer bufferSize ignoreBytesCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>COMarshalling</package></attributes></class><class><name>HuffmanDecodingNode</name><environment>COAST</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1-Support</category><attributes><package>COMarshalling</package></attributes></class><class><name>COBinaryExternal</name><environment>COAST</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>singleton libAvailable </class-inst-vars><imports>			private COAST.COBinaryExternalDictionary.*			</imports><category>COMarshalling</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>coastbinary.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>COMarshalling</package></attributes></class><class><name>HuffmanStringCodec</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>arrayStack characterArray byteEncoding byteDecodingRoots </class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COMarshalling</package></attributes></class><class><name>HuffmanEncodingArray</name><environment>COAST</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>numberOfBits character </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1-Support</category><attributes><package>COMarshalling</package></attributes></class><class><name>CatCSTempBytesPool</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tempBytesPool tempBytesCounter exclusiveLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSM</category><attributes><package>COMarshalling</package></attributes></class><class><name>HuffmanDecodingLeaf</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>character numberOfBits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COMarshalling</category><attributes><package>COMarshalling</package></attributes></class><class><name>HuffmanEncodeStatus</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byte bitPos </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>COMarshalling</package></attributes></class><class><name>CatRMFileDownloadTarget</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetStream bytesOnly key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>CatCSClusterInfo</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loadTime accessTime accessCount loadFromMediatorCount loadFromCacheCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSFrameClassIndex</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classNameManager namespaceDict frameClassTable frameClassDict hasUpdates </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><comment><class-id>COAST.CatCSFrameClassIndex</class-id><body>to save bytes while marschalling coast frames, a frame class index can associate frame classes and their slots to numbers.this is done by a frame slot index (CatFSFrameSlotIndex) per frame class.	Instance Variables:	classNameManager			clusterManager (for lazy updates)	namespaceDict				Dictionary for old frameclasses without namespace	frameClassDict				Dictionary frameClass -&gt; frameSlotIndex (also holds frameClassSymbol -&gt; frameSlotIndex)	frameClassTable			Array frameClassKey -&gt; frameSlotIndex	hasUpdates					true when modified (for lazy updates)</body></comment><class><name>StreamableCluster</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>AbstractStorageInterface</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManager binaryStoreInterfaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>AbstractVolumeStorageInterface</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSClusterController</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cluster clusterID modified changeCount clusterManager lastSaveTime byteArrayFilename oldStyleFrameDetected </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastFrameClassIndexError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastFileStorageError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COClusterManagement</package></attributes></class><class><name>UnloadableClustersCollection</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orderDict orderedClusters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastOsStreamError</name><environment>OS</environment><super>OS.OsError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COReplication</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSVolumeManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManagers volumeInterface exclusiveLock currentLoadedClusterID packetStations autoSaveTimeInterval maxModifiedClusters segmentSplitSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatRMPacketStation</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sendQueue sendProcess receiveProcess sendStream receiveStream socketAccessor connected volumeManager trySendMessage lastSendID lastReceiveID isInShutdown ipAdressString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastCSVLogColumn</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index isQuoted isUnknown </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSClusterManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterController autoSaveInterval volume volumeManager volumeID storageInterface autosaveTime lastSaveTime frameClassIndex nextClusterID tempBytesPool classNameManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatCSFrameSlotIndex</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClassIndex key slotArray slotDict frameClass frameClassSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><comment><class-id>COAST.CatCSFrameSlotIndex</class-id><body>instances of CatCSFrameSlotIndex know all about a single frame classInstance Variables:	frameClassIndex	the frame class index which controlls all frame slot indices (for callbacks)	key					the Number associated to frameClass	frameClass			a subclass of CatFSFrame, optional (eg Mediator)	frameClassSymbol	the frameClassSymbol of frameClass	slotArray			Array (slotnumber =&gt; slotSymbol)	slotDict				Dictionary (slotSymbol =&gt; number)</body></comment><class><name>CatBFSegmentedFile</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>segmentsModifiedIndex blockFileSystem stream isLocked </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFStream</name><environment>COAST</environment><super>OS.ExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockFileSystem currentBlock file blockMinPosition isOpen bufferSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><comment><class-id>COAST.CatBFStream</class-id><body>Read/Write-Stream on a file within a block file system.Instance Variables:	blockFileSystem	&lt;CatBFSBlockFileSystem&gt;	file system of this stream	currentBlock	&lt;CatBFBlock&gt;	currently accessed block</body></comment><class><name>CatBFDirectorySegment</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filesDictionary maxKey numFiles dirty </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFLockError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFBlockFileSystem</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bfsFileHandle isLocked lockInfoString seekPosition accessLock numberOfBlocks blockSize patchMode lastModification version modificationNumber processID headerBuffer availableBuffers buffers openWriteStreams openReadStreams workingDirectory coreName directory freeList nextClusterID uniqueVolumeID lockFile backupCopyInfo backgroundCopyInfos growSizeInBytes backgroundOperationProcessPriority readOnly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><comment><class-id>COAST.CatBFBlockFileSystem</class-id><body>A block file system (BFS). Consists of two files:- A block file (containing the blocks)- An index file (for fast file access)The block file is the master file, and the index file can always be recovered from the block file.The block file has a fixed size header. The block size can be specified when creating a BFS.Instance Variables:	accessLock	&lt;RecursionLock&gt;	Used to synchronize access to the BFS	blockSize	&lt;Integer&gt;	Size of a block	coreFilename	&lt;Filename&gt;	Filename of the block/index file without extension	directory	&lt;CatBFDirectory&gt;	directory of files stored in the BFS	freeList	&lt;CatBFFreeBlockList&gt;	free blocks list	growSize	&lt;Integer&gt;	Number of blocks that are allocated when growing	lastModification	&lt;Timestamp&gt;	Timestamp of the last modification	modificationNumber	&lt;Integer&gt;	Increasing number of the last modification	numberOfBlocks	&lt;Integer&gt;	Total number of allocated blocks	stream	&lt;Stream&gt;	private read-/write-stream on the block data file	version	&lt;CoastVersion&gt;	Version of the BFS (= COAST version)	openStreams &lt;CatBFBlockFileStream&gt;	Open streams on files within the BFS	recoveryMode &lt;Boolean&gt;	True if a recovery is in progress	headerBuffer &lt;ByteArray&gt;	Buffer used to write the block file header	processID	&lt;Integer&gt;	ID of the current OS process that has opened the BFS</body></comment><class><name>CatBFRecoverFile</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockIDs fileSize fileType modificationNumber firstBlockNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>FreeMapLeafList</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLeaf numberOfLeafs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFBackgroundCopyInfo</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetBlockFile sourceBlockFile blockFileBytesToCopy lock targetDirectory copyProcess copySemaphore copyDone description header </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFFile</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileNumber firstBlockNumber fileType modificationNumber fileSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFBlock</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockNumber fileNumber nextBlockNumber blockSize dataSize modificationNumber fileBlockIndex fileType needsWriteBack </inst-vars><class-inst-vars>tmpHeaderBytes tmpEmptyBytes </class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFFreeBlockListSegment</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>freeBlocks dirty </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatBFFileLock</name><environment>COAST</environment><super>COAST.FileLock</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lockStream infoDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COUtilities</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CatCSMissingTransactionError</name><environment>COAST</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMLoggedTransactionAgenda</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>agenda transactionID flags failReasons </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSPreparedAgenda</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unpreparedAgenda writeAccessesPerCluster readAccessesPerCluster createdCellsPerCluster preparedSimpleAgendas </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastUnhandledAbortTransactionNotification</name><environment>COAST</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COTransactions</package></attributes></class><class><name>TransactionPolicy</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transactionManager isFastRead embeddedStackDepth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><comment><class-id>COAST.TransactionPolicy</class-id><body>Hilft beim Umgang mit TransaktionenDie konkreten Subklassen steuern, welche Teile durch eine Transaktion zusammengefasst werden.		instances := policy discreteTransactionDo: [ concept instances ].		policy enclosingTransactionDo: [			instances do: [ : instance |				policy embeddedTransactionDo: [					instance isolateWithDeleteContext.				].			]		].</body></comment><class><name>CatCSAgenda</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readAccesses readClusterIDs createdCells writesPerCell involvedClusters accessedUnregisteredCells simpleAgendas createdLocalFrames clusterManager writeAccessesAndNils removedFrames preparedAgenda referencedClusterIDs removedSlots </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastTransactionManager</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activeTransaction transactionSequence eagerObservers developmentMode active rollForwardNotificationBlocks rollBackNotificationBlocks updateNotificationBlocks pendingProcesses volumeManager context outstandingTransactionsCount blockCaches needsFlush localUser </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSClusterLocator</name><environment>COAST</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id volume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastSequenceFailureNotification</name><environment>COAST</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COTransactions</package></attributes></class><class><name>SegmentedCollectionHeader</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastKeys clusterIDs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatRMAbstractAgendaChecker</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><comment><class-id>COAST.CatRMAbstractAgendaChecker</class-id><body>CatRMAbstractAgendaChecker is an abstract classsubclasses should implement #isValidAgenda:cluster: (return true if the agenda for the given cluster should be replayed)An instance of the subclass should be stored in the shared variable COAST.AgendaChecker</body></comment><class><name>FrameSet</name><environment>COAST</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COFramesystem</package></attributes></class><comment><class-id>COAST.FrameSet</class-id><body>The class FrameSet is just like IdentitySet, but uses another hashingMethod (#sharedFrameHash)Intended Use: stores shared frames.if other objects are added, the FrameSet becomes an IdentitySet...</body></comment><class><name>CoastTransactionError</name><environment>COAST</environment><super>COAST.CoastError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COTransactions</package></attributes></class><class><name>ThreadSafeWeakFrameSet</name><environment>Core</environment><super>Core.ThreadSafeWeakSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastFinalEndBlock</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>ResolveClusterNotification</name><environment>COAST</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastBlockCache</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block cachedValues transactionManager hits misses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIWidgets</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSCluster</name><environment>COAST</environment><super>COAST.CatCSContainerCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterController modificationNumber unmarshaller approxByteSize clusterStream mayHaveNonWeakObserver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastApplicationLogEntry</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastAbortTransactionNotification</name><environment>COAST</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CatFSDemon</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>priority name argument read write preJob postJob endTransactionJob postTransactionJob </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatRMTransactionID</name><environment>COAST</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientID localSeqNum globalSeqNum clusterLocator basedOnLocal basedOnGlobal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CatFSVirtualSlot</name><environment>COAST</environment><super>COAST.CatCSEndCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars>valid subjects subjectObserverPairs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatRMSimpleAgenda</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameCreations frameRemoves slotCreations slotRemoves unpreparedReadAccesses slotWriteAccesses slotReadAccesses clusterLocator cluster slotAccessList isPrepared </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>SegmentedFrameSet</name><environment>COAST</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>contents keyIndex overflow splitSize keyBitShift </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COFramesystem</package></attributes></class><class><name>CatRMLoggedTransaction</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transactionID transaction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>AbstractObserver</name><environment>COAST</environment><super>Weaklings.Weakling</super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatCSApplicationLog</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logEntries currentEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CatFSSlot</name><environment>COAST</environment><super>COAST.CatCSEndCell</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CopyContext</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>copyStack volume deepCopyQueryBlock spawnBlock deepCopiedCells </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COFramesystem</package></attributes></class><class><name>CatFSCachedValue</name><environment>COAST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastLargeSetSegment</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>maxNumberOfValues </class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatMASingleRepeatedObject</name><environment>COAST</environment><super>COAST.CatMARepeatedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>singleton </class-inst-vars><imports></imports><category>COMarshalling</category><attributes><package>COMarshalling</package></attributes></class><class><name>CatFSPreIsolateDemon</name><environment>COAST</environment><super>COAST.CatFSDemon</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>HuffmanISOString</name><environment>COAST</environment><super>COAST.HuffmanString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COMarshalling</category><attributes><package>COMarshalling</package></attributes></class><class><name>CoastCollection</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatMAShortRepeatedObject</name><environment>COAST</environment><super>COAST.CatMARepeatedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars>singletons </class-inst-vars><imports></imports><category>COMarshalling</category><attributes><package>COMarshalling</package></attributes></class><class><name>CatFSCachingVirtualSlot</name><environment>COAST</environment><super>COAST.CatFSVirtualSlot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatMALongRepeatedObject</name><environment>COAST</environment><super>COAST.CatMARepeatedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COMarshalling</category><attributes><package>COMarshalling</package></attributes></class><class><name>CatFSEagerVirtualSlot</name><environment>COAST</environment><super>COAST.CatFSVirtualSlot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastThreeByteInteger</name><environment>COAST</environment><super>COAST.CoastVirtualInteger</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>COMarshalling</package></attributes></class><comment><class-id>COAST.CoastThreeByteInteger</class-id><body>see comment of superclass CoastVirtualInteger</body></comment><class><name>CoastCollectionSegment</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastOneByteInteger</name><environment>COAST</environment><super>COAST.CoastVirtualInteger</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>COMarshalling</package></attributes></class><comment><class-id>COAST.CoastOneByteInteger</class-id><body>see comment of superclass CoastVirtualInteger</body></comment><class><name>CatFSConstituentDemon</name><environment>COAST</environment><super>COAST.CatFSDemon</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastTwoByteInteger</name><environment>COAST</environment><super>COAST.CoastVirtualInteger</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>COMarshalling</package></attributes></class><comment><class-id>COAST.CoastTwoByteInteger</class-id><body>see comment of superclass CoastVirtualInteger</body></comment><class><name>AbstractBinaryContainer</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastSegmentSetHolder</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatRMInterruptMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volume data target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>WeakSegmentedFrameSet</name><environment>COAST</environment><super>COAST.SegmentedFrameSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COFramesystem</package></attributes></class><class><name>CatFSUniversalFrame</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>frameClassName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSM</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatCSClusterAdministrationFrame</name><environment>COAST</environment><super>COAST.CatFSFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatRMAliveMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>globalSeqNum clientID receiver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COMessages</package></attributes></class><class><name>SlotObserverPair</name><environment>COAST</environment><super>COAST.AbstractObserver</super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars>slotName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>SegmentedIndexHeader</name><environment>COAST</environment><super>COAST.SegmentedCollectionHeader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore</category><attributes><package>COFramesystem</package></attributes></class><class><name>AccessObserverPair</name><environment>COAST</environment><super>COAST.AbstractObserver</super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars>accesses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatCSExternalFileInfo</name><environment>COAST</environment><super>COAST.CatCSClusterInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatFSInvertingDemon</name><environment>COAST</environment><super>COAST.CatFSPreIsolateDemon</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastJournalCollection</name><environment>COAST</environment><super>COAST.CoastCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastSegmentedCollection</name><environment>COAST</environment><super>COAST.CoastCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>MemoryBasedUnloadStrategy</name><environment>COAST</environment><super>COAST.AbstractUnloadStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>approxTotalClusterSize approxTotalIndexClusterSize ccIterateIndex lastGCState currentObjectMemory unloadRecommended forceUnloadAllPossible </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastIndexSegment</name><environment>COAST</environment><super>COAST.CoastCollectionSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>RemoteFrameClassIndex</name><environment>COAST</environment><super>COAST.CatCSFrameClassIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatFSCoastNameDemon</name><environment>COAST</environment><super>COAST.CatFSPreIsolateDemon</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>UpdatingFrameClassIndex</name><environment>COAST</environment><super>COAST.CatCSFrameClassIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lock doNotUpdateNow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastAbstractSetSegment</name><environment>COAST</environment><super>COAST.CoastCollectionSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>UnpreparedStreamableCluster</name><environment>COAST</environment><super>COAST.StreamableCluster</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterController marshaller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COClusterManagement</package></attributes></class><class><name>CatFSWeakCachingSlot</name><environment>COAST</environment><super>COAST.CatFSCachingVirtualSlot</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockCache arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>RemoteStorageInterface</name><environment>COAST</environment><super>COAST.AbstractStorageInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastDictionarySegment</name><environment>COAST</environment><super>COAST.CoastCollectionSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>LocalVolumeStorageInterface</name><environment>COAST</environment><super>COAST.AbstractVolumeStorageInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumeAccessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastBinaryContainer</name><environment>COAST</environment><super>COAST.AbstractBinaryContainer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatCSSingleController</name><environment>COAST</environment><super>COAST.CatCSClusterController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unloadStrategyInformation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastJournalIndex</name><environment>COAST</environment><super>COAST.CoastJournalCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>LocalStorageInterface</name><environment>COAST</environment><super>COAST.AbstractStorageInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storageAccessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastAbstractSegmentedSet</name><environment>COAST</environment><super>COAST.CoastSegmentedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>RemoteVolumeStorageInterface</name><environment>COAST</environment><super>COAST.AbstractVolumeStorageInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastKeyIndexSegment</name><environment>COAST</environment><super>COAST.CoastIndexSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>PreparedStreamableCluster</name><environment>COAST</environment><super>COAST.StreamableCluster</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clusterBytes clusterID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastSegmentedIndex</name><environment>COAST</environment><super>COAST.CoastSegmentedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatCSNullApplicationLogger</name><environment>COAST</environment><super>COAST.CatCSApplicationLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-COClusterManagement</category><attributes><package>COClusterManagement</package></attributes></class><class><name>CoastSetSegment</name><environment>COAST</environment><super>COAST.CoastAbstractSetSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatBFSegmentedFreeBlockList</name><environment>COAST</environment><super>COAST.CatBFSegmentedFile</super><private>false</private><indexed-type>none</indexed-type><inst-vars>freeBlockSegments freeMap obsoleteStartBlocks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastJournalSet</name><environment>COAST</environment><super>COAST.CoastJournalCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatBFSegmentedDirectory</name><environment>COAST</environment><super>COAST.CatBFSegmentedFile</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filesDictionarySegments specialFilesSegment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastKeyDictionarySegment</name><environment>COAST</environment><super>COAST.CoastDictionarySegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatBFReadStream</name><environment>COAST</environment><super>COAST.CatBFStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastValueIndexSegment</name><environment>COAST</environment><super>COAST.CoastIndexSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatBFBadBlockError</name><environment>COAST</environment><super>COAST.CatBFError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastMixedSetSegment</name><environment>COAST</environment><super>COAST.CoastAbstractSetSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>FreeMapRoot</name><environment>COAST</environment><super>COAST.FreeMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node leavesBySize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBase</category><attributes><package>COBlockFileSystem</package></attributes></class><comment><class-id>COAST.FreeMapRoot</class-id><body>FreeMapRootInstance Variables:	leafesBySize	MultiValueDictionary to acess a leaf for a given interval length	node	FreeMapNonRoot or nil to hold the ranges</body></comment><class><name>CoastJournalValueIndex</name><environment>COAST</environment><super>COAST.CoastJournalIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatBFSpecialFilesSegment</name><environment>COAST</environment><super>COAST.CatBFDirectorySegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastSegmentedSet</name><environment>COAST</environment><super>COAST.CoastAbstractSegmentedSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastSegmentedKeyIndex</name><environment>COAST</environment><super>COAST.CoastSegmentedIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatBFBackgroundCopyError</name><environment>COAST</environment><super>COAST.CatBFError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastBagSegment</name><environment>COAST</environment><super>COAST.CoastSetSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastSegmentedValueIndex</name><environment>COAST</environment><super>COAST.CoastSegmentedIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CoastJournalDictionary</name><environment>COAST</environment><super>COAST.CoastJournalSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatBFWriteStream</name><environment>COAST</environment><super>COAST.CatBFStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>preAllocatedBlocks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastJournalKeyIndex</name><environment>COAST</environment><super>COAST.CoastJournalIndex</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatBFAbortBackgroundCopySignal</name><environment>COAST</environment><super>COAST.CatBFError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastSegmentedMixedSet</name><environment>COAST</environment><super>COAST.CoastAbstractSegmentedSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COFramesystem</package></attributes></class><class><name>CatBFLockMaintenanceError</name><environment>COAST</environment><super>COAST.CatBFLockError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastSegmentedDictionary</name><environment>COAST</environment><super>COAST.CoastSegmentedSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>ReadOnlyBlockFileSystem</name><environment>COAST</environment><super>COAST.CatBFBlockFileSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastSegmentedBag</name><environment>COAST</environment><super>COAST.CoastSegmentedSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatBFLockInfoError</name><environment>COAST</environment><super>COAST.CatBFLockError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COBlockFileSystem</category><attributes><package>COBlockFileSystem</package></attributes></class><class><name>CoastJournalKeyDictionary</name><environment>COAST</environment><super>COAST.CoastJournalDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatRMApplicationLogMessage</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applicationLog volume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastSegmentedKeyDictionary</name><environment>COAST</environment><super>COAST.CoastSegmentedDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSFramesystem</category><attributes><package>COFramesystem</package></attributes></class><class><name>CatCSSequence</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enableEndBlocks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSSequenceTransaction</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>waitingProcesses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>TransactionPartitionsPolicy</name><environment>COAST</environment><super>COAST.TransactionPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>partitionSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSLastWishTransaction</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>SingleTransactionPolicy</name><environment>COAST</environment><super>COAST.TransactionPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>OutOfSequence</name><environment>COAST</environment><super>COAST.TransactionFailReason</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wrongBaseNumber expectedBaseNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSVolatileTransaction</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>OuterTransactionPolicy</name><environment>COAST</environment><super>COAST.TransactionPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>MultipleTransactionsPolicy</name><environment>COAST</environment><super>COAST.TransactionPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><class><name>CoastTransactionNestingError</name><environment>COAST</environment><super>COAST.CoastTransactionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSPessimisticTransaction</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-CSTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatDMDisplayTransaction</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastSequenceWithinTransactionError</name><environment>COAST</environment><super>COAST.CoastTransactionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CoastFullTransactionWithinSequenceError</name><environment>COAST</environment><super>COAST.CoastTransactionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMTryAndTell</name><environment>COAST</environment><super>COAST.CatRMMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loggedTransactionAgendas applicationLog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMMessages</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMSkippingAgendaChecker</name><environment>COAST</environment><super>COAST.CatRMAbstractAgendaChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>CatCSSmallTransaction</name><environment>COAST</environment><super>COAST.CatCSTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COTransactions</category><attributes><package>COTransactions</package></attributes></class><class><name>CatRMAgendaChecker</name><environment>COAST</environment><super>COAST.CatRMAbstractAgendaChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTCore-RMReplicationBase</category><attributes><package>COTransactions</package></attributes></class><class><name>BestSingleTransactionPolicy</name><environment>COAST</environment><super>COAST.TransactionPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>COTransactions</package></attributes></class><shared-variable><name>BigSwapArray</name><environment>Core.Character</environment><private>false</private><constant>false</constant><category>COAST</category><initializer>Character bigSwapArray</initializer><attributes><package>COBase</package></attributes></shared-variable><shared-variable><name>CoBasePartsTableSize</name><environment>Core.Character</environment><private>false</private><constant>false</constant><category>COAST</category><initializer>1024</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>CoBasePartsTable</name><environment>Core.Character</environment><private>false</private><constant>false</constant><category>COAST</category><initializer>nil</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>CoastSkipHaltOrContinue</name><environment>Core.Object</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>false</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>DownloadTargets</name><environment>COAST.CatRMFileDownloadTarget</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COMessages</package></attributes></shared-variable><shared-variable><name>TargetKeyCounter</name><environment>COAST.CatRMFileDownloadTarget</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COMessages</package></attributes></shared-variable><shared-variable><name>LogLevelFatalError</name><environment>COAST</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>40</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>LogEntries</name><environment>COAST</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COTransactions</package></attributes></shared-variable><shared-variable><name>AgendaChecker</name><environment>COAST</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>CatRMAgendaChecker new</initializer><attributes><package>COTransactions</package></attributes></shared-variable><shared-variable><name>LogLevelDebug</name><environment>COAST</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>3</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>LogLevelNormal</name><environment>COAST</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>10</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>COBinaryExternalDictionary</name><environment>COAST</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>COMarshalling</package></attributes></shared-variable><shared-variable><name>LogLevelDebugCoast</name><environment>COAST</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>0</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>LogLevelWarning</name><environment>COAST</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>20</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>LogLevelDebugNotify</name><environment>COAST</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>5</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>LogLevelError</name><environment>COAST</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>30</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>LogLevelAll</name><environment>COAST</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>SmallInteger maxVal</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>LastLogCount</name><environment>COAST.MemoryBasedUnloadStrategy</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>0</initializer><attributes><package>COClusterManagement</package></attributes></shared-variable><shared-variable><name>LastLog</name><environment>COAST.MemoryBasedUnloadStrategy</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COClusterManagement</package></attributes></shared-variable><shared-variable><name>ObserverSlotNames</name><environment>COAST.CatFSFrame</environment><private>false</private><constant>false</constant><category>shared observers</category><initializer>Core.Dictionary new</initializer><attributes><package>COFramesystem</package></attributes></shared-variable><shared-variable><name>RecordClustersReferencedByAccessTime</name><environment>COAST.CatCSAgenda</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>0</initializer><attributes><package>COTransactions</package></attributes></shared-variable><shared-variable><name>MaxInvalidationCycles</name><environment>COAST.CatFSVirtualSlot</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COFramesystem</package></attributes></shared-variable><shared-variable><name>PrimitiveClasses</name><environment>COAST.CatMAMarshallBinary</environment><private>false</private><constant>false</constant><category>primitive classes</category><attributes><package>COMarshalling</package></attributes></shared-variable><shared-variable><name>EnableRangeDemon</name><environment>COAST.CatFSSlot</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COFramesystem</package></attributes></shared-variable><shared-variable><name>DemonsEnabled</name><environment>COAST.CatCSEndCell</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>COBase</package></attributes></shared-variable><shared-variable><name>RandomStream</name><environment>COAST.CatCSCell</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>CatCSCell initializeRandomStream</initializer><attributes><package>COBase</package></attributes></shared-variable><shared-variable><name>CoastNoDelay</name><environment>OS.SocketAccessor</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>SocketAccessor coastDefaultNoDelay</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>CoastStreamBufferSize</name><environment>OS.SocketAccessor</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>CoastWindowSize</name><environment>OS.SocketAccessor</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>SocketAccessor coastDefaultWindowSize</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>CommandLineOverride</name><environment>COAST.CoastApplicationConfiguration</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COBase</package></attributes></shared-variable><shared-variable><name>Current</name><environment>COAST.CoastApplicationConfiguration</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COBase</package></attributes></shared-variable><shared-variable><name>LowSpaceHandler</name><environment>COAST.CoastMemoryPolicy</environment><private>false</private><constant>false</constant><category>accessing</category><initializer></initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>DefaultStorageClass</name><environment>COAST.CatCSVolumeManager</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COClusterManagement</package></attributes></shared-variable><shared-variable><name>ClientID</name><environment>COAST.CoastLog</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>COUtilities</package></attributes></shared-variable><shared-variable><name>Spices</name><environment>COAST.CatCSAbstractFileApplicationLogger</environment><private>false</private><constant>false</constant><category>crypto</category><initializer>#( #[])</initializer><attributes><package>COClusterManagement</package></attributes></shared-variable><methods><class-id>COAST.CatFSFrame class</class-id> <category>accessing</category><body package="COFramesystem">oldClassPragmaDefinition	"use #coastFormerName: Pragma to remap shared Frames of renamed classes"	&lt;pragmas: #class&gt;	^#(coastFormerName:)</body></methods><methods><class-id>COAST.CatMAMarshallBinary class</class-id> <category>primitive classes</category><body package="COMarshalling">initializePrimitivesArray	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #usesTrue&gt;		| unsortedPrimitives max |	unsortedPrimitives := ( Set new )			add: UndefinedObject;			add: False;			add: True;			add: SmallInteger;			add: CoastOneByteInteger;			add: CoastTwoByteInteger;			add: CoastThreeByteInteger;			add: ISO8859L1String;			add: ByteArray;			add: Float;			add: Double;			add: Point;			add: Timestamp;			add: ColorValue;			add: ByteString;			add: Symbol;			add: LargePositiveInteger;			add: LargeNegativeInteger;			add: TwoByteString;			add: TwoByteSymbol;			add: CatMASingleRepeatedObject;			add: CatMAShortRepeatedObject;			add: CatMALongRepeatedObject;			add: HuffmanByteString;			add: HuffmanISOString;			add: HuffmanSymbol;			yourself.	max := 0.	" detect the largest ID "	unsortedPrimitives do: [: aClass | max := max max: aClass marshallID ].	" tum de dum.... the smallest ID is zero so must add 1 "	PrimitiveClasses := Array new: max + 1.	" store the primitive classes in an array at their marshall ID "	unsortedPrimitives do: 		[: aClass | ( PrimitiveClasses at: aClass marshallID + 1 ) notNil ifTrue: [ self halt: 'wrong marshall IDs' ].			PrimitiveClasses at: aClass marshallID + 1 put: aClass		].	^ PrimitiveClasses</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>setup</category><body package="COUtilities">transcriptFilename: aStringOrNil 	" sets the transcript filename. 	!!! Does not redirect the transcript to the file, use setupTranscript !!! "	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #referenceNonPrerequisiteClass&gt;	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #undefinedLiteralBindings&gt;	aStringOrNil notNil 		ifTrue: 		[	fileName := aStringOrNil asString.			fileName asFilename directory ensureFullDirectory.			#{Smalltalk.RuntimePackager.RuntimeManager} ifDefinedDo: [ : rtm | rtm errorLogPath: aStringOrNil ]		]		ifFalse: [ fileName := nil ].	Notifier headlessDo: [: headlessImage | headlessImage transcriptFilename: aStringOrNil ].</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>private</category><body package="COUtilities">defaultLogException: exception message: message level: level 	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #referenceNonPrerequisiteClass&gt;		self haltOnExceptions 		ifTrue: [ self haltOrContinue: message, ' - ', exception description ].	self 		logLevel: level		show: 		[ | messageStream context |			messageStream := String new writeStream.			context := self exceptionFirstContextOutsideLog.			messageStream				nextPutAll: message; cr;				nextPutAll: '--- ' , Timestamp now coastShortPrintString , ' ---'; cr;				nextPutAll: 'Exception:'; cr;				nextPutAll: exception description; cr;				nextPutAll: 'Call stack:'; cr.			context printStackFrom: 1 to: self exceptionLogSize on: messageStream.			messageStream cr;				cr.			#{COAST.CatCSClusterManager} ifDefinedDo: [: cm | cm addDumpInfoTo: messageStream ].			#{COAST.CatFSUniversalFrame} ifDefinedDo: [: uFrame | uFrame addDumpInfoTo: messageStream ].			ObjectMemory currentMemoryPolicy addDumpInfoTo: messageStream.			#{COAST.CoastVersion} ifDefinedDo: 				[: ver |					messageStream						tab; nextPutAll: 'build: '; nextPutAll: ver buildString; cr				].			messageStream nextPutAll: 'Parcel info:'; cr.			Parcel coastParcelVersionStringsDo: [: sortedStr | messageStream tab; nextPutAll: sortedStr; cr ].			messageStream cr;				nextPutAll: '--------------------------------------'; cr.			messageStream contents		].</body><body package="COUtilities">infoDict	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #referenceNonPrerequisiteClass&gt;		| current |	current := nil.	#{CoastApplicationConfiguration} ifDefinedDo: [: cac | current := cac current ].	^ current notNil 		ifTrue: [ current infoDict ]		ifFalse: [ Dictionary new ]</body></methods><methods><class-id>COAST.CoastExitCode class</class-id> <category>exit codes</category><body package="COBase">applicationFailure	&lt;errorCodeName: 'application failure' description: 'controlled error in an application'&gt;		^ 16r0011</body><body package="COBase">badParameter	&lt;errorCodeName: 'bad parameter' description: 'missing or invalid command line parameter on startup'&gt;		^ 16r0012</body><body package="COBase">badVersion	&lt;errorCodeName: 'bad version' description: 'Coast version of server or volume does not match client version'&gt;		^ 16r0016</body><body package="COBase">connectionLost	&lt;errorCodeName: 'connection lost' description: 'connection to mediator lost'&gt;		^ 16r0014</body><body package="COBase">lowMemory	&lt;errorCodeName: 'low memory' description: 'low memory detected'&gt;		^ 16r0017</body><body package="COBase">noError	"common sense 0 == OK"	&lt;errorCodeName: 'no error' description: 'everything is fine'&gt;		^ 16r0000</body><body package="COBase">nonCoastError	"do not call from Coast or K-Infinity code. Value 16r10 reserved for non-coast-packages"	&lt;errorCodeName: 'non coast error' description: 'error specific to image core components'&gt;		^ 16r0010</body><body package="COBase">operationFailed	&lt;errorCodeName: 'operation failed' description: 'operation failed'&gt;		^ 16r0013</body><body package="COBase">scheduledShutdown	&lt;errorCodeName: 'scheduled shutdown' description: 'the service has received and successfuly performed a shut down'&gt;		" !!! war frÃ¼her 1, soll nach wie vor 1 sein !!!  " 	^ 16r0001</body><body package="COBase">unhandledException	&lt;errorCodeName: 'unhandled exception' description: 'an unexpected error occured - check log file'&gt;		^ 16r0015</body><body package="COBase">warnings	&lt;errorCodeName: 'warnings' description: 'the application reported warnings - check log file'&gt;		^ 16r0018</body></methods><methods><class-id>COAST.CoastExitCode class</class-id> <category>pragma</category><body package="COBase">errorPragmas	&lt;pragmas: #class&gt;		^ #( #errorCodeName:description: )</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>config</category><body package="COBase">configureTimezone	&lt;configuration&gt;		| timezone |	timezone := iniAccess numberAt: 'timezone' ifAbsent: [ ^ self ].	TimeZone coastSetTimeZone: timezone.</body><body package="COBase">configureVolumeAccessorClass	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #referenceNonPrerequisiteClass&gt;		| accessorClassName accessorClass |	accessorClassName := self iniAccess stringAt: 'volumeAccessor' ifAbsent: [ nil ].	accessorClassName isNil ifTrue: [ ^ self ].	accessorClass := ( StrictBindingReference simpleName: accessorClassName in: COAST ) valueOrDo: [ nil ].	accessorClass isNil ifTrue: [ ^ self ].	( accessorClass includesBehavior: CatCSVolumeStorageAccessor ) ifFalse: [ ^ self error: 'Class ' , accessorClass fullName , ' is not a volume accessor class' ].	accessorClass isAbstract ifTrue: [ ^ self error: 'Volume accessor ' , accessorClass fullName , ' is abstract' ].	CatCSVolumeManager defaultStorageClass: accessorClass.	CoastLog log: 'Using storage accessor ' , accessorClass fullName.</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>private - command line</category><body package="COBase">parseDebug: stream	&lt;	commandlineParameter: #debug		canPerform: nil		aliases: nil		usage: 'debug'		help: 'activate debug messages in the log file'		&gt;	CoastLog singleton isDebug: true.</body><body package="COBase">parseIniFile: stream	&lt;	commandlineParameter: #inifile		canPerform: nil		aliases: #(ini)		usage: 'inifile {file name}'		help: 'read configuration from ini file named {file name}'		&gt;	| filename |	filename := stream next.	filename isNil ifTrue: [ self errorInCommandLine: 'Ini file not specified'. ].	filename asFilename definitelyExists ifFalse: [ self errorInCommandLine: 'Ini file "', filename, '" does not exist'. ].	self iniFilename: filename.</body><body package="COBase">parseLogFile: stream	&lt;	commandlineParameter: #logfile		canPerform: nil		aliases: #(log)		usage: 'logfile {file name}'		help: 'write log messages to the file named {file name}'		&gt;	logFilename := stream next ifNil: [ self errorInCommandLine: 'Log file not specified' ].	[ logFilename asFilename ] on: Error do: [ self errorInCommandLine: 'Illegal log file name'. ].</body><body package="COBase">parseLogLevel: stream	&lt;	commandlineParameter: #loglevel		canPerform: nil		aliases:nil		usage: 'loglevel {number}'		help: 'set the logging level to {number}'		&gt;	| level |	level := stream next ifNotNil: [ : s | s asInteger ] ifNil: [ self errorInCommandLine: 'log level not specified' ].	CoastLog singleton logLevel: level.</body><body package="COBase">parseNoLog: stream	&lt;	commandlineParameter: #nolog		canPerform: nil		aliases: nil		usage: 'nolog'		help: 'turn off logging to the log file'		&gt;	logFilename := nil.</body><body package="COBase">parseParcelVersions: stream 	&lt;	commandlineParameter: #parcelVersions		canPerform: nil		aliases: nil		usage: 'parcelVersions'		help: 'print all parcel (software component) versions to the log file or console'		&gt;		| outStream |	outStream := String new writeStream.	Parcel coastParcelVersionStringsDo: [ : sortedStr | outStream nextPutAll: sortedStr; cr ].	self class showText: outStream contents.	Notifier isDevelopment ifFalse: [ ObjectMemory quit. ].</body><body package="COBase">parseRaiseError: stream	&lt;	commandlineParameter: #raiseError		canPerform: nil		aliases: nil		usage: 'raiseError {seconds}'		help: 'raise an error after {seconds}; development only'		&gt;	| seconds |	seconds := stream next ifNotNil: [ : s | s asInteger ] ifNil: [ 0 ].	[	(Delay forSeconds: seconds) wait.		 Error raiseSignal: '~~~ Automatic error raising ~~~'.	] forkAt: Processor activeProcess priority + 1.</body><body package="COBase">parseShowBuildID: stream 	&lt;	commandlineParameter: #showBuildID		canPerform: nil		aliases: nil		usage: 'showBuildID'		help: 'print app description, build number and public key to the log file or console'		&gt;	| outStream |	outStream := String new writeStream.	CoastVersion printImageIdOn: outStream.	outStream cr.	self class showText: outStream contents.	Notifier isDevelopment ifFalse: [ ObjectMemory quit. ].</body><body package="COBase">parseSupervisorPort: stream 	&lt;	commandlineParameter: #supervisorPort		canPerform: nil		aliases: nil		usage: 'supervisorPort {port number}'		help: 'starts the application in supervised mode at port {port number}'		&gt;	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #referenceNonPrerequisiteClass&gt;	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #undefinedLiteralBindings&gt;	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #sentNotImplemented&gt;		| port subordinate initialCommand |	port := stream next ifNotNil: [: s | s asInteger ] ifNil: [ self errorInCommandLine: 'Supervisor port not specified' ].	self addPreConfigurationBlock: 		[: application |						[	CoastLog log: 'supervision requested'.				subordinate := SupervisedSubordinate supervisorPort: port.				initialCommand := subordinate nextCommand.				initialCommand commandSymbol = #ini 					ifTrue: 					[	iniAccess := initialCommand iniFileArgument.						CoastLog log: 'configuration received'					]					ifFalse: [ CoastLog log: initialCommand ].				subordinate coastApplication: application.				CoastLog log: 'supervised mode activated'			] on: Error do: [: ex | CoastLog logException: ex message: 'initialization of supervised mode failed' ]		].</body><body package="COBase">parseTimezone: stream	&lt;	commandlineParameter: #timezone		canPerform: nil		aliases: nil		usage: 'timezone {hour offset}'		help: 'use a timezone offset by {hour offset} hours from UTC'		&gt;	| timezone |	timezone := stream next ifNotNil: [: s | Number readFrom: s readStream ] ifNil: [ self errorInCommandLine: 'Timezone not specified' ].	TimeZone coastSetTimeZone: timezone.</body><body package="COBase">parseVersion: stream 	&lt;	commandlineParameter: #version		canPerform: nil		aliases: nil		usage: 'version [&lt;infoType&gt;]'		help: 'Prints the version of this image. Default infoType is "full"'		&gt;		| infoType out availableInfoTypes |	availableInfoTypes := Dictionary new.	( Pragma allNamed: #versionInfo: from: self class to: CoastApplicationConfiguration ) 		do: [: pragma | availableInfoTypes at: ( pragma argumentAt: 1 ) put: pragma selector ].	infoType := stream peek ifNotNil: [: v | v asSymbol ] ifNil: [ #full ].	out := String new writeStream.	infoType = #full 		ifTrue: 		[	availableInfoTypes keys asSortedCollection 				do: 				[: key |					out nextPutAll: key; nextPutAll: '='.					self perform: ( availableInfoTypes at: key ) with: out				]				separatedBy: [ out nextPutAll: '; ' ]		]		ifFalse: 		[( availableInfoTypes at: infoType ifAbsent: [ nil ]) 				ifNotNil: [: selector | self perform: selector with: out ]				ifNil: [ out nextPutAll: 'Unknown version info type: ' , infoType ]		].	self class showText: out contents.	Notifier isDevelopment 		ifFalse: [ ObjectMemory quit ].</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>private - version</category><body package="COBase">versionInfoBuildOn: aStream 	&lt;versionInfo: #build&gt;		aStream nextPutAll: ( CoastVersion deploymentVersionBuildString ifNil: [ '-' ]).</body><body package="COBase">versionInfoCoastOn: aStream 	&lt;versionInfo: #coast&gt;		CoastVersion defaultCoastVersion printOn: aStream.</body><body package="COBase">versionInfoImageOn: aStream 	&lt;versionInfo: #image&gt;		aStream nextPutAll: CoastVersion imageVersionString.</body><body package="COBase">versionInfoVMOn: aStream 	&lt;versionInfo: #vm&gt;		aStream nextPutAll: CoastVersion vmVersionString</body></methods><methods><class-id>COAST.CoastApplicationConfiguration class</class-id> <category>pragma handling</category><body package="COBase">commandlineParameterPragmas	&lt;pragmas: #instance&gt;	^ #(commandlineParameter:canPerform:aliases:usage:help:)</body><body package="COBase">configurationPragmas	&lt;pragmas: #instance&gt;	^ #(		configuration		transactionManagerConfiguration		applicationConfiguration		pluginConfiguration		pluginTransactionManagerConfiguration		pluginApplicationConfiguration	)</body><body package="COBase">versionPragmas	&lt;pragmas: #instance&gt;	^ #(		versionInfo:	)</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>mediator services</category><body package="COBase">backupVolumeID	&lt;request&gt;	^12</body><body package="COBase">blobOrClusterSize	&lt;request&gt;	^ 24</body><body package="COBase">blockUntilBackupIsDone	&lt;request&gt;	^ 27</body><body package="COBase">buildInfoID	&lt;request&gt;	^ 32</body><body package="COBase">changeRemotePasswordID	&lt;request&gt;	^ 30</body><body package="COBase">clientConnection	&lt;request&gt;	^33</body><body package="COBase">clientReConnection	&lt;request&gt;	^ 34</body><body package="COBase">compressVolumeID	&lt;request&gt;	^ 28</body><body package="COBase">copyVolumeID	&lt;request&gt;	^13</body><body package="COBase">createVolumeID	&lt;request&gt;	^ 31</body><body package="COBase">deleteBackupVolumeID	&lt;request&gt;	^20</body><body package="COBase">deleteVolumeID	&lt;request&gt;	^14</body><body package="COBase">downloadLogID	&lt;request&gt;	^22</body><body package="COBase">downloadVolumeID	&lt;request&gt;	^18</body><body package="COBase">evaluateID	&lt;request&gt;	^ 9</body><body package="COBase">getFrameClassIndex	&lt;request&gt;	^ 29</body><body package="COBase">listConnections	&lt;request&gt;	^ 26</body><body package="COBase">pauseGCID	&lt;request&gt;	^10</body><body package="COBase">recoverToVolumeID	&lt;request&gt;	^17</body><body package="COBase">recoverableVolumes	&lt;request&gt;	^16</body><body package="COBase">replaceVolumeID	&lt;request&gt;	^21</body><body package="COBase">shutDownMediator	&lt;request&gt;	^1</body><body package="COBase">startGCID	&lt;request&gt;	^7</body><body package="COBase">statusGCID	&lt;request&gt;	^23</body><body package="COBase">stopGCID	&lt;request&gt;	^8</body><body package="COBase">synchTime	&lt;request&gt;	^3</body><body package="COBase">uploadVolumeID	&lt;request&gt;	^19</body><body package="COBase">version	&lt;request&gt;	^6</body><body package="COBase">volumeExists	&lt;request&gt;	^36</body><body package="COBase">volumes	&lt;request&gt;	^11</body><body package="COBase">volumesPasswordProtected	&lt;request&gt;	" replaces #volumes "	^35</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>private</category><body package="COBase">requestIDPragma	&lt;pragmas: #class&gt;	^ #(request)</body></methods><methods><class-id>COAST.CoastApplication</class-id> <category>initialize-release</category><body package="COBase">initializeCoast	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #referenceNonPrerequisiteClass&gt;		CatCSCellAccess initializeAccesses.	CatCSCluster initializeRandomStream.	CatMAMarshallBinary flushPrimitivesArray.</body></methods><methods><class-id>COAST.CoastApplication</class-id> <category>parameters - command line</category><body package="COBase">parseAvailableChannels: argumentStream	&lt;	commandlineParameter: #availableChannels		canPerform: nil		aliases: nil		usage: 'availableChannels'		help: 'show all available channels'		&gt;	| string |	string := CoastLog searchFilterChannelsCountString.		Notifier isDevelopment ifTrue: [ ^ Transcript show: string ].	CoastApplicationConfiguration showText: string.	self shutDownAndQuit.</body><body package="COBase">parseDeInstallService: stream	&lt;	commandlineParameter: #deinstallService		canPerform: #canBeService		aliases: nil		usage: 'deinstallService {service name}'		help: 'deinstall this application as a Windows service named {service name}'		&gt;	| oldServiceName |	oldServiceName := stream next ifNil: [ self errorInCommandLine: 'Service name not specified' ].	self configuration deinstallService: oldServiceName.	Notifier isDevelopment ifFalse: [ ObjectMemory quit. ].</body><body package="COBase">parseHelp: argumentStream	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #referenceNonPrerequisiteClass&gt;	&lt;	commandlineParameter: #help		canPerform: nil		aliases: #(#'?')		usage: 'help'		help: 'show this help message for all options'		&gt;		"Dieser Parameter ist allegemein und gehÃ¶rt eigentlich an die CoastApplicationConfiguration,	allerdings kennt diese nicht die CoastAppliction und es werden die Parameter von beiden	benÃ¶tigt."	self showUsage.	Notifier isDevelopment ifFalse: [ ObjectMemory quit. ].</body><body package="COBase">parseInstallAsService: stream 	" service name "	&lt;commandlineParameter: #installAsService		canPerform: #canBeService		aliases: nil		usage: 'installAsService {service name} {prerequisite services}*'		help: 'install this application as a Windows service with the specified {service name} and define optional {prerequisite services}'		&gt;		| commandLine serviceCommandStream servicePrerequisistesString servicePrerequisistes newServiceName serviceCommandLine imageName service |	newServiceName := stream next ifNil: [ self errorInCommandLine: 'Service name not specified' ].	(( newServiceName includes: $: ) or: [ newServiceName includes: $\ ]) 		ifTrue: [ self errorInCommandLine: 'Service name ' , newServiceName printString , ' may not contain special characters (":", "\")' ].	" prerequisites "	servicePrerequisistes := Set new.	[	stream atEnd not and: 			[( servicePrerequisistesString := stream peek ) notEmpty 					and: [( '-*' match: servicePrerequisistesString ) not and: [( '/*' match: servicePrerequisistesString ) not ]]			]	] whileTrue: 		[	servicePrerequisistes add: servicePrerequisistesString trimBlanks.			stream skip: 1		].	service := CoastWinService serviceName: newServiceName.	" construct service command line "	serviceCommandStream := String new writeStream.	" check if &lt;vm&gt; &lt;image&gt; or &lt;exe&gt;"	(( imageName := CEnvironment commandLine at: 2 ) endsWith: '.im' ) 		ifTrue: 		[	serviceCommandStream space.			service printCommandPart: imageName asFilename asAbsoluteFilename asString on: serviceCommandStream		].	" -serviceName starts the application "	serviceCommandStream nextPutAll: ' -serviceName '.	service printCommandPart: newServiceName on: serviceCommandStream.	" additional parameters "	commandLine := stream upToEnd asOrderedCollection.	commandLine do: 		[: token |			serviceCommandStream space.			service printCommandPart: token on: serviceCommandStream		].	serviceCommandLine := serviceCommandStream contents.	" install "	[	service 			installServiceWithParameters: serviceCommandLine			executable: ( CoastWinService serviceName: newServiceName ) pathToExecutable			prerequisistes: servicePrerequisistes			autoStart: true			startNow: false.		CoastWinService serviceName: newServiceName.		Notifier isDevelopment 			ifFalse: [ ObjectMemory quit ]	] 		on: WinServiceError		do: 		[: ex |			CoastLog logWarning: ex description.			Notifier isDevelopment 				ifFalse: [ ObjectMemory quitWithError: 1 ]		].</body><body package="COBase">parseServiceName: stream	&lt;	commandlineParameter: #serviceName		canPerform: #canBeService		aliases: nil		usage: 'serviceName {service name}'		help: 'start as Windows service with name {service name}; only used by installed services'		&gt;	| serviceName serviceDir |	serviceName := stream next ifNil: [ self errorInCommandLine: 'Service name not specified' ].	self configuration serviceName: serviceName.	" this is VERY important. the default directory for services is system32"	serviceDir := CEnvironment commandLine first asFilename directory.	serviceDir beCurrentDirectory.	"set start action"	self startAction: [ self startUpAsService ].</body></methods><methods><class-id>COAST.CoastApplication class</class-id> <category>pragma handling</category><body package="COBase">commandlineParameterPragmas	&lt;pragmas: #instance&gt;	^ #(commandlineParameter:canPerform:aliases:usage:help:)</body></methods><methods><class-id>COAST.CoastStatusResponse</class-id> <category>marshalling</category><body package="COBase">unmarshallBinaryFrom: aStream 	&lt;lintFilterRuleNamed: #usesTrue&gt;	self ok: (aStream next = True marshallID).	self code: aStream nextCoastString asSymbol.	self message: aStream nextCoastString.</body></methods><methods><class-id>COAST.SupervisionMessage class</class-id> <category>marshaling</category><body package="COBase">unmarshalPrimitiveFrom: aStream	&lt;lintFilterRuleNamed: #returnsBooleanAndOther&gt;	&lt;lintFilterRuleNamed: #usesTrue&gt;	| marshalID |	marshalID := aStream next.	ByteArray marshallID = marshalID ifTrue: [ ^ByteArray supervisorUnmarshalPrimitiveFrom: aStream ].	ByteString marshallID = marshalID ifTrue: [ ^ByteString supervisorUnmarshalPrimitiveFrom: aStream  ].	ByteSymbol marshallID = marshalID ifTrue: [ ^(ByteString supervisorUnmarshalPrimitiveFrom: aStream) asSymbol  ].	True marshallID = marshalID ifTrue: [ ^true ].	False marshallID = marshalID ifTrue: [ ^false ].	UndefinedObject marshallID = marshalID ifTrue: [ ^nil ].	CoastError raiseSignal: 'supervisor marshaling failed: unknow primitive number ', marshalID printString.	^nil</body></methods><methods><class-id>COAST.CoastVersion class</class-id> <category>utils</category><body package="COBase">deploymentCoastVersion	&lt;deploymentComponent: 'COAST'&gt;	^ self defaultCoastVersion displayString</body><body package="COBase">deploymentVersionBuildString	&lt;deploymentComponent: 'Build'&gt;	^buildString</body></methods><methods><class-id>COAST.CatCSAbstractCollection</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">collect: block as: collectionClass 	&lt;lintFilterRule: #'Refactory.Browser.ParseTreeLintRule' named: #usesAdd&gt;		| result |	result := collectionClass new: self size.	self do: [: elem | result add: ( block value: elem )].	^ result</body></methods><methods><class-id>COAST.CoastJournalSet</class-id> <category>private</category><body package="COFramesystem">cleanJournalDiffs	"remove added already included	remove removed not included yet"	&lt;lintFilterRule: #'Refactory.Browser.ParseTreeLintRule' named: #usesAdd&gt;		| added removed result |	added := self at: #added.	removed := self at: #removed.	result := Array with: added copy with: removed copy.	added do: [: v | ( self segmentedCollection includes: v ) ifTrue: [( result at: 1 ) remove: v ifAbsent: nil ]].	removed do: [: v | ( self segmentedCollection includes: v ) ifFalse: [( result at: 2 ) remove: v ifAbsent: nil]].	^ result</body></methods><methods><class-id>COAST.CoastJournalDictionary</class-id> <category>private</category><body package="COFramesystem">cleanJournalDiffs	"remove added already included	remove removed not included yet"	&lt;lintFilterRule: #'Refactory.Browser.ParseTreeLintRule' named: #usesAdd&gt;		| added removed addedCopy removedCopy |	added := self at: #added.	removed := self at: #removed.	addedCopy := added copy.	removedCopy := removed copy.	added keysAndValuesDo: 		[: k : v | | v2 |			v2 := self segmentedCollection atKey: k.			v2 = v 				ifTrue: [ addedCopy removeKey: k ]				ifFalse: [ v2 notNil ifTrue: [ removedCopy add: k ]]		].	removed do: [: k | ( self segmentedCollection includesKey: k ) ifFalse: [ removedCopy remove: k ifAbsent: nil ]].	^ Array with: addedCopy with: removedCopy</body></methods><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="COUtilities">haltOrContinue	&lt;lintFilterRule: #'Refactory.Browser.BlockLintRule' named: #sendsHalt&gt;	Notifier isDevelopment ifTrue: 		[	self coastSkipHaltOrContinue 				ifTrue: [ COAST.CoastLog logWarning: 'haltOrContinue in ' , thisContext sender printString ]				ifFalse: [ self halt ]		].</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="COUtilities">flushCoastLog	&lt;triggerAtSystemEvent: #aboutToQuit&gt;		(Notifier isDevelopment) 		ifFalse: 		[	[				COAST.CoastLog flushAndWait			] on: Error do: [: ex |			].		].</body></methods><methods><class-id>COAST.COBinaryExternal</class-id> <category>api</category><body package="COMarshalling">xorFold: byteArray limit: limit checksum: checksum 	&lt;C: _oop xorFold(_oop byteArray, int limit , _oop checksum)&gt;		^ self externalAccessFailedWith:  _errorCode</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures</category><body package="COUtilities">CopyFile: lpExistingFileName newFileName: lpNewFileName failIfExists: bFailIfExists	&lt;C: BOOL _threaded CopyFileW(		 LPCWSTR lpExistingFileName,	 	LPCWSTR lpNewFileName,		 BOOL bFailIfExists	)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="COUtilities">GetUserNameW: lpBuffer with: nSize	&lt;C: BOOL GetUserNameW(LPTSTR lpBuffer, DWORD * nSize)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="COUtilities">GlobalMemoryStatus: lpBuffer	&lt;C: BOOL GlobalMemoryStatusEx(		  struct MEMORYSTATUSEX* lpBuffer   // memory status structure	)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="COUtilities">MoveFileEx: lpExistingFileName with: lpNewFileName with: dwFlags	&lt;C: BOOL MoveFileExA(		LPCTSTR lpExistingFileName,		LPCTSTR lpNewFileName,		DWORD dwFlags	)&gt;	^self externalAccessFailedWith:_errorCode</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>procedures</category><body package="COUtilities">sysconf: name	&lt;C: long sysconf(int name)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>demons</category><body package="COBase">allDemonsDo: aBlock	" I have no demons, therefore there is nothing to do "</body><body package="COFramesystem">allResponsibleDemonsFor: anAccess	" I have no demons, therefore there is nothing to do "	^#()</body><body package="COBase">hasDemons	^ false</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>accessing - private</category><body package="COCellAccesses">accessCellValue	" returns the cell's value, using an official read access "	| vh |	vh := self resolvedValueHolder.	^ vh isNil 		ifTrue: [ nil ]		ifFalse: 		[	self isPrototype 				ifTrue: [ vh value ]				ifFalse: [ self valueAccess: ( CatCSValueReadAccess cell: self )]		]</body><body package="COCellAccesses">allowsNilValueAtKey	^ false</body><body package="COBase">basicValueAccess: aCatCSCellAccess	^self valueHolder access: aCatCSCellAccess.</body><body package="COBase">basicValueHolder	^ valueHolder</body><body package="COBase">basicValueHolderContent	" for compatiblity "	^ self resolvedCellValue</body><body package="COBase">coastID	self subclassResponsibility</body><body package="COBase">coastID: newCoastID	self subclassResponsibility</body><body package="COBase">invalidateObserversWithAccess: aCatCSCellAccess	" inform all observers that the cell was modified "	| t |	t := aCatCSCellAccess transaction.	( t notNil and: [ t invalidationSuppressed ] ) ifTrue: [^self ].	self minimalInvalidateObserversWithAccess: aCatCSCellAccess.</body><body package="COBase">resolvedValueHolder	^ self valueHolder</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>initialize-release</category><body package="COBase">breakReferences	container := nil.	self valueHolder: nil</body><body package="COBase">initializeAfterDeepCopy	"nothing necessary for general cells"</body><body package="COBase">initializePrototype	"nothing to do so far"</body><body package="COBase">initializeSpawned	self valueHolder: self prototype valueHolder class new.</body><body package="COBase">makeLocal	" nothing to do here "</body><body package="COBase">makeShared	" nothing to do here "</body><body package="COBase">release	self releaseObservers.	super release.</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>accessing</category><body package="COFramesystem">access: aCatCSCellAccess	aCatCSCellAccess cell: self.	^self valueAccess: aCatCSCellAccess</body><body package="COBase">accessForUpdate: aCatCSCellAccess	"this special access method is for updating only (internal usage).	Do not record stuff ! 	Nobody is interested in the result of the access!"	aCatCSCellAccess cell: self.	self valueHolder performUpdateAccess: aCatCSCellAccess.	self postAccess: aCatCSCellAccess.</body><body package="COBase">cellContainer	"the container this cell belongs to"	^container isCell ifTrue: [ container ] ifFalse: [ nil ]</body><body package="COBase">cellContainer: aCatCSContainerCell	"the container this cell belongs to"	container := aCatCSContainerCell</body><body package="COBase">cellValue	" By default, the value of the cell is stored in a value holder "	^self valueHolder value.</body><body package="COBase">cluster	"the cluster this cell belongs to, ask container for it"	^self cellContainer isNil ifTrue: [ nil ] ifFalse: [ container cluster ]</body><body package="COBase">clusterManager	"the cluster manager can be reached via the cluster"	"if a cell does not (yet) belong to a cluster, 	the *cluster* is the transaction manager that created the cell"	^self cellContainer isNil		ifTrue: [self isUnresolved				ifTrue: [container clusterManager]				ifFalse: [nil]]		ifFalse:[ | c |			c := self cluster.			c notNil				ifTrue: [c clusterManager]				ifFalse: [nil]]</body><body package="COTransactions">clusterManagerForBlockCache	^ self clusterManager</body><body package="COBase">coastHashOrNil	^ self coastID coastHashOrNil</body><body package="COBase">differencesToOldValue: oldValue 	^ self valueHolder differencesToOldValue: oldValue</body><body package="COFramesystem">frame	^(self cellContainer isNil) ifTrue: [ nil ] ifFalse: [ container frame ]</body><body package="COBase">hash	^ self coastID coastHashFor: self</body><body package="COBase">id	^ self coastID coastAsID</body><body package="COBase">id: newID	self subclassResponsibility</body><body package="COTransactions">idForMinimalInvalidation	" local ID for the minimal invalidation mechanism.	it is ok if two objects have the same idForMinimalInvalidation, will only result in too much invalidations "	^ self id</body><body package="COFramesystem">markAsEndcellPrototype	self valueHolder value markAsEndcellPrototypeValue.</body><body package="COBase">propagateNonWeakObserver	container notNil ifTrue: [ container propagateNonWeakObserver ]</body><body package="COBase">prototype	| p |	^ (p := self class prototypeNeeded) ~~ self		ifTrue: [ p ]		ifFalse: [ nil ]</body><body package="COBase">prototype: aCatCSCell	" ignored, for compatibility "</body><body package="COTransactions">referencedClusterIDs	"virtual frames can refer each other as subject of their computed slot	to avoid nasty (and fast growin;-) ) infinit loops, keep track of visited (local) frames"	^ self referencedClusterIDsSkip: Set new</body><body package="COTransactions">referencedClusterIDsSkip: skipFrames 	^ #( )</body><body package="COBase">resolveClusterIfNeeded	"nothing to do"</body><body package="COBase">resolvedCellValue	^self resolvedValueHolder value.</body><body package="COBase">resolvedCluster	^ self resolveClusterIfNeeded</body><body package="COTransactions">restoreOldValue: oldValue transaction: transaction	" for rollback: restore the old cell value "	self accessForUpdate: (oldValue accessClassForValueRestoring argument: oldValue).</body><body package="COTransactions">transactionManager	"the transaction manager can be usually reached via the cluster"	"if a cell does not (yet) belong to a cluster,	the *cluster* is the transaction manager that created the cell"	^ container isNil 		ifTrue: [ nil ]		ifFalse: [ container transactionManager ]</body><body package="COCellAccesses">unwrappedCell	^self</body><body package="COBase">valueHolder	^ self basicValueHolder</body><body package="COBase">valueHolder: aCatCSValueHolder	valueHolder := aCatCSValueHolder</body><body package="COBase">volume	^self isUnresolved		ifTrue: [container volume]		ifFalse: [ self cluster isNil ifTrue: [ nil ] ifFalse: [ self cluster volume ] ]</body><body package="COBase">volumeManager	"the volume manager can be reached via the cluster"	"if a cell does not (yet) belong to a cluster,	the *cluster* is the transaction manager that created the cell"	^container isNil		ifTrue: [ nil ]		ifFalse: [ container volumeManager ]</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>copying</category><body package="COCellAccesses">coastCopyWith: copyContext 	"copy the cell and the subcell structure"	^ copyContext copyOf: self deepCopyFinishBlock: [: copy | self copyValueHolderTo: copy with: copyContext ]</body><body package="COBase">coastSpawn	"i am a prototype and this methods creates a new instance with my appearance"	" don't forget to register the cell "	| transaction |	transaction := Processor activeTransaction.	^transaction isNil 		ifTrue: 			[self error: 'missing transaction in spawn'.			^self class basicNew]		ifFalse: [self spawnFor: transaction transactionManager]</body><body package="COBase">copy		"use deepCopy !"	self shouldNotImplement</body><body package="COBase">spawnFor: aTransactionManager	"i am a prototype and this methods creates a new instance with my appearance"	| newInst |	newInst := self class basicNew.	"the tm will be the temporary container until we find a better one"	newInst		cellContainer: aTransactionManager;		prototype: self;		initializeSpawned.	^ newInst</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>finalization</category><body package="COBase">executor		^nil</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>observer - subject</category><body package="COBase">addObserver: aCatCSVirtualCell	" Add a new Observer to the cell. The observer will be notified when	changes to the cell occur. This method does not establish a bidirectional	connection "	observers isNil ifTrue: [ self initializeObservers ].	observers add: aCatCSVirtualCell.</body><body package="COBase">addObserver: newObserver access: cellAccess	self addObserver: newObserver.	newObserver addSubject: self</body><body package="COBase">allObservedClusterIDs	^ #()</body><body package="COBase">buildUpDependenciesForTransaction: aTransaction access: accessOrNil 	"  build up a bidirectional dependency if a virtual cell is currently composed, "	| ccc |	aTransaction notNil ifTrue: 		[	ccc := aTransaction currentlyComposedCell.			( ccc notNil and: [ self isPrototype not and: [ (ccc subjectsIncludes: self) not ]]) ifTrue: 				[	self addObserver: ccc access: accessOrNil				]		]</body><body package="COBase">coastObserver	^ self</body><body package="COBase">coastSubject	^ self</body><body package="COBase">finishObservation	self flushObservers</body><body package="COBase">flushObservers	" removes all observers (removes this cell as subject first)  "	observers notNil ifTrue: 		[	self observers do: [ : o | o coastRemoveSubject: self ].			observers := nil.		]</body><body package="COBase">initializeObservers	observers := CoastWeakObservers new.	" note that CoastWeakSet may not implement some collection methods correctly that are not used here! "</body><body package="COBase">invalidateObservers	 self  invalidateObserversUsing: nil</body><body package="COBase">invalidateObserversDisresolved	" inform all observers that the cell was disresolved "	| oldObservers |	observers notNil		ifTrue: [ 			oldObservers := self observers.			observers := nil.			oldObservers do: [ : o | o coastInvalidateDisresolved ]. 		].</body><body package="COBase">invalidateObserversUsing: aCatCSCellAccess 	" inform all observers that the cell was modified "	| oldObservers |	observers notNil ifTrue: 		[	oldObservers := self observers.			observers := nil.			oldObservers do: [: o | o coastInvalidateWithAccess: aCatCSCellAccess ]		].</body><body package="COBase">minimalInvalidateObserversWithAccess: aCatCSCellAccess 	self invalidateObserversUsing: aCatCSCellAccess.</body><body package="COBase">observers	" CoastWeakSet of observers. "	^ observers</body><body package="COBase">releaseObservers	" removes all observers (removes this cell as subject first) . this method is	only called, when the observer-subject-mechanism is not used any longer "	observers notNil ifTrue: 		[	self observers do: [: o | o coastRemoveSubject: self ].			observers := nil		]</body><body package="COBase">removeObserver: aCatCSVirtualCell	observers notNil		ifTrue: [ observers remove: aCatCSVirtualCell ifAbsent:[]].</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>testing</category><body package="COFramesystem">allowsSlotModification	^ false</body><body package="COFramesystem">canFastRead	^true</body><body package="COFramesystem">canFastReadFullValue	"differs only for proxy&amp;delegating values 	-&gt; you cannot fast read parts but you should get the segmented frame for iteration"	^ self canFastRead</body><body package="COClusterManagement">hasNonWeakObservers	^ observers notNil and: [ observers anySatisfy: [ : obs | obs isWeakObserver not ]]</body><body package="COClusterManagement">hasObservers	^ observers notNil and: [ observers isEmpty not ]</body><body package="COBase">isCell	^true</body><body package="COFramesystem">isCluster	^ false</body><body package="COFramesystem">isLocal	^ false</body><body package="COBase">isPrototype	^self cellContainer isNil		ifTrue: [ self prototype isNil ]		ifFalse: [ container isPrototype ]</body><body package="COBase">isShared	^ self isLocal not</body><body package="COBase">isSlot	^ false</body><body package="COBase">isUnresolved	^ valueHolder isNil</body><body package="COBase">isVirtual	" true if this this cell computed. if true, isLocal must be true, too "	^false</body><body package="COClusterManagement">isWeakObserver	^ false</body><body package="COTransactions">needsCellValueCopyForRollbackIn: transaction 	^ true</body><body package="COTransactions">needsCellValueCopyForUnmanaged: transaction 	^ false</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>transactions</category><body package="COBase">sequenceDo: aBlock	^self transactionManager sequenceDo: aBlock</body><body package="COBase">transactionDo: aBlock	^self transactionManager transactionDo: aBlock</body><body package="COBase">transactionOrSequenceDo: aBlock	^self transactionManager transactionOrSequenceDo: aBlock</body><body package="COBase">transactionSequenceDo: aBlock	^self transactionManager transactionSequenceDo: aBlock</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>check</category><body package="COBase">coastTotalByteSize	" total size of the object and its substructure, including values, but not referenced first class COAST objects "	^ self coastObjectSize + observers coastReferencedObjectSize + valueHolder coastTotalByteSize</body><body package="COBase">numberOfAllObservers	^ observers size</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>garbage collection</category><body package="COBase">referencedFramesOrLocatorsCursorDo: aBlock 	"for use of garbage-collection only!!!"	self valueHolder notNil 		ifTrue: [ self valueHolder referencedFramesOrLocatorsCursorDo: aBlock ]</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>inspecting</category><body package="COBase">idPrintString	| stream |	stream := String new writeStream.	self idPrintStringOn: stream.	^ stream contents</body><body package="COBase">idPrintStringOn: stream 	self subclassResponsibility.</body><body package="COBase">printOn: aStream 	"the one-and-only basic printing method"	"works under all conditions - even if the object is damaged"	"is usable in debuggers, i.e. does not load any clusters"	^ self isPrototype 		ifTrue: 		[	aStream nextPutAll: 'prototype of '.			aStream nextPutAll: self classLabel		]		ifFalse: 		[	aStream nextPutAll: 'a '.			aStream nextPutAll: self classLabel.			aStream nextPutAll: ' '.			self idPrintStringOn: aStream		]</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>value accessing</category><body package="COBase">postAccess: aCatCSCellAccess 	aCatCSCellAccess isWriteAccess 		ifTrue: 		[	"Inform the dependents that our value has changed"			self invalidateObserversWithAccess: aCatCSCellAccess		]		ifFalse: 		[	"dependencies to the access - not the slot (which could be a prototype)"			aCatCSCellAccess buildUpDependencies		].</body><body package="COBase">rememberAccess: aCatCSCellAccess 	( aCatCSCellAccess isWriteAccess and: [ aCatCSCellAccess isAccessOnPrototype not ]) 		ifTrue: [ self transactionManager rememberAccessIfFirst: aCatCSCellAccess ].</body><body package="COBase">valueAccess: aCatCSCellAccess	| result vh |	vh := self resolvedValueHolder.	self rememberAccess: aCatCSCellAccess.	result := vh access: aCatCSCellAccess.	self postAccess: aCatCSCellAccess.	^ result</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>copying - private</category><body package="COBase">copyValueHolderTo: anotherCell with: copyContext 	"copy the contents of my value holder to anotherCell"	self accessCellValue.	"first do an official read access to the whole value holder"	"this is essential for correct concurrency control behaviour!!!"	self valueHolder isEmpty ifFalse: 		[( self valueHolder constructCopyParameters: copyContext ) do: 				[: access | | cellContainer probe |					cellContainer := anotherCell cellContainer.					( cellContainer isNil or: 						[	probe := cellContainer basicValueHolder at: anotherCell id.							probe isNil or: [ probe == anotherCell ]						]) 						ifTrue: [ anotherCell access: access ]						ifFalse: [ anotherCell basicValueHolder value: probe basicValueHolder value ]				]		]</body></methods><methods><class-id>COAST.CatCSCell</class-id> <category>marshalling</category><body package="COMarshalling">coastAsRemoteArgumentFor: aCluster	self error: 'Cannot marshal objects of class ', self class fullName.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	self error: 'for frames and slots only'.</body></methods><methods><class-id>COAST.CatCSCell class</class-id> <category>prototype accessing</category><body package="COBase">emptyPrototype	prototype := nil</body><body package="COBase">prototype	^prototype</body></methods><methods><class-id>COAST.CatCSCell class</class-id> <category>accessing</category><body package="COBase">generateNextID	"returns a number from 1 to SmallInteger maxVal"	^((RandomStream next) * 536870910 ) truncated + 1.</body><body package="COBase">initializeRandomStream	"CatCSClusterCell initializeRandomStream"	^RandomStream := Random new.</body></methods><methods><class-id>COAST.CatCSCell class</class-id> <category>instance creation</category><body package="COBase">new	^self halt: 'use other instance creation methods provided'.</body><body package="COBase">newClassPrototype	"create a new prototype cell for this class and store it in the protype class instance variable"	| cell |	cell := self basicNew.	prototype := cell.	cell id: self.	cell initializePrototype.	^cell</body><body package="COBase">newPrototype	"create a new prototype cell"	| cell |	cell := self basicNew.	cell makeLocal.	cell initializePrototype.	^cell</body></methods><methods><class-id>COAST.CatCSCell class</class-id> <category>marshalling</category><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	^ self new		unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall;		yourself.</body></methods><methods><class-id>COAST.CatCSContainerCell</class-id> <category>initialize-release</category><body package="COBase">breakReferences	self basicValueHolder notNil		ifTrue: [ self basicValueHolder coastInternalDo: [:e | e breakReferences]].	super breakReferences</body></methods><methods><class-id>COAST.CatCSContainerCell</class-id> <category>checks</category><body package="COBase">coastTotalByteSize	| sz |	sz := super coastTotalByteSize.	self basicValueHolder notNil		ifTrue: [			self basicValueHolderContent do: [ : cell |				sz := sz + cell coastTotalByteSize.			].		].	^ sz</body><body package="COBase">numberOfAllObservers	| i |	i := super numberOfAllObservers.	self basicValueHolder notNil		ifTrue: [			self basicValueHolderContent do: [ : cell |				i := i + cell numberOfAllObservers.			].		].	^ i</body></methods><methods><class-id>COAST.CatCSContainerCell</class-id> <category>accessing</category><body package="COBase">id: newID	| oldID |	oldID := self id.	(oldID ~= newID and: [ oldID isString or: [ oldID isSymbol ]])		ifTrue: [ self error: 'Cell already has an ID' ].	self coastID: (self coastID coastAsNewIDFrom: newID for: self)</body></methods><methods><class-id>COAST.CatCSContainerCell</class-id> <category>private</category><body package="COBase">coastID	^ coastID</body><body package="COBase">coastID: newCoastID	coastID := newCoastID</body><body package="COFramesystem">notifyFastRead: aFrame</body></methods><methods><class-id>COAST.CatCSContainerCell</class-id> <category>adding cells</category><body package="COFramesystem">addCellWithID: aCatCSCell	"add a cell that already has an ID to the container"	| access |	aCatCSCell cellContainer: self.	access := CatCSAtKeyPutAccess cell: self argument1: aCatCSCell id argument2: aCatCSCell.	self isPrototype ifTrue: [ self basicValueAccess: access ] ifFalse: [ self valueAccess: access ].</body><body package="COCellValueHolder">removeCell: aCatCSCell	"remove a cell from the container"		aCatCSCell cellContainer: nil.	self valueAccess:		(CatCSRemoveKeyAccess			cell: self			argument: aCatCSCell id).	^aCatCSCell</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>comparing</category><body package="COFramesystem">&lt; aFrameOrFrameLocator	^self clusterID = aFrameOrFrameLocator clusterID		ifTrue: [self frameID &lt; aFrameOrFrameLocator frameID]		ifFalse: [self clusterID &lt; aFrameOrFrameLocator clusterID]</body><body package="COFramesystem">= object 	^ self == object or: [ object isCoastFrame not and: [ self clusterID notNil and: [ object equalFromFrameLocator: self ]]]</body><body package="COFramesystem">coastCompareFrameOrReferenceTo: aFrameOrFrameLocator 	^ self clusterID = aFrameOrFrameLocator clusterID 		ifTrue: [ self frameID coastCompareTo: aFrameOrFrameLocator frameID ]		ifFalse: [ self clusterID coastCompareTo: aFrameOrFrameLocator clusterID ]</body><body package="COFramesystem">coastCompareTo: aFrameOrFrameLocator 	^ ( aFrameOrFrameLocator coastCompareFrameOrReferenceTo: self ) negated</body><body package="COFramesystem">coastCompareTypeOrder	^ -1</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>private</category><body package="COFramesystem">addCrossVolumeReferenceFrom: aSlot	| aFrame refString |	aFrame := aSlot frame.	refString := aFrame volume, '/' ,				aFrame clusterID printString, '/',				aFrame id printString, '/',				aSlot id printString.	self at: #crossVolumeReferredBy add: refString.</body><body package="COFramesystem">byteArray	^ valueHolder coastIsByteArray		ifTrue: [ valueHolder ]		ifFalse: [ nil ]</body><body package="COFramesystem">byteArray: aByteArray 	( self isUnresolved or: [ self byteArray notNil or: [ aByteArray isNil ]]) ifTrue: [ valueHolder := aByteArray ].</body><body package="COFramesystem">byteArrayIndex	^ valueHolder isInteger 		ifTrue: [ valueHolder haltOrContinue: 'unexpected byteArrayIndex' ]		ifFalse: [ nil ]</body><body package="COFramesystem">byteArraySize	| ba |	^ (ba := self byteArray) notNil		ifTrue: [ ba size ]		ifFalse: [ 0 ]</body><body package="COFramesystem">byteArrayStreamFor: marshall 	^ self byteArray notNil 		ifTrue: [ self byteArray readStream ]		ifFalse: [ nil ]</body><body package="COFramesystem">checkOutgoingCrossVolumeRefsFor: access slot: slot	"the given slot changed its refs"	"keep the references up to date"	| diffs |	diffs := access differencesToBeginOfTransaction.	(diffs at: #removed) do:	[ :f |		f removeCrossVolumeReferenceFrom: slot	].	(diffs at: #added) do:	[ :f |		f addCrossVolumeReferenceFrom: slot	].</body><body package="COMarshalling">createSlotForUnmarshalling: slotID	" Create a new slot, ready for unmarshalling "	| slot |	slot := self slotClass basicNew.	slot cellContainer: self.	slot id: slotID.	^ slot</body><body package="COFramesystem">nameChangedFrom: oldName to: newName	oldName notNil ifTrue:	[		self volumeManager removeFrameNamed: oldName inVolume: self volume.	].	newName notNil ifTrue:	[		self volumeManager addNamedFrame: self inVolume: self volume.	].</body><body package="COFramesystem">notifyFastRead	" lightweight notification mechanism "	container notNil ifTrue: [ container notifyFastRead: self ]</body><body package="COFramesystem">removeCrossVolumeReferenceFrom: aSlot	| aFrame refString |	aFrame := aSlot frame.	refString := aFrame volume, '/' ,				aFrame cluster id printString, '/',				aFrame id printString, '/',				aSlot id printString.	self at: #crossVolumeReferredBy remove: refString.</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>cluster management</category><body package="COFramesystem">addToCluster: aCluster 	"add me to this cluster"	aCluster isNil 		ifFalse: 		[	coastID isNil 				ifTrue: [ self makeShared ].			self needsCluster 				ifTrue: [ aCluster addCell: self ]				ifFalse: 				[	CoastLog logError: 'Error in CatFSFrame&gt;&gt;addToCluster: - tried to assign cluster twice for ' , self printString;						cr				]		].	^ aCluster</body><body package="COFramesystem">addToVolume: volumename	"create a new cluster in the given volume and add me to this cluster"	| newCluster |	(self volume= volumename) ifTrue: [^self].	self cluster notNil		ifTrue: [ self error: 'The frame ', self printString, ' is already assigned to a cluster' ].	newCluster := self volumeManager createClusterInVolume: volumename.	self addToCluster: newCluster.</body><body package="COFramesystem">needsCluster	^self isUnresolved not and: [self cluster isNil]</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>marshalling</category><body package="COFramesystem">allSlotNames	^self resolvedValueHolder value collect: [ :slot | slot id ]</body><body package="COMarshalling">coastAsArgumentForMinimalInvalidation	^ CatFSFrameID id: self idForMinimalInvalidation</body><body package="COMarshalling">coastAsRemoteArgumentFor: aCluster	" fixed: frÃ¼her stand hier 'self cluster = aCluster '	'self cluster' kÃ¶nnte theoretisch auch nil zurÃ¼ckliefern, aber in der Praxis kann es ein Client	*eigentlich* nicht schaffen, hier einen unresolvten Frame durchzuschleusen "	^ self clusterID = aCluster clusterID		ifTrue: [ " internal reference "			CatFSFrameID id: self id ]		ifFalse: [ " external reference "				CatFSFrameReference frame: self ]</body><body package="COClusterManagement">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall 	aCatRMMarshall frameSlotIndexForSymbol: self frameClassSymbol.	self unmarshallBeforeMarshallIfNecessaryWith: aCatRMMarshall.	"byteArray can be nil now (after unmarshallLazy) -&gt; check again!"	self byteArray isNil ifTrue: [ self basicSlots do: [: slot | slot ensureUpdatedFrameSlotIndexWith: aCatRMMarshall frame: self ]].</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall	self frameReference marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall</body><body package="COMarshalling">marshallBinarySlots: slots to: aStream marshaller: aCatRMMarshall 	"unmarshall now or update is futile"	aStream nextPut: slots size.	slots do: 		[: slot |			aCatRMMarshall writeSlotName: slot id frame: self to: aStream.			slot marshallBinaryTo: aStream marshaller: aCatRMMarshall		]</body><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	"unmarshall now or update is futile"	| ba |	self unmarshallBeforeMarshallIfNecessaryWith: aCatRMMarshall.	"byteArray can be nil now (after unmarshallLazy) -&gt; check again!"	( ba := self byteArray ) isNil 		ifTrue: 		[ | allSlots |			allSlots := self resolvedValueHolder value.			aStream nextOptimized32SizeBefore: [: patchedStream | self marshallBinarySlots: allSlots to: patchedStream marshaller: aCatRMMarshall ]		]		ifFalse: [ aStream nextPutAll: ba ].</body><body package="COFramesystem">marshallBinaryValueTo: aStream marshaller: aCatRMMarshall 	| currentClusterID |	currentClusterID := aCatRMMarshall currentClusterID.	( currentClusterID notNil and: [ self clusterID = currentClusterID ]) 		ifTrue: 		[	"internal frame reference"			CatFSFrameID marshallBinaryValue: self id to: aStream		]		ifFalse: 		[	" frame reference"			( CatFSFrameReference frame: self ) marshallBinaryValueTo: aStream marshaller: aCatRMMarshall		].</body><body package="COFramesystem">morphSelectorFor: slotID	^ nil</body><body package="COMarshalling">prepareForUnmarshalling</body><body package="COMarshalling">unmarshallBeforeMarshallIfNecessaryWith: aCatRMMarshall 	( self byteArrayIndex notNil and: [ self unmarshaller wasLoadedFromOldCoastVersion ]) ifTrue: [ self unmarshallLazy ].</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	aCatRMMarshall unmarshallBinaryFrame: self from: aStream</body><body package="COMarshalling">unmarshallByteArrayFrom: aStream 	| position byteArraySize delta |	position := aStream position.	byteArraySize := aStream nextOptimized32.	delta := position - aStream position.	aStream skip: delta.	self byteArray: ( aStream next: byteArraySize - delta ).</body><body package="COMarshalling">unmarshallFromStream: aStream 	| numberOfSlots sd frameSlotIndex vers44 marshall |	marshall := self unmarshaller.	(vers44 := marshall loadCoastVersion isMin: 4 minor: 4) 		ifTrue: 			[frameSlotIndex := marshall frameSlotIndexForSymbol: self coastFrameDictKey ].	self prepareForUnmarshalling.	numberOfSlots := aStream next.	self valueHolder: (sd := CatCSSlotDictionary new: numberOfSlots).	numberOfSlots timesRepeat: 			[| slotID slot morph |			slotID := vers44 						ifTrue: [ marshall readSlotNameFrom: aStream withIndex: frameSlotIndex]						ifFalse: [ marshall readSlotNameFrom: aStream].			slot := self createSlotForUnmarshalling: slotID.			sd coastInternalAt: slotID put: slot.			morph := self morphSelectorFor: slotID.			slot unmarshallSlotBinaryFrom: aStream marshaller: marshall morph: morph ]</body><body package="COMarshalling">unmarshallLazy	| bstr |	bstr := self byteArrayStreamFor: self unmarshaller.	bstr nextOptimized32.	"length ob byteArray"	self unmarshallFromStream: bstr.</body><body package="COMarshalling">unmarshaller	^self cluster unmarshaller</body><body package="COClusterManagement">valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall 	aCatRMMarshall frameSlotIndexForSymbol: self frameClassSymbol.</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing</category><body package="COFramesystem">asCompactArgument	^ self frameReference</body><body package="COFramesystem">asValidFrameReferenceOrNil	self isLocal ifTrue: [ ^ nil ].	self clusterID isNil ifTrue: [ ^ nil ].	^ self frameReference</body><body package="COFramesystem">asWeakFrameReference	^self frameLocator asWeakFrameReference</body><body package="COTransactions">blockCacheFor: block transactionManager: transactionManager 	| slot |	slot := self slotNamed: #localBlockCache.	slot isNil ifTrue: [ slot := self buildSlot: #localBlockCache withAccess: nil ].	^ slot valueHolder at: block		ifAbsent: 		[ | cache |			cache := CoastBlockCache newWithBlock: block transactionManager: transactionManager.			slot valueHolder coastInternalAt: block put: cache.			cache		]</body><body package="COTransactions">blockCacheFor: block transactionManager: transactionManager activeTransaction: activeTransaction 	| slot |	self isUnmanagedLocal ifTrue: 		[	CoastLog logDebug: [ 'skipping block cache of unmanagedLocal Frame ' , self displayString ] channel: #blockCache.			^ nil		].	slot := self slotNamed: #localBlockCache.	slot isNil ifTrue: 		[	activeTransaction notNil 				ifTrue: [ slot := self buildSlot: #localBlockCache withAccess: nil ]				ifFalse: [ ^ nil ]		].	^ slot valueHolder at: block		ifAbsent: 		[ | cache |			cache := CoastBlockCache newWithBlock: block transactionManager: transactionManager.			slot valueHolder coastInternalAt: block put: cache.			cache		]</body><body package="COMarshalling">coastFrameDictKey	^ self class</body><body package="COFramesystem">coastFrameSetHash	^ self isLocal 		ifTrue: [ super coastFrameSetHash ]		ifFalse: [ self frameID ]</body><body package="COFramesystem">coastFrameSetSegmentHash	^ self isLocal 		ifTrue: [ super coastFrameSetSegmentHash ]		ifFalse: [ self clusterID ]</body><body package="COTransactions">coastInternalRemoveFromCluster	"this is post commit &amp; internal"	"maybe your looking fpr #removeFromClusterOnCommit ???"	coastID := self coastID coastAsNewIDFrom: #local for: self.	self cellContainer: self transactionManager.</body><body package="COFramesystem">coastName	^self at: #coastName</body><body package="COFramesystem">coastName: aString	self at: #coastName set: aString</body><body package="COFramesystem">demonPerformer	^self</body><body package="COFramesystem">frame	^self</body><body package="COFramesystem">frameClassName	^ self class frameClassName</body><body package="COFramesystem">frameClassSymbol	^ self class frameClassSymbol</body><body package="COFramesystem">frameID	^ self id</body><body package="COFramesystem">frameKey	^ self class frameKey</body><body package="COFramesystem">frameReference	^ CatFSFrameReference frame: self.</body><body package="COFramesystem">frameReferenceOrSelf	^ CatFSFrameReference frame: self</body><body package="COFramesystem">fullIDNumber	" 64 bit number "	^ self isLocal 		ifTrue: [ 0 ]		ifFalse: 		[	self frameID positive 				ifTrue: [( self clusterID bitShift: 32 ) bitOr: self frameID ]				ifFalse: [(( self clusterID bitShift: 32 ) bitOr: self frameID abs ) negated ]		]</body><body package="COFramesystem">fullIDString	| aStream |	aStream := (String new: 16) writeStream.	self fullIDStringOn: aStream.	^ aStream contents</body><body package="COFramesystem">fullIDStringOn: aStream	self isLocal ifTrue: [ aStream nextPutAll: 'local'. ^ self ].	aStream nextPutAll: 'ID'.	self clusterID printOn: aStream.	aStream nextPut: $_.	self frameID printOn: aStream.</body><body package="COTransactions">idForMinimalInvalidation	^ self isLocal		ifTrue: [ self identityHash ]		ifFalse: [ super idForMinimalInvalidation ]</body><body package="COFramesystem">journalSizeAt: slotName 	| slot |	slot := self fastFind: slotName.	^ slot notNil 		ifTrue: [ slot valueHolder journalSize ]		ifFalse: [ 0 ]</body><body package="COFramesystem">maxJournalSizeAt: slotName 	| slot |	slot := self fastFind: slotName.	^ slot notNil 		ifTrue: [ slot valueHolder maxJournalSize ]		ifFalse: [ 0 ]</body><body package="COFramesystem">notifyClusterLoad</body><body package="COTransactions">ownRemoveFromClusterOnCommit	self isTempSharedFrame ifTrue: 		[ | combinedAgenda |			combinedAgenda := self transactionManager activeTransaction combinedAgenda.			( self fastAt: #coastInternalReferencedBy ) copy 				do: [: rFrame | ( rFrame referencesSharedFrame: self ) ifFalse: [ self at: #coastInternalReferencedBy remove: rFrame ]].			combinedAgenda addRemovedFrame: self		].</body><body package="COFramesystem">propagateNonWeakObserver	( self isShared and: [ container notNil ]) ifTrue: [ container propagateNonWeakObserver ].</body><body package="COTransactions">referencedClusterIDsSkip: skipFrames 	^ self isLocal 		ifTrue: [ #( )]		ifFalse: [ Array with: self clusterID ]</body><body package="COTransactions">removeAllTempSharedFromClusterOnCommit	"Remove this TempShared Frame from his cluster. Recursively remove all connected temp-shareds as well"	self removeAllTempSharedFromClusterOnCommit: Set new</body><body package="COTransactions">removeAllTempSharedFromClusterOnCommit: doneSet	"Remove this TempShared Frame from his cluster. Recursively remove all connected temp-shareds as well"	(self isTempSharedFrame and: [ (doneSet includes: self) not ]) ifTrue:	[		doneSet add: self.		self ownRemoveFromClusterOnCommit.		self basicSlots do: [: slot | slot referencedFramesOrLocatorsCursorDo: [: frameOrLocator | frameOrLocator isTempSharedFrame ifTrue: [ frameOrLocator removeAllTempSharedFromClusterOnCommit: doneSet ] ] ].	].</body><body package="COFramesystem">resolveClusterIfNeeded	^ ( self isUnresolved and: [ container notNil ]) 		ifTrue: 		[	self notifyClusterLoad.			[ container getCluster ] on: CoastTriedToLoadClusterTwiceError				do: 				[: ex |					self valueHolder: CatCSDefectSlotDictionary new.					nil				]		]		ifFalse: [ self cluster ]</body><body package="COFramesystem">resolveValueHolderIfNeeded	| vh |	vh := valueHolder.	^ ( vh isResolvedValueHolder and: [ vh coastIsValueHolder not ]) 		ifTrue: 		[	self volumeManager exclusiveAndInterruptProtectDo: 				[	self isLazyUnmarshalled ifTrue: [ self unmarshallLazy ].					valueHolder				]		]		ifFalse: [ vh ]</body><body package="COFramesystem">setCompactCollectionClusterManagerFor: compactCollection 	compactCollection clusterManager: self clusterManager</body><body package="COFramesystem">valueHolder	^self resolveValueHolderIfNeeded.</body><body package="COFramesystem">withoutRPCsOn: slotName do: block	| slot |	slot := self basicSlotNamed: slotName.	slot isNil ifTrue: [ ^ block value ].		^ slot withoutRPCsDo: block</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing - private</category><body package="COFramesystem">basicValueHolder	^ valueHolder coastIsValueHolder		ifTrue: [ valueHolder ]		ifFalse: [ nil ]</body><body package="COFramesystem">resolvedValueHolder	| vh |	vh := valueHolder.	^ ( vh isResolvedValueHolder not and: [ container notNil ]) 		ifTrue: 		[	self volumeManager exclusiveAndInterruptProtectDo: 				[	self resolveClusterIfNeeded.					self isLazyUnmarshalled ifTrue: [ self unmarshallLazy ].					valueHolder				]		]		ifFalse: [ self resolveValueHolderIfNeeded ]</body><body package="COFramesystem">setInvalidFrameID	self coastID: (self coastID coastAsNewIDFrom: #invalid for: self).</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>testing</category><body package="COFramesystem">allowsSlotComputation	" Is it ok to compute slots when this object is used as a model? "	^true</body><body package="COFramesystem">areSlotsResolved	^ self basicSlots notNil</body><body package="COFramesystem">clusterID	^ container notNil 		ifTrue: [ container clusterID ]		ifFalse: [ nil ]</body><body package="COFramesystem">coastIsFastRead	^ self isUnmanagedLocal or: [ self class isFastRead ]</body><body package="COFramesystem">coastTimestamp	self cluster isNil		ifTrue: [^Timestamp coastRightNow]		ifFalse: [^self clusterManager timestamp].</body><body package="COFramesystem">equalFromFrameLocator: frameLocator 	^ self frameID == frameLocator frameID and: [ self clusterID == frameLocator clusterID ]</body><body package="COFramesystem">frameLocator	^CatCSFrameLocator newFrameID: self id clusterID: self clusterID</body><body package="COClusterManagement">hasNonWeakObservers	^ super hasNonWeakObservers or: [ self isFullyResolved and: [ self basicValueHolder hasNonWeakObservers ]]</body><body package="COClusterManagement">hasObservers	^ super hasObservers 		or: [ self isFullyResolved and: [ self basicValueHolder hasObservers ]]</body><body package="COFramesystem">isBadFrame	^ ( self id isNil or: [ self id = #invalid or: [ container isNil ]]) or: 		[				[ | vh |				vh := self resolvedValueHolder.				vh isNil or: [ vh isDefect ]			] on: CoastTriedToLoadClusterTwiceError do: [: ex | true ]		]</body><body package="COFramesystem">isCoastFrame	^ true</body><body package="COFramesystem">isExternallyVisible	" Answer whether this frame is externally visible or not. Frames which are	visible can be referenced by external frame references (CatFSExternalFrameReference) "	^self coastName notNil	"named objects are visible"		or: [ (self sizeAt: #crossVolumeReferredBy) = 0 ]</body><body package="COFramesystem">isFrameOrFrameReference	^true</body><body package="COFramesystem">isFullyResolved	" cluster and valueholder are present and not lazy "	^ self isResolved and: [ self isLazyUnmarshalled not ]</body><body package="COFramesystem">isInCluster	^ self id isInteger</body><body package="COFramesystem">isLazyUnmarshalled	^ self isResolved and: [ self basicValueHolder isNil ]</body><body package="COFramesystem">isLocal	^ self id isSymbol</body><body package="COTransactions">isNewInCurrentTransaction	| activeTransaction |	self isLocal ifTrue: [ ^ false ].	activeTransaction := self transactionManager activeTransaction.	activeTransaction isNil ifTrue: [ ^ false ].	^ activeTransaction combinedAgenda isNewInCurrentTransaction: self</body><body package="COFramesystem">isResolved	"my cluster is loaded"	^ valueHolder isResolvedValueHolder</body><body package="COFramesystem">isShared	^ coastID notNil and: [ self id isSymbol not ]	"symbols may be #local, #unmamagedLocal or #invalid (or whatever)"</body><body package="COFramesystem">isTempSharedFrame	^ self coastID coastIsTempSharedFrameID</body><body package="COFramesystem">isUniversalFrame	^ false</body><body package="COFramesystem">isUnmanagedLocal	"this frame will not be rolled back on transaction failure..."	^ self id == #unmanagedLocal</body><body package="COFramesystem">isUnresolved	"my cluster is not yet loaded"	^ valueHolder isResolvedValueHolder not</body><body package="COFramesystem">isValidAccessParameter	^ self isShared</body><body package="COFramesystem">isVirtual	" frames are not computed "	" in earlier versions, isVirtual was true for local frames. This was	not correct, but commonly used, so print a reminder on the transcript "	CoastLog logWarning: 'CatFSAbstractFrame&gt;&gt;isVirtual - method behaviour has changed, see method comment';cr.	^ false</body><body package="COTransactions">needsCellValueCopyForRollbackIn: transaction 	^ ( self isUnmanagedLocal or: 		[	self isLocal 				ifTrue: [ transaction combinedAgenda createdLocalFrames includes: self ]				ifFalse: [ transaction combinedAgenda isNewInCurrentTransaction: self ]		]) 		not</body><body package="COFramesystem">referencesSharedFrame: frame 	^ self slots contains: [: slot | slot referencesSharedFrame: frame ]</body><body package="COFramesystem">selfOrFrameLocator	^ self frameLocator</body><body package="COFramesystem">shouldHandleJournalAccess	^ self isLocal or: [ self clusterManager responsibleForVolume ]</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing-SFK style</category><body package="COFramesystem">isolate	" deplete all inverted slots "	self transactionManager ifNotNil: [: tm | tm recordIsolatedFrame: self ].	self slots copy do: [: slot | ( slot depleteSlotBeforeIsolate and: [ slot valueHolder isEmpty not ]) ifTrue: [ self depleteSlot: slot id ]].	( self clusterID notNil and: [ self coastFastGetCounter notNil ]) ifTrue: [ self coastSetCounter: nil ].</body><body package="COFramesystem">isolateAllSlots	" deplete all slots "	self isolate.	self slots do: [: slot | 		self depleteSlot: slot id.	]</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>observer - subject</category><body package="COFramesystem">addObserver: newObserver 	newObserver isWeakObserver ifFalse: [ self propagateNonWeakObserver ].	^super addObserver: newObserver</body><body package="COFramesystem">allObservedClusterIDs	| cid |	^ (cid := self clusterID) notNil		ifTrue: [ Array with: cid ]		ifFalse: [ #() ]</body><body package="COFramesystem">buildUpDependenciesForTransaction: aTransaction access: access 	"  build up a bidirectional dependency if a virtual cell is currently composed, "	| ccc |	aTransaction notNil 		ifTrue: 		[	ccc := aTransaction currentlyComposedCell.			( ccc notNil and: [ self isPrototype not ]) 				ifTrue: 				[	"remember the slot we wanted to read"					ccc addObserverOnFrame: self slotName: access firstArgument				]		].</body><body package="COFramesystem">invalidateObserversWithAccess: aCatCSCellAccess 	" inform all observers that the cell was modified "	| oldObservers slotName keep |	observers isNil 		ifTrue: [ ^ self ].	slotName := aCatCSCellAccess slotName.	slotName == #localBlockCache 		ifTrue: 		[	"do not trigger any invalidations"			^ self		].	( observers 		allSatisfy: [: observer | observer coastObserver notNil and: [ slotName ~= observer slotName and: [ observer coastObserver isValidOrComputed ]]]) 		ifTrue: 		[	"all would be kept - nothing to invalidate!"			^ self		].	" invalidate a minimal set of observers "	oldObservers := observers.	observers := nil.	slotName isNil 		ifTrue: [ oldObservers do: [: observer | observer coastInvalidate ]]		ifFalse: 		[	keep := OrderedCollection new: oldObservers size.			oldObservers do: 				[: observer |					observer coastObserver notNil 						ifTrue: 						[	slotName = observer slotName 								ifTrue: [ observer coastInvalidateWithAccess: aCatCSCellAccess ]								ifFalse: [ keep add: observer ]						]				].			keep do: 				[: observer |					observer coastObserver ifNotNil: 						[: coastObserver |							coastObserver isValidOrComputed 								ifTrue: [ self addObserver: observer ]						]				]		].</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>slot accessing / Set</category><body package="COFramesystem">at: slotName add: anObject	^self accessSlot: slotName accessClass: CatCSAddAccess argument: anObject.</body><body package="COFramesystem">at: slotName remove: anObject	^self accessSlot: slotName accessClass: CatCSRemoveAccess argument: anObject.</body><body package="COTransactions">coastIsValidRPCArgument	" frÃ¼her wurden neue Shared Frames als invalid zurÃ¼ckgewiesen.	Leider ist wird diese Methode viel zu hÃ¤ufig aufgerufen und weisst somit auch bei lokalen Abfragen neue Shared Frames zurÃ¼ck.	deshalb nur lokale Frames zurÃ¼ckweisen "	^ self isLocal not</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>inverting</category><body package="COFramesystem">invertTo: slotname access: aCatCSCellAccess demon: demon 	" an inverted slot of mine has been modified. check that all frames of this slot are properly inverted "	| diff |	diff := aCatCSCellAccess differences.	diff addedDo: [: targetFrame | targetFrame notNil ifTrue: [ targetFrame invertedSlotNamed: slotname addFrame: self demon: demon ]].	diff removedDo: [: targetFrame | targetFrame notNil ifTrue: [ targetFrame invertedSlotNamed: slotname removeFrame: self demon: demon ]].</body><body package="COFramesystem">invertedCollectionSlotNamed: slotName addFrame: aFrame 	( self at: slotName includes: aFrame ) ifFalse: 		[ | slot access |			access := CatCSAddAccess argument: aFrame.			slot := self findSlot: slotName access: access.			self doAccessSlot: slot slotname: slotName access: access		]</body><body package="COFramesystem">invertedIndexSlotNamed: slotName atKey: key add: value 	( self at: slotName atKey: key includes: value ) ifFalse: 		[ | slot access |			access := CatCSAtKeyAddAccess arguments: ( Array with: key with: value ).			slot := self findSlot: slotName access: access.			self doAccessSlot: slot slotname: slotName access: access		]</body><body package="COFramesystem">invertedSingleValueSlotNamed: slotName addFrame: aFrame 	( self at: slotName ) = aFrame ifFalse: 		[ | slot access |			access := CatCSValueWriteAccess argument: aFrame.			slot := self findSlot: slotName access: access.			self doAccessSlot: slot slotname: slotName access: access		]</body><body package="COFramesystem">invertedSlotNamed: slotName addFrame: aFrame demon: demon 	^ demon invertedSlotNamed: slotName at: self addFrame: aFrame</body><body package="COFramesystem">invertedSlotNamed: slotName removeFrame: aFrame demon: demon 	^ demon invertedSlotNamed: slotName at: self removeFrame: aFrame</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>slot accessing / collections</category><body package="COFramesystem">at: slotName includes: anObject	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastAt: slotName includes: anObject ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSIncludesAccess argument: anObject. ]</body><body package="COFramesystem">at: slotName occurrencesOf: anObject	^self accessSlot: slotName accessClass: CatCSOccurrencesOfAccess argument: anObject.</body><body package="COFramesystem">fastAt: slotName includes: anObject	^ self 		fastAt: slotName		do: [ : slotValueHolder | slotValueHolder includes: anObject ]		normalDo: [ self accessSlot: slotName accessClass: CatCSIncludesAccess argument: anObject ]</body><body package="COFramesystem">fastIsEmptyAt: slotName	^ self 		fastAt: slotName		do: [ : slotValueHolder | slotValueHolder isEmpty ]		normalDo: [ self accessSlot: slotName accessClass: CatCSIsEmptyAccess. ]</body><body package="COFramesystem">fastSizeAt: slotName	^ self 		fastAt: slotName		do: [ : slotValueHolder | slotValueHolder size ]		normalDo: [ self accessSlot: slotName accessClass: CatCSSizeAccess. ]</body><body package="COFramesystem">isEmpty: slotName	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastIsEmptyAt: slotName ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSIsEmptyAccess transaction: t ].</body><body package="COFramesystem">sizeAt: slotName	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastSizeAt: slotName ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSSizeAccess transaction: t ].</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing-private</category><body package="COFramesystem">addSlot: aCatFSSlot named: aSymbol	aCatFSSlot id: aSymbol.	self addCellWithID: aCatFSSlot.	(self isPrototype not and: [ self isShared and: [ aCatFSSlot isVirtual not ]])		ifTrue: [ self transactionManager activeTransaction recordCellCreation: aCatFSSlot ].</body><body package="COFramesystem">basicSlotExists: aSlotSymbol	" Answer true if a slot identified by aSlotSymbol is already used	do not use an access "	^ self resolvedValueHolder includesKey: aSlotSymbol</body><body package="COFramesystem">basicSlotNamed: aSlotSymbol 	" Answer the slot aSlotSymbol or nil, if it does not exist.	Do not use an access "	^ self resolvedValueHolder at: aSlotSymbol</body><body package="COFramesystem">basicSlots	" Answer the slots, nothing more or less - resolve the frame iff it is not yet loaded"	^self resolvedCellValue</body><body package="COFramesystem">buildHashWrapper	coastID isNil 		ifTrue: [ coastID := CoastIDAndHashWrapper coastID: nil hash: self class generateNextID ]		ifFalse: [ self error: 'bad method #buildHashWrapper for cell with id ~= nil !' ].	^ coastID</body><body package="COFramesystem">coastInternalRemoveSlotNamed: slotID 	self valueHolder coastInternalRemoveKey: slotID</body><body package="COFramesystem">isClassDefinedPersistentSlot: aSlotSymbol 	"wenn es am prototy den slot gibt, so kÃ¶nnen drei Sorten von definedBy vorkommen		- Das Symbol #initializePrototyoe: kennzeichnet einen ComputedSlot per Slot-Methode angebracht (zBsp #coastEagerObserverSlotSlot)		- Klasse des Frames: 'normale' Slots per Slot-Methode (zBsp #coastInternalReferencedBySlot ) - 		- ein konkreter Slot - wurde nach dem Laden dem prototype bekannt gemacht.	nur die erste Variante geht als &gt;ClassDefinedPersistentSlot&lt; durch"	| slot |	slot := self prototypeNeeded basicSlotNamed: aSlotSymbol.	^ slot notNil and: [ slot definition definedBy isBehavior ]</body><body package="COFramesystem">protoSlotNamed: slotName complain: complain 	"access a prototype slot"	"the slot may have to be created first"	| slot slotOrSomething slotDescriptionMethod |	slot := self basicSlotNamed: slotName.	slot isNil		ifTrue: 			[slotDescriptionMethod := (slotName , 'Slot') asSymbol.			(self class respondsTo: slotDescriptionMethod)				ifTrue: 					[slotOrSomething := self class perform: slotDescriptionMethod.					(slot := self basicSlotNamed: slotName) isNil ifTrue: [slot := slotOrSomething].					slot notNil ifTrue: [self slot: slotName with: slot]]				ifFalse: [					complain ifTrue: [ self haltOrError: 'missing slot definition: ' , slotName ]]].	^slot</body><body package="COFramesystem">referencedFile	"normal frames do not refer to files..."	^nil</body><body package="COFramesystem">removeSlot: aSymbol	^ self valueAccess: (CatCSRemoveKeyAccess						cell: self						argument: aSymbol).</body><body package="COFramesystem">slotClass	" Answer the class used for slots "	^ self class slotClass</body><body package="COFramesystem">slotExists: aSlotSymbol	" Answer true if a slot identified by aSlotSymbol is already used "	^ self slots contains: [ :slot | slot id = aSlotSymbol]</body><body package="COFramesystem">slotNamed: slotName 	^ self valueAccess: ( CatCSAtKeyAccess cell: self argument: slotName )</body><body package="COFramesystem">slots		^ self accessCellValue</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>shared observers</category><body package="COFramesystem">basicExistsObserverSlotAtSlot: slotname	"check if an observer slot already exists, use only basic accessing"	^self basicSlotExists: (self observerSlotnameFor: slotname)</body><body package="COFramesystem">notifyOfAccess: anAccess frame: frame slot: slotName	"an access to an observed frame/slot has occurred"	"this method has to be overwritten if you want to react to the notify"</body><body package="COFramesystem">observerSlotnameFor: slotname	"construct the name of the corresponding observer slot"	ObserverSlotNames isNil		ifTrue: [ ObserverSlotNames := Dictionary new ].	^ ObserverSlotNames at: slotname ifAbsent: [		ObserverSlotNames at: slotname put: ('coastObserverFor' , slotname asString) asSymbol ]</body><body package="COFramesystem">removeObserver: observer atSlot: slotname	"remove the specified observer (a CoastModel) from the given slot"	"do not complain if there is no observers slot"	(self basicExistsObserverSlotAtSlot: slotname) ifTrue:	[		self at: (self observerSlotnameFor: slotname) remove: observer.	].</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>slot accessing / index</category><body package="COFramesystem">at: slotName exclusiveFromKey: startKey toKey: stopKey	^ self accessSlot: slotName accessClass: CatCSExclusiveKeyIntervalAccess argument1: startKey argument2: stopKey</body><body package="COFramesystem">at: slotName fromKey: startKey toKey: stopKey	^ self accessSlot: slotName accessClass: CatCSKeyIntervalAccess argument1: startKey argument2: stopKey</body><body package="COFramesystem">at: slotName greaterKey: key	^ self at: slotName exclusiveFromKey: key toKey: nil</body><body package="COFramesystem">at: slotName greaterOrEqualKey: key	^ self at: slotName fromKey: key toKey: nil</body><body package="COFramesystem">at: slotName lessKey: key	^ self at: slotName exclusiveFromKey: nil toKey: key</body><body package="COFramesystem">at: slotName lessOrEqualKey: key	^ self at: slotName fromKey: nil toKey: key</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>slot accessing / single value</category><body package="COFramesystem">at: slotName maxJournalSize: journalSize 	| slot access |	access := CatCSMaxJournalSizeWriteAccess argument: journalSize.	slot := self findSlot: slotName access: access.	^ slot disableDemonsWhile: [ self doAccessSlot: slot slotname: slotName access: access ]</body><body package="COFramesystem">at: slotName set: anObject	^self accessSlot: slotName accessClass: CatCSValueWriteAccess argument: anObject.</body><body package="COFramesystem">at: slotName setAll: aCollection 	^ self accessSlot: slotName accessClass: CatCSCollectionWriteAccess argument: aCollection</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>slot accessing / OrderedCollection</category><body package="COFramesystem">at: slotName add: anObject after: anotherObject	^ self accessSlot: slotName accessClass: CatCSAddAfterAccess argument1: anObject argument2: anotherObject</body><body package="COFramesystem">at: slotName add: anObject afterIndex: index	^ self accessSlot: slotName accessClass: CatCSAddAfterIndexAccess argument1: anObject argument2: index</body><body package="COFramesystem">at: slotName add: anObject before: anotherObject	^ self accessSlot: slotName accessClass: CatCSAddBeforeAccess argument1: anObject argument2: anotherObject.</body><body package="COFramesystem">at: slotName add: anObject beforeIndex: index	^ self accessSlot: slotName accessClass: CatCSAddBeforeIndexAccess argument1: anObject argument2: index</body><body package="COFramesystem">at: slotName addFirst: anObject	^ self accessSlot: slotName accessClass: CatCSAddFirstAccess argument: anObject.</body><body package="COFramesystem">at: slotName addLast: anObject	^ self accessSlot: slotName accessClass: CatCSAddLastAccess argument: anObject.</body><body package="COFramesystem">at: slotName after: anObject	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastAt: slotName after: anObject ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSAfterAccess argument: anObject ].</body><body package="COFramesystem">at: slotName atIndex: index	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastAt: slotName atIndex: index ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSAtIndexAccess argument: index. ].</body><body package="COFramesystem">at: slotName atIndex: index put: anObject	^self accessSlot: slotName accessClass: CatCSAtIndexPutAccess argument1: index argument2: anObject</body><body package="COFramesystem">at: slotName before: anObject	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastAt: slotName before: anObject ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSBeforeAccess argument: anObject ].</body><body package="COFramesystem">at: slotName indexOf: anObject	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastAt: slotName indexOf: anObject ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSIndexOfAccess argument: anObject ].</body><body package="COFramesystem">at: slotName move: anObject by: numPositions	| oldPos newPos |	anObject isNil ifTrue: [ ^nil ].	oldPos := self at: slotName indexOf: anObject.	oldPos = 0		ifTrue: [ ^ nil ].	newPos := oldPos + numPositions.	(newPos &lt; 1 or: [ newPos &gt; (self sizeAt: slotName) ])		ifTrue: [ ^ nil ].	" if the ordered collection is inverted, temporary overwriting a value triggers the inverting demon.	therefore disable the demon "	self 		disableDemons: #(#invertingSlot)		at: slotName		while: [			self at: slotName removeAtIndex: oldPos.			self at: slotName add: anObject beforeIndex: newPos.		].	^ anObject</body><body package="COFramesystem">at: slotName removeAtIndex: index	^self accessSlot: slotName accessClass: CatCSRemoveAtIndexAccess argument: index.</body><body package="COFramesystem">fastAt: slotName after: anObject	^ self 		fastAt: slotName		do: [ : slotValueHolder | slotValueHolder after: anObject ]		normalDo: [ self accessSlot: slotName accessClass: CatCSAfterAccess argument: anObject ]</body><body package="COFramesystem">fastAt: slotName atIndex: index	^ self 		fastAt: slotName		do: [ : slotValueHolder | slotValueHolder at: index ]		normalDo: [ self accessSlot: slotName accessClass: CatCSAtIndexAccess argument: index. ]</body><body package="COFramesystem">fastAt: slotName before: anObject	^ self 		fastAt: slotName		do: [ : slotValueHolder | slotValueHolder before: anObject ]		normalDo: [ self accessSlot: slotName accessClass: CatCSBeforeAccess argument: anObject ]</body><body package="COFramesystem">fastAt: slotName indexOf: anObject	^ self 		fastAt: slotName		do: [ : slotValueHolder | slotValueHolder indexOf: anObject ifAbsent: [ nil ] ]		normalDo: [ self accessSlot: slotName accessClass: CatCSIndexOfAccess argument: anObject. ]</body><body package="COFramesystem">firstAt: slotName	^self accessSlot: slotName accessClass: CatCSFirstAccess.</body><body package="COFramesystem">lastAt: slotName	^self accessSlot: slotName accessClass: CatCSLastAccess.</body><body package="COFramesystem">removeFirstAt: slotName	^self accessSlot: slotName accessClass: CatCSRemoveFirstAccess.</body><body package="COFramesystem">removeLastAt: slotName	^self accessSlot: slotName accessClass: CatCSRemoveLastAccess.</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>initialize-release</category><body package="COFramesystem">disresolve	( self isResolved and: [ valueHolder coastIsValueHolder ]) ifTrue: [ self basicSlots do: [: slot | slot invalidateObserversDisresolved ]].	self invalidateObservers.	container := nil.	"will be (re-)set later"	valueHolder := nil.</body><body package="COFramesystem">finishObservation	self valueHolder value notNil		ifTrue: [ self valueHolder keysAndValuesDo: [:name :cell |		cell finishObservation ]].	super finishObservation.</body><body package="COTransactions">flushSlotsForRollbak	valueHolder := COAST.CatCSSlotDictionary new.</body><body package="COFramesystem">initializeFrame</body><body package="COFramesystem">initializeFrameAndSlots	self isLocal ifTrue: 		[	self initializeVirtualSlots.			self isUnmanagedLocal ifFalse: [ self transactionManager activeTransaction recordLocalFrameCreation: self ]		].	self initializeFrame.</body><body package="COFramesystem">initializePrototype	" the prototype builds all slots immediately "	| aSlotOrSomething |	super initializePrototype.	self valueHolder: CatCSSlotDictionary new.	self class allLazySlotNames do: 		[: slotName |			aSlotOrSomething := [ self class perform: ( slotName , 'Slot' ) asSymbol ] on: self class subclassResponsibilitySignal do: [: ex | nil ].			( aSlotOrSomething notNil and: [( self basicSlotNamed: slotName ) isNil ]) ifTrue: [ self slot: slotName with: aSlotOrSomething ]		].</body><body package="COFramesystem">initializeVirtualSlots	" create all virtual slots "	self prototype valueHolder keysAndValuesDo: 		[: slotname : protoSlot |			protoSlot isVirtual 				ifTrue: [ self buildSlot: slotname withAccess: nil ]		].</body><body package="COClusterManagement">invalidateSlotObservers	"invalidate all my slot's dependants to get rid of old dependencies. Use this for clean-up"	self basicSlots do: [ :slot | slot invalidateObservers ]</body><body package="COFramesystem">makeLocal	self id: #local.</body><body package="COFramesystem">makeShared	"record the creation of the cell (this must be done before accessing 	the cell and inside the transaction the cell was created)"	| activeTransaction |	activeTransaction := self transactionManager activeTransaction.	activeTransaction inDisplayPhase ifTrue: [ activeTransaction illegalWriteAccessDuringDisplayPhaseError ].	coastID == nil ifTrue: [ self buildHashWrapper ].	activeTransaction recordCellCreation: self</body><body package="COFramesystem">makeTempShared	"record the creation of the cell (this must be done before accessing 	the cell and inside the transaction the cell was created)"	| activeTransaction |	activeTransaction := self transactionManager activeTransaction.	activeTransaction inDisplayPhase ifTrue: [ activeTransaction illegalWriteAccessDuringDisplayPhaseError ].	#newUnreferencedFrame == coastID 		ifFalse: [ CoastError raiseSignal: 'This frame must not be temp shared - use #newTempInCluster: or #newTempColocatedTo:' ].	coastID := CoastIDAndHashWrapper coastID: nil hash: self class generateNextID negated.	activeTransaction recordCellCreation: self.</body><body package="COFramesystem">release	self isUnresolved ifFalse: [ self basicSlots do: [ : slot | slot release ]].	super release.</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>slot accessing / bag</category><body package="COFramesystem">at: slotName add: anObject withOccurrences: anInteger	^ self accessSlot: slotName accessClass: CatCSAddWithOccurrencesAccess argument1: anObject argument2: anInteger</body><body package="COFramesystem">at: slotName removeAllOccurrences: anObject	^ self accessSlot: slotName accessClass: CatCSRemoveAllOccurrencesAccess argument: anObject</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing user level</category><body package="COFramesystem">accessSlot: slotName accessClass: aClass 	" access the slot with the given access class "	^ self accessSlot: slotName accessClass: aClass transaction: nil</body><body package="COFramesystem">accessSlot: slotName accessClass: aClass argument1: aValue1 argument2: aValue2	" access the slot with the given access class and arguments "	| slot access |	access := aClass argument1: aValue1 argument2: aValue2.	slot := self findSlot: slotName access: access.	^ self doAccessSlot: slot slotname: slotName access: access</body><body package="COFramesystem">accessSlot: slotName accessClass: aClass argument: anObject 	" access the slot with the given access class and argument"	| slot access |	access := aClass argument: anObject.	slot := self findSlot: slotName access: access.	^ self doAccessSlot: slot slotname: slotName access: access</body><body package="COFramesystem">accessSlot: slotName accessClass: aClass arguments: anArray 	" access the slot with the given access class and arguments "	| slot access |	access := aClass arguments: anArray.	slot := self findSlot: slotName access: access.	^ self doAccessSlot: slot slotname: slotName access: access</body><body package="COFramesystem">accessSlot: slotName accessClass: aClass transaction: transactionOrNil 	" access the slot with the given access class "	| slot access |	access := aClass new.	( transactionOrNil notNil and: [ transactionOrNil ownerProcess == Processor activeProcess ]) 		ifTrue: [ access transaction: transactionOrNil ].	slot := self findSlot: slotName access: access.	^ self doAccessSlot: slot slotname: slotName access: access</body><body package="COFramesystem">disableDemons: demonNames at: slotName while: aBlock	| slot |	slot := self basicSlotNamed: slotName.	^ slot isNil 		ifTrue: [ aBlock value ]		ifFalse: [			slot disableDemons: demonNames while: aBlock		].</body><body package="COFramesystem">doAccessSlot: slot slotname: slotName access: anAccess 	"access the slot with the given access object"	"return the result of the access operation"	^ slot access: anAccess</body><body package="COFramesystem">findSlot: slotName access: access 	" find the slot, create it if necessary "	| slot cell |	cell := slot := self basicSlotNamed: slotName.	" peek if the slot exists "	slot isNil ifTrue: 		[	slot := access isWriteAccess 					ifTrue: [ self buildSlot: slotName withAccess: access ]					ifFalse: [ self prototypeNeeded protoSlotNamed: slotName complain: true ].			slot isNil ifTrue: [ self slotNotFoundError: slotName ].			cell := ( access isWriteAccess or: [ self isPrototype ]) 					ifTrue: [ slot ]					ifFalse: [ CatCSCellWrapper protoSlot: slot frame: self ]		].	access cell: cell.	( access isWriteAccess and: [ slot allowsSlotModification not ]) ifTrue: [ self slotNotWriteableError: slotName ].	^ slot</body><body package="COFramesystem">findSlot: slotName accessClass: accessClass	" find the slot, create it if necessary - compatibility to coast 4"	^self findSlot: slotName access: accessClass new</body><body package="COFramesystem">realFrameFrom: clusterManager	^self</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>slot accessing / Dictionary</category><body package="COFramesystem">at: slotName atKey: key	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastAt: slotName atKey: key ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSAtKeyAccess argument: key ]</body><body package="COFramesystem">at: slotName atKey: key add: value 	^ self accessSlot: slotName accessClass: CatCSAtKeyAddAccess argument1: key argument2: value</body><body package="COFramesystem">at: slotName atKey: key ifAbsent: aBlock	| probe |	probe := self at: slotName atKey: key.	^probe notNil		ifTrue: [ probe ]		ifFalse: [ aBlock value ]</body><body package="COFramesystem">at: slotName atKey: key ifAbsentPut: valueBlock 	^self at: slotName atKey: key		ifAbsent: 		[| newValue |			newValue := valueBlock value.			self at: slotName atKey: key put: newValue.			newValue ]</body><body package="COFramesystem">at: slotName atKey: key includes: value 	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue:  [ self fastAt: slotName atKey: key includes: value ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSAtKeyIncludesAccess argument1: key argument2: value ]</body><body package="COFramesystem">at: slotName atKey: key put: value	^self accessSlot: slotName accessClass: CatCSAtKeyPutAccess argument1: key argument2: value.</body><body package="COFramesystem">at: slotName atKey: key remove: value 	^ self accessSlot: slotName accessClass: CatCSAtKeyRemoveAccess argument1: key argument2: value</body><body package="COFramesystem">at: slotName atKeyPattern: key ignoreCase: ignoreCase maxSize: maxSize 	"acces to come"	^ ( self at: slotName ) atKeyPattern: key ignoreCase: ignoreCase maxSize: maxSize</body><body package="COFramesystem">at: slotName atKeys: keys 	"( self at: slotName ) atKeys: keys would be bad for concurrency"	"until better solution is availabel, use #fastAt:atKeys:"	^ self fastAt: slotName atKeys: keys</body><body package="COFramesystem">at: slotName atKeys: keys maxRPCSize: maxRPCSize	"( self at: slotName ) atKeys: keys maxRPCSize: maxRPCSize would be bad for concurrency"	"until better solution is availabel, use #fastAt:"	^ ( self fastAt: slotName ) atKeys: keys maxRPCSize: maxRPCSize</body><body package="COFramesystem">at: slotName atKeys: keys maxRPCSize: maxRPCSize restrictToValues: restrictToValues	"( self at: slotName ) atKeys: ... would be bad for concurrency"	"until better solution is availabel, use #fastAt:"	^ ( self fastAt: slotName ) atKeys: keys maxRPCSize: maxRPCSize restrictToValues: restrictToValues</body><body package="COFramesystem">at: slotName includesKey: key	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ (self fastAt: slotName atKey: key) notNil ]		ifFalse: [self accessSlot: slotName accessClass: CatCSIncludesKeyAccess argument: key]</body><body package="COFramesystem">at: slotName keyAtValue: value	^self accessSlot: slotName accessClass: CatCSKeyAtValueAccess argument: value.</body><body package="COFramesystem">at: slotName matchingPattern: key ignoreCase: ignoreCase 	"acces to come"	^ ( self at: slotName ) matchingPattern: key ignoreCase: ignoreCase maxSize: nil</body><body package="COFramesystem">at: slotName matchingPattern: key ignoreCase: ignoreCase maxSize: maxSize	"acces to come"	^ ( self at: slotName ) matchingPattern: key ignoreCase: ignoreCase maxSize: maxSize</body><body package="COFramesystem">at: slotName removeKey: key	^self accessSlot: slotName accessClass: CatCSRemoveKeyAccess argument: key.</body><body package="COFramesystem">fastAt: slotName atKey: key 	| slot |	slot := self fastFind: slotName.	^ slot canFastRead 		ifTrue: 		[	self notifyFastRead.			slot resolvedCellValue atKey: key		]		ifFalse: [ self accessSlot: slotName accessClass: CatCSAtKeyAccess argument: key ]</body><body package="COFramesystem">fastAt: slotName atKey: key includes: value 	| slot |	slot := self fastFind: slotName.	^ slot canFastRead 		ifTrue: 		[	self notifyFastRead.			slot resolvedCellValue atKey: key includes: value		]		ifFalse: [ self accessSlot: slotName accessClass: CatCSAtKeyIncludesAccess argument1: key argument2: value ]</body><body package="COFramesystem">fastAt: slotName atKeys: keys 	^ ( self fastAt: slotName ) atKeys: keys</body><body package="COFramesystem">fastKeysAt: slotName	^ self 		fastAt: slotName		do: [ : slotValueHolder | slotValueHolder keys ]		normalDo: [ self accessSlot: slotName accessClass: CatCSKeysAccess. ]</body><body package="COFramesystem">fastValuesAt: slotName	^ self 		fastAt: slotName		do: [ : slotValueHolder | slotValueHolder values ]		normalDo: [ self accessSlot: slotName accessClass: CatCSValuesAccess. ]</body><body package="COFramesystem">keysAt: slotName	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastKeysAt: slotName ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSKeysAccess transaction: t ].</body><body package="COFramesystem">valuesAt: slotName	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastValuesAt: slotName ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSValuesAccess transaction: t ].</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>slot accessing / general</category><body package="COFramesystem">activeTransaction	| tm |	tm := self transactionManager.	^tm isNil		ifTrue: [ nil ]		ifFalse: [ tm activeTransaction ]</body><body package="COFramesystem">at: slotName	| t |	^ (self coastIsFastRead or: [ (t := self activeTransaction) notNil and: [ t isFastRead ]])		ifTrue: [ self fastAt: slotName ]		ifFalse: [ self accessSlot: slotName accessClass: CatCSValueReadAccess transaction: t ].</body><body package="COFramesystem">at: slotName replace: oldValue with: newValue	(self slotNamed: slotName) ifNotNil: [: slot | slot valueHolder frame: self at: slot slotName replace: oldValue with: newValue ]</body><body package="COFramesystem">depleteSlot: slotName 	"remove all elements from the slot"	( self basicSlotExists: slotName ) 		ifTrue: [ self accessSlot: slotName accessClass: CatCSDepleteAccess ]		ifFalse: [ self slotExists: slotName ]</body><body package="COFramesystem">fastAt: slotName 	| slot |	slot := self fastFind: slotName.	^ slot canFastReadFullValue 		ifTrue: 		[	self notifyFastRead.			slot valueHolder valueForReadAccess		]		ifFalse: 		[	"do not fast read invalid slots"			self accessSlot: slotName accessClass: CatCSValueReadAccess		]</body><body package="COFramesystem">fastAt: slotName do: aBlock normalDo: normalBlock 	| slot |	slot := self fastFind: slotName.	^ slot canFastRead 		ifTrue: 		[	self notifyFastRead.			aBlock value: slot resolvedValueHolder		]		ifFalse: [ normalBlock value ]</body><body package="COFramesystem">fastFind: slotName 	| cl res |	res := self basicSlotNamed: slotName.	res isNil ifTrue: [ res := self prototypeNeeded protoSlotNamed: slotName complain: true ].	( cl := self cluster ) notNil ifTrue: [ cl notifyRead ].	^ res</body><body package="COFramesystem">restorePrototypeValueFor: slotName 	"remove the slot so it's value is read from the prototype again."	self prototype isNil ifFalse: [self removeSlot: slotName]</body><body package="COFramesystem">safeAt: slotName 	^ ( self basicSlotExists: slotName ) 		ifTrue: [ self at: slotName ]		ifFalse: [ nil ].</body><body package="COFramesystem">safeDepleteSlot: slotName 	(self basicSlotExists: slotName)		ifTrue: [self depleteSlot: slotName ]</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>slot description - accessing</category><body package="COFramesystem">allLazySlotNames	^self class allLazySlotNames</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>copying</category><body package="COFramesystem">coastCopyWith: copyContext	" need to set the cell container of my slots if I am a prototype	(if I am not a prototype, the cell container is already set when copying a slot) "	| theCopy |	theCopy := super coastCopyWith: copyContext. 	self isPrototype		ifTrue: [			theCopy valueHolder keysAndValuesDo:  [ :slotID :slot  |				 slot cellContainer: theCopy			].		].	^theCopy</body><body package="COFramesystem">shallowCopyQuery 	^[:obj | obj == self or: [ obj isCoastFrame  not ]].</body><body package="COFramesystem">tempSharedCopyOfFramesInCluster: aCluster deepCopyQueryBlock: deepCopyQueryBlock	| ctx |	ctx := CopyContext deepCopyQueryBlock: deepCopyQueryBlock.	ctx spawnTempSharedInCluster: aCluster.	^ self coastCopyWith: ctx</body><body package="COFramesystem">tempSharedCopyOfLocalFrames	" Copy with all adjacent local frames "	^ self tempSharedCopyOfLocalFramesIn: nil</body><body package="COFramesystem">tempSharedCopyOfLocalFramesIn: cluster	" Copy with all adjacent local frames "	| ctx |	ctx := CopyContext deepCopyQueryBlock: [: obj | obj isLocal ].	ctx spawnTempSharedInCluster: cluster.	^ self coastCopyWith: ctx</body><body package="COFramesystem">tempSharedCopyOfLocalFramesInCluster: aCluster	" Copy with all adjacent local frames "	^self tempSharedCopyOfFramesInCluster: aCluster deepCopyQueryBlock: [: obj | obj isLocal ].</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>error handling</category><body package="COFramesystem">slotNotFoundError: aSymbol 	"This method is called when a slot is accessed for which no value can be found."	"a signal should be raised here"	self transactionManager statusError: 'Unknown slot: ' , aSymbol printString , ' in ' , self printString</body><body package="COFramesystem">slotNotWriteableError: aSymbol 	"This method is called when a slot is accessed for which no value can be found."	"a signal should be raised here"	self transactionManager statusError: 'Read only slot: ' , aSymbol printString , ' in ' , self printString.</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>rpc accessing </category><body package="COFramesystem">at: slotName rpcPerform: symbol withArguments: arguments allowCache: allowCache 	| clusterManager |	^ ( clusterManager := self clusterManager ) notNil 		ifTrue: [ clusterManager remoteCall: self slotName: slotName selector: symbol arguments: arguments allowCache: allowCache ]		ifFalse: [( self at: slotName ) perform: symbol withArguments: arguments ]</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>slot creation - private</category><body package="COFramesystem">slot: aSymbol with: aCatCSCell 	" Create a reference slot aCatCSCell.	Return the slot. "	aCatCSCell definition definedBy isNil ifTrue: [ aCatCSCell definition definedBy: #initializePrototype ].	self addSlot: aCatCSCell named: aSymbol.	^ aCatCSCell markAsEndcellPrototype</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>routing</category><body package="COFramesystem">buildSlot: aSlotName withAccess: writeAccessOrNil 	"do not use protoSlot deepCopy - the copy will not know its container	hs&amp;cs nov 20 2000"	| protoSlot slot |	protoSlot := self prototypeNeeded protoSlotNamed: aSlotName complain: true.	protoSlot isNil ifTrue: [ self slotNotFoundError: aSlotName ].	self isPrototype ifTrue: [ ^ protoSlot ].	slot := protoSlot spawnFor: self transactionManager.	self addSlot: slot named: aSlotName.	writeAccessOrNil notNil ifTrue: 		[	writeAccessOrNil cell: slot.			writeAccessOrNil initializeSlot: slot protoSlot: protoSlot		].	^ slot</body><body package="COFramesystem">prototypeNeeded	| prototype |	prototype := self prototype.	^ prototype notNil 		ifTrue: [ prototype ]		ifFalse: [ self class prototypeNeeded ]</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>printing</category><body package="COFramesystem">idPrintStringOn: stream 	self isLocal ifTrue: 		[	stream nextPut: $[.			stream nextPutAll: self id.			stream nextPut: $].			^ self		].	self clusterID isNil ifTrue: 		[	stream nextPutAll: '[a cell not yet assigned to a cluster]'.			^ self		].	stream nextPut: $[.	self clusterID printOn: stream.	stream nextPut: $/.	self id printOn: stream.	stream nextPut: $].</body><body package="COFramesystem">printOn: aStream 	"the one-and-only basic printing method"	"works under all conditions - even if the object is damaged"	"is usable in debuggers, i.e. does not load any clusters"	| nameSlot coastName |	self basicValueHolder isNil 		ifTrue: 		[	self isUnresolved 				ifTrue: [ aStream nextPutAll: 'an unresolved ' ]				ifFalse: [ aStream nextPutAll: 'a lazy ' ].			aStream nextPutAll: self classLabel.			self idPrintStringOn: aStream		]		ifFalse: 		[				[	nameSlot := self basicSlotNamed: #coastName.				coastName := nameSlot isNil 						ifTrue: [ nil ]						ifFalse: [ nameSlot resolvedCellValue ]			] on: Error do: [: ex | ].			coastName isNil 				ifTrue: [ super printOn: aStream ]				ifFalse: 				[	aStream nextPutAll: 'a '.					aStream nextPutAll: self classLabel.					aStream nextPutAll: ' (' , coastName , ') '.					self idPrintStringOn: aStream				]		].</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>accessing counter</category><body package="COFramesystem">coastCounterFrame	^ self clusterManager rootClusterNeeded administrationFrame</body><body package="COFramesystem">coastFastGetCounter	^ self coastCounterFrame coastFastCounterAt: self</body><body package="COFramesystem">coastGetCounter	^ self coastCounterFrame coastCounterAt: self</body><body package="COFramesystem">coastIncCounter	^ self coastCounterFrame coastCounterAt: self incBy: 1</body><body package="COFramesystem">coastSetCounter: integer 	^ self coastCounterFrame coastCounterAt: self set: integer</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>copying - private</category><body package="COFramesystem">coastCreateBasicCopyColocatedTo: anotherFrame context: copyContext 	" part of the copy mechanism - create a new frame of this kind colocated to the other frame "	^ self class newColocatedTo: anotherFrame</body><body package="COFramesystem">coastCreateBasicCopyInNewClusterInContext: copyContext 	" part of the copy mechanism - create a new frame of this kind in a new cluster  "	^ self class newInVolume: copyContext volume</body><body package="COFramesystem">coastCreateBasicLocalCopyInContext: copyContext 	" part of the copy mechanism - create a new local frame of this kind "	^ self class newLocal</body><body package="COFramesystem">copySlot: slot to: myCopy with: copyContext 	"copy the contents of my value holder to myCopy"	| slotCopy accesses |	slot definition isUnknown 		ifTrue: [ ^ self ].	slot isVirtual 		ifTrue: [ ^ self ].	slot name = #localBlockCache 		ifTrue: [ ^ self ].	( myCopy prototype isClassDefinedPersistentSlot: slot name ) 		ifFalse: [ ^ self ].	( copyContext shouldCopySlot: slot ) 		ifFalse: [ ^ self ].	( myCopy basicSlotExists: slot id ) 		ifTrue: 		[	" slot already exists (e.g. created in #initializeFrame) " 			slot canOverwriteOnCopy 				ifFalse: [ ^ self ].			myCopy depleteSlot: slot id		].	accesses := slot valueHolder constructCopyParameters: copyContext.	accesses do: 		[: access |			slotCopy := myCopy findSlot: slot id access: access.			myCopy doAccessSlot: slotCopy slotname: slotCopy id access: access		].</body><body package="COFramesystem">copyValueHolderTo: myCopy with: copyContext 	"copy the contents of my value holder to myCopy"	" first do an official read access to the whole value holder	this is essential for correct concurrency control behaviour!!!"	self accessCellValue.		(self slots sortedBy: [ : slot | slot copyOrder ]) do: [: slot | copyContext copySlot: slot frame: self with: [ self copySlot: slot to: myCopy with: copyContext ] ]</body></methods><methods><class-id>COAST.CatFSFrame</class-id> <category>update</category><body package="COTransactions">addSlotForUpdate: aSlot 	self resolveValueHolderIfNeeded.	^ self accessForUpdate: ( CatCSAtKeyPutAccess argument1: aSlot id argument2: aSlot )</body><body package="COTransactions">slotAccessForUpdate: aCatRMSlotAccess argumentTranslationBlock: translationBlock transaction: aTransaction 	| slot cellAccess morphSelector morphArg morphClass |	slot := self resolvedValueHolder at: aCatRMSlotAccess slotName asSymbol.	slot isNil ifTrue: 		[	CoastLog logError: 'slot ' , aCatRMSlotAccess slotName , ' not found - slot access failed'.			self haltOrContinue.			^ self	"hope it was a joke"		].	cellAccess := aCatRMSlotAccess createCellAccessWith: translationBlock .	cellAccess transaction: aTransaction.	morphSelector := self morphSelectorFor: slot id.	morphSelector notNil ifTrue: 		[	morphArg := cellAccess argumentToCheck.			morphArg notNil ifTrue: 				[	morphClass := morphArg class perform: morphSelector.					morphClass ~~ morphArg class ifTrue: [ morphArg changeClassTo: morphClass ]				]		].	slot accessForUpdate: cellAccess</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>testing</category><body package="COFramesystem">coastIsFrameClass	^ true</body><body package="COFramesystem">isFastRead	" if true, all slots are accessed with fast reads if possible "	^ false</body><body package="COFramesystem">isPartOfIndexStructure	^false</body><body package="COFramesystem">isVirtual	^ false</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>naming service</category><body package="COFramesystem">named: aString inVolume: volumeName	"create the specified model"	| newInst |	newInst := self newInVolume: volumeName.	newInst coastName: aString.	^newInst</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>instance creation</category><body package="COFramesystem">new	^ self newSharedIfPossible: self isVirtual not</body><body package="COFramesystem">newColocatedTo: aFrame 	| newFrame |	aFrame isNil ifTrue: [ ^ self new ].	aFrame isLocal ifTrue: 		[	^ aFrame isUnmanagedLocal 				ifTrue: [ self newUnmanagedLocalFor: aFrame transactionManager ]				ifFalse: [ self newLocal ]		].	aFrame resolvedCluster ifNotNil: 		[: cluster |			^ aFrame isTempSharedFrame 				ifTrue: [ self newTempInCluster: cluster ]				ifFalse: [ self newInCluster: cluster ]		].	newFrame := self new.	aFrame isTempSharedFrame ifTrue: 		[	newFrame coastID: #newUnreferencedFrame.	"mark it as a valid frame for temp sharing"			newFrame makeTempShared		].	^ newFrame</body><body package="COFramesystem">newInCluster: aCluster 	"create a new model instance in aCluster"	^ self newWithClusteringBlock: [ : newFrame | newFrame addToCluster: aCluster ]</body><body package="COFramesystem">newInCluster: aCluster named: aStringOrNil 	"create a new model instance in aCluster"	^ self newWithClusteringBlock: 		[: newFrame |			newFrame addToCluster: aCluster.			aStringOrNil notNil ifTrue: [ newFrame coastName: aStringOrNil ]		]</body><body package="COFramesystem">newInVolume: volumename 	"create a new cluster in the given volume and create a new model instance in this cluster"	^ self newWithClusteringBlock: [ : newFrame | newFrame addToVolume: volumename ]</body><body package="COFramesystem">newInVolumeOf: aFrame 	aFrame isNil ifTrue: [ ^ self new ].	aFrame isLocal ifTrue: [ ^ self newLocal ].	aFrame volume notNil ifTrue: [ ^ self newInVolume: aFrame volume ].	^ self new</body><body package="COFramesystem">newLocal	^ self newSharedIfPossible: false</body><body package="COFramesystem">newSharedIfPossible: makeSharedIfPossible	" if makeSharedIfPossible is true, try to create a shared frame.	if this not be possible (e.g. in display transactions), the frame	is create locally "	| newFrame |	self prototype isNil		ifTrue: [self initializePrototype].	newFrame := self prototype coastSpawn.	(makeSharedIfPossible and: [ Processor activeTransaction inDisplayPhase not ])		ifTrue: [ newFrame makeShared ]		ifFalse: [ newFrame makeLocal ].	newFrame transactionManager withoutDependenciesDo: [		newFrame initializeFrameAndSlots.	].	^newFrame</body><body package="COFramesystem">newTempColocatedTo: frame 	^ frame isLocal 		ifTrue: [ self newLocal ]		ifFalse: [ self newTempInCluster: frame resolvedCluster ]</body><body package="COFramesystem">newTempInCluster: aCluster 	"create a new model instance in aCluster"	| newFrame |	self prototype isNil ifTrue: [ self initializePrototype ].	newFrame := self prototype coastSpawn.	newFrame coastID: #newUnreferencedFrame.	"mark it as a valid frame for temp sharing"	newFrame makeTempShared.	"calling makeTempShared is only allowed for new frames (not yet added to a slot)"	newFrame addToCluster: aCluster.	"add the frame before calling initialize!	otherwise information may be missing during initialize. CS0900"	newFrame initializeFrameAndSlots.	^ newFrame</body><body package="COFramesystem">newTempInVolumeOf: clusterManager 	^ self newTempInCluster: clusterManager createCluster</body><body package="COFramesystem">newUnmanagedLocal	"this frame will not be rolled back on transaction failure..."	| tm |	tm := Processor activeTransaction 			ifNotNil: [: t | t transactionManager ]			ifNil: [ CoastError raiseSignal: 'Cannot create unmanaged frame without transaction manager' ].	^ self newUnmanagedLocalFor: tm</body><body package="COFramesystem">newUnmanagedLocalFor: transactionManager 	"this frame will not be rolled back on transaction failure..."	^ ( self basicNew )		id: #unmanagedLocal;		cellContainer: transactionManager;		valueHolder: COAST.CatCSSlotDictionary new;		initializeFrameAndSlots;		yourself</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>class name</category><body package="COFramesystem">renameTo: aString 	super renameTo: aString.	coastFrameClassName := nil.	coastFrameClassSymbol := nil.</body><body package="COFramesystem">setName: aString 	super setName: aString.	coastFrameClassName := nil.	coastFrameClassSymbol := nil.</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>accessing</category><body package="COFramesystem">emptyPrototype	super emptyPrototype.	coastFrameClassName := nil.	coastFrameClassSymbol := nil</body><body package="COFramesystem">frameClassName	| pragmas formerName ref |	coastFrameClassName isNil 			ifTrue: [ 					pragmas := Pragma allNamed: #coastFormerName: in: self class.				pragmas size &gt; 1 ifTrue: [ CoastFatalError raiseSignal: self printString , ' has different former names' ].				coastFrameClassName := pragmas size = 1 					ifTrue: [ 						formerName := pragmas singleElement argumentAt: 1.						((ref := formerName asQualifiedReference) isDefined and: [ ref value isKindOf: CatFSFrame ])								ifTrue: [ self error: formerName , ' is not a unique old class name!' ].						formerName					]					ifFalse: [ self fullName ].			].	^ coastFrameClassName</body><body package="COFramesystem">frameClassSymbol	coastFrameClassSymbol isNil		ifTrue: [ coastFrameClassSymbol := self frameClassName asSymbol ].	^ coastFrameClassSymbol</body><body package="COFramesystem">frameKey	^ self</body><body package="COFramesystem">slotClass	" Answer the class used for slots "	^ CatFSSlot</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>slot accessing</category><body package="COFramesystem">allLazySlotNames	^ (self allLazySlotSelectors 		collect: [ :sel | (sel copyFrom: 1 to: (sel size - 4)) asSymbol ])		 asSortedCollection: [ :sel1 :sel2 | 			(self preferredSlotOrder indexOf: sel1 ifAbsent: [ SmallInteger maxVal ])				&lt;= (self preferredSlotOrder indexOf: sel2 ifAbsent: [ SmallInteger maxVal ])		]</body><body package="COFramesystem">allLazySlotSelectors	| cl slotSelectors |	slotSelectors := IdentitySet new.	cl := self.	[	slotSelectors addAll: cl lazySlotSelectors.		cl == CatFSFrame	] whileFalse: [ cl := cl superclass ].	^ slotSelectors</body><body package="COFramesystem">lazySlotNames	^self lazySlotSelectors collect: [ :sel | (sel copyFrom: 1 to: (sel size - 4)) asSymbol ]</body><body package="COFramesystem">lazySlotSelectors	^self class selectors select: [ :s | '*Slot' match: s asString ]</body><body package="COFramesystem">slot: aSlotName	^self prototype slotNamed: aSlotName</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>slot creation</category><body package="COFramesystem">initializeSlotDescription	self prototype: self newClassPrototype.	^self prototype.</body><body package="COFramesystem">preferredSlotOrder	^ #()</body><body package="COFramesystem">slotComputedBy: aBlockOrSelector 	^ self slotComputedBy: aBlockOrSelector slotClass: CatFSVirtualSlot</body><body package="COFramesystem">slotComputedBy: aBlockOrSelector slotClass: slotClass 	| composingMethod |	composingMethod := aBlockOrSelector isSymbol 			ifTrue: [ 				[: frame | frame perform: aBlockOrSelector ]			]			ifFalse: [ 				aBlockOrSelector 			].	^ slotClass computedBy: composingMethod</body><body package="COFramesystem">slotComputedEagerBy: aBlockOrSelector 	^ self slotComputedBy: aBlockOrSelector slotClass: CatFSEagerVirtualSlot</body><body package="COFramesystem">slotOfType: aType 	| slot |	slot := self slotClass newPrototypeOfType: aType.	slot definition definedBy: self.	^ slot</body><body package="COFramesystem">slotSingleValue	^self slotOfType: #singleValue</body><body package="COFramesystem">virtualSlotOfType: aType 	^CatFSVirtualSlot newPrototypeOfType: aType.</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>prototype</category><body package="COFramesystem">initializePrototype	self initializeSlotDescription.</body><body package="COFramesystem">prototype: aCatFSVirtualFrame	prototype := aCatFSVirtualFrame</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>prototype accessing</category><body package="COFramesystem">prototypeNeeded	prototype isNil ifTrue: [self initializePrototype].	^prototype</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>private</category><body package="COFramesystem">newWithClusteringBlock: clusteringBlock	"create a new model instance in aCluster"	| newFrame |	self prototype isNil ifTrue: [self initializePrototype].	newFrame := self prototype coastSpawn.	newFrame makeShared.	clusteringBlock value: newFrame.	"add the frame before calling initialize!	otherwise information may be missing during initialize. CS0900"	newFrame initializeFrameAndSlots.	^newFrame</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>slot description</category><body package="COFramesystem">coastInternalReferencedBySlot	^ ( self slotOfType: #set )		doNotCopy;		range: CatFSFrame;		yourself</body><body package="COFramesystem">coastNameSlot	^ ( self slotSingleValue )		range: String;		doNotCopy;		addDemon: CatFSCoastNameDemon new;		yourself</body><body package="COFramesystem">crossVolumeReferredBySlot	^(self slotOfType: #set)		doNotCopy;		range: String.</body></methods><methods><class-id>COAST.CatFSFrame class</class-id> <category>slots</category><body package="COTransactions">localBlockCacheSlot	^ (self slotOfType: #dictionary)</body></methods><methods><class-id>COAST.CatFSVirtualFrame</class-id> <category>accessing</category><body package="COTransactions">referencedClusterIDsSkip: skipFrames 	| result |	result := Set new.	( skipFrames includes: self ) ifFalse: 		[	skipFrames add: self.			self slots do: [: s | result addAll: ( s referencedClusterIDsSkip: skipFrames )]		].	^ result</body></methods><methods><class-id>COAST.CatFSVirtualFrame class</class-id> <category>testing</category><body package="COFramesystem">isVirtual	^true</body></methods><methods><class-id>COAST.CoastEagerObserver</class-id> <category>computing</category><body package="COEagerObservers">computeEagerObserverSlot	"this method should compute a value by reading all values I have to observe"</body></methods><methods><class-id>COAST.CoastEagerObserver</class-id> <category>startup -shutdown</category><body package="COEagerObservers">prepareForDebugging	"a debugger is about to pop up"</body><body package="COEagerObservers">shutDown	"override (extend) this method to do any shutDown operation right before de-install	(which will happen latest before Coast shutDown)"	| slot |	slot := (self slotNamed: #coastEagerObserverSlot).	slot notNil ifTrue: [ slot computedLazy; release ].</body><body package="COEagerObservers">startUp	"override this method to initialize me after install"</body></methods><methods><class-id>COAST.CoastEagerObserver</class-id> <category>testing</category><body package="COEagerObservers">isInterestsObserver	^false</body></methods><methods><class-id>COAST.CoastEagerObserver</class-id> <category>accessing</category><body package="COEagerObservers">localAppModels	^ #( )</body></methods><methods><class-id>COAST.CoastEagerObserver class</class-id> <category>slot description</category><body package="COEagerObservers">coastEagerObserverSlotSlot	^ self slotComputedEagerBy: [: frame | frame computeEagerObserverSlot ]</body></methods><methods><class-id>COAST.CoastEagerDifferencesObserver</class-id> <category>actions</category><body package="COEagerObservers">added: addedSet removed: removedSet	"my computed slot has changed, here are the differences to the old value"	self subclassResponsibility</body></methods><methods><class-id>COAST.CoastEagerDifferencesObserver class</class-id> <category>slots</category><body package="COEagerObservers">coastEagerObserverSlotSlot	^super coastEagerObserverSlotSlot		onDifferencesRead: [:frame :added :removed | frame added: added removed: removed ].</body></methods><methods><class-id>COAST.CoastDifferencesProcessingObserver</class-id> <category>actions</category><body package="COEagerObservers">added: addedSet removed: removedSet	addedSet do: [ :e |  requestQueue nextPut: e ]</body><body package="COEagerObservers">processRequest: aRequest	^ true</body></methods><methods><class-id>COAST.CoastDifferencesProcessingObserver</class-id> <category>startup -shutdown</category><body package="COEagerObservers">catchUp		(self at: #coastEagerObserverSlot) copy do: [ :e | requestQueue nextPut: e ]</body><body package="COEagerObservers">initializeFrame	super initializeFrame.	requestQueue := SharedQueue new.</body><body package="COEagerObservers">requestBlock	^ [	| r |		[ r := requestQueue next.		  r ~~ #stopProcessing and: [ self processRequest: r ]		] whileTrue	]</body><body package="COEagerObservers">shutDown	| doSuspend count |	requestProcess notNil ifTrue: 		[	doSuspend := requestProcess ~~ Processor activeProcess.	"do not suspend self"			requestQueue patchQueueForStop.			Processor yield.	"give it a chance to terminate immidiately"			count := 10.	"give it another 10 chances with waiting"			[ count &gt; 0 and: [ requestQueue isEmpty not ]] whileTrue: 				[( Delay forMilliseconds: 200 ) wait.					count := count - 1				].			"if it is still there terminate it"			( requestQueue isEmpty not and: [ doSuspend ]) ifTrue: [ requestProcess terminate ]		].	requestProcess := nil.	super shutDown.</body><body package="COEagerObservers">startUp	super startUp.	requestProcess :=		[ self requestBlock value ] fork</body></methods><methods><class-id>COAST.CoastEagerBlockObserver</class-id> <category>observer</category><body package="COEagerObservers">added: addedSet removed: removedSet	updateBlock value: addedSet value: removedSet</body><body package="COEagerObservers">computeEagerObserverSlot	^ observeBlock value</body></methods><methods><class-id>COAST.CoastEagerBlockObserver</class-id> <category>accessing</category><body package="COEagerObservers">observeBlock: anObserveBlock updateBlock: anUpdateBlock 	observeBlock := anObserveBlock.	updateBlock := anUpdateBlock.</body><body package="COEagerObservers">shutDownBlock	^ shutDownBlock</body><body package="COEagerObservers">shutDownBlock: aShutDownBlock 	shutDownBlock := aShutDownBlock.</body></methods><methods><class-id>COAST.CoastEagerBlockObserver</class-id> <category>startup -shutdown</category><body package="COEagerObservers">shutDown	super shutDown.	self shutDownBlock notNil 		ifTrue: [ 			[				[ self shutDownBlock value ] valueWithinSeconds: 3 orDo: [ CoastError raiseSignal: 'Timeout' ].			] on: Error do: [  : ex |				CoastLog logWarning: 'Shutdown of observer failed: ', ex description.			]		].</body></methods><methods><class-id>COAST.CoastEagerBlockObserver class</class-id> <category>instance creation</category><body package="COEagerObservers">observeBlock: anObserveBlock updateBlock: anUpdateBlock 	^ ( self new ) 		observeBlock: anObserveBlock updateBlock: anUpdateBlock;		startUp;		yourself</body><body package="COEagerObservers">transactionManager: transactionManager observeBlock: anObserveBlock updateBlock: anUpdateBlock 	| observer |	observer := self new.	observer observeBlock: anObserveBlock updateBlock: anUpdateBlock.	transactionManager installEagerObserver: observer.	^ observer.</body><body package="COEagerObservers">transactionManager: transactionManager observeBlock: anObserveBlock updateBlock: anUpdateBlock  shutDownBlock: shutDownBlock 	| observer |	observer := self new.	observer observeBlock: anObserveBlock updateBlock: anUpdateBlock.	observer shutDownBlock: shutDownBlock .	transactionManager installEagerObserver: observer.	^ observer.</body></methods><methods><class-id>COAST.HuffmanString class</class-id> <category>accessing</category><body package="COMarshalling">baseClass	self subclassResponsibility.</body><body package="COMarshalling">marshallID	self subclassResponsibility</body></methods><methods><class-id>COAST.HuffmanString class</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinary: string to: stream marshaller: aCatRMMarshall 	stream nextPut: self marshallID.	stream nextOptimized32Put: string size.	HuffmanStringCodec encode: string on: stream.	^ string</body><body package="COMarshalling">unmarshallBinaryFrom: stream marshaller: aCatRMMarshall 	| length string |	length := stream nextOptimized32.	string := self baseClass new: length.	HuffmanStringCodec decode: string from: stream.	^ string</body></methods><methods><class-id>COAST.HuffmanByteString class</class-id> <category>accessing</category><body package="COMarshalling">baseClass	^ ByteString</body><body package="COMarshalling">marshallID	^ 26</body></methods><methods><class-id>COAST.HuffmanSymbol class</class-id> <category>accessing</category><body package="COMarshalling">marshallID	^ 28</body><body package="COMarshalling">unmarshallBinaryFrom: stream marshaller: aCatRMMarshall 	^ ( super unmarshallBinaryFrom: stream marshaller: aCatRMMarshall ) asSymbol</body></methods><methods><class-id>COAST.CatMAMarshallBinary</class-id> <category>indexing</category><body package="COMarshalling">frameClassSymbolAt: anInteger	^(self frameSlotIndexForIndex: anInteger) frameClassSymbol</body><body package="COMarshalling">frameIndexAt: aSymbolOrClass	| fsi |	fsi := self frameSlotIndexForSymbol: aSymbolOrClass.	^fsi isNil ifTrue: [ 0 ] ifFalse: [ fsi key ]</body><body package="COMarshalling">frameKeyAt: anInteger	^(self frameSlotIndexForIndex: anInteger) frameKey</body><body package="COMarshalling">frameSlotIndexForIndex: anInteger	^ self clusterManager frameSlotIndexForIndex: anInteger</body><body package="COMarshalling">frameSlotIndexForSymbol: aSymbolOrClass	^self clusterManager frameSlotIndexForSymbol: aSymbolOrClass</body></methods><methods><class-id>COAST.CatMAMarshallBinary</class-id> <category>marshalling</category><body package="COMarshalling">marshall: anObject to: aStream	anObject marshallBinaryTo: aStream marshaller: self.</body><body package="COMarshalling">marshallValue: aValue to: aStream 	aValue marshallBinaryValueTo: aStream marshaller: self.</body><body package="COMarshalling">readFrameClassSymbolFrom: aStream 	^ self readFrameClassSymbolFrom: aStream ifOldStyleDo: [ ]</body><body package="COMarshalling">readFrameClassSymbolFrom: aStream ifOldStyleDo: aBlock 	| idx |	idx := aStream next.	^idx = 0 		ifTrue: 		[ | string |			aBlock value.	"hook"			string := aStream nextShortString.			( string includes: $. ) 				ifTrue: [ string asSymbol ]				ifFalse: [ self clusterManager withNameSpaceFrom: string ]		]		ifFalse: 		[	idx = 255 ifTrue: [ idx := aStream next16 ].			self frameClassSymbolAt: idx		]</body><body package="COMarshalling">readFrameKeyFrom: aStream	^self		readFrameKeyFrom: aStream		ifOldStyleDo: []</body><body package="COMarshalling">readFrameKeyFrom: aStream ifOldStyleDo: aBlock 	| idx |	idx := aStream next.	^idx = 0 		ifTrue: 		[ | string |			aBlock value.	"hook"			string := aStream nextShortString.			( string includes: $. ) 				ifTrue: [ string asSymbol ]				ifFalse: [ self clusterManager withNameSpaceFrom: string ]		]		ifFalse: 		[	idx = 255 ifTrue: [ idx := aStream next16 ].			self frameKeyAt: idx		].</body><body package="COMarshalling">readSlotNameFrom: aStream withIndex: frameSlotIndex	^ self readSlotNameFrom: aStream withIndex: frameSlotIndex ifOldStyleDo: nil</body><body package="COMarshalling">readSlotNameFrom: aStream withIndex: frameSlotIndex ifOldStyleDo: aBlock 	"new (&gt;= 4.4) style encoding"	^ frameSlotIndex isNil 		ifTrue: 		[	aStream next.			aStream nextShortString asSymbol		]		ifFalse: 		[ | idx |			idx := aStream next.			idx = 0 				ifTrue: 				[	aBlock value.					aStream nextShortString asSymbol				]				ifFalse: [ frameSlotIndex slotAtIndex: idx ]		]</body><body package="COMarshalling">slotIndexFor: aSymbol frame: aFrame 	| fsi |	^ slotToNumberDict at: ( Array with: aFrame coastFrameDictKey with: aSymbol )		ifAbsentPut: 		[	fsi := self frameSlotIndexForSymbol: aFrame frameClassSymbol.			fsi isNil 				ifTrue: [ 0 ]				ifFalse: [ fsi slotIndexFor: aSymbol ]		]</body><body package="COMarshalling">stringLengthFrom: aStream	^self loadCoastVersion major &gt;= 4		ifTrue: [ aStream nextCoastStringLength ]		ifFalse: [ aStream oldNextCoastStringLength ].</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream	| argumentType |	argumentType := aStream next.	argumentType = CatFSFrameID marshallID ifTrue: 		[	" Frame ID "			^ CatFSFrameID unmarshallBinaryArgumentFrom: aStream marshaller: self		].	argumentType = CatFSFrameReference marshallID ifTrue: 		[	"External Frame definition "			^ CatFSFrameReference unmarshallBinaryArgumentFrom: aStream marshaller: self		].	argumentType = CatCSFrameLocator marshallID ifTrue: 		[	"External Frame locator i.e. short/lightweight ref "			^ CatCSFrameLocator unmarshallBinaryArgumentFrom: aStream marshaller: self		].	argumentType = CatCSCollection marshallID ifTrue: 		[	"a wrapped collection"			^ CatCSCollection unmarshallBinaryArgumentFrom: aStream marshaller: self.		].	" primitive object "	^ self unmarshallPrimitive: argumentType from: aStream morph: nil</body><body package="COMarshalling">unmarshallPrimitive: primitiveIndex from: aStream morph: morphSelector	" Unmarshall a primitive value from a stream "	| aClass actualClass |	" the smallest ID is zero so must add 1 "	aClass := self class primitivesArray at: primitiveIndex + 1.	^ aClass notNil		ifTrue: [ 			actualClass := morphSelector notNil				ifTrue: [ aClass perform: morphSelector ]				ifFalse: [ aClass ].			actualClass unmarshallBinaryFrom: aStream marshaller: self ]		ifFalse: [			self error: 'Unmarshall error: Unsupported value type ', primitiveIndex printString, 					'. Only COAST standard types can be unmarshalled'.			nil		]</body><body package="COMarshalling">unmarshallPrimitiveValueFrom: aStream 	^ self unmarshallValueFrom: aStream morph: nil</body><body package="COMarshalling">unmarshallValueFrom: aStream morph: morphSelector 	" Unmarshall a value from a stream. If the cluster is nil,	only primitives can be unmarshalled  "	| index |	index := aStream next.	index = CatFSFrameID marshallID ifTrue: [ ^ CatFSFrameID unmarshallBinaryReferenceFrom: aStream marshaller: self ].	index = CatCSFrameLocator marshallID ifTrue: [ ^ CatCSFrameLocator unmarshallBinaryReferenceFrom: aStream marshaller: self ].	index = CatFSFrameReference marshallID ifTrue: [ ^ CatFSFrameReference unmarshallBinaryReferenceFrom: aStream marshaller: self ].	" it seems to be a primitive "	^ self unmarshallPrimitive: index from: aStream morph: morphSelector</body><body package="COMarshalling">writeFrameClassSymbol: aSymbolOrClass to: aStream	| idx s |	idx := self frameIndexAt: aSymbolOrClass.	idx &gt; 254		ifTrue: [ aStream nextPut: 255. aStream next16Put: idx ]		ifFalse: [ aStream nextPut: idx ].	idx = 0 		ifTrue: [			s := aSymbolOrClass isCharacters				ifTrue: [ aSymbolOrClass asString ]				ifFalse: [ aSymbolOrClass frameClassName ].			aStream nextShortStringPut: s		].</body><body package="COMarshalling">writeSlotName: aSymbol frame: aFrame to: aStream 	| idx |	idx := self slotIndexFor: aSymbol frame: aFrame.	aStream nextPut: idx.	idx = 0 ifTrue: [ aStream nextShortStringPut: aSymbol asString ].</body><body package="COMarshalling">writeSlotName: aSymbol frameSlotIndex: frameSlotIndex to: aStream 	| idx |	idx := frameSlotIndex isNil 			ifTrue: [ 0 ]			ifFalse: [ frameSlotIndex slotIndexFor: aSymbol ].	aStream nextPut: idx.	idx = 0 ifTrue: [ aStream nextShortStringPut: aSymbol asString ].	^ idx</body></methods><methods><class-id>COAST.CatMAMarshallBinary</class-id> <category>accessing</category><body package="COMarshalling">clusterManager	^ clusterManager</body><body package="COMarshalling">clusterManager: aClusterManager	clusterManager := aClusterManager</body><body package="COMarshalling">currentClusterID	^ currentClusterID</body><body package="COMarshalling">currentClusterID: aCatCSClusterID 	currentClusterID notNil ifTrue: 		[	currentClusterID = aCatCSClusterID 				ifTrue: [ self haltOrContinue: 'cluster id unnÃ¶tig mehrfach eingetragen' ]				ifFalse: [ "CoastError raiseSignal:" self haltOrContinue:  'marshaller must be dedicated to only one cluster for lifetime' ]		].	currentClusterID := aCatCSClusterID.</body><body package="COMarshalling">loadCoastVersion	^ CoastVersion defaultCoastVersion</body><body package="COMarshalling">saveMagicWord	" magic word used for saving "	^ 'COAST'</body><body package="COMarshalling">storageInterface	^ self clusterManager storageInterface</body><body package="COMarshalling">supportsLazyUnmarshalling	| storageInterface |	(self loadCoastVersion isMin: 4 minor: 14 ) ifFalse: [ ^ false ].	self clusterManager supportsLazyUnmarshalling ifFalse: [ ^ false ].	storageInterface := self storageInterface.	^ storageInterface isNil or: [ storageInterface supportsLazyUnmarshalling ]</body><body package="COMarshalling">tempBytesDo: aBlock	" do not allocate ByteArrays all the time, instead use a pool of ByteArrays "	self clusterManager tempBytesPool tempBytesDo: aBlock</body><body package="COMarshalling">volumeManager: aCatCSVolumeManager volume: aVolume 	clusterManager isNil 		ifTrue: [ clusterManager := aCatCSVolumeManager clusterManagerForVolume: aVolume ]		ifFalse: 		[	aVolume = clusterManager volume 				ifFalse: [ CoastLog logWarning: 'unmarshalling volume conflict: ' , clusterManager volume , ' does not match: ' , aVolume ]		].</body><body package="COMarshalling">wasLoadedFromOldCoastVersion	^ false</body></methods><methods><class-id>COAST.CatMAMarshallBinary</class-id> <category>marshalling - RLE</category><body package="COMarshalling">optimized32Marshall: array to: aStream 	"the integers are sorted and zero or positive"	"use -1 to introduce the count of repeated previous integers"	" [ 0 0 0 0 0 4 ] ==&gt; [ 0 -1 5 4 ]"	" [ 0 0 0 0 5 ] ==&gt; [ 0 -1 4 5 ] "	" [ 0 0 4 5 ] ==&gt; [ 0 0 4 5 ] "	| last count |	last := nil.	count := 0.	1 to: array size		do: 		[: index | | current |			current := array at: index.			current = last 				ifTrue: [ count := count + 1 ]				ifFalse: 				[	0 = count ifFalse: 						[	1 = count 								ifTrue: [ aStream nextOptimized32Put: last ]								ifFalse: 								[	aStream nextOptimized32Put: -1.									aStream nextOptimized32Put: count								].							count := 0						].					aStream nextOptimized32Put: current.					last := current				]		].	0 = count ifFalse: 		[	1 = count 				ifTrue: [ aStream nextOptimized32Put: last ]				ifFalse: 				[	aStream nextOptimized32Put: -1.					aStream nextOptimized32Put: count				]		].</body><body package="COMarshalling">optimized32Unmarshall: array from: aStream 	"the integers are sorted and zero or positive"	"use -1 to introduce the count of repeated previous integers"	" [ 0 -1 5 4 ] ==&gt; [ 0 0 0 0 0 4 ]"	" [ 0 -1 4 5 ] ==&gt; [ 0 0 0 0 5 ]"	" [ 0 0 4 5 ] ==&gt; [ 0 0 4 5 ]"	| index previous |	previous := nil.	index := 0.	[ index = array size ] whileFalse: 		[ | probe count |			probe := aStream nextOptimized32.			( previous notNil and: [ -1 = probe ]) 				ifTrue: 				[	count := aStream nextOptimized32.	"except clusterID to be a storeable in two byte"					index + 1 to: index + count do: [: i | array at: i put: previous ].					previous := nil.					index := index + count				]				ifFalse: 				[	index := index + 1.					array at: index put: probe.					previous := probe				]		].</body><body package="COMarshalling">optimizedMarshall: array to: aStream 	"the objects are run length encoded using CatMARepeatedObjects"	| last count |	last := nil.	count := 0.	1 to: array size		do: 		[: index | | current |			current := array at: index.			( last == current or: [ last = current ]) 				ifTrue: [ count := count + 1 ]				ifFalse: 				[	count = 0 ifFalse: 						[	self marshallValue: ( CatMARepeatedObject fromCount: count ) to: aStream.							count := 0						].					self marshallValue: current to: aStream.					last := current				]		].	count = 0 ifFalse: 		[	last isNil ifTrue: [ self noObjectToRepeatError ].			self marshallValue: ( CatMARepeatedObject fromCount: count ) to: aStream		].</body><body package="COMarshalling">optimizedUnmarshall: array from: aStream morph: morphSelector 	"the objects are run length encoded using CatMARepeatedObjects"	| index previous |	previous := nil.	index := 0.	[ index = array size ] whileFalse: 		[ | probe count |			probe := self unmarshallValueFrom: aStream morph: morphSelector.			probe isCoastOptimizedInteger 				ifTrue: 				[	previous notNil ifFalse: [ self noObjectToRepeatError ].					count := probe asInteger.					index + 1 to: index + count do: [: i | array at: i put: previous ].					previous := nil.					index := index + count				]				ifFalse: 				[	index := index + 1.					array at: index put: probe.					previous := probe				]		].</body></methods><methods><class-id>COAST.CatMAMarshallBinary</class-id> <category>marshalling - frames</category><body package="COMarshalling">unmarshallBinaryFrame: frame from: stream 	( self loadCoastVersion isMin: 4 minor: 3 ) ifFalse: [ ^ frame unmarshallFromStream: stream ].	self supportsLazyUnmarshalling ifFalse: 		[	stream nextOptimized32.			^ frame unmarshallFromStream: stream		].	^ frame unmarshallByteArrayFrom: stream</body></methods><methods><class-id>COAST.CatMAMarshallBinary</class-id> <category>marshalling - cluster</category><body package="COMarshalling">marshallClusterBody: aCluster to: aStream 	"only save coast 5"	"save clusterInfo &amp; header into tempBytes -&gt; enables bfs to supply low fragmentated cluster files"	clusterManager := aCluster clusterManager.	self tempBytesDo: 		[: clusterBytes | | clsStream frames |			clsStream := clusterBytes writeStream.			" save cluster info "			aCluster marshallBinaryClusterInfoTo: clsStream marshaller: self.			"save the header"			aCluster marshallBinaryHeaderTo: clsStream marshaller: self.			"save the body "			frames := aCluster cellValue values asArray.			"marshall all frame declarations"			self preWriteFrameTable: frames to: clsStream.			"look ahead tables: an obsolete feature for classic volumes + local client only.			patch look ahead table for old 5.2. current 5.2 will allways ignore these			5.3 will not save these numbers any more"			"marshall all frames"			1 to: frames size do: [: i | ( frames at: i ) marshallBinaryTo: clsStream marshaller: self ].			COAST.CoastHashStream hashOf: clusterBytes stream: clsStream.			aCluster approxByteSize: clsStream size.			aStream next: clsStream size putAll: clusterBytes startingAt: 1		].</body><body package="COMarshalling">preWriteFrameTable: frameArray to: aStream 	"store the number of frames in the cluster"	aStream nextOptimized32Put: frameArray size.	"store enough information to declare all frames - remember start postions"	frameArray do: 		[: frame |			aStream nextOptimized32Put: frame id.			self writeFrameClassSymbol: frame coastFrameDictKey to: aStream			" 5.x stores frame position "		].</body></methods><methods><class-id>COAST.CatMAMarshallBinary</class-id> <category>marshalling - optimized</category><body package="COMarshalling">nextOptimizedCoastString: string to: stream 	"( self huffmanCodec shouldCompress: string ) " false		ifTrue: [ string asCoastString marshallHuffmanBinaryTo: stream marshaller: self ]		ifFalse: [ string asCoastString defaultMarshallBinaryTo: stream marshaller: self ].</body></methods><methods><class-id>COAST.CatMAMarshallBinary</class-id> <category>private</category><body package="COMarshalling">noObjectToRepeatError	self haltOrContinue.	CoastFatalError raiseSignal: 'no object to repeat'</body></methods><methods><class-id>COAST.CatMAMarshallBinary</class-id> <category>initialize-release</category><body package="COMarshalling">initialize	slotToNumberDict := Dictionary new.</body></methods><methods><class-id>COAST.CatMAMarshallBinary class</class-id> <category>accessing</category><body package="COMarshalling">blobExtension	^ '.clb'</body><body package="COMarshalling">clusterExtension	^ '.cls'</body></methods><methods><class-id>COAST.CatMAMarshallBinary class</class-id> <category>instance creation</category><body package="COMarshalling">new	^ super new initialize</body></methods><methods><class-id>COAST.CatMAMarshallBinary class</class-id> <category>primitive classes</category><body package="COMarshalling">flushPrimitivesArray	PrimitiveClasses := nil.</body><body package="COMarshalling">obsolete	PrimitiveClasses := nil.	^ super obsolete</body><body package="COMarshalling">primitiveClassWithMarshallID: marshallID	^ self primitivesArray at: marshallID + 1</body><body package="COMarshalling">primitivesArray	PrimitiveClasses isNil ifTrue: [ self initializePrimitivesArray ].	^ PrimitiveClasses</body></methods><methods><class-id>COAST.ClusterUnmarshaller</class-id> <category>marshalling - cluster</category><body package="COMarshalling">readFrameTable4xFor: aCluster from: aStream 	| numberOfFrames frames cm |	numberOfFrames := aStream nextOptimized32.	aCluster valueHolder: ( aCluster valueHolderClass new: ( numberOfFrames * 1.3 ) truncated ).	frames := Array new: numberOfFrames.	cm := self clusterManager.	1 to: numberOfFrames		do: 		[: indx | | frame |			frame := self unmarshallEmptyFrame4xFrom: aStream cluster: aCluster clusterManager: cm.			frames at: indx put: frame		].	^ frames</body><body package="COMarshalling">readFrameTable5xFor: aCluster from: aStream 	| numberOfFrames frames cm |	numberOfFrames := aStream nextOptimized32.	aCluster valueHolder: ( aCluster valueHolderClass new: ( numberOfFrames * 1.3 ) truncated ).	frames := Array new: numberOfFrames.	cm := self clusterManager.	1 to: numberOfFrames		do: 		[: indx | | frameStub |			frameStub := self unmarshallEmptyFrame5xFrom: aStream cluster: aCluster clusterManager: cm lazy: false.			frames at: indx put: frameStub		].	" position is stored relative to beginning of frames block "	^ frames</body><body package="COMarshalling">unmarshallClusterBody4x: aCluster from: aStream 	| frames startTime oldPos elapsedTime cm |	elapsedTime := Time millisecondsToRun: 			[	oldPos := aStream position.				clusterController cluster: aCluster.				cm := self clusterManager.				self unmarshallSymbolsFrom: aStream.				"unmarshall frame declarations"				startTime := Time millisecondClockValue.				frames := self readFrameTable4xFor: aCluster from: aStream.				"unmarshall all frames"				frames do: [: frame | frame unmarshallBinaryFrom: aStream marshaller: self ].				cm volumeManager currentLoadedClusterID: nil			].	CoastLog logDebug: 		[	'Loaded cluster ' , aCluster id printString , ' (time: ' , elapsedTime printString , ', ' , ' frames: ' 				, frames size printString , ',  kBps: ' 				, (( aStream position - oldPos ) / ( Time millisecondClockValue - startTime max: 1 ) / 1.024 ) rounded printString , ')'		]</body><body package="COMarshalling">unmarshallClusterBody5x: aCluster from: aStream 	| frames startTime oldPos elapsedTime cm |	elapsedTime := Time millisecondsToRun: 			[	oldPos := aStream position.				clusterController cluster: aCluster.				cm := self clusterManager.				self unmarshallSymbolsFrom: aStream.				"unmarshall frame declarations"				startTime := Time millisecondClockValue.				frames := self readFrameTable5xFor: aCluster from: aStream.				"unmarshall all frames"				frames do: [: frame | frame unmarshallBinaryFrom: aStream marshaller: self ].				cm volumeManager currentLoadedClusterID: nil			].	CoastLog logDebug: 		[	'Loaded cluster ' , aCluster id printString , ' (time: ' , elapsedTime printString , ', ' , ' frames: ' , frames size printString 				, ',  kBps: ' , (( aStream position - oldPos ) / ( Time millisecondClockValue - startTime max: 1 ) / 1.024 ) rounded printString 				, ')'		].</body><body package="COMarshalling">unmarshallClusterBody: aCluster from: aStream 	( self loadCoastVersion isMin: 5 minor: 0 ) 		ifTrue: [ self unmarshallClusterBody5x: aCluster from: aStream ]		ifFalse: [ self unmarshallClusterBody4x: aCluster from: aStream ]</body></methods><methods><class-id>COAST.ClusterUnmarshaller</class-id> <category>accessing</category><body package="COMarshalling">clusterController	^clusterController</body><body package="COMarshalling">clusterController: aCC	clusterController := aCC</body><body package="COMarshalling">clusterManager	^ super clusterManager ifNil: [ clusterController clusterManager ]</body><body package="COMarshalling">lazyLoad	"das muss hÃ¼bscher gemacht werden"	^clusterController lazyLoad</body><body package="COMarshalling">loadCoastVersion	" coast version used for loading "	^ loadCoastVersion ifNil: [ loadCoastVersion := CoastVersion defaultCoastVersion ]</body><body package="COMarshalling">loadCoastVersion: aCoastVersion 	" set the coast version used for loading "	( aCoastVersion notNil and: [ aCoastVersion isFutureCoastVersion ]) 		ifTrue: [ CoastFatalError raiseSignal: 'unknown COAST version ' , aCoastVersion printString ].	loadCoastVersion := aCoastVersion.	(loadCoastVersion isMin: 4 minor: 4) ifFalse: [ self changeClassTo: ClusterUnmarshallerPre44 ].</body><body package="COMarshalling">loadMagicWord: aString 	" set the magic word used for loading "	'COAST' = aString ifFalse: 		[	"be paranoid"			CoastFatalError raiseSignal: 'magic word &gt;COAST&lt; expected!'		].</body><body package="COMarshalling">verifyCoastHashOn: stream 	(clusterController notNil and: [ clusterController lazyLoad ]) ifTrue: [ ^ self	"cluster not fully loaded" ].	( self loadCoastVersion isMin: 5 minor: 2 ) ifFalse: [ ^ self	"old style cluster" ].	stream verifyCoastHash ifTrue: [ ^ self	"hash match" ].	"1 = 2 ifTrue: [ ^ self clusterController modified: true ]."	self haltOrContinue.	CoastFatalError raiseSignal: 'coast hash failed'.</body><body package="COMarshalling">wasLoadedFromOldCoastVersion	" coast version used for loading "	^ loadCoastVersion notNil and: [ loadCoastVersion ~= CoastVersion defaultCoastVersion ]</body></methods><methods><class-id>COAST.ClusterUnmarshaller</class-id> <category>symbol handling</category><body package="COMarshalling">unmarshallSymbolsFrom: aStream</body></methods><methods><class-id>COAST.ClusterUnmarshaller</class-id> <category>marshalling - frames</category><body package="COMarshalling">unmarshallEmptyFrame4xFrom: aStream cluster: aCluster clusterManager: cm 	| frameID frame frameKey |	frameID := aStream nextOptimized32.	frameKey := self readFrameKeyFrom: aStream ifOldStyleDo: [ clusterController notNil ifTrue: [ clusterController oldStyleFrameDetected ]].	frame := cm getFrameForLoading: frameID clusterID: aCluster id frameKey: frameKey.	aCluster directTableAccessAt: frameID put: frame.	frame cellContainer: aCluster.	frame id: frameID.	^ frame</body><body package="COMarshalling">unmarshallEmptyFrame5xFrom: aStream cluster: aCluster clusterManager: cm lazy: loadLazy 	| frame |	frame := self unmarshallEmptyFrame4xFrom: aStream cluster: aCluster clusterManager: cm.	" position - not needed in this case "	( self loadCoastVersion isMin: 5 minor: 3 ) ifFalse: [ aStream nextOptimized32	"old style: relative position" ].	^ frame</body></methods><methods><class-id>COAST.ClusterUnmarshaller</class-id> <category>load / save</category><body package="COMarshalling">loadCluster: clusterIDInteger fromStore: aStorageInterface 	| clusterReadStream |	clusterReadStream := aStorageInterface 				readStreamOnCluster: clusterIDInteger.	^ clusterReadStream isNil 		ifTrue: [nil]		ifFalse: [			[ | cl |				cl := self loadClusterFromStream: clusterReadStream.				cl approxByteSize: (aStorageInterface storageSizeForCluster: clusterIDInteger).				cl			] ensure: [clusterReadStream close]		]</body><body package="COMarshalling">loadClusterFromStream: aStream 	" load the cluster from the stream "	^  CatCSCluster loadFromStream: aStream marshaller: self.</body></methods><methods><class-id>COAST.ClusterUnmarshaller</class-id> <category>marshalling</category><body package="COMarshalling">readFrameClassSymbolFrom: aStream	^self		readFrameClassSymbolFrom: aStream		ifOldStyleDo: 		[	clusterController notNil 				ifTrue: [ clusterController oldStyleFrameDetected ] 		]</body><body package="COMarshalling">readFrameKeyFrom: aStream	^self		readFrameKeyFrom: aStream		ifOldStyleDo: 		[	clusterController notNil 				ifTrue: [ clusterController oldStyleFrameDetected ] 		]</body></methods><methods><class-id>COAST.ClusterUnmarshallerPre44</class-id> <category>symbol handling</category><body package="COMarshalling">symbolAtIndex: anInteger 	^symbolTable at: anInteger</body><body package="COMarshalling">unmarshallSymbolsFrom: aStream 	" coast 2.2 or higher: load index to frame class names and slot symbols "	(self loadCoastVersion isMin: 4 minor: 4) ifTrue: [ ^nil ].	(self loadCoastVersion isMin: 2 minor: 2) 		ifTrue: 			[| tableSize |			tableSize := aStream next16.			symbolTable := Array new: tableSize.			1 to: tableSize				do: 					[:idx | 					| slotName |					slotName := Symbol unmarshallBinaryFrom: aStream marshaller: self.					symbolTable at: idx put: slotName]]</body></methods><methods><class-id>COAST.ClusterUnmarshallerPre44</class-id> <category>marshalling</category><body package="COMarshalling">readFrameClassSymbolFrom: aStream ifOldStyleDo: aBlock	^self symbolAtIndex: aStream next16.</body><body package="COMarshalling">readFrameKeyFrom: aStream ifOldStyleDo: aBlock 	^ self symbolAtIndex: aStream next16</body><body package="COMarshalling">readSlotNameFrom: aStream	| idx |	idx := aStream next16.	^ (self symbolAtIndex: idx) asSymbol</body></methods><methods><class-id>COAST.ClusterUnmarshallerPre44</class-id> <category>initialize-release</category><body package="COMarshalling">initialize	super initialize.	symbolTable := OrderedCollection new.</body></methods><methods><class-id>COAST.CatRMMessage</class-id> <category>accessing</category><body package="COMessages">commandID	^42</body><body package="COMessages">messageID	^ messageID</body><body package="COMessages">messageID: anInteger	messageID := anInteger</body><body package="COMessages">receiver	^nil</body><body package="COMessages">receiverPacketStation: aCatCSPacketStation	"Clients of Subclasses might want to remember the packet station"	"these classes can implement this interface"</body><body package="COMessages">receiverVolume	| r |	r := self receiver.	^r isNil		ifTrue: [nil]		ifFalse: [r volume]</body></methods><methods><class-id>COAST.CatRMMessage</class-id> <category>synch</category><body package="COMessages">deliverError	"message has not been delivered correctly"</body><body package="COMessages">delivered	"message has been delivered"</body></methods><methods><class-id>COAST.CatRMMessage</class-id> <category>testing</category><body package="COMessages">isCommand	^false</body><body package="COMessages">isError	"false by default"	^false</body><body package="COMessages">isInterruptMessage	^false</body><body package="COMessages">isRequest	^ false</body><body package="COMessages">isResponse	^false</body><body package="COMessages">needsChecksum	^ self isCommand not</body><body package="COMessages">transportsCluster	^false</body></methods><methods><class-id>COAST.CatRMMessage</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryHeaderTo: aStream marshaller: aCatRMMarshall	aStream nextCoastStringPut: self messageClassName.	CoastVersion defaultCoastVersion marshallBinaryTo: aStream marshaller: aCatRMMarshall.	 aStream nextPut: self messageID</body><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall	"subclasses transporting arguments in a message should override this method"</body><body package="COMessages">messageClassName	^self class name asString</body><body package="COMessages">prepareMarshaller: marshaller volumeManager: volumeManager</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	"subclasses transporting arguments in a message should override this method"</body></methods><methods><class-id>COAST.CatRMMessage</class-id> <category>printing</category><body package="COMessages">printString	^ [ super printString ] on: Error		do: 		[: ex | | stream |			stream := String new writeStream.			stream nextPutAll: 'Error while printing '.			self basicPrintOn: stream.			stream contents		]</body></methods><methods><class-id>COAST.CatRMMessage</class-id> <category>execution</category><body package="COMessages">initiateFor: aMessageHandler	"somehow handle the message if this is not a direct response message"	"non-response subclasses must override this method"	self isResponse ifFalse: [ self error: 'No message handler defined for ', self printString ].</body></methods><methods><class-id>COAST.CatRMRequestMessage</class-id> <category>testing</category><body package="COMessages">isRequest	^ true</body></methods><methods><class-id>COAST.CatRMRequestMessage</class-id> <category>accessing</category><body package="COMessages">printOn: stream 	super printOn: stream.	stream nextPutAll: ' receiverPacketStation '.	receiverPacketStation printOn: stream</body><body package="COMessages">receiverPacketStation	^ receiverPacketStation</body><body package="COMessages">receiverPacketStation: aCatCSPacketStation	receiverPacketStation := aCatCSPacketStation</body><body package="COMessages">receiverVolume	^nil</body></methods><methods><class-id>COAST.CatRMClusterRequest</class-id> <category>accessing</category><body package="COMessages">clusterLocator	^clusterLocator</body><body package="COMessages">clusterLocator: aCatCSClusterLocator	clusterLocator := aCatCSClusterLocator</body><body package="COMessages">modificationNumber	^modificationNumber</body><body package="COMessages">modificationNumber: aNumber	modificationNumber:= aNumber</body><body package="COMessages">receiverVolume	^self clusterLocator volume</body></methods><methods><class-id>COAST.CatRMClusterRequest</class-id> <category>printing</category><body package="COMessages">printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ' clusterLocator '.	clusterLocator printOn: aStream</body></methods><methods><class-id>COAST.CatRMClusterRequest</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextUnsigned32Put: self modificationNumber.	self clusterLocator marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self modificationNumber: aStream nextUnsigned32.	self clusterLocator: ( CatCSClusterLocator unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ).</body></methods><methods><class-id>COAST.CatRMClusterRequest class</class-id> <category>instance creation</category><body package="COMessages">clusterLocator: aCatCSClusterLocator withModificationNumber: aNumber	| m |	m := self new.	m clusterLocator: aCatCSClusterLocator.	m modificationNumber: aNumber.	^m</body></methods><methods><class-id>COAST.CatRMResponseMessage</class-id> <category>testing</category><body package="COMessages">isResponse	^true</body></methods><methods><class-id>COAST.CatRMVolumeIDResponse</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextShortStringPut: self volumeID.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self volumeID: aStream nextShortString.</body></methods><methods><class-id>COAST.CatRMVolumeIDResponse</class-id> <category>accessing</category><body package="COMessages">volumeID	^volumeID</body><body package="COMessages">volumeID: aString	volumeID:= aString</body></methods><methods><class-id>COAST.CatRMVolumeIDResponse class</class-id> <category>instance creation</category><body package="COMessages">volumeID: aString	^self new volumeID: aString</body></methods><methods><class-id>COAST.CatRMRPCRequest</class-id> <category>accessing</category><body package="COMessages">arguments	^ arguments</body><body package="COMessages">arguments: newArguments 	arguments := newArguments</body><body package="COMessages">receiverVolume	^ volume</body><body package="COMessages">recipientFrameLocator	^ recipientFrameLocator</body><body package="COMessages">recipientFrameLocator: aFrameLocator 	recipientFrameLocator := aFrameLocator</body><body package="COMessages">selector	^ selector</body><body package="COMessages">selector: newSelector 	selector := newSelector</body><body package="COMessages">slotName	^ slotName</body><body package="COMessages">slotName: aSymbol	slotName := aSymbol</body><body package="COMessages">volume: newVolume 	volume := newVolume</body></methods><methods><class-id>COAST.CatRMRPCRequest</class-id> <category>printing</category><body package="COMessages">printOn: stream 	super printOn: stream.	stream nextPutAll: ' selector '.	selector printOn: stream</body></methods><methods><class-id>COAST.CatRMRPCRequest</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextShortStringPut: volume.	aStream nextShortStringPut: selector asString.	aStream nextOptimized32Put: arguments size.	arguments do: [: arg | arg marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall ].	recipientFrameLocator marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall.	slotName marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall.</body><body package="COMessages">prepareMarshaller: marshaller volumeManager: volumeManager 	marshaller clusterManager: (volumeManager clusterManagerForVolume: volume)</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	volume := aStream nextShortString.	aCatRMMarshall clusterManager: (aCatCSVolumeManager clusterManagerForVolume: volume).	selector := aStream nextShortString asSymbol.	arguments := Array new: aStream nextOptimized32.	1 to: arguments size		do: [: idx | arguments at: idx put: (aCatRMMarshall unmarshallBinaryArgumentFrom: aStream) ].	recipientFrameLocator := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.	slotName := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream</body></methods><methods><class-id>COAST.CatRMRPCRequest class</class-id> <category>instance creation</category><body package="COMessages">recipient: aFrame selector: aSymbol arguments: anArray 	^ ( self new )		volume: aFrame volume;		recipientFrameLocator: aFrame frameLocator;		selector: aSymbol;		arguments: anArray;		yourself</body><body package="COMessages">recipient: aFrame slotName: slotSymbol selector: aSymbol arguments: anArray 	^ ( self new )		volume: aFrame volume;		recipientFrameLocator: aFrame frameLocator;		slotName: slotSymbol;		selector: aSymbol;		arguments: anArray;		yourself</body></methods><methods><class-id>COAST.CatRMClusterForClientMessage</class-id> <category>accessing</category><body package="COMessages">byteArray	^ byteArray</body><body package="COMessages">cluster	cluster isNil		ifTrue: [			"the heavy part: unmarshall the whole cluster"			byteSize := byteArray size.			cluster := marshall loadClusterFromStream: byteArray readStream.			"HS/CS: das sieht lustig aus -&gt; Inverierung in cluster: und clusterController: einbauen (aber Seiteneffekte Ã¼berprÃ¼fen!)"			cluster clusterController cluster: cluster.			cluster clusterController globalSeqNum: self globalSeqNum.			cluster approxByteSize: byteSize.			byteArray := nil.		].	^cluster</body><body package="COMessages">cluster: aCatCSCluster	cluster := aCatCSCluster</body><body package="COMessages">clusterController	^ marshall clusterController</body><body package="COMessages">clusterID	| clusterStub |	^cluster isNil		ifTrue: [			clusterStub := CatCSCluster loadHeaderFromStream: byteArray readStream marshaller: marshall.			clusterStub id.		] ifFalse:  [ cluster id ]</body><body package="COMessages">globalSeqNum	^globalSeqNum</body><body package="COMessages">globalSeqNum: aValue	globalSeqNum := aValue</body></methods><methods><class-id>COAST.CatRMClusterForClientMessage</class-id> <category>testing</category><body package="COMessages">needsChecksum	^ false</body><body package="COMessages">transportsCluster	^true</body></methods><methods><class-id>COAST.CatRMClusterForClientMessage</class-id> <category>printing</category><body package="COMessages">printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ' cluster '.	cluster printOn: aStream</body></methods><methods><class-id>COAST.CatRMClusterForClientMessage</class-id> <category>marshalling</category><body package="COMessages">basicMarshallBinaryTo: aStream marshaller: aCatRMMarshall 	" the message is unprepared "	| wp |	aStream nextUnsigned32Put: globalSeqNum.	" the cluster is marshalled without the volume name, so write the name to	the stream now "	aStream nextShortStringPut: self cluster volume.	wp := aStream writePosition.	self cluster marshallBinaryTo: aStream marshaller: aCatRMMarshall.	clusterByteSize := aStream writePosition - wp.</body><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	( isPrepared ifNil: [ false ]) ifFalse: [ self prepare ].	" clusterByteSize is the core size of the cluster, without volumename, seq.number and piggy size "	aStream nextUnsigned32Put: clusterByteSize.	aStream next: byteSize putAll: byteArray startingAt: 1.</body><body package="COMessages">prepareMarshaller: marshaller volumeManager: volumeManager 	marshaller currentClusterID: self cluster clusterID.	marshaller clusterManager: self cluster clusterManager.</body><body package="COMessages">saveGetByteArrayOnFailDo: block 	| count |	count := 0.	byteArray := nil.	[			[ byteArray := ByteArray new: clusterByteSize ] on: ObjectMemory allocationFailedSignal do: block.		byteArray isNil and: [ count &lt; 10 ]	] whileTrue: 		[	count := count + 1.			CoastLog logError: 'failed (', count displayString ,') to allocate ' , clusterByteSize printString , ' bytes!'		].	byteArray isNil ifTrue: [ byteArray := ByteArray new: clusterByteSize	"pass the allocation failure or succeed" ].</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	| volume cm cc |	clusterByteSize := aStream nextUnsigned32.	self globalSeqNum: aStream nextUnsigned32.	volume := aStream nextShortString.	cm := aCatCSVolumeManager clusterManagerForVolume: volume.	self saveGetByteArrayOnFailDo: [: ex | cm lowSpaceAction ].	aStream next: clusterByteSize into: byteArray startingAt: 1.	marshall := ClusterUnmarshaller new.	cc := cm controllerClass new.	cc clusterManager: cm.	marshall clusterController: cc.</body></methods><methods><class-id>COAST.CatRMClusterForClientMessage</class-id> <category>preparing</category><body package="COMessages">prepare	"marshall the message right now and store the result in the byteArray"	| ws dummyMarshall |	dummyMarshall := CatMAMarshallBinary new.	byteArray := ByteArray new: cluster approxByteSize + 256. " headroom for preamble "	ws := ReadWriteStream on: byteArray.	self basicMarshallBinaryTo: ws marshaller: dummyMarshall.	byteSize := ws writePosition.	ws close.	isPrepared := true.</body></methods><methods><class-id>COAST.CatRMClusterForClientMessage</class-id> <category>execution</category><body package="COMessages">logActionForClusterManager: clusterManager</body></methods><methods><class-id>COAST.CatRMFileTransfer</class-id> <category>accessing</category><body package="COMessages">sourceFile	^sourceFile</body><body package="COMessages">sourceFile: aFilename	sourceFile := aFilename</body><body package="COMessages">sourceSize	^self sourceFile fileSize</body><body package="COMessages">sourceStreamDo: aBlock ifNone: noStreamBlock 	| str |	^ self sourceFile isReadable 		ifTrue: 		[	str := self sourceFile readStream binary.			[ aBlock value: str ] ensure: [ str close ]		]		ifFalse: [ noStreamBlock value ]</body><body package="COMessages">targetStream	^targetStream</body><body package="COMessages">targetStream: aWriteStream	targetStream := aWriteStream</body></methods><methods><class-id>COAST.CatRMFileTransfer</class-id> <category>marshalling</category><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	"size has to be set by the subclass implementation!!"	| byteCount |	byteCount := 0.	targetStream isNil 		ifTrue: 		[	size timesRepeat: [ aStream next ].			^ self		].	[			[	size timesRepeat: 				[ | readByte |					readByte := aStream next.					byteCount := byteCount + 1.					targetStream nextPut: readByte				]		] 			on: OsTransferFaultError , OsIllegalOperation , OsInaccessibleError			from: targetStream coastOsOutputExceptionOriginator			do: 			[: ex |				CoastLog logWarning: 'Error during file transfer: ' , ex description.				" read remaining bytes "				( byteCount + 1 to: size ) do: [: i | aStream next ]			]	] ensure: 		[				[	targetStream flush.				targetStream close			] 				on: Error				do: 				[: ex |					"ignore"				]		].</body></methods><methods><class-id>COAST.CatRMFileTransfer</class-id> <category>testing</category><body package="COMessages">needsChecksum	^ false</body></methods><methods><class-id>COAST.CatRMFileUploadRequest</class-id> <category>accessing</category><body package="COMessages">bytes: newBytes	bytes := newBytes.</body><body package="COMessages">fileID	^fileID</body><body package="COMessages">fileVolume	^volume</body><body package="COMessages">fileVolume: aVolume	volume := aVolume</body><body package="COMessages">receiverPacketStation	^ receiverPacketStation</body><body package="COMessages">receiverPacketStation: aCatCSPacketStation	receiverPacketStation := aCatCSPacketStation</body><body package="COMessages">receiverVolume	^volume</body><body package="COMessages">sourceSize	^ sourceStream isNil 		ifTrue: [ super sourceSize ]		ifFalse: [ sourceStream nextUnsigned32 ]</body><body package="COMessages">sourceStream: aStream	sourceStream := aStream</body><body package="COMessages">sourceStreamDo: aBlock ifNone: noStreamBlock 	^ sourceStream notNil		ifTrue: [ aBlock value: sourceStream ]		ifFalse: [ super sourceStreamDo: aBlock ifNone: noStreamBlock ]</body><body package="COMessages">uploadSucceeded	^ uploadSucceeded ifNil: [ true ]</body></methods><methods><class-id>COAST.CatRMFileUploadRequest</class-id> <category>testing</category><body package="COMessages">isRequest	^ true</body></methods><methods><class-id>COAST.CatRMFileUploadRequest</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextShortStringPut: volume.	sourceFile = '' 		ifTrue: [ self marshallBytesTo: aStream marshaller: aCatRMMarshall ]		ifFalse: [ self marshallBytesFromSourceStreamTo: aStream marshaller: aCatRMMarshall ].</body><body package="COMessages">marshallBytesFromSourceStreamTo: aStream marshaller: aCatRMMarshall 	self 		sourceStreamDo: 		[: bytesStream | | byteCount |			size := self sourceSize.			aStream nextUnsigned32Put: size.			byteCount := 0.			[	size timesRepeat: 					[ | readByte |						readByte := bytesStream next.						readByte isNil 							ifTrue: 							[	" hk: sehr dubios, aber cs meint, dass dieser Fall trotz EndOfStreamNotification-Handler aufgetreten ist "								EndOfStreamNotification raiseRequestFrom: bytesStream							]							ifFalse: 							[	aStream nextPut: readByte.								byteCount := byteCount + 1							]					]			] 				on: EndOfStreamNotification , Error				from: bytesStream				do: 				[: ex |					CoastLog logException: ex message: 'Error during file upload (file ', fileID printString, ')'.					uploadSucceeded := false.					byteCount + 1 to: size do: [: i | aStream nextPut: 0 ]				]		]		ifNone: 		[	size := 0.			aStream nextUnsigned32Put: size		].</body><body package="COMessages">marshallBytesTo: aStream marshaller: aCatRMMarshall 	aStream nextUnsigned32Put: bytes size.	( 1 to: bytes size ) do: [: i | aStream nextPut: ( bytes at: i )].</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	| cm |	volume := aStream nextShortString.	size := aStream nextUnsigned32.	cm := receiverPacketStation volumeManager clusterManagerForVolume: volume.	fileID := cm newClusterID.	targetStream := cm storageInterface writeStreamOnBlob: fileID size: size.	super unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager</body></methods><methods><class-id>COAST.CatRMFileUploadRequest class</class-id> <category>instance creation</category><body package="COMessages">fromBytes: aByteArray toVolume: aVolume	| newInst |	newInst := self new.	newInst fileVolume: aVolume.	newInst sourceFile: ''.	newInst bytes: aByteArray.	^newInst.</body><body package="COMessages">fromFile: aFilename toVolume: aVolume	| newInst |	newInst := self new.	newInst fileVolume: aVolume.	newInst sourceFile: aFilename.	^newInst.</body><body package="COMessages">fromStream: aStream toVolume: aVolume	| newInst |	newInst := self new.	newInst fileVolume: aVolume.	newInst sourceStream: aStream.	^newInst.</body></methods><methods><class-id>COAST.CatRMClusterReleaseMessage</class-id> <category>accessing</category><body package="COMessages">clusterLocator	^clusterLocator</body><body package="COMessages">clusterLocator: aCatCSClusterLocator	clusterLocator := aCatCSClusterLocator</body><body package="COMessages">receiver	^clusterLocator</body><body package="COMessages">receiverVolume	^clusterLocator volume</body></methods><methods><class-id>COAST.CatRMClusterReleaseMessage</class-id> <category>printing</category><body package="COMessages">printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ' clusterLocator '.	clusterLocator printOn: aStream</body></methods><methods><class-id>COAST.CatRMClusterReleaseMessage</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	clusterLocator marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	clusterLocator := CatCSClusterLocator unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CatRMClusterReleaseMessage class</class-id> <category>instance creation</category><body package="COMessages">clusterLocator: aCatCSClusterLocator	| newInst |	newInst := self new.	newInst clusterLocator: aCatCSClusterLocator.	^newInst</body></methods><methods><class-id>COAST.CatRMIndexDownloadRequest</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextShortStringPut: self volume.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self volume: aStream nextShortString</body></methods><methods><class-id>COAST.CatRMIndexDownloadRequest</class-id> <category>accessing</category><body package="COMessages">receiverVolume	^volume</body><body package="COMessages">volume	^volume</body><body package="COMessages">volume: aString	volume := aString</body></methods><methods><class-id>COAST.CatRMIndexDownloadRequest class</class-id> <category>instance creation</category><body package="COMessages">volume: aString 	^ ( self new )		volume: aString;		yourself</body></methods><methods><class-id>COAST.CatRMConnectionsResponse</class-id> <category>accessing</category><body package="COMessages">connections	^connections</body><body package="COMessages">connections: aCollection	connections := aCollection</body></methods><methods><class-id>COAST.CatRMConnectionsResponse</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: self connections size.	self connections do: [: hostAdressByteArray | hostAdressByteArray marshallBinaryTo: aStream marshaller: aCatRMMarshall ].</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	| connectionSize |	connectionSize := aStream nextOptimized32.	connections := ( 1 to: connectionSize ) collect: [: dummy | aCatRMMarshall unmarshallValueFrom: aStream morph: nil ].</body></methods><methods><class-id>COAST.CatRMConnectionsResponse class</class-id> <category>instance creation</category><body package="COMessages">connections: aCollection 	^(self new) connections: aCollection; yourself</body></methods><methods><class-id>COAST.CatRMFileDownloadResponse</class-id> <category>accessing</category><body package="COMessages">bytes	^bytes</body><body package="COMessages">fileID	^fileID</body><body package="COMessages">fileID: anInteger	fileID := anInteger</body><body package="COMessages">storageInterface: anObject 	storageInterface := anObject</body><body package="COMessages">targetFile: aString	targetFile := aString</body></methods><methods><class-id>COAST.CatRMFileDownloadResponse</class-id> <category>testing</category><body package="COMessages">isResponse	^true</body></methods><methods><class-id>COAST.CatRMFileDownloadResponse</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextShortStringPut: targetFile asString.	storageInterface transferBlob: fileID to: aStream</body><body package="COMessages">targetStreamFromString: aString 	"if the string begins with the targetStreamMarker we have to find a stream in which to put the bytes"	| downloadTarget |	^ ( CatRMFileDownloadTarget isTargetStreamName: aString ) 		ifTrue: 		[	downloadTarget := CatRMFileDownloadTarget deregisterDownloadTargetForKey: aString.			downloadTarget notNil 				ifTrue: 				[	downloadTarget bytesOnly 						ifFalse: [ downloadTarget targetStream nextUnsigned32Put: size ].					downloadTarget targetStream				]				ifFalse: 				[	CoastLog logWarning: 'Target stream for file download not found'.					nil				]		]		ifFalse: [( Filename named: aString ) writeStream binary ]</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	| aString |	aString := aStream nextShortString.	size := aStream nextUnsigned32.	aString = '' 		ifTrue: 		[	"empty string means: bytes are stored internally"			bytes := Processor execute: [ ByteArray new: size ] withPriority: Processor userSchedulingPriority.			aStream next: size into: bytes startingAt: 1		]		ifFalse: 		[	self targetStream: ( self targetStreamFromString: aString ).			super unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager		].</body></methods><methods><class-id>COAST.CatRMFileDownloadResponse</class-id> <category>compatibility</category><body package="COMessages">clusterID	self haltOrContinue: 'replaced by #fileID'.	^fileID</body><body package="COMessages">clusterID: aBlobID	self haltOrContinue: 'replaced by #fileID:'.	fileID := aBlobID</body></methods><methods><class-id>COAST.CatRMFileDownloadResponse class</class-id> <category>instance creation</category><body package="COMessages">fileID: aFileID sourceStore: storageAccessor targetFile: file 	^(self new)		fileID: aFileID;		storageInterface: storageAccessor;		targetFile: file;		yourself</body></methods><methods><class-id>COAST.CatRMTestAndSetResultMessage</class-id> <category>accessing</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextShortStringPut: volume.	result marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall.</body><body package="COMessages">result	^ result</body><body package="COMessages">result: resultFrameRef volume: frameVolume 	result := resultFrameRef.	volume := frameVolume.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	volume := aStream nextShortString.	aCatRMMarshall clusterManager: ( aCatCSVolumeManager clusterManagerForVolume: volume ).	result := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.</body></methods><methods><class-id>COAST.CatRMTestAndSetResultMessage class</class-id> <category>instance creation</category><body package="COMessages">result: resultFrameRef volume: frameVolume 	^ self new		result: resultFrameRef volume: frameVolume;		yourself</body></methods><methods><class-id>COAST.CatRMFileUploadResponse</class-id> <category>accessing</category><body package="COMessages">fileID	^fileID</body><body package="COMessages">fileID: anInteger	fileID := anInteger</body></methods><methods><class-id>COAST.CatRMFileUploadResponse</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextOptimized32Put: fileID.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self fileID: (aStream nextOptimized32).</body></methods><methods><class-id>COAST.CatRMFileUploadResponse class</class-id> <category>instance creation</category><body package="COMessages">fileID: anInteger	| newInst |	newInst := self new.	newInst fileID: anInteger.	^newInst.</body></methods><methods><class-id>COAST.CatRMIndexDownloadResponse</class-id> <category>accessing</category><body package="COMessages">bytes	^bytes</body><body package="COMessages">bytes: aByteArray	bytes := aByteArray</body></methods><methods><class-id>COAST.CatRMIndexDownloadResponse</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextUnsigned32Put: self bytes size.	aStream nextPutAll: self bytes.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	| size |	size := aStream nextUnsigned32.	bytes := ByteArray new: size.	aStream next: size into: bytes startingAt: 1.</body></methods><methods><class-id>COAST.CatRMVolumeAdministrationRequest</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextShortStringPut: self volume.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self volume: aStream nextShortString</body></methods><methods><class-id>COAST.CatRMVolumeAdministrationRequest</class-id> <category>accessing</category><body package="COMessages">receiverVolume	^volume</body><body package="COMessages">volume	^volume</body><body package="COMessages">volume: aVolume	volume := aVolume</body></methods><methods><class-id>COAST.CatRMRPCResultMessage</class-id> <category>accessing</category><body package="COMessages">result	^ result</body><body package="COMessages">result: coastPrimitive marshaller: aMarshaller volume: aVolume 	| mStream |	resultError := ''.	volume := aVolume.	marshalledResult := ByteArray new.	[	mStream := ByteArray new writeStream.		coastPrimitive marshallBinaryArgumentTo: mStream marshaller: aMarshaller.		marshalledResult := mStream contents	] on: Error do: [ : ex |		resultError := ex description.		CoastLog logException: ex message: 'marshaling of result message failed'.		].</body><body package="COMessages">resultError	^ resultError</body></methods><methods><class-id>COAST.CatRMRPCResultMessage</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextShortStringPut: volume.	resultError isEmpty 		ifTrue: 		[	aStream nextPut: 1.			aStream nextPutAll: marshalledResult		]		ifFalse: 		[	aStream nextPut: 0.			aStream nextShortStringPut: resultError		].</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	volume := aStream nextShortString.	aCatRMMarshall clusterManager: (aCatCSVolumeManager clusterManagerForVolume: volume).	aStream next = 0 		ifTrue: [ resultError := aStream nextShortString ]		ifFalse: [ result := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream ].</body></methods><methods><class-id>COAST.CatRMRPCResultMessage class</class-id> <category>instance creation</category><body package="COMessages">result: anObject marshaller: aMarshaller volume: volume 	^ ( self new )		result: anObject asCoastPrimitive marshaller: aMarshaller volume: volume;		yourself</body></methods><methods><class-id>COAST.CatRMCachedClusterOkMessage</class-id> <category>accessing</category><body package="COMessages">clusterController	^ marshall clusterController</body><body package="COMessages">clusterID	^clusterLocator id</body><body package="COMessages">clusterLocator	^clusterLocator</body><body package="COMessages">clusterLocator: aCatCSClusterLocator	clusterLocator := aCatCSClusterLocator</body><body package="COMessages">marshallerForCachedCluster	^marshall</body></methods><methods><class-id>COAST.CatRMCachedClusterOkMessage</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall	self clusterLocator marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	| volume cm cc |	self clusterLocator: (CatCSClusterLocator					unmarshallBinaryFrom: aStream					marshaller: aCatRMMarshall).	volume := self clusterLocator volume.	marshall := ClusterUnmarshaller new.	cm := aCatCSVolumeManager clusterManagerForVolume: volume.	cc := cm controllerClass new.	cc clusterManager: cm.	marshall clusterController: cc.</body></methods><methods><class-id>COAST.CatRMCachedClusterOkMessage</class-id> <category>execution</category><body package="COMessages">logActionForClusterManager: clusterManager	clusterManager notifyCacheLoad: self clusterLocator id.</body></methods><methods><class-id>COAST.CatRMVolumesResponse</class-id> <category>accessing</category><body package="COMessages">volumes	^volumes</body><body package="COMessages">volumes: aSet	volumes := aSet</body></methods><methods><class-id>COAST.CatRMVolumesResponse</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: self volumes size.	self volumes do: [: volumeName | aStream nextShortStringPut: volumeName ].</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	| size |	size := aStream nextOptimized32.	volumes := Set new: size.	size timesRepeat: [ volumes add: aStream nextShortString ].</body></methods><methods><class-id>COAST.CatRMVolumesResponse class</class-id> <category>instance creation</category><body package="COMessages">volumes: aSet	^self new volumes: aSet</body></methods><methods><class-id>COAST.CatRMErrorMessage</class-id> <category>accessing</category><body package="COMessages">description	^description</body><body package="COMessages">description: aString	description := aString</body><body package="COMessages">fullDescription	^ 'Error message returned from Mediator: ', self description</body></methods><methods><class-id>COAST.CatRMErrorMessage</class-id> <category>testing</category><body package="COMessages">isError	^true</body><body package="COMessages">logActionForClusterManager: clusterManager	clusterManager statusError: 'error receiving cluster: ' , self description.</body></methods><methods><class-id>COAST.CatRMErrorMessage</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextCoastStringPut: self description</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self description: aStream nextCoastString.</body></methods><methods><class-id>COAST.CatRMErrorMessage class</class-id> <category>instance creation</category><body package="COMessages">description: aString	| m |	m := self new.	m description: aString.	^m</body></methods><methods><class-id>COAST.CatRMCommand</class-id> <category>testing</category><body package="COMessages">isCommand	^true</body></methods><methods><class-id>COAST.CatRMAliveCommand</class-id> <category>constants</category><body package="COMessages">commandID	^1</body></methods><methods><class-id>COAST.CatRMFileDownloadRequest</class-id> <category>accessing</category><body package="COMessages">deregisterTargetStream	( CatRMFileDownloadTarget isTargetStreamName: self targetFile) 		ifTrue: [ CatRMFileDownloadTarget deregisterDownloadTargetForKey: self targetFile ]</body><body package="COMessages">fileID^fileID</body><body package="COMessages">fileID: anIntegerfileID := anInteger</body><body package="COMessages">receiverVolume	^volume</body><body package="COMessages">targetFile	^targetFile</body><body package="COMessages">targetFile: aFilename	targetFile := aFilename</body><body package="COMessages">volume	^volume</body><body package="COMessages">volume: aString	volume := aString</body></methods><methods><class-id>COAST.CatRMFileDownloadRequest</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: fileID.	aStream nextShortStringPut: volume.	aStream nextShortStringPut: targetFile asString.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self fileID: aStream nextOptimized32.	self volume: aStream nextCoastString.	self targetFile: aStream nextCoastString.</body></methods><methods><class-id>COAST.CatRMFileDownloadRequest class</class-id> <category>instance creation</category><body package="COMessages">fileID: anInteger volume: aVolume targetFile: aFilename	| newInst |	newInst := self new.	newInst fileID: anInteger.	newInst volume: aVolume.	newInst targetFile: aFilename.	^newInst.</body><body package="COMessages">fileID: anInteger volume: aVolume targetStream: aStream bytesOnly: bytesOnly 	" Transfer the file contents to the stream. The header (currently only the file size) will be streamed first if includeHeader = true "	| key |	key :=  (CatRMFileDownloadTarget targetStream: aStream bytesOnly: bytesOnly ) register.	^ self fileID: anInteger volume: aVolume targetFile: key</body></methods><methods><class-id>COAST.CatRMTestAndSetRequest</class-id> <category>accessing</category><body package="COMessages">keyFrame	^ keyFrame</body><body package="COMessages">keyFrame: aKeyFrame 	keyFrame := aKeyFrame.	volume := aKeyFrame volume.</body><body package="COMessages">newValue	^ newValue</body><body package="COMessages">newValue: aNewValue 	newValue := aNewValue.</body><body package="COMessages">oldValue	^ oldValue</body><body package="COMessages">oldValue: aOldValue 	oldValue := aOldValue.</body><body package="COMessages">receiverVolume	^ volume</body></methods><methods><class-id>COAST.CatRMTestAndSetRequest</class-id> <category>printing</category><body package="COMessages">printOn: stream 	super printOn: stream.	stream nextPutAll: ' atKey: '.	keyFrame printOn: stream.	stream nextPutAll: ' oldValue: '.	oldValue printOn: stream.	stream nextPutAll: ' putNewValue: '.	newValue printOn: stream.</body></methods><methods><class-id>COAST.CatRMTestAndSetRequest</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextShortStringPut: volume.	keyFrame marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall.	oldValue marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall.	newValue marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall.</body><body package="COMessages">prepareMarshaller: marshaller volumeManager: volumeManager 	marshaller clusterManager: (volumeManager clusterManagerForVolume: self receiverVolume)</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	volume := aStream nextShortString.	aCatRMMarshall clusterManager: ( aCatCSVolumeManager clusterManagerForVolume: volume ).	keyFrame := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.	oldValue := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.	newValue := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.</body></methods><methods><class-id>COAST.CatRMTestAndSetRequest class</class-id> <category>instance creation</category><body package="COMessages">keyFrame: keyFrame oldValue: oldValue newValue: newValue 	^ self new		keyFrame: keyFrame;		oldValue: oldValue;		newValue: newValue;		yourself</body></methods><methods><class-id>COAST.CatRMClusterCreateRequest</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextShortStringPut: self volume.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self volume: aStream nextShortString</body></methods><methods><class-id>COAST.CatRMClusterCreateRequest</class-id> <category>accessing</category><body package="COMessages">modificationNumber	^0</body><body package="COMessages">receiverVolume	^volume</body><body package="COMessages">volume	^volume</body><body package="COMessages">volume: aString	volume := aString</body></methods><methods><class-id>COAST.CatRMClusterCreateRequest</class-id> <category>printing</category><body package="COMessages">printOn: stream 	super printOn: stream.	stream nextPutAll: ' volume '.	volume printOn: stream</body></methods><methods><class-id>COAST.CatRMClusterCreateRequest class</class-id> <category>instanceCreation</category><body package="COMessages">volume: aString	^self new volume: aString</body></methods><methods><class-id>COAST.CatRMCloseCommand</class-id> <category>accessing</category><body package="COMessages">commandID	^0</body></methods><methods><class-id>COAST.CatRMCloseCommand</class-id> <category>synch</category><body package="COMessages">deliverError	deliverSemaphore signal</body><body package="COMessages">delivered	deliverSemaphore signal</body><body package="COMessages">waitForDelivery	deliverSemaphore wait</body></methods><methods><class-id>COAST.CatRMCloseCommand</class-id> <category>initialize</category><body package="COMessages">initialize	deliverSemaphore := Semaphore new.</body></methods><methods><class-id>COAST.CatRMCloseCommand class</class-id> <category>instance creation</category><body package="COMessages">new	^super new initialize; yourself</body></methods><methods><class-id>COAST.CatCSApplicationLogger</class-id> <category>private</category><body package="COClusterManagement">iniCategory	^ self class name asString</body></methods><methods><class-id>COAST.CatCSApplicationLogger</class-id> <category>initialize-release</category><body package="COClusterManagement">initialize</body></methods><methods><class-id>COAST.CatCSApplicationLogger</class-id> <category>accessing</category><body package="COClusterManagement">logIniFile	^ logIniFile</body><body package="COClusterManagement">logIniFile: aFilename	logIniFile := aFilename</body><body package="COClusterManagement">workingDirectory: aDirectory	workingDirectory := aDirectory</body></methods><methods><class-id>COAST.CatCSApplicationLogger</class-id> <category>API</category><body package="COClusterManagement">addToApplicationLog: aCatCSApplicationLog	self subclassResponsibility</body><body package="COClusterManagement">copyLogFilesToDirectory: destinationDirectory	self subclassResponsibility</body><body package="COClusterManagement">deleteLogFiles	" delete all log-related files, including configuration files"	self subclassResponsibility</body><body package="COClusterManagement">initializeFromIni: iniAccess</body><body package="COClusterManagement">moveLogFilesToDirectory: destinationDirectory	self subclassResponsibility</body><body package="COClusterManagement">shutDown	self subclassResponsibility</body><body package="COClusterManagement">startUp	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSApplicationLogger class</class-id> <category>testing</category><body package="COClusterManagement">isAbstract	^ true</body></methods><methods><class-id>COAST.CatCSApplicationLogger class</class-id> <category>instance creation</category><body package="COClusterManagement">createFromIniFile: logIniFile workingDirectory: workingDirectory 	^ self createFromIniFile: logIniFile workingDirectory: workingDirectory allowAbsolute: false</body><body package="COClusterManagement">createFromIniFile: logIniFile workingDirectory: workingDirectory allowAbsolute: boolean 	| applicationLoggers logClassNames iniAccess relativeIniFilename fullFilename |	( boolean or: [ logIniFile isRelative ]) ifFalse: 		[	CoastLog logWarning: 'Log ini filename must be relative: ' , logIniFile asString.			^ #( )		].	iniAccess := CoastIniAccess new.	relativeIniFilename := logIniFile tail asFilename.	fullFilename := workingDirectory construct: relativeIniFilename asString.	fullFilename exists ifFalse: 		[	CoastLog logWarning: 'Application log configuration file not found: ' , fullFilename displayString.			^ #( )		].	iniAccess readFile: fullFilename.	logClassNames := iniAccess stringAt: 'applicationLogs'.	logClassNames isNil ifTrue: 		[	"fallback code fÃ¼r alte ini-files"			logClassNames := iniAccess stringAt: 'applicationLog' ifAbsent: [ ^ #( )]		].	applicationLoggers := OrderedCollection new: logClassNames size.	( logClassNames tokensBasedOn: $; ) do: 		[: logClassName | | logClass applicationLogger |			logClass := ( StrictBindingReference simpleName: logClassName in: COAST ) valueOrDo: [ nil ].			logClass isNil ifTrue: 				[	CoastLog logWarning: 'Unknow application log class: ' , logClassName name asString.					^ #( )				].			logClass isAbstract ifTrue: 				[	CoastLog logWarning: 'Application log class is abstract: ' , logClass fullName.					^ #( )				].			applicationLogger := logClass new.			applicationLogger workingDirectory: workingDirectory.			applicationLogger logIniFile: relativeIniFilename.			applicationLogger initializeFromIni: iniAccess.			applicationLoggers add: applicationLogger		].	^ applicationLoggers</body><body package="COClusterManagement">new	^super new initialize</body></methods><methods><class-id>COAST.CatCSAbstractFileApplicationLogger</class-id> <category>backup</category><body package="COClusterManagement">backupInterval	" interval between backups (in days)"	backupInterval isNil ifTrue: [ backupInterval := 14 ].	^backupInterval</body><body package="COClusterManagement">backupLog	| bfn |	self fullFilename exists ifFalse: [ ^ self ].	CoastLog log: 'Backup application log'.	self closeStream.	[	bfn := self createBackupFilename.		hashInstance notNil ifTrue: [ self updateHashWithBackup: bfn ].		self fullFilename moveTo: bfn	] on: Error do: [: ex | CoastLog logException: ex message: 'Could not backup application log' ].	self openStream.</body><body package="COClusterManagement">checkBackupLog	| t |	t := Timestamp now asSeconds.	( t - self currentFileCreated ) // 86400 &gt; self backupInterval ifTrue: [ self backupLog ].</body><body package="COClusterManagement">createBackupFilename	| counter bfn |	counter := self lastBackupID.	[		counter := counter + 1.		bfn := (self fullFilename asString, '.', counter printString, '.bak') asFilename.		bfn exists	] whileTrue.	self lastBackupID: counter.	^ bfn</body><body package="COClusterManagement">currentFileCreated	" Timestamp asSeconds "	^ self iniAccess category: self iniCategory numberAt: #currentFileCreated ifAbsent: [ 0 ].</body><body package="COClusterManagement">currentFileCreated: timestampSeconds 	" Timestamp asSeconds "	self iniAccess category: self iniCategory at: #currentFileCreated put: timestampSeconds.	self writeBackIni.</body><body package="COClusterManagement">lastBackupID	" counter "	^ self iniAccess category: self iniCategory numberAt: #lastBackupID ifAbsent: [ 0 ].</body><body package="COClusterManagement">lastBackupID: anInteger	" counter "	self iniAccess category: self iniCategory at: #lastBackupID put: anInteger.	self writeBackIni.</body></methods><methods><class-id>COAST.CatCSAbstractFileApplicationLogger</class-id> <category>accessing</category><body package="COClusterManagement">defaultEncoding	^ 'iso8859-1'</body><body package="COClusterManagement">encoding	encoding isNil 		ifTrue: [ encoding := self defaultEncoding asSymbol ].	^ encoding</body><body package="COClusterManagement">encoding: aSymbol	encoding := aSymbol</body><body package="COClusterManagement">filename	^ filename ifNil: [ self class defaultFilename  ]</body><body package="COClusterManagement">filename: aFilename	filename := aFilename</body><body package="COClusterManagement">writeBackImmediately	^ writeBackImmediately ifNil: [ true ]</body><body package="COClusterManagement">writeBackImmediately: aBoolean	writeBackImmediately := aBoolean</body></methods><methods><class-id>COAST.CatCSAbstractFileApplicationLogger</class-id> <category>private</category><body package="COClusterManagement">allRelativeFilenames	| filenames pattern |	filenames := Set new.	filenames add: self logIniFile tail asString.	pattern := self filename asString, '*'.	workingDirectory directoryContents do: [ : fn |		(pattern match: fn)			ifTrue: [ filenames add: fn ].	].	^ filenames</body><body package="COClusterManagement">closeStream	externalStream notNil ifTrue: 		[	self flush.			externalStream close.			externalStream := nil		].</body><body package="COClusterManagement">encoder	encoder isNil ifTrue: [ 		encoder := StreamEncoder new: self encoding.	].	^ encoder</body><body package="COClusterManagement">fullFilename	^ workingDirectory construct: self filename asString</body><body package="COClusterManagement">hasHash	^ hashClass notNil</body><body package="COClusterManagement">iniAccess	iniAccess isNil		ifTrue: [ iniAccess := CoastIniAccess readFile: self iniFilename ].	^ iniAccess</body><body package="COClusterManagement">iniFilename	^ (self fullFilename asString, '.ini') asFilename</body><body package="COClusterManagement">openStream	| isOld |	self closeStream.	isOld := self fullFilename exists.	externalStream := self fullFilename appendStream binary.	internalStream := ( ByteArray new withEncoding: self encoding ) writeStream.	self hasHash ifTrue: [ self verifyOldFileHash ].	isOld ifFalse: [ self currentFileCreated: Timestamp now asSeconds ].</body><body package="COClusterManagement">writeBackIni	self iniAccess writeFile</body></methods><methods><class-id>COAST.CatCSAbstractFileApplicationLogger</class-id> <category>API</category><body package="COClusterManagement">addToApplicationLog: aCatCSApplicationLog 	self checkBackupLog.	self basicAddToApplicationLog: aCatCSApplicationLog.	self writeBackImmediately ifTrue: [ self flush ].</body><body package="COClusterManagement">basicAddToApplicationLog: aCatCSApplicationLog	self subclassResponsibility</body><body package="COClusterManagement">copyLogFilesToDirectory: destinationDirectory	self allRelativeFilenames do: [: fn | ( workingDirectory construct: fn ) copyTo: ( destinationDirectory construct: fn ) ]</body><body package="COClusterManagement">deleteLogFiles	self allRelativeFilenames do: [: fn | ( workingDirectory construct: fn ) delete ]</body><body package="COClusterManagement">flush	| bytes |	bytes := internalStream coreStream contents asByteArray.	internalStream reset.	externalStream nextPutAll: bytes.	externalStream flush.	hashInstance notNil ifTrue: [ self flushBytesToHash: bytes ].</body><body package="COClusterManagement">initializeFromIni: coastIniAccess 	| s enc b |	super initializeFromIni: coastIniAccess.	( s := coastIniAccess category: self iniCategory stringAt: 'filename' ) notNil ifTrue: [ self filename: s asFilename tail ].	b := coastIniAccess category: self iniCategory booleanAt: 'writeBackImmediately' ifAbsent: [ true ].	self writeBackImmediately: b.	s := coastIniAccess category: self iniCategory stringAt: 'hash' ifAbsent: [ '' ].	self initHashClassFrom: s.	backupInterval := ( coastIniAccess category: self iniCategory numberAt: 'backupInterval' ifAbsent: [ 14 ]) max: 1.	( s := coastIniAccess category: self iniCategory stringAt: 'encoding' ) notNil ifTrue: 		[	enc := s asSymbol.			( StreamEncoder availableEncodings includes: enc ) 				ifTrue: [ self encoding: enc ]				ifFalse: [ CoastLog logWarning: 'Ignored unknown application log encoding: ' , s printString ]		].</body><body package="COClusterManagement">moveLogFilesToDirectory: destinationDirectory	self allRelativeFilenames do: [: fn | ( workingDirectory construct: fn ) moveTo: ( destinationDirectory construct: fn ) ]</body><body package="COClusterManagement">shutDown	self closeStream.	self writeBackIni.</body><body package="COClusterManagement">startUp	self openStream.</body></methods><methods><class-id>COAST.CatCSAbstractFileApplicationLogger</class-id> <category>crypto</category><body package="COClusterManagement">allHashValuesHash	| metaHash dictionary i |	metaHash := hashClass new.	dictionary := self iniAccess category: 'hash'.	i := 1.	dictionary notNil ifTrue: 		[	dictionary values asSortedCollection do: 				[: hexString |					metaHash updateWith: ( ByteArray fromHexString: hexString ).					metaHash updateWith: ( Spices at: i ).					i := i = Spices size 							ifTrue: [ 1 ]							ifFalse: [ i + 1 ]				]		].	^ metaHash digest</body><body package="COClusterManagement">fileValidationDictOn: files 	| result expected |	result := Dictionary new.	files do: 		[: file |			expected := self hashForFilename: file asFilename.			expected isNil 				ifTrue: [ result at: file asFilename tail put: #unknown ]				ifFalse: 				[	result at: file asFilename tail						ifAbsentPut: 						[	expected = ( hashClass coastHashOnFile: file ) digest 								ifTrue: [ #OK ]								ifFalse: [ #invalid ]						]				]		].	( self iniAccess category: 'hash' ) keysDo: [: hashedFile | result at: hashedFile ifAbsentPut: [ #missing ]].	^ result</body><body package="COClusterManagement">flushBytesToHash: bytes 	hashInstance updateWith: bytes.	self hash: hashInstance digest forFilename: self fullFilename warnIfPresent: false.	self iniAccess category: self iniCategory at: 'validation' putIniString: self allHashValuesHash asHexString.	self writeBackIni.</body><body package="COClusterManagement">hash: digest forFilename: aFilename warnIfPresent: checkOld 	| old string |	string := aFilename asFilename tail.	( digest notNil and: [ checkOld ]) ifTrue: 		[	old := self hashForFilename: string.			old notNil and: [ old ~= digest ]		].	digest notNil 		ifTrue: [ self iniAccess category: 'hash' at: string putIniString: digest asHexString ]		ifFalse: [ self iniAccess category: hashInstance removeKey: string ].</body><body package="COClusterManagement">hashForFilename: aFilename 	| string |	string := self iniAccess category: 'hash' stringAt: aFilename asFilename tail.	^ string notNil 		ifTrue: [ ByteArray fromHexString: string ]		ifFalse: [ nil ]</body><body package="COClusterManagement">initHashClassFrom: s 	s isEmpty 		ifTrue: [ hashClass := nil ]		ifFalse: 		[	hashClass := Security.Hash allSubclasses 					detect: [: class | class name asString match: s ]					ifNone: [ self securityError: 'unsupported Hash ' , s printString ].			self iniAccess category: self iniCategory at: 'hash' putIniString: hashClass name		].</body><body package="COClusterManagement">securityError: string 	self haltOrContinue: string.	CoastFatalError raiseSignal: string.</body><body package="COClusterManagement">updateHashWithBackup: bfn 	| digest |	digest := self hashForFilename: self fullFilename.	self hash: digest forFilename: bfn warnIfPresent: true.	self hash: nil forFilename: self fullFilename warnIfPresent: true.</body><body package="COClusterManagement">verifyAllHashesHash	| allHashValuesHash |	allHashValuesHash := ByteArray fromHexString: ( self iniAccess category: self iniCategory stringAt: 'validation' ifAbsent: [ '' ]).	^ allHashValuesHash = self allHashValuesHash</body><body package="COClusterManagement">verifyOldFileHash	| expected found |	self verifyAllHashesHash ifFalse: [ self securityError: self class name , ' ' , hashClass name , ' validation failed' ].	expected := self hashForFilename: self fullFilename.	expected isNil ifTrue: 		[	CoastLog logWarning: 'missing ' , hashClass name , ' hash for: ' , self fullFilename asString.			hashInstance := nil.			^ self backupLog		].	hashInstance := hashClass coastHashOnFile: self fullFilename.	found := hashInstance digest.	expected = found ifFalse: 		[	self securityError: 'bad hash for: ' , self fullFilename asString.			self hash: found forFilename: self fullFilename warnIfPresent: false		].</body></methods><methods><class-id>COAST.CatCSAbstractFileApplicationLogger class</class-id> <category>instance creation</category><body package="COClusterManagement">filename: aFilename	^ self new		filename: aFilename;		yourself</body></methods><methods><class-id>COAST.CatCSAbstractFileApplicationLogger class</class-id> <category>accessing</category><body package="COClusterManagement">defaultFilename	^ defaultFilename ifNil: [ 'application.log' ].</body><body package="COClusterManagement">defaultFilename: aFilename	defaultFilename := aFilename</body></methods><methods><class-id>COAST.CoastCSVApplicationLogger</class-id> <category>API</category><body package="COClusterManagement">basicAddToApplicationLog: aCatCSApplicationLog	aCatCSApplicationLog logEntries do: [ : logEntry |		currentRow atAllPut: nil.		logEntry keysAndValuesDo: [ : key : value |			| column |			column := self columnNeeded: key.			currentRow growToAtLeast: self numberOfColumns.			currentRow at: column index put: value.		].		self writeCurrentRow.	].</body><body package="COClusterManagement">startUp	self checkFormat.	super startUp.</body></methods><methods><class-id>COAST.CoastCSVApplicationLogger</class-id> <category>initialize-release</category><body package="COClusterManagement">initialize 	super initialize.	currentRow := OrderedCollection new.</body><body package="COClusterManagement">initializeFromIni: coastIniAccess	| s columnNames |	super initializeFromIni: coastIniAccess.	(s := coastIniAccess category: self iniCategory stringAt: 'columns') notNil		ifTrue: [ 				columnNames := s tokensBasedOn: $;.			columnNames keysAndValuesDo: [ : i : token | | column |				column := CoastCSVLogColumn fromToken: token index: i.				self addColumn: column.			]		].</body></methods><methods><class-id>COAST.CoastCSVApplicationLogger</class-id> <category>private</category><body package="COClusterManagement">addColumn: aCSVColumn	| key index |	key := aCSVColumn key.	(self columnsDictionary includesKey: key)		ifTrue: [ CoastLog logError: ('Application log column name used twice: &lt;1s&gt;' expandMacrosWith: key) ].	self columnsDictionary at: key put: aCSVColumn.	index := aCSVColumn index.	self columns growToAtLeast: index.	(self columns at: index) notNil		ifTrue: [ CoastLog logError: ('Application log column index used twice: &lt;1s&gt;:&lt;2p&gt;' expandMacrosWith: key with: index) ].	self columns at: index put: aCSVColumn.	^ aCSVColumn</body><body package="COClusterManagement">checkFormat	"close your eyes - this is ridiculos pseudo crypto code..."	| pain |	pain := self columns size.	pain := pain bitXor: self encoding asString coastAsLargeInteger.	self columnsDictionary do: [: c | pain := pain bitXor: c logHash ].	self formatHash = pain ifFalse: 		[	CoastLog log: 'Columns format has changed, creating new log file'.			self backupLog.			self formatHash: pain		].</body><body package="COClusterManagement">columnNeeded: aKey	^ self columnsDictionary 		at: aKey		ifAbsent: [ self createUnknownColumnFor: aKey ]</body><body package="COClusterManagement">columns	columns isNil ifTrue: [ columns := OrderedCollection new ].	^ columns</body><body package="COClusterManagement">columnsDictionary	columnsDictionary isNil ifTrue: [ columnsDictionary := Dictionary new ].	^ columnsDictionary</body><body package="COClusterManagement">createUnknownColumnFor: key	| column index |	column := CoastCSVLogColumn new.	index := self numberOfColumns + 1.	column 		index: index;		name: key;		isQuoted: true;		isUnknown: true.	CoastLog logWarning: ('Unknown column in application log added: Name "&lt;1s&gt;" Index "&lt;2p&gt;"'			expandMacrosWith: key with: index).	self addColumn: column.	^ column</body><body package="COClusterManagement">formatHash	" hash to prevent modifying column format for existing logs"	^ self iniAccess category: self iniCategory numberAt: #formatHash ifAbsent: [ 0 ].</body><body package="COClusterManagement">formatHash: anInteger	" hash to prevent modifying column format for existing logs"	self iniAccess category: self iniCategory at: #formatHash put: anInteger</body><body package="COClusterManagement">logWarning: string	CoastLog logWarning: string.</body><body package="COClusterManagement">numberOfColumns	^ self columnsDictionary size</body><body package="COClusterManagement">readCurrentRowFrom: aStream	| cols cr lf atEndAndNextCharBlock char writeStream |	cols := OrderedCollection new: 13.	cr := Character cr.	lf := Character lf.	atEndAndNextCharBlock := [ aStream atEnd or: [ (char := aStream next) = cr or: [ char = lf ] ] ].	writeStream := String new writeStream.	[ atEndAndNextCharBlock value	] whileFalse: [		char = $\			ifTrue:	[ atEndAndNextCharBlock value ifFalse: [						char = $c							ifTrue:	[ writeStream nextPut: cr. ]							ifFalse:	[ char = $b										ifTrue:	[ writeStream nextPut: $\. ]										ifFalse:	[ char = $s													ifTrue:	[ writeStream nextPut: $;. ]													ifFalse:	[ writeStream nextPut: $\;																nextPut: char ] ] ]						].					]			ifFalse:	[ char = $;						ifTrue:	[ 	cols add: writeStream contents.									writeStream := String new writeStream.								]						ifFalse:	[ 	writeStream nextPut: char ] ]		].	cols add: writeStream contents.	^ cols</body><body package="COClusterManagement">unknownKeys	unknownKeys isNil ifTrue: [ unknownKeys := Dictionary new ].	^ unknownKeys</body><body package="COClusterManagement">writeCurrentRow	(1 to: self numberOfColumns)		do: [ : i | self writeValueAt: i ]		separatedBy: [ internalStream nextPut: $; ].	internalStream cr.</body><body package="COClusterManagement">writeValueAt: i 	| s enc |	s := currentRow at: i.	s notNil ifTrue: 		[	s := s displayString.			enc := self encoder.			s do: 				[: ch | ( enc coastCanEncode: ch ) 						ifTrue: 						[	ch = Character cr 								ifTrue: [ internalStream nextPutAll: '\c' ]								ifFalse: 								[	ch = $\ 										ifTrue: [ internalStream nextPutAll: '\b' ]										ifFalse: 										[	ch = $; 												ifTrue: [ internalStream nextPutAll: '\s' ]												ifFalse: [ internalStream nextPut: ch ]										]								]						]						ifFalse: [ internalStream nextPut: $~ ]				]		].</body></methods><methods><class-id>COAST.CoastCSVApplicationLogger class</class-id> <category>accessing</category><body package="COClusterManagement">defaultFilename	^ defaultFilename ifNil: [ 'application.log.csv' ].</body></methods><methods><class-id>COAST.CoastCSVApplicationLogger class</class-id> <category>testing</category><body package="COClusterManagement">isAbstract	^ false</body></methods><methods><class-id>COAST.AbstractUnloadStrategy</class-id> <category>accessing</category><body package="COClusterManagement">accessCountFor: clusterID 	"Needed for cache cleanup"	^ 0</body><body package="COClusterManagement">accessTable	^ Array new</body><body package="COClusterManagement">clusterManager	^manager</body><body package="COClusterManagement">clusterManager: aManager	manager:= aManager.	aManager clusterController do: [: cc | self notifyLoadCluster: cc cluster ].</body><body package="COClusterManagement">clusterUnloadFinished: didUnload 	"called by the CM to indicate end of unload-phase.	if didUnload is true, some clusters were actually unloaded "</body><body package="COClusterManagement">keepClusterID: clusterID 	keepClusterIDs isNil		ifTrue:	[ keepClusterIDs := Set with: clusterID ]		ifFalse:	[ keepClusterIDs add: clusterID ]</body><body package="COClusterManagement">keepClusterIDs	^ keepClusterIDs ifNil: [ keepClusterIDs := Set new ]</body><body package="COClusterManagement">keepClusterIDs: collection 	keepClusterIDs isNil		ifTrue: [	keepClusterIDs := collection asSet ]		ifFalse: [ keepClusterIDs addAll: collection asSet ]</body><body package="COClusterManagement">keepSize: keepSize</body><body package="COClusterManagement">maxClusterCount	"dunno"	^100</body><body package="COClusterManagement">maxMemory	^  maxMemory ifNil: [ self class defaultMaxMemory ]</body><body package="COClusterManagement">maxMemory: memoryByteSize	maxMemory := memoryByteSize</body><body package="COClusterManagement">maxUnloadTime	^SmallInteger maxVal</body><body package="COClusterManagement">maxUnloadTime: maxUnloadTime</body><body package="COClusterManagement">minAge: minAge</body><body package="COClusterManagement">unloadClustersFlag: aBoolean	"hook for subclassed working with unloadFlag"</body><body package="COClusterManagement">unloadInterval: unloadInterval</body><body package="COClusterManagement">unloadSize: unloadSize</body><body package="COClusterManagement">unloadableClustersWithout: clusterIDsToKeep background: background ignoreRestrictions: ignoreRestrictions 	^self subclassResponsibility</body></methods><methods><class-id>COAST.AbstractUnloadStrategy</class-id> <category>load / unload</category><body package="COClusterManagement">clusterInfoFor: clusterID 	^ nil</body><body package="COClusterManagement">manyClustersToLoadDo: aBlockClosure 	" evaluating the block will load many clusters. prepare the strategy if needed "	^aBlockClosure value</body><body package="COClusterManagement">notifyCacheLoad: clusterID</body><body package="COClusterManagement">notifyClusterAccess: clusterIDInteger</body><body package="COClusterManagement">notifyExternalFileLoad: clusterID</body><body package="COClusterManagement">notifyLoadCluster: cluster</body><body package="COClusterManagement">notifyUnloadCluster: cluster</body></methods><methods><class-id>COAST.AbstractUnloadStrategy</class-id> <category>testing</category><body package="COClusterManagement">checkForClusterUnload	| transaction |	transaction := self clusterManager transactionManager activeTransaction.	( transaction notNil and: [ transaction canUnloadClusters and: [ self unloadRecommended ]]) 		ifTrue: [ transaction unloadClusters ].</body><body package="COClusterManagement">clusterUnloadNeeded	"indicates the necessity to unload some clusters"	"is asked at the end of every transaction"	"is asked when a FastReadTransaction wants to do intermediate unload"	^self subclassResponsibility</body><body package="COClusterManagement">needsLowSpaceHandler	^ false</body><body package="COClusterManagement">unloadRecommended	" true if clusters should be unloaded "	self subclassResponsibility.</body><body package="COClusterManagement">unloadableClustersWithout: clusterIDsToKeep 	"compatibility"	^ self unloadableClustersWithout: clusterIDsToKeep background: false ignoreRestrictions: false</body></methods><methods><class-id>COAST.AbstractUnloadStrategy</class-id> <category>initialize-release</category><body package="COClusterManagement">initialize</body></methods><methods><class-id>COAST.AbstractUnloadStrategy</class-id> <category>cluster unload</category><body package="COClusterManagement">selectNonObservedClustersFrom: clusterIDs 	^ clusterIDs select: 		[: cid | | cc |			cc := manager clusterControllerAt: cid.			cc isNil or: [ cc cluster hasObservers not ]		]</body></methods><methods><class-id>COAST.AbstractUnloadStrategy</class-id> <category>copying</category><body package="COClusterManagement">initializeFrom: another</body></methods><methods><class-id>COAST.AbstractUnloadStrategy</class-id> <category>printing</category><body package="COClusterManagement">additionalInfoString	| stream |	stream := String new writeStream.	self additionalInfoStringOn: stream.	^ stream contents</body><body package="COClusterManagement">additionalInfoStringOn: stream	"nothing to print"</body></methods><methods><class-id>COAST.AbstractUnloadStrategy class</class-id> <category>default</category><body package="COClusterManagement">defaultMaxMemory	^ ObjectMemory currentMemoryPolicy growthRegimeUpperBound</body></methods><methods><class-id>COAST.AbstractUnloadStrategy class</class-id> <category>instance creation</category><body package="COClusterManagement">new	^ super new initialize;		yourself</body><body package="COClusterManagement">newWith: manager 	| newInst |	newInst := self new.	newInst clusterManager: manager.	manager unloadStrategy: newInst.	^ newInst</body></methods><methods><class-id>COAST.AbstractUnloadStrategy class</class-id> <category>constants</category><body package="COClusterManagement">strategyNamed: shortName fallBack: fallBackClass	^self allSubclasses detect: [ : sc | | ssn | (ssn := sc strategyShortName) notNil and: [ ssn asUppercase = shortName asUppercase ] ] ifNone: [ fallBackClass ]</body><body package="COClusterManagement">strategyShortName	^ nil</body></methods><methods><class-id>COAST.CatCSUnloadStrategy</class-id> <category>testing</category><body package="COClusterManagement">checkForClusterUnload	( unloadClustersFlag ~~ true and: [ self unloadRecommended ]) 		ifTrue: 		[	" remember to unload "			unloadClustersFlag := true.			self clusterManager transactionManager activeTransaction ifNotNil: 				[: transaction |					transaction canUnloadClusters 						ifTrue: 						[	transaction unloadClusters.							unloadClustersFlag := false						]				]		].</body><body package="COClusterManagement">clusterUnloadFinished: didUnload 	super clusterUnloadFinished: didUnload .	unloadClustersFlag := false.	didUnload 		ifTrue: [ self compressAccessTable ].</body><body package="COClusterManagement">clusterUnloadNeeded	^unloadClustersFlag ifNil: [false]</body><body package="COClusterManagement">unloadClustersFlag: aBoolean	unloadClustersFlag := aBoolean</body><body package="COClusterManagement">unloadRecommended	^ self clusterManager numberOfClustersLoaded &gt; ( self unloadSize + self keepClusterIDs size ) 		or: [ ObjectMemory currentMemoryPolicy allocatedMemory &gt; self maxMemory ]</body><body package="COClusterManagement">unloadableClustersWithout: clusterIDsToKeep background: background ignoreRestrictions: ignoreRestrictions 	" ignoreRestrictions: true -&gt; ignore restrictions like unloadSize, minAge etc. "	| numberToUnload possibleClustersToUnload unloadableClusters |	( ignoreRestrictions not and: [ manager numberOfClustersLoaded &lt;= ( self keepSize + self keepClusterIDs size )]) ifTrue: [ ^ OrderedCollection new ].	possibleClustersToUnload := self unloadableClusterIDs.	background ifTrue: [ possibleClustersToUnload := self selectNonObservedClustersFrom: possibleClustersToUnload ].	numberToUnload := possibleClustersToUnload size.	ignoreRestrictions ifFalse: [ numberToUnload := numberToUnload - self keepSize min: self maxUnloadSize ].	numberToUnload &gt; 0 ifFalse: [ ^ OrderedCollection new ].	unloadableClusters := OrderedCollection new: numberToUnload.	possibleClustersToUnload do: 		[: clusterID | ( unloadableClusters size &lt;= numberToUnload and: 				[( clusterIDsToKeep includes: clusterID ) not and: 						[ | cc |							cc := self clusterManager clusterController at: clusterID ifAbsent: nil.							cc notNil 								ifTrue: [ cc hasLog not ]								ifFalse: 								[	self removeUnloadableClusterID: clusterID.									false								]						]				]) 				ifTrue: [ unloadableClusters add: clusterID ]		].	^ unloadableClusters</body></methods><methods><class-id>COAST.CatCSUnloadStrategy</class-id> <category>load / unload</category><body package="COClusterManagement">clusterInfoClass	^ clusterInfoClass ifNil: [ clusterInfoClass := CatCSClusterInfo ]</body><body package="COClusterManagement">clusterInfoClass: aClusterInfoClass	clusterInfoClass := aClusterInfoClass</body><body package="COClusterManagement">clusterInfoFor: clusterID 	^ self accessTable at: clusterID ifAbsent: [ nil ]</body><body package="COClusterManagement">clusterInfoNeededFor: clusterID 	clusterID isInteger ifFalse: [ CoastError raiseSignal: '#clusterInfoNeededFor: expected an Integer argument' ].	^ self accessTable at: clusterID ifAbsentPut: [ self clusterInfoClass new ]</body><body package="COClusterManagement">externalFileInfoNeededFor: clusterID 	^self accessTable at: clusterID ifAbsentPut: [CatCSExternalFileInfo new]</body><body package="COClusterManagement">notifyCacheLoad: clusterID 	self notifyClusterAccess: clusterID.	( self clusterInfoNeededFor: clusterID ) logCacheLoad</body><body package="COClusterManagement">notifyClusterAccess: clusterIDInteger 	( self clusterInfoNeededFor: clusterIDInteger ) logAccess</body><body package="COClusterManagement">notifyExternalFileLoad: clusterID 	( self externalFileInfoNeededFor: clusterID ) logAccess</body><body package="COClusterManagement">notifyLoadCluster: cluster	( self clusterInfoNeededFor: cluster clusterID ) logLoad.	self notifyClusterAccess: cluster clusterID</body><body package="COClusterManagement">notifyUnloadCluster: cluster 	( self clusterInfoNeededFor: cluster clusterID ) logUnload.	self removeUnloadableClusterID: cluster clusterID</body></methods><methods><class-id>COAST.CatCSUnloadStrategy</class-id> <category>accessing</category><body package="COClusterManagement">accessCountFor: clusterID 	| clusterInfo |	clusterInfo := accessTable at: clusterID ifAbsent: nil.	^ clusterInfo notNil 		ifTrue: [ clusterInfo accessCount ]		ifFalse: [ 0 ]</body><body package="COClusterManagement">accessTable	accessTable isNil ifTrue: [ accessTable := CatCOIntegerKeyDictionary new ].	^ accessTable</body><body package="COClusterManagement">addUnloadableClusterID: clusterID 	basicUnloadableClusterIDs isNil ifTrue: [ basicUnloadableClusterIDs := self newBasicUnloadableClusterIDs ].	basicUnloadableClusterIDs ensureLastElement: clusterID</body><body package="COClusterManagement">ensureClusterID: clusterID notUnloadedWhile: block 	( self keepClusterIDs includes: clusterID ) ifTrue: [ ^ block value ].	self keepClusterIDs add: clusterID.	( self includesUnloadableClusterID: clusterID ) ifTrue: [ self removeUnloadableClusterID: clusterID ].	^ block ensure: 		[	self addUnloadableClusterID: clusterID.			self keepClusterIDs remove: clusterID		]</body><body package="COClusterManagement">growthLimit	| up |	up := ObjectMemory currentMemoryPolicy growthRegimeUpperBound.	^ up - ( up // 10 )</body><body package="COClusterManagement">includesUnloadableClusterID: clusterID 	^ basicUnloadableClusterIDs notNil and: [ basicUnloadableClusterIDs includes: clusterID ]</body><body package="COClusterManagement">keepClusterID: clusterID 	basicUnloadableClusterIDs notNil ifTrue: [ basicUnloadableClusterIDs remove: clusterID ifAbsent: nil ].	keepClusterIDs isNil		ifTrue:	[ keepClusterIDs := Set with: clusterID ]		ifFalse:	[ keepClusterIDs add: clusterID ]</body><body package="COClusterManagement">keepClusterIDs: collection 	basicUnloadableClusterIDs notNil ifTrue: [ basicUnloadableClusterIDs removeAll: collection ifAbsent: nil ].	keepClusterIDs isNil		ifTrue: [	keepClusterIDs := collection asSet ]		ifFalse: [ keepClusterIDs addAll: collection asSet ]</body><body package="COClusterManagement">keepSize	^ keepSize</body><body package="COClusterManagement">keepSize: aNumber	keepSize := aNumber</body><body package="COClusterManagement">manyClustersToLoadDo: aBlock 	| oldMaxUnloadTime |	oldMaxUnloadTime := maxUnloadTime.	^ [	maxUnloadTime := SmallInteger maxVal.		aBlock value	] ensure: [ maxUnloadTime := oldMaxUnloadTime ]</body><body package="COClusterManagement">maxAccessTableAge	" Max. Alter (sek.) von AccessTable-EintrÃ¤gen. Ãltere werden entfernt "	^ 450 "15 Minuten"</body><body package="COClusterManagement">maxClusterCount	^self unloadSize</body><body package="COClusterManagement">maxUnloadSize	maxUnloadSize isNil ifTrue: [ maxUnloadSize := SmallInteger maxVal ].	^ maxUnloadSize</body><body package="COClusterManagement">maxUnloadSize: aMaxUnloadSize 	maxUnloadSize := aMaxUnloadSize</body><body package="COClusterManagement">maxUnloadTime	"default half a second"	^maxUnloadTime ifNil: [ SmallInteger maxVal ]</body><body package="COClusterManagement">maxUnloadTime: milliseconds	^maxUnloadTime := milliseconds</body><body package="COClusterManagement">newBasicUnloadableClusterIDs	^ UnloadableClustersCollection new</body><body package="COClusterManagement">removeUnloadableClusterID: clusterID 	^ basicUnloadableClusterIDs notNil 		ifTrue: [ basicUnloadableClusterIDs remove: clusterID ifAbsent: nil ]		ifFalse: [ nil ]</body><body package="COClusterManagement">unloadByteSize: anInteger	" max. cluster byte size on disk "	"unloadByteSize := anInteger"	CoastError raiseSignal: 'unloadByteSize: not supported, use maxMemory: instead'.</body><body package="COClusterManagement">unloadSize	^unloadSize</body><body package="COClusterManagement">unloadSize: aNumber	unloadSize := aNumber</body><body package="COClusterManagement">unloadableClusterIDs	^ basicUnloadableClusterIDs notNil 		ifTrue: [ basicUnloadableClusterIDs ]		ifFalse: [ OrderedCollection new ]</body></methods><methods><class-id>COAST.CatCSUnloadStrategy</class-id> <category>private</category><body package="COClusterManagement">compressAccessTable	| keysToRemove maxAge ccs |	accessTable isNil ifTrue: [ ^ self ].	(lastAccessTableCompress isNil or: [ lastAccessTableCompress + 120 &lt; Time secondClock ]) ifFalse: [^self ].	CoastLog logDebug: 'Compressing access table' channel: #unloadProcess.	lastAccessTableCompress := Time secondClock.	ccs := self clusterManager clusterController.	keysToRemove := OrderedCollection new.	maxAge := Time secondClock - self maxAccessTableAge.	accessTable keysAndValuesDo: 		[: clusterID : info | ( info accessTime &lt; maxAge and: [( ccs includesKey: clusterID ) not ]) 				ifTrue: [ keysToRemove add: clusterID ]		].	keysToRemove do: [: clusterID | accessTable removeKey: clusterID ].	CoastLog logDebug: 'Removed ' , keysToRemove size printString , ' entries' channel: #unloadProcess</body><body package="COClusterManagement">systemSupport	systemSupport isNil		ifTrue: [ systemSupport := OSSystemSupport concreteClass new ].	^ systemSupport</body></methods><methods><class-id>COAST.CatCSUnloadStrategy</class-id> <category>cluster unload</category><body package="COClusterManagement">nonWeakObservedClustersFor: cm 	| clustersToKeep |	clustersToKeep := Set new.	cm clusters do: 			[:cluster | 			cluster hasNonWeakObservers 				ifTrue: [clustersToKeep add: cluster clusterID]].	^clustersToKeep</body></methods><methods><class-id>COAST.CatCSUnloadStrategy</class-id> <category>copying</category><body package="COClusterManagement">initializeFrom: anotherUnloadStrategy	"transfer all those values that the configuration usually sets"	self		keepSize: anotherUnloadStrategy keepSize;		unloadSize: anotherUnloadStrategy unloadSize;		maxUnloadTime: anotherUnloadStrategy maxUnloadTime.	^self</body><body package="COClusterManagement">postCopy	accessTable := nil.	basicUnloadableClusterIDs := nil.	keepClusterIDs := nil.	super postCopy.</body></methods><methods><class-id>COAST.CatCSUnloadStrategy</class-id> <category>printing</category><body package="COClusterManagement">additionalInfoStringOn: stream	super additionalInfoStringOn: stream.	stream cr; tab; nextPutAll: 'maxMemory: '.	self maxMemory printOn: stream.	stream cr; tab; nextPutAll: 'keepSize: '.	self keepSize printOn: stream.	stream cr; tab; nextPutAll: 'unloadSize: '.	self unloadSize printOn: stream.	stream cr; tab; nextPutAll: 'maxUnloadTime: '.	self maxUnloadTime printOn: stream.	stream cr; tab; nextPutAll: 'maxUnloadSize: '.	self maxUnloadSize printOn: stream.</body></methods><methods><class-id>COAST.CatCSUnloadStrategy class</class-id> <category>default</category><body package="COClusterManagement">defaultKeepSize	^100</body><body package="COClusterManagement">defaultUnloadSize	^200</body></methods><methods><class-id>COAST.CatCSUnloadStrategy class</class-id> <category>accessing</category><body package="COClusterManagement">allActive	| strategies |	strategies := OrderedCollection new.	CatCSUnloadStrategy subclasses do: [ : sc |		strategies addAll: sc allInstances.		].	^ strategies singleElementOnError:  [ strategies ]</body></methods><methods><class-id>COAST.CatCSUnloadStrategy class</class-id> <category>instance creation</category><body package="COClusterManagement">newWith: manager 	| newInst |	newInst := super newWith: manager.	newInst unloadSize: self defaultUnloadSize.	newInst keepSize: self defaultKeepSize.	^ newInst</body></methods><methods><class-id>COAST.LRUUnloadStrategy</class-id> <category>load / unload</category><body package="COClusterManagement">notifyClusterAccess: clusterIDInteger 	"skip first access.for fast reads, the load will simulate an access"	super notifyClusterAccess: clusterIDInteger.	( self keepClusterIDs includes: clusterIDInteger ) ifFalse: [ self addUnloadableClusterID: clusterIDInteger ]</body></methods><methods><class-id>COAST.LRUUnloadStrategy class</class-id> <category>constants</category><body package="COClusterManagement">strategyShortName	^ 'LRU'</body></methods><methods><class-id>COAST.SCUnloadStrategy</class-id> <category>accessing</category><body package="COClusterManagement">newBasicUnloadableClusterIDs	^ SortedCollection sortBlock: 		[: cidA : cidB | | infoA infoB |			infoA := accessTable at: cidA.			infoB := accessTable at: cidB.			infoA loadFromMediatorCount = infoB loadFromMediatorCount 				ifTrue: 				[	infoA loadFromCacheCount = infoB loadFromCacheCount 						ifTrue: [ infoA accessTime &lt; infoB accessTime ]						ifFalse: [ infoA loadFromCacheCount &lt; infoB loadFromCacheCount ]				]				ifFalse: [ infoA loadFromMediatorCount &lt; infoB loadFromMediatorCount ]		]</body></methods><methods><class-id>COAST.SCUnloadStrategy</class-id> <category>load / unload</category><body package="COClusterManagement">notifyCacheLoad: clusterID 	super notifyCacheLoad: clusterID.	( self includesUnloadableClusterID: clusterID ) 		ifTrue: [ basicUnloadableClusterIDs reSort ]		ifFalse: [( self keepClusterIDs includes: clusterID ) ifFalse: [ self addUnloadableClusterID: clusterID ]]</body><body package="COClusterManagement">notifyLoadCluster: cluster 	super notifyLoadCluster: cluster.	( self includesUnloadableClusterID: cluster clusterID ) 		ifTrue: [ basicUnloadableClusterIDs reSort ]		ifFalse: [( self keepClusterIDs includes: cluster clusterID ) ifFalse: [ self addUnloadableClusterID: cluster clusterID ]]</body></methods><methods><class-id>COAST.SeparableFileTranscript</class-id> <category>accessing</category><body package="COUtilities">maxLogSize	^ maxLogSize ifNil: [ -1 ]</body><body package="COUtilities">maxLogSize: aMaxLogSize 	maxLogSize := aMaxLogSize.</body></methods><methods><class-id>COAST.SeparableFileTranscript</class-id> <category>updating</category><body package="COUtilities">update: aParameter 	"HeadlessImage isActive ifFalse: [^self]."	aParameter == #appendEntry ifTrue: [ ^ self appendEntry ].	aParameter == #update ifTrue: [ ^ self updateContents ].</body></methods><methods><class-id>COAST.SeparableFileTranscript</class-id> <category>private</category><body package="COUtilities">appendEntry	| string | 	[	string := transcript nextEntry asString.		stream nextPutAll: string.		stream flush	] on: Error do: [: ex | ex return ].	self maxLogSize &lt; 1 ifFalse: 		[( self stream size &gt; self maxLogSize and: [ string last == Character cr or: [ string last == Character lf ]]) ifTrue: 				[	"dont wine to the transcript here !!!"					self backupOldLogFile				]		].</body><body package="COUtilities">backupOldLogFile	"close"	| filenameStream timestamp oldLog oldFilename newFilename |	self release.	"move"	oldFilename := self filename asString.	oldLog := Filename named: oldFilename.	timestamp := Timestamp now.	filenameStream := String new writeStream.	filenameStream nextPutAll: oldLog tail; nextPut: $-.	timestamp coastLogFilePrintOn: filenameStream.	filenameStream nextPutAll: oldLog extension.	newFilename := filenameStream contents.	[ oldLog renameTo: ( oldLog directory construct: newFilename )] on: Error		do: 		[: ex |			"dont whine to the transcript here !!!"		].	"the same as new ;-)"	self filename: oldFilename.</body></methods><methods><class-id>COAST.SeparableFileTranscript class</class-id> <category>instance creation</category><body package="COUtilities">named: aName maxLogSize: anIntegerOrNil 	| newInst |	newInst := self named: aName.	anIntegerOrNil notNil ifTrue: [ newInst maxLogSize: anIntegerOrNil ].	^ newInst</body></methods><methods><class-id>COAST.CoastXMLApplicationLogger</class-id> <category>accessing</category><body package="COClusterManagement">defaultEncoding	^ 'UTF-8'</body><body package="COClusterManagement">genericKeys	^ genericKeys</body><body package="COClusterManagement">genericKeys: aBoolean	genericKeys := aBoolean</body></methods><methods><class-id>COAST.CoastXMLApplicationLogger</class-id> <category>initialize-release</category><body package="COClusterManagement">initialize	super initialize.	genericKeys := false.	self setupEntitiyTable.</body><body package="COClusterManagement">setupEntitiyTable	entityTable := Dictionary new.	entityTable		at: $&amp; put: '&amp;amp;';		at: $&lt; put: '&amp;lt;';		at: $&gt; put: '&amp;gt;'</body></methods><methods><class-id>COAST.CoastXMLApplicationLogger</class-id> <category>API</category><body package="COClusterManagement">basicAddToApplicationLog: aCatCSApplicationLog	internalStream nextPutAll: '&lt;Transaction timestamp="', Timestamp now coastShortPrintString, '"&gt;';cr.	aCatCSApplicationLog logEntries do: [ : logEntry |		internalStream nextPutAll: '	&lt;Entry&gt;';cr.		logEntry keysAndValuesDo: [ : key : value |			self writeKey: key value: value.		].		internalStream nextPutAll: '	&lt;/Entry&gt;';cr.	].	internalStream nextPutAll: '&lt;/Transaction&gt;';cr.</body></methods><methods><class-id>COAST.CoastXMLApplicationLogger</class-id> <category>private</category><body package="COClusterManagement">openStream	super openStream.	internalStream lineEndConvention: externalStream lineEndConvention.</body><body package="COClusterManagement">writeGenericKey: key value: value	internalStream nextPutAll: '&lt;Pair&gt;&lt;Key&gt;'.	self writeText: key.	internalStream nextPutAll: '&lt;/Key&gt;&lt;Value&gt;'.	self writeText: value.	internalStream nextPutAll: '&lt;/Value&gt;&lt;/Pair&gt;'.</body><body package="COClusterManagement">writeKey: key value: value	internalStream nextPutAll: '		'.	self genericKeys		ifTrue: [ self writeGenericKey: key value: value ]		ifFalse: [ self writeKeyTag: key value: value ].	internalStream cr.</body><body package="COClusterManagement">writeKeyTag: key value: value	internalStream nextPutAll: '&lt;'.	internalStream nextPutAll: key.	internalStream nextPutAll: '&gt;'.	self writeText: value displayString.	internalStream nextPutAll: '&lt;/'.	internalStream nextPutAll: key.	internalStream nextPutAll: '&gt;'.</body><body package="COClusterManagement">writeText: aString 	| enc |	enc := self encoder.	aString do: 		[: c | | ent |			( ent := entityTable at: c ifAbsent: [ nil ]) notNil 				ifTrue: [ 	internalStream nextPutAll: ent  ]				ifFalse: 				[ (( enc coastCanEncode: c ) and: [ (XML.CharacterClasses at: c asInteger+1) &gt; 0])						ifTrue: [ internalStream nextPut: c ]						ifFalse: 						[	internalStream nextPutAll: '&amp;#'; print: c asInteger;								nextPut: $;						]				]		].</body></methods><methods><class-id>COAST.CoastXMLApplicationLogger class</class-id> <category>accessing</category><body package="COClusterManagement">defaultFilename	^ defaultFilename ifNil: [ 'application.log.xml' ].</body></methods><methods><class-id>COAST.CoastXMLApplicationLogger class</class-id> <category>testing</category><body package="COClusterManagement">isAbstract	^ false</body></methods><methods><class-id>COAST.CoastMemoryPolicy</class-id> <category>low space</category><body package="COUtilities">defaultLowSpaceHandlerMargin	^ 10000000</body><body package="COUtilities">emergencyLowSpaceAction	"Take an appropriate action when space falls to or below the hard low-spave limit."	"shut up and restart"	emergencyLowSpaceBlock isNil 		ifTrue: [ super emergencyLowSpaceAction ]		ifFalse: [ emergencyLowSpaceBlock value ].</body><body package="COUtilities">lowSpaceHandlerMargin	^ lowSpaceHandlerMargin notNil		ifTrue: [ lowSpaceHandlerMargin ] 		ifFalse: [ self defaultLowSpaceHandlerMargin ]</body><body package="COUtilities">lowSpaceHandlerMargin: anInteger	lowSpaceHandlerMargin := anInteger</body><body package="COUtilities">shouldNotifyLowSpace	"	Transcript show: 'Upper: ' , self memoryUpperBound printString; cr.	Transcript show: 'Allocated: ' , ObjectMemory dynamicallyAllocatedFootprint printString; cr.	Transcript show: 'Available: ' , ObjectMemory current availableFreeBytes printString; cr.	Transcript show: '-&gt; left: ' , ( self memoryUpperBound - ObjectMemory dynamicallyAllocatedFootprint + ObjectMemory current availableFreeBytes ) printString; cr."	^ ( self isSpaceLowAfter and: [ ObjectMemory hardLowSpaceLimit &gt; 0 ]) or: 		[	self memoryUpperBound &gt; 0 and: 				[	self memoryUpperBound - ObjectMemory dynamicallyAllocatedFootprint + ObjectMemory current availableFreeBytes &lt; self lowSpaceHandlerMargin				]		]</body></methods><methods><class-id>COAST.CoastMemoryPolicy</class-id> <category>accessing</category><body package="COUtilities">emergencyLowSpaceBlock: aEmergencyLowSpaceBlock 	emergencyLowSpaceBlock := aEmergencyLowSpaceBlock</body></methods><methods><class-id>COAST.CoastMemoryPolicy</class-id> <category>initialize-release</category><body package="COUtilities">setDefaults	| physMem |	super setDefaults.	(physMem := OSSystemSupport concreteClass new coastMaxMemory) notNil		ifTrue: [ 			memoryUpperBound := physMem - (50 * 1024 * 1024).			growthRegimeUpperBound := (memoryUpperBound * 9 // 10) min: (120 * 1024 * 1024).		]		ifFalse: [ 			growthRegimeUpperBound := 120 * 1024 * 1024.		].</body></methods><methods><class-id>COAST.CoastMemoryPolicy</class-id> <category>growing memory</category><body package="COUtilities">growMemoryBy: growthRequired 	" no-op "	^ true</body></methods><methods><class-id>COAST.CoastMemoryPolicy class</class-id> <category>instance-creation</category><body package="COUtilities">installInSystem	ObjectMemory installMemoryPolicy: self new setDefaults</body></methods><methods><class-id>COAST.CoastMemoryPolicy class</class-id> <category>accessing</category><body package="COUtilities">flushLowSpaceHandler	LowSpaceHandler := nil.	ObjectMemory currentMemoryPolicy emergencyLowSpaceBlock: nil</body><body package="COUtilities">lowSpaceHandler: anObject	LowSpaceHandler := anObject</body><body package="COUtilities">lowSpaceHandlerDo: aBlock 	^ LowSpaceHandler		ifNotNil: [ : handler | (aBlock value: handler) == true ]		ifNil: [ true ]</body></methods><methods><class-id>COAST.CatCSVolumeStorageAccessor</class-id> <category>private</category><body package="COClusterManagement">basicNewClusterStorageAccessorFor: aVolume	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSVolumeStorageAccessor</class-id> <category>auto repair</category><body package="COClusterManagement">checkVolume: volume 	" make sure that the volume is OK "	" returns nil if OK, or a string with an error message "	self checkVolume: volume clusterManager: nil.</body><body package="COClusterManagement">checkVolume: volume clusterManager: clusterManagerOrNil 	" make sure that the volume is OK "	" returns nil if OK, or a string with an error message "	self subclassResponsibility.</body><body package="COClusterManagement">checkVolumes	CoastLog log: 'checking all volumes started'.	self storedVolumes do: [: volume |		self checkVolume: volume ].	CoastLog log: 'checking all volumes finished'.</body><body package="COClusterManagement">deepCheckVolume: volume	" perform a thorough check of the volume "	^ self checkVolume: volume</body><body package="COClusterManagement">quickRecoverVolume: volumeName	^ self recoverVolume: volumeName</body><body package="COClusterManagement">recoverVolume: volumeName	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSVolumeStorageAccessor</class-id> <category>accessing</category><body package="COClusterManagement">configuration	^ configuration</body><body package="COClusterManagement">configuration: appConfiguration	configuration := appConfiguration.	configuration iniAccess ifNotNil: [ : ini | self configureWithIni: ini ].</body><body package="COClusterManagement">deleteBackup: oldVolume version: version	self subclassResponsibility</body><body package="COClusterManagement">deleteVolume: oldVolume	self subclassResponsibility</body><body package="COClusterManagement">newClusterStorageAccessorFor: aClusterManager 	| csa |	csa := self basicNewClusterStorageAccessorFor: aClusterManager volume.	self configuration ifNotNil: [: cfg | cfg iniAccess ifNotNil: [: ini | csa configureWithIni: ini ]].	csa volumeAccessor: self.	csa startUpStorageAccessorFrom: aClusterManager.	^ csa</body><body package="COClusterManagement">recoverVolume: oldVolume version: version to: recoverVolume	self subclassResponsibility</body><body package="COClusterManagement">recoverableVolumes	"retreive all available stored volumes, answer a set of volumenames"	self subclassResponsibility</body><body package="COClusterManagement">replaceVolume: oldVolume with: newVolume	self subclassResponsibility</body><body package="COClusterManagement">sizeOfBlobOrCluster: clusterID in: volume 	self subclassResponsibility</body><body package="COClusterManagement">storedVolumes	"retreive all available stored volumes, answer a set of volumenames"	self subclassResponsibility</body><body package="COClusterManagement">volumeExists: aVolume	" true if the volume exists "	" default implementation, might be slow "	^ self storedVolumes includes: aVolume</body></methods><methods><class-id>COAST.CatCSVolumeStorageAccessor</class-id> <category>config</category><body package="COClusterManagement">configureWithIni: iniAccess</body></methods><methods><class-id>COAST.CatCSVolumeStorageAccessor</class-id> <category>initialize-release</category><body package="COClusterManagement">initialize</body><body package="COClusterManagement">shutDown</body></methods><methods><class-id>COAST.CatCSVolumeStorageAccessor class</class-id> <category>accessing</category><body package="COClusterManagement">isAbstract	^ true</body><body package="COClusterManagement">storageAccessorClass	^self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSVolumeStorageAccessor class</class-id> <category>instance creation</category><body package="COClusterManagement">new	^ super new initialize</body></methods><methods><class-id>COAST.CatCSAbstractDiskVolumeAccessor</class-id> <category>directories</category><body package="COClusterManagement">backupDirectory	"answer the volume directory as filename"	"create the directory if not existent"	^ backupDirectory ifNil: 		[	backupDirectory := self class defaultBackupDirectory isNil 					ifTrue: [ self baseDirectory construct: CoastConstant defaultBackupDirectory ]					ifFalse: [ self class defaultBackupDirectory ]		]</body><body package="COClusterManagement">backupDirectory: aDirectory	backupDirectory := aDirectory asFilename.</body><body package="COClusterManagement">baseDirectory	" base directory for all directories (volumes, backup, download*) "	baseDirectory isNil ifTrue: 		[ | dir |			dir := self class defaultBaseDirectory.			dir isNil ifTrue: [ dir := '.' asFilename ].			dir isRelative ifTrue: [ dir := dir head asFilename construct: dir tail ].			dir exists ifFalse: 				[	dir makeFullDirectory.					dir exists ifFalse: [ self error: 'cannot access base directory: ' , dir asString ].					dir makeWritable				].			baseDirectory := dir		].	^ baseDirectory</body><body package="COClusterManagement">baseDirectory: aDirectory 	baseDirectory := aDirectory asFilename.	" 'volumes' abschneiden "	baseDirectory tail = CoastConstant defaultVolumeDirectory 		ifTrue: [ baseDirectory := baseDirectory directory ].	^ baseDirectory</body><body package="COClusterManagement">directoryForVolume: aVolume	self subclassResponsibility</body><body package="COClusterManagement">volumeDirectory	"answer the volume directory as filename"	volumeDirectory isNil ifTrue: [ volumeDirectory := self class defaultVolumesDirectory ifNil: [ self baseDirectory construct: CoastConstant defaultVolumeDirectory ]].	^ volumeDirectory</body><body package="COClusterManagement">volumeDirectory: aDirectory	volumeDirectory := aDirectory asFilename.</body></methods><methods><class-id>COAST.CatCSAbstractDiskVolumeAccessor</class-id> <category>private</category><body package="COClusterManagement">deleteDirectory: deleteDir	deleteDir definitelyExists		ifTrue: [			deleteDir directoryContents do: [: clusterName |  | file |				file := deleteDir construct: clusterName.				file isDirectory 					ifTrue: [self deleteDirectory: file]					ifFalse: [file delete]			].			deleteDir directoryContents isEmpty ifTrue: [deleteDir delete].		].</body><body package="COClusterManagement">ensureDirectoryNamed: dirName	| dir |	dir := self baseDirectory construct: dirName.	dir ensureFullDirectory.	^ dir</body><body package="COClusterManagement">isValidBackup: aFilename 	" true if the filename contains a valid backup "	^ aFilename isDirectory</body><body package="COClusterManagement">isVolumeDirectory: aFilename	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSAbstractDiskVolumeAccessor</class-id> <category>accessing</category><body package="COClusterManagement">backupDirectoryForVolume: oldVolume 	^ self backupDirectory construct: oldVolume</body><body package="COClusterManagement">deleteBackup: oldVolume version: version	| backupDir |	backupDir := self backupDirectoryForVolume: oldVolume.	self deleteDirectory: (backupDir construct: version).	backupDir directoryContents isEmpty ifTrue: [backupDir delete].</body><body package="COClusterManagement">deleteVolume: oldVolume	self deleteDirectory: (self volumeDirectory construct: oldVolume).</body><body package="COClusterManagement">recoverableVolumes	"retreive all available stored volumes, answer a set of 	volumenames"	| backDir result |	backDir := self backupDirectory.	result := Dictionary new.	(backDir notNil and: [ backDir exists ])		ifTrue: 		[	backDir directoryContents do: 				[: vol | | volDir |					volDir := backDir construct: vol.					volDir isDirectory 						ifTrue: 						[	result 								at: vol								put: ( volDir directoryContents select: 										[: time | | timeDir |											timeDir := volDir construct: time.											self isValidBackup: timeDir										])						]				]		].	^ result</body><body package="COClusterManagement">removeBackups: volume except: numberOfBackupsToKeep 	| backupBaseDirectory allBackups toDelete backupsToDelete |	backupBaseDirectory := self backupDirectoryForVolume: volume.	backupBaseDirectory exists 		ifFalse: 		[	CoastLog log: 'No backups for volume ' , volume , ' found, nothing to remove'.			^ self		].	allBackups := OrderedCollection new.	backupBaseDirectory directoryContents do: 		[: dirName |			(backupBaseDirectory construct: dirName) isDirectory 				ifTrue: [ allBackups add: dirName ]		].	toDelete := allBackups size - numberOfBackupsToKeep.	toDelete &gt; 0 		ifTrue: 		[	CoastLog log: 'Removing ' , toDelete printString , ' old backups'.			backupsToDelete := ( allBackups sortedBy: [: dirName | dirName asInteger ]) copyFrom: 1 to: toDelete.			backupsToDelete do: 				[: version |					CoastLog log: 'Removing backup ' , version , ' (' , ( CatCSVolumeManager descriptionForBackupVersion: version ) , ')'.					self deleteBackup: volume version: version				]		]		ifFalse: [ CoastLog log: 'No obsolete backups for volume ' , volume , ' found, nothing to remove' ].</body><body package="COClusterManagement">storedVolumes	"retreive all available stored volumes, answer a set of volumenames"	| vd |	vd := self volumeDirectory.	vd isNil ifTrue: [ ^ Set new ].	vd definitelyExists ifFalse: [ ^ Set new ].	vd isDirectory ifFalse: [ ^ Set new ].	^ ( vd directoryContents select: 		[: s | | concreteVolumeDirectory |			concreteVolumeDirectory := vd construct: s.			self isVolumeDirectory: concreteVolumeDirectory.		]) 		asSet</body><body package="COClusterManagement">volumeExists: aVolume	| volumesDirectory concreteVolumeDirectory |	volumesDirectory := self volumeDirectory.	volumesDirectory isNil ifTrue: [ ^ false ].	volumesDirectory definitelyExists ifFalse: [ ^ false ].	volumesDirectory isDirectory ifFalse: [ ^ false ].	concreteVolumeDirectory :=  volumesDirectory construct: aVolume.	^ self isVolumeDirectory: concreteVolumeDirectory</body></methods><methods><class-id>COAST.CatCSAbstractDiskVolumeAccessor</class-id> <category>config</category><body package="COClusterManagement">configureDirectoriesWithIni: iniAccess 	| volumesDir backupDir baseDir |	volumesDir := iniAccess stringAt: CoastConstant iniAccessVolumesDirectory ifAbsent: [ nil ].	volumesDir notNil 		ifTrue: [ self volumeDirectory: volumesDir asFilename ].	backupDir := iniAccess stringAt: CoastConstant iniAccessBackupDirectory ifAbsent: [ nil ].	backupDir notNil 		ifTrue: [ self backupDirectory: backupDir asFilename ].	baseDir := iniAccess 			stringAt: CoastConstant iniAccessBaseDirectory			ifAbsent: [ iniAccess stringAt: CoastConstant defaultVolumeDirectory ifAbsent: [ nil ]].	baseDir notNil 		ifTrue: [ self baseDirectory: baseDir ].</body><body package="COClusterManagement">configureWithIni: iniAccess 	super configureWithIni: iniAccess.	self configureDirectoriesWithIni: iniAccess .</body></methods><methods><class-id>COAST.CatCSAbstractDiskVolumeAccessor class</class-id> <category>accessing</category><body package="COClusterManagement">defaultBackupDirectory	^ defaultBackupDirectory</body><body package="COClusterManagement">defaultBackupDirectory: aFilename	defaultBackupDirectory :=  aFilename isNil ifTrue: [ nil ] ifFalse: [ aFilename asFilename ]</body><body package="COClusterManagement">defaultBaseDirectory	^ defaultBaseDirectory</body><body package="COClusterManagement">defaultBaseDirectory: aFilename	" base directory for volumes, backup, download* "	defaultBaseDirectory := aFilename isNil ifTrue: [ nil ] ifFalse: [ aFilename asFilename ]</body><body package="COClusterManagement">defaultVolumesDirectory	^defaultVolumesDirectory</body><body package="COClusterManagement">defaultVolumesDirectory: aFilename	defaultVolumesDirectory :=  aFilename isNil ifTrue: [ nil ] ifFalse: [ aFilename asFilename ]</body><body package="COClusterManagement">resetDefaultDirectory	"self resetDefaultDirectory"	defaultBaseDirectory := nil</body></methods><methods><class-id>COAST.CatCSAbstractDiskVolumeAccessor class</class-id> <category>compatibility</category><body package="COClusterManagement">defaultDirectory	^ defaultBaseDirectory</body><body package="COClusterManagement">defaultDirectory: aFilename	defaultBaseDirectory := aFilename isNil ifTrue: [ nil ] ifFalse: [ aFilename asFilename ]</body></methods><methods><class-id>COAST.CatCSVolumeFileStorageAccessor</class-id> <category>private</category><body package="COClusterManagement">basicNewClusterStorageAccessorFor: aVolume	"aVolume must be accessed later (after connection to clusterManager)"	^CatCSFileStorageAccessor new.</body><body package="COClusterManagement">isVolumeDirectory: aFilename 	^ aFilename isDirectory and: [( aFilename construct: 'volume.ini' ) exists ]</body></methods><methods><class-id>COAST.CatCSVolumeFileStorageAccessor</class-id> <category>directories</category><body package="COClusterManagement">directoryForVolume: aVolume	| newDirectory |	newDirectory := self volumeDirectory construct: aVolume.	newDirectory ensureFullDirectory.	^newDirectory</body></methods><methods><class-id>COAST.CatCSVolumeFileStorageAccessor</class-id> <category>auto repair - private</category><body package="COClusterManagement">checkCoastVersionOfVolume: volume	| storageAccessor volumeVersion |	storageAccessor := self basicNewClusterStorageAccessorFor: volume.	storageAccessor volumeAccessor: self.	storageAccessor workingDirectory: (self directoryForVolume: volume).	volumeVersion := storageAccessor coastVersion.	storageAccessor releaseVolumeAccess.	volumeVersion notNil		ifTrue: [			CoastVersion defaultCoastVersion &lt; volumeVersion				ifTrue: [	^self logAndReturn: 'volume ' , volume printString , 							' was created by newer version of COAST: ', volumeVersion printString					].		].	^ nil</body><body package="COClusterManagement">checkWritabilityOfVolume: volume	" check that the volume can be written.	doesn't check all files, just the directory, volume.ini and 0.cls "	| directory volumeIni storageAccessor clusterZero |	directory := self directoryForVolume: volume.	directory isWritable		ifFalse:[	^self logAndReturn: 'volume ' , volume printString , ' is locked: directory is write-protected' ].	storageAccessor := self basicNewClusterStorageAccessorFor: volume.	volumeIni := (storageAccessor volumeIniFileIn: directory) asFilename.	(volumeIni notNil and: [ volumeIni exists and: [ volumeIni isWritable not ]])		ifTrue: [ ^self logAndReturn: 'volume ' , volume printString , ' is locked: volume.ini file is write-protected' ].	clusterZero := directory construct: '0.cls'.	(clusterZero notNil and: [ clusterZero exists and: [ clusterZero isWritable not ]])		ifTrue: [	^self logAndReturn: 'volume ' , volume printString , ' is locked: cluster 0 is write-protected' ].			^ nil</body><body package="COClusterManagement">cleanUpBrokenVolume: lockedVolume from: recoverDir	| directoryContents directory |	directory := self directoryForVolume: lockedVolume.	directoryContents := recoverDir directoryContents asOrderedCollection.	(directoryContents includes: 'finished')		ifTrue: [	"move saved clusters from temp to volume"				directoryContents remove: 'finished'. 				directoryContents do: [: fileName | 					( recoverDir construct: fileName ) moveToRecursively: ( directory construct: fileName )].				(recoverDir construct: 'finished') delete.				recoverDir delete.				CoastLog log: 'volume ' , lockedVolume printString , ': recovered successfully' ]		ifFalse: [ "remove files (not finished clusters OR the 'finished' file"				recoverDir deleteRecursively.				CoastLog log: 'volume ' , lockedVolume printString , ': unfixable - removed temp directory' ].</body><body package="COClusterManagement">lockVolume: volume infoString: infoString	| fileLock directory |	directory := self directoryForVolume: volume.	fileLock := FileLock filename: ( directory construct: 'lock' ) infoString: infoString.	fileLock getLock.	(fileLock hasLock not and: [fileLock storedInfoString = 'Fatal Error during save' ])		ifTrue: [fileLock forceLock].	^fileLock</body><body package="COClusterManagement">logAndReturn: errorText 	CoastLog log: errorText.	^errorText</body><body package="COClusterManagement">recoverDirForVolume: volume ifOK: okBlock onError: errorBlock	"try to find the single recover dir	if no recover directory -&gt; execute okBlock	if multiple recover directories exist -&gt; execute errorBlock (passing the directory )"	| directory |	directory := self directoryForVolume: volume.	^ ((directory directoryContents		select: [: fileName | ( 'temp*' match: fileName ) 			and: [( directory construct: fileName ) isDirectory ]])		collect: [: string | directory construct: string ])	"&lt;-- all subdirs called temp*"		singleElementIfNone: [ okBlock value ] "no recover directory"		ifMore: ["multiple recover directories"			errorBlock value: directory ].</body><body package="COClusterManagement">recoverVolume: volume 	" try to recover the volume (if needed) "	| recoverDir |	recoverDir := self recoverDirForVolume: volume		ifOK: [ ^nil. ] 		onError: [ : dir | | fileLock |			"complicated - should not be fix here"			fileLock := self lockVolume: volume infoString: 'volume damage - must be fixed manualy'.			fileLock hasLock				ifTrue: [CoastLog log: 'volume ' , volume printString , ': locked (multiple temp files)']				ifFalse: [ CoastLog log: 'volume ' , volume printString , ': skipped (lock: ' , fileLock storedInfoString printString , ')' ].			dir ].	^self recoverVolume: volume recoverDirectory: recoverDir</body><body package="COClusterManagement">recoverVolume: volume recoverDirectory: directoryToRecover	" the volume contains a single temp directory with clusters that should be recovered "	| nilOrErrorMessage fileLock |	nilOrErrorMessage := 'volume damage - autofix failed'.	CoastLog log: 'Recovering ', volume printString, ' from ', directoryToRecover asFilename tail.	fileLock := self lockVolume: volume infoString: nilOrErrorMessage.	fileLock hasLock 		ifFalse: [ 			CoastLog log: 'Could not get lock, volume not recovered'.			^ nilOrErrorMessage ].	[	self cleanUpBrokenVolume: volume from: directoryToRecover.		fileLock releaseLock.		nilOrErrorMessage := nil	] 	on: Error		do: 	[: exception | 			"don't care aboute the lock -&gt; disable try repair next time!"			CoastLog logException: exception message: 'volume ' , volume printString , ': recover failed!'		].	^nilOrErrorMessage</body></methods><methods><class-id>COAST.CatCSVolumeFileStorageAccessor</class-id> <category>accessing</category><body package="COClusterManagement">recoverVolume: oldVolume version: version to: recoverVolume 	| sourceDir targetDir |	sourceDir := ( self backupDirectoryForVolume: oldVolume ) construct: version.	sourceDir exists 		ifFalse: [ CoastError raiseSignal: 'Backup ' , sourceDir asString , ' does not exist' ].	targetDir := self volumeDirectory construct: recoverVolume.	targetDir ensureFullDirectory.	sourceDir subDirsAndFilesDo: 		[: subDir : fileName | | sourceFile targetFile |			sourceFile := ( sourceDir construct: subDir ) construct: fileName.			targetFile := ( targetDir construct: subDir )					ensureFullDirectory;					construct: fileName.			sourceFile copyTo: targetFile		].</body><body package="COClusterManagement">replaceVolume: oldVolume with: newVolume	| oldName |	oldVolume = newVolume ifTrue: [ ^ self error: 'Cannot replace volume ', oldVolume printString, ' with itself' ].	oldName := self volumeDirectory construct: oldVolume.	self deleteDirectory: oldName.	(self volumeDirectory construct: newVolume) renameTo: oldName.</body><body package="COClusterManagement">sizeOfBlobOrCluster: clusterID in: volume 	| directory |	directory := self volumeDirectory.	directory isNil ifTrue: [ ^ 0 ].	directory definitelyExists ifFalse: [ ^ 0 ].	directory isDirectory ifFalse: [ ^ 0 ].	directory := directory construct: volume.	directory definitelyExists ifFalse: [ ^ 0 ].	directory isDirectory ifFalse: [ ^ 0 ].	^ directory sizeOfBlobOrCluster: clusterID</body></methods><methods><class-id>COAST.CatCSVolumeFileStorageAccessor</class-id> <category>auto repair</category><body package="COClusterManagement">checkVolume: volume clusterManager: clusterManagerOrNil 	| nilOrErrorMessage | 	[	nilOrErrorMessage := self checkVolumeLock: volume clusterManager: clusterManagerOrNil.		nilOrErrorMessage isNil ifTrue: [ nilOrErrorMessage := self recoverVolume: volume ].		nilOrErrorMessage isNil ifTrue: [ nilOrErrorMessage := self checkWritabilityOfVolume: volume ].		nilOrErrorMessage isNil ifTrue: [ nilOrErrorMessage := self checkCoastVersionOfVolume: volume ].		nilOrErrorMessage isNil ifTrue: [ CoastLog log: 'volume ' , volume printString , ': ok' ]	] on: Error		do: 		[: ex |			CoastLog logException: ex message: 'Error while checking volume ' , volume printString.			nilOrErrorMessage := ex description		].	^ nilOrErrorMessage</body></methods><methods><class-id>COAST.CatCSVolumeFileStorageAccessor</class-id> <category>As yet unclassified</category><body package="COClusterManagement">checkVolumeLock: volume clusterManager: clusterManagerOrNil 	| fileLock directory errorText |	directory := self directoryForVolume: volume.	fileLock := FileLock filename: (directory construct: 'lock') infoString: ''.	(clusterManagerOrNil notNil 		and: [ fileLock isLockedByOtherProcess and: [ clusterManagerOrNil canCaptureFileLock: fileLock ] ]) 			ifTrue: 			[	CoastLog log: 'Found reincarnation of volume accessor - about to remove lock'.				fileLock forceLock.				fileLock releaseLock 			].	fileLock fileExists ifFalse: [ ^ nil ].	errorText := 'volume ' , volume printString , ' is locked: ' , fileLock storedInfoString.	CoastLog log: errorText.	^ errorText</body></methods><methods><class-id>COAST.CatCSVolumeFileStorageAccessor class</class-id> <category>accessing</category><body package="COClusterManagement">isAbstract	^ false</body><body package="COClusterManagement">storageAccessorClass	^CatCSFileStorageAccessor</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>accessing - comfy</category><body package="COUtilities">cr	self logLevel: LogLevelNormal do: [ self basicCr ]</body><body package="COUtilities">exceptionFirstContextOutsideLog	| cls context |	context := thisContext.	[ context sender notNil and: [( cls := context coastHomeClass ) == self class or: [ cls == self class class ]]] whileTrue: [ context := context sender ].	^ context</body><body package="COUtilities">flush	" initiate flushing the log "	logQueue nextPut: #processLogEntryFlush.</body><body package="COUtilities">flushAndWait	"  flush and wait until we're sure that the log was flushed  "	| semaphore |	self flush.	semaphore := Semaphore new.	logQueue nextPut: #processLogEntrySemaphore.	logQueue nextPut: semaphore.	[ semaphore wait ] coastValueWithinMilliseconds: 100 orDo: [ ].</body><body package="COUtilities">log: aStringOrBlock	self logLevel: LogLevelNormal show: aStringOrBlock.</body><body package="COUtilities">log: aStringOrBlock channel: aSymbol	self logLevel: LogLevelNormal channel: aSymbol show: aStringOrBlock</body><body package="COUtilities">logDebug: aStringOrBlock channel: aSymbol	self logLevel: LogLevelDebug channel: aSymbol show: aStringOrBlock</body><body package="COUtilities">logDebug: aStringOrBlock channel: aSymbol minTime: time 	( minTime isNil or: [ time &lt; minTime ]) ifTrue: [ ^ self ].	self logDebug: aStringOrBlock channel: aSymbol</body><body package="COUtilities">logDebug: aStringOrBlock minTime: time 	( minTime isNil or: [ time &lt; minTime ]) ifTrue: [ ^ self ].	self logDebug: aStringOrBlock</body><body package="COUtilities">logDebugNotify: aStringOrBlock	^ self logLevel: LogLevelDebugNotify show: aStringOrBlock</body><body package="COUtilities">logDebugNotify: aStringOrBlock channel: aSymbol	self logLevel: LogLevelDebugNotify channel: aSymbol show: aStringOrBlock</body><body package="COUtilities">logDeveloper: aStringOrBlock	Notifier isDevelopment		ifTrue: [ 	self logLevel: LogLevelNormal show: aStringOrBlock ].</body><body package="COUtilities">logError: aStringOrBlock	self logLevel: LogLevelError show: aStringOrBlock.	self flush</body><body package="COUtilities">logError: aStringOrBlock channel: aSymbol	self logLevel: LogLevelError channel: aSymbol show: aStringOrBlock.	self flush</body><body package="COUtilities">logException: exception message: message 	self logException: exception message: message level: LogLevelError</body><body package="COUtilities">logException: exception message: message level: level 	self logExceptionBlock notNil 		ifTrue: [ self logExceptionBlock cull: exception cull: message cull: level ]		ifFalse: [ self defaultLogException: exception message: message level: level ].</body><body package="COUtilities">logExceptionShort: exception logLevel: aLogLevel message: message 	self haltOnExceptions 		ifTrue: [ self haltOrContinue: message ].	self 		logLevel: aLogLevel		show: 		[ | messageStream context |			messageStream := String new writeStream.			context := self exceptionFirstContextOutsideLog.			messageStream				nextPutAll: message; cr;				nextPutAll: '--- ' , Timestamp now coastShortPrintString , ' ---'; cr;				nextPutAll: 'Exception:'; cr;				nextPutAll: exception description; cr;				nextPutAll: 'Call stack:'; cr.			context printStackFrom: 1 to: self exceptionLogSize on: messageStream.			messageStream cr.			messageStream nextPutAll: '--------------------------------------'; cr.			messageStream contents		].</body><body package="COUtilities">logExceptionShort: exception message: message 	self logExceptionShort: exception logLevel: LogLevelError message: message</body><body package="COUtilities">logFatalError: aStringOrBlock	self logLevel: LogLevelFatalError show: aStringOrBlock.	self flush</body><body package="COUtilities">logFatalError: aStringOrBlock channel: aSymbol	self logLevel: LogLevelFatalError channel: aSymbol show: aStringOrBlock.	self flush</body><body package="COUtilities">logFatalException: exception message: message 	self logException: exception message: message level: LogLevelFatalError</body><body package="COUtilities">logMemory: aString 	self logMemory: aString level: LogLevelDebug.</body><body package="COUtilities">logMemory: aString level: level 	self logLevel: level		show: 		[ | om str |			om := ObjectMemory current.			str := String new writeStream.			str				nextPutAll: Timestamp now coastShortPrintString; nextPutAll: ': '; nextPutAll: aString; nextPutAll: '  O:'.			om oldBytes printOn: str.			str nextPutAll: ' A:'.			om availableFreeBytes printOn: str.			str nextPutAll: ' C:'.			om contiguousFreeBytes printOn: str.			str nextPutAll: ' #RTE:'.			om rtUsedEntries printOn: str.			str contents		].</body><body package="COUtilities">logTime: aBlock	| result |	self log: (Time millisecondsToRun: [ result := aBlock value ]).	^ result</body><body package="COUtilities">logTime: aBlock channel: channel 	| result |	self log: ( Time millisecondsToRun: [ result := aBlock value ]) channel: channel.	^ result</body><body package="COUtilities">logTime: aBlock message: aString	| result t |	t := Time millisecondsToRun: [ result := aBlock value ].	self log: aString, ': ', t printString.	^ result</body><body package="COUtilities">logWarning: aStringOrBlock	self logLevel: LogLevelWarning show: aStringOrBlock.	self flush.</body><body package="COUtilities">logWarning: aStringOrBlock channel: aSymbol	self logLevel: LogLevelWarning channel: aSymbol show: aStringOrBlock.	self flush.</body><body package="COUtilities">show: aString	self logLevel: LogLevelNormal do: [ self basicShow: aString ].</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>accessing - compatibility</category><body package="COUtilities">debugDo: aBlock 	self logLevel: LogLevelDebug do: [ aBlock value ]</body><body package="COUtilities">enableConsole	^ false</body><body package="COUtilities">enableConsole: aBoolean</body><body package="COUtilities">enableConsoleWhile: aBlock	^ aBlock value</body><body package="COUtilities">logDebug: aStringOrBlock	self logLevel: LogLevelDebug show: aStringOrBlock.</body><body package="COUtilities">logDebugCr	" for compatibility.... logDebug adds a CR to the log "	self logLevel: LogLevelDebug do: [ self transcript cr ]</body><body package="COUtilities">logDebugDo: aStringOrBlock 	self logLevel: LogLevelDebug show: aStringOrBlock.</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>setup</category><body package="COUtilities">addNotifier: aCoastLogNotifier	notifiers isNil 		ifTrue: [ notifiers := SortedCollection sortBlock: [ : n1 :n2 | n1 logLevel &gt; n2 logLevel ]].	notifiers add: aCoastLogNotifier.	self logLevel: LogLevelNormal channel: #default showWithoutNotify: [ 'Log: added notifier "&lt;1s&gt;"' expandMacrosWith: aCoastLogNotifier name ].</body><body package="COUtilities">isDebug	^self logLevel &lt;= LogLevelDebug</body><body package="COUtilities">isDebug: aBoolean	aBoolean		ifTrue: [ self logLevel: LogLevelDebug ]		ifFalse: [ self logLevel: LogLevelNormal ]</body><body package="COUtilities">logLevel	^ logLevel</body><body package="COUtilities">logLevel: anInteger	" don't allow to disable warnings and errors ! "	logLevel := anInteger min: LogLevelWarning</body><body package="COUtilities">setupTranscript	Notifier 		headlessDo: [: headlessImage | headlessImage setupSeparableFileTranscript: self maxLogSize ]		elseDo: 		[	fileName notNil 				ifTrue: [ self enableFileLog: true ]		].</body><body package="COUtilities">transcript	^ Transcript</body><body package="COUtilities">transcript: aTextCollector	TextCollector newTranscript: aTextCollector.</body><body package="COUtilities">transcriptFilename	^ Notifier headlessDo: [: headlessImage | headlessImage transcriptFilename ] elseDo: [ nil ]</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>accessing</category><body package="COUtilities">enableFileLog: aBoolean 	self releaseFileTranscripts.	aBoolean 		ifTrue: 		[				[ | logFileName |				logFileName := ( fileName ifNil: [ 'coast.log' ]) asFilename.				( logFileName directory isWritable and: [ logFileName exists not or: [ logFileName isWritable ]]) 					ifTrue: [ Transcript addDependent: ( SeparableFileTranscript named: logFileName maxLogSize: maxLogSize )]					ifFalse: 					[	Stderr nextPutAll: 'cannot write log file: ' , ( logFileName directory construct: logFileName tail ) asString; cr;							flush					]			] 				on: Error				do: 				[: ex |					Stderr nextPutAll: ex description; cr;						flush.					self haltOrContinue				]		].</body><body package="COUtilities">exceptionLogSize	^ exceptionLogSize ifNil: [ 500 ]</body><body package="COUtilities">exceptionLogSize: anInteger	exceptionLogSize := anInteger</body><body package="COUtilities">haltOnExceptionLog	^ self haltOnExceptions</body><body package="COUtilities">haltOnExceptionLog: aBoolean 	self haltOnExceptions: aBoolean</body><body package="COUtilities">haltOnExceptions	^ haltOnExceptions == true</body><body package="COUtilities">haltOnExceptions: aBoolean	haltOnExceptions := aBoolean</body><body package="COUtilities">logExceptionBlock	^ logExceptionBlock</body><body package="COUtilities">logExceptionBlock: aLogExceptionBlock 	logExceptionBlock := aLogExceptionBlock.</body><body package="COUtilities">logLevel: anInteger channel: channel do: aBlock 	" perform the block if it matches the log level "	| level |	level := self logLevelForChannel: channel.	^ anInteger &gt;= level 		ifTrue: [ aBlock value ]		ifFalse: [ nil ]</body><body package="COUtilities">logLevel: anInteger channel: aSymbol show: aStringOrBlock	" show the block result if it matches the log level, and trigger notifiers "	| s |	s := self logLevel: anInteger channel: aSymbol showWithoutNotify: aStringOrBlock.	s notNil		ifTrue: [ self notifiersLevel: anInteger do: [ : notifier | notifier notify: s level: anInteger for: self ]].</body><body package="COUtilities">logLevel: anInteger channel: aSymbol showWithoutNotify: aStringOrBlock	" show the block result if it matches the log level "	^ self logLevel: anInteger channel: aSymbol do: [		| message str |		message := aStringOrBlock value.		str := (String new: 64) writeStream.		self writePrefixForLevel: anInteger channel: aSymbol on: str.		self basicShow: str contents.		self basicShow: message.		self basicCr.		message	 ]</body><body package="COUtilities">logLevel: anInteger do: aBlock 	" perform the block if it matches the log level "	^self logLevel: anInteger channel: #default do: aBlock</body><body package="COUtilities">logLevel: anInteger show: aStringOrBlock 	" show the block result if it matches the log level, and trigger notifiers "	| s |	s := self logLevel: anInteger channel: #default showWithoutNotify: aStringOrBlock.	s notNil		ifTrue: [ self notifiersLevel: anInteger do: [ : notifier | notifier notify: s level: anInteger for: self ]].</body><body package="COUtilities">maxLogSize	^ maxLogSize</body><body package="COUtilities">maxLogSize: aMaxLogSize 	| dummy |	dummy := aMaxLogSize &lt; 1024 			ifTrue: [ aMaxLogSize * 1024 * 1024 ]			ifFalse: [ aMaxLogSize ].	maxLogSize := dummy.</body><body package="COUtilities">minTime	^ minTime</body><body package="COUtilities">minTime: time 	minTime := time</body><body package="COUtilities">name	^ name</body><body package="COUtilities">name: aSymbolOrString	name := aSymbolOrString asSymbol</body><body package="COUtilities">timestampFormat	^ timestampFormat</body><body package="COUtilities">timestampFormat: aTimestampFormat 	timestampFormat := aTimestampFormat.</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>private</category><body package="COUtilities">addPrefix: aPrefix	prefixes := self prefixes copyWith: aPrefix</body><body package="COUtilities">additionalActionsForNotifiers	notifiers isNil ifTrue: [ ^ self ].	notifiers do: [ : n | n additionalActionFor: self ]</body><body package="COUtilities">basicCr	self basicShowString: self crString.</body><body package="COUtilities">basicShow: aStringOrObject 	| stringToShow |	stringToShow := (aStringOrObject isCharacters and: [ aStringOrObject isSymbol not ])			ifTrue: [ aStringOrObject asString ]			ifFalse: [ aStringOrObject printString ].	stringToShow isByteIndexed ifFalse: 		[	stringToShow := stringToShow collect: 					[: char |						char asInteger &gt; 255 							ifTrue: [ $~ ]							ifFalse: [ char ]					]		].	self basicShowString: stringToShow.</body><body package="COUtilities">basicShowString: aString	self ensureLogProcess.	logQueue nextPut: #processLogEntryString; nextPut: aString</body><body package="COUtilities">consoleShow: aString 	self enableConsoleWhile: [ self show: aString ].</body><body package="COUtilities">crString	^ ''</body><body package="COUtilities">disableLogfile	self transcriptFilename: nil.	TextCollector newTranscript: CoastNullTextCollector new.</body><body package="COUtilities">handleLogErrorsWhile: aBlock	^ aBlock on: Error do: [ : ex |			].</body><body package="COUtilities">initializePrefixBlocks	prefixBlocks := Dictionary new.	prefixBlocks 		at: #timestamp put: [ self logPrefixTimestamp ];		at: #date put: [ Timestamp now asDate shortPrintString, ':' ];		at: #time put: [ Timestamp now asTime shortPrintString, ':' ];		at: #proc put: [ '[proc=', Processor activeProcess hash printString, ']' ];		at: #clientID put: [ '[ID=', (ClientID notNil ifTrue: [ ClientID printString ] ifFalse: [ '-' ]), ']' ];		at: #free put: [ '[free=', (ObjectMemory current availableFreeBytes // (1024*1024)) printString, 'M]' ];		at: #alloc put: [ '[alloc=', (ObjectMemory current dynamicallyAllocatedFootprint // (1024*1024)) printString, 'M]' ];		at: #incGC put: [ '[incGC=', ((ObjectMemory current numIncGCs printString, ' ') copyWith: ObjectMemory current incGCState), ']' ].	^ prefixBlocks</body><body package="COUtilities">levelAsString: anInteger	" a string representing the log level "	^ self class levelAsString: anInteger</body><body package="COUtilities">levelFromString: aString	" parse the string representing the log level (either an integer or a name) "	^ self class levelFromString: aString</body><body package="COUtilities">logPrefixTimestamp	| stream timestamp tokens |	stream := String new writeStream.	timestamp := Timestamp now.	self timestampFormat isNil		ifTrue:	[	"Standardverhalten bzw. wie bisher"					timestamp coastShortPrintStringOn: stream.				]		ifFalse:	[	"Format-Anweisung zur Zeitausgabe verwenden"					[	tokens := TimestampPrintPolicy formatTokensFor: self timestampFormat.						Locale current timePolicy print: timestamp on: stream using: tokens.					] on: Error do: [ : ex |						timestamp coastShortPrintStringOn: stream.						].				].	stream nextPut: $:.	^ stream contents</body><body package="COUtilities">notifiersLevel: anInteger do: aBlock	notifiers isNil ifTrue: [ ^ self ].	notifiers do: [ : n | anInteger &gt;= n logLevel ifTrue: [ aBlock value: n ]]</body><body package="COUtilities">prefixBlocks	^ prefixBlocks ifNil: [ self initializePrefixBlocks ]</body><body package="COUtilities">prefixes	^ prefixes ifNil: [ prefixes := OrderedCollection with: #timestamp ].</body><body package="COUtilities">prefixes: anOrderedCollection	prefixes := anOrderedCollection</body><body package="COUtilities">showLogLoop	[	self handleLogErrorsWhile: [ self processNextLogEntry ].		self class singletonOrNil == self	] whileTrue.</body><body package="COUtilities">writePrefixForLevel: level channel: channel on: aStream 	| levelString infoDict |	infoDict := self infoDict.	self prefixes do: 		[: prefix | | prefixString |			prefix isSymbol 				ifTrue: 				[	prefixString := self prefixBlocks at: prefix ifAbsent: [ nil ].					prefixString isNil 						ifTrue: 						[	prefixString := infoDict at: prefix asString ifAbsent: [ nil ].							prefixString := prefixString notNil 									ifTrue: [ '[' , prefix , '=' , prefixString , ']' ]									ifFalse: [ nil ]						].					prefixString := prefixString value displayString trimBlanks				]				ifFalse: [ prefixString := '[' , prefix value displayString trimBlanks, ']' ].			( prefixString notNil and: [ prefixString notEmpty ]) 				ifTrue: 				[	aStream nextPutAll: prefixString.					aStream space				]		].	( self ~~ self class singleton and: [ self name notNil ]) 		ifTrue: 		[	aStream nextPutAll: self name asString.			aStream space		].	( channel notNil and: [ channel ~~ #default ]) 		ifTrue: 		[	aStream nextPut: $[.			aStream nextPutAll: channel asString.			aStream nextPut: $].			aStream space		].	levelString := self levelAsString: level.	levelString notEmpty 		ifTrue: 		[	aStream nextPut: $[.			aStream nextPutAll: levelString.			aStream nextPut: $].			aStream space		].</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>special</category><body package="COUtilities">generateLogStartInfo	CoastApplicationConfiguration current ifNotNil: [: conf | conf logInfo ]</body><body package="COUtilities">specialDebugLog: aStringOrBlock	| str |	str := 'specialDebug.log' asFilename appendStream text.	[		str nextPutAll: aStringOrBlock value displayString;cr.	] ensure: [ str close ].</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>accessing - channels</category><body package="COUtilities">channelLogLevels	" log level can be set for channels individually "	channelLogLevels isNil 		ifTrue: [ channelLogLevels := Dictionary new ].	^ channelLogLevels</body><body package="COUtilities">channels	^ channels ifNil: [ #() ]</body><body package="COUtilities">channels: aSetOfChannelNames	channels := aSetOfChannelNames</body><body package="COUtilities">clearChannels	channels := Set new</body><body package="COUtilities">disableChannel: aSymbol	channels remove: aSymbol ifAbsent: []</body><body package="COUtilities">enableChannel: aSymbol	channels add: aSymbol</body><body package="COUtilities">filterChannels	^ filterChannels ifNil: [ false ]</body><body package="COUtilities">filterChannels: aBoolean	filterChannels := aBoolean</body><body package="COUtilities">logLevelForChannel: channel 	" returns the minimal logged level for the channel "	^ channel notNil 		ifTrue: 		[	self channelLogLevels 				at: channel				ifAbsent: 				[( self filterChannels not or: [ channel = #default or: [ self channels includes: channel ]]) 						ifTrue: [ self logLevel ]						ifFalse: [ LogLevelWarning ]				]		]		ifFalse: [ self logLevel ]</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>setup - ini</category><body package="COUtilities">iniBlocks	| d |	d := Dictionary new.	d		at: 'logfile' put: [: s : ini | self transcriptFilename: s ];		at: 'nolog'			put: 			[: s : ini |				s asLowercase = 'true' 					ifTrue: [ self disableLogfile ]			];		at: 'notifiers' put: [: s : ini | self initializeNotifers: s fromIni: ini ];		at: 'loglevel' put: [: s : ini | self parseLogLevelFrom: s ];		at: 'logprefix' put: [: s : ini | self parseLogPrefixFrom: s ];		at: 'logTimestampFormat' put: [: s : ini | self timestampFormat: s ];		at: 'console' put: [: s : ini | self enableConsole: s asLowercase = 'true' ];		at: 'debug' put: [: s : ini | self isDebug: s asLowercase = 'true' ];		at: 'exceptionLogSize' put: [: s : ini | self exceptionLogSize: s asInteger ];		at: 'minTime' put: [: s : ini | self minTime: s asInteger ];		at: 'maxLogSize' put: [: s : ini | self maxLogSize: s asInteger ];		at: 'channels' put: [: s : ini | self parseChannelsFrom: s ];		at: 'channelLevels' put: [: s : ini | self parseChannelLogLevelsFrom: s ].	^ d</body><body package="COUtilities">initializeFromIni: iniAccess	self iniBlocks keysAndValuesDo: [ : key : keyBlock |		| s |		s := iniAccess category: nil stringAt: key.		s notNil			ifTrue: [ keyBlock value: s value: iniAccess ]	].	CoastLogReconfig singleton initializeFromIni: iniAccess.</body><body package="COUtilities">initializeNotifers: s fromIni: iniAccess	| notifierNames |	notifiers := nil.	notifierNames := (s tokensBasedOn: $,) collect: [ : nm | nm trimBlanks ].	notifierNames do: [ : nm | | notifier |		notifier := CoastLogNotifier named: nm fromIni: iniAccess.		notifier notNil			ifTrue: [ 				self addNotifier: notifier			].	].</body><body package="COUtilities">parseChannelLogLevelsFrom: aString	" &lt;channel&gt;:&lt;level&gt;,&lt;channel&gt;:&lt;level&gt;,...  "	| cleanString i channel levelString level |	 channelLogLevels := Dictionary new.	(aString tokensBasedOn: $,) do: [ : pairString |		cleanString := pairString trimBlanks.		i := cleanString lastIndexOf: $: ifAbsent: [ ^ nil ].		channel := cleanString copyFrom: 1 to: i - 1.		levelString := cleanString copyFrom: i + 1 to: cleanString size.		level := self levelFromString: levelString.		channelLogLevels at: channel asSymbol put: level.	].</body><body package="COUtilities">parseChannelsFrom: aString	channels := (aString tokensBasedOn: $,) collect: [ : p | | s |		filterChannels := true.		s := p trimBlanks.		s asSymbol	].</body><body package="COUtilities">parseLogLevelFrom: aString 	self logLevel: (self levelFromString: aString)</body><body package="COUtilities">parseLogPrefixFrom: aString	prefixes := (aString tokensBasedOn: $,) collect: [ : p | | s |		s := p trimBlanks.		('$*$' match: s)			ifTrue: [	s := s copyFrom: 2 to: s size - 1 ].		s asSymbol	].</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>printing</category><body package="COUtilities">addDumpInfoTo: stream	stream nextPutAll: 'CoastLog'; cr.	self variablesAndValuesOn: stream indent: 1.</body><body package="COUtilities">infoStringOn: stream indent: indent 	indent timesRepeat: [ stream tab ].	stream nextPutAll: 'coastlog:'; cr.	self variablesAndValuesOn: stream indent: indent + 1.</body><body package="COUtilities">printCollection: collection variableName: variableName on: stream indent: indent 	indent timesRepeat: [ stream tab. ].	stream nextPutAll: variableName; nextPutAll: ': '.	collection do: [ : element |		element printOn: stream		"stream nextPutAll: element."		] separatedBy: [ stream nextPutAll: ', ' ].	stream cr.</body><body package="COUtilities">variablesAndValuesOn: stream indent: indent 	self logLevel ifNotNil: [ : level |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'logLevel: '.		level printOn: stream.		stream cr		].	self channelLogLevels notEmpty		ifTrue: [			indent timesRepeat: [ stream tab ].			stream nextPutAll: 'channel levels: '; cr.			self channelLogLevels keysAndValuesDo: [ : channel : level |				(indent + 1) timesRepeat: [ stream tab ].				stream nextPutAll: channel; nextPutAll: ': '; print: level;cr.			].		].	notifiers ifNotNil: [ : notis |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'notifiers: '; cr.		notis do: [ : noti |			noti infoStringOn: stream indent: indent + 1.			].		].	self name ifNotNil: [ : n |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'name: '; nextPutAll: n printString; cr		].	self prefixes ifNotNil: [ : collection |		self printCollection: collection variableName: 'prefixes' on: stream indent: indent.		].	self transcript ifNotNil: [ : t |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'transcript: '.		t printOn: stream.		stream cr		].	multiTranscript ifNotNil: [ : t |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'multiTranscript: '.		t printOn: stream.		stream cr		].	self exceptionLogSize ifNotNil: [ : size |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'exceptionLogSize:'.		size printOn: stream.		stream cr		].	channels ifNotNil: [ : collection |		self printCollection: collection variableName: 'channels' on: stream indent: indent.		].	self filterChannels ifNotNil: [ : boolean |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'filterChannels: '.		boolean printOn: stream.		stream cr		].	fileName ifNotNil: [ : t |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'fileName: '; nextPutAll: fileName; cr		].	self minTime ifNotNil: [ : time |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'minTime:'.		time printOn: stream.		stream cr		].	self maxLogSize ifNotNil: [ : size |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'maxLogSize: '.		size printOn: stream.		stream cr		].	self enableConsole ifNotNil: [ : boolean |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'enableConsole: '.		boolean printOn: stream.		stream cr		].</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>initialize-release</category><body package="COUtilities">initialize		self initializeDefaults.	haltOnExceptions := Notifier isDevelopment</body><body package="COUtilities">initializeDefaults		self logLevel: LogLevelNormal.	channels := Set new.	filterChannels :=  false.</body><body package="COUtilities">release	self flush.	logProcess notNil ifTrue: [ logProcess terminate ].	self releaseFileTranscripts</body><body package="COUtilities">releaseFileTranscripts	" remove old file logs "	self transcript dependents copy do: 		[: transcript | ( transcript isKindOf: SeparableFileTranscript ) 				ifTrue: 				[	transcript release.					self transcript removeDependent: transcript				]		].</body></methods><methods><class-id>COAST.CoastLog</class-id> <category>log process</category><body package="COUtilities">ensureLogProcess	logQueue isNil 		ifTrue: [ logQueue := SharedQueue new ].	( logProcess isNil or: [ logProcess isTerminated ]) 		ifTrue: 		[	logProcess :=				[ self showLogLoop ] forkAt: Processor userInterruptPriority.			logProcess name: 'COAST Log writer process'		].</body><body package="COUtilities">processLogEntryFlush	self transcript flush.</body><body package="COUtilities">processLogEntrySemaphore	| semaphore |	semaphore := logQueue next.	semaphore signal.</body><body package="COUtilities">processLogEntryString	| string |	string := logQueue next.	string = self crString 		ifTrue: [ self transcript cr ]		ifFalse: [ self transcript show: string ].</body><body package="COUtilities">processNextLogEntry	| selector |	selector := logQueue next.	self perform: selector.</body></methods><methods><class-id>COAST.CoastLog class</class-id> <category>accessing - comfy</category><body package="COUtilities">consoleShow: aBlock 	^ self singleton consoleShow: aBlock</body><body package="COUtilities">cr	^ self singleton cr</body><body package="COUtilities">debugDo: aBlock 	self singleton debugDo: aBlock.</body><body package="COUtilities">enableConsoleWhile: aBlock		^ aBlock value</body><body package="COUtilities">flush	singleton notNil 		ifTrue: [ singleton flush ].</body><body package="COUtilities">flushAndWait	singleton notNil 		ifTrue: [ singleton flushAndWait ].</body><body package="COUtilities">isDebug	^ self singleton isDebug</body><body package="COUtilities">isDebug: isDebug	self singleton isDebug: isDebug</body><body package="COUtilities">log: aString	^ self singleton log: aString</body><body package="COUtilities">log: aStringOrBlock channel: aSymbol	^self singleton log: aStringOrBlock channel: aSymbol</body><body package="COUtilities">logDebug: aStringOrBlock	^ self singleton logDebug: aStringOrBlock</body><body package="COUtilities">logDebug: aBlock channel: aSymbol	^self singleton logDebug: aBlock channel: aSymbol</body><body package="COUtilities">logDebug: aBlock channel: aSymbol minTime: minTime 	^ self singleton logDebug: aBlock channel: aSymbol minTime: minTime</body><body package="COUtilities">logDebug: aBlock minTime: minTime 	^ self singleton logDebug: aBlock minTime: minTime</body><body package="COUtilities">logDebugCoast: aStringOrBlock 	self singleton logLevel: LogLevelDebugCoast show: aStringOrBlock</body><body package="COUtilities">logDebugCr	" for compatibility.... logDebug adds a CR to the log "	^ self singleton logDebugCr</body><body package="COUtilities">logDebugDo: aBlock 	^self singleton logDebugDo: aBlock</body><body package="COUtilities">logDebugNotify: aStringOrBlock	^ self singleton logDebugNotify: aStringOrBlock</body><body package="COUtilities">logDebugNotify: aBlock channel: aSymbol	^self singleton logDebugNotify: aBlock channel: aSymbol</body><body package="COUtilities">logDeveloper: aStringOrBlock	^ self singleton logDeveloper: aStringOrBlock</body><body package="COUtilities">logError: aString	^ self singleton logError: aString</body><body package="COUtilities">logError: aString channel: aSymbol	^ self singleton logError: aString channel: aSymbol</body><body package="COUtilities">logException: exception message: message	^ self singleton logException: exception message: message</body><body package="COUtilities">logExceptionAsWarning: exception message: message	^ self singleton logExceptionShort: exception logLevel: LogLevelWarning message: message</body><body package="COUtilities">logExceptionShort: exception message: message	^ self singleton logExceptionShort: exception message: message</body><body package="COUtilities">logFatalError: aStringOrBlock	^ self singleton logFatalError: aStringOrBlock</body><body package="COUtilities">logFatalError: aStringOrBlock channel: aSymbol	^ self singleton logFatalError: aStringOrBlock channel: aSymbol</body><body package="COUtilities">logFatalException: exception message: message 	^ self singleton logFatalException: exception message: message</body><body package="COUtilities">logMemory: aString	^ self singleton logMemory: aString</body><body package="COUtilities">logMemory: aString level: level 	^ self singleton logMemory: aString level: level</body><body package="COUtilities">logTime: aBlock	^ self singleton logTime: aBlock</body><body package="COUtilities">logTime: aBlock channel: channel 	^ self singleton logTime: aBlock channel: channel</body><body package="COUtilities">logTime: aBlock message: aString	^ self singleton logTime: aBlock message: aString</body><body package="COUtilities">logWarning: aString	^ self singleton logWarning: aString</body><body package="COUtilities">logWarning: aString channel: aSymbol	^ self singleton logWarning: aString channel: aSymbol</body><body package="COUtilities">minTime	^ self singleton minTime</body><body package="COUtilities">minTime: minTime 	^ self singleton minTime: minTime</body><body package="COUtilities">show: aStringOrObject	^ self singleton show: aStringOrObject</body></methods><methods><class-id>COAST.CoastLog class</class-id> <category>instance creation</category><body package="COUtilities">createNamed: aSymbolOrString	| log |	log := self new.	log name: aSymbolOrString asSymbol.	self logs at: log name put: log.	^ log</body><body package="COUtilities">ensureNamed: aSymbolOrString	^ self logs at: aSymbolOrString asSymbol ifAbsent: [ self createNamed: aSymbolOrString ]</body><body package="COUtilities">named: aSymbolOrString	^ self logs at: aSymbolOrString asSymbol ifAbsent: [ self singleton ]</body><body package="COUtilities">new	^ super new initialize</body><body package="COUtilities">reset	singleton notNil ifTrue: [ singleton release ].	singleton := nil.	logs := nil.</body><body package="COUtilities">singleton	| log |	singleton isNil		ifTrue: [ 				log := self createNamed: #default.			self singleton: log		].	^ singleton</body><body package="COUtilities">singleton: aCoastLogWriter 	singleton notNil ifTrue: [ singleton release ].	singleton := aCoastLogWriter.</body></methods><methods><class-id>COAST.CoastLog class</class-id> <category>accessing</category><body package="COUtilities">haltOnExceptionLog	^ self singleton haltOnExceptionLog</body><body package="COUtilities">haltOnExceptionLog: aBoolean 	self singleton haltOnExceptionLog: aBoolean</body><body package="COUtilities">haltOnExceptions	^ self singleton haltOnExceptions</body><body package="COUtilities">haltOnExceptions: aBoolean 	self singleton haltOnExceptions: aBoolean</body><body package="COUtilities">log: message forMillisecondsToRun: timedBlock 	^self logLevel: LogLevelNormal forMillisecondsToRun: timedBlock show: message</body><body package="COUtilities">log: message forMillisecondsToRun: timedBlock channel: aSymbol	"CoastLog log: 'lost &lt;1s&gt; ms while doing something' forMillisecondsToRun: [ something doIt ] channel: channelSymbol."	| ms result |	ms := Time millisecondsToRun: [ result := timedBlock value ].	self log: [ message expandMacrosWith: ms displayString ] channel: aSymbol.	^ result</body><body package="COUtilities">logLevel: anInteger channel: channel do: aBlock 	^ self singleton logLevel: anInteger channel: channel do: aBlock</body><body package="COUtilities">logLevel: anInteger do: aBlock 	^ self singleton logLevel: anInteger do: aBlock</body><body package="COUtilities">logLevel: logLevel forMillisecondsToRun: timedBlock show: message	"CoastLog log: 'lost &lt;1s&gt; ms while doing something' forMillisecondsToRun: [ something doIt ]."	| ms result |	ms := Time millisecondsToRun: [ result := timedBlock value ].	self logLevel: logLevel show: ( message expandMacrosWith: ms displayString ).	^ result</body><body package="COUtilities">logLevel: logLevel forMillisecondsToRun: timedBlock show: message channel: channel	"CoastLog log: 'lost &lt;1s&gt; ms while doing something' forMillisecondsToRun: [ something doIt ]."	| ms result |	ms := Time millisecondsToRun: [ result := timedBlock value ].	self singleton logLevel: logLevel channel: channel show: ( message expandMacrosWith: ms displayString ).	^ result</body><body package="COUtilities">logLevel: anInteger show: aStringOrBlock 	^ self singleton logLevel: anInteger show: aStringOrBlock</body><body package="COUtilities">loggedClientID: anIntegerOrNil	ClientID := anIntegerOrNil</body><body package="COUtilities">logs	logs isNil		ifTrue: [ 	logs := Dictionary new ].	^ logs</body><body package="COUtilities">noHaltOnExceptionLogDo: block 	^ self haltOnExceptionLog 		ifTrue: 		[	self haltOnExceptionLog: false.			block ensure: [ self haltOnExceptionLog: true ]		]		ifFalse: [ block value ]</body></methods><methods><class-id>COAST.CoastLog class</class-id> <category>private</category><body package="COUtilities">levelAsString: anInteger 	" a string representing the log level "	anInteger &gt;= LogLevelFatalError 		ifTrue: [ ^ self logLevelFatalErrorString ].	anInteger &gt;= LogLevelError 		ifTrue: [ ^ self logLevelErrorString ].	anInteger &gt;= LogLevelWarning 		ifTrue: [ ^ self logLevelWarningString ].	anInteger &gt;= LogLevelNormal 		ifTrue: [ ^ '' ].	^ self logLevelDebugString</body><body package="COUtilities">levelFromString: aString 	" parse the string representing the log level (either an integer or a name) "	| cleanString |	cleanString := aString trimBlanks.	( cleanString  allSatisfy: [: char | char isDigit ]) 		ifTrue: [ ^ cleanString  asInteger ].	cleanString := cleanString  asUppercase.	cleanString  = self logLevelFatalErrorString 		ifTrue: [ ^ LogLevelFatalError ].	cleanString  = self logLevelErrorString 		ifTrue: [ ^ LogLevelError ].	cleanString  = self logLevelWarningString 		ifTrue: [ ^ LogLevelWarning ].	cleanString  = self logLevelNormalString 		ifTrue: [ ^ LogLevelNormal ].	cleanString  = self logLevelDebugNotifyString 		ifTrue: [ ^ LogLevelDebugNotify ].	cleanString  = self logLevelDebugString 		ifTrue: [ ^ LogLevelDebug ].	" default "	^ LogLevelNormal</body><body package="COUtilities">logLevelDebugNotifyString	^ 'NOTIFY'</body><body package="COUtilities">logLevelDebugString	^ 'DEBUG'</body><body package="COUtilities">logLevelErrorString	^ 'ERROR'</body><body package="COUtilities">logLevelFatalErrorString	^ 'FATAL ERROR'</body><body package="COUtilities">logLevelNormalString	^ 'NORMAL'</body><body package="COUtilities">logLevelWarningString	^ 'WARNING'</body><body package="COUtilities">singletonOrNil	^ singleton</body></methods><methods><class-id>COAST.CoastLog class</class-id> <category>accessing - channels</category><body package="COUtilities">searchFilterChannelsCountDictionary	"self searchFilterChannelsCountDictionary"	| resultDictionary |	resultDictionary := Dictionary new.	self searchFilterChannelsWithFindBlock:	[ : symbol : sourceString	 |		resultDictionary at: symbol put: (resultDictionary at: symbol ifAbsent: [ 0 ]) + 1.		].	^ resultDictionary</body><body package="COUtilities">searchFilterChannelsCountString	| stream |	stream := String new writeStream.	stream nextPutAll: 'All available channels'; cr.	CoastLog searchFilterChannelsCountDictionary keys do: [ : symbol |		symbol printOn: stream.		stream cr.		].	^stream contents</body><body package="COUtilities">searchFilterChannelsSourceDictionary	"self searchFilterChannelsSourceDictionary"	| resultDictionary |	resultDictionary := Dictionary new.	self searchFilterChannelsWithFindBlock:	[ : symbol : sourceString	 |		(resultDictionary at: symbol ifAbsentPut: [ OrderedCollection new ]) add: sourceString.		].	^ resultDictionary</body></methods><methods><class-id>COAST.CoastLog class</class-id> <category>private - channels</category><body package="COUtilities">searchFilterChannelsWithFindBlock: findBlock	| methodSymbols wordSeperators |	methodSymbols := #( #log:channel: #logDebug:channel: #logDebug:channel:minTime: #logDebugNotify:channel: #logLevel:channel:do: #logTime:channel: #log:forMillisecondsToRun:channel:).	wordSeperators := ' ,.:[]()', (String with: Character cr), (String with: Character lf).	(self sourceCodesFor: methodSymbols) do: [ : sourceString | | stream |		stream := ((sourceString asStringsSeperatedBy: wordSeperators) collect: [ : string | string trimWhitespaces ]) readStream.		[ stream atEnd ] whileFalse: [ | next |			next := stream next.			(next = 'channel' and: [ stream atEnd not ]) ifTrue: [				next := stream next.				(next notNil and: [ next notEmpty and: [ next first = $# ] ]) ifTrue: [					next := next copyFrom: 2 to: next size.					findBlock value: next asSymbol value: sourceString.					].				].			].		].</body><body package="COUtilities">sourceCodesFor: methodSymbols	| sourceCodes ignore |	sourceCodes := Set new: 32.	ignore := #( #searchFilterChannelsCountDictionary #searchFilterChannelsWithFindBlock: #sourceCodesFor: ).	SystemUtils allBehaviorsDo: [ : behavior |		self sourceCodesFor: methodSymbols behavior: behavior ignore: ignore sourceCodes: sourceCodes.		self sourceCodesFor: methodSymbols behavior: behavior class ignore: ignore sourceCodes: sourceCodes.		].	^ sourceCodes</body><body package="COUtilities">sourceCodesFor: methodSymbols behavior: behavior ignore: ignore sourceCodes: sourceCodes	behavior selectorsAndMethodsDo: [ : selector : method |		(ignore includes: selector) ifFalse: [			methodSymbols do: [ : methodSymbol |				(method refersToLiteral: methodSymbol) ifTrue: [					sourceCodes add: (behavior sourceCodeAt: selector) asString.					].				].			].		].</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>requests-blob</category><body package="COClusterManagement">blobExists: blobID	self subclassResponsibility</body><body package="COClusterManagement">bytesFor: clusterIDInteger 	self subclassResponsibility</body><body package="COClusterManagement">importBlob: blobIDInteger fromBytes: byteArray 	| stream |	stream := self writeStreamOnBlob: blobIDInteger size: byteArray size.	[ stream nextPutAll: byteArray ]		ensure: [ stream close ]</body><body package="COClusterManagement">importBlob: blobIDInteger fromFile: aFilename 	self subclassResponsibility</body><body package="COClusterManagement">importCluster: clusterID fromBytes: byteArray 	| stream |	stream := self writeStreamOnCluster: clusterID.	[ stream nextPutAll: byteArray ] ensure: [ stream close ].</body><body package="COClusterManagement">readStreamOnBlob: blobID 	self subclassResponsibility</body><body package="COClusterManagement">realSizeForBlobNr: cNr 	self subclassResponsibility</body><body package="COClusterManagement">writeStreamOnBlob: blobIDInteger size: anInteger 	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>requests</category><body package="COClusterManagement">addToApplicationLog: aCatCSApplicationLog	[ self applicationLoggers do: [: anApplicationLogger | anApplicationLogger addToApplicationLog: aCatCSApplicationLog ]] on: Error		do: [: ex | CoastLog logException: ex message: 'Could not add application log' ].</body><body package="COClusterManagement">backupVolume	" Initiate a backup of the volume. returns a CMStatusResponse "	self subclassResponsibility</body><body package="COClusterManagement">blobIDs	"retreive all available stored clusters, answer a set of cluster names"	self subclassResponsibility</body><body package="COClusterManagement">blockUntilBackupIsDone	" wait until the last asynchronous backup has finished "	self subclassResponsibility.</body><body package="COClusterManagement">clusterAndBlobIDs	"retreive all available stored clusters, answer a set of cluster names"	self subclassResponsibility</body><body package="COClusterManagement">clusterExists: clusterIDInteger	self subclassResponsibility</body><body package="COClusterManagement">clusterIDs	self subclassResponsibility</body><body package="COClusterManagement">compress	^ 'Error: Operation not supported'</body><body package="COClusterManagement">copyVolumeTo: newVolume 	self subclassResponsibility</body><body package="COClusterManagement">deleteCluster: clusterIDInteger 	" delete the cluster. return true if successful "	^ self deleteCluster: clusterIDInteger ifAbsent: [ true ]</body><body package="COClusterManagement">deleteCluster: clusterIDInteger ifAbsent: block 	" delete the cluster. return true if successful "	self subclassResponsibility</body><body package="COClusterManagement">deleteVolume	self subclassResponsibility</body><body package="COClusterManagement">deleteVolumeNoBackup	self subclassResponsibility</body><body package="COClusterManagement">exclusiveInitiateCopyVolumeForDownload	" start to copy the volume to a temporary volume and return a storage accessor on it.	the return value may be anything, it is passed to #finishCopyVolumeForDownloadWith:		This method is performed in an exclusiveUseDo: block "	^ self subclassResponsibility</body><body package="COClusterManagement">highestID	^self subclassResponsibility</body><body package="COClusterManagement">modificationNumberFor: clusterIDInteger 	| newCluster num |	num := 0.	[			newCluster := self clusterHeaderFor: clusterIDInteger.		(newCluster notNil and: [ newCluster modificationNumber notNil ])			ifTrue: [ num := newCluster modificationNumber ].	] on: Error do: [: ex | 		num := 0.	].	^num</body><body package="COClusterManagement">nonExclusiveFinishCopyVolumeForDownloadWith: initiateCopyResult	" finish copy the volume to temporary volume and return a storage accessor on it.	the parameter  initiateCopyResult is the return value of #initiateCopyVolumeForDownload	This method is NOT performed in an exclusiveUseDo: block "	self subclassResponsibility</body><body package="COClusterManagement">prepareDeleteVolume</body><body package="COClusterManagement">readStreamOnCluster: clusterIDInteger 	self subclassResponsibility</body><body package="COClusterManagement">removeBackupsExcept: numberOfBackupsToKeep	self subclassResponsibility</body><body package="COClusterManagement">saveAllClustersFor: streamableClusters updatedIndexAccess: frameClassIndex 	" save all clusters. returns true if the save succeded, false otherwise "	self subclassResponsibility.</body><body package="COClusterManagement">storageSizeForCluster: clusterIDInteger 	self subclassResponsibility</body><body package="COClusterManagement">writeStreamOnBlob: blobID	self subclassResponsibility</body><body package="COClusterManagement">writeStreamOnCluster: clusterIDInteger	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>private</category><body package="COClusterManagement">allIDsDo: aBlock 	" perform aBlock with all cluster/blob IDs "	self clusterAndBlobIDs do: [ : id | aBlock value: id ]</body><body package="COClusterManagement">clusterHeaderFor: clusterIDInteger	^ self clusterHeaderFor: clusterIDInteger marshall: CatMAMarshallBinary new</body><body package="COClusterManagement">clusterHeaderFor: clusterIDInteger marshall: aMarshall	| readStream newCluster |	newCluster := nil.	readStream := self readStreamOnCluster: clusterIDInteger.	[		newCluster := CatCSCluster loadHeaderFromStream: readStream marshaller: aMarshall	] ensure: [ 		readStream close	].	^ newCluster</body><body package="COClusterManagement">createApplicationLoggers	^ nil</body><body package="COClusterManagement">enumerateWithProgress: aCollection description: description with: aBlock	| reportedProgress i total |	reportedProgress := 0.	i := 0.	total := aCollection size.	aCollection do: [ : each | | progress |		aBlock cull: each.		i := i + 1.		progress := (i * 100 / total) rounded.		progress - reportedProgress &gt;= 10			ifTrue: [				MessageNotification raiseSignal: description , ' ', i printString, '/', total printString, ' (', progress printString, '%)'.				reportedProgress := progress // 10 * 10.			]	].</body><body package="COClusterManagement">logError: exception	CoastLog logException: exception message: 'Error'.</body><body package="COClusterManagement">logMessage: message	CoastLog log:  message</body><body package="COClusterManagement">logSavedAllClusters: streamableClusters startedAt: startMilliseconds 	CoastLog log: 		[ | maxClusterSize maxCluster total delta |			delta := (( Time millisecondClockValue - startMilliseconds ) / 1000.0 ) printString.			maxClusterSize := 0.			maxCluster := -1.			total := 0.			streamableClusters do: 				[: cc | | sz |					sz := cc approxByteSize.					total := total + sz.					sz &gt; maxClusterSize ifTrue: 						[	maxClusterSize := sz.							maxCluster := cc clusterID						]				].			'saved ' , streamableClusters size printString , ' clusters [total size: ' , total coastShortByteSizePrintString , ', largest cluster ' 				, maxCluster printString , ' : ' 				, maxClusterSize coastShortByteSizePrintString , '] in ' 				, delta , ' sec into ' 				, self storageDescriptionString		].</body><body package="COClusterManagement">nextClusterIDKey	^ 'nextClusterID'</body><body package="COClusterManagement">updateIndexIniAccessWith: newIndexIniOrNil	newIndexIniOrNil notNil ifTrue:	[		self indexIniAccess: newIndexIniOrNil.	].</body><body package="COClusterManagement">volumeIDKey	^ 'volumeID'</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>accessing</category><body package="COClusterManagement">applicationLoggers	( applicationLoggers isNil or: [ applicationLoggers isEmpty ]) ifTrue: 		[	self createApplicationLoggers.			( applicationLoggers isNil or: [ applicationLoggers isEmpty ]) ifTrue: 				[	applicationLoggers := ( OrderedCollection new ) add: CatCSNullApplicationLogger new;							yourself				]		].	^ applicationLoggers</body><body package="COClusterManagement">applicationLoggers: aCollectionOrNil 	applicationLoggers := aCollectionOrNil.</body><body package="COClusterManagement">coastVersion	" COAST version of the mediator/local client that last wrote the volume "	self subclassResponsibility</body><body package="COClusterManagement">exists	self subclassResponsibility</body><body package="COClusterManagement">filenameForClusterID: clusterIDInteger	^ nil</body><body package="COClusterManagement">largestClusterDo: block maxCount: maxCount 	"ignore"</body><body package="COClusterManagement">nextClusterID	self subclassResponsibility</body><body package="COClusterManagement">nextClusterID: anInteger	self subclassResponsibility</body><body package="COClusterManagement">nextClusterIDToLoad	^ nil</body><body package="COClusterManagement">okToCleanup	^ true</body><body package="COClusterManagement">storageDescriptionString	^'cluster storage'</body><body package="COClusterManagement">supportsLazyUnmarshalling	^ false</body><body package="COClusterManagement">uniqueVolumeID	self subclassResponsibility</body><body package="COClusterManagement">uniqueVolumeID: aString	self subclassResponsibility</body><body package="COClusterManagement">uniqueVolumeIDNeeded	| id |	id := self uniqueVolumeID.	id isNil ifTrue: 	[	id := self class newVolumeID.		self uniqueVolumeID: id.	].	^id</body><body package="COClusterManagement">volume	^ volume</body><body package="COClusterManagement">volume: aVolume 	volume := aVolume.</body><body package="COClusterManagement">volumeAccessor	^ volumeAccessor</body><body package="COClusterManagement">volumeAccessor: volumeStorageAccessor	volumeAccessor := volumeStorageAccessor</body><body package="COClusterManagement">volumeLockInfoString	^ volumeLockInfoString ifNil: [ 'locked by unknown' ]</body><body package="COClusterManagement">volumeLockInfoString: aVolumeLockInfoString 	volumeLockInfoString := aVolumeLockInfoString.</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>ini</category><body package="COClusterManagement">indexIniAccess	self subclassResponsibility</body><body package="COClusterManagement">indexIniAccess: aCoastIniAccess	self subclassResponsibility</body><body package="COClusterManagement">volumeIniAccess	self subclassResponsibility</body><body package="COClusterManagement">volumeIniAccess: aCoastIniAccess	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>utility</category><body package="COClusterManagement">emergencyRemoveAllClusters	" delete all clusters. returns true if successfull "	self removeAllClusters</body><body package="COClusterManagement">removeAllClusters	" delete all clusters. returns true if successfull "	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>transfer</category><body package="COClusterManagement">receiveBlobsFrom: receiveStream 	self 		enumerateWithProgress: (1 to: receiveStream nextOptimized32)		description: 'Blob'		with: 		[ : i | | writeStream blobID blobSize |			writeStream := nil.			[	blobID := receiveStream nextOptimized32.				blobSize := receiveStream nextUnsigned32.				writeStream := self writeStreamOnBlob: blobID.				receiveStream coastTransfer: blobSize to: writeStream			] ensure: 				[	writeStream notNil 						ifTrue: [ writeStream close ]				]		].</body><body package="COClusterManagement">receiveClustersFrom: receiveStream	| maxClusterID |	maxClusterID := 0.	self enumerateWithProgress: (1 to: receiveStream nextOptimized32)		description: 'Cluster'		with: 		[ : i | | writeStream clusterID clusterSize bytes |			clusterID := receiveStream nextOptimized32.			clusterID &gt; maxClusterID ifTrue: [ maxClusterID := clusterID ].			clusterSize := receiveStream nextUnsigned32.			bytes := receiveStream next: clusterSize.			writeStream := self writeStreamOnCluster: clusterID.			[	writeStream nextPutAll: bytes.				writeStream close			] ensure: [ writeStream close ]		].</body><body package="COClusterManagement">receiveClustersFrom: receiveStream clusterManager: clusterManagerOrNil 	| maxClusterID upgradeNeeded |	clusterManagerOrNil ifNotNil: [: cm | cm loadIndex ].	upgradeNeeded := ( clusterManagerOrNil isNil or: [ self coastVersion isNil ]) 			ifTrue: [ false ]			ifFalse: [ self coastVersion &lt; CoastVersion defaultCoastVersion ].	maxClusterID := 0.	receiveStream nextOptimized32 timesRepeat: 		[ | writeStream clusterID clusterSize bytes |			clusterID := receiveStream nextOptimized32.			clusterID &gt; maxClusterID ifTrue: [ maxClusterID := clusterID ].			clusterSize := receiveStream nextUnsigned32.			bytes := receiveStream next: clusterSize.			upgradeNeeded ifTrue: [ bytes := clusterManagerOrNil patch: bytes ].			writeStream := self writeStreamOnCluster: clusterID.			[	writeStream nextPutAll: bytes.				writeStream close			] ensure: [ writeStream close ]		].</body><body package="COClusterManagement">receiveIniFrom: receiveStream 	| iniA |	iniA := self indexIniAccess.	iniA readFromBinary: receiveStream.	self indexIniAccess: iniA.	" flush nextClusterID, will be computed if needed "	self nextClusterID: nil.</body><body package="COClusterManagement">receiveVolumeFrom: receiveStream 	self receiveIniFrom: receiveStream.	self receiveClustersFrom: receiveStream.	self receiveBlobsFrom: receiveStream.</body><body package="COClusterManagement">receiveVolumeFrom: receiveStream clusterManager: clusterManagerOrNil 	self receiveIniFrom: receiveStream.	self receiveClustersFrom: receiveStream clusterManager: clusterManagerOrNil.	self receiveBlobsFrom: receiveStream.</body><body package="COClusterManagement">sendBlobsTo: sendStream 	| blobIDs |	blobIDs := self blobIDs.	sendStream nextOptimized32Put: blobIDs size.	self 		enumerateWithProgress: blobIDs		description: 'Blob'		with: 		[: aBlobID |			sendStream nextOptimized32Put: aBlobID.			self transferBlob: aBlobID to: sendStream		].</body><body package="COClusterManagement">sendClustersTo: sendStream 	| clusterIDs |	clusterIDs := self clusterIDs.	sendStream nextOptimized32Put: clusterIDs size.	self 		enumerateWithProgress: clusterIDs		description: 'Cluster'		with: 		[: aClusterIDInteger | | size |			sendStream nextOptimized32Put: aClusterIDInteger.			size := self storageSizeForCluster: aClusterIDInteger.			sendStream nextUnsigned32Put: size.			self transferCluster: aClusterIDInteger to: sendStream		].</body><body package="COClusterManagement">sendIniTo: sendStream	| iniA |	iniA := self indexIniAccess.	iniA writeToBinary: sendStream.</body><body package="COClusterManagement">sendVolumeTo: sendStream 	self sendIniTo: sendStream.	self sendClustersTo: sendStream.	self sendBlobsTo: sendStream.	sendStream flush</body><body package="COClusterManagement">transferBlob: blobNr to: writeStream 	self transferBlob: blobNr to: writeStream bytesOnly: false</body><body package="COClusterManagement">transferBlob: blobNr to: writeStream bytesOnly: bytesOnly 	| size |	bytesOnly 		ifFalse: 		[	size := self realSizeForBlobNr: blobNr.			writeStream nextUnsigned32Put: size		].	self transferBlobData: blobNr to: writeStream.</body><body package="COClusterManagement">transferBlobData: blobNr to: writeStream 	| size readStream byteCount |	size := self realSizeForBlobNr: blobNr.	readStream := self readStreamOnBlob: blobNr.	byteCount := 0.	[	1 to: size			do: 			[: i |				writeStream nextPut: readStream next.				byteCount := byteCount + 1			]	] valueNowOrOnUnwindDo: 		[( byteCount + 1 to: size ) do: [: i | writeStream nextPut: 0 ].			readStream close		]</body><body package="COClusterManagement">transferCluster: clusterIDInteger to: writeStream	| readStream |	readStream := self readStreamOnCluster: clusterIDInteger.	[		readStream do: [ :byte | writeStream nextPut: byte ].		"writeStream nextPutAll: readStream contents (faster with large clusters)"	] valueNowOrOnUnwindDo: [ 		"don't forget to close the readStream - not the writeStream"		readStream close.	].</body></methods><methods><class-id>COAST.CatCSStorageAccessor</class-id> <category>initialize - release</category><body package="COClusterManagement">prepareRelease	" the mediator/local client wants to shutdown "</body><body package="COClusterManagement">releaseVolumeAccess	" close open streams/connections etc. "	self subclassResponsibility</body><body package="COClusterManagement">shutDown	self releaseVolumeAccess.	self applicationLoggers notNil ifTrue: [ self applicationLoggers do: [: anApplicationLogger | anApplicationLogger shutDown ]].</body><body package="COClusterManagement">startUp	"compatibility"	self startUpStorageAccessorFrom: nil</body><body package="COClusterManagement">startUpApplicationLoggers	self applicationLoggers do: [: anApplicationLogger | anApplicationLogger startUp ].</body><body package="COClusterManagement">startUpStorageAccessorFrom: clusterManagerOrNil 	self startUpApplicationLoggers.	clusterManagerOrNil notNil ifTrue:	[		self volume: clusterManagerOrNil volume.		self volumeLockInfoString: clusterManagerOrNil volumeLockInfoString.	].</body></methods><methods><class-id>COAST.CatCSStorageAccessor class</class-id> <category>instance creation</category><body package="COClusterManagement">clusterManager: aCatCSClusterManager 	^(self new)		volume: aCatCSClusterManager volume;		volumeLockInfoString: aCatCSClusterManager volumeLockInfoString;		yourself</body></methods><methods><class-id>COAST.CatCSStorageAccessor class</class-id> <category>utility</category><body package="COClusterManagement">newVolumeID	| now bytes aString ip |	aString := ''.	bytes := OrderedCollection new.	now := Time millisecondClockValue.	ip := Object errorSignal handle: 			[: ex | | r |				r := Random new.				OrderedCollection new					add: 0;					add: ( r next * 255 ) truncated;					add: ( r next * 255 ) truncated;					add: ( r next * 255 ) truncated;					yourself			]			do: [( IPSocketAddress hostAddressByName: SocketAccessor defaultClass getHostname ) asOrderedCollection ].	ip do: [: aByte | bytes add: aByte ].	bytes add: (( now bitShift: -24 ) bitAnd: 255 ).	bytes add: (( now bitShift: -16 ) bitAnd: 255 ).	bytes add: (( now bitShift: -8 ) bitAnd: 255 ).	bytes add: ( now bitAnd: 255 ).	bytes reverseDo: 		[: aByte |			aString := aString 					, (( String with: ( aByte // 16 + $a asInteger ) asCharacter ) , ( String with: ( aByte \\ 16 + $a asInteger ) asCharacter ))		].	^ aString</body></methods><methods><class-id>COAST.CatCSAbstractDiskStorageAccessor</class-id> <category>private</category><body package="COClusterManagement">basicSaveClusters: streamableClusters 	streamableClusters do: 		[: cc | | writeStream |			writeStream := self writeStreamOnCluster: cc clusterID.			[ cc saveClusterOn: writeStream ] ensure: [ writeStream close ]		].</body><body package="COClusterManagement">copyVolumeToDirectory: aDirectory	self subclassResponsibility</body><body package="COClusterManagement">createApplicationLoggers	| loggers logIniFile |	logIniFile := self logIniFilename.	logIniFile isNil ifTrue: [ ^ nil ].	( self workingDirectory construct: logIniFile asString ) exists ifFalse: [ ^ nil ].	loggers := CatCSApplicationLogger createFromIniFile: logIniFile asFilename workingDirectory: self workingDirectory.	loggers isNil ifTrue: [ ^ nil ].	self applicationLoggers: loggers.</body><body package="COClusterManagement">moveVolumeToDirectory: destinationDirectory 	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSAbstractDiskStorageAccessor</class-id> <category>requests</category><body package="COClusterManagement">backupVolume	CoastLog log: 'Starting backup of ' , self volume printString.	self copyVolumeToDirectory: self directoryForBackup.	CoastLog log: 'Finished backup of ' , self volume printString.	^ CoastStatusResponse okCode: CoastStatusResponse codeBackupFinished message: 'Backup of volume ', self volume, ' finished'.</body><body package="COClusterManagement">blockUntilBackupIsDone	^ CoastStatusResponse failureCode: #noAsynchronousBackupsPossible message: 'No asynchronous backups supported'</body><body package="COClusterManagement">copyVolumeTo: newVolume 	| destination |	destination := volumeAccessor directoryForVolume: newVolume.	self copyVolumeToDirectory: destination</body><body package="COClusterManagement">deleteVolume	self moveVolumeToDirectory: self directoryForBackup.</body><body package="COClusterManagement">removeBackupsExcept: numberOfBackupsToKeep	self volumeAccessor removeBackups: self volume except: numberOfBackupsToKeep</body></methods><methods><class-id>COAST.CatCSAbstractDiskStorageAccessor</class-id> <category>ini</category><body package="COClusterManagement">configureWithIni: ini</body><body package="COClusterManagement">logIniFilename	" returns a (possibly read only) log-ini-filename, or nil if no such file exists "	^  self class logIniFileName</body></methods><methods><class-id>COAST.CatCSAbstractDiskStorageAccessor</class-id> <category>requests - blob</category><body package="COClusterManagement">writeStreamOnBlob: blobIDInteger size: anInteger 	^self writeStreamOnBlob: blobIDInteger</body></methods><methods><class-id>COAST.CatCSAbstractDiskStorageAccessor</class-id> <category>accessing</category><body package="COClusterManagement">optimizeInMemory</body><body package="COClusterManagement">supportsLazyUnmarshalling	^ true</body></methods><methods><class-id>COAST.CatCSAbstractDiskStorageAccessor</class-id> <category>directories</category><body package="COClusterManagement">backupBaseDirectory	"answer the directory containing all backups of the volume "	| bd |	bd := (self volumeAccessor backupDirectory 		construct: self volume) .	bd ensureFullDirectory.	^ bd</body><body package="COClusterManagement">directoryForBackup	"create a new directory for a backup "	| bd |	bd := self backupBaseDirectory construct: Timestamp now asSeconds printString.	bd ensureFullDirectory.	^ bd</body><body package="COClusterManagement">workingDirectory	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSAbstractDiskStorageAccessor</class-id> <category>utility</category><body package="COClusterManagement">removeAllClusters	" delete all clusters. returns true if successfull "	| success |	success := true.	1 to: self highestID do: [: id | ( self deleteCluster: id) ifFalse: [ success := false ]].	^ success</body></methods><methods><class-id>COAST.CatCSAbstractDiskStorageAccessor class</class-id> <category>ini</category><body package="COClusterManagement">logIniFileName	^ 'log.ini'</body></methods><methods><class-id>COAST.CatCSAbstractDiskStorageAccessor class</class-id> <category>accessing</category><body package="COClusterManagement">directory: aDirectory volume: volumeName	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>requests</category><body package="COClusterManagement">allIDsFor: extensions do: aBlock 	"retreive all available stored clusters, answer a set of cluster IDs"	| badExtensions |	badExtensions := extensions collect: [: ext | ext asUppercase ].	self workingDirectory subDirsAndFilesDo: 		[: subDir : fileRepresentingString | | index extension |			fileRepresentingString first isDigit ifTrue: 				[	index := fileRepresentingString indexOf: $. ifAbsent: nil.					index notNil ifTrue: [ extension := fileRepresentingString copyFrom: index to: fileRepresentingString size ].					( extensions includes: extension ) 						ifTrue: [ aBlock value: ( fileRepresentingString copyFrom: 1 to: index - 1 ) asInteger ].					( badExtensions includes: extension ) ifTrue: [ self unexpectedFile: fileRepresentingString ]				]		]</body><body package="COClusterManagement">blobIDs	"retreive all available stored clusters "	^self filesForExtensions: (Array with: self getBlobExtension)</body><body package="COClusterManagement">clusterAndBlobIDs	"retreive all available stored clusters, answer a set of cluster IDs"	^self filesForExtensions: (Array with: self getClusterExtension with: self getBlobExtension)</body><body package="COClusterManagement">clusterExists: clusterIDInteger	^ (self filenameForClusterID: clusterIDInteger) exists</body><body package="COClusterManagement">clusterIDs	"retreive all available stored clusters, answer a set of cluster IDs"	^self filesForExtensions: (Array with: self getClusterExtension)</body><body package="COClusterManagement">deleteCluster: clusterIDInteger ifAbsent: block 	| filename fileSize |	filename := self filenameForBlobOrClusterID: clusterIDInteger.	^ [	filename definitelyExists 			ifTrue: 			[	fileSize := filename fileSize.				filename delete.				true			]			ifFalse: [ block value ]	] on: Error		do: 		[: ex |			CoastLog logError: 'Unable to delete :"' , filename printString , '"!'.			false		]</body><body package="COClusterManagement">deleteVolumeNoBackup	[		self workingDirectory deleteRecursively	] on: Error do: [:ex | 		CoastLog logException: ex message: 'Error while deleting volume ', self workingDirectory asString.	]</body><body package="COClusterManagement">exclusiveInitiateCopyVolumeForDownload	| destDir sa |	destDir := volumeAccessor ensureDirectoryNamed: 'download' , Timestamp now asSeconds printString.	self copyVolumeToDirectory: destDir.	sa := self class workingDirectory: destDir.	sa volume: self volume.	^ sa</body><body package="COClusterManagement">highestID	| result extensions badExtensions filenames highestSubDir |	result := -1.	extensions := Array with: self getClusterExtension with: self getBlobExtension.	badExtensions := extensions collect: [: ext | ext asUppercase ].	(highestSubDir := self highestSubDir) isNil ifTrue: [ ^ result ].	filenames := highestSubDir directoryContents.	filenames do: 		[: fileRepresentingString | | index id extension |			fileRepresentingString first isDigit ifTrue: 				[	index := fileRepresentingString indexOf: $. ifAbsent: nil.					index notNil ifTrue: [ extension := fileRepresentingString copyFrom: index to: fileRepresentingString size ].					( extensions includes: extension ) ifTrue: 						[	id := ( fileRepresentingString copyFrom: 1 to: index - 1 ) asInteger.							id &gt; result ifTrue: [ result := id ]						].					( badExtensions includes: extension ) ifTrue: [ self unexpectedFile: fileRepresentingString ]				]		].	^ result</body><body package="COClusterManagement">nonExclusiveFinishCopyVolumeForDownloadWith: storageAccessor	^ storageAccessor</body><body package="COClusterManagement">readStreamOnCluster: clusterIDInteger 	| fName |	fName := self filenameForClusterID: clusterIDInteger.	^ fName exists 		ifTrue: [ fName readStream binary ]		ifFalse: [ nil ]</body><body package="COClusterManagement">storageSizeForCluster: clusterIDInteger 	| filename |	filename := self filenameForClusterID: clusterIDInteger.	^ self storageSizeForFile: filename</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>requests - blob</category><body package="COClusterManagement">blobExists: blobID 	| fName |	fName := self filenameForBlobFileID: blobID.	^fName exists</body><body package="COClusterManagement">bytesFor: clusterIDInteger 	| sourceFile |	sourceFile := self filenameForBlobFileID: clusterIDInteger .	^self class bytesFromFile: sourceFile</body><body package="COClusterManagement">filenameForBlobFileID: anInteger 	^anInteger isInteger		ifTrue: [ self workingDirectory constructForCluster: ( anInteger printString , self getBlobExtension ) number: anInteger mod: self filesPerSubDir ]		ifFalse: [ self filenameForBlobFileID: anInteger id ]</body><body package="COClusterManagement">filenameForBlobID: blobIDInteger 	^self filenameForBlobFileID: blobIDInteger</body><body package="COClusterManagement">importBlob: blobIDInteger  fromBytes: aByteArray 	| aStream targetFile |	targetFile := self filenameForBlobID: blobIDInteger.	aStream := targetFile writeStream.		[aStream binary.	aByteArray do: [:x | aStream nextPut: x]] 			valueNowOrOnUnwindDo: [aStream close]</body><body package="COClusterManagement">importBlob: blobIDInteger fromFile: aFilename 	| targetFile |	targetFile := self filenameForBlobID: blobIDInteger.	aFilename asFilename copyTo: targetFile</body><body package="COClusterManagement">importBlob: blobIDInteger fromStream: readStream 	| targetFile aStream |	targetFile := self filenameForBlobID: blobIDInteger.	aStream := targetFile writeStream.	aStream binary.	[ aStream nextUnsigned32 timesRepeat: [ aStream nextPut: readStream next ]] ensure: [ aStream close ].</body><body package="COClusterManagement">realSizeForBlobNr: aBlobID 	| filename |	filename := self filenameForBlobFileID: aBlobID.	^ self storageSizeForFile: filename</body><body package="COClusterManagement">writeStreamOnBlob: blobIDInteger	| fName |	" sanity check "	(self filenameForClusterID: blobIDInteger) exists		ifTrue: [ ^ self error: 'File ', blobIDInteger printString, ' is a cluster, expected a blob' ].	fName := self filenameForBlobID: blobIDInteger.	^fName writeStream binary</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>accessing</category><body package="COClusterManagement">coastVersion	" COAST version of the mediator/local client that last wrote the volume "	| ini major minor |	ini := self volumeIniAccess.	major := ini numberAt: self majorVersionKey ifAbsent: [ ^ nil ].	minor := ini numberAt: self minorVersionKey ifAbsent: [ ^ nil ].	^ CoastVersion major: major minor: minor</body><body package="COClusterManagement">exists	^ self workingDirectory exists and: [ self workingDirectory directoryContents isEmpty not ]</body><body package="COClusterManagement">filenameForClusterID: clusterIDInteger	^ lastID = clusterIDInteger 		ifTrue: [ lastFilename ]		ifFalse: [ 			lastFilename := self workingDirectory 				constructForCluster: (clusterIDInteger printString , self getClusterExtension)				number: clusterIDInteger				mod: self filesPerSubDir.			lastID := clusterIDInteger.			lastFilename		].</body><body package="COClusterManagement">nextClusterID	| iniAccess tempCid |	iniAccess := self volumeIniAccess.	tempCid := iniAccess numberAt: self nextClusterIDKey ifAbsent: [ nil ].	"sanity check"	^ (tempCid notNil and: [ (self clusterExists: tempCid) or: [ (self blobExists: tempCid) ]])		ifTrue: [ nil ]		ifFalse: [ tempCid ]</body><body package="COClusterManagement">nextClusterID: anInteger	| iniAccess |	iniAccess := self volumeIniAccess.	iniAccess at: self nextClusterIDKey put: anInteger.	iniAccess writeFile.</body><body package="COClusterManagement">uniqueVolumeID	"annswer the unique volume id"	"create id if not existent"	| iniAccess |	iniAccess := self volumeIniAccess.	^ iniAccess at: self volumeIDKey</body><body package="COClusterManagement">uniqueVolumeID: aString 	| iniAccess |	iniAccess := self volumeIniAccess.	iniAccess at: self volumeIDKey put: aString.	iniAccess writeFile</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>private</category><body package="COClusterManagement">allIDsDo: aBlock 	self allIDsFor: ( Array 				with: self getClusterExtension				with: self getBlobExtension )		do: aBlock</body><body package="COClusterManagement">copyVolumeToDirectory: destinationDirectory 	"cluster"	| newIniAccess |	self clusterIDs do: 		[: id | | sourceFile |			sourceFile := self filenameForClusterID: id.			sourceFile copyTo: ( destinationDirectory constructForCluster: sourceFile tail number: id mod: self filesPerSubDir )		].	"blobs"	self blobIDs do: 		[: id | | sourceFile |			sourceFile := self filenameForBlobID: id.			sourceFile copyTo: ( destinationDirectory constructForCluster: sourceFile tail number: id mod: self filesPerSubDir )		].	"volume.ini"	newIniAccess := self volumeIniAccess.	newIniAccess removeKey: 'volumeID'.	newIniAccess writeFile: ( self volumeIniFileIn: destinationDirectory ).	"index.ini"	newIniAccess := self indexIniAccess.	newIniAccess fileExists ifTrue: [ newIniAccess writeFile: ( self indexIniFileIn: destinationDirectory )].	" app log "	self applicationLoggers do: [: anApplicationLogger | anApplicationLogger copyLogFilesToDirectory: destinationDirectory ].</body><body package="COClusterManagement">defaultFilesPerSubDir	^ 1000</body><body package="COClusterManagement">filenameForBlobOrClusterID: clusterIDInteger 	| cFile |	cFile := self filenameForClusterID: clusterIDInteger.	^cFile exists ifTrue: [cFile] ifFalse: [self filenameForBlobID: clusterIDInteger]</body><body package="COClusterManagement">filesForExtensions: extensions 	"retreive all available stored clusters, answer a set of cluster IDs"	| result |	result := Set new.	self allIDsFor: extensions do: [: id | result add: id ].	^ result</body><body package="COClusterManagement">filesPerSubDir	^filesPerSubDir isNil		ifTrue: [ filesPerSubDir := (self workingDirectory construct: ('0' , self getClusterExtension )) exists						ifTrue: [ 0 ]						ifFalse: [ self defaultFilesPerSubDir ]]		ifFalse: [ filesPerSubDir ]</body><body package="COClusterManagement">getBlobExtension	^CatMAMarshallBinary blobExtension</body><body package="COClusterManagement">getClusterExtension	^CatMAMarshallBinary clusterExtension</body><body package="COClusterManagement">highestSubDir	| result filenames aDirectory |	aDirectory := self workingDirectory.	self filesPerSubDir = 0 ifTrue: [ ^aDirectory ].	result := -1.	filenames := aDirectory directoryContents.	filenames		do: [: fileRepresentingString | | id |			(( fileRepresentingString allSatisfy: [: char | char isDigit ])				and: [( aDirectory construct: fileRepresentingString ) isDirectory ])				ifTrue: [ id := fileRepresentingString asInteger. id &gt; result ifTrue: [ result := id ]]].	^ result &gt;= 0		ifTrue:	[ aDirectory construct: result printString ]		ifFalse: 	[ nil ]</body><body package="COClusterManagement">majorVersionKey	^ 'majorVersion'</body><body package="COClusterManagement">minorVersionKey	^ 'minorVersion'</body><body package="COClusterManagement">moveFilesFrom: aDirectory 	"second step of the cluster save procedure"	^self moveFilesFrom: aDirectory to: self workingDirectory</body><body package="COClusterManagement">moveFilesFrom: sourceDir  to: targetDir	"second step of the cluster save procedure"	| sourceSubDirs targetSubDirs |	targetDir ensureFullDirectory.	sourceSubDirs := Dictionary new.	targetSubDirs := Dictionary new.	sourceDir subDirsAndFilesDo: 	[: subDir : fileString |		fileString ~= 'finished' 		ifTrue:		[	| sourceFile targetSubDir targetFile sourceSubDir |			sourceSubDir := sourceSubDirs 				at: subDir 				ifAbsentPut: [ sourceDir fastConstruct: subDir ].			sourceFile := sourceSubDir fastConstruct: fileString.			targetSubDir := targetSubDirs 				at: subDir 				ifAbsentPut: [					targetSubDir := targetDir fastConstruct: subDir.					targetSubDir ensureFullDirectory.				].			targetFile := targetSubDir  fastConstruct: fileString.			sourceFile moveTo: targetFile."Variante 2:				self sysInterface coastMoveFile: sourceFile to: targetFile.Variante 3:			targetFile delete.			sourceFile renameTo: targetFile."		]	].	sourceDir directoryContents do: 	[: f | f ~= 'finished' 		ifTrue: 		[ (sourceDir construct: f ) delete		]	]</body><body package="COClusterManagement">moveVolumeToDirectory: destinationDirectory 	[	self moveFilesFrom: self workingDirectory to: destinationDirectory.		self workingDirectory delete	] on: Error do: [:ex | 		CoastLog logException: ex message: 'Error while moving files from ', self workingDirectory asString, ' to ', destinationDirectory asString.	]</body><body package="COClusterManagement">readStreamOnBlob: blobID 	| fName |	fName := self filenameForBlobFileID: blobID.	^fName exists		ifTrue: [fName readStream binary]		ifFalse: [nil]</body><body package="COClusterManagement">storageSizeForFile: filename	| fileSize |	fileSize := 0.	[		filename exists 			ifTrue: [fileSize := filename fileSize].	] on: Error do: [ :ex |		CoastLog logError: 'Unable to read :"' , filename printString , '"!'.		ex return	].	^fileSize</body><body package="COClusterManagement">tempDirectory	| tempDir |	tempDir := self workingDirectory construct: 'temp' , 		Timestamp now asSeconds printString, (Time millisecondClockValue \\ 1000) printString.	tempDir makeDirectory; makeWritable.	^ tempDir</body><body package="COClusterManagement">unexpectedFile: fileRepresentingString 	"the fileRepresentingString is not supposed to be in my directory"	self error: 'unexpectedFile: ' , fileRepresentingString</body><body package="COClusterManagement">writeStreamOnCluster: clusterIDInteger	| fName |	" sanity check "	(self filenameForBlobID: clusterIDInteger) exists		ifTrue: [ ^ self error: 'File ', clusterIDInteger printString, ' is a blob, expected a cluster' ].	fName := self filenameForClusterID: clusterIDInteger.	^fName writeStream binary</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>ini</category><body package="COClusterManagement">indexIniAccess	| iniAccess |	iniAccess := CoastIniAccess new.	iniAccess readFile: self indexIniFile.	^iniAccess</body><body package="COClusterManagement">indexIniAccess: aCoastIniAccess	aCoastIniAccess writeFile: self indexIniFile</body><body package="COClusterManagement">indexIniFile	^self indexIniFileIn: self workingDirectory</body><body package="COClusterManagement">indexIniFileIn: directory	^directory constructString: 'index.ini'</body><body package="COClusterManagement">volumeIniAccess	^self volumeIniAccessOn: self workingDirectory</body><body package="COClusterManagement">volumeIniAccess: aCoastIniAccess	aCoastIniAccess writeFile: self volumeIniFile</body><body package="COClusterManagement">volumeIniAccessOn: aDirectory	| iniAccess |	iniAccess := CoastIniAccess new.	iniAccess readFile: (self volumeIniFileIn: aDirectory).	^iniAccess</body><body package="COClusterManagement">volumeIniFile	^self volumeIniFileIn: self workingDirectory</body><body package="COClusterManagement">volumeIniFileIn: directory	^ self class volumeIniFileIn: directory</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>file lock</category><body package="COClusterManagement">fileLock	fileLock isNil ifTrue: 		[	fileLock := FileLock filename: ( self workingDirectory asFilename construct: 'lock' ) infoString: self volumeLockInfoString.			fileLock getLock		].	^ fileLock</body><body package="COClusterManagement">releaseVolumeAccess	| dir |	(fileLock notNil and: [self fileLock hasLock])		ifTrue: [fileLock releaseLock].	fileLock := nil.	dir := self workingDirectory.	dir definitelyExists ifFalse: [ ^ self ].	dir directoryContents do: 	[: fileString | | file |		file := dir construct: fileString.		( file isDirectory 			and: [ file directoryContents isEmpty ])			ifTrue: [ file delete ]	].	dir directoryContents isEmpty		ifTrue: [ dir delete ].</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>utility</category><body package="COClusterManagement">removeClustersByAge: seconds andSize: maxSize 	"for caching *only*"	| checkTime sortedIDsSizesAndTimes totalSize |	totalSize := 0.	checkTime := Time secondClock.	sortedIDsSizesAndTimes := self sortedIDsSizesAndTimes.	sortedIDsSizesAndTimes do: 	[: idSizeAndTime | | age size |	age := checkTime - idSizeAndTime last.		size := idSizeAndTime at: 2.		( age &lt;= seconds and: [ totalSize + size &lt;= maxSize ])			ifTrue: [ totalSize := totalSize + size ]			ifFalse: [ self deleteCluster: idSizeAndTime first ]	].</body><body package="COClusterManagement">sortedIDsSizesAndTimes	"newes first / same age - largest first"	| unsorted |	unsorted := self clusterAndBlobIDs collect: 	[ :	aClusterID | | filename |		filename := self filenameForBlobOrClusterID: aClusterID.		Array with: aClusterID			with: filename fileSize			with: filename modifiedTimestamp asSeconds	].	^unsorted asSortedCollection: 	[: array1 : array2 | 		array1 last = array2 last			ifTrue: [(array1 at: 2) &gt; (array2 at: 2)]			ifFalse: [array1 last &gt; array2 last]	]</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>directories</category><body package="COClusterManagement">setWorkingDirectory: aDirectory	workingDirectory := aDirectory asFilename.	lastID := nil.	lastFilename := nil.</body><body package="COClusterManagement">workingDirectory	workingDirectory isNil 		ifTrue: [workingDirectory := volumeAccessor directoryForVolume: self volume].	^workingDirectory</body><body package="COClusterManagement">workingDirectory: aDirectory	self setWorkingDirectory: aDirectory.</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>transfer</category><body package="COClusterManagement">transferCluster: clusterIDInteger to: writeStream	| readStream |	readStream := self readStreamOnCluster: clusterIDInteger.	[		readStream coastTransferAllTo: writeStream	] valueNowOrOnUnwindDo: [ 		"don't forget to close the readStream - not the writeStream"		readStream close.	].</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor</class-id> <category>initialize - release</category><body package="COClusterManagement">closeAndLockWithMessage: msg 	( FileLock filename: ( self workingDirectory asFilename construct: 'lock' ) infoString: msg ) forceLock.</body><body package="COClusterManagement">ensureVolumeAccess	self fileLock hasLock ifFalse: [ self error: 'volume is locked' ].</body><body package="COClusterManagement">saveAllClustersFor: streamableClusters updatedIndexAccess: newIndexIniOrNil 	"first save all clusters in an empty temp dir, then move all files to the base dir"	| milliseconds tempDir |	self ensureVolumeAccess.	milliseconds := Time millisecondClockValue.	[ | deleteRetry tempCopy |		tempDir := self tempDirectory.		tempCopy := self copy.		tempCopy workingDirectory: tempDir.		tempCopy basicSaveClusters: streamableClusters.		tempCopy updateIndexIniAccessWith: newIndexIniOrNil.		( tempDir construct: 'finished' ) writeStream close.		self moveFilesFrom: tempDir.		( tempDir construct: 'finished' ) delete.		deleteRetry := 0.		[ tempDir exists &amp; ( deleteRetry &lt; 3 )] whileTrue: 			[					[ tempDir delete ] on: OsError					do: 					[: ex |						deleteRetry := deleteRetry + 1.						ex resume					]			].		( self volumeIniAccess )			at: self majorVersionKey put: CoastVersion defaultCoastVersion major displayString;			at: self minorVersionKey put: CoastVersion defaultCoastVersion minor displayString;			writeFrameIndexFile	] on: Error , UnhandledException		do: 		[: ex | | msg |			msg := 'Error during save: ' , ex description.			self haltOrContinue: msg.			self closeAndLockWithMessage: msg.			ex pass		].	self logSavedAllClusters: streamableClusters startedAt: milliseconds.	^ true</body><body package="COClusterManagement">startUpStorageAccessorFrom: clusterManagerOrNil 	clusterManagerOrNil notNil ifTrue: [ volume := clusterManagerOrNil volume ].	self workingDirectory ensureFullDirectory.	super startUpStorageAccessorFrom: clusterManagerOrNil.	self fileLock hasLock ifFalse: 		[	clusterManagerOrNil notNil 				ifTrue: [ clusterManagerOrNil volumeAccessDenied: self fileLock ]				ifFalse: 				[ | error storedInfoString |					error := 'invalid access on volume:' , self workingDirectory tail.					storedInfoString := self fileLock storedInfoString.					storedInfoString isEmpty ifFalse: [ error := error , '(' , storedInfoString , ')' ].					CoastError raiseSignal: error				]		].</body><body package="COClusterManagement">storageDescriptionString	^ self workingDirectory tail asString</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor class</class-id> <category>utility</category><body package="COClusterManagement">bytesFromFile: aFilename	"return *the bytes* as a ByteArray "	| aByteArray aStream size |	aStream := aFilename readStream.	size := aFilename fileSize.	aByteArray := ByteArray new: size.	aStream binary.	"this is faster than aStream contents..."	aStream next: size into: aByteArray startingAt: 1.	aStream close.	^aByteArray</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor class</class-id> <category>volume copy</category><body package="COClusterManagement">copyFrom: sourceStorage to: destinationDirectory 	| dest ini |	self halt: 'needs work'."	dest := self workingDirectory: destinationDirectory.	dest clusterManager: sourceStorage clusterManager.	ini := sourceStorage volumeIniAccess.	ini removeKey: self volumeIDKey.	ini writeFile: (destinationDirectory constructString: 'volume.ini').	sourceStorage clusterIDs do: 			[:cid | 			| bytes |			bytes := (sourceStorage bytesFromCluster: cid).			CoastLog logDebug: cid printString, ' -&gt; ', bytes size printString; cr.			dest storeBytes: bytes forCluster: cid.			].	dest close"</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor class</class-id> <category>instance creation</category><body package="COClusterManagement">cachingDirectory: aDirectory 	^self workingDirectory: aDirectory</body><body package="COClusterManagement">directory: aDirectory volume: volumeName	| wd |	wd := (aDirectory asFilename construct: volumeName).	^ self workingDirectory: wd</body><body package="COClusterManagement">workingDirectory: aDirectory 	^(self new)		workingDirectory: aDirectory;		yourself</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor class</class-id> <category>accessing</category><body package="COClusterManagement">defaultNewStorageAccessorClass	^ self "CatCSBlockStorageAccessor"</body><body package="COClusterManagement">defaultStorageAccessorClass	^ self</body><body package="COClusterManagement">errorSignal	^ CoastFileStorageError</body></methods><methods><class-id>COAST.CatCSFileStorageAccessor class</class-id> <category>ini</category><body package="COClusterManagement">volumeIniFileIn: directory	^ directory constructString: 'volume.ini'</body></methods><methods><class-id>COAST.TimeoutInterrupt</class-id> <category>accessing</category><body package="COUtilities">defaultAction	" fÃ¼r den Fall der FÃ¤lle ganz sicher gehen, dass dieser Interrupt keinen Absturz zur Folge hat	(aber eigentlich darf man nicht bis hierher kommen) "	^ nil</body></methods><methods><class-id>COAST.NFUUnloadStrategy</class-id> <category>load / unload</category><body package="COClusterManagement">notifyClusterAccess: clusterIDInteger 	super notifyClusterAccess: clusterIDInteger.	( self keepClusterIDs includes: clusterIDInteger ) ifFalse: [ self addUnloadableClusterID: clusterIDInteger ]</body></methods><methods><class-id>COAST.NFUUnloadStrategy</class-id> <category>accessing</category><body package="COClusterManagement">newBasicUnloadableClusterIDs	^ SortedCollection sortBlock: [: cidA : cidB | ( accessTable at: cidA ) accessCount &lt;= ( accessTable at: cidB ) accessCount ]</body></methods><methods><class-id>COAST.NFUUnloadStrategy</class-id> <category>testing</category><body package="COClusterManagement">unloadRecommended	super unloadRecommended ifFalse: [ ^ false ].	ObjectMemory globalCompactingGC.	^ super unloadRecommended</body></methods><methods><class-id>COAST.NFUUnloadStrategy class</class-id> <category>constants</category><body package="COClusterManagement">strategyShortName	^ 'NFU'</body></methods><methods><class-id>COAST.FileLock</class-id> <category>public</category><body package="COUtilities">getLock	"Get the lock only if the lock file does not exists"	self fileExists ifFalse: [ self forceLock ]</body><body package="COUtilities">hasLock	"Check if fileLock has the lock"	"Note: this can change from true to false by releaseLock OR by 	hostile forceLock"	| stream iString rNumber |	self fileExists ifFalse: [ ^ false ].	stream := fileName asFilename readStream.	[	stream binary.		iString := [ stream nextCoastString ] on: Error do: [: ex | '' ].		rNumber := [ stream nextCoastString asInteger ] on: Error do: [: ex | 0 ]	] ensure: [ stream close ].	^ iString = infoString and: [ rNumber = randomNumber ]</body><body package="COUtilities">isLockedByOtherProcess	^ self fileExists and: [ self hasLock not ]</body><body package="COUtilities">releaseLock	"Release the lock when holding it"	self hasLock ifTrue: [ fileName asFilename delete ]</body><body package="COUtilities">storedInfoString	"Check if fileLock has the lock"	"Note: this can change from true to false by releaseLock OR by hostile forceLock"	| stream iString |	self fileExists ifFalse: [ ^ '' ].	stream := fileName asFilename readStream.	[	stream binary.		iString := self readLockInfoFrom: stream	] ensure: [ stream close ].	^ iString ifNil: [ '' ]</body></methods><methods><class-id>COAST.FileLock</class-id> <category>public - emergency</category><body package="COUtilities">forceLock	"Definitely get the lock"	"Only use in emergency cases! Better use getLock"	"Note: Does not ensure hasLock"	| stream | 	[ stream := fileName asFilename writeStream ] on: Error do: [: ex | ex return ].	stream isNil 		ifTrue: [ ^ self ].	[	stream binary.		self writeLockInfoOn: stream	] ensure: [ stream close ].</body><body package="COUtilities">maintenanceNeeded: aString	self infoString: aString.	self forceLock.</body></methods><methods><class-id>COAST.FileLock</class-id> <category>private</category><body package="COUtilities">fileExists		^fileName asFilename definitelyExists</body><body package="COUtilities">filename: aFilename	fileName := aFilename</body><body package="COUtilities">generateRandomNumber	^randomNumber := self class nextRandomNumber</body><body package="COUtilities">infoString: aString	infoString := aString,			' (', Timestamp now printString,			', Process: ', OSHandle currentProcessID printString,			')'.</body><body package="COUtilities">readLockInfoFrom: stream 	^ [ stream nextCoastString ] on: Error do: [: ex | '' ]</body><body package="COUtilities">writeLockInfoOn: stream 	stream nextCoastStringPut: infoString.	^ stream nextCoastStringPut: randomNumber printString</body></methods><methods><class-id>COAST.FileLock</class-id> <category>initialize-release</category><body package="COUtilities">initialize</body></methods><methods><class-id>COAST.FileLock class</class-id> <category>instance creation</category><body package="COUtilities">filename: aFilename	^self filename: aFilename infoString: ''</body><body package="COUtilities">filename: aFilename infoString: aString	^(self new)		generateRandomNumber;		filename: aFilename; 		infoString: aString;		yourself</body><body package="COUtilities">new	^ super new initialize</body></methods><methods><class-id>COAST.FileLock class</class-id> <category>privat</category><body package="COUtilities">nextRandomNumber	^((self randomStream next) * SmallInteger maxVal) truncated</body><body package="COUtilities">randomStream	randomStream isNil ifTrue: [randomStream := Random new].	^randomStream</body></methods><methods><class-id>COAST.CatBSBlockFileVolumeAccessor</class-id> <category>auto repair</category><body package="COBlockFileSystem">checkVolume: volume clusterManager: clusterManagerOrNil 	| nilOrErrorMessage bfs |	nilOrErrorMessage := nil.	bfs := self blockFileSystemOnVolume: volume.	clusterManagerOrNil notNil ifTrue: [ bfs lockInfoString: clusterManagerOrNil volumeLockInfoString ].	[	bfs canBeCreated ifTrue: [ ^ nil ].		bfs quickCheck 	] on: Error			do: 			[: ex |				nilOrErrorMessage := ex description.				CoastLog logError: 'Error while checking volume ' , volume printString , ': ' , nilOrErrorMessage 			].	^ nilOrErrorMessage</body><body package="COBlockFileSystem">deepCheckVolume: volume	| nilOrErrorMessage bfs |	nilOrErrorMessage := nil.	bfs := self blockFileSystemOnVolume: volume.	bfs exists ifFalse: [ ^ nil ].	[		bfs deepCheck	] on: Error do: [ : ex |		CoastLog logException: ex message: 'Error while deep checking volume ', volume printString.		nilOrErrorMessage := ex description	].	^ nilOrErrorMessage</body><body package="COBlockFileSystem">quickRecoverVolume: volumeName	| bfs |	bfs := self blockFileSystemOnVolume: volumeName.	bfs quickRecover.</body><body package="COBlockFileSystem">recoverVolume: volumeName	| bfs |	bfs := self blockFileSystemOnVolume: volumeName.	bfs recover.</body></methods><methods><class-id>COAST.CatBSBlockFileVolumeAccessor</class-id> <category>directories</category><body package="COBlockFileSystem">directoryForVolume: aVolume	^ self volumeDirectory construct: aVolume</body></methods><methods><class-id>COAST.CatBSBlockFileVolumeAccessor</class-id> <category>accessing</category><body package="COBlockFileSystem">recoverVolume: oldVolume version: version to: recoverVolume 	| sourceDir targetDir |	sourceDir := ( self backupDirectoryForVolume: oldVolume ) construct: version.	targetDir := self volumeDirectory construct: recoverVolume.	( self blockFileSystemClass directory: sourceDir name: oldVolume ) copyToDirectory: targetDir coreName: recoverVolume includeLock: true.</body><body package="COBlockFileSystem">replaceVolume: oldVolume with: newVolume	| oldBfs newBfs oldDir newDir |	oldVolume = newVolume ifTrue: [ ^ self error: 'Cannot replace volume ', oldVolume printString, ' with itself' ].	oldBfs := self blockFileSystemOnVolume: oldVolume.	newBfs := self blockFileSystemOnVolume: newVolume.	newDir := newBfs workingDirectory.	oldDir := oldBfs workingDirectory.	oldBfs delete.	newBfs moveToDirectory: oldDir coreName: oldVolume.	newDir directoryContents isEmpty		ifTrue: [ newDir delete ].</body><body package="COBlockFileSystem">sizeOfBlobOrCluster: clusterID in: volume	" *** This method was defined by COAST.CatCSVolumeStorageAccessor as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>COAST.CatBSBlockFileVolumeAccessor</class-id> <category>private</category><body package="COBlockFileSystem">basicNewClusterStorageAccessorFor: aVolume	| bfs |	bfs := self blockFileSystemOnVolume: aVolume.	^ self class storageAccessorClass blockFileSystem: bfs</body><body package="COBlockFileSystem">blockFileSystemClass	^ self class blockFileSystemClass</body><body package="COBlockFileSystem">blockFileSystemOnVolume: volumeName	| dir |	dir := self directoryForVolume: volumeName.	^ self blockFileSystemClass directory: dir name: volumeName</body><body package="COBlockFileSystem">isVolumeDirectory: aFilename	^ aFilename exists and: [ aFilename isDirectory and: [  (self blockFileSystemClass directory: aFilename) exists ]]</body></methods><methods><class-id>COAST.CatBSBlockFileVolumeAccessor class</class-id> <category>accessing</category><body package="COBlockFileSystem">blockFileSystemClass	^ self storageAccessorClass blockFileSystemClass</body><body package="COBlockFileSystem">isAbstract	^ false</body><body package="COBlockFileSystem">storageAccessorClass	^CatCSBlockFileStorageAccessor</body></methods><methods><class-id>COAST.CoastLogReconfig</class-id> <category>accessing</category><body package="COUtilities">logIniFile	^ logIniFile</body><body package="COUtilities">logIniFile: stringOrFilname	| newValue |	stringOrFilname isNil 		ifTrue: [ newValue := nil. ]		ifFalse: [ newValue := stringOrFilname isString 									ifTrue: [ stringOrFilname ] 									ifFalse: [ stringOrFilname asString ].				 newValue isEmpty ifTrue: [ newValue := nil. ].				].	logIniFile = newValue ifTrue: [ ^ self ].	logIniFile := newValue.	self updateCheckerProcess.</body><body package="COUtilities">logIniFileCheck	^ logIniFileCheck ifNil: [ 0 ]</body><body package="COUtilities">logIniFileCheck: newValue	logIniFileCheck = newValue ifTrue: [ ^ self ].	logIniFileCheck := newValue.	self updateCheckerProcess.</body></methods><methods><class-id>COAST.CoastLogReconfig</class-id> <category>setup - ini</category><body package="COUtilities">iniBlocks	| d |	d := Dictionary new.	d		at: 'logIniFile' put: [ : s : ini | self logIniFile: s ];		at: 'logIniFileCheck' put: [ : s : ini | self logIniFileCheck: ([ s asInteger ] on: Error do: [ : ex | ex return: 0 ]) ].	^ d</body><body package="COUtilities">initializeFromIni: iniAccess	self logIniFile: iniAccess filename.	self iniBlocks keysAndValuesDo: [ : key : keyBlock | | s |		s := iniAccess category: nil stringAt: key.		s notNil			ifTrue: [ keyBlock value: s value: iniAccess ]		].</body></methods><methods><class-id>COAST.CoastLogReconfig</class-id> <category>private</category><body package="COUtilities">applyIniAccess: iniAccess	| coastLog |	coastLog := CoastLog singleton.	coastLog initializeDefaults.	coastLog iniBlocks keysAndValuesDo: [ : key : keyBlock | | s |		(self reconfigurableCoastLogIniBlockKeys includes: key) ifTrue: [			s := iniAccess category: nil stringAt: key.			s notNil ifTrue: [ 				keyBlock value: s value: iniAccess.				].			].	].	self initializeFromIni: iniAccess.	coastLog log: 'reconfigured coast logging'.</body><body package="COUtilities">checkForNewLogConfig	| filename iniAccess file timestamp |	filename := self logIniFile.	(filename isNil or: [ filename isEmpty ]) ifTrue: [ ^ self ].	file := filename asFilename.	(file definitelyExists and: [ file isReadable ]) ifFalse: [ ^ self ].	timestamp := file modificationTimestamp.	(timestamp isNil or: [ lastModificationTimestamp notNil and: [ timestamp &lt;= lastModificationTimestamp ]])		ifTrue: [ ^ self ].	iniAccess := [ CoastIniAccess readFile: filename ] on: Error do: [ : ex | ex return: nil ].	iniAccess isNil ifTrue: [ ^ self ].	lastModificationTimestamp := timestamp.	self applyIniAccess: iniAccess.</body><body package="COUtilities">checkIniFileLoop	(Delay forSeconds: self logIniFileCheck) wait.	self checkForNewLogConfig.</body><body package="COUtilities">reconfigurableCoastLogIniBlockKeys	^ #('loglevel' 'logprefix' 'debug' 'exceptionLogSize' 'minTime' 'maxLogSize' 'channels')</body><body package="COUtilities">updateCheckerProcess	| process |	(Notifier isDevelopment or: [ self logIniFileCheck = 0 or: [ self logIniFile isNil ]]) ifTrue: [ 		checkerProcess isNil ifFalse: [			"remember me before terminating myself :)"			process := checkerProcess.			checkerProcess := nil.			process terminate.			].		^ self		].	checkerProcess isNil ifFalse: [ ^ self ].	process := [ [ self checkIniFileLoop. ] repeat. ] forkAt: Processor userSchedulingPriority + 1.	process name: self class name, '.checkIniFileLoop'.	checkerProcess := process.</body></methods><methods><class-id>COAST.CoastLogReconfig class</class-id> <category>accessing</category><body package="COUtilities">singleton	singleton isNil ifTrue: [ 			singleton := self new.		].	^ singleton</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor</class-id> <category>requests - blob</category><body package="COBlockFileSystem">blobExists: blobID	^ (self blockFileSystem fileExists: blobID) and: [ (self blockFileSystem getFile: blobID) isBlob ]</body><body package="COBlockFileSystem">bytesFor: blobIDInteger 	| str bytes |	str := self readStreamOnBlob: blobIDInteger.	[		bytes := str upToEnd	] ensure: [		str close	].	^ bytes</body><body package="COBlockFileSystem">importBlob: blobIDInteger fromFile: aFilename	| readStr writeStr |	readStr := aFilename readStream binary.	[		writeStr := self writeStreamOnBlob: blobIDInteger.		[			[ readStr atEnd ] whileFalse: [				writeStr nextPut: readStr next			]		] ensure: [			writeStr close		].			] ensure: [		readStr close	]</body><body package="COBlockFileSystem">readStreamOnBlob: blobID	| file |	file := self blockFileSystem getFile: blobID.	^ (file notNil and: [ file isBlob ])		ifTrue: [ self blockFileSystem readStreamOnFile: file ]		ifFalse: [ nil ]</body><body package="COBlockFileSystem">realSizeForBlobNr: clusterIDInteger	| file |	file := self blockFileSystem getFile: clusterIDInteger.	file isNil		ifTrue: [ ^ self error: 'Blob ', clusterIDInteger printString, ' not found' ].	file isBlob		ifFalse: [ ^ self error: 'File ', clusterIDInteger printString, ' is not a cluster' ].	^ file fileSize</body><body package="COBlockFileSystem">writeStreamOnBlob: blobID	| file |	file := self blockFileSystem getOrCreateBlobFile: blobID.	^ self blockFileSystem writeStreamOnFile: file</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor</class-id> <category>requests</category><body package="COBlockFileSystem">backupVolume	| backupDir message |	self blockFileSystem isBackupActive 		ifTrue: 		[	message := 'Backup of volume ' , self volume , ' already initiated'.			CoastLog log: message.			^ CoastStatusResponse failureCode: #backupAlreadyInitiated message: message		].	CoastLog log: 'Starting backup of ' , self volume printString.	[ backupDir := self directoryForBackup ] 		on: OsError		do: 		[: ex |			message := 'Error while creating backup directory'.			CoastLog logFatalException: ex message: message.			^ CoastStatusResponse failureCode: #couldNotCreateBackupDirectory message: message , ': ' , ex description		].	^ [	self blockFileSystem backgroundBackupToDirectory: backupDir.		self applicationLoggers do: [: applicationLogger | applicationLogger copyLogFilesToDirectory: backupDir ].		CoastLog log: 'Finished exclusive part of backup of ' , self volume printString.		CoastStatusResponse okCode: CoastStatusResponse codeBackupStarted message: CoastConstant responseStringBackupStarted	] 		on: CatBFBackgroundCopyError		do: 		[: ex |			message := 'Could not initiate backup of volume ' , self volume.			CoastLog logFatalException: ex message: message.			CoastStatusResponse failureCode: #backupFailed message: message , ': ' , ex description		]</body><body package="COBlockFileSystem">blobIDs	^ self blockFileSystem blobIDs</body><body package="COBlockFileSystem">blockUntilBackupIsDone	" todo: 		cannot distinguish between 'backup finished' and 'never initiated a backup'		when initiating a backup, the server should return a token, which should be passed by the client to this request "	^ self blockFileSystem isBackupActive 		ifTrue: 		[	self blockFileSystem blockUntilBackupIsDone.			CoastStatusResponse okCode: CoastStatusResponse codeBackupFinished message: 'Backup of volume ' , self volume , ' finished'		]		ifFalse: [ CoastStatusResponse okCode: CoastStatusResponse codeNoBackupActive message: 'No backup of volume ' , self volume , ' active' ]</body><body package="COBlockFileSystem">closeAndLockWithMessage: msg 	self blockFileSystem privateCloseRecoveryNeeded: msg.</body><body package="COBlockFileSystem">clusterAndBlobIDs	^ self blockFileSystem clusterAndBlobIDs</body><body package="COBlockFileSystem">clusterExists: clusterIDInteger	^ (self blockFileSystem fileExists: clusterIDInteger) and: [ (self blockFileSystem getFile: clusterIDInteger) isCluster ]</body><body package="COBlockFileSystem">clusterIDs	^ self blockFileSystem clusterIDs</body><body package="COBlockFileSystem">compress	^ self blockFileSystem compress</body><body package="COBlockFileSystem">copyVolumeTo: newVolume 	| destination |	destination := volumeAccessor directoryForVolume: newVolume.	self blockFileSystem copyToDirectory: destination coreName: newVolume includeLock: false.	self applicationLoggers do: [: anApplicationLogger | anApplicationLogger copyLogFilesToDirectory: destination ].</body><body package="COBlockFileSystem">deleteCluster: clusterIDInteger ifAbsent: block	^ (self blockFileSystem fileExists: clusterIDInteger)		ifTrue: [ 			[				self blockFileSystem deleteFileNumber: clusterIDInteger.				true			] on: Error do: [ : ex |				CoastLog logException: ex message: 'Error while deleting cluster/blob ', clusterIDInteger printString.				false			].		]		ifFalse: [			block value		].</body><body package="COBlockFileSystem">deleteVolumeNoBackup	[( self blockFileSystem )			close;			delete.		self applicationLoggers do: 			[: anApplicationLogger |				anApplicationLogger shutDown;					deleteLogFiles			]	] on: Error do: [: ex | CoastLog logException: ex message: 'Error while deleting volume ' , self workingDirectory asString ].</body><body package="COBlockFileSystem">exclusiveInitiateCopyVolumeForDownload	| destDir tempVolName copyInfo |	tempVolName := 'download' , Timestamp now asSeconds printString.	destDir := volumeAccessor ensureDirectoryNamed: tempVolName.	copyInfo := self blockFileSystem backgroundCopyToDirectory: destDir.	copyInfo isNil ifTrue: [ self error: 'Could not create a temporary copy of the volume for download' ].	^ copyInfo</body><body package="COBlockFileSystem">highestID	^ self blockFileSystem highestFileNumber</body><body package="COBlockFileSystem">nonExclusiveFinishCopyVolumeForDownloadWith: copyInfo	| bfs sa |	copyInfo blockUntilCopyIsDone.	bfs := self blockFileSystemClass directory: copyInfo targetDirectory name: self volume.	( bfs notNil and: [ bfs exists ]) 		ifFalse: [ self error: 'Could not create a temporary copy of the volume for download' ].	sa := self class blockFileSystem: bfs.	sa volume: self volume.	^ sa</body><body package="COBlockFileSystem">readStreamOnCluster: clusterIDInteger	| file |	file := self blockFileSystem getFile: clusterIDInteger.	^ (file notNil and: [ file isCluster ])		ifTrue: [ self blockFileSystem readStreamOnFile: file ]		ifFalse: [ nil ]</body><body package="COBlockFileSystem">saveAllClustersFor: streamableClusters updatedIndexAccess: newIndexIniOrNil 	| milliseconds |	self blockFileSystem readOnly ifTrue: [ ^ false ].	self ensureVolumeAccess.	milliseconds := Time millisecondClockValue.	self blockFileSystem exclusiveUseDo: 		[				[	self basicSaveClusters: streamableClusters.				self updateIndexIniAccessWith: newIndexIniOrNil.				self blockFileSystem writeBack			] on: Error , UnhandledException				do: 				[: ex | | msg |					msg := 'Error during save: ' , ex description.					self haltOrContinue: msg.					self closeAndLockWithMessage: msg.					ex pass				]		].	self logSavedAllClusters: streamableClusters startedAt: milliseconds.	^ true</body><body package="COBlockFileSystem">storageDescriptionString	^ self blockFileSystem displayString</body><body package="COBlockFileSystem">storageSizeForCluster: clusterIDInteger	| file |	file := self blockFileSystem getFile: clusterIDInteger.	file isNil		ifTrue: [ ^ self error: 'Cluster ', clusterIDInteger printString, ' not found' ].	file isCluster		ifFalse: [ ^ self error: 'File ', clusterIDInteger printString, ' is not a cluster' ].	^ file fileSize</body><body package="COBlockFileSystem">writeStreamOnCluster: clusterIDInteger	^ self blockFileSystem writeStreamOnCluster: clusterIDInteger</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor</class-id> <category>private</category><body package="COBlockFileSystem">allIDsDo: aBlock 	^ self blockFileSystem allIDsDo: aBlock</body><body package="COBlockFileSystem">blockFileSystem	" BlockFileSystem that is used to store clusters/blobs/special files "	^ blockFileSystem</body><body package="COBlockFileSystem">blockFileSystem: aCatBFBlockFileSystem	" BlockFileSystem that is used to store clusters/blobs/special files "	blockFileSystem := aCatBFBlockFileSystem</body><body package="COBlockFileSystem">blockFileSystemClass	^ self class blockFileSystemClass</body><body package="COBlockFileSystem">copyVolumeToDirectory: aDirectory 	self blockFileSystem copyToDirectory: aDirectory.	self applicationLoggers do: [: anApplicationLogger | anApplicationLogger copyLogFilesToDirectory: aDirectory ].</body><body package="COBlockFileSystem">ensureVolumeAccess	self blockFileSystem isNil		ifTrue: [ self error: 'Block file system not configured' ].	self blockFileSystem isOpen		ifFalse: [ self blockFileSystem open ]</body><body package="COBlockFileSystem">largestClusterDo: block maxCount: maxCount 	blockFileSystem largestClusterDo: block maxCount: maxCount</body><body package="COBlockFileSystem">moveVolumeToDirectory: destinationDirectory	[	self blockFileSystem moveToDirectory: destinationDirectory.		self applicationLoggers do: [: anApplicationLogger | anApplicationLogger moveLogFilesToDirectory: destinationDirectory ].		self workingDirectory delete	] on: Error		do: [: ex | self error: 'Error while moving files from ' , self blockFileSystem displayString , ' to ' , destinationDirectory asString , ': ' , ex description ].</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor</class-id> <category>accessing</category><body package="COBlockFileSystem">coastVersion		^ self blockFileSystem version</body><body package="COBlockFileSystem">exists	^ self blockFileSystem exists</body><body package="COBlockFileSystem">gcEnabled	^ true</body><body package="COBlockFileSystem">nextClusterID	| id |	" 0 is reserved "	^ ((id := self blockFileSystem nextClusterID) &gt; 0 and: [ (self blockFileSystem fileExists: id) not ])		ifTrue: [ id ]		ifFalse: [ nil ]</body><body package="COBlockFileSystem">nextClusterID: anInteger	self blockFileSystem nextClusterID: anInteger</body><body package="COBlockFileSystem">nextClusterIDToLoad	| block file |	block := blockFileSystem getNextBlockFromSeekPosition.	block isNil ifTrue: [ ^ super nextClusterIDToLoad ].	file := blockFileSystem getFile: block fileNumber.	^ (file notNil and: [ file isCluster ])		ifTrue: [ file fileNumber ]		ifFalse: [  nil ].</body><body package="COBlockFileSystem">okToCleanup	^ super okToCleanup and: [ self blockFileSystem isBackgroundCopyActive not ]</body><body package="COBlockFileSystem">optimizeInMemory	self blockFileSystem optimizeInMemory</body><body package="COBlockFileSystem">prepareDeleteVolume	self blockFileSystem isBackgroundCopyActive 		ifTrue: [ CatBFError raiseSignal: 'Volume ', self volume printString, ' cannot be deleted, background operation(s) are still active' ].	super prepareDeleteVolume</body><body package="COBlockFileSystem">uniqueVolumeID	^ self blockFileSystem uniqueVolumeID</body><body package="COBlockFileSystem">uniqueVolumeID: aString	self blockFileSystem uniqueVolumeID: aString</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor</class-id> <category>ini</category><body package="COBlockFileSystem">configureWithIni: ini	super configureWithIni: ini.	self blockFileSystem configureWithIni: ini</body><body package="COBlockFileSystem">indexIniAccess		^ self blockFileSystem indexIniAccess</body><body package="COBlockFileSystem">indexIniAccess: aCoastIniAccess		self blockFileSystem indexIniAccess: aCoastIniAccess</body><body package="COBlockFileSystem">volumeIniAccess	^ self blockFileSystem volumeIniAccess</body><body package="COBlockFileSystem">volumeIniAccess: aCoastIniAccess	self blockFileSystem volumeIniAccess: aCoastIniAccess</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor</class-id> <category>initialize-release</category><body package="COBlockFileSystem">prepareRelease	super prepareRelease.	self blockFileSystem prepareClose.</body><body package="COBlockFileSystem">releaseVolumeAccess	self blockFileSystem close.</body><body package="COBlockFileSystem">removeClustersByAge: seconds andSize: maxSize 	" reducing the number of cached clusters is done by writeBack "	self blockFileSystem writeBack.</body><body package="COBlockFileSystem">startUpStorageAccessorFrom: clusterManagerOrNil 	self blockFileSystem lockInfoString: ( clusterManagerOrNil ifNotNil: [: cm | cm volumeLockInfoString ] ifNil: [ 'locked: ' , self displayString ]).	self blockFileSystem openOrCreate.	super startUpStorageAccessorFrom: clusterManagerOrNil.</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor</class-id> <category>directories</category><body package="COBlockFileSystem">workingDirectory	^ self blockFileSystem workingDirectory</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor</class-id> <category>utility</category><body package="COBlockFileSystem">emergencyRemoveAllClusters	self blockFileSystem emergencyRemoveAllFiles.</body><body package="COBlockFileSystem">removeAllClusters	self blockFileSystem removeAllFiles</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor class</class-id> <category>instance creation</category><body package="COBlockFileSystem">blockFileSystem: aCatBFBlockFileSystem	^ self new 		blockFileSystem: aCatBFBlockFileSystem;		yourself</body><body package="COBlockFileSystem">directory: aDirectory volume: volumeName	| bfs wd |	wd := aDirectory asFilename construct: volumeName.	bfs := self blockFileSystemClass directory: wd name: volumeName.	^ self blockFileSystem: bfs</body></methods><methods><class-id>COAST.CatCSBlockFileStorageAccessor class</class-id> <category>accessing</category><body package="COBlockFileSystem">blockFileSystemClass	^ CatBFBlockFileSystem</body></methods><methods><class-id>COAST.CoastIniAccess</class-id> <category>accessing</category><body package="COUtilities">at: aKey	" answer the value at the default category at aKey as a string "	^ self category: nil at: aKey</body><body package="COUtilities">at: aKey ifAbsent: aBlockClosure	" answer the value at the default category at aKey as a string "	^ self category: nil at: aKey ifAbsent: aBlockClosure</body><body package="COUtilities">at: aKey put: aValue	" put the value at the default category at aKey as a string"	^ self category: nil at: aKey put: aValue.</body><body package="COUtilities">booleanAt: aKey	" answer the boolean at the default category at aKey "	^ self category: nil booleanAt: aKey</body><body package="COUtilities">booleanAt: aKey ifAbsent: aBlockClosure	" answer the boolean at the default category at aKey "	^ self category: nil booleanAt: aKey ifAbsent: aBlockClosure</body><body package="COUtilities">category: aString 	" return the dictionary associated with the category "	| categoryString |	categoryString := aString notNil 			ifTrue: [ aString ]			ifFalse: [ self defaultCategory ].	^ dictionary at: categoryString ifAbsent: [ nil ]</body><body package="COUtilities">category: aString at: aKey	" answer the value at the category at aKey as a string, or nil if it doesn't exist "	^ self category: aString at: aKey ifAbsent: [ nil ]</body><body package="COUtilities">category: aString at: aKey ifAbsent: aBlockClosure 	" answer the value at the category at aKey as a string "	| dict |	dict := self category: aString.	^dict isNil 		ifTrue: [aBlockClosure value]		ifFalse: [dict at: aKey asIniString ifAbsent: aBlockClosure]</body><body package="COUtilities">category: aString at: aKey put: aValue	" put the value at the category at aKey as a string"	self category: aString at: aKey putIniString: aValue asIniString.	^ aValue</body><body package="COUtilities">category: aString at: aKey putIniString: aConvertedString 	" put the value at the category at aKey as a string"	| categoryString |	categoryString := aString notNil 			ifTrue: [ aString ]			ifFalse: [ self defaultCategory ].	self createCategoryIfAbsent: categoryString.	( self dictionary at: categoryString ) at: aKey asIniString put: aConvertedString.	^ aConvertedString</body><body package="COUtilities">category: aString booleanAt: aKey	" answer the boolean at the category at aKey "	^ self category: aString booleanAt: aKey ifAbsent: [ nil ]</body><body package="COUtilities">category: aString booleanAt: aKey ifAbsent: aBlockClosure	" answer the boolean at the category at aKey "	| value |	value := self category: aString at: aKey.	^ (value notNil and: [ #('true' 'false') includes: value asLowercase ])		ifTrue: [ Boolean readFrom: value asLowercase ]		ifFalse: [ aBlockClosure value ].</body><body package="COUtilities">category: aString collectionAt: aKey separater: char	| string |	string := self category: aString at: aKey ifAbsent: [ nil ].	string isNil ifTrue: [ ^ OrderedCollection new ].	^ (string tokensBasedOn: char) collect: [ : nm | nm trimBlanks ]</body><body package="COUtilities">category: category memoryAt: aKey ifAbsent: aBlockClosure	" answer an amount of memory at aKey 	assume memory is &gt;= 1 MB "	| mem |	mem := self category: category numberAt: aKey ifAbsent: aBlockClosure.	^ (mem notNil and: [ mem &lt; 1048576 ])		ifTrue: [ mem * 1048576 ]		ifFalse: [ mem ]</body><body package="COUtilities">category: aString numberAt: aKey	" answer the number at the category at aKey  "	^ self category: aString numberAt: aKey ifAbsent: [ nil ]</body><body package="COUtilities">category: aString numberAt: aKey ifAbsent: aBlockClosure	" answer the number at the category at aKey  "	| value |	value := self category: aString at: aKey.	^ value notNil		ifTrue: [ Number readFrom: value readStream ]		ifFalse: [ aBlockClosure value ].</body><body package="COUtilities">category: aString pointAt: aKey	" answer the number at the category at aKey  "	^ self category: aString pointAt: aKey ifAbsent: [ nil ]</body><body package="COUtilities">category: aString pointAt: aKey ifAbsent: aBlockClosure	" answer the point at the category at aKey "	| value |	value := self category: aString at: aKey.	^ value notNil		ifTrue: [ Point readFrom: value readStream ]		ifFalse: [ aBlockClosure value ].</body><body package="COUtilities">category: cat removeKey: aKey	" remove the value at category &lt;cat&gt; at &lt;aKey&gt; "	| dict |	dict := self category: cat.	dict isNil 		ifFalse: [dict removeKey: aKey asIniString ifAbsent: []]</body><body package="COUtilities">category: aString secondsAt: aKey defaultUnit: defaultUnit ifAbsent: aBlockClosure 	" answer the number of seconds at the category at aKey. 	if no unit is specified, the defaultUnit will be used "	| string stream numberStream ch number secondsUnitMultiplier |	string := self category: aString stringAt: aKey ifAbsent: [ ^ aBlockClosure value ].	stream := string readStream.	numberStream := String new writeStream.	[( ch := stream next ) notNil and: [ ch isDigit ]] whileTrue: [ numberStream nextPut: ch ].	number := numberStream contents asInteger.	ch isNil ifTrue: [ ch := defaultUnit ].	secondsUnitMultiplier := self secondsUnitMultiplier at: ch asLowercase ifAbsent: [ self error: 'Unknown unit: ' , string ].	^ number * secondsUnitMultiplier</body><body package="COUtilities">category: aString stringAt: aKey	" answer the original string at the category at aKey "	^ self category: aString stringAt: aKey ifAbsent: nil</body><body package="COUtilities">category: aString stringAt: aKey ifAbsent: aBlockClosure	" answer the original string at the category at aKey "	| value |	value := self category: aString at: aKey.	^ value notNil 		ifTrue: [ String fromIniString: value ]		ifFalse: [ aBlockClosure value ].</body><body package="COUtilities">category: aString symbolAt: aKey 	" answer the symbol at the category at aKey "	^ self category: aString symbolAt: aKey ifAbsent: [ nil ]</body><body package="COUtilities">category: aString symbolAt: aKey ifAbsent: aBlockClosure	" answer the symbol at the category at aKey "	| value |	value := self category: aString at: aKey.	^ value notNil		ifTrue: [ value asSymbol]		ifFalse: [ aBlockClosure value ].</body><body package="COUtilities">categorySet	^self dictionary keys</body><body package="COUtilities">collectionAt: aKey separater: char	^ self category: nil collectionAt: aKey separater: char</body><body package="COUtilities">defaultCategory	" the default category that will be used when no category is given (e.g. when using #at:) "	^ defaultCategory</body><body package="COUtilities">defaultCategory: aString	" set the default category that will be used when no category is given (e.g. when using #at:) "	defaultCategory := aString</body><body package="COUtilities">empty	self initialize.</body><body package="COUtilities">iniValueAt: parameterName category: category ifAbsentPut: aValue	| value |	value := self				category: category 				at: parameterName 				ifAbsent: [ self category: category at: parameterName put: aValue ].	^ value</body><body package="COUtilities">memoryAt: aKey ifAbsent: aBlockClosure	" answer an amount of memory at the default category at aKey 	assume memory is &gt;= 1 MB "	^ self category: nil memoryAt: aKey ifAbsent: aBlockClosure</body><body package="COUtilities">millisecondsAt: aKey ifAbsent: aBlockClosure	" answer an amount of milliseconds at the default category at aKey 	assume value is &gt;= 1 sec   "	| msecs |	msecs := self numberAt: aKey ifAbsent: aBlockClosure.	^ (msecs notNil and: [ msecs &lt; 1000 ])		ifTrue: [ msecs * 1000 ]		ifFalse: [ msecs ]</body><body package="COUtilities">numberAt: aKey	" answer the number at the default category at aKey  "	^ self category: nil numberAt: aKey</body><body package="COUtilities">numberAt: parameterName category: category rangeLow: rangeLow rangeHigh: rangeHigh default: defaultValue	| value |	value := self iniValueAt: parameterName category: category ifAbsentPut: defaultValue.	value := value asNumber.	(rangeLow notNil and: [ value &lt; rangeLow ]) ifTrue: [		CoastLog log: 'value &lt;', value printString, '&gt; to low for parameter &lt;' , parameterName, '&gt; - using default &lt;' , defaultValue printString , '&gt;'.		value := defaultValue.		].	(rangeHigh notNil and: [ value &gt; rangeHigh ]) ifTrue: [		CoastLog log: 'value &lt;', value printString, '&gt; to high for parameter &lt;' , parameterName, '&gt; -  using default &lt;' , defaultValue printString , '&gt;'.		value := defaultValue.		].	^ value</body><body package="COUtilities">numberAt: aKey ifAbsent: aBlockClosure	" answer the number at the default category at aKey  "	^ self category: nil numberAt: aKey ifAbsent: aBlockClosure</body><body package="COUtilities">pointAt: aKey	" answer the number at the default category at aKey  "	^ self category: nil pointAt: aKey</body><body package="COUtilities">pointAt: aKey ifAbsent: aBlockClosure	" answer the number at the default category at aKey  "	^ self category: nil pointAt: aKey ifAbsent: aBlockClosure</body><body package="COUtilities">popDefaultCategory	self defaultCategory: categoryStack removeLast</body><body package="COUtilities">pushDefaultCategory	categoryStack addLast: self defaultCategory.</body><body package="COUtilities">removeKey: aKey	" remove the value at the default category at &lt;aKey&gt; "	^ self category: nil removeKey: aKey</body><body package="COUtilities">secondsAt: aKey defaultUnit: defaultUnit ifAbsent: aBlockClosure 	^ self category: nil secondsAt: aKey defaultUnit: defaultUnit ifAbsent: aBlockClosure</body><body package="COUtilities">stringAt: aKey	^ self category: nil stringAt: aKey</body><body package="COUtilities">stringAt: aKey ifAbsent: absentBlock	^ self category: nil stringAt: aKey ifAbsent: absentBlock</body></methods><methods><class-id>COAST.CoastIniAccess</class-id> <category>private</category><body package="COUtilities">createCategoryIfAbsent: aString	(dictionary at: aString ifAbsent: [nil]) isNil		ifTrue: [ dictionary at: aString put: Dictionary new ].</body><body package="COUtilities">dictionary	^ dictionary</body><body package="COUtilities">dictionary: aDictionary	dictionary := aDictionary</body><body package="COUtilities">secondsUnitMultiplier	| secondsUnitMultiplier |	secondsUnitMultiplier := Dictionary new.	secondsUnitMultiplier		at: $s put: 1;		at: $m put: 60;		at: $h put: 60*60;		at: $d put: 60*60*24.	^ secondsUnitMultiplier</body></methods><methods><class-id>COAST.CoastIniAccess</class-id> <category>private - fileIO</category><body package="COUtilities">defaultDirectory	" make sure the directory ends with an separator  "		^ self class defaultDirectory withSeparator</body><body package="COUtilities">processLine: aString 	" parse the line and do the right thing. Would be easier in Perl ;-) "	" empty line "	| line i key value |	aString isNil 		ifTrue: [ ^ self ].	( line := aString coastTrimBlanks ) isEmpty 		ifTrue: [ ^ self ].	"comment"	line first = $; 		ifTrue: [ ^ self ].	" [category] "	( line first = $[ and: [ line last = $] and: [ line size &gt; 2 ]]) 		ifTrue: 		[	self readCategory: ( line copyFrom: 2 to: line size - 1 ).			^ self		].	"key=value"	i := line indexOf: $= ifAbsent: [ nil ].	i notNil 		ifTrue: 		[	i &gt; 1 				ifTrue: 				[	key := ( String fromIniString: ( line copyFrom: 1 to: i - 1 )) coastTrimBlanks.					value := ( line copyFrom: i + 1 to: line size ) coastTrimBlanks.					self category: readCategory at: key putIniString: value				].			^ self		].	CoastLog logWarning: 'Could not parse the following ini line:' , aString.</body><body package="COUtilities">readCategory	^ readCategory</body><body package="COUtilities">readCategory: aString	readCategory := aString.	self createCategoryIfAbsent: aString.</body></methods><methods><class-id>COAST.CoastIniAccess</class-id> <category>fileIO</category><body package="COUtilities">defaultSortBlock	^ [: val1 : val2 | val1 &lt; val2 ]</body><body package="COUtilities">fileExists	^ filename definitelyExists</body><body package="COUtilities">filename	^ filename</body><body package="COUtilities">readFile: aFilename 	| stream |	filename := aFilename asFilename.	filename definitelyExists ifFalse: [ ^ self ].	stream := filename readStream text.	[ self readFrom: stream ] ensure: [ stream close ].</body><body package="COUtilities">readFrom: aStream	| str lb ch |	str := String new writeStream.	lb := Array with: Character cr with: Character lf.	[aStream atEnd] 	whileFalse:[		ch := aStream next.		(lb includes: ch)			ifTrue: [				self processLine: str contents.				str := String new writeStream.			]			ifFalse: [ str nextPut: ch ].	]."Don't forget the last line - there might be no cr at the end of the file! "	self processLine: str contents</body><body package="COUtilities">readFromBinary: aStream 	| dict1 |	dict1 := Dictionary new.	aStream next32		timesRepeat: 			[| dict2 category |			dict2 := Dictionary new.			category := aStream nextCoastString.			aStream next32 timesRepeat: [dict2 at: aStream nextCoastString put: aStream nextCoastString].			dict1 at: category put: dict2].	self dictionary: dict1.</body><body package="COUtilities">writeFile	self writeFile: filename</body><body package="COUtilities">writeFile: aFilename 	^ self writeFile: aFilename categorySortBlock: self defaultSortBlock keySortBlock: self defaultSortBlock</body><body package="COUtilities">writeFile: aFilename categorySortBlock: categorySortBlock keySortBlock: keySortBlock 	| stream file |	file := aFilename asFilename.	( file exists not or: [ file isWritable ]) 		ifTrue: 		[	stream := file writeStream text.			[ self writeTo: stream categorySortBlock: categorySortBlock keySortBlock: keySortBlock ] ensure: [ stream close ]		]		ifFalse: [ self error: 'Could not write INI file: ' , aFilename asString ]</body><body package="COUtilities">writeFrameIndexFile	| categoryDict |	categoryDict := Dictionary new.	self writeFile: filename		categorySortBlock: 		[: cat1 : cat2 | | n1 n2 |			n1 := categoryDict at: cat1 ifAbsentPut: [(( self category: cat1 at: '#frameKey' ) ifNil: [ 0 ]) asNumber ].			n2 := categoryDict at: cat2 ifAbsentPut: [(( self category: cat2 at: '#frameKey' ) ifNil: [ 0 ]) asNumber ].			n1 &lt; n2		]		keySortBlock: [: key1 : key2 | key1 &lt; key2 ]</body><body package="COUtilities">writeTo: aStream 	^ self writeTo: aStream categorySortBlock: self defaultSortBlock keySortBlock: self defaultSortBlock</body><body package="COUtilities">writeTo: aStream categorySortBlock: categorySortBlock keySortBlock: keySortBlock 	" Write the Ini-data to the stream. Writes the categories and keys sorted "	( self dictionary keys asSortedCollection: categorySortBlock ) do: 		[: category | | keyValueDictionary |			keyValueDictionary := self dictionary at: category.			aStream				nextPut: $[;				nextPutAll: category;				nextPut: $];				cr.			( keyValueDictionary keys asSortedCollection: keySortBlock ) do: 				[: key |					aStream						nextPutAll: key;						nextPut: $=;						nextPutAll: ( keyValueDictionary at: key );						cr				].			aStream cr		]</body><body package="COUtilities">writeToBinary: aStream 	"Write the Ini-data to the stream. Writes the categories and keys 	sorted"	aStream next32Put: self dictionary size.	(self dictionary associations asSortedCollection: [:a :b | a key &lt; b key])		do: 			[:categoryAndDictionary | 			| category keyValueDictionary |			category := categoryAndDictionary key.			keyValueDictionary := categoryAndDictionary value.			aStream nextCoastStringPut: category.			aStream next32Put: keyValueDictionary size.			(keyValueDictionary associations asSortedCollection: [:a :b | a key &lt; b key])				do: [:association | aStream nextCoastStringPut: association key; nextCoastStringPut: association value]]</body></methods><methods><class-id>COAST.CoastIniAccess</class-id> <category>initialize-release</category><body package="COUtilities">initialize	dictionary := Dictionary new.	categoryStack := OrderedCollection new.	defaultCategory := 'Default'</body></methods><methods><class-id>COAST.CoastIniAccess class</class-id> <category>instance creation</category><body package="COUtilities">new	^super new initialize</body><body package="COUtilities">readFile: aFilename	^ self new		readFile: aFilename;		yourself.</body><body package="COUtilities">readFrom: aStream	^ self new		readFrom: aStream;		yourself.</body></methods><methods><class-id>COAST.CoastError</class-id> <category>tesing</category><body package="COBase">isCoastError	^true</body></methods><methods><class-id>COAST.CoastError class</class-id> <category>instance creation</category><body package="COBase">raiseBadValueClass	self raiseSignal: 'invalid value class'</body></methods><methods><class-id>COAST.CoastError class</class-id> <category>accessing</category><body package="COBase">classForStatusResponse: statusResponse	| code |	code := statusResponse code.	^ CoastError allSubclasses detect: [ : errorClass | errorClass statusResponseCode = code ] ifNone: [ CoastError ].</body><body package="COBase">statusResponseCode	" returns the matching CoastStatusResponse code, or nil "	^ nil</body></methods><methods><class-id>COAST.PersistentTextCollector</class-id> <category>entry control</category><body package="COUtilities">beginEntry</body><body package="COUtilities">closeCollector	self closeFile.</body><body package="COUtilities">endEntry	self changed: #appendEntry.</body></methods><methods><class-id>COAST.PersistentTextCollector</class-id> <category>character writing</category><body package="COUtilities">cr	self fileStream cr.	self flushFile.	self checkFileSize.</body><body package="COUtilities">crtab	self fileStream crtab.</body><body package="COUtilities">crtab: anInteger 	self fileStream crtab: anInteger.</body><body package="COUtilities">space	self fileStream space.</body><body package="COUtilities">tab	self fileStream tab.</body></methods><methods><class-id>COAST.PersistentTextCollector</class-id> <category>update</category><body package="COUtilities">update: anAspect with: aParameter from: anObject	(anObject = ObjectMemory and: [ #(aboutToSnapshot #aboutToQuit) includes: anAspect ])		ifTrue: [ self closeFile ].</body></methods><methods><class-id>COAST.PersistentTextCollector</class-id> <category>private</category><body package="COUtilities">closeFile	fileStream isNil ifTrue: [ ^ self ].	fileStream close.	fileStream := nil.	ObjectMemory removeDependent: self.</body><body package="COUtilities">fileStream	fileStream isNil		ifTrue: [ 			fileStream := ( Filename named: self filename ) appendStream text.			ObjectMemory removeDependent: self; addDependent: self.		].	^ fileStream</body><body package="COUtilities">flushFile	fileStream notNil ifTrue: 		[	fileStream flush.		]</body><body package="COUtilities">resetFileStream	"den fileStream wie in #fileStream oeffnen, da aber das loeschen manchmal (immer?!?) fehlschlagen kann, hier bei null beginnen"	fileStream isNil		ifTrue: [ 			fileStream := ( Filename named: self filename ) writeStream text.			ObjectMemory removeDependent: self; addDependent: self.		].	^ fileStream</body></methods><methods><class-id>COAST.PersistentTextCollector</class-id> <category>accessing</category><body package="COUtilities">filename	filename isNil ifTrue: [filename := 'transcript.log'].	^filename</body><body package="COUtilities">filename: aFilename 	"this is the origin of the file log, any previous entries will be stored to a backup file"	self backupOldLogFile.	filename := aFilename.</body><body package="COUtilities">flush	self flushFile.</body><body package="COUtilities">next: anInteger put: aCharacter 	self fileStream next: anInteger put: aCharacter.</body><body package="COUtilities">nextPut: aCharacter 	self fileStream nextPut: aCharacter.</body><body package="COUtilities">nextPutAll: aCollection 	"beware: aCollection can be a User Message :-\, e.g. Garbage Collection"	[ self fileStream nextPutAll: aCollection asString ] on: UnsupportedCharacterError		do: 		[: ex |			"nicht so schlimm"			self fileStream nextPutAll: ' ... (unsupported Character Error)' 		].	self flushFile</body></methods><methods><class-id>COAST.PersistentTextCollector</class-id> <category>tailing</category><body package="COUtilities">backupOldLogFile	| stream timestamp oldLog |	oldLog := Filename named: self filename.	timestamp := Timestamp now.	stream := String new writeStream.	stream nextPutAll: oldLog tail; nextPut: $-.	timestamp coastLogFilePrintOn: stream.	stream nextPutAll: oldLog extension.	self closeFile.	[ oldLog moveTo: ( oldLog directory construct: stream contents )] 		on: Error		do: 		[: ex |			"dont wine to the transcript here !!!"		].</body><body package="COUtilities">checkFileSize	"mechanism can be disabled by setting a maxLogSize value of 0 or -1"	self maxLogSize &lt; 1 		ifTrue: [ ^ self ].	( fileStream notNil and: [ fileStream position &gt; self maxLogSize ]) 		ifTrue: 		[	self backupOldLogFile.			self resetFileStream.			"write information about our environment at the top of the new logfile"			CoastLog singleton generateLogStartInfo		].</body><body package="COUtilities">maxLogSize"by default, turned of"	^ maxLogSize ifNil: [ -1 ]</body><body package="COUtilities">maxLogSize: aMaxLogSize 	maxLogSize := aMaxLogSize.</body></methods><methods><class-id>COAST.PersistentTextCollector class</class-id> <category>instance creation</category><body package="COUtilities">filename: aFilename	^ self new		filename: aFilename;		yourself</body></methods><methods><class-id>COAST.CatBFRecoverableError</class-id> <category>accessing</category><body package="COBlockFileSystem">recover: aBlockFileSystem	self subclassResponsibility</body></methods><methods><class-id>COAST.CatBFBlockFileTooLargeError</class-id> <category>accessing</category><body package="COBlockFileSystem">recover: aBlockFileSystem	aBlockFileSystem truncateToCorrectSize</body></methods><methods><class-id>UI.CoastNullTextCollector</class-id> <category>accessing</category><body package="COUtilities">next: anInteger put: aCharacter 	"Do nothing."	^self</body><body package="COUtilities">nextPut: aCharacter 	"Do nothing."	^self</body><body package="COUtilities">nextPutAll: aCollection 	"Do nothing."	^self</body></methods><methods><class-id>UI.CoastNullTextCollector</class-id> <category>entry control</category><body package="COUtilities">appendEntry	"Do nothing."	^self</body><body package="COUtilities">endEntry	"Do nothing."	^self</body></methods><methods><class-id>UI.CoastNullTextCollector</class-id> <category>character writing</category><body package="COUtilities">cr	"Do nothing."	^self</body><body package="COUtilities">crtab	"Do nothing."	^self</body><body package="COUtilities">crtab: anInteger 	"Do nothing."	^self</body><body package="COUtilities">space	"Do nothing."	^self</body><body package="COUtilities">tab	"Do nothing."	^self</body></methods><methods><class-id>UI.CoastNullTextCollector</class-id> <category>clearing</category><body package="COUtilities">clear	"Do nothing."	^self</body></methods><methods><class-id>UI.CoastNullTextCollector</class-id> <category>private</category><body package="COUtilities">characterLimit	^100</body></methods><methods><class-id>COAST.FreeMap</class-id> <category>accessing</category><body package="COBlockFileSystem">add: elem 	self addFrom: elem to: elem.	^ elem</body><body package="COBlockFileSystem">addAll: collection 	self rangesIn: collection do: [: start : stop | self addFrom: start to: stop ].</body><body package="COBlockFileSystem">addFrom: start to: stop 	self subclassResponsibility.</body><body package="COBlockFileSystem">do: block 	self subclassResponsibility.</body><body package="COBlockFileSystem">height	self subclassResponsibility.</body><body package="COBlockFileSystem">max	self subclassResponsibility.</body><body package="COBlockFileSystem">min	self subclassResponsibility.</body><body package="COBlockFileSystem">rangesIn: collection do: block 	| start stop |	start := 1.	stop := 0.	collection do: 		[: elem |			stop + 1 = elem 				ifTrue: [ stop := elem ]				ifFalse: 				[	start &lt;= stop ifTrue: [ block value: start value: stop ].					start := stop := elem				]		].	start &lt;= stop ifTrue: [ block value: start value: stop ].</body><body package="COBlockFileSystem">remove: elem 	^ self removeFrom: elem to: elem</body><body package="COBlockFileSystem">removeAll: collection 	self rangesIn: collection do: [: start : stop | self removeFrom: start to: stop ].</body><body package="COBlockFileSystem">removeFrom: start to: stop 	^ self subclassResponsibility</body><body package="COBlockFileSystem">root	self subclassResponsibility.</body></methods><methods><class-id>COAST.FreeMap</class-id> <category>testing</category><body package="COBlockFileSystem">canMergeWithLeft: leftLeaf 	^ false</body><body package="COBlockFileSystem">canMergeWithRight: rightNode 	^ false</body><body package="COBlockFileSystem">covers: aRange 	self subclassResponsibility.</body><body package="COBlockFileSystem">isBalanced	self subclassResponsibility.</body><body package="COBlockFileSystem">isEmpty	self subclassResponsibility.</body><body package="COBlockFileSystem">isSorted	self subclassResponsibility.</body></methods><methods><class-id>COAST.FreeMap</class-id> <category>private</category><body package="COBlockFileSystem">newLeafFrom: start to: stop 	^ FreeMapLeaf root: self root from: start to: stop</body><body package="COBlockFileSystem">ownValidateIsBalanced</body><body package="COBlockFileSystem">ownValidateIsSorted</body><body package="COBlockFileSystem">validate	self ownValidateIsBalanced.	self ownValidateIsSorted.</body></methods><methods><class-id>COAST.FreeMapNonRoot</class-id> <category>accessing</category><body package="COBlockFileSystem">max	^ max</body><body package="COBlockFileSystem">min	^ min</body><body package="COBlockFileSystem">root	^ root</body><body package="COBlockFileSystem">root: aRoot 	root := aRoot.</body></methods><methods><class-id>COAST.FreeMapNonRoot</class-id> <category>testing</category><body package="COBlockFileSystem">isEmpty	^ min &gt; max</body></methods><methods><class-id>COAST.FreeMapNonRoot class</class-id> <category>instance creation</category><body package="COBlockFileSystem">root: root 	^ ( self new )		root: root;		yourself</body></methods><methods><class-id>COAST.FreeMapLeaf</class-id> <category>accessing</category><body package="COBlockFileSystem">addFrom: start to: stop 	| newLeft newRight |	( start &lt; min and: [ stop &gt; max ]) 		ifTrue: 		[	" overlapping "			self deregister.			min := start.			max := stop.			self register		]		ifFalse: 		[	start &lt; min 				ifTrue: 				[( stop + 1 &gt;= min and: [ stop &lt;= max ]) 						ifTrue: 						[	" expand left "							self deregister.							min := start.							self register						]						ifFalse: 						[	"add left"							newLeft := self newLeafFrom: start to: stop						]				].			stop &gt; max 				ifTrue: 				[( start &gt;= min and: [ start &lt;= ( max + 1 )]) 						ifTrue: 						[	" expand right "							self deregister.							max := stop.							self register						]						ifFalse: 						[	"add right"							newRight := self newLeafFrom: start to: stop						]				]		].	^ ( newLeft notNil or: [ newRight notNil ]) 		ifTrue: [ self newNodeLeft: ( newLeft ifNil: [ self ]) right: ( newRight ifNil: [ self ])]		ifFalse: [ self ]</body><body package="COBlockFileSystem">asOrderedCollection	^ OrderedCollection withAll: self</body><body package="COBlockFileSystem">covers: aRange 	^ min &lt;= aRange min and: [ max &gt;= aRange max ]</body><body package="COBlockFileSystem">do: block 	min to: max do: [: i | block value: i ].</body><body package="COBlockFileSystem">height	^ 0</body><body package="COBlockFileSystem">leftMostRange	^ self</body><body package="COBlockFileSystem">newFrom: start to: stop 	min := start.	max := stop.</body><body package="COBlockFileSystem">nextLeafOfSameSize	^ nextLeafOfSameSize</body><body package="COBlockFileSystem">nextLeafOfSameSize: aNextLeafOfSameSize 	nextLeafOfSameSize := aNextLeafOfSameSize.</body><body package="COBlockFileSystem">prevLeafOfSameSize	^ prevLeafOfSameSize</body><body package="COBlockFileSystem">prevLeafOfSameSize: aPrevLeafOfSameSize 	prevLeafOfSameSize := aPrevLeafOfSameSize.</body><body package="COBlockFileSystem">removeFrom: start to: stop 	| leftStop rightStart oldMax |	self deregister.	leftStop := start - 1.	rightStart := stop + 1.	( leftStop &lt; min and: [ rightStart &gt; max ]) ifTrue: [ ^ nil ].	leftStop &lt; min ifTrue: 		[	"i become the right one"			min := rightStart.			self register.			^ self		].	rightStart &gt; max ifTrue: 		[	"i become the left one"			max := leftStop.			self register.			^ self		].	oldMax := max.	max := leftStop.	self register.	^ self newNodeLeft: self right: ( self newLeafFrom: rightStart to: oldMax )</body><body package="COBlockFileSystem">size	^ max - min + 1</body></methods><methods><class-id>COAST.FreeMapLeaf</class-id> <category>testing</category><body package="COBlockFileSystem">canMergeWithLeft: leftLeaf 	^ leftLeaf max + 1 = self min</body><body package="COBlockFileSystem">canMergeWithRight: rightNode 	^ rightNode canMergeWithLeft: self</body><body package="COBlockFileSystem">isBalanced	^ true</body><body package="COBlockFileSystem">isSorted	^ min &lt;= max</body></methods><methods><class-id>COAST.FreeMapLeaf</class-id> <category>private</category><body package="COBlockFileSystem">deregister	root deregisterLeaf: self.</body><body package="COBlockFileSystem">newNodeLeft: leftNode right: rightNode 	^ ( FreeMapNode root: self root )		left: leftNode;		right: rightNode;		yourself</body><body package="COBlockFileSystem">register	root registerLeaf: self.</body></methods><methods><class-id>COAST.FreeMapLeaf</class-id> <category>printing</category><body package="COBlockFileSystem">printOn: stream 	stream nextPutAll: '('.	min printOn: stream.	stream nextPutAll: ' .. '.	max printOn: stream.	stream nextPutAll: ')'.</body></methods><methods><class-id>COAST.FreeMapLeaf</class-id> <category>comparing</category><body package="COBlockFileSystem">= anotherLeaf	^ self class == anotherLeaf class		and: [ self min = anotherLeaf min		and: [ self max = anotherLeaf max ]]</body><body package="COBlockFileSystem">hash	^ self min hash</body></methods><methods><class-id>COAST.FreeMapLeaf</class-id> <category>As yet unclassified</category><body package="COBlockFileSystem">leavesOfSameSizeDo: aBlock expectedListSize: expectedListSize	| iteratedLeaf i |	i := 0.	iteratedLeaf := self.	[		aBlock value: iteratedLeaf.		iteratedLeaf := iteratedLeaf nextLeafOfSameSize .		iteratedLeaf == self ifTrue: [ self error: 'Free list cycle detected' ].		i := i + 1.		i &gt; expectedListSize ifTrue: [ self error: 'Free list size exceeded' ].		iteratedLeaf notNil	] whileTrue.</body></methods><methods><class-id>COAST.FreeMapLeaf class</class-id> <category>instance creation</category><body package="COBlockFileSystem">root: root from: start to: stop 	^ ( self root: root )		newFrom: start to: stop;		register;		yourself</body></methods><methods><class-id>COAST.CoastLogNotifier</class-id> <category>initialize-release</category><body package="COUtilities">initialize</body></methods><methods><class-id>COAST.CoastLogNotifier</class-id> <category>config</category><body package="COUtilities">initializeFromIni: iniAccess	self logLevel: (iniAccess category: self name asString numberAt: 'level').</body><body package="COUtilities">logLevel	logLevel isNil ifTrue: [ logLevel := LogLevelError ].	^ logLevel</body><body package="COUtilities">logLevel: anInteger	logLevel := anInteger</body><body package="COUtilities">name	^ name ifNil: [ 'unknown' ].</body><body package="COUtilities">name: aStringOrSymbol	name := aStringOrSymbol asSymbol</body></methods><methods><class-id>COAST.CoastLogNotifier</class-id> <category>accessing</category><body package="COUtilities">notify: aString level: anInteger for: aLog	" override this method "</body></methods><methods><class-id>COAST.CoastLogNotifier</class-id> <category>printing</category><body package="COUtilities">infoStringOn: stream indent: int 	| indent |	int timesRepeat: [ stream tab ].	stream nextPutAll: self class fullName; nextPutAll: ': '; cr.	indent := int + 1.	self logLevel ifNotNil: [ : level |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'logLevel: '.		level printOn: stream.		stream cr		].	self name ifNotNil: [ : n |		indent timesRepeat: [ stream tab ].		stream nextPutAll: 'name: '; nextPutAll: n printString; cr		].</body></methods><methods><class-id>COAST.CoastLogNotifier</class-id> <category>action</category><body package="COUtilities">additionalActionFor: aCoastLog	"do nothing"</body></methods><methods><class-id>COAST.CoastLogNotifier</class-id> <category>testing</category><body package="COUtilities">isUsable	" true: Notifer is properly configured and usable "	^ true</body></methods><methods><class-id>COAST.CoastLogNotifier class</class-id> <category>instance creation</category><body package="COUtilities">named: aString fromIni: iniAccess 	| className |	className := iniAccess category: aString stringAt: 'class'.	^ className asQualifiedReference 		ifDefinedDo: 		[: cl | | notifier |			notifier := cl new.			notifier name: aString.			notifier initializeFromIni: iniAccess.			notifier isUsable 				ifTrue: [ notifier ]				ifFalse: 				[	CoastLog logWarning: 'Skipped unusable notifier: ' , className printString.					nil				]		]		elseDo: 		[	className notNil ifTrue: [ CoastLog logWarning: 'Unknown notifier class: ' , className printString ].			nil		]</body><body package="COUtilities">new	^ super new initialize</body></methods><methods><class-id>COAST.CatBFCorruptSegmentFileError</class-id> <category>accessing</category><body package="COBlockFileSystem">recover: aBlockFileSystem	aBlockFileSystem rebuildAllIndexFiles</body></methods><methods><class-id>COAST.CoastTestAndSet</class-id> <category>initialize-release</category><body package="COUtilities">initialize	recursionLock := RecursionLock new.	dictionary := Dictionary new.</body><body package="COUtilities">testAndSet: key oldValue: oldValue newValue: newValue 	"only set newValue at key if oldValue is the current value at key"	"return the value at key - sender must check if the value has been set correctly"	^ recursionLock critical: 		[ | found |			found := dictionary at: key ifAbsent: nil.			found = oldValue 				ifTrue: 				[	newValue notNil 						ifTrue: [ oldValue = newValue ifFalse: [ dictionary at: key put: newValue ]	"store newValue if different" ]						ifFalse: [ oldValue notNil ifTrue: [ dictionary removeKey: key ]	"newValue = nil means remove key" ].					newValue				]				ifFalse: [ found	"found different -&gt; report" ]		]</body></methods><methods><class-id>COAST.CoastTestAndSet class</class-id> <category>instance creation</category><body package="COUtilities">new	^ super new		initialize;		yourself</body></methods><methods><class-id>COAST.FreeMapNode</class-id> <category>private</category><body package="COBlockFileSystem">ownValidateIsBalanced	( left height - right height ) abs &lt; 2 		ifFalse: [ self error: 'not balanced' ].</body><body package="COBlockFileSystem">ownValidateIsSorted	left max &lt; right min 		ifFalse: [ self error: 'not sorted' ].</body><body package="COBlockFileSystem">postAdd	| move node |	left max + 1 = self right min ifFalse: [ ^ self postMod ].	^ ( left canMergeWithRight: right ) 		ifTrue: 		[	"trivial: two leaves"			left deregister.			right deregister.			self newLeafFrom: left min to: right max		]		ifFalse: 		[	move := right leftMostRange.			self left: ( left addFrom: move min to: move max ).			node := right removeFrom: move min to: move max.			node notNil 				ifTrue: 				[	self right: node.					self postMod				]				ifFalse: [ left ]		]</body><body package="COBlockFileSystem">postAddAll	| oldLeft result | 	[	oldLeft := left.		result := self postAdd.		result == self and: [ oldLeft ~= left ]	] whileTrue: 		[	oldLeft = right 				ifTrue: [ right postAddAll ]				ifFalse: [ left postAddAll ]		].	^ result</body><body package="COBlockFileSystem">postMod	| diff |	diff := left height - right height.	diff abs &gt; 1 ifTrue: 		[	diff &gt; 0 				ifTrue: [ self turnRight ]				ifFalse: [ self turnLeft ]		].	^ self</body><body package="COBlockFileSystem">validate	super validate.	left validate.	right validate.</body></methods><methods><class-id>COAST.FreeMapNode</class-id> <category>accessing</category><body package="COBlockFileSystem">addFrom: start to: stop 	start &lt;= (left max + 1)		ifTrue: [ self left: ( left addFrom: start to: (stop min: right min - 1))].	stop &gt; left max		ifTrue: [ self right: ( right addFrom: (start max: left max + 1) to: stop )].	^ self postAdd</body><body package="COBlockFileSystem">covers: aRange 	^ left max &gt;= aRange min 		ifTrue: [ left covers: aRange ]		ifFalse: [ right covers: aRange ]</body><body package="COBlockFileSystem">do: block 	left do: block.	right do: block.</body><body package="COBlockFileSystem">height	height isNil ifTrue: [ height := ( left height max: right height ) + 1 ].	^ height</body><body package="COBlockFileSystem">left	^ left</body><body package="COBlockFileSystem">left: node 	( height notNil and: [ height ~~ ( node height + 1 )]) ifTrue: [ height := nil ].	left := node.	min := node min.</body><body package="COBlockFileSystem">leftMostRange	^ left leftMostRange</body><body package="COBlockFileSystem">removeFrom: start to: stop 	| node |	left max &gt;= start 		ifTrue: 		[	node := left removeFrom: start to: stop.			node isNil 				ifTrue: [ ^ right ]				ifFalse: [ self left: node ]		]		ifFalse: 		[	node := right removeFrom: start to: stop.			node isNil 				ifTrue: [ ^ left ]				ifFalse: [ self right: node ]		].	^ self postMod</body><body package="COBlockFileSystem">right	^ right</body><body package="COBlockFileSystem">right: node 	( height notNil and: [ height ~~ ( node height + 1 )]) ifTrue: [ height := nil ].	right := node.	max := right max.</body></methods><methods><class-id>COAST.FreeMapNode</class-id> <category>balancing</category><body package="COBlockFileSystem">basicTurnLeft	" ( L ( ( RL RR))) ==&gt; ( (L RL) RR  )"	| rl rr |	rl := right left.	rr := right right.	right left: left.	right right: rl.	self left: right.	self right: rr.</body><body package="COBlockFileSystem">basicTurnRight	" ( (LL LR ) ( R ) ) ==&gt; ( ( LL ) ( LR R ))"	| ll lr |	ll := left left.	lr := left right.	left left: lr.	left right: right.	self right: left.	self left: ll.</body><body package="COBlockFileSystem">turnLeft	" ( L ( ( RL RR))) ==&gt; ( (L RL) RR  )"	" ( L ( ( RL ( RRL RRR )))) ==&gt; (( L RL ) ( RRL RRR )  )"	right left height &gt; right right height ifTrue: [ right basicTurnRight ].	self basicTurnLeft.</body><body package="COBlockFileSystem">turnRight	" ( (LL LR ) ( R ) ) ==&gt; ( ( LL ) ( LR R ))"	" ( (LL ( LRL LRR ) ) ( R ) ) ==&gt; ( ( LL LRL ) ( LRR R ))"	left right height &gt; left left height ifTrue: [ left basicTurnLeft ].	self basicTurnRight.</body></methods><methods><class-id>COAST.FreeMapNode</class-id> <category>printing</category><body package="COBlockFileSystem">printOn: stream 	left printOn: stream.	right printOn: stream.</body></methods><methods><class-id>COAST.FreeMapNode</class-id> <category>testing</category><body package="COBlockFileSystem">isBalanced	^ ( left height - right height ) abs &lt; 2 and: [ left isBalanced and: [ right isBalanced ]]</body><body package="COBlockFileSystem">isSorted	^ left max &lt; right min and: [ left isSorted and: [ right isSorted ]]</body></methods><methods><class-id>COAST.Version</class-id> <category>accessing</category><body package="COBase">major	^ major</body><body package="COBase">major: anInteger 		( anInteger &lt; 0 or: [ anInteger &gt; 255 ]) 		ifTrue: [ self error: 'Illegal major version' ].	major := anInteger.</body><body package="COBase">minor	^ minor</body><body package="COBase">minor: anInteger 	( anInteger &lt; 0 or: [ anInteger &gt; 255 ]) 		ifTrue: [ self error: 'Illegal minor version' ].	minor := anInteger.</body></methods><methods><class-id>COAST.Version</class-id> <category>printing</category><body package="COBase">printOn: stream 	self major printOn: stream.	stream nextPut: $..	self minor printOn: stream</body></methods><methods><class-id>COAST.Version</class-id> <category>comparing</category><body package="COBase">&lt; aCoastVersion	| compare1 compare2 n s1 s2 |	compare1 := self comparisonArray.	compare2 := aCoastVersion comparisonArray.	n := (s1 := compare1 size) min: (s2 := compare2 size).	1 to: n		do: 		[: i | | a b |			a := compare1 at: i.			b := compare2 at: i.			a = b ifFalse: 				[	(a isNil and: [ b notNil ]) ifTrue: [ ^ true ].					(a notNil and: [ b isNil ]) ifTrue: [ ^ false ].					a &lt; b ifTrue: [ ^ true ].					a &gt; b ifTrue: [ ^ false ] 				] 		].	^ s1 &lt; s2</body><body package="COBase">= aVersion 	"Answer whether the receiver is equal to the argument."	^ ( aVersion  isKindOf: Version ) and: [ self comparisonArray = aVersion  comparisonArray ]</body><body package="COBase">hash	" There is no need to define more sophisticated hash values "	^ self major hash</body><body package="COBase">isMax: ma minor: mi	^ major &lt; ma or: [ major = ma and: [ minor &lt;= mi ]]</body><body package="COBase">isMin: ma minor: mi	major &gt; ma ifTrue: [ ^true ].	^major = ma		ifTrue: [ minor &gt;= mi ]		ifFalse: [ false ]</body></methods><methods><class-id>COAST.Version</class-id> <category>private</category><body package="COBase">comparisonArray	" Returns an array which defines the equality / ordering of versions "	^ Array with: self major with: self minor</body></methods><methods><class-id>COAST.Version class</class-id> <category>instance creation</category><body package="COBase">major: majorByte minor: minorByte	^ self new		major: majorByte;		minor: minorByte;		yourself.</body></methods><methods><class-id>COAST.CatRMRemoteCellAccess</class-id> <category>accessing</category><body package="COTransactions">frameID	^ frameID</body><body package="COTransactions">frameID: anInteger	frameID := anInteger</body><body package="COTransactions">referencesRemovedFrame: removedFrameID 	^ frameID = removedFrameID frameID</body></methods><methods><class-id>COAST.CatRMRemoteCellAccess</class-id> <category>printing</category><body package="COTransactions">ccPrintStringOn: aStream withClusterID: clusterID	"todo: beautify (no class names, create nice frame reference IDX_Y, etc.)"	self printOn: aStream</body><body package="COTransactions">printString	^ [ super printString ] on: Error		do: 		[: ex | | stream |			stream := String new writeStream.			stream nextPutAll: 'Error while printing '.			self basicPrintOn: stream.			stream contents		]</body></methods><methods><class-id>COAST.CatRMRemoteCellAccess</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: self frameID.</body><body package="COTransactions">unmarshallBinary50From: aStream marshaller: aCatRMMarshall 	self frameID: aStream nextOptimized32.</body><body package="COTransactions">unmarshallBinary52From: aStream marshaller: aCatRMMarshall 	self frameID: aStream nextOptimized32.</body><body package="COTransactions">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	( aCatRMMarshall loadCoastVersion isMin: 5 minor: 2 ) 		ifTrue: [ self unmarshallBinary52From: aStream marshaller: aCatRMMarshall ]		ifFalse: [ self unmarshallBinary50From: aStream marshaller: aCatRMMarshall ].</body></methods><methods><class-id>COAST.CatRMRemoteCellAccess class</class-id> <category>instance creation</category><body package="COTransactions">frameID: frameID 	^ ( self new )		frameID: frameID;		yourself</body><body package="COTransactions">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	^ ( self new )		unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall;		yourself</body></methods><methods><class-id>COAST.CatRMAbstractSlotAccess</class-id> <category>accessing</category><body package="COTransactions">frame: frame 	self frameID: frame id.	self frameClassSymbol: frame frameClassSymbol.</body><body package="COTransactions">frameClassSymbol	^ frameClassSymbol</body><body package="COTransactions">frameClassSymbol: aFrameClassSymbol 	frameClassSymbol := aFrameClassSymbol.</body><body package="COTransactions">slot: slot 	self slotName: slot name.	self valueHolderIndex: slot valueHolder index.</body><body package="COTransactions">slotName	^ slotName</body><body package="COTransactions">slotName: aStringOrSymbol 	slotName := aStringOrSymbol.</body><body package="COTransactions">valueHolderIndex	^ valueHolderIndex</body><body package="COTransactions">valueHolderIndex: aValueHolderIndex	valueHolderIndex := aValueHolderIndex</body></methods><methods><class-id>COAST.CatRMAbstractSlotAccess</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	| frameSlotIndex |	super marshallBinaryTo: aStream marshaller: aCatRMMarshall.	aCatRMMarshall writeFrameClassSymbol: self frameClassSymbol to: aStream.	frameSlotIndex := aCatRMMarshall frameSlotIndexForSymbol: self frameClassSymbol.	aCatRMMarshall writeSlotName: self slotName asSymbol frameSlotIndex: frameSlotIndex to: aStream.</body><body package="COTransactions">unmarshallBinary52From: aStream marshaller: aCatRMMarshall 	| frameSlotIndex |	super unmarshallBinary52From: aStream marshaller: aCatRMMarshall.	self frameClassSymbol: ( aCatRMMarshall readFrameClassSymbolFrom: aStream ).	frameSlotIndex := aCatRMMarshall frameSlotIndexForSymbol: self frameClassSymbol.	self slotName: ( aCatRMMarshall readSlotNameFrom: aStream withIndex: frameSlotIndex ).</body></methods><methods><class-id>COAST.CatRMAbstractSlotAccess class</class-id> <category>instance creation</category><body package="COTransactions">slot: slot frame: frame 	^ self new		slot: slot;		frame: frame;		yourself</body></methods><methods><class-id>COAST.CatRMSlotAccess</class-id> <category>comparing</category><body package="COTransactions">= anotherAccess	" assume both accesses touch the same cluster. 	do not compare slot acceses of different agendas "	^anotherAccess class = self class		and: [ frameID = anotherAccess frameID		and: [ slotName = anotherAccess slotName ]]</body><body package="COTransactions">hash	^ frameID bitXor: slotName size</body></methods><methods><class-id>COAST.CatRMSlotAccess</class-id> <category>accessing</category><body package="COTransactions">accessClass	^ accessClass</body><body package="COTransactions">accessClassID	^ accessClassID</body><body package="COTransactions">accessClassID: aByte	accessClassID := aByte.	accessClass := CatCSCellAccess accessClassWithID: aByte.</body><body package="COTransactions">arguments	^ arguments</body><body package="COTransactions">arguments: anArray	arguments := anArray</body><body package="COTransactions">createCellAccessWith: argumentTranslationBlock 	| n |	( n := self arguments size ) = 1 		ifTrue: [ 			^ accessClass argument: ( argumentTranslationBlock value: ( arguments at: 1 ))		].	n = 2 		ifTrue: [				^ accessClass 				argument1: ( argumentTranslationBlock value: ( arguments at: 1 ))				argument2: ( argumentTranslationBlock value: ( arguments at: 2 ))		].	n = 0		ifTrue: [ 			^ accessClass new		].	self error: 'Unsupported number of arguments: ' , arguments size printString</body><body package="COTransactions">referencesRemovedFrame: removedFrameID 	^ ( super referencesRemovedFrame: removedFrameID ) or: [ arguments includes: removedFrameID ]</body><body package="COTransactions">valueHolderClass	^ CatCSCellValueHolder valueHolderClassWithID: valueHolderIndex</body></methods><methods><class-id>COAST.CatRMSlotAccess</class-id> <category>concurrency control</category><body package="COTransactions">isCommutativeTo: aCatRMSlotAccess	"True if both accesses are commutative "	^ self accessClass		withArguments: self arguments		isCommutative: aCatRMSlotAccess accessClass		arguments: aCatRMSlotAccess arguments</body></methods><methods><class-id>COAST.CatRMSlotAccess</class-id> <category>printing</category><body package="COTransactions">ccPrintStringOn: stream withClusterID: clusterID	stream nextPutAll: 'SlotAccess ('.	frameClassSymbol notNil ifTrue: [ stream nextPutAll: frameClassSymbol asString. stream nextPutAll: '&lt;'. ].	stream nextPutAll: 'ID'.	clusterID printOn: stream.	stream nextPutAll: '_'.	frameID printOn: stream.	frameClassSymbol notNil ifTrue: [ stream nextPutAll: '&gt;'. ].	stream nextPutAll: ' '.	slotName printOn: stream.	stream nextPutAll: ' '.	stream nextPutAll: accessClass name asString.	stream nextPutAll: ':'.	arguments ccPrintStringOn: stream withClusterID: clusterID.	stream nextPutAll: ')'</body><body package="COTransactions">printOn: stream 	super printOn: stream.	stream nextPutAll: ' [frame '.	frameID printOn: stream.	stream nextPutAll: ' slot '.	slotName printOn: stream.	stream nextPutAll: ' access '.	accessClass printOn: stream.	stream nextPutAll: ' args '.	arguments printOn: stream.	stream nextPutAll: ']'</body></methods><methods><class-id>COAST.CatRMSlotAccess</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	super marshallBinaryTo: aStream marshaller: aCatRMMarshall.	aStream nextPut: self accessClassID.	aStream nextPut: self valueHolderIndex.	" Marshall all arguments "	aStream nextPut: arguments size.	arguments do: [: argument | argument marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall ].</body><body package="COTransactions">unmarshallBinary50From: aStream marshaller: aCatRMMarshall 	| size |	self slotName: aStream nextShortString.	self accessClassID: aStream next.	self valueHolderIndex: aStream next.	" Unmarshall all arguments "	size := aStream next.	arguments := Array new: size.	1 to: size		do: 		[: i | | arg |			arg := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.			arguments at: i put: arg		].	super unmarshallBinary50From: aStream marshaller: aCatRMMarshall.</body><body package="COTransactions">unmarshallBinary52From: aStream marshaller: aCatRMMarshall 	| size |	super unmarshallBinary52From: aStream marshaller: aCatRMMarshall.	self accessClassID: aStream next.	self valueHolderIndex: aStream next.	" Unmarshall all arguments "	size := aStream next.	arguments := Array new: size.	1 to: size		do: 		[: i | | arg |			arg := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.			arguments at: i put: arg		].</body></methods><methods><class-id>COAST.CatRMSlotAccess class</class-id> <category>instance creation</category><body package="COTransactions">slot: slot frame: frame accessClassID: accessClassID arguments: arguments 	^ ( self slot: slot frame: frame)		accessClassID: accessClassID;		arguments: arguments;		yourself</body></methods><methods><class-id>COAST.CommandLineParameter</class-id> <category>testing</category><body package="COBase">matches: aCommandLineParameterString	^ self parameter match: aCommandLineParameterString</body></methods><methods><class-id>COAST.CommandLineParameter</class-id> <category>accessing</category><body package="COBase">parameter	^ parameter</body><body package="COBase">parameter: aParameter 	parameter := aParameter.</body><body package="COBase">receiver	^ receiver</body><body package="COBase">receiver: aReceiver 	receiver := aReceiver.</body><body package="COBase">selector	^ selector</body><body package="COBase">selector: aSelector 	selector := aSelector.</body></methods><methods><class-id>COAST.CommandLineParameter</class-id> <category>printing</category><body package="COBase">printOn: aStream	aStream nextPutAll: self parameter.	aStream nextPutAll: ' ('.	aStream nextPutAll: self receiver class fullName.	aStream nextPutAll: '&gt;&gt;'.	aStream nextPutAll: self selector.	aStream nextPutAll: ')'.</body></methods><methods><class-id>COAST.CommandLineParameter</class-id> <category>evaluating</category><body package="COBase">parseFromStream: aParameterStream 	self receiver perform: self selector with: aParameterStream.</body></methods><methods><class-id>COAST.CommandLineParameter class</class-id> <category>accessing</category><body package="COBase">commandLineParametersOf: aReceiver 	" Create a parameter for each parameter pragma "	| result |	result := OrderedCollection new.	aReceiver commandlinePragmas do: [ : pragma |		result add: (self parameter: (pragma argumentAt: 1) printString receiver: aReceiver selector: pragma selector).		(pragma argumentAt: 3) ifNotNil: [ : aliases |			aliases do: [ : alias |				result add: (self parameter:  alias printString receiver: aReceiver selector: pragma selector).				].			].		].	^ result</body><body package="COBase">helpTextFor: pragmas	| options stream helpText |	options := Set new: pragmas size. "filter for duplicate options"	stream := String new writeStream.	(pragmas sortedBy: [ : p | p argumentAt: 1 ]) do: [ : pragma | | option aliases |		option := pragma argumentAt: 1.		aliases := (pragma argumentAt: 3) ifNil: [ #() ].		aliases := aliases reject: [ : alias | options includes: alias ].		(options includes: option) ifTrue: [			option := aliases detect: [ : alias | (options includes: alias) not ] ifNone: nil.			option notNil ifTrue: [ aliases := aliases copy remove: option. ].			].		option notNil ifTrue: [			options add: option.			stream				nextPut: $-;				nextPutAll: (pragma argumentAt: 4); cr.			((helpText := pragma argumentAt: 5) notNil and: [ helpText notEmpty ]) ifTrue: [				stream					nextPutAll: ' ';					nextPutAll: helpText; cr.				].			aliases isEmpty ifFalse: [				stream nextPutAll: ' aliases: '.				aliases	do: [ : alias | 								stream nextPut: $-; nextPutAll: alias.								options add: alias.								]						separatedBy: [ stream nextPutAll: ', ' ].				stream cr.				].			].		].	^ stream contents</body><body package="COBase">parseCommandLine: commandLine parameters: commandLineParameters 	" Parse the defined parameters from the command line. "	| paramStream knownSubsystemParameters |	paramStream := COAST.CommandLineReadStream on: commandLine.	knownSubsystemParameters := self knownSubsystemParameters.	[ paramStream atEnd ] whileFalse: 		[ | param matchingParameter |			param := paramStream next.			( param notNil and: [ param size &gt; 1 and: [ '/-' includes: param first ]]) 				ifTrue: 				[	matchingParameter := commandLineParameters detect: [: commandLineParameter | commandLineParameter matches: param ] ifNone: [ nil ].					matchingParameter notNil 						ifTrue: 						[								[ matchingParameter parseFromStream: paramStream ] 								on: Error								do: 								[: ex |									ex isCoastError 										ifTrue: [ ex pass ]										ifFalse: 										[	ex 												resignalAs: ( COAST.CoastError new messageText: 'command line error in ' , matchingParameter selector printString , ' : ' , ex description )										]								]						]						ifFalse: 						[( knownSubsystemParameters includes: param ) 								ifFalse: [ COAST.UnknownCommandLineArgument signalWith: param ]						]				]		].</body><body package="COBase">parseCommandLineParameters: commandLineParameters 	 " Parse the defined parameters from the command line. "	self parseCommandLine: CEnvironment commandLine parameters: commandLineParameters</body></methods><methods><class-id>COAST.CommandLineParameter class</class-id> <category>instance creation</category><body package="COBase">parameter: aParameter receiver: aReceiver selector: aSelector 	^ self new		parameter: aParameter;		receiver: aReceiver;		selector: aSelector;		yourself</body></methods><methods><class-id>COAST.CommandLineParameter class</class-id> <category>private</category><body package="COBase">knownSubsystemParameters	"  parameters defined by an #option: pragma "	| known |	known := Set new.	Subsystem withAllSubclasses do: [ : subsystemClass |		(Pragma allNamed: #option: in: subsystemClass) do: [ : pragma |			known add: (pragma argumentAt: 1)		].	].	^ known</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>state blocks</category><body package="COTransactions">addCommitBlock: aBlock 	self commitBlocks add: aBlock</body><body package="COTransactions">addEndBlock: aBlock 	self endBlocks add: aBlock</body><body package="COTransactions">addFailureBlock: aBlock 	self failureBlocks add: aBlock</body><body package="COTransactions">addFinalEndBlock: aBlock 	self endBlocks add: (CoastFinalEndBlock block: aBlock)</body><body package="COTransactions">addPostViewUpdateBlock: aBlock 	postViewUpdateBlocks isNil 		ifTrue: [ postViewUpdateBlocks := OrderedCollection new ].	postViewUpdateBlocks add: aBlock</body><body package="COTransactions">commitBlocks	commitBlocks isNil ifTrue: [commitBlocks := OrderedCollection new].	^commitBlocks</body><body package="COTransactions">endBlocks	endBlocks isNil ifTrue: [endBlocks := OrderedCollection new].	^endBlocks</body><body package="COTransactions">evaluateCommitBlocks	commitBlocks notNil ifTrue:		[ commitBlocks			do: [ : eachBlock | eachBlock value] ].</body><body package="COTransactions">evaluateFailureBlocks	[ failureBlocks isEmpty ] whileFalse: 		[ | eachFailureBlock |			eachFailureBlock := failureBlocks removeLast.			[	eachFailureBlock numArgs = 1 					ifTrue: [ eachFailureBlock value: failureReason ]					ifFalse: [ eachFailureBlock value ]			] ifCurtailed: [ self evaluateFailureBlocks ]		].</body><body package="COTransactions">evaluatePostViewUpdateBlocks	| blocks |	(blocks := postViewUpdateBlocks) notNil		ifTrue: [			postViewUpdateBlocks := nil.			" separate view update from the transaction by forking a new process "			[				[					self transactionManager volumeManager exclusiveUseDo: [						blocks do: [ : aBlock | aBlock value ].					].					WindowManager managerRegistry do: [ : wm | wm notNil ifTrue: [ wm checkForEvents ]].				] on: Error do: [ : ex |					CoastLog logException: ex message: 'Error whille evaluating postViewUpdateBlocks'				].			] forkAt: (Processor activeProcess priority + 1 min: Processor lowIOPriority - 1)		].</body><body package="COTransactions">failureBlocks	^failureBlocks</body><body package="COTransactions">postViewUpdateBlocks	^ postViewUpdateBlocks ifNil: [ #() ]</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>testing</category><body package="COTransactions">agendaNotEmpty	^combinedAgenda isEmpty not</body><body package="COTransactions">canUnloadClusters	" true if clusters can be unloaded during the transaction "	^ false</body><body package="COTransactions">canWrite	^ true</body><body package="COTransactions">fastReadWhile: aBlock 	| oldFastRead |	oldFastRead := isFastRead.	self isFastRead: true.	^ aBlock ensure: [ isFastRead := oldFastRead ]</body><body package="COTransactions">fastWithoutDependenciesDo: aBlock 	^ self isFastRead 		ifTrue: [ self withoutDependenciesDo: aBlock ]		ifFalse: 		[ | oldFastRead |			oldFastRead := isFastRead.			self isFastRead: true.			self beginComposing: nil.			aBlock ensure: 				[	self endComposing: nil.					isFastRead := oldFastRead				]		]</body><body package="COTransactions">invalidationSuppressed	^invalidationSuppressed == true</body><body package="COTransactions">isDisplayTransaction	^false</body><body package="COTransactions">isFastRead	^ inDisplayPhase not and: [( isFastRead ifNil: [ false ]) and: [ self currentlyComposedCell isNil ]]</body><body package="COTransactions">isFastRead: boolean	^isFastRead := boolean</body><body package="COTransactions">isTransient	^false</body><body package="COTransactions">isUpdateTransaction	^false</body><body package="COTransactions">mayDisplay	"answer true if this transaction can be used for displaying"	^self inDisplayPhase</body><body package="COTransactions">pessimistic	"spanning multiple clusters makes me pessimistic"	"congestion makes me sad and pessimistic (side effect: 	I have more time to think about listening for updates ;-)"	^ failureBlocks size &gt; 0 or: 		[ 	(transactionManager transactionMustBePessimistic: self)				or: [  combinedAgenda transactionMustBePessimistic  ] 		 ]</body><body package="COTransactions">referencesClusterWithID: clusterID	^ combinedAgenda referencesClusterWithID: clusterID</body><body package="COTransactions">suppressInvalidationWhile: aBlock	| oldSupressed |	oldSupressed := invalidationSuppressed.	invalidationSuppressed := true.	^ aBlock ensure: [ invalidationSuppressed := oldSupressed ].</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>accessing</category><body package="COTransactions">addAgendaFlag: flag forCluster: cluster 	( self transactionContextAt: #coastAgendaFlags ifAbsentPut: [ MultiValueDictionary new ]) atKey: cluster clusterID add: flag.</body><body package="COTransactions">allowRPCWriteAccessesWhile: aBlock 	" Mediator only "	^ aBlock value</body><body package="COTransactions">checkedOwnerProcess	( ownerProcess notNil and: [ ownerProcess isTerminated ]) 		ifTrue: 		[	" da kommt nichts mehr... "			ownerProcess := nil		].	^ ownerProcess</body><body package="COTransactions">cluster	"this is part of a hack using the container of a cell to store the active transaction	instead of a real cluster..... so someone assumes I know the cluster, which I do not"	^nil</body><body package="COTransactions">clusterID	"sometimes frames ask their container for clusterID - I am no cluster"	^nil</body><body package="COTransactions">combinedAgenda	^combinedAgenda</body><body package="COTransactions">composedCells	^ composedCells at: Processor activeProcess ifAbsentPut: [ OrderedCollection new ]</body><body package="COTransactions">composedCells: aCollection 	composedCells at: Processor activeProcess put: aCollection</body><body package="COTransactions">continueTransaction: aCatCSTransaction 	"obviously not needed: rolledBack inDisplayPhase inInvalidationPhase ownerProcess transactionManager isFastRead invalidationSuppressed"	"to be checked: composedCells outstandingCompositions compositionFinishBlocks endDemons postDemons oldValuesDict delayedCompositions postViewUpdateBlocks"	combinedAgenda := aCatCSTransaction combinedAgenda.	oldValuesDict := aCatCSTransaction oldValuesDict.	failureBlocks := aCatCSTransaction failureBlocks.	endBlocks := aCatCSTransaction endBlocks.	context := aCatCSTransaction fullContext.	commitBlocks := aCatCSTransaction commitBlocks.	applicationLog := aCatCSTransaction applicationLog.	delegationContexts := aCatCSTransaction delegationContextsNeeded</body><body package="COTransactions">endInvalidationPhase	inInvalidationPhase := inInvalidationPhase - 1</body><body package="COTransactions">exceedsPartitionSize: partSize 	| ca cm |	ca := self combinedAgenda.	^ ca numberOfAccesses &gt; partSize 		or: [ self readClusterIDs size * 10 &gt; partSize or: [( cm := ca clusterManager ) notNil and: [ cm unloadStrategy unloadRecommended ]]]</body><body package="COTransactions">expectRollbackFor: frame 	"mar agenda - by cluster only"	self addAgendaFlag: CoastConstant noConcurrencyNag forCluster: frame cluster.</body><body package="COTransactions">failureReason	"the optional argument for failureBlocks"	"see #failureReason: for possible values"	^ failureReason</body><body package="COTransactions">failureReason: aFailureReason 	"the optional argument for failureBlocks"	"sending ths method does not indicate an error - it's only a marker when an failure occures	when the transactionManager is not active, the argument will be #errorNotActive	possible values: 		#errorInBlock		#errorInEndBlocks		#errorInDemons		#errorAbort			#errorReject	"	failureReason := aFailureReason.</body><body package="COTransactions">inDisplayPhase	^inDisplayPhase</body><body package="COTransactions">inDisplayPhase: aBoolean	inDisplayPhase := aBoolean</body><body package="COTransactions">inInvalidationPhase	^inInvalidationPhase ~~ 0</body><body package="COTransactions">invertedFrameDo: aBlock	" workaround for inverted write accesss in virtual slot computations "	^ self withoutDependenciesDo: aBlock</body><body package="COTransactions">involvedClusters	"answer all clusters involved in this transaction"	^combinedAgenda involvedClusters</body><body package="COTransactions">needsFlush: bool 	transactionManager needsFlush: bool</body><body package="COTransactions">outstandingCompositions	outstandingCompositions isNil		ifTrue: [ 	outstandingCompositions := OrderedCollection new: self defaultCollectionSize ].	^ outstandingCompositions</body><body package="COTransactions">ownerProcess	^ownerProcess</body><body package="COTransactions">readClusterIDs	^ self combinedAgenda readClusterIDs</body><body package="COTransactions">reduceRollingAgenda	" has no rolling agenda, so do nothing "</body><body package="COTransactions">removeProxyAccess: access</body><body package="COTransactions">sequenceOrSelf	^ self</body><body package="COTransactions">skipValidAccessTest	^ false</body><body package="COTransactions">startInvalidationPhase	inInvalidationPhase := inInvalidationPhase + 1</body><body package="COTransactions">transactionManager	^transactionManager</body><body package="COTransactions">transactionManager: aTransactionManager	transactionManager := aTransactionManager</body><body package="COTransactions">unloadClusters	" ignored "</body><body package="COTransactions">wasRolledBack	^ rolledBack</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>execution</category><body package="COTransactions">abort	" Abort the transaction. Undo everything which has changed "	self markDelayedCompositionsAsOutstanding.	[ self rollBack ] ensure: 		[	outstandingCompositions := self outstandingCompositions reject: [: e | combinedAgenda createdLocalFrames includes: e frame ].			self inDisplayPhase: true;				performOutstandingCompositions		].</body><body package="COTransactions">commited	" the transaction was accepted "	self evaluateCommitBlocks.</body><body package="COTransactions">doFastReadWhile: aBlock 	| oldFastRead |	oldFastRead := isFastRead.	^ [self isFastRead: true.	aBlock value] ensure: [isFastRead := oldFastRead]</body><body package="COTransactions">doNormalReadWhile: aBlock 	| oldFastRead |	oldFastRead := isFastRead.	^ [	self isFastRead: false.		aBlock value	] ensure: [ isFastRead := oldFastRead ]</body><body package="COTransactions">execute: aBlock 	"evaluate the given Block"	self failureReason: #errorInBlock.	^ aBlock numArgs = 0 		ifTrue: [ aBlock value ]		ifFalse: [ aBlock value: self ]</body><body package="COTransactions">finishForVolumeManager: volumeManager	" The main part of the transaction is finished. Now do everything necessary to properly	complete the transaction "	volumeManager interruptProtectDo:	[			self inDisplayPhase: true.		self handleOutstandingCompositions.		self unloadClustersForVolumeManager: volumeManager.		self handleOutstandingCompositions.	].	self evaluatePostViewUpdateBlocks.</body><body package="COTransactions">handleOutstandingCompositions	[self hasOutstandingCompositions]		whileTrue: [			self performOutstandingCompositions.			self performPostTransactionDemons.		].	self performPostTransactionDemons.</body><body package="COTransactions">moveDelayedCompositionsTo: aTransaction 	delayedCompositions isNil ifTrue: [ ^ self ].	delayedCompositions do: [: eagerSlot | aTransaction rememberDelayedComposition: eagerSlot ].	delayedCompositions := nil</body><body package="COTransactions">propagateApplicationLog	" record a standalone application log (which is not recorded as a part of this transaction) "	| cm |	self applicationLog isEmpty		ifFalse: [ 			(cm := self combinedAgenda clusterManager) notNil				ifTrue: [ cm recordApplicationLog: self applicationLog. self flushApplicationLog ]				"ifFalse: [ CoastLog log: 'ClusterManager of transaction unknown, cannot record application log' ]."		].</body><body package="COTransactions">propagateWith: aCatCSTransactionManager 	"only record non-empty transactions"	self failureReason: #errorReject.	^ self agendaNotEmpty 		ifTrue: 		[	combinedAgenda prepareCreatedCells.			self pessimistic 				ifTrue: 				[	"pessimistic: propagate and wait for commit"					aCatCSTransactionManager onePhaseCommit: self				]				ifFalse: 				[	"optimistic: fire and forget (we let you know)"					aCatCSTransactionManager recordTransaction: self				]		]		ifFalse: [ #accepted ]</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>context accessing</category><body package="COTransactions">context	^ context</body><body package="COTransactions">fullContext	context isNil ifTrue: [ context := IdentityDictionary new ].	^ context</body><body package="COTransactions">transactionContextAt: key 	"search the context"	^self transactionContextAt: key ifAbsent: [ nil ]</body><body package="COTransactions">transactionContextAt: key ifAbsent: absentBlock 	"search the context"	^ context isNil 		ifTrue: [ absentBlock value ]		ifFalse: [ context at: key ifAbsent: absentBlock ]</body><body package="COTransactions">transactionContextAt: key ifAbsentPut: aBlock 	^ self fullContext at: key ifAbsentPut: aBlock</body><body package="COTransactions">transactionContextAt: key put: value 	self fullContext at: key put: value</body><body package="COTransactions">transactionContextRemoveKey: key 	^context isNil 		ifTrue: [ nil ]		ifFalse: [context removeKey: key ifAbsent: [ nil ]]</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>initialize - release</category><body package="COTransactions">defaultCollectionSize	^ 50</body><body package="COTransactions">initialSizeForAccesses	^500</body><body package="COTransactions">initialize	self setOwnerProcess.	rolledBack := false.	composedCells := Dictionary new.	inDisplayPhase := false.	inInvalidationPhase := 0.	combinedAgenda := CatCSAgenda new.	failureBlocks := OrderedCollection new.	applicationLog := CatCSApplicationLog new.	composedCellsLock := RecursionLock new.</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>demon support</category><body package="COTransactions">demonCollectionClass	^ OrderedCollection</body><body package="COTransactions">differencesToBeginOfTransaction: cellAccess 	" return the difference between the current state of the cell access and the state	when it was accesses the first time in this transaction "	| cell oldValue |	cell := cellAccess cell.	oldValue := oldValuesDict notNil 			ifTrue: [ oldValuesDict at: cell ifAbsent: [ nil ]]			ifFalse: [ nil ].	^ cell differencesToOldValue: oldValue</body><body package="COTransactions">endDemons	endDemons isNil		ifTrue: [ endDemons := self demonCollectionClass new: self defaultCollectionSize ].	^ endDemons</body><body package="COTransactions">performEndTransactionDemons	" it may happen that the end transaction demons add new accesses to this dictionary "	self failureReason: #errorInDemons.	[ endDemons isNil or: [ endDemons isEmpty ]] whileFalse: 		[ | currentEndDemons |			currentEndDemons := endDemons.			endDemons := nil.			currentEndDemons do: [: access | access performEndTransactionDemons ]		].</body><body package="COTransactions">performPostTransactionDemons	" it may happen that the post transaction demons add new accesses to this dictionary "	[		postDemons isNil or: [ postDemons isEmpty ]	] whileFalse: [		| currentPostDemons |		currentPostDemons := postDemons.		postDemons := nil.		currentPostDemons do: [ :access |			access performPostTransactionDemons		].	].</body><body package="COTransactions">postDemons	postDemons isNil		ifTrue: [ postDemons := self demonCollectionClass new: self defaultCollectionSize ].	^ postDemons</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>composing virtual cells</category><body package="COTransactions">beginComposing: anObject	composedCellsLock critical: [ 		self composedCells addLast: anObject	].</body><body package="COTransactions">currentlyComposedCell	^ composedCellsLock critical: [		| ccs |		ccs :=  composedCells at: Processor activeProcess ifAbsent: [ #() ].		ccs isEmpty			ifTrue: [ nil ]			ifFalse: [ ccs last ].	].</body><body package="COTransactions">delayOutstandingComposition: aSlot	^ false</body><body package="COTransactions">endComposing: anObject 	composedCellsLock critical: 		[ | ccs |			ccs := composedCells at: Processor activeProcess ifAbsent: [ nil ].			( ccs notNil and: [ ccs notEmpty and: [ ccs last == anObject ]]) 				ifTrue: [ ccs removeLast ]				ifFalse: [ self confusionInComposeListError: anObject ]		]</body><body package="COTransactions">hasOutstandingCompositions	"do I have outstanding compositions?"	^ outstandingCompositions notNil and: [ outstandingCompositions isEmpty not ]</body><body package="COTransactions">markDelayedCompositionsAsOutstanding	delayedCompositions isNil ifTrue: [ ^ self ].	delayedCompositions do: [: eagerSlot | self rememberOutstandingComposition: eagerSlot ].	delayedCompositions := nil</body><body package="COTransactions">performOutstandingCompositions	"while performing the outstanding compositions, new compositions may be added to the list"	| actualTraversedCompositions | 	[ self hasOutstandingCompositions ] whileTrue: 		[	actualTraversedCompositions := self outstandingCompositions.			outstandingCompositions := nil.			actualTraversedCompositions do: 				[: eagerSlot | 					( self delayOutstandingComposition: eagerSlot ) 						ifTrue: [ self rememberDelayedComposition: eagerSlot ]						ifFalse: 						[	self wasRolledBack 								ifTrue: 								[	"in case of a rollbacked transaction be very cautious with eager computations!!!"									[ eagerSlot updateEagerSlot ] on: Error do: [: ex | self composedCells: OrderedCollection new ]								]								ifFalse: [ eagerSlot updateEagerSlot ]						]				]		]</body><body package="COTransactions">rememberDelayedComposition: aVirtualCell 	delayedCompositions isNil 		ifTrue: [ delayedCompositions := OrderedCollection with: aVirtualCell ]		ifFalse: [( delayedCompositions includes: aVirtualCell ) ifFalse: [ delayedCompositions addLast: aVirtualCell ]]</body><body package="COTransactions">rememberInitialOutstandingComposition: aVirtualCell 	self outstandingCompositions addLast: aVirtualCell.</body><body package="COTransactions">rememberOutstandingComposition: aVirtualCell 	( self outstandingCompositions includes: aVirtualCell ) ifFalse: [ self outstandingCompositions addLast: aVirtualCell ]</body><body package="COTransactions">withoutDependenciesDo: aBlock 	self beginComposing: nil.	^ aBlock ensure: [ self endComposing: nil ]</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>error handling</category><body package="COTransactions">confusionInComposeListError: anObject	| s |	s := self composedCells inject: String new into: [ :str :c | str, '\', c printString ].	self errorSignal raiseSignal: 		('Error while building up dependencies:\Ended computing: ', 		anObject printString, '\Computing Stack: ', s) withCRs.</body><body package="COTransactions">illegalWriteAccessDuringDisplayPhaseError	" an error should be raised here. "	self errorSignal raiseSignal: 'Illegal write access during a display phase'</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>private</category><body package="COTransactions">flushAfterOnePhaseCommit	self		flushDelegationContexts;		flushRpcCache</body><body package="COTransactions">keepClusterIDs	^ combinedAgenda referencedClusterIDs</body><body package="COTransactions">oldValuesDict	oldValuesDict isNil 		ifTrue: [ oldValuesDict := IdentityDictionary new: self initialSizeForAccesses ].	^ oldValuesDict</body><body package="COTransactions">setOwnerProcess	ownerProcess := Processor activeProcess.</body><body package="COTransactions">unloadClustersForVolumeManager: volumeManager 	| clusterManager keepClusterIDs |	self combinedAgenda updateClusterInfoFor: volumeManager.	keepClusterIDs := self keepClusterIDs.	clusterManager := self combinedAgenda clusterManager.	clusterManager notNil ifTrue: [ clusterManager unloadClustersIfNecessaryExcept: keepClusterIDs ]</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>agenda handling</category><body package="COTransactions">addReadCluster: cluster 	combinedAgenda addReadCluster: cluster.</body><body package="COTransactions">notifyUnloadCluster: cluster 	self combinedAgenda notifyUnloadCluster: cluster</body><body package="COTransactions">recordAccess: aCatCSCellAccess 	"Add the access to the agenda. Also store the cell value for rollbacks 	if aCatCSCellAccess is the first access in this transaction	(some demons might be interested, too) "	| isRead |	self transactionManager recordAccess: aCatCSCellAccess in: self.	(isRead := aCatCSCellAccess isReadAccess)		ifFalse: [ self recordDelayedDemons: aCatCSCellAccess ].	aCatCSCellAccess isLocalCell		ifTrue: [ ^ self ].	" nothing to do anymore "	isRead	ifTrue:	[		self inDisplayPhase			ifTrue: [ combinedAgenda addDisplayAccess: aCatCSCellAccess ]			ifFalse: [ (isFastRead == true) ifFalse: [ combinedAgenda addAccess: aCatCSCellAccess ] ].	]	ifFalse:	[		(self inDisplayPhase and: [ aCatCSCellAccess isSharedCell ])			ifTrue: [ ^self illegalWriteAccessDuringDisplayPhaseError ].		combinedAgenda addAccess: aCatCSCellAccess.	].</body><body package="COTransactions">recordCellCreation: aCatCSCell 	"the creation of new cell instances has to be recorded."	self inDisplayPhase		ifTrue: [ 			" It's not possible to make this cell shared "			aCatCSCell makeLocal ]		ifFalse: [			" record the creation "			combinedAgenda addCellCreation: aCatCSCell ]</body><body package="COTransactions">recordDelayedDemons: aCatCSCellAccess 	"the access may have triggered demons that will be executed later - have a look"	aCatCSCellAccess cell allDemonsDo: [ :demon |		(demon hasEndTransactionJobWithAccess: aCatCSCellAccess) ifTrue: [ self endDemons add: aCatCSCellAccess ]. 		(demon hasPostTransactionJobWithAccess: aCatCSCellAccess) ifTrue: [ self postDemons add: aCatCSCellAccess ]. 	]</body><body package="COTransactions">recordLocalFrameCreation: localFrame		combinedAgenda recordLocalFrameCreation: localFrame</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>rolling</category><body package="COTransactions">oldKeysAndValuesDo: block 	self oldValuesDict keysAndValuesDo: block.</body><body package="COTransactions">rollBack	" Roll back the transaction "	| createdLocalFrames |	CoastLog logDebug: 'Rollback'.	self wasRolledBack ifFalse: 		[	createdLocalFrames := combinedAgenda createdLocalFrames.			" simply restore the old values of the modified cells "			self oldKeysAndValuesDo: [: cell : oldValue | cell restoreOldValue: oldValue transaction: self ].			" flag unregistered frames as invalid "			self combinedAgenda accessedUnregisteredCells 				keysDo: [: cell | ( cell isCoastFrame and: [ cell cellContainer isNil ]) ifTrue: [ cell setInvalidFrameID ]].			" release local stuff "			createdLocalFrames do: [: frame | frame release; flushSlotsForRollbak ].			rolledBack := true.			self evaluateFailureBlocks		].</body><body package="COTransactions">rollForward	"this method is for replaying a transaction using its agenda"	"subclasses should override this method"	self errorSignal raiseSignal: 'not supported'</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>rpc</category><body package="COTransactions">flushRpcCache	^ self transactionContextRemoveKey: #rpcCache</body><body package="COTransactions">rpcCache	^ self transactionContextAt: #rpcCache ifAbsentPut: [ Dictionary new ].</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>access handling</category><body package="COTransactions">evaluateEndBlocks	self failureReason: #errorInEndBlocks.	endBlocks notNil ifTrue: 		[	endBlocks do: [: eachBlock | eachBlock value ].			endBlocks do: [: eachBlock | eachBlock finalEndBlockValue ].			self performEndTransactionDemons		].</body><body package="COTransactions">oldValuesDictAt: cell ifAbsentPut: block 	( cell isSlot and: [ cell frame isLocal and: [ combinedAgenda createdLocalFrames includes: cell frame ]]) 		ifTrue: [	"keine lokalen Frames" ]		ifFalse: [ self oldValuesDict at: cell ifAbsentPut: block ].</body><body package="COTransactions">rememberAccessIfFirst: cellAccess 	| cell |	self wasRolledBack ifFalse: 		[	cell := cellAccess cell.			( cell needsCellValueCopyForRollbackIn: self ) ifTrue: [ self oldValuesDictAt: cell ifAbsentPut: [ cell valueHolder copyForRollback ]]		].</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>application log</category><body package="COTransactions">applicationLog	^ applicationLog</body><body package="COTransactions">flushApplicationLog	applicationLog := CatCSApplicationLog new.</body></methods><methods><class-id>COAST.CatCSTransaction</class-id> <category>delegation context</category><body package="COTransactions">delegationContextAt: aDelegationValueHolder	delegationContexts isNil ifTrue: [ ^nil ].	^self delegationContextsNeeded at: aDelegationValueHolder ifAbsent: [ nil ]</body><body package="COTransactions">delegationContextNeededAt: aDelegationValueHolder	^self delegationContextsNeeded at: aDelegationValueHolder ifAbsentPut: [ Dictionary new ]</body><body package="COTransactions">delegationContextsNeeded	^delegationContexts ifNil: [ delegationContexts := Dictionary new ]</body><body package="COTransactions">flushDelegationContexts	^delegationContexts := nil</body></methods><methods><class-id>COAST.CatCSTransaction class</class-id> <category>instance creation</category><body package="COTransactions">new	^super new initialize</body></methods><methods><class-id>COAST.CatCSTransaction class</class-id> <category>accessing</category><body package="COTransactions">errorSignal	^ CoastError</body></methods><methods><class-id>COAST.CatRMUpdateTransaction</class-id> <category>initialize - release</category><body package="COTransactions">initialSizeForAccesses	^0</body><body package="COTransactions">initialize	owner := Processor activeProcess.	super initialize</body></methods><methods><class-id>COAST.CatRMUpdateTransaction</class-id> <category>testing</category><body package="COTransactions">isUpdateTransaction	^true</body><body package="COTransactions">mayDisplay	"other processes than my owner process that want to display, have to wait for their own transaction"	"hopping onto a running update transaction for display is very dangerous!!!"	^Processor activeProcess == owner and: [ super mayDisplay ]</body></methods><methods><class-id>COAST.CatRMUpdateTransaction</class-id> <category>agenda handling</category><body package="COTransactions">recordAccess: aCatCSCellAccess 	aCatCSCellAccess isUpdateAccess		ifTrue: [ self recordDelayedDemons: aCatCSCellAccess ].</body><body package="COTransactions">recordCellCreation: aCatCSCellCreation	"the creation of new cell instances has not to be recorded by update transactions"</body></methods><methods><class-id>COAST.CatRMUpdateTransaction</class-id> <category>rolling</category><body package="COTransactions">rollForward	"this method is for replaying a transaction using its agenda"	self subclassResponsibility</body><body package="COTransactions">unloadClustersForVolumeManager: volumeManager</body></methods><methods><class-id>COAST.CatRMUpdateSingleTransaction</class-id> <category>accessing</category><body package="COTransactions">clusterController: aCatRMClientCC	clusterController := aCatRMClientCC</body><body package="COTransactions">simpleAgenda: aCatRMSimpleAgenda	simpleAgenda := aCatRMSimpleAgenda</body></methods><methods><class-id>COAST.CatRMUpdateSingleTransaction</class-id> <category>rolling</category><body package="COTransactions">rollForward	"this method is for replaying a transaction using its agenda"	simpleAgenda rollForwardForClusterController: clusterController</body></methods><methods><class-id>COAST.ArgumentsDictionary</class-id> <category>initialize-release</category><body package="COBase">at: key ifAbsent: aBlock 	tally = 0 ifTrue: [ ^ aBlock value ].	tally &gt; 2 ifTrue: [ ^ super at: key ifAbsent: aBlock ].	1 to: self basicSize		do: 		[: index | | elem |			( elem := self basicAt: index ) == nil ifFalse: [ elem key = key ifTrue: [ ^ elem value ]]		].	^ aBlock value</body><body package="COBase">findKeyOrNil: anObject 	"Answer the index of the argument anObject or answer nil."	"Copied from Set with equality check changed to identity."	| index length probe pass |	length := self basicSize.	pass := 1.	index := self initialIndexFor: anObject coastArgumentsHash boundedBy: length.	[( probe := self basicAt: index ) == nil or: [ probe key = anObject ]] whileFalse: 		[( index := index + 1 ) &gt; length ifTrue: 				[	index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [ ^ self grow findElementOrNil: anObject ]				]		].	^ index</body></methods><methods><class-id>COAST.CatRMMessageWithAgenda</class-id> <category>accessing</category><body package="COTransactions">loggedTransactionAgenda	^loggedTransactionAgenda</body><body package="COTransactions">loggedTransactionAgenda: aValue	loggedTransactionAgenda := aValue</body><body package="COTransactions">receiver	"answer the cluster locator the message is to be delivered to"	^loggedTransactionAgenda transactionID clusterLocator</body><body package="COTransactions">receiverVolume	^self receiver volume</body></methods><methods><class-id>COAST.CatRMMessageWithAgenda</class-id> <category>printing</category><body package="COTransactions">printOn: aStream	super printOn: aStream.	aStream nextPut: $[.	loggedTransactionAgenda printOn: aStream.	aStream nextPut: $].</body></methods><methods><class-id>COAST.CatRMMessageWithAgenda</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall	CoastLog logDebug: [ | cStream |		cStream := SizeCalculatingStream new initialize.		self loggedTransactionAgenda			marshallBinaryTo: cStream			marshaller: aCatRMMarshall.		' sending agenda of size: ', cStream byteSize printString.	] channel: #coastIO.	self loggedTransactionAgenda		marshallBinaryTo: aStream		marshaller: aCatRMMarshall.</body><body package="COTransactions">prepareMarshaller: marshaller volumeManager: volumeManager 	marshaller currentClusterID: loggedTransactionAgenda agenda cluster clusterID.	marshaller clusterManager: loggedTransactionAgenda agenda cluster clusterManager.</body><body package="COTransactions">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	self loggedTransactionAgenda: ( CatRMLoggedTransactionAgenda new unmarshallAgendaFrom: aStream				marshaller: aCatRMMarshall				withVolumeManager: aCatCSVolumeManager )</body></methods><methods><class-id>COAST.CatRMUpdateMessage class</class-id> <category>instance creation</category><body package="COTransactions">loggedTransactionAgenda: aValue	| newInst |	newInst := self new.	newInst loggedTransactionAgenda: aValue.	^newInst</body></methods><methods><class-id>COAST.CoastExitCode class</class-id> <category>exit codes</category><body package="COBase">unhandelHeadlessError	"used in parcel Headless - hard wired :("	"do not!!! send"	^ 16r0002</body></methods><methods><class-id>COAST.CoastExitCode class</class-id> <category>util</category><body package="COBase">errorCodesAndDescriptions	"self errorCodesAndDescriptions"	| stream |	stream := String new writeStream.	self errorCodesAndDescriptionsOn: stream.	^ stream contents</body><body package="COBase">errorCodesAndDescriptionsOn: stream	| pragmas |	pragmas := (Pragma allNamed: #errorCodeName:description: in: self class) collect: [ : pragma | (self perform: pragma selector) -&gt; pragma ].	(pragmas sortedBy: [ : assoc | assoc key ]) do: [ : assoc |		assoc key printOn: stream.		stream tab.		assoc value printOn: stream.		] separatedBy: [			stream cr.			].</body></methods><methods><class-id>COAST.CatRMTryResponseMessage</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall	self transactionID marshallBinaryTo: aStream marshaller: aCatRMMarshall</body><body package="COTransactions">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self transactionID:		(CatRMTransactionID new				unmarshallBinaryFrom: aStream				marshaller: aCatRMMarshall).</body></methods><methods><class-id>COAST.CatRMTryResponseMessage</class-id> <category>accessing</category><body package="COTransactions">receiver	^transactionID clusterLocator</body><body package="COTransactions">transactionID	^transactionID</body><body package="COTransactions">transactionID: aValue	transactionID := aValue</body></methods><methods><class-id>COAST.CatRMTryResponseMessage class</class-id> <category>instance creation</category><body package="COTransactions">transactionID: aCatRMTransactionID	| newInst |	newInst := self new.	newInst transactionID: aCatRMTransactionID.	^newInst</body></methods><methods><class-id>COAST.CoastSocketAccessor</class-id> <category>services</category><body package="COBase">close	( socketAccessor notNil and: [ socketAccessor isActive ]) 		ifTrue: 		[	super close.			socketAccessor close		].</body></methods><methods><class-id>COAST.CoastSocketAccessor</class-id> <category>accessing</category><body package="COBase">coastBinaryReadStream	| stream |	stream := self readAppendStream binary.	SocketAccessor coastConfigureStream: stream.	^ stream</body><body package="COBase">coastBinaryWriteStream	| stream |	stream := self readAppendStream binary.	SocketAccessor coastConfigureStream: stream.	^ stream</body><body package="COBase">connect	self connect: [ : server | true ]</body><body package="COBase">getName	^ socketAccessor getName</body><body package="COBase">getPeer	^ socketAccessor getPeer</body><body package="COBase">readStream	"compatible to the socketAccessor"	^ self readAppendStream</body><body package="COBase">socketAccessor: aSocketAccessor 	socketAccessor := aSocketAccessor.</body><body package="COBase">writeStream	"compatible to the socketAccessor"	^ self readAppendStream</body></methods><methods><class-id>COAST.CoastSocketAccessor class</class-id> <category>accessing</category><body package="COBase">transferMode	^ self useSSL 		ifTrue: [ self sslUsageID ]		ifFalse: [ self sslSkipID ]</body><body package="COBase">useSSL	^ useSSL ifNil: [ false ]</body><body package="COBase">useSSL: boolean 	useSSL := boolean.</body></methods><methods><class-id>COAST.CoastSocketAccessor class</class-id> <category>instance creation</category><body package="COBase">acceptSocketAccessor: socketAccessor securityContext: securityContext 	| coastSocketAccessor |	^ self 		plainSocketAccessor: socketAccessor		sslDo: 		[	securityContext notNil 				ifTrue: 				[	coastSocketAccessor := securityContext coastConnectionForSocket: socketAccessor.					coastSocketAccessor socketAccessor: socketAccessor.					" HK: Hier wurde frÃ¼her mal SSLNoServerCertificate ignoriert. 					Das ist zwar mÃ¶glich (anonymer SchlÃ¼sselaustausch, siehe http://www.ietf.org/rfc/rfc2246.txt F.1.1.1),					verhindert dann aber nicht mehr Man-in-the-middle-Angriffe "					coastSocketAccessor accept.					coastSocketAccessor				]				ifFalse: 				[	" keine sichere Verbindung mÃ¶glich "					CoastError raiseSignal: 'Cannot not establish a secure connection, SSL not configured'.					nil				]		]</body><body package="COBase">connectSocketAccessor: socketAccessor 	| context coastSocketAccessor |	^ self plainSocketAccessor: socketAccessor		sslDo: 		[	context := Xtreams.TLSContext newClientWithDefaults.			coastSocketAccessor := context coastConnectionForSocket: socketAccessor .			[				coastSocketAccessor socketAccessor: socketAccessor.				coastSocketAccessor connect.			] on: Xtreams.TLSCertificateWarning				do: 				[: ex |					CoastLog logWarning: ex description.					ex resume				].			coastSocketAccessor		]</body><body package="COBase">plainSocketAccessor: socketAccessor sslDo: block 	| ownTransferMode buffer clientTransferMode |	ownTransferMode := self transferMode.	socketAccessor writeStream binary nextPut: ownTransferMode; flush.	buffer := ByteArray new: 1.	"would we use &lt;socketAccessor readStream binary next&gt;, there is the good chance of a dead lock based on loss of the readStreams buffer"	"details: peer A has read his buffer and starts so send more bytes"	"these bytes will all end in the readStream buffer of peer B, but only the first byte is read in this method - the rest of it is lost -&gt; dead lock"	"HS/CS 2011: DO NOT MODIFY NEXT LINE!"	socketAccessor readInto: buffer startingAt: 1 for: 1.	clientTransferMode := buffer first .	^ ( ownTransferMode = clientTransferMode and: [ clientTransferMode = self sslSkipID ]) 		ifTrue: [ socketAccessor	"agreement: plain text transfer" ]		ifFalse: 		[	clientTransferMode = self sslUsageID 				ifTrue: 				[	"ssl required"					block value				]				ifFalse: 				[	CoastError raiseSignal: 'Unsupported connection type, probably an unknown client'.					nil				]		]</body></methods><methods><class-id>COAST.CoastSocketAccessor class</class-id> <category>constants</category><body package="COBase">sslSkipID	^ 42</body><body package="COBase">sslUsageID	^ 66</body></methods><methods><class-id>COAST.TransactionFailReason</class-id> <category>accessing</category><body package="COTransactions">conflictingAgenda: aConflictingAgenda</body></methods><methods><class-id>COAST.NotCommutative</class-id> <category>accessing</category><body package="COTransactions">conflictingAgenda	^ conflictingAgenda</body><body package="COTransactions">conflictingAgenda: aConflictingAgenda 	conflictingAgenda := aConflictingAgenda.</body></methods><methods><class-id>COAST.NotCommutative</class-id> <category>printing</category><body package="COTransactions">printConflictingClientOn: aStream	conflictingAgenda notNil ifTrue:	[		conflictingAgenda printClientDescriptionOn: aStream	]</body><body package="COTransactions">printOn: aStream	aStream nextPutAll: 'concurrency conflict'</body></methods><methods><class-id>COAST.NotCommutative class</class-id> <category>instance creation</category><body package="COTransactions">conflictingAgenda: aConflictingAgenda 	^ self new conflictingAgenda: aConflictingAgenda;		yourself</body></methods><methods><class-id>COAST.FrameIDCollision</class-id> <category>accessing</category><body package="COTransactions">conflictingFrameCreation	^ conflictingFrameCreation</body><body package="COTransactions">conflictingFrameCreation: aConflictingFrameCreation 	conflictingFrameCreation := aConflictingFrameCreation.</body></methods><methods><class-id>COAST.FrameIDCollision</class-id> <category>printing</category><body package="COTransactions">printOn: aStream	aStream nextPutAll: self class name; space.		conflictingFrameCreation printOn: aStream.</body></methods><methods><class-id>COAST.FrameIDCollision class</class-id> <category>instance creation</category><body package="COTransactions">conflictingAgenda: aConflictingAgenda conflictingFrameCreation: frameCreation	^ (self conflictingAgenda: aConflictingAgenda)		conflictingFrameCreation: frameCreation;		yourself</body></methods><methods><class-id>COAST.CatCOIntegerKeySet</class-id> <category>accessing</category><body package="COBase">coastAsSetOrYourself	^ self</body></methods><methods><class-id>COAST.CatCOIntegerKeySet</class-id> <category>private</category><body package="COBase">findElementOrNil: anObject	"Answer the index of the argument anObject, if present, or the index of a nil	entry where anObject would be placed."		| index length probe steps |	length := self basicSize.	steps := 0.	index := self initialIndexFor: anObject hash boundedBy: length.	[( probe := self basicAt: index ) == nil or: [ probe = anObject ]]		whileFalse:			[( index := index + 1 ) &gt; length ifTrue: [ index := 1 ].			steps := steps + 1.			steps &gt;= length ifTrue: [ ^ self grow findElementOrNil: anObject ]].	collisions isNil ifTrue: [ collisions := steps ] ifFalse: [ collisions :=collisions + steps ].	^ index</body><body package="COBase">initialIndexFor: aHashValue boundedBy: length	" optimize for large sets with relatively even spread hash values "	^ ((( aHashValue \\ length ) * 4 ) \\ length ) + 1</body><body package="COBase">maxCollisions 	^ self basicSize // 2</body><body package="COBase">postCopy	collisions := 0.	^ super postCopy</body></methods><methods><class-id>COAST.CatCOIntegerKeySet</class-id> <category>adding</category><body package="COBase">add: anObject 	"Answer the index of the argument anObject, if present, or the index of a nil	entry where anObject would be placed."	collisions isNil 		ifTrue: [ collisions := 0 ].	collisions &gt;= self maxCollisions 		ifTrue: [ self grow add: anObject ]		ifFalse: [ super add: anObject ].	^ anObject</body></methods><methods><class-id>COAST.SlotCreationConflict</class-id> <category>accessing</category><body package="COTransactions">slotCreation	^ slotCreation</body><body package="COTransactions">slotCreation: aSlotCreation 	slotCreation := aSlotCreation.</body></methods><methods><class-id>COAST.SlotCreationConflict class</class-id> <category>instance creation</category><body package="COTransactions">conflictingAgenda: aConflictingAgenda slotCreation: slotCreation	^ (self conflictingAgenda: aConflictingAgenda)		slotCreation: slotCreation;		yourself</body></methods><methods><class-id>COAST.CoastMediatorStub class</class-id> <category>mediator services</category><body package="COBase">backupVolume: volumename atHost: hostname remotePassword: remotePassword 	^ self sendTo: hostname		requestID: CoastConstant backupVolumeID		andStrings: ( Array with: remotePassword with: volumename )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ].</body><body package="COBase">blockUntilBackupIsDoneVolume: volumename atHost: hostname 	^ self 		sendTo: hostname		requestID: CoastConstant blockUntilBackupIsDone		andStrings: ( Array with: volumename )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ]</body><body package="COBase">clientsAtHost: hostname 	"self clientsAtHost: 'localhost' "	| connectionsCount clients |	clients := OrderedCollection new.	self 		sendTo: hostname		requestID: CoastConstant listConnections		andStrings: Array new		receiveStreamDo: 		[: receiveStream | | client |			connectionsCount := receiveStream nextOptimized32.			connectionsCount timesRepeat: 				[ | volumes |					client := Dictionary new.					client at: #clientID put: receiveStream nextOptimized32.					client at: #ipString put: receiveStream nextCoastString.					volumes := OrderedCollection new.					( 1 to: receiveStream nextOptimized32 ) do: [: i | volumes add: receiveStream nextCoastString ].					client at: #volumes put: volumes.					clients add: client				]		].	^ clients</body><body package="COBase">compressVolume: volumename atHost: hostname remotePassword: remotePassword 	^ self sendTo: hostname		requestID: CoastConstant compressVolumeID		andStrings: ( Array with: remotePassword with: volumename )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream  ].</body><body package="COBase">connectionsAtHost: hostname 	"self connectionsAtHost: 'localhost' "	| connectionsCount connections |	connections := OrderedCollection new.	self sendTo: hostname		requestID: CoastConstant listConnections		andStrings: Array new		receiveStreamDo: 		[: receiveStream |			self checkValidResponseFrom: receiveStream.			connectionsCount := receiveStream nextOptimized32.			connectionsCount timesRepeat: 				[ | writeStream |					writeStream := String new writeStream.					writeStream nextPutAll: 'client '.					receiveStream nextOptimized32 printOn: writeStream.	"clientID "					writeStream nextPutAll: ' at '.					writeStream nextPutAll: receiveStream nextCoastString.	"clientIPString"					writeStream nextPutAll: ' ('.	"volumesCount"					( 1 to: receiveStream nextOptimized32 ) 						do: [: i | writeStream nextPutAll: receiveStream nextCoastString	"volume" ]						separatedBy: [ writeStream space ].					writeStream nextPut: $).					connections add: writeStream contents				]		].	^ connections</body><body package="COBase">connectionsPerVolumeAtHost: hostname 	"self connectionsPerVolumeAtHost: 'localhost' "	| connectionsCount connections |	connections := MultiValueDictionary new.	self sendTo: hostname		requestID: CoastConstant listConnections		andStrings: Array new		receiveStreamDo: 		[: receiveStream |			self checkValidResponseFrom: receiveStream.			connectionsCount := receiveStream nextOptimized32.			connectionsCount timesRepeat: 				[ | writeStream |					writeStream := String new writeStream.					writeStream nextPutAll: 'client '.					receiveStream nextOptimized32 printOn: writeStream.	"clientID "					writeStream nextPutAll: ' at '.					writeStream nextPutAll: receiveStream nextCoastString.	"clientIPString"					( 1 to: receiveStream nextOptimized32 ) do: [: i | connections atKey: receiveStream nextCoastString add: writeStream contents	"volume" ]				]		].	^ connections</body><body package="COBase">copyVolume: volumename to: newName atHost: hostname remotePassword: remotePassword 	^ self 		sendTo: hostname		requestID: CoastConstant copyVolumeID		andStrings: ( Array with: remotePassword with: volumename with: newName )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ]</body><body package="COBase">createVolume: volume atHost: hostname remotePassword: remotePassword 	^ self 		sendTo: hostname		requestID: CoastConstant createVolumeID		andStrings: ( Array with: remotePassword with: volume )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ]</body><body package="COBase">deleteBackup: backupVolume version: version atHost: hostname remotePassword: remotePassword 	^ CoastMediatorStub 		sendTo: hostname		requestID: CoastConstant deleteBackupVolumeID		andStrings: ( Array with: remotePassword with: backupVolume with: version )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ]</body><body package="COBase">deleteVolume: volumename atHost: hostname remotePassword: remotePassword 	^ CoastMediatorStub 		sendTo: hostname		requestID: CoastConstant deleteVolumeID		andStrings: ( Array with: remotePassword with: volumename )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ]</body><body package="COBase">downloadLogFromHost: hostname toFilename: filename remotePassword: remotePassword 	| statusResponse |	statusResponse := self 			sendTo: hostname			requestID: CoastConstant downloadLogID			andStrings: ( Array with: remotePassword )			receiveStreamDo: 			[: receiveStream | | writeStream response |				response := CoastStatusResponse fromStream: receiveStream.				response ok 					ifTrue: 					[	writeStream := nil.						[	 | logSize |							writeStream := filename asFilename writeStream binary.							logSize := receiveStream nextUnsigned32.							writeStream nextPutAll: ( receiveStream nextAvailable: logSize )						] ensure: 							[	writeStream isNil 									ifFalse: [ writeStream close ]							]					].				response			].	statusResponse ok 		ifFalse: [ CoastError raiseSignal: statusResponse message ].</body><body package="COClusterManagement">downloadVolume: volumename fromHost: hostname toLocalVolume: localVolumename in: localDirectory remotePassword: remotePassword 	" Download the volume. Returns a CoastStatusResponse "	| storageAccessor |	storageAccessor := CatCSVolumeManager defaultStorageClass storageAccessorClass directory: localDirectory volume: localVolumename.	storageAccessor exists 		ifTrue: [ CoastError raiseSignal: 'Target volume already exists' ].	^ self 		sendTo: hostname		requestID: CoastConstant downloadVolumeID		andStrings: ( Array with: remotePassword with: volumename )		receiveStreamDo: 		[: receiveStream |			| statusResponse |			statusResponse := CoastStatusResponse fromStream: receiveStream.			statusResponse ok 				ifFalse: [ CoastError raiseSignal: statusResponse message ].			storageAccessor startUp.			[ storageAccessor receiveVolumeFrom: receiveStream ] ensure: [ storageAccessor shutDown ].			statusResponse		]</body><body package="COBase">evaluate: aString password: password atHost: hostname 	"self evaluate: 'CoastMediator default volumeManager clientIPNumbers' atHost: 'localhost'"	^ self sendTo: hostname		requestID: CoastConstant evaluateID		andStrings: ( Array with: aString with: password )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream  ].</body><body package="COBase">recoverToVolume: volumename fromVolume: backupVolume version: version atHost: hostname remotePassword: remotePassword 	^ self sendTo: hostname		requestID: CoastConstant recoverToVolumeID		andStrings: ( Array with: remotePassword with: backupVolume with: version with: volumename )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ].</body><body package="COBase">recoverableVolumesAtHost: hostname 	"contact host and retrieve all available recoverable volumes, answer a dictionary of volumenames -&gt; timetamps (as ms)"	^ CoastMediatorStub 		sendTo: hostname		requestID: CoastConstant recoverableVolumes		andStrings: Array new		receiveStreamDo: 		[: receiveStream | | volumeCount volumes |			self checkValidResponseFrom: receiveStream.			volumes := Dictionary new.			volumeCount := receiveStream nextOptimized32.			volumeCount timesRepeat: 				[ | vol col |					vol := receiveStream nextCoastString.					col := OrderedCollection new.					receiveStream nextOptimized32 timesRepeat: [ col add: receiveStream nextCoastString ].					volumes at: vol put: col				].			volumes		]</body><body package="COClusterManagement">replaceVolume: volumeToReplace atHost: hostname with: localVolume remotePassword: remotePassword 	| volAccessorClass dir storageAccessor |	volAccessorClass := CatCSVolumeManager defaultStorageClass.	dir := volAccessorClass defaultVolumesDirectory ifNil: 			[	volAccessorClass defaultBaseDirectory 					ifNotNil: [: d | d asFilename construct: CoastConstant defaultVolumeDirectory ]					ifNil: [ CoastConstant defaultVolumeDirectory asFilename ]			].	storageAccessor := volAccessorClass storageAccessorClass directory: dir volume: localVolume.	storageAccessor exists 		ifFalse: [ CoastError raiseSignal: 'Volume "' , localVolume , '" does not exist' ].	storageAccessor startUp.	^ [	self 			sendTo: hostname			requestID: CoastConstant replaceVolumeID			andStrings: ( Array with: remotePassword with: volumeToReplace )			sendStreamDo: [: sendStream | storageAccessor sendVolumeTo: sendStream ]			receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ]	] ensure: [ storageAccessor shutDown ]</body><body package="COBase">shutDownMediatorAtHost: hostname password: password 	"self shutDownMediatorAtHost: 'localhost' password: 'shutdown' "	^ self 		sendTo: hostname		requestID: CoastConstant shutDownMediator		andStrings: ( Array with: password )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ]</body><body package="COBase">timeDifferenceAtHost: hostname 	" mediator time as milliseconds "	| sendTime |	^ CoastMediatorStub 		sendTo: hostname		requestID: CoastConstant synchTime		andStrings: Array new		sendStreamDo: [: sendStream | sendTime := Timestamp coastRightNow asMilliseconds ]		receiveStreamDo: 		[: receiveStream | | byteArray mediatorTime roundTripDelay |			roundTripDelay := Time millisecondsToRun: 					[	self checkValidResponseFrom: receiveStream.						byteArray := ByteArray new: 8.						( 1 to: 8 ) reverseDo: [: i | byteArray at: i put: receiveStream next ].						mediatorTime := byteArray inject: 0 into: [: sub : byte | sub * 256 + byte ]					].			mediatorTime - sendTime - ( roundTripDelay // 2 )		]</body><body package="COBase">versionAtHost: hostname 	^ self 		sendTo: hostname		requestID: CoastConstant version		andStrings: Array new		receiveStreamDo: 		[: receiveStream |			self checkValidResponseFrom: receiveStream.			CoastVersion unmarshallBinaryFrom: receiveStream		]</body><body package="COBase">volumeExists: aVolume atHost: aHostname 	" returns true if the volume exists "	"compatibility "	^ (self volumesAtHost: aHostname ) includes: aVolume	" new style ""	^ CoastMediatorStub 		sendTo: aHostname		requestID: CoastConstant volumeExists		andStrings: ( Array with: aVolume )		receiveStreamDo: 		[: receiveStream | | statusResponse |			statusResponse := CoastStatusResponse fromStream: receiveStream.			statusResponse ok		] "</body><body package="COBase">volumesAtHost: hostname password: password 	" compatibility "	^ self volumesAtHost: hostname.	" new style ""	^ CoastMediatorStub 		sendTo: hostname		requestID: CoastConstant volumesPasswordProtected		andStrings: ( Array with: password )		receiveStreamDo: 		[: receiveStream | | volumeCount volumes |			self checkValidResponseFrom: receiveStream.			volumeCount := receiveStream nextOptimized32.			volumes := OrderedCollection new: volumeCount.			volumeCount timesRepeat: [ volumes add: receiveStream nextCoastString ].			volumes		]"</body></methods><methods><class-id>COAST.CoastMediatorStub class</class-id> <category>mediator volume services</category><body package="COBase">pauseGCAtHost: hostname volume: volumename remotePassword: remotePassword 	^ self sendTo: hostname		requestID: CoastConstant pauseGCID		andStrings: ( Array with: remotePassword with: volumename )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ].</body><body package="COBase">sizeOfBlobOrCluster: clusterID in: volume atHost: hostname 	^  self sendTo: hostname		requestID: CoastConstant blobOrClusterSize		andStrings: ( Array with: volume )		sendStreamDo: [: sendStream | sendStream nextOptimized32Put: clusterID ]		receiveStreamDo: [: receiveStream | 			self checkValidResponseFrom: receiveStream.			receiveStream nextUnsigned32 		].</body><body package="COBase">startGCAtHost: hostname volume: volumename remotePassword: remotePassword 	^ self sendTo: hostname		requestID: CoastConstant startGCID		andStrings: ( Array with: remotePassword with: volumename )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ].</body><body package="COBase">statusGCAtHost: hostname volume: volumename remotePassword: remotePassword 	^ self 		sendTo: hostname		requestID: CoastConstant statusGCID		andStrings: ( Array with: remotePassword with: volumename )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ]</body><body package="COBase">stopGCAtHost: hostname volume: volumename remotePassword: remotePassword 	^ self sendTo: hostname		requestID: CoastConstant stopGCID		andStrings: ( Array with: remotePassword with: volumename )		receiveStreamDo: [: receiveStream | CoastStatusResponse fromStream: receiveStream ].</body></methods><methods><class-id>COAST.CoastMediatorStub class</class-id> <category>mediator services - private</category><body package="COBase">checkValidResponseFrom: receiveStream 	| statusResponse errorClass |	statusResponse := CoastStatusResponse fromStream: receiveStream.	statusResponse ok 		ifFalse: [ 			errorClass := CoastError classForStatusResponse: statusResponse.			errorClass raiseSignal: statusResponse message 		].	^statusResponse</body><body package="COBase">sendTo: hostname requestID: requestID andStrings: strings receiveStreamDo: receiveBlock	^ self sendTo: hostname requestID: requestID andStrings: strings sendStreamDo: [: nope | ] receiveStreamDo: receiveBlock</body><body package="COBase">sendTo: hostname requestID: requestID andStrings: strings sendStreamDo: sendBlock receiveStreamDo: receiveBlock 	" send the request and read the response. 	returns the result of the receiveBlock "	| aSocketAccessor coastSocketAccessor |	coastSocketAccessor := aSocketAccessor := nil.	^ [	aSocketAccessor := SocketAccessor defaultClass newTCPclientToHostAndPort: hostname defaultPort: self defaultServerPort.		( aSocketAccessor notNil and: [ aSocketAccessor isActive ]) 			ifFalse: [ CoastError raiseSignal: 'Could not open a socket for sending a request to ' , hostname ].		coastSocketAccessor := CoastSocketAccessor connectSocketAccessor: aSocketAccessor.		[ | sendStream |			sendStream := coastSocketAccessor writeStream binary.			[ | receiveStream |				sendStream nextPut: requestID.				CatRMPacketStation marshallVersionOn: sendStream.				strings do: [: str | sendStream nextCoastStringPut: str ].				sendBlock value: sendStream.				sendStream flush.				receiveStream := coastSocketAccessor readStream binary.				[						[ receiveBlock value: receiveStream ] 						on: EndOfStreamNotification						from: receiveStream coreStream						do: [: ex | CoastError raiseSignal: 'Unexpected end of stream while waiting for response' ]				] ensure: 					[							[ receiveStream close ] on: Error do: [: ex | ]					]			] ensure: 				[						[ sendStream close ] on: Error do: [: ex | ]				]		] ensure: 			[					[ coastSocketAccessor close ] on: Error do: [: ex | ]			]	] on: OsError do: [: ex | ex resignalAs: ( CoastError new messageText: ex description )]</body></methods><methods><class-id>COAST.CoastMediatorStub class</class-id> <category>accessing</category><body package="COBase">defaultServerPort	^ 30000 + ( 10 * CoastVersion defaultCoastMajorVersion ) + CoastVersion defaultCoastMinorVersion</body></methods><methods><class-id>COAST.CoastMediatorStub class</class-id> <category>mediator services - deprecated</category><body package="COBase">volumesAtHost: hostname 	" compatibility "	^ CoastMediatorStub 		sendTo: hostname		requestID: CoastConstant volumes		andStrings: Array new		receiveStreamDo: 		[: receiveStream | | volumeCount volumes |			self checkValidResponseFrom: receiveStream.			volumeCount := receiveStream nextOptimized32.			volumes := OrderedCollection new: volumeCount.			volumeCount timesRepeat: [ volumes add: receiveStream nextCoastString ].			volumes 		].</body></methods><methods><class-id>COAST.CatRMUpdateMultipartTransaction</class-id> <category>accessing</category><body package="COTransactions">clusterControllers: anOrderedCollection	clusterControllers := anOrderedCollection</body><body package="COTransactions">simpleAgendas: anOrderedCollection	simpleAgendas := anOrderedCollection</body></methods><methods><class-id>COAST.CatRMUpdateMultipartTransaction</class-id> <category>rolling</category><body package="COTransactions">doCreations	"this method is for replaying the frame and slot creations of my agendas"	simpleAgendas with: clusterControllers do: [ :sa :cc | sa doCreationsForClusterController: cc ].</body><body package="COTransactions">rollForward	"first do all creations and then all accesses"	"if not done in this order we might get write accesses to not yet created frames or slots"	self doCreations.	self rollForwardAccesses.</body><body package="COTransactions">rollForwardAccesses	"this method is for replaying the accesses stored in my agendas"	simpleAgendas with: clusterControllers		do: 		[: sa : cc |			sa rollForwardAccessesForClusterController: cc.		].	simpleAgendas with: clusterControllers		do: 		[: sa : cc |			sa doRemovesForClusterController: cc		].</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>config</category><body package="COBase">checkCommandLineFor: application 	" Parse all known command line parameters of the configuration and the application "	| cmdLine possibleParameters |	cmdLine := CommandLineOverride 			ifNotNil: 			[: overridenCommandLine |				CoastLog logWarning: 'Using overriden command line: ' , overridenCommandLine printString.				overridenCommandLine			]			ifNil: 			[	" first command line element is the VM / packed executable "				CEnvironment commandLine asOrderedCollection removeFirst;					yourself			].	possibleParameters := OrderedCollection new.	possibleParameters addAll: self commandLineParameters.	possibleParameters addAll: application commandLineParameters.	CommandLineParameter parseCommandLine: cmdLine parameters: possibleParameters.</body><body package="COBase">configure: application 	" perform all configuration tasks "	self isSubConfiguration 		ifFalse: 		[	self checkCommandLineFor: application.			self configureLog		].	self evaluatePreConfigurationBlocksFor: application.	self isSubConfiguration 		ifFalse: 		[	self configurePublicKeys.			self configureNetwork.			self configureVolumeAccessorClass		].	self configureCoastCore: application.	self isSubConfiguration 		ifFalse: [ self configurePragmas ].	self configureApplicationPragmasFor: application.	serviceAction notNil 		ifTrue: [ serviceAction value: self ].</body><body package="COBase">configureApplicationPragmasFor: application 	application transactionManager ifNotNil: [: transactionManager | self configurePragma: #transactionManagerConfiguration for: transactionManager ].	self configurePragma: #applicationConfiguration for: application.</body><body package="COBase">configureCoastCore: application 	| segmentSplitSize |	segmentSplitSize := self segmentSplitSize.	segmentSplitSize notNil ifTrue: [ application volumeManager segmentSplitSize: segmentSplitSize ].</body><body package="COBase">configureNetwork	| bufferSize windowSize noDelay |	bufferSize := self iniAccess numberAt: 'networkBufferSize' ifAbsent: [ nil ].	bufferSize notNil 		ifTrue: 		[	SocketAccessor coastStreamBufferSize: bufferSize asInteger.			CoastLog log: 'Network buffer size: ' , bufferSize coastShortByteSizePrintString		].	windowSize := self iniAccess numberAt: 'tcpWindowSize' ifAbsent: [ nil ].	windowSize notNil 		ifTrue: 		[	SocketAccessor coastWindowSize: windowSize asInteger.			SocketAccessor coastWindowSize 				ifNotNil: [: ws | CoastLog log: 'TCP window size: ' , ws coastShortByteSizePrintString ]				ifNil: [ CoastLog log: 'Using default TCP window size' ]		].	noDelay := self iniAccess booleanAt: 'tcpNoDelay' ifAbsent: [ nil ].	noDelay notNil 		ifTrue: 		[	SocketAccessor coastNoDelay: noDelay.			CoastLog log: 'TCP no delay: ' , noDelay printString		].</body><body package="COBase">configurePluginPragmasFor: application 	self 		configurePragma: #pluginConfiguration for: nil;		configurePragma: #pluginTransactionManagerConfiguration for: application transactionManager;		configurePragma: #pluginApplicationConfiguration for: application.</body><body package="COBase">configurePragma: pragmaSymbol for: object	(Pragma allNamed: pragmaSymbol from: self class to: CoastApplicationConfiguration)		do: [ : pragma |			object isNil 				ifTrue: [ 	self perform: pragma selector. ]				ifFalse: [ self perform: pragma selector with: object. ].			].</body><body package="COBase">configurePragmas	self configurePragma: #configuration for: nil.</body><body package="COBase">configureTransactionManagerPragmasFor: transactionManager 	#( 		#transactionManagerConfiguration 		#pluginTransactionManagerConfiguration 	) do: [: symbol | self configurePragma: symbol for: transactionManager ].</body><body package="COBase">createMemoryPolicy	" install and configure a new memory policy. must be explicitly called. due to new refactoring this standard call is mapped on downwards"		^self createMemoryPolicyFor: nil</body><body package="COBase">createMemoryPolicyFor: applicationOrNil 	" install and configure a new memory policy. must be explicitly called "	| memoryPolicyClass memoryUpperBound memoryPolicy freeBound grub |	memoryPolicyClass := self memoryPolicyClassFor: applicationOrNil.	memoryPolicy := memoryPolicyClass new setDefaults.	memoryUpperBound := self maxMemory.	freeBound := self freeMemoryBound.	grub := self growthRegimeUpperBound.	memoryPolicy		memoryUpperBound: memoryUpperBound;		freeMemoryUpperBound: freeBound;		growthRegimeUpperBound: grub;		preferredGrowthIncrement: self preferredGrowthIncrement;		growthRetryDecrement: self growthRetryDecrement;		lowSpaceHandlerMargin: self lowSpaceMargin.	ObjectMemory		installMemoryPolicy: memoryPolicy;		installLowSpaceProcess.	ObjectMemory hardLowSpaceLimit: self hardLowSpaceLimit.	memoryPolicy contiguousSpaceSafetyMargin: self contiguousSpaceSafetyMargin.	self logCreatedMemoryPolicy: memoryPolicy.	^ memoryPolicy</body><body package="COBase">evaluatePreConfigurationBlocksFor: application	preConfigurationBlocks notNil ifTrue:	[		preConfigurationBlocks do: [ : cfgBlock | cfgBlock value: application ]	]</body><body package="COBase">logCreatedMemoryPolicy: memoryPolicy	| str |	str := (String new: 64) writeStream.	memoryPolicy addDumpInfoTo: str.	CoastLog log: str contents.	CoastLog log: 'Object memory sizes: ', ObjectMemory sizesAtStartup printString.</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>parameters - memory</category><body package="COBase">contiguousSpaceSafetyMargin	^ self iniAccess memoryAt: 'contiguousSpaceSafetyMargin' ifAbsent: [ self hardLowSpaceLimit ]</body><body package="COBase">enableLowSpaceHandler	" true if the default lowSpaceHandler should be installed "	" use lowSpaceMargin to configure the condition "	^ self iniAccess booleanAt: 'enableLowSpaceHandler' ifAbsent: [ false ]</body><body package="COBase">freeMemoryBound	" VM will try to free memory (give back to the OS) if more memory than this parameter is available in OldSpace"	^ self iniAccess memoryAt: 'freeMemoryUpperBound' ifAbsent: [self iniAccess memoryAt: 'freeMemoryBound' ifAbsent: [ 2 * self preferredGrowthIncrement ]].</body><body package="COBase">growthRegimeMarginFactor	" minimal difference between growth regime and max memory, relative to max memory "	^ 0.3</body><body package="COBase">growthRegimeMarginMin	" minimal difference between growth regime and max memory "	^ 16r10000000</body><body package="COBase">growthRegimeUpperBound	| growthRegimeUpperBound maxMem |	maxMem := self maxMemory.	growthRegimeUpperBound := self iniAccess 			memoryAt: 'baseMemory'			ifAbsent: 			[	self iniAccess 					memoryAt: 'growthRegimeUpperBound'					ifAbsent: 					[ | safetyMargin |						maxMem &gt; 16r20000000 							ifTrue: 							[	" leave some room "								safetyMargin := ( self maxMemory * self growthRegimeMarginFactor ) ceiling max: self growthRegimeMarginMin.								maxMem - safetyMargin							]							ifFalse: [ maxMem // 2 ]					]			].	^ growthRegimeUpperBound min: maxMem</body><body package="COBase">growthRetryDecrement	" see Resolution 96812 "	^ self iniAccess numberAt: 'growthRetryDecrement' ifAbsent: [ 2 ** 15 ].</body><body package="COBase">hardLowSpaceLimit	^ self iniAccess 		memoryAt: 'hardLowSpaceLimit'		ifAbsent: 		[ | memStatus |			memStatus := ObjectMemory current.			ObjectMemory hardLowSpaceLimit max: ( memStatus edenBytes max: memStatus survBytes ) * 4		]</body><body package="COBase">incGCAccelerationFactor	" preferredGrowthIncrement (old space)"	^ self iniAccess numberAt: 'incGCAccelerationFactor' ifAbsent: [ nil ]</body><body package="COBase">lowSpaceMargin	" if there is less free memory than this value, low space actions will be performed "	" if there is no lowSpaceHandler, than this parameter has no effect "	| value |	value := self iniAccess memoryAt: 'lowSpaceMargin' ifAbsent: [ 10 ].	^ value max: 5242880	"5*(1024*1024)"</body><body package="COBase">maxMemory	" max. available memory for the VM "	| configuredMaxMemory maxPhysicalMemory actualMaxMemory |	maxMemory isNil 		ifTrue: 		[	maxPhysicalMemory := OSSystemSupport concreteClass new coastMaxMemory.			configuredMaxMemory := self iniAccess memoryAt: 'maxMemory' ifAbsent: [ nil ].			maxMemory := configuredMaxMemory notNil 					ifTrue: 					[	actualMaxMemory := ( configuredMaxMemory max: self maxMemoryLowerLimit ) min: maxPhysicalMemory.						actualMaxMemory ~= configuredMaxMemory 							ifTrue: 							[	CoastLog 									logWarning: 'maxMemory set to ' , actualMaxMemory coastShortByteSizePrintString , ' instead of ' , configuredMaxMemory coastShortByteSizePrintString							].						actualMaxMemory					]					ifFalse: [ maxPhysicalMemory ]		].	^ maxMemory</body><body package="COBase">maxMemoryLowerLimit	^ 52428800 	"50*(1024*1024)"</body><body package="COBase">preferredGrowthIncrement	" preferredGrowthIncrement (old space).	see Resolution 96812 "	^ self iniAccess memoryAt: 'preferredGrowthIncrement' ifAbsent: [ 16 ].</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>accessing - information</category><body package="COBase">fullInfoString	| str |	str := (String new: 256)  writeStream.	self infoString notNil		ifTrue: [ str nextPutAll: self infoString;cr ].	self infoDict keysAndValuesDo: [ : key : value |		str nextPutAll: key; nextPutAll: ': '; nextPutAll: value;cr.	].	^ str contents</body><body package="COBase">infoDict	" dictionary with additional information "	^ infoDict</body><body package="COBase">infoDictAt: aKey put: aString	self infoDict at: aKey put: aString</body><body package="COBase">infoString	" string with additional information "	^ infoString</body><body package="COBase">infoString: aString	infoString := aString.</body><body package="COBase">logInfo	CoastLog singleton		cr;		log: 'Environment:' , self fullInfoString.</body><body package="COBase">shutDownTimeout	^ self iniAccess numberAt: 'shutDownTimeout' ifAbsent: [ 10 ]</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>accessing</category><body package="COBase">defaultIniFilename	^ defaultIniFilename ifNil: [  'config.ini' ]</body><body package="COBase">defaultIniFilename: aDefaultIniFilename 	defaultIniFilename := aDefaultIniFilename.</body><body package="COBase">defaultLogFilename: aFilenameOrNil	" set the default log filename (used when neither cmdline or ini ovverride the log settings) "	defaultLogFilename := aFilenameOrNil.	logFilename := defaultLogFilename.	aFilenameOrNil notNil ifTrue: [ CoastLog singleton transcriptFilename: aFilenameOrNil ]</body><body package="COBase">iniAccess	| file |	iniAccess isNil		ifTrue: [			iniAccess := (self iniFilename notNil and: [ (file := self iniFilename asFilename) definitelyExists or: [ self needsIni not and: [ file canBeWritten ]]])				ifTrue: [ 	iniAccess := CoastIniAccess readFile: file ].			iniAccess isNil				ifTrue: [ " load failed "					self needsIni						ifTrue: [ self error: 'Could not process ini file: ' , self iniFilename printString ]						ifFalse: [ 							CoastLog logDebug: 'Could not process ini file: ' , self iniFilename printString.							iniAccess := CoastIniAccess new						].				].		].	^ iniAccess</body><body package="COBase">iniAccess: aCoastIniAccess	iniAccess := aCoastIniAccess</body><body package="COBase">iniFilename	^ iniFilename ifNil: [ self defaultIniFilename ]</body><body package="COBase">iniFilename: aFilenameOrString	iniFilename := aFilenameOrString</body><body package="COBase">isWindowsService	^ serviceName notNil</body><body package="COBase">needsIni	^ needsIni ifNil: [ true ]</body><body package="COBase">needsIni: aBoolean	needsIni := aBoolean</body><body package="COBase">parentConfiguration	^ parentConfiguration</body><body package="COBase">parentConfiguration: aParentConfiguration 	parentConfiguration := aParentConfiguration.</body><body package="COBase">serviceAction: aBlock	serviceAction := aBlock.</body><body package="COBase">serviceName: sname	serviceName := sname.</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>initialize-release</category><body package="COBase">cmdString	| cmd nextTokenIsPassword |	cmd := String new writeStream.	nextTokenIsPassword := false.	CEnvironment commandLine 		do: [ : token |			nextTokenIsPassword 				ifTrue: [					nextTokenIsPassword := false.					cmd nextPutAll: '***'.					]				ifFalse: [ 					nextTokenIsPassword := '*password*' match: token.					(token contains: [ : c | #(9 10 13 32) includes: c asInteger])						ifTrue: [ cmd nextPut: $"; nextPutAll: token; nextPut: $". ]						ifFalse: [ cmd nextPutAll: token. ].					].			]		separatedBy: [ cmd space. ].	^ cmd contents</body><body package="COBase">initialize	Current := self.	self initializeInfoDict.</body><body package="COBase">initializeInfoDict	infoDict := Dictionary new.	infoDict 		at: 'pid' put: OSHandle currentProcessID printString;		at: 'os' put: OSHandle currentPlatformID;		at: 'cmd' put: self cmdString;		at: 'build' put: CoastVersion buildString;		at: 'platform' put: ObjectMemory versionId printString;		at: 'vm' put: CoastVersion vmVersionString;		at: 'image' put:  CoastVersion imageVersionString.	[	infoDict at: 'coast' put: (CoastVersion versionOf: 'COASTCore').	] on: Error do: [ : ex | ].	[	infoDict at: 'locale' put: CompositeLocale preferredLocaleName.	] on: Error do: [ : ex | ].	"Macht an dieser Stelle keinen Sinn (so glaube ich), da die MemoryPolicy spÃ¤ter die Werte gesetzt bekommt	und dabei selbst einen Log-Eintrag schreibt	[	infoDict at: 'memoryBound' put: (ObjectMemory currentMemoryPolicy memoryUpperBound printFormat: '#,#').	] on: Error do: [ : ex | ]."</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>private</category><body package="COBase">addPreConfigurationBlock: aBlock	preConfigurationBlocks isNil ifTrue: [ preConfigurationBlocks := OrderedCollection new ].	preConfigurationBlocks add: aBlock</body><body package="COBase">configureLog	"look for the inifile with caution"	[ CoastLog singleton initializeFromIni: self iniAccess ] on: Error		do: 		[: ex |			"initializeCoastLog to ensure that this fatal error can be logged to destination file"			logFilename isNil ifTrue: [ logFilename := 'coast.log'. ].			self initializeCoastLog.			CoastLog logException: ex message: 'Error in inifile initialization!'.			ex pass		].	self initializeCoastLog.</body><body package="COBase">configurePublicKeys	( self iniAccess category: CoastConstant iniAccessBuildIDPrefix , CoastVersion dummyPublicFingerPrint asHexString ) notNil ifTrue: 		[	"trust all, do not challenge"			CoastVersion disabledChallenge.			^ CoastLog log: 'disable peer challenge' channel: #crypto		].	self iniAccess categorySet do: 		[: cat | | n e fingerPrint |			( cat size &gt; CoastConstant iniAccessBuildIDPrefix size 				and: [( cat copyFrom: 1 to: CoastConstant iniAccessBuildIDPrefix size ) = CoastConstant iniAccessBuildIDPrefix ]) ifTrue: 				[	n := self getHexIniValueAt: 'rsa.n' category: cat.					e := self getHexIniValueAt: 'rsa.e' category: cat.					fingerPrint := CoastVersion addTrustedPublicKey: ( Security.RSAPublicKey e: e n: n ).					"check consistency"					( CoastConstant iniAccessBuildIDPrefix , fingerPrint asHexString ) = cat 						ifFalse: [ CoastError raiseSignal: self iniFilename asString , ': invalid fingerprint ' , cat ].					CoastLog logDebug: [ 'added peer fingerprint: ' , fingerPrint asHexString ] channel: #crypto				]		].</body><body package="COBase">getHexIniValueAt: name category: cat 	| hexString stream count |	stream := String new readWriteStream.	count := 1.	[	hexString := self iniAccess category: cat stringAt: name , '_' , count printString ifAbsent: [ nil ].		hexString notNil	] whileTrue: 		[	stream nextPutAll: hexString.			count := count + 1		].	count = 1 ifTrue: [ CoastError raiseSignal: self iniFilename asString , ': missing parameter ' , cat , ':' , name ].	stream reset.	^ Integer readFrom: stream radix: 16</body><body package="COBase">initializeCoastLog	" cmdline overrides default and ini settings 	(logFilename is specified by the cmdline, defaultLogFilename by the application) "	logFilename = defaultLogFilename		ifFalse: [ CoastLog singleton transcriptFilename: logFilename ].	CoastLog singleton setupTranscript.</body><body package="COBase">isSubConfiguration	^ parentConfiguration notNil</body><body package="COBase">logFilename	^ logFilename ifNil: [ defaultLogFilename ]</body><body package="COBase">memoryPolicyClassFor: applicationOrNil	| className |	className := self iniAccess at: 'memoryPolicy' ifAbsent: [ applicationOrNil notNil ifTrue: [ applicationOrNil memoryPolicyClassString ] ifFalse: [ 'COAST.CoastMemoryPolicy' ]].	^ className asQualifiedReference 		ifDefinedDo: [: cl | cl ]		elseDo: 		[	CoastLog logError: 'Unknown memoryPolicy class: ' , className printString.			CoastMemoryPolicy		]</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>config - OS specific</category><body package="COBase">createWinService	" remember the service so that it is not GC'd "	^ (winService := CoastWinService serviceName: serviceName)</body><body package="COBase">deinstallService: newServiceName	" deinstall a windows service "	(CoastWinService serviceName: newServiceName) deinstallService</body><body package="COBase">onUnixSignals: signalList do: aBlock	" listen for Unix signals "	| sem |	OSHandle currentOS == #unix ifFalse: [ ^ false ].	sem := Semaphore new.	signalList do: [ : signalName |		ObjectMemory registerObject: sem withEngineFor: signalName	].	[		sem wait.		aBlock value.	] forkAt: Processor userInterruptPriority.	^ true</body><body package="COBase">startAsService: startUpBlock postStartBlock: postStartBlock shutdownBlock: shutdownBlock 	self createWinService startAsService: startUpBlock postStartBlock: postStartBlock shutdownBlock: shutdownBlock.</body><body package="COBase">startAsService: startUpBlock shutdownBlock: shutdownBlock 	self createWinService startAsService: startUpBlock shutdownBlock: shutdownBlock</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>parameters - framesystem</category><body package="COBase">segmentSplitSize	^ self iniAccess numberAt: 'segmentSplitSize' ifAbsent: [ nil ]</body></methods><methods><class-id>COAST.CoastApplicationConfiguration</class-id> <category>private - command line</category><body package="COBase">commandLineParameters	^ CommandLineParameter commandLineParametersOf: self</body><body package="COBase">commandlinePragmas	"fast die gleiche Implementierung wie	CoastApplication &gt;&gt; #commandlinePragmas"	| pragmas |	pragmas := Pragma					allNamed: #commandlineParameter:canPerform:aliases:usage:help:					from: self class					to: CoastApplicationConfiguration.	^ pragmas reject: [ : pragma |		(pragma argumentAt: 2)			ifNil: [ false ]			ifNotNil: [ : canPerform | (self class perform: canPerform) not ]		]</body><body package="COBase">errorInCommandLine: aString	CoastLog enableConsoleWhile: [ CoastLog logError: aString ].	CoastError raiseSignal: aString.</body></methods><methods><class-id>COAST.CoastApplicationConfiguration class</class-id> <category>accessing</category><body package="COBase">current	^ Current</body><body package="COBase">current: config	Current := config</body></methods><methods><class-id>COAST.CoastApplicationConfiguration class</class-id> <category>instance creation</category><body package="COBase">defaultLogFilename: defaultLogFilename defaultIniFilename: defaultIniFilename needsIni: aBoolean	^ self new		defaultLogFilename: defaultLogFilename;		defaultIniFilename: defaultIniFilename;		needsIni: aBoolean;		yourself.</body><body package="COBase">new	^ super new initialize</body></methods><methods><class-id>COAST.CoastApplicationConfiguration class</class-id> <category>utilities</category><body package="COBase">safeStartupDo: aBlock 	" this method can be used to wrap the startup of an application "	^ [	aBlock on: CoastCommandLineError			do: 			[: ex |				CoastLog enableConsoleWhile: [ CoastLog logError: ex description ].				Notifier isDevelopment 					ifTrue: [ self haltOrContinue: ex description ]					ifFalse: [ ObjectMemory quitWithError: CoastExitCode badParameter ]			]	] on: Error		do: 		[: ex |						[ | filename |				filename := CEnvironment commandLine first asFilename directory construct: 'error.log'.				Notifier headlessDo: 					[: headlessImage |						CoastLog singleton transcriptFilename isNil ifTrue: 							[	headlessImage transcriptFilename: filename;									setupTranscript							].						( CoastLog singleton )							cr;							show: ex description; cr;							cr.						headlessImage dumpStackToTranscript: thisContext label: 'Startup failed'					]			] on: Error do: [: e | self haltOrContinue: e description ].			Notifier isDevelopment 				ifTrue: [ self haltOrContinue: ex description ]				ifFalse: [ ObjectMemory quitWithError: CoastExitCode unhandledException ].			nil		]</body><body package="COBase">showText: text	Notifier isDevelopment ifTrue: [ ^ Transcript show: text ].	Notifier isHeadless 		ifTrue:	[ CoastLog enableConsoleWhile: [ CoastLog show: text. ]. ]		ifFalse:	[ #{UI.Dialog}					ifDefinedDo: [ : cl | cl chooseReport: text labels: (Array with: (#OK &lt;&lt; #labels &gt;&gt; 'OK')) values: #(nil) default: nil for: nil  ]					elseDo: [ CoastLog enableConsoleWhile: [ CoastLog show: text. ]. ].				].	"Anmerkung am Rande:	#enableConsoleWhile: ist derzeit (seit 14.01.2009) ohne Funktion"</body></methods><methods><class-id>COAST.AccessConflict</class-id> <category>accessing</category><body package="COTransactions">conflictingAccess	^ conflictingAccess</body><body package="COTransactions">conflictingAccess: remoteCellAccess 	conflictingAccess := remoteCellAccess.</body><body package="COTransactions">ownAccess	^ ownAccess</body><body package="COTransactions">ownAccess: remoteCellAccess 	ownAccess := remoteCellAccess.</body></methods><methods><class-id>COAST.AccessConflict</class-id> <category>printing</category><body package="COTransactions">printOn: aStream	| clusterID |	aStream nextPutAll: self class name; space.		clusterID := conflictingAgenda clusterID.	(ownAccess ccPrintStringOn: aStream withClusterID: clusterID).	aStream nextPutAll: ' conflicts with: Transaction '.	self printConflictingClientOn: aStream.	aStream nextPutAll: ' '.	(conflictingAccess ccPrintStringOn: aStream withClusterID: clusterID)</body></methods><methods><class-id>COAST.AccessConflict class</class-id> <category>instance creation</category><body package="COTransactions">conflictingAgenda: aConflictingAgenda conflictingAccess: remoteCellAccess1 ownAccess: remoteCellAccess2	^ (self conflictingAgenda: aConflictingAgenda)		conflictingAccess: remoteCellAccess1;		ownAccess: remoteCellAccess2;		yourself</body></methods><methods><class-id>COAST.CatCOIntegerKeyDictionary</class-id> <category>private</category><body package="COBase">findKeyOrNil: key  	" large keys are not identical, so use equality instead "	| index length probe pass |	length := self basicSize.	pass := 1.	index := self initialIndexFor: key hash boundedBy: length.	[(probe := self basicAt: index) == nil or: [probe = key]]		whileFalse: [(index := index + 1) &gt; length				ifTrue: 					[index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^index</body><body package="COBase">fullCheck	"If there is insufficient capacity in the receiver to do efficient lookups,	 then grow.  Require at least 50% free slots, or 1 free slot, whichever	 is the greater."	| cap sizePlusOne |	cap := self capacity.	sizePlusOne := self size + 1.	(sizePlusOne &gt;= cap or: [cap - sizePlusOne &lt; (cap bitShift: -1)])		ifTrue: [self grow]</body><body package="COBase">initialIndexFor: aHashValue boundedBy: length 	" optimize for large dictionaries with relatively even spread hash values "	^ ((( aHashValue \\ length ) * 4 ) \\ length ) + 1</body></methods><methods><class-id>COAST.CatCOIntegerKeyDictionary</class-id> <category>statistics</category><body package="COBase">printStatisticsTo: stream	| sumSeekSize maxSeekSize length initialIndex finalIndex numSmallIntegers |	sumSeekSize := 0.	maxSeekSize := 0.	length := self basicSize.	numSmallIntegers := 0.	self keysDo: [ : key |		| seekSize |		key coastIsSmallInteger ifTrue: [ numSmallIntegers := numSmallIntegers + 1].		initialIndex := self initialIndexFor: key hash boundedBy: length.		finalIndex := self findKeyOrNil: key.		seekSize := finalIndex &gt;= initialIndex			ifTrue: [ finalIndex - initialIndex ]			ifFalse: [ length - initialIndex + finalIndex ].		sumSeekSize := sumSeekSize + seekSize.		maxSeekSize := maxSeekSize max: seekSize.	].	stream nextPutAll: 'Avg. seek size: '.	stream nextPutAll: (sumSeekSize / self size) asFloat printString.	stream nextPutAll: ' Max. seek size: '.	stream nextPutAll: maxSeekSize printString.	stream nextPutAll: ' Small Integer keys: '.	stream nextPutAll: (numSmallIntegers * 100 / self size) rounded printString.	stream nextPutAll: '%'.</body></methods><methods><class-id>COAST.CatRMTryMessage</class-id> <category>accessing</category><body package="COTransactions">applicationLog	applicationLog isNil		ifTrue: [ applicationLog := CatCSApplicationLog new ].	^ applicationLog</body><body package="COTransactions">applicationLog: aCatCSApplicationLog	applicationLog := aCatCSApplicationLog</body></methods><methods><class-id>COAST.CatRMTryMessage</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall	super marshallBinaryTo: aStream marshaller: aCatRMMarshall.	self applicationLog marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COTransactions">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	super unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager.	applicationLog := CatCSApplicationLog unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>caching client services</category><body package="COBase">clearCache	^252</body><body package="COBase">getCachedBlob	^254</body><body package="COBase">putBlobToCache	^253</body><body package="COBase">shutDownCache	^251</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>ini labels</category><body package="COBlockFileSystem">iniAccessBFSBlockSize	^ 'bfsBlockSize'</body><body package="COBlockFileSystem">iniAccessBFSGrowSize	^ 'bfsGrowSize'</body><body package="COBlockFileSystem">iniAccessBackgroundProcessPriority	^ 'bfsBackgroundProcessPriority'</body><body package="COBase">iniAccessBackupDirectory	"string for iniAccess for backup directory"	^ 'backupDirectory'</body><body package="COBase">iniAccessBaseDirectory	"answer the default base directory"	^ 'baseDirectory'</body><body package="COBase">iniAccessBuildIDPrefix	^ 'buildID.'</body><body package="COBase">iniAccessSkipVolumesCheck	^ 'skipVolumesCheck'</body><body package="COBase">iniAccessStartBlobService	^ 'startBlobService'</body><body package="COBase">iniAccessUseSSL	^ 'useSSL'</body><body package="COBase">iniAccessVolumesDirectory	"answer the default volume directory"	^ 'volumesDirectory'</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>directories</category><body package="COBase">defaultBackupDirectory	^ 'backup'</body><body package="COBase">defaultVolumeDirectory	"answer the default base directory for ini access	OR	the default volume directory"	^ 'volumes'</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>response strings</category><body package="COBase">responseStringBackupStarted	^ 'Backup started'</body><body package="COBase">responseStringOk	^ 'ok'</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>application description</category><body package="COBase">applicationBuildString	^'buildString'</body><body package="COBase">applicationCoastVersion	^'coastVersion'</body><body package="COBase">applicationImageVersion	^'imageVersion'</body><body package="COBase">applicationMD5FingerPrint	^ 'md5FingerPrint'</body><body package="COBase">applicationOS	^'os'</body><body package="COBase">applicationVMVersion	^'vmVersion'</body><body package="COBase">clientProcessID	^'processID'</body><body package="COBase">clientType	^'type'</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>client authentication</category><body package="COClusterManagement">authenticationOK	^ 1</body><body package="COClusterManagement">authenticationRejected	^ 2</body><body package="COClusterManagement">protocolVersion	" 		3: client description beim Verbindungsaufbau mitliefern		2: File up/download ohne Checksum		1: initiale Version, bei Umbau der Status responses mit eingebaut 	"	^ 3</body></methods><methods><class-id>COAST.CoastConstant class</class-id> <category>agenda flags</category><body package="COTransactions">noConcurrencyNag	^ 1</body></methods><methods><class-id>COAST.CatCSFastReadTransaction</class-id> <category>testing</category><body package="COTransactions">agendaNotEmpty	^false</body><body package="COTransactions">canUnloadClusters	^ true</body><body package="COTransactions">canWrite	^ false</body><body package="COTransactions">referencesClusterWithID: clusterID	^ false</body></methods><methods><class-id>COAST.CatCSFastReadTransaction</class-id> <category>initialize - release</category><body package="COTransactions">defaultCollectionSize	^ 1</body><body package="COTransactions">initialSizeForAccesses	^0</body><body package="COTransactions">initialize	isFastRead := true.	^super initialize</body></methods><methods><class-id>COAST.CatCSFastReadTransaction</class-id> <category>accessing</category><body package="COTransactions">hasOutstandingCompositions	"don't handle outstanding compositions before displayPhase"	^ super hasOutstandingCompositions and: [ self inDisplayPhase ]</body><body package="COTransactions">unloadClusters	| vm | 	vm := self transactionManager volumeManager.	vm interruptProtectDo:	[		self unloadClustersForVolumeManager: vm.	].</body></methods><methods><class-id>COAST.CatCSFastReadTransaction</class-id> <category>private</category><body package="COTransactions">keepClusterIDs	^ self transactionManager eagerObservers inject: Set new		into: 		[: result : eo |			result				addAll: eo referencedClusterIDs;				yourself		]</body></methods><methods><class-id>COAST.CatCSFastReadTransaction</class-id> <category>execution</category><body package="COTransactions">abort	" Abort the transaction. Undo everything which has changed (=nothing!) "	Notifier isDevelopment ifTrue: [ CoastLog log: 'Aborted a fast read transaction' ].</body><body package="COTransactions">propagateWith: aCatCSTransactionManager	^ #accepted</body></methods><methods><class-id>COAST.CatCSFastReadTransaction</class-id> <category>agenda handling</category><body package="COTransactions">recordAccess: aCatCSCellAccess 	(aCatCSCellAccess isReadAccess) ifTrue: [ ^self ]. "no need to record read accesses"	(aCatCSCellAccess isUpdateAccess and: [ aCatCSCellAccess cell hasNoDemons ]) ifTrue: [ ^self  ].	(aCatCSCellAccess isLocalCell ) ifTrue: [ ^super recordAccess: aCatCSCellAccess ].	self error: 'FastTransaction cannot record accesses to shared slots'</body><body package="COTransactions">recordCellCreation: aCatCSCell 	" It's not possible to make this cell shared "	aCatCSCell makeLocal</body></methods><methods><class-id>COAST.CatCSFastReadTransaction</class-id> <category>access handling</category><body package="COTransactions">rememberAccessIfFirst: cellAccess	(cellAccess isUpdateAccess and: [ cellAccess cell hasNoDemons ]) ifTrue: [ ^self  ].	cellAccess isLocalCell ifTrue: [ ^super rememberAccessIfFirst: cellAccess ].	self error: 'FastTransactions cannot remember accesses to shared slots'</body></methods><methods><class-id>COAST.CatCSUnmanagedTransaction</class-id> <category>access handling</category><body package="COTransactions">rememberAccessIfFirst: cellAccess	(cellAccess isUpdateAccess and: [ cellAccess cell hasNoDemons ]) ifTrue: [ ^self  ].	cellAccess isLocalCell ifTrue: [ ^ self  ].	self error: 'Unmanaged transactions cannot remember accesses to shared slots'</body></methods><methods><class-id>COAST.ClassNameManager</class-id> <category>private</category><body package="COBase">defaultNameSpaces	" returns the default namespaces.	these will be used when a class name without namespace is found "	^ defaultNameSpaces</body><body package="COBase">defaultNameSpaces: someNameSpaces	defaultNameSpaces := someNameSpaces</body><body package="COBase">getClassForCoastClassName: coastClassName 	^ ( coastClassName includes: $. ) 		ifTrue: [( StrictBindingReference pathString: coastClassName ) valueOrDo: nil ]		ifFalse: [ self getClassForSimpleName: coastClassName ]</body><body package="COBase">getClassForLocalName: className in: nameSpaces	| classSymbol |	classSymbol := className asSymbol.	nameSpaces do: [ :nameSpace | | theClass |		(theClass := nameSpace at: classSymbol ifAbsent: nil) notNil			ifTrue: [ ^ theClass ].	].	^ nil</body><body package="COBase">getClassForSimpleName: className	" className contains no namespace "	^ self getClassForLocalName: className in: self defaultNameSpaces</body><body package="COBase">systemNameSpaceFrom: systemNameSpaceString	| systemNameSpace |	systemNameSpace := (StrictBindingReference pathString: systemNameSpaceString) valueOrDo: nil.	systemNameSpace isNil		ifTrue: [ self halt: 'The namespace ', systemNameSpaceString, ' does not exist' ].	^ systemNameSpace</body></methods><methods><class-id>COAST.ClassNameManager</class-id> <category>accessing</category><body package="COBase">addDefaultNameSpace: systemNameSpaceString	" adds a namespace to the end of the default namespaces.	these will be used when a class name without namespace is found "	| systemNameSpace |	systemNameSpace := self systemNameSpaceFrom: systemNameSpaceString.	(defaultNameSpaces includes: systemNameSpace)		ifFalse: [ defaultNameSpaces add: systemNameSpace ]</body><body package="COBase">addDumpInfoTo: aStream</body><body package="COBase">createNewManager	| newManager |	newManager := self class new.	newManager defaultNameSpaces: defaultNameSpaces copy.	^ newManager</body><body package="COBase">flushCache	class2nameDict := Dictionary new.	name2classDict := Dictionary new.</body></methods><methods><class-id>COAST.ClassNameManager</class-id> <category>namespace converting</category><body package="COBase">classForCoastClassName: coastClassName	" returns the class associated with the class name (which may be	qualified), or nil if the class does not exist "	self subclassResponsibility</body></methods><methods><class-id>COAST.ClassNameManager</class-id> <category>initialize-release</category><body package="COBase">initialize	defaultNameSpaces := OrderedCollection new.	self addDefaultNameSpace: 'COAST'.	self flushCache</body></methods><methods><class-id>COAST.ClassNameManager class</class-id> <category>accessing</category><body package="COBase">default	default isNil ifTrue: 		[	ObjectMemory				removeDependent: self;				addDependent: self.			default := self new		].	^ default</body><body package="COBase">resetDefault	default := nil.	ObjectMemory removeDependent: self.	^ self default</body></methods><methods><class-id>COAST.ClassNameManager class</class-id> <category>update</category><body package="COBase">update: anAspect	((#(aboutToSnapshot) includes: anAspect) and: [ self default notNil ])		ifTrue: [ 			default := nil.			ObjectMemory removeDependent: self.		].</body></methods><methods><class-id>COAST.ClassNameManager class</class-id> <category>instance creation</category><body package="COBase">new	^ super new initialize</body></methods><methods><class-id>COAST.ClassNameManager class</class-id> <category>debug</category><body package="COBase">addDumpInfoTo: stream 	self withAllSubclasses do: [: subClass | subClass allInstances do: [: cnm | cnm addDumpInfoTo: stream ]].</body></methods><methods><class-id>COAST.CatRMSlotRemove</class-id> <category>comparing</category><body package="COTransactions">= anotherSlotCreation	" assume both slots are in the same cluster. 	do not compare slot removes of different agendas "	^ self class = anotherSlotCreation class		and: [ frameID = anotherSlotCreation frameID		and: [ slotName = anotherSlotCreation slotName ]]</body><body package="COTransactions">hash	^ frameID hash bitXor: slotName hash</body></methods><methods><class-id>COAST.CatRMSlotRemove</class-id> <category>printing</category><body package="COTransactions">ccPrintStringOn: stream withClusterID: clusterID	stream nextPutAll: 'SlotRemove (ID'.	clusterID printOn: stream.	stream nextPutAll: '_'.	frameID printOn: stream.	stream nextPutAll: ' '.	frameClassSymbol notNil ifTrue: [ stream nextPutAll: frameClassSymbol asString. stream nextPutAll: ' '. ].	slotName printOn: stream.	stream nextPutAll: ')'</body><body package="COTransactions">printOn: stream 	super printOn: stream.	stream nextPutAll: ' [frame '.	frameID printOn: stream.	stream nextPutAll: ' slot '.	slotName printOn: stream.	stream nextPutAll: ']'</body></methods><methods><class-id>COAST.CoastApplication</class-id> <category>config</category><body package="COBase">applicationInfoString	^ nil</body><body package="COBase">applyConfiguration	[		configuration configure: self.	] on: UnknownCommandLineArgument do: [ : unknown |		self notifyUnknownCommandLineArgument: unknown parameter.		unknown resume.	].</body><body package="COBase">configuration	^ configuration</body><body package="COBase">configurationClass	^ CoastApplicationConfiguration</body><body package="COBase">configureApplication	" performs a basic configuration of the application "	self createConfiguration.	self applyConfiguration.	self finalizeConfiguration.	^ configuration</body><body package="COBase">createConfiguration	"do not overwrite existing configuration"	configuration isNil ifTrue:	[		configuration := self configurationClass 			defaultLogFilename: self class defaultLogFilename			defaultIniFilename: self class defaultIniFilename 			needsIni: self needsIni.	].</body><body package="COBase">finalizeConfiguration	| s |	(s := self applicationInfoString) notNil		ifTrue: [ configuration infoString: s ].	configuration logInfo.</body><body package="COBase">iniAccess	^ self configuration iniAccess</body><body package="COBase">iniAccess: aCoastIniAccess	self configuration iniAccess: aCoastIniAccess</body><body package="COBase">needsIni	^ true</body></methods><methods><class-id>COAST.CoastApplication</class-id> <category>accessing</category><body package="COBase">addSubApplication: coastApplication	"add secondary applications to be started together with this application"	subApplications isNil ifTrue: [ subApplications := OrderedCollection new ].	subApplications add: coastApplication.</body><body package="COBase">isWindowsService	^ self configuration isWindowsService</body><body package="COBase">memoryPolicyClassString	^'COAST.CoastMemoryPolicy'</body><body package="COBase">pidFilename	^ nil</body><body package="COBase">removePidFile	| filename |	Notifier isDevelopment ifTrue: [ ^ self ].	filename := self pidFilename.	filename isNil ifTrue: [ ^ self ].	[	filename asFilename delete 	] on: Error	  do: [ : ex | CoastLog log: 'could not delete pid file: ', ex description ].</body><body package="COBase">startAction	^ startAction</body><body package="COBase">startAction: block 	startAction notNil 		ifTrue:	[	self consoleAndLogShow: 'Error: bad start parameter!'.					ObjectMemory quitWithError: CoastExitCode badParameter				]		ifFalse:	[	startAction := block				].</body><body package="COBase">writePidFile	| filename stream |	Notifier isDevelopment ifTrue: [ ^ self ].	filename := self pidFilename.	filename isNil ifTrue: [ ^ self ].	stream := nil.	[		[	stream := filename asFilename writeStream.			stream isNil ifFalse: [				stream text.				OSHandle currentProcessID printOn: stream.				].		]	on: Error 			do: [ : ex | CoastLog log: 'could not write pid file: ', ex description. ].	] ensure: [ stream isNil ifFalse: [ stream close. ]. ].</body></methods><methods><class-id>COAST.CoastApplication</class-id> <category>release</category><body package="COBase">shutDown	self subclassResponsibility</body></methods><methods><class-id>COAST.CoastApplication</class-id> <category>private</category><body package="COBase">checkVMAndImageVersion	| vmVersion imageVersion | 	[	( vmVersion := CoastVersion vmVersion ) notNil			ifTrue: 			[	imageVersion := CoastVersion imageVersion.				imageVersion &gt; vmVersion 					ifTrue: 					[	CoastError 							raiseSignal: 'VM version ' , vmVersion printString , ' does not match image version ' , imageVersion printString , ', quitting application'					]			]			ifFalse: 			[	vmVersion isNil 					ifTrue: [ CoastLog logWarning: 'Unknown virtual machine version (version ID ' , ObjectMemory versionId printString , ')' ]			].		VisualWorksVersion checkForBlacklistedVMVersion	] 		on: CoastError		do: 		[: ex |			CoastLog log: ex description.			ex pass		].</body><body package="COBase">commandLineParameters	^ CommandLineParameter commandLineParametersOf: self</body><body package="COBase">consoleAndLogShow: aString 	CoastLog enableConsoleWhile: [ CoastLog log: aString ].</body><body package="COBase">errorInCommandLine: aString	CoastLog enableConsoleWhile: [ CoastLog logError: aString ].	CoastError raiseSignal: aString.</body><body package="COBase">notifyUnknownCommandLineArgument: anArgumentString	CoastLog logWarning: 'Unknown command line argument: ', anArgumentString</body><body package="COBase">showUsage	| pragmas text |	pragmas := OrderedCollection new.	pragmas addAll: self commandlinePragmas.	configuration isNil ifFalse: [ pragmas addAll: configuration commandlinePragmas ].	text := CommandLineParameter helpTextFor: pragmas.	Notifier isDevelopment ifTrue: [ ^ Transcript show: text ].	CoastApplicationConfiguration showText: text.</body><body package="COBase">shutDownAndQuit	self shutDown.	Notifier isDevelopment ifFalse: [ 		CoastLog log: 'Terminating'.		ObjectMemory quit	].</body><body package="COBase">startUpAsService	"hier sollte eigentlich keiner vorbeikommen"	self consoleAndLogShow: 'Can not start ' , self class name , ' as service'.	self shutDownAndQuit.</body></methods><methods><class-id>COAST.CoastApplication</class-id> <category>initialize-release</category><body package="COBase">startAsSubApplicationOf: anotherCoastApplication 	^ startAction notNil 		ifTrue: [ startAction value ]		ifFalse: [ CoastError raiseSignal: 'no start action specified for: ' , self printString ]</body><body package="COBase">startSubApplications	subApplications isNil ifTrue: [ ^self ].	subApplications do: [ : subApp |		subApp configuration isNil ifTrue: [ subApp createConfiguration ].		subApp configuration parentConfiguration: self configuration.		subApp applyConfiguration.		subApp finalizeConfiguration.		subApp startAsSubApplicationOf: self.	].</body></methods><methods><class-id>COAST.CoastApplication</class-id> <category>pragma handling</category><body package="COBase">commandlinePragmas	"fast die gleiche Implementierung wie	CoastApplicationConfiguration &gt;&gt; #commandlinePragmas"	| pragmas |	pragmas := Pragma					allNamed: #commandlineParameter:canPerform:aliases:usage:help:					from: self class					to: CoastApplication.	^ pragmas reject: [ : pragma |		(pragma argumentAt: 2)			ifNil: [ false ]			ifNotNil: [ : canPerform | (self class perform: canPerform) not ]		]</body></methods><methods><class-id>COAST.CoastApplication class</class-id> <category>accessing</category><body package="COBase">defaultIniFilename	^ 'configuration.ini'</body><body package="COBase">defaultLogFilename	^ 'application.log'</body></methods><methods><class-id>COAST.CoastApplication class</class-id> <category>testing</category><body package="COBase">canBeService	^ true</body></methods><methods><class-id>COAST.CoastStatusResponse</class-id> <category>accessing</category><body package="COBase">code	^ code</body><body package="COBase">code: aCodeSymbol 	code := aCodeSymbol.</body><body package="COBase">message	^ message</body><body package="COBase">message: aString 	message := aString.</body><body package="COBase">ok	^ ok</body><body package="COBase">ok: aBoolean 	ok := aBoolean.</body></methods><methods><class-id>COAST.CoastStatusResponse</class-id> <category>marshalling</category><body package="COBase">marshallBinaryTo: aStream 	aStream nextPut: self ok class marshallID.	aStream nextCoastStringPut: self code.	aStream nextCoastStringPut: self message.</body></methods><methods><class-id>COAST.CoastStatusResponse</class-id> <category>printing</category><body package="COBase">printOn: aStream	aStream nextPutAll: 'Status: '.	self ok		ifTrue: [ aStream nextPutAll: 'OK' ]		ifFalse:[ aStream nextPutAll: 'Error' ].	aStream nextPutAll: ' Code: '.	self code printOn: aStream.	aStream nextPutAll: ' Message: '.	self message printOn: aStream.</body></methods><methods><class-id>COAST.CoastStatusResponse</class-id> <category>testing</category><body package="COBase">accessDenied	^code = self class codeAccessDenied</body></methods><methods><class-id>COAST.CoastStatusResponse class</class-id> <category>common codes</category><body package="COBase">codeAccessDenied	^ #accessDenied</body><body package="COBase">codeBackupFinished	^ #backupFinished</body><body package="COBase">codeBackupStarted	^ #backupStarted</body><body package="COBase">codeBadVolumeName	^ #badVolumeName</body><body package="COBase">codeColumeCopied	^ #volumeCopied</body><body package="COBase">codeNoBackupActive	^ #noBackupActive</body><body package="COBase">codeNoGCRunning	^ #noGCRunning</body><body package="COBase">codeUnhandledError	^ #unhandledError</body><body package="COBase">codeVolumeDoesNotExist	^ #volumeDoesNotExist</body></methods><methods><class-id>COAST.CoastStatusResponse class</class-id> <category>common responses</category><body package="COBase">accessDenied	^ self failureCode: self codeAccessDenied message: 'Access denied, wrong password'</body><body package="COBase">requestOk	^ self okCode: #ok message: ''</body><body package="COBase">volumeDoesNotExist: volumeName 	^ self failureCode: CoastStatusResponse codeVolumeDoesNotExist message: 'Volume ' , volumeName , ' does not exist or is not accessable'</body></methods><methods><class-id>COAST.CoastStatusResponse class</class-id> <category>instance creation</category><body package="COBase">failureCode: aCodeSymbol message: aString 	^ self ok: false code: aCodeSymbol message: aString</body><body package="COBase">fromStream: aStream	^ self new unmarshallBinaryFrom: aStream; yourself</body><body package="COBase">ok	^ self ok: true code: #ok message: 'ok'</body><body package="COBase">ok: aBoolean code: aCodeSymbol message: aString 	^ self new		ok: aBoolean;		code: aCodeSymbol;		message: aString;		yourself</body><body package="COBase">okCode: aCodeSymbol message: aString 	^ self ok: true code: aCodeSymbol message: aString</body></methods><methods><class-id>COAST.CatRMTryAndHoldResponseMessage</class-id> <category>testing</category><body package="COTransactions">isResponse	^true</body></methods><methods><class-id>COAST.CatRMFrameOperation</class-id> <category>comparing</category><body package="COTransactions">= anotherFrameOperation 	" assume both frames are in the same cluster. 	do not compare frame operations of different agendas "	^ self class = anotherFrameOperation class and: [ frameID = anotherFrameOperation frameID ]</body><body package="COTransactions">hash	^ frameID</body></methods><methods><class-id>COAST.CatRMFrameOperation</class-id> <category>accessing</category><body package="COTransactions">isCommutativeTo: anotherFrameOperation 	^ self frameID ~= anotherFrameOperation frameID</body></methods><methods><class-id>COAST.CatRMFrameRemove</class-id> <category>printing</category><body package="COTransactions">ccPrintStringOn: stream withClusterID: clusterID	stream nextPutAll: 'FrameRemove (ID'.	clusterID printOn: stream.	stream nextPutAll: '_'.	frameID printOn: stream.	stream nextPutAll: ')'</body><body package="COTransactions">printOn: stream 	super printOn: stream.	stream nextPutAll: ' ['.	self frameID printOn: stream.	stream nextPut: $].</body></methods><methods><class-id>COAST.CommandLineReadStream</class-id> <category>accessing</category><body package="COBase">nextBoolean	^ self next ifNotNil: 		[: s | ( 'true' match: s ) 				ifTrue: [ true ]				ifFalse: 				[( 'false' match: s ) 						ifTrue: [ false ]						ifFalse: [ nil ]				]		].</body><body package="COBase">nextEncoding	^ self next ifNotNil: [ : s | s asLowercase asSymbol. ]</body><body package="COBase">nextFilename	^ self next ifNotNil: [: s | s asFilename ].</body><body package="COBase">nextInteger	| p i |	p := self position.	i := Integer readFrom: self.	^ (i isInteger and: [ self position &gt; p ])		ifTrue: [ i ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CatRMFrameCreation</class-id> <category>accessing</category><body package="COTransactions">frameClassFor: aNameSpaceManager	^ aNameSpaceManager classForCoastClassName: self frameClassName</body><body package="COTransactions">frameClassName	^ frameClassSymbol asString</body><body package="COTransactions">frameClassName: aString 	frameClassSymbol := aString asSymbol.</body><body package="COTransactions">frameClassSymbol	^ frameClassSymbol</body><body package="COTransactions">frameClassSymbol: symbol 	frameClassSymbol := symbol.</body></methods><methods><class-id>COAST.CatRMFrameCreation</class-id> <category>printing</category><body package="COTransactions">ccPrintStringOn: stream withClusterID: clusterID	stream nextPutAll: 'FrameCreation (ID'.	clusterID printOn: stream.	stream nextPutAll: '_'.	frameID printOn: stream.	stream nextPutAll: ' '.	frameClassSymbol notNil ifTrue: [ stream nextPutAll: frameClassSymbol asString. stream nextPutAll: ' '. ].	stream nextPutAll: ')'</body><body package="COTransactions">printOn: stream 	super printOn: stream.	stream nextPutAll: ' ['.	self frameClassName printOn: stream.	stream space.	self frameID printOn: stream.	stream nextPut: $]</body></methods><methods><class-id>COAST.CatRMFrameCreation</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aCatRMMarshall writeFrameClassSymbol: self frameClassSymbol to: aStream.	super marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COTransactions">unmarshallBinary50From: aStream marshaller: aCatRMMarshall 	self frameClassName: aStream nextShortString.	super unmarshallBinary50From: aStream marshaller: aCatRMMarshall.</body><body package="COTransactions">unmarshallBinary52From: aStream marshaller: aCatRMMarshall 	self frameClassSymbol: ( aCatRMMarshall readFrameClassSymbolFrom: aStream ).	super unmarshallBinary52From: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CatRMFrameCreation class</class-id> <category>instance creation</category><body package="COTransactions">frameID: frameID frameClassSymbol: frameClassSymbol 	^ ( self frameID: frameID )		frameClassSymbol: frameClassSymbol;		yourself</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>testing</category><body package="COFramesystem">allowsSlotModification	^ true</body><body package="COBase">canCheckKeyRange	" does this value holder support the #keyRange demon? "	^ false</body><body package="COBase">canFastRead	^ true</body><body package="COFramesystem">canFastReadFullValue	^ self canFastRead</body><body package="COBase">coastIsValueHolder	^ true</body><body package="COCellValueHolder">isDirty	^ false</body><body package="COCellValueHolder">isProxyValueHolder	^ false</body><body package="COCellValueHolder">isSingleValue	^false</body><body package="COCellValueHolder">isValidSingleValue: newValue 	^ false</body><body package="COFramesystem">referencesSharedFrame: frame 	self subclassResponsibility.</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>accessing</category><body package="COBase">access: aCatCSCellAccess 	" add access to agenda if the cell wishes to record stuff  "	| t diffsComputed |	t := aCatCSCellAccess transaction.	( t isNil and: [ aCatCSCellAccess isWriteAccess and: [ aCatCSCellAccess isAccessOnPrototype not ]]) ifTrue: [ ^ self accessOutsideTransactionError ].	diffsComputed := false.	( t notNil and: [ aCatCSCellAccess isAccessOnPrototype not ]) ifTrue: 		[	" perform valid accesses only (note: local cells can contain anything so accesses to local cells are not validated) "			( aCatCSCellAccess isLocalCell 				or: [ aCatCSCellAccess skipValidAccessTest or: [ aCatCSCellAccess isValidAccess	"allowsTempSharedFrames is ignored in 5.3" ]]) ifFalse: 				[	CoastInvalidAccessError raiseForAccess: aCatCSCellAccess.					aCatCSCellAccess transactionManager abortTransaction.					^ nil				].			"may be needed before recording the access"			aCatCSCellAccess computeDifferencesIfNeeded.			diffsComputed := true.			t recordAccess: aCatCSCellAccess.			( t isTransient and: [ aCatCSCellAccess isWriteAccess ]) ifTrue: 				[	"escape here before actually writing the value"					^ nil				]		].	"last chance to compute the diffs"	diffsComputed ifFalse: [ aCatCSCellAccess computeDifferencesIfNeeded ].	aCatCSCellAccess isWriteAccess ifTrue: [ self checkBeforeAccess: aCatCSCellAccess ].	^ aCatCSCellAccess performOn: self</body><body package="COCellValueHolder">changeToDelegatingProxy</body><body package="COCellValueHolder">changeToDelegatingProxyForSlot: aCoastSlot</body><body package="COBase">checkBeforeAccess: aWriteAccess</body><body package="COCellValueHolder">clusterManagerIfNeeded: clusterManager 	"not needed"</body><body package="COCellValueHolder">coastCompactElementCount	^ self value coastCompactElementCount</body><body package="COBase">coastTotalByteSize	" total size of the valueholder and it's values "	^ self coastObjectSize + value coastTotalByteSize</body><body package="COFramesystem">differencesToOldValue: oldValue 	| myValueAsSet oldValueAsSet |	myValueAsSet := self value coastAsSetOrYourself.	oldValueAsSet := oldValue coastAsSetOrYourself.	^ CatCSCellValueDifferences added: ( myValueAsSet coastSubstract: oldValueAsSet ) removed: ( oldValueAsSet coastSubstract: myValueAsSet )</body><body package="COCellValueHolder">directValuesDo: block 	self value do: block.</body><body package="COFramesystem">frame: frame at: slotname replace: oldValue with: newValue	self subclassResponsibility</body><body package="COMarshalling">index	self subclassResponsibility.</body><body package="COCellValueHolder">initializeForArgumentsBlock: argumentsBlock inVolume: volume 	^ nil</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	( frame at: slotName ) = addedFrame ifFalse: [ frame at: slotName set: addedFrame ]</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	( frame at: slotName ) = removedFrame ifTrue: [ frame at: slotName set: nil ]</body><body package="COBase">performUpdateAccess: aCatCSCellAccess 	aCatCSCellAccess computeDifferencesIfNeeded.	^ aCatCSCellAccess performOn: self</body><body package="COBase">remap: aCatCSCellAccessClass	" For certain value holders, aCatCSCellAccessClass may have a different meaning, e.g. for ordered collections,	'add' means 'addLast'. Remap these accesses, so that the concurrency control can work correctly "	" By default, the access class is not remapped "	^ aCatCSCellAccessClass</body><body package="COBase">value	^ value</body><body package="COBase">value: anObject	value := anObject</body><body package="COCellAccesses">valueAsDepleteAddedCollection	^ Set new</body><body package="COCellAccesses">valueAsDepleteRemovedCollection	^ self valueAsSet</body><body package="COCellValueHolder">valueAsSet	self subclassResponsibility</body><body package="COBase">valueForReadAccess	^self</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>error handling</category><body package="COBase">accessOutsideTransactionError	self haltOrError: 'Access on ' , self printString , ' outside a transaction'</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>initialize-release</category><body package="COBase">initializeSpawned	" my slot was just spawned "	" however, I don't care "</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>printing</category><body package="COBase">printOn: stream 	super printOn: stream.	stream nextPutAll: ' on: '.	self value printOn: stream</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>adapting</category><body package="COCellValueHolder">adaptedCoastValueHolderToClass: valueHolderClass 	^ self</body><body package="COBase">coastAllArgumentsDo: aBlock 	self subclassResponsibility.</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">coastValueFor: valueHolder 	^ value coastValueFor: valueHolder</body><body package="COCellValueHolder">iteratingDo: aBlock	"overwritten in coast development"	^aBlock value</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>copying</category><body package="COCellValueHolder">constructCopyParameters: awareness 	self subclassResponsibility.</body><body package="COTransactions">copyForRollback	^ self value copyForRollback</body><body package="COCellValueHolder">selfOrAdaptedCoastValueHolderToClass: valueHolderClass 	^ self class == valueHolderClass 		ifTrue: [ self ]		ifFalse: [ self adaptedCoastValueHolderToClass: valueHolderClass ]</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>private</category><body package="COFramesystem">frame: frame atBagSlotNamed: slotName replace: oldValue with: newValue	| occurrences |	occurrences := frame at: slotName occurrencesOf: oldValue.	frame at: slotName removeAllOccurrences: oldValue.	frame at: slotName add: newValue withOccurrences: occurrences</body><body package="COFramesystem">frame: frame atCollectionSlotNamed: slotName replace: oldValue with: newValue 	( frame at: slotName includes: oldValue ) 		ifTrue: [			frame at: slotName remove: oldValue.			frame at: slotName add: newValue.		].</body><body package="COFramesystem">frame: frame atKeyedSlotNamed: slotName replace: oldValue with: newValue 	( frame at: slotName ) copy keysAndValuesDo: 		[: k : v | | replacedKey replacedValue replaced |			replaced := false.			replacedKey := k = oldValue 					ifTrue: 					[	replaced := true.						newValue					]					ifFalse: [ k ].			replacedValue := v = oldValue 					ifTrue: 					[	replaced := true.						newValue					]					ifFalse: [ v ].			replaced 				ifTrue: 				[	frame at: slotName atKey: k remove: v.					frame at: slotName atKey: replacedKey remove: replacedValue				]		].</body><body package="COCellValueHolder">slot: aCatFSSlot	" slot which contains this value holder. "	" i don't care "</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>garbage collect</category><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock 	"for use of garbage-collection only!"	^ self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>converting</category><body package="COCellValueHolder">coastAsSet	^ self valueAsSet</body></methods><methods><class-id>COAST.CatCSCellValueHolder</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	| frame |	frame := aCatRMMarshall unmarshallValueFrom: aStream morph: morphSelector.	self value: frame.	self clusterManagerIfNeeded: aCatRMMarshall clusterManager.</body></methods><methods><class-id>COAST.CatCSCellValueHolder class</class-id> <category>adapting</category><body package="COCellValueHolder">coastAdaptFromBag: bagValueHolder 	^ bagValueHolder</body><body package="COCellValueHolder">coastAdaptFromDictionary: valueHolder 	^ valueHolder</body><body package="COCellValueHolder">coastAdaptFromIndex: valueHolder 	^ valueHolder</body><body package="COCellValueHolder">coastAdaptFromSimpleCollection: bagValueHolder 	^ bagValueHolder</body></methods><methods><class-id>COAST.CatCSCellValueHolder class</class-id> <category>marshalling</category><body package="COCellValueHolder">initializeIndexArray	"CatCSCellValueHolder initializeIndexArray"	| valueHolderDict maxIndex |	valueHolderDict := Dictionary new.	maxIndex := 0.	CatCSCellValueHolder withAllSubclasses do:  		[: class | class valueHolderIndex ifNotNil: [ : idx | idx &gt; maxIndex ifTrue: [ maxIndex := idx ]. valueHolderDict at: idx put: class ].		].	indexArray := Array new: maxIndex.	valueHolderDict keysAndValuesDo: [ : idx : class | indexArray at: idx put: class ].	"check := Array new: 18.	check		at: 1 put: CatCSSingleValue;		at: 2 put: CatCSSet;		at: 3 put: CatCSOrderedCollection;		at: 4 put: CatCSDictionary;		at: 5 put: CatCSBag;		at: 6 put: CatCSCompactSet;		at: 7 put: CatCSCompactKeyDictionary;		at: 9 put: CatCSCompactDictionary;		at: 8 put: CatCSCompactBag;		at: 10 put: CatCSCompactIndex;		at: 11 put: CatCSCompactValueIndex;		at: 12 put: CatCSProxyIndex;		at: 13 put: CatCSProxySet;		at: 14 put: CatCSProxyDictionary;		at: 15 put: CatCSProxyBag;		at: 16 put: CatCSCompactKeyIndex;		at: 17 put: CatCSMultiValueDictionary;		at: 18 put: CatCSCompactRPCResultCollection.		at: 19 put: CatCSSortedSet.	check = indexArray ifFalse: [ self halt ]."</body><body package="COCellValueHolder">valueHolderClassWithID: anID 	indexArray isNil ifTrue: [self initializeIndexArray].	^ (anID &gt;=1 and: [ anID &lt;= indexArray size ])		ifTrue: [ indexArray at: anID ]		ifFalse: [ CoastError raiseSignal: 'Unknown valueholder class ID: ', anID printString ].</body></methods><methods><class-id>COAST.CatCSCellValueHolder class</class-id> <category>instance creation</category><body package="COFramesystem">newPrototype	^self new</body><body package="COCellValueHolder">newWithoutValue	^ self new</body></methods><methods><class-id>COAST.CatCSCellValueHolder class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^nil</body><body package="COCellValueHolder">valueHolderIndex	^nil</body></methods><methods><class-id>COAST.CatCSFastReadWriteTransaction</class-id> <category>initialize - release</category><body package="COTransactions">initialize	isFastRead := true.	^ super initialize</body></methods><methods><class-id>COAST.CatCSFastReadWriteTransaction</class-id> <category>accessing</category><body package="COTransactions">defaultCollectionSize	^ super defaultCollectionSize // 2</body><body package="COTransactions">initialSizeForAccesses	^ super initialSizeForAccesses // 2</body></methods><methods><class-id>COAST.CatCSUnmanagedWriteTransaction</class-id> <category>access handling</category><body package="COTransactions">rememberAccessIfFirst: cellAccess 	| cell |	( cellAccess isUpdateAccess and: [ cellAccess cell hasNoDemons ]) ifTrue: [ ^ self ].	cellAccess isLocalCell ifTrue: [ ^ self ].	(( cell := cellAccess cell ) needsCellValueCopyForUnmanaged: self ) 		ifTrue: [ self oldValuesDictAt: cell ifAbsentPut: [ cell valueHolder copyForRollback ]].</body></methods><methods><class-id>COAST.HashSegmentedDictionary</class-id> <category>accessing</category><body package="COBase">associationAt: key ifAbsent: aBlock 	^ ( self segmentedDictionaryFor: key hash ) associationAt: key ifAbsent: aBlock</body><body package="COBase">at: key ifAbsent: aBlock 	^ ( self segmentedDictionaryFor: key hash ) at: key ifAbsent: aBlock</body><body package="COBase">at: key put: anObject 	^ self segmentedDictionaryFor: key hash		withParentDo: 		[: dict : parent | | index element |			index := dict findKeyOrNil: key.			element := dict basicAt: index.			element == nil 				ifTrue: 				[	tally := tally + 1.					dict atNewIndex: index put: ( dict createKey: key value: anObject ).					parent splitIfNeeded				]				ifFalse: [ element value: anObject ].			^ anObject		]</body><body package="COBase">findElementLike: anObject ifAbsent: aBlock 	^ contents findElementLike: anObject		ifAbsent: 		[	self overflowDo: 				[: more | | result |					result := more findElementLike: anObject ifAbsent: nil.					nil == result ifTrue: [ ^ result ]				].			aBlock value		]</body></methods><methods><class-id>COAST.HashSegmentedDictionary</class-id> <category>private</category><body package="COBase">atNewIndex: index put: anObject 		self shouldNotImplement</body><body package="COBase">byteFrom: hash 	| byte |	byte := bytePos = 1 			ifTrue: [ hash bitAnd: 16rFF ]			ifFalse: 			[	bytePos = 2 					ifTrue: [( hash bitAnd: 16rFF00 ) bitShift: -8 ]					ifFalse: 					[	bytePos = 3 							ifTrue: [( hash bitAnd: 16rFF0000 ) bitShift: -16 ]							ifFalse: [( hash bitShift: -24 ) bitAnd: 16rFF ]					]			].	^ byte</body><body package="COBase">changeCapacityTo: newCapacity 	"overflow notNil 		ifTrue: 		[	contents changeCapacityTo: ( 1 + newCapacity ) // 2.			overflow changeCapacityTo: ( 1 + newCapacity ) // 2		]		ifFalse: [ contents changeCapacityTo: newCapacity ]."</body><body package="COBase">contentsType: dictionaryClass bytePos: pos 	contents notNil ifTrue: [ self shouldNotImplement ].	bytePos := pos.	bytePos = 1 		ifTrue: 		[	tally := 0.			overflow := ( 1 to: 255 ) collect: [: byte | self class contentsType: dictionaryClass bytePos: bytePos + 1 ].			contents := self class contentsType: dictionaryClass bytePos: bytePos + 1		]		ifFalse: [ contents := dictionaryClass new: self splitSize ].</body><body package="COBase">find: anObject ifAbsent: aBlock 	self shouldNotImplement.</body><body package="COBase">findBitPosForSplit	| anyKey |	anyKey := nil.	contents keysDo: 		[: key |			anyKey isNil 				ifTrue: [ anyKey := key ]				ifFalse: [ ^ ( anyKey identityHash bitXor: key identityHash ) lowBit ]		].	^ 0</body><body package="COBase">findKey: key ifAbsent: aBlock 	^ self shouldNotImplement</body><body package="COBase">findKey: key ifAbsentRaise: aSignal 	self shouldNotImplement.</body><body package="COBase">findKeyOrNil: key 	self shouldNotImplement.</body><body package="COBase">fixCollisionsFrom: index 	"hmpf"</body><body package="COBase">noCheckAdd: anObject 	self at: anObject key put: anObject value.</body><body package="COBase">segmentedDictionaryFor: hash 	^ self segmentedDictionaryFor: hash withParentDo: nil</body><body package="COBase">segmentedDictionaryFor: hash withParentDo: block 	| byte more |	nil == overflow ifTrue: 		[	^ nil == block 				ifTrue: [ contents ]				ifFalse: [ block value: contents value: self ]		].	byte := self byteFrom: hash.	more := 0 == byte 			ifTrue: [ contents ]			ifFalse: [ overflow at: byte ].	^ more segmentedDictionaryFor: hash withParentDo: block</body><body package="COBase">splitIfNeeded	| filling |	( nil ~~ overflow or: [ contents size &lt; self splitSize ]) ifTrue: [ ^ self ].	filling := contents.	overflow := ( 1 to: 255 ) collect: [: byte | self class contentsType: contents species bytePos: bytePos + 1 ].	contents := self class contentsType: contents species bytePos: bytePos + 1.	filling keysAndValuesDo: [: key : value | ( self segmentedDictionaryFor: key hash ) at: key put: value ].</body><body package="COBase">splitSize	^ 4096</body></methods><methods><class-id>COAST.HashSegmentedDictionary</class-id> <category>copying</category><body package="COBase">postCopy	contents := contents copy.	overflow := overflow collect: [: more | more copy ].</body><body package="COBase">postCopyWithCopiedValues	self postCopy.	contents postCopyWithCopiedValues.	self overflowDo: [: more | more postCopyWithCopiedValues ].</body></methods><methods><class-id>COAST.HashSegmentedDictionary</class-id> <category>dictionary enumerating</category><body package="COBase">associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's key/value associations."	contents associationsDo: aBlock.	self overflowDo: [: more | more associationsDo: aBlock ].</body><body package="COBase">overflowDo: block 	overflow notNil ifTrue: [ overflow do: block ].</body></methods><methods><class-id>COAST.HashSegmentedDictionary</class-id> <category>dictionary testing</category><body package="COBase">includesKey: key 	^ ( self segmentedDictionaryFor: key hash ) includesKey: key</body></methods><methods><class-id>COAST.HashSegmentedDictionary</class-id> <category>enumerating</category><body package="COBase">collect: aBlock 	| newSet |	newSet := Set new: self size * 3 // 2.	self do: [: element | newSet add: ( aBlock value: element )].	^ newSet</body><body package="COBase">do: aBlock 	contents do: aBlock.	self overflowDo: [: more | more do: aBlock ].</body><body package="COBase">keysAndValuesDo: aBlock 	contents keysAndValuesDo: aBlock.	self overflowDo: [: more | more keysAndValuesDo: aBlock ].</body></methods><methods><class-id>COAST.HashSegmentedDictionary</class-id> <category>dictionary removing</category><body package="COBase">removeKey: key ifAbsent: aBlock 	^ self segmentedDictionaryFor: key hash		withParentDo: 		[: dict : parent | "parent wird hier als internes Objekt, das nicht im Dictionary enthalten sein soll, als marker verwendet.			nil geht nicht, da ja idR auch nil als value erlaubt ist"			| result |			result := dict removeKey: key ifAbsent: parent.			result == parent 				ifTrue: [ aBlock value ]				ifFalse: 				[	tally := tally - 1.					result				]		]</body></methods><methods><class-id>COAST.HashSegmentedDictionary</class-id> <category>adding</category><body package="COBase">add: anAssociation 	"Include anAssociation as one of the receiver's elements.  Answer anAssociation."	self at: anAssociation key put: anAssociation value.	^anAssociation</body></methods><methods><class-id>COAST.HashSegmentedDictionary</class-id> <category>removing</category><body package="COBase">remove: oldObject ifAbsent: anExceptionBlock 	| oldValue |	oldObject coastIsAssociation ifFalse: [ ^ anExceptionBlock value ].	oldValue := self at: oldObject key ifAbsent: [ ^ anExceptionBlock value ].	oldValue = oldObject value 		ifTrue: [ self removeKey: oldObject key ]		ifFalse: [ ^ anExceptionBlock value ].	^ oldObject</body></methods><methods><class-id>COAST.HashSegmentedDictionary</class-id> <category>binary storage</category><body package="COBase">readGeneralStructureOn: aBinaryStorageReader 	self shouldNotImplement.</body></methods><methods><class-id>COAST.HashSegmentedDictionary class</class-id> <category>instance creation</category><body package="COBase">contentsType: dictionaryClass bytePos: bytePos 	^ ( self basicNew )		contentsType: dictionaryClass bytePos: bytePos;		yourself</body><body package="COBase">new	^ self contentsType: Dictionary bytePos: 1</body><body package="COBase">new: size 	^ self new</body></methods><methods><class-id>COAST.CatRMSlotCreation</class-id> <category>comparing</category><body package="COTransactions">= anotherSlotCreation	" assume both slots are in the same cluster. 	do not compare slot creations of different agendas "	^ self class = anotherSlotCreation class		and: [ frameID = anotherSlotCreation frameID		and: [ slotName = anotherSlotCreation slotName ]]</body><body package="COTransactions">hash	^ frameID hash bitXor: slotName hash</body></methods><methods><class-id>COAST.CatRMSlotCreation</class-id> <category>accessing</category><body package="COTransactions">valueHolderClass	^ CatCSCellValueHolder valueHolderClassWithID: valueHolderIndex</body></methods><methods><class-id>COAST.CatRMSlotCreation</class-id> <category>printing</category><body package="COTransactions">ccPrintStringOn: stream withClusterID: clusterID	stream nextPutAll: 'SlotCreation (ID'.	clusterID printOn: stream.	stream nextPutAll: '_'.	frameID printOn: stream.	stream nextPutAll: ' '.	frameClassSymbol notNil ifTrue: [ stream nextPutAll: frameClassSymbol asString. stream nextPutAll: ' '. ].	slotName printOn: stream.	stream nextPutAll: ')'</body><body package="COTransactions">printOn: stream 	super printOn: stream.	stream nextPutAll: ' [frame '.	frameID printOn: stream.	stream nextPutAll: ' slot '.	slotName printOn: stream.	stream nextPutAll: ']'</body></methods><methods><class-id>COAST.CatRMSlotCreation</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	super marshallBinaryTo: aStream marshaller: aCatRMMarshall.	aStream nextPut: self valueHolderIndex.</body><body package="COTransactions">unmarshallBinary50From: aStream marshaller: aCatRMMarshall 	self slotName: aStream nextShortString.	self valueHolderIndex: aStream next.	super unmarshallBinary50From: aStream marshaller: aCatRMMarshall.</body><body package="COTransactions">unmarshallBinary52From: aStream marshaller: aCatRMMarshall 	super unmarshallBinary52From: aStream marshaller: aCatRMMarshall.	self valueHolderIndex: aStream next.</body></methods><methods><class-id>COAST.SupervisedSubordinate</class-id> <category>initialize-release</category><body package="COBase">startUp	| connOK |	socketAccessor := SocketAccessor defaultClass newCoastClientToHost: 'localhost' port: supervisorPort.	( socketAccessor isNil or: [ socketAccessor isActive not ]) ifTrue: 		[	CoastError raiseSignal: 'could not connect to supervisor'.			^ nil		].	connOK :=		[				[	sendStream := socketAccessor coastBinaryWriteStream.				receiveStream := socketAccessor coastBinaryReadStream.				self sendConnectionRequest.				sendStream flush			] coastValueWithinSeconds: 8		] on: Error			do: 			[: ex |				socketAccessor := nil.				false			].	connOK ifFalse: [( CoastError new messageText: 'Connection can not be established' ) raise ].	commandQueue := SharedQueue new.	self startReceiveProcess.</body></methods><methods><class-id>COAST.SupervisedSubordinate</class-id> <category>accessing</category><body package="COBase">coastApplication	^ coastApplication</body><body package="COBase">coastApplication: aCoastApplication 	coastApplication := aCoastApplication.</body><body package="COBase">nextCommand	^commandQueue next</body><body package="COBase">supervisorPort: aSupervisorPort 	supervisorPort := aSupervisorPort.</body></methods><methods><class-id>COAST.SupervisedSubordinate</class-id> <category>private: send/receive</category><body package="COBase">ignoreMessageLoopErrors	^false</body><body package="COBase">messageLoopDo: aBlock	[			[				[					[ aBlock value ] on: CoastConnectionLostError , OsError					do: 					[: ex |						CoastLog logError: 'subordinate lonnection lost at ' , self printString , ': ' , ex description.						false					]			] on: UserInterrupt				do: 				[: ex |					CoastLog log: 'Ignore user interrupt in subordinate message loop'.					ex resume				]		] on: Error			do: 			[: ex |				CoastLog logExceptionShort: ex message: 'Error in message loop of ' , self printString.				[ self disconnect ] fork.				false			]	] whileTrue: [ ].	"reconnect will terminate this process, so be careful and fork another one"	[ self disconnect ] fork.</body><body package="COBase">receiveBlock	^ [		self 			messageLoopDo: [ self receiveNextCommand ]	]</body><body package="COBase">receiveNextCommand	| cmd |	cmd := SupervisorCommand unmarshalFrom: receiveStream.	cmd notNil ifTrue: 		[			CoastLog log: cmd.			(cmd isShutdownCommand and: [ coastApplication notNil ]) ifTrue: [ coastApplication shutDownAndQuit ].			commandQueue nextPut: cmd		].	^ cmd notNil</body><body package="COBase">sendConnectionRequest			sendStream next32Put: OSHandle currentProcessID.	sendStream flush.</body></methods><methods><class-id>COAST.SupervisedSubordinate</class-id> <category>private: initialize</category><body package="COBase">disconnect	[		self terminateProcessesAndStreams.	] on: Error do: [:ex |		ex return	].</body><body package="COBase">startReceiveProcess	receiveProcess := self receiveBlock newProcess.	receiveProcess priority: Processor lowIOPriority - 3.	receiveProcess name: 'supervised subordinate' , ' - receive process'.	receiveProcess resume.</body><body package="COBase">terminateProcessesAndStreams	receiveProcess notNil		ifTrue: [			receiveProcess terminate.			receiveProcess := nil		].	receiveStream close.	sendStream close.	[		socketAccessor close.	] on: Error do: [ : ex |		CoastLog logWarning: 'Could not close socket: ', ex description.	].</body></methods><methods><class-id>COAST.SupervisedSubordinate class</class-id> <category>instance creation</category><body package="COBase">supervisorPort: aSupervisorPort 	^ self new supervisorPort: aSupervisorPort;		startUp;		yourself</body></methods><methods><class-id>COAST.CatRMVolumeSaveRequest class</class-id> <category>instance creation</category><body package="COMessages">volume: aVolume	^self new volume: aVolume</body></methods><methods><class-id>COAST.CoastIDAndHashWrapper</class-id> <category>accessing</category><body package="COBase">coastAsID	^coastID</body><body package="COBase">coastHash: hash	cellHashValue := hash</body><body package="COBase">coastHashFor: coastCell	^cellHashValue</body><body package="COBase">coastHashOrNil	^cellHashValue</body><body package="COBase">coastID: id	coastID := id</body></methods><methods><class-id>COAST.CoastIDAndHashWrapper</class-id> <category>instance creation</category><body package="COBase">coastAsNewIDFrom: newID for: frame	^ cellHashValue == newID		ifTrue: [ newID ]		ifFalse: [ COAST.CoastIDAndHashWrapper coastID: newID hash: cellHashValue ]</body></methods><methods><class-id>COAST.CoastIDAndHashWrapper</class-id> <category>testing</category><body package="COBase">coastIsTempSharedFrameID	^ coastID notNil 		ifTrue: [ coastID coastIsTempSharedFrameID ]		ifFalse: [ cellHashValue coastIsTempSharedFrameID ]</body></methods><methods><class-id>COAST.CoastIDAndHashWrapper class</class-id> <category>instance creation</category><body package="COBase">coastID: id hash: hash	^ self new		coastID: id;		coastHash: hash;		yourself</body></methods><methods><class-id>COAST.CatRMStreamingClusterForClientMessage</class-id> <category>marshalling</category><body package="COMessages">basicMarshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextUnsigned32Put: globalSeqNum.	aStream nextShortStringPut: self cluster volume.	storageInterface transferCluster: cluster id to: aStream.	aStream close.	clusterByteSize := storageInterface storageSizeForCluster: cluster id.</body><body package="COMessages">messageClassName	^ 'CatRMStreamingClusterForClientMessage'</body></methods><methods><class-id>COAST.CatRMStreamingClusterForClientMessage</class-id> <category>accessing</category><body package="COMessages">storageInterface: aStorageInterface	storageInterface:= aStorageInterface</body></methods><methods><class-id>COAST.CoastSortedSet</class-id> <category>testing</category><body package="COBase">coastIncludesCompactKey: compactKey 	self includes: compactKey</body><body package="COBase">includes: value 	^ value isCoastPrimitiveValue and: [( self binarySearch: value ifAbsent: [: newIndex | nil ]) notNil ]</body><body package="COBase">includesFrameWithReference: frameOrReference 	^ self includes: frameOrReference</body></methods><methods><class-id>COAST.CoastSortedSet</class-id> <category>accessing</category><body package="COBase">binarySearch: searchElement ifAbsent: absentBlock 	"	^ self binarySearch: searchElement min: 1 max: value size ifAbsent: absentBlock"	| index |	tally = 0 ifTrue: [ ^ absentBlock value: 1 ].	index := self coastMinIndexForInserting: searchElement min: 1 max: tally.	^ ( index &lt;= tally and: [( self basicAt: index ) = searchElement ]) 		ifTrue: [ index ]		ifFalse: [ absentBlock value: index ]</body><body package="COBase">coastMinIndexForInserting: search min: min max: max 	| minIndex maxIndex |	minIndex := min.	maxIndex := max.	maxIndex == 0 ifTrue: [ ^ 1	"empty collection" ].	"1 &lt;= min &lt;= minIndex &lt;= maxIndex &lt;= max &lt;= self size"	[ minIndex &lt; maxIndex ] whileTrue: 		[ "search in interval [ minIndex .. maxIndex ]"			| midIndex found |			midIndex := minIndex + maxIndex bitShift: -1.	"minIndex &lt;= index &lt; maxIndex"			found := self basicAt: midIndex.			( found coastLessThan: search ) 				ifTrue: [ minIndex := midIndex + 1	"search behind index" ]				ifFalse: [ maxIndex := midIndex	"search at or before index" ]		].	^ ( minIndex = max and: [( self basicAt: max ) coastLessThan: search ]) 		ifTrue: [ minIndex + 1 ]		ifFalse: [ minIndex ]</body><body package="COBase">first	self emptyCheck.	^ self basicAt: 1</body><body package="COBase">last	self emptyCheck.	^ self basicAt: tally</body></methods><methods><class-id>COAST.CoastSortedSet</class-id> <category>enumerating</category><body package="COBase">do: block 	1 to: tally do: [: i | block value: ( self basicAt: i )].</body></methods><methods><class-id>COAST.CoastSortedSet</class-id> <category>private</category><body package="COBase">checkValidStructure: repair 	| prev |	self notEmpty ifTrue: [ prev := self basicAt: 1 ].	2 to: tally		do: 		[: index | | current |			current := self basicAt: index.			( prev coastLessThan: current ) ifFalse: [ self error: 'invalid sorting in ' , self displayString ].			prev := current		].	^ false</body><body package="COBase">coastInsert: anObject beforeIndex: targetIndex 	| fixedIndex |	fixedIndex := targetIndex min: tally + 1.	tally &gt;= self basicSize 		ifTrue: 		[ | newSelf newTally |			newTally := tally + 1.			newSelf := self copyEmpty: self capacity + self growSize.			1 to: fixedIndex - 1 do: [: index | newSelf basicAt: index put: ( self basicAt: index )	"copy pre insert range" ].			newSelf basicAt: fixedIndex put: anObject.	"insert object"			fixedIndex + 1 to: newTally do: [: index | newSelf basicAt: index put: ( self basicAt: index - 1 )	"copy post insert range" ].			self become: newSelf.			tally := newTally		]		ifFalse: 		[	tally := tally + 1.			tally to: fixedIndex + 1 by: -1 do: [: index | self basicAt: index put: ( self basicAt: index - 1 )].			self basicAt: fixedIndex put: anObject		].	^ anObject</body><body package="COBase">coastRemoveAtIndex: targetIndex 	tally := tally - 1.	targetIndex to: tally do: [: index | self basicAt: index put: ( self basicAt: index + 1 )].</body><body package="COBase">compactElementAtIndex: index 	^ self basicAt: index</body><body package="COBase">findElementOrNil: anObject 	self shouldNotImplement.</body><body package="COBase">frameWithClusterID: clusterID frameID: frameID withIndexDo: block 	self shouldNotImplement.</body><body package="COBase">initialIndexFor: aHashValue boundedBy: length 	self shouldNotImplement.</body><body package="COBase">noCheckAdd: anObject 	"Assume that anObject is not in the receiver and add it	without checking to make sure."	self basicAt: ( tally := tally + 1 ) put: anObject.</body><body package="COBase">species	^ Set</body></methods><methods><class-id>COAST.CoastSortedSet</class-id> <category>removing</category><body package="COBase">remove: value ifAbsent: absentBlock 	| removeAtIndex |	value isCoastPrimitiveValue ifFalse: [ ^ absentBlock value ].	removeAtIndex := self binarySearch: value ifAbsent: [: newIndex | nil ].	^ removeAtIndex notNil 		ifTrue: 		[	self coastRemoveAtIndex: removeAtIndex.			value		]		ifFalse: [ absentBlock value ]</body></methods><methods><class-id>COAST.CoastSortedSet</class-id> <category>adding</category><body package="COBase">add: value 	value notNil ifTrue: 		[	value isCoastPrimitiveValue ifFalse: [ self error: 'Only store coast primitive values' ].			self binarySearch: value ifAbsent: [: newIndex | self coastInsert: value beforeIndex: newIndex ]		].	^ value</body></methods><methods><class-id>COAST.CoastSortedSet</class-id> <category>marshalling</category><body package="COMarshalling">unmarshallBinary: elementsCount from: aStream marshaller: aCatRMMarshall morph: morphSelector 	1 to: elementsCount do: [: index | self basicAt: index put: ( aCatRMMarshall unmarshallValueFrom: aStream morph: morphSelector )].	tally := elementsCount.</body></methods><methods><class-id>COAST.CoastSortedSet class</class-id> <category>private</category><body package="COMarshalling">goodSizeFrom: someSize 	^ someSize</body></methods><methods><class-id>COAST.CoastSortedSet class</class-id> <category>marshalling</category><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	| elementsCount instance |	elementsCount := aStream nextOptimized32.	instance := self new: elementsCount.	instance unmarshallBinary: elementsCount from: aStream marshaller: aCatRMMarshall morph: morphSelector.	^ instance</body></methods><methods><class-id>COAST.CatRMVolumeIDRequest class</class-id> <category>instance creation</category><body package="COMessages">volume: aVolume	^self new volume: aVolume</body></methods><methods><class-id>COAST.SupervisionMessage</class-id> <category>utility</category><body package="COBase">iniFileArgument	| iniString |	iniString := arguments at: #iniString ifAbsent: [ ^nil ].	^CoastIniAccess readFrom: iniString readStream</body><body package="COBase">iniFileArgument: coastIniAccess	| stream |	stream := String new writeStream.	coastIniAccess writeTo: stream.	arguments at: #iniString put: stream contents.</body></methods><methods><class-id>COAST.SupervisionMessage</class-id> <category>accessing</category><body package="COBase">arguments	^ arguments</body><body package="COBase">arguments: aArguments 	arguments := aArguments.</body><body package="COBase">commandSymbol	^ commandSymbol</body><body package="COBase">commandSymbol: aCommandSymbol 	commandSymbol := aCommandSymbol.</body></methods><methods><class-id>COAST.SupervisionMessage</class-id> <category>printing</category><body package="COBase">printOn: aStream	commandSymbol printOn: aStream.	aStream nextPutAll: ' ('.	arguments notNil ifTrue: [		arguments keys do: [ : key | key printOn: aStream ] separatedBy: [ aStream nextPut: $,. ].	].	aStream nextPut: $).</body></methods><methods><class-id>COAST.SupervisionMessage</class-id> <category>marshaling</category><body package="COBase">marshalTo: aStream	aStream nextCoastStringPut: commandSymbol.	aStream next32Put: arguments size.	arguments keysAndValuesDo: [ : key : value |		key supervisorMarshalTo: aStream.		value supervisorMarshalTo: aStream.	]</body></methods><methods><class-id>COAST.SupervisionMessage class</class-id> <category>marshaling</category><body package="COBase">unmarshalFrom: aStream	| commandSymbol argSize arguments |	commandSymbol := aStream nextCoastString asSymbol.	argSize := aStream next32.	arguments := Dictionary new: argSize.	argSize timesRepeat:	[ | key value |		key := self unmarshalPrimitiveFrom: aStream.		value := self unmarshalPrimitiveFrom: aStream.		arguments at: key put: value.	].	^self commandSymbol: commandSymbol arguments: arguments</body></methods><methods><class-id>COAST.SupervisionMessage class</class-id> <category>instance creation</category><body package="COBase">commandSymbol: symbol	^self new		commandSymbol: symbol;		arguments: Dictionary new;		yourself</body><body package="COBase">commandSymbol: symbol arguments: args	^self new		commandSymbol: symbol;		arguments: args;		yourself</body></methods><methods><class-id>COAST.CoastFilteringCSVApplicationLogger</class-id> <category>API</category><body package="COClusterManagement">basicAddToApplicationLog: aCatCSApplicationLog 	aCatCSApplicationLog logEntries do: 		[: logEntry | ( filterKeys allSatisfy: [: key | ( validValues at: ( filterKeys indexOf: key )) includes: ( logEntry valueAtKey: key )]) ifTrue: 				[	currentRow atAllPut: nil.					logEntry keysAndValuesDo: 						[: key : value | | column |							column := self columnsDictionary at: key ifAbsent: [ nil ].							column notNil ifTrue: 								[	currentRow growToAtLeast: self numberOfColumns.									currentRow at: column index put: value								]						].					self writeCurrentRow				]		].</body></methods><methods><class-id>COAST.CoastFilteringCSVApplicationLogger</class-id> <category>initialize-release</category><body package="COClusterManagement">initializeFromIni: coastIniAccess 	| validValuesStrings |	super initializeFromIni: coastIniAccess.	filterKeys := ( coastIniAccess category: self iniCategory stringAt: 'filterKeys' ifAbsent: [ '' ]) tokensBasedOn: $;.	validValuesStrings := ( coastIniAccess category: self iniCategory stringAt: 'validValues' ifAbsent: [ '' ]) tokensBasedOn: $;.	validValues := validValuesStrings collect: [: valueString | valueString tokensBasedOn: $, ].	filterKeys size ~= validValues size ifTrue: 		[	CoastLog logError: 'Filtering application log initialized failed'.			filterKeys := OrderedCollection new.			validValues := OrderedCollection new		].</body></methods><methods><class-id>COAST.CoastFilteringCSVApplicationLogger</class-id> <category>private</category><body package="COClusterManagement">writeCurrentRow	super writeCurrentRow.	internalStream flush.</body></methods><methods><class-id>COAST.CoastFilteringCSVApplicationLogger class</class-id> <category>accessing</category><body package="COClusterManagement">defaultFilename	^ defaultFilename ifNil: [ 'aktenzeichenlog.csv' ]</body></methods><methods><class-id>COAST.MinAgeLRUUnloadStrategy</class-id> <category>initialize</category><body package="COClusterManagement">initialize	minAge := 30.	unloadInterval := 30.</body></methods><methods><class-id>COAST.MinAgeLRUUnloadStrategy</class-id> <category>accessing</category><body package="COClusterManagement">clusterUnloadFinished: didUnload 	super clusterUnloadFinished: didUnload.	didUnload 		ifTrue: [ lastUnloadAttempt := Time secondClock ].</body><body package="COClusterManagement">manyClustersToLoadDo: aBlock 	" evaluating the block will load many clusters. prepare the strategy if needed "	| oldMinAge oldUnloadInterval |	oldMinAge := minAge.	oldUnloadInterval := unloadInterval.	^ [	minAge := 0.		unloadInterval := 0.		super manyClustersToLoadDo: aBlock	] ensure: 		[	minAge := oldMinAge.			unloadInterval := oldUnloadInterval		]</body><body package="COClusterManagement">minAge	" minimal age (seconds since last access) "	^ minAge</body><body package="COClusterManagement">minAge: anInteger	" minimal age (seconds since last access) "	minAge := anInteger</body><body package="COClusterManagement">unloadInterval	" min. interval between unloads "	^ unloadInterval</body><body package="COClusterManagement">unloadInterval: anInteger	" min. interval between unloads "	unloadInterval := anInteger</body><body package="COClusterManagement">unloadRecommended	| time |	time := Time secondClock.	^ ( lastUnloadAttempt notNil and: [ time - lastUnloadAttempt &lt; unloadInterval ]) 		ifTrue: [  false ]		ifFalse:  [ super unloadRecommended ]</body><body package="COClusterManagement">unloadableClusterIDs	| time result |	time := Time secondClock.	( lastUnloadAttempt notNil and: [ time - lastUnloadAttempt &lt; unloadInterval ]) ifTrue: [ ^ OrderedCollection new ].	result := super unloadableClusterIDs select: 		[: cid | | access |			access := accessTable at: cid ifAbsent: nil.			access notNil and: 				[ | loadTime |					( loadTime := access loadTime ) notNil and: [ loadTime + minAge &lt; time ]				]		].	result notEmpty ifTrue: [ lastUnloadAttempt := time. ].	^ result</body><body package="COClusterManagement">unloadableClustersWithout: clusterIDsToKeep background: boolean ignoreRestrictions: ignoreRestrictions 	^ ( boolean and: [ lastUnloadAttempt notNil ]) 		ifTrue: 		[ | oldVal |			oldVal := lastUnloadAttempt.			[ super unloadableClustersWithout: clusterIDsToKeep background: boolean ignoreRestrictions: ignoreRestrictions ] ensure: [ lastUnloadAttempt := oldVal ]		]		ifFalse: [ super unloadableClustersWithout: clusterIDsToKeep background: boolean ignoreRestrictions: ignoreRestrictions ]</body></methods><methods><class-id>COAST.MinAgeLRUUnloadStrategy</class-id> <category>copying</category><body package="COClusterManagement">initializeFrom: anotherUnloadStrategy	"transfer all those values that the configuration usually sets"	super initializeFrom: anotherUnloadStrategy.	self		minAge: anotherUnloadStrategy minAge;		unloadInterval: anotherUnloadStrategy unloadInterval.	^self</body></methods><methods><class-id>COAST.MinAgeLRUUnloadStrategy</class-id> <category>printing</category><body package="COClusterManagement">additionalInfoStringOn: stream	super additionalInfoStringOn: stream.	stream cr; tab; nextPutAll: 'minAge: '.	self minAge printOn: stream.	stream cr; tab; nextPutAll: 'unloadInterval: '.	self unloadInterval printOn: stream.</body></methods><methods><class-id>COAST.MinAgeLRUUnloadStrategy class</class-id> <category>instance creation</category><body package="COClusterManagement">new	^ super new initialize</body></methods><methods><class-id>COAST.MinAgeLRUUnloadStrategy class</class-id> <category>constants</category><body package="COClusterManagement">strategyShortName	^ 'MinAgeLRU'</body></methods><methods><class-id>COAST.CatCSSlotDefinition</class-id> <category>demons</category><body package="COBase">addDemon: aCatCSDemon	demons isNil ifTrue: [ demons := OrderedCollection new. ].	demons add: aCatCSDemon.	responsibleDemons := nil.</body><body package="COBase">allDemonsDo: aBlock	(CatCSEndCell demonsEnabled and: [demons notNil ])		ifTrue: [ demons do: aBlock ].</body><body package="COFramesystem">allResponsibleDemonsFor: anAccess 	| allResponsibleDemons demon |	allResponsibleDemons := CatCSEndCell demonsEnabled 			ifTrue: [ self responsibleDemonsAt: anAccess class id ]			ifFalse: [ #( )].	^ ( anAccess isLocalCell not and: [ anAccess hasAddedTempObjects ]) 		ifTrue: 		[	demon := ( COAST.CatFSDemon writeOnly )					postJob: 						[: theDemon : access : slot |							access arguments do: 								[: arg | ( arg isTempSharedFrame and: [( arg fastAt: #coastInternalReferencedBy includes: slot frame ) not ]) 										ifTrue: [ arg at: #coastInternalReferencedBy add: slot frame ]								]						];					name: #markReferencedTempFrames;					yourself.			allResponsibleDemons copyWith: demon		]		ifFalse: [ allResponsibleDemons ]</body><body package="COBase">canceledDemon: aDemonName 	| demon |	demons isNil ifTrue: [ ^ nil ].	demon := demons 				detect: [ :d | d name = aDemonName]				ifNone: [ nil ].	demon notNil ifTrue: [ demons remove: demon ].	responsibleDemons := nil.	^ demon</body><body package="COBase">demonNamed: aName 	^ self demons notNil 		ifTrue: 		[	self demons 				detect: [: demon | demon name = aName ]				ifNone: nil		]		ifFalse: [ nil ]</body><body package="COFramesystem">depleteSlotBeforeIsolate	^ self demons notNil and: [ self demons contains: [: demon | demon interestedInPreIsolate ]]</body><body package="COCellAccesses">initializeResponsibleDemons	" for each access class, compute all responsible demons "	" should be in COBase, unfortunately CatCSCellAccess is in COCellAccesses "	responsibleDemons := OrderedCollection new.	CatCSCellAccess withAllSubclasses do: 		[: accessClass | | responsible |			accessClass id &gt; 0 ifTrue: 				[	responsible := nil.					demons notNil ifTrue: 						[	demons do: 								[: demon | ( demon isResponsibleForAccessClass: accessClass ) ifTrue: 										[	responsible notNil 												ifTrue: [ responsible add: demon ]												ifFalse: [ responsible := OrderedCollection with: demon ]										]								]						].					responsibleDemons size &lt; accessClass id ifTrue: [ responsibleDemons changeSizeTo: accessClass id ].					responsible := responsible isNil 							ifTrue: [ #( )]							ifFalse: [ responsible asArray ].					responsibleDemons at: accessClass id put: responsible				]		].	^ responsibleDemons := responsibleDemons asArray</body><body package="COBase">removeDemon: aCatFSDemonName	demons isNil ifTrue: [ ^ nil ].	responsibleDemons := nil.	^ demons remove: (self demonNamed: aCatFSDemonName) ifAbsent: nil</body><body package="COFramesystem">responsibleDemonsAt: accessID 	( demons isNil or: [ demons isEmpty ]) ifTrue: [ ^ #( )].	responsibleDemons isNil ifTrue: [ self initializeResponsibleDemons ].	^ responsibleDemons at: accessID</body></methods><methods><class-id>COAST.CatCSSlotDefinition</class-id> <category>accessing</category><body package="COBase">allowRPCs	^ allowRPCs ~~ false</body><body package="COBase">allowRPCs: boolean 	allowRPCs := boolean</body><body package="COBase">clientData	" dictionary to store additional information about the slot "	clientData isNil		ifTrue: [ clientData := Dictionary new ].	^ clientData</body><body package="COBase">coastID	^ slotName</body><body package="COBase">coastID: aSymbol	slotName := aSymbol</body><body package="COBase">definedBy	^ definedBy</body><body package="COBase">definedBy: aDefinedBy 	definedBy := aDefinedBy.</body><body package="COBase">demons	^ demons</body><body package="COBase">forceRPC	^ forceRPC == true</body><body package="COBase">forceRPC: aForceRPC 	forceRPC := aForceRPC.</body><body package="COBase">isUnknown	^ definedBy == #unknown</body><body package="COBase">minimizeInvalidation	^ minimizeInvalidation</body><body package="COBase">minimizeInvalidation: aBoolean 	minimizeInvalidation := aBoolean</body><body package="COBase">prototype	^ prototype</body><body package="COBase">prototype: aCatCSEndCell	prototype := aCatCSEndCell</body><body package="COFramesystem">removeAllDemons	demons := #( ).	responsibleDemons := nil.</body><body package="COBase">slotName	^ slotName</body><body package="COBase">slotName: aSymbol	slotName := aSymbol</body></methods><methods><class-id>COAST.CatCSSlotDefinition</class-id> <category>initialize-release</category><body package="COBase">initialize	minimizeInvalidation := false.</body></methods><methods><class-id>COAST.CatCSSlotDefinition class</class-id> <category>instance creation</category><body package="COBase">new	^ super new initialize</body></methods><methods><class-id>COAST.ReadOnlyBlockFileVolumeAccessor</class-id> <category>accessing</category><body package="COBlockFileSystem">backupDirectory	^ Filename tempDirectory</body><body package="COBlockFileSystem">basicNewClusterStorageAccessorFor: aVolume	CoastLog logWarning: 'Volume ', aVolume, ' is read-only!'.	^ super basicNewClusterStorageAccessorFor: aVolume</body><body package="COBlockFileSystem">checkVolume: volume clusterManager: clusterManagerOrNil 	^ nil</body><body package="COBlockFileSystem">deleteDirectory: deleteDir</body><body package="COBlockFileSystem">ensureDirectoryNamed: dirName	| dir |	dir := self baseDirectory construct: dirName.	^ dir</body><body package="COBlockFileSystem">recoverVolume: volume	^ nil</body></methods><methods><class-id>COAST.ReadOnlyBlockFileVolumeAccessor class</class-id> <category>accessing</category><body package="COBlockFileSystem">storageAccessorClass	^ ReadOnlyBlockFileStorageAccessor</body></methods><methods><class-id>COAST.ReadOnlyBlockFileStorageAccessor</class-id> <category>utility</category><body package="COBlockFileSystem">removeAllClusters</body><body package="COBlockFileSystem">removeClustersByAge: seconds andSize: maxSize</body></methods><methods><class-id>COAST.ReadOnlyBlockFileStorageAccessor</class-id> <category>requests - blob</category><body package="COBlockFileSystem">importBlob: blobIDInteger fromFile: aFilename 	" readonly "</body><body package="COBlockFileSystem">importBlob: blobIDInteger fromStream: readStream 	" readonly "</body><body package="COBlockFileSystem">writeStreamOnBlob: blobIDInteger	" readonly "</body><body package="COBlockFileSystem">writeStreamOnBlob: blobIDInteger size: anInteger 	" readonly "</body></methods><methods><class-id>COAST.ReadOnlyBlockFileStorageAccessor</class-id> <category>accessing</category><body package="COBlockFileSystem">gcEnabled	^ false</body></methods><methods><class-id>COAST.ReadOnlyBlockFileStorageAccessor</class-id> <category>private</category><body package="COBlockFileSystem">writeStreamOnCluster: clusterIDInteger	^ ByteArray new writeStream</body></methods><methods><class-id>COAST.ReadOnlyBlockFileStorageAccessor</class-id> <category>requests</category><body package="COBlockFileSystem">saveAllClustersFor: streamableClusters updatedIndexAccess: frameClassIndex 	^ true</body></methods><methods><class-id>COAST.ReadOnlyBlockFileStorageAccessor class</class-id> <category>accessing</category><body package="COBlockFileSystem">blockFileSystemClass	^ ReadOnlyBlockFileSystem</body></methods><methods><class-id>COAST.CatCSCellValueDifferences</class-id> <category>accessing</category><body package="COBase">added	^ added notNil 		ifTrue: [ added ]		ifFalse: [ #( )]</body><body package="COBase">added: aSet		added := aSet</body><body package="COBase">addedDo: block 	added notNil ifTrue: [ added do: block ].</body><body package="COBase">addedOrNil		^ added</body><body package="COBase">removed	^ removed notNil 		ifTrue: [ removed ]		ifFalse: [ #( )]</body><body package="COBase">removed: aSet		removed := aSet</body><body package="COBase">removedDo: block 	removed notNil ifTrue: [ removed do: block ].</body><body package="COBase">removedOrNil		^ removed</body></methods><methods><class-id>COAST.CatCSCellValueDifferences class</class-id> <category>instance creation</category><body package="COBase">added: addedSet removed: removedSet	^ self new		added: addedSet;		removed: removedSet;		yourself</body><body package="COBase">newEmpty	emptyDifferencesSingleton isNil		ifTrue: [ emptyDifferencesSingleton :=  self added: Set new removed: Set new ].	^ emptyDifferencesSingleton</body></methods><methods><class-id>COAST.DuplicateSlotCreation</class-id> <category>accessing</category><body package="COTransactions">conflictingType	^ conflictingType</body><body package="COTransactions">conflictingType: aConflictingType 	conflictingType := aConflictingType.</body></methods><methods><class-id>COAST.DuplicateSlotCreation</class-id> <category>printing</category><body package="COTransactions">printOn: aStream	"beware: conflictingAgenda is nil"	aStream nextPutAll: self class name; space.		aStream nextPutAll: 'Slot '.	slotCreation slotName printOn: aStream.	aStream nextPutAll: ' of frame '.	slotCreation frameID printOn: aStream.	aStream nextPutAll: ' was created with different types ('.	slotCreation valueHolderClass printOn: aStream.	aStream nextPutAll: ' vs '.	conflictingType printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>COAST.DuplicateSlotCreation class</class-id> <category>instance creation</category><body package="COTransactions">conflictingAgenda: aConflictingAgenda slotCreation: slotCreation conflictingType: aConflictingType	^ (self conflictingAgenda: aConflictingAgenda slotCreation: slotCreation)		conflictingType: aConflictingType;		yourself</body></methods><methods><class-id>COAST.AbstractMultiValueDictionary</class-id> <category>accessing</category><body package="COBase">add: assoc 	self atKey: assoc key add: assoc value</body><body package="COBase">anyKey	^ self subclassResponsibility</body><body package="COBase">asArray	^ self values asArray</body><body package="COBase">asSet	^ Set withAll: self values</body><body package="COBase">at: key	^self atKey: key</body><body package="COBase">atKey: key 	^ self atKey: key ifAbsent: [ self valuesCollectionClass new ]</body><body package="COBase">atKey: key add: value 	self subclassResponsibility</body><body package="COBase">atKey: key addAll: valueCollection	valueCollection do: [ : v | self atKey: key add: v ]</body><body package="COBase">atKey: key ifAbsent: aBlock 	self subclassResponsibility</body><body package="COBase">atKey: key includes: value 	self subclassResponsibility</body><body package="COBase">atKey: key remove: value 	^ self atKey: key remove: value ifAbsent: [ self notFoundError ]</body><body package="COBase">atKey: key remove: value ifAbsent: absentBlock 	self subclassResponsibility</body><body package="COBase">atKey: key removeAll: rValues 	self subclassResponsibility.</body><body package="COBase">atKeys: someKeys 	self subclassResponsibility</body><body package="COBase">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COBase">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rValues 	self subclassResponsibility.</body><body package="COBase">coastAsSet	^ self asSet</body><body package="COBase">coastCompactElementCount	^ self size</body><body package="COBase">coastDepletedValue	^ self class new</body><body package="COBase">eachKeyIn: someKeys do: eachKeyBlock	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index.	Equivalent to 		(self atKeys: someKeys) keysDo: eachKeyBlock	but faster for some classes "	someKeys do: 		[: key | | valuesOrNil |			valuesOrNil := self atKey: key ifAbsent: nil.			valuesOrNil notNil ifTrue: [ valuesOrNil do: [ : v | eachKeyBlock value: key ] ]		].</body><body package="COBase">keys	^ self subclassResponsibility</body><body package="COBase">keysAtValue: value	| keys |	keys := Set new.	self keysAndValuesDo: [ : k : v | v = value ifTrue: [ keys add: k ] ].	^keys</body><body package="COBase">removeKey: key 	^ self removeKey: key ifAbsent: [ self notFoundError ]</body><body package="COBase">removeKey: key ifAbsent: absentBlock 	self subclassResponsibility</body><body package="COBase">selectKeys: someKeys whichInclude: aValue 	^ someKeys select: [: key | self atKey: key includes: aValue ]</body><body package="COBase">values	self subclassResponsibility</body></methods><methods><class-id>COAST.AbstractMultiValueDictionary</class-id> <category>iterating</category><body package="COBase">allSatisfy: aBlock 	self do: [: e | ( aBlock value: e ) ifFalse: [ ^ false ]].	^ true</body><body package="COBase">associationsDo: block 	self keysAndValuesDo: [ : k : v | block value: k -&gt; v ].</body><body package="COBase">coastAllArgumentsDo: aBlock 	self keysAndValuesDo: 		[: k : v |			aBlock value: k.			aBlock value: v		].</body><body package="COBase">collect: aBlock 	"Evaluate aBlock with each of the values of the receiver as the  	argument.  Collect the resulting values into a collection.	 Answer the new collection."	| newCollection |	newCollection := self valuesCollectionClass new: self size.	self do: [: each | newCollection add: ( aBlock value: each )].	^ newCollection</body><body package="COBase">contains: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	 Answer true if aBlock ever evaluates to true, otherwise answer false."	self 		detect: aBlock		ifNone: [ ^ false ].	^ true</body><body package="COBase">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [: each | ( aBlock value: each ) ifTrue: [ ^ each ]].	^ exceptionBlock value</body><body package="COBase">do: block 	self subclassResponsibility</body><body package="COBase">keysAndValuesDo: block 	self subclassResponsibility</body><body package="COBase">keysDo: block 	self subclassResponsibility</body><body package="COBase">referencesElementsCursorDo: aBlock 	self associationsDo: aBlock.</body><body package="COBase">reject: aBlock 	| newCollection |	newCollection := self valuesCollectionClass new: self size.	self do: [: each | ( aBlock value: each ) ifFalse: [ newCollection add: each ]].	^ newCollection</body><body package="COBase">select: aBlock 	| newCollection |	newCollection := self valuesCollectionClass new: self size.	self do: [: each | ( aBlock value: each ) ifTrue: [ newCollection add: each ]].	^ newCollection</body></methods><methods><class-id>COAST.AbstractMultiValueDictionary</class-id> <category>testing</category><body package="COBase">includesKey: key 	self subclassResponsibility</body><body package="COBase">isEmpty	^ self subclassResponsibility</body><body package="COBase">notEmpty	^ self isEmpty not</body></methods><methods><class-id>COAST.AbstractMultiValueDictionary</class-id> <category>copying</category><body package="COBase">coastCopyWith: awareness	| theCopy |	theCopy := self species new.	self keysAndValuesDo: [:k :v | theCopy atKey: (k coastCopyWith: awareness) add: (v coastCopyWith: awareness)].	^theCopy</body><body package="COTransactions">copyForRollback	^ self copy</body></methods><methods><class-id>COAST.AbstractMultiValueDictionary</class-id> <category>private</category><body package="COBase">copyEmpty: aSize 	"Answer a copy of the receiver that contains no elements.	This method should be redefined in subclasses that add	instance variables, so that the state of those variables	is preserved"	^ self class new: aSize</body><body package="COBase">notFoundError	^ self class notFoundSignal raise</body><body package="COBase">valuesCollectionClass	self subclassResponsibility</body></methods><methods><class-id>COAST.AbstractMultiValueDictionary</class-id> <category>removing</category><body package="COBase">restrictToValues: rvalues 	"return a copy restricted to the given values"	| restrictedDict |	restrictedDict := self species new: rvalues size.	self keysAndValuesDo: [ : k : v | (rvalues includes: v) ifTrue: [ restrictedDict atKey: k add: v ] ].	^restrictedDict</body></methods><methods><class-id>COAST.AbstractMultiValueDictionary</class-id> <category>converting</category><body package="COBase">asMultiValueDictionary	| index |	index := MultiValueDictionary new: self size.	self keysAndValuesDo: [ : k : v | index atKey: k add: v ].	^index</body></methods><methods><class-id>COAST.CreateSlotOfUnknownFrame</class-id> <category>printing</category><body package="COTransactions">printOn: aStream	"beware: conflictingAgenda is nil"	aStream nextPutAll: self class name; space.		aStream nextPutAll: 'Slot creation '.	slotCreation slotName printOn: aStream.	aStream nextPutAll: ' failed: Frame '.	slotCreation frameID printOn: aStream.	aStream nextPutAll: ' not found in cluster '.</body></methods><methods><class-id>COAST.AbstractSegmentedCollection</class-id> <category>private</category><body package="COBase">atKey: key addSubcollection: collection 	"it is mandatory that no other index shares the same keys as index"	self subclassResponsibility.</body><body package="COBase">capacity	"Answer how much space the receiver has to contain elements."	^self basicSize</body><body package="COBase">changeCapacityTo: newCapacity 	"Change the size of the receiver to newCapacity.  The receiver will	be regrown if necessary to fit its contents."	"Note that #rehash uses this -- don't optimize the case where	the receiver doesn't change in size."	| newSelf |	newSelf := self copyEmpty: newCapacity.	self valuesAssociationsDo: [: each | newSelf noCheckAdd: each ].	self become: newSelf.</body><body package="COBase">copyEmpty: aSize 	"Answer a copy of the receiver that contains no elements.	This method should be redefined in subclasses that add	instance variables, so that the state of those variables	is preserved"	^ self class new: aSize</body><body package="COBase">diffCollection	"use one index for all adds not applyable to a compact index"	diffCollection isNil ifTrue: [ diffCollection := self diffCollectionClass new ].	^ diffCollection</body><body package="COBase">diffCollectionClass	self subclassResponsibility.</body><body package="COBase">findKeyOrNil: key 	"Look for the key in the receiver.  If it is found, answer	the index of the association containing the key, otherwise	answer the index of the first unused slot."	| location length probe pass |	length := self basicSize.	pass := 1.	location := self initialIndexFor: key hash boundedBy: length.	[( probe := self basicAt: location ) == nil or: [ probe key = key ]] whileFalse: 		[( location := location + 1 ) &gt; length ifTrue: 				[	location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [ ^ nil ]				]		].	^ location</body><body package="COBase">fixCollisionsFrom: index 	| myLength oldIndex nextIndex nextObject |	oldIndex := index.	myLength := self basicSize.	[	oldIndex := oldIndex \\ myLength + 1.		nextObject := self basicAt: oldIndex.		nextObject == nil	] whileFalse: 		[	nextIndex := self findKeyOrNil: nextObject key.			nextIndex = oldIndex ifFalse: 				[	self basicAt: nextIndex put: nextObject.					self basicAt: oldIndex put: nil				]		].</body><body package="COBase">grow	"The receiver becomes roomier."	self changeCapacityTo: self capacity + self growSize</body><body package="COBase">growSize	"Answer an amount by which the receiver should grow 	to make room for more elements."	^self capacity max: 2</body><body package="COBase">initialIndexFor: aHashValue boundedBy: length 	"Find the place where we should start the search.	Optimize for relatively small dictionaries."	"Objects whose hashes are based on their identityHash are restricted 	by current implementations to the range 0 to some small number 	like 16383. For collections whose sizes are much larger than this 	number, using the hash as-is would tend to cause collisions at the 	low end, leading to performance bottlenecks. To compensate, we use 	an algorithm to spread small hash values more evenly across large 	collections. Large hash values, however, are used as-is, under the 	assumption that they are more likely to have been adequately 	spread, and also to avoid LargeInteger performance loss."	^ ( length &gt; Set.SmallCollectionLimit and: [ aHashValue &lt;= ObjectMemory maximumIdentityHashValue ]) 		ifTrue: [ aHashValue * ( length // Set.SmallCollectionLimit + 1 ) \\ length + 1 ]		ifFalse: [ aHashValue \\ length + 1 ]</body><body package="COBase">noCheckAdd: anObject 	"Assume that anObject is not in the receiver and add it	without checking to make sure."	self basicAt: ( self findKeyOrNil: anObject key ) put: anObject</body><body package="COBase">notFoundError	^ self class notFoundSignal raise</body><body package="COBase">postRPCInitializeWith: delegatingProxy 	" done while creating... "</body><body package="COBase">saveFindKeyOrNil: key 	^ ( self findKeyOrNil: key ) ifNil: [ self grow findKeyOrNil: key ]</body><body package="COBase">subCollectionOrNilAtKey: key 	"Answer the index at key.  If key is not found, return nil."	| pos |	pos := self findKeyOrNil: key.	^ pos notNil 		ifTrue: [( self basicAt: pos ) value ]		ifFalse: [ nil ]</body><body package="COBase">subcollectionNeededAtKey: key 	"Answer the index at key.  If key is not found, return nil."	| pos subCol |	pos := self saveFindKeyOrNil: key.	subCol := ( self basicAt: pos ) value.	subCol isNil ifTrue: 		[	subCol := self diffCollection.			self basicAt: pos put: key -&gt; subCol		].	^ subCol</body><body package="COBase">valuesAssociationsDo: aBlock 	"Evaluate aBlock for each of the receiver's key/value-set associations."	1 to: self basicSize		do: 		[: index | | elem |			( elem := self basicAt: index ) == nil ifFalse: [ aBlock value: elem ]		].</body><body package="COBase">valuesCollectionClass	self subclassResponsibility.</body></methods><methods><class-id>COAST.AbstractSegmentedCollection</class-id> <category>iterating</category><body package="COBase">associationsDo: block 	self keysAndValuesDo: [ : k : v | block value: k -&gt; v ].</body><body package="COBase">collect: aBlock 	"Evaluate aBlock with each of the values of the receiver as the  	argument.  Collect the resulting values into a collection.	 Answer the new collection."	| newCollection |	newCollection := self valuesCollectionClass new: self size.	self do: [: each | newCollection add: ( aBlock value: each )].	^ newCollection</body><body package="COBase">contains: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	 Answer true if aBlock ever evaluates to true, otherwise answer false."	self 		detect: aBlock		ifNone: [ ^ false ].	^ true</body><body package="COBase">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [: each | ( aBlock value: each ) ifTrue: [ ^ each ]].	^ exceptionBlock value</body><body package="COBase">do: block 	self keysAndValuesDo: [: k : v | block value: v ].</body><body package="COBase">keysAndValuesDo: block 	"Evaluate aBlock for each key value pair."	| done |	done := Set new: self capacity.	self valuesAssociationsDo: 		[: assoc | | subColl |			subColl := assoc value.			( done includes: subColl ) ifFalse: 				[	done add: subColl.					( partialCollections includes: subColl ) 						ifTrue: [ subColl keysAndValuesDo: [: k : v | ( self includesKey: k ) ifTrue: [ block value: k value: v ]]]						ifFalse: [ subColl keysAndValuesDo: block ]				]		].</body><body package="COBase">keysDo: block 	"Evaluate aBlock for each key"	| done |	done := Set new: self capacity.	self valuesAssociationsDo: 		[: assoc | | subColl |			subColl := assoc value.			( done includes: subColl ) ifFalse: 				[	done add: subColl.					( partialCollections includes: subColl ) 						ifTrue: [ subColl keysDo: [: k | ( self includesKey: k ) ifTrue: [ block value: k ]]]						ifFalse: [ subColl keysDo: block ]				]		].</body><body package="COBase">referencesElementsCursorDo: aBlock 	| done |	done := Set new: self capacity.	self valuesAssociationsDo: 		[: assoc | | subColl |			subColl := assoc value.			( done includes: subColl ) ifFalse: 				[	done add: subColl.					( partialCollections includes: subColl ) 						ifTrue: 						[	subColl referencesElementsCursorDo: [: refElem | ( self includesKey: refElem key ) ifTrue: [ aBlock value: refElem ]]						]						ifFalse: [ subColl referencesElementsCursorDo: aBlock ]				]		].</body><body package="COBase">reject: aBlock 	| newCollection |	newCollection := self valuesCollectionClass new: self size.	self do: [: each | ( aBlock value: each ) ifFalse: [ newCollection add: each ]].	^ newCollection</body><body package="COBase">select: aBlock 	| newCollection |	newCollection := self valuesCollectionClass new: self size.	self do: [: each | ( aBlock value: each ) ifTrue: [ newCollection add: each ]].	^ newCollection</body></methods><methods><class-id>COAST.AbstractSegmentedCollection</class-id> <category>copying</category><body package="COBase">coastCopyWith: awareness	| theCopy |	theCopy := self species new.	self keysAndValuesDo: [:k :v | theCopy atKey: (k coastCopyWith: awareness) add: (v coastCopyWith: awareness)].	^theCopy</body><body package="COBase">postCopy	| newPartials |	newPartials := Set new: partialCollections size.	super postCopy.	1 to: self capacity		do: 		[: i | | assoc collectionCopy |			nil == ( assoc := self basicAt: i ) ifFalse: 				[	collectionCopy := assoc value copy.					self basicAt: i put: assoc key -&gt; collectionCopy.					( partialCollections includes: assoc value ) ifTrue: [ newPartials add: collectionCopy ]				]		].	partialCollections := newPartials.</body></methods><methods><class-id>COAST.AbstractSegmentedCollection</class-id> <category>accessing</category><body package="COBase">add: assoc 	self subclassResponsibility.</body><body package="COBase">anyKey	self valuesAssociationsDo: [: assoc | ^ assoc key ].	^ nil</body><body package="COBase">asSet	| set |	set := Set new: self size.	self do: [: v | set add: v ].	^ set</body><body package="COBase">at: key	^self atKey: key</body><body package="COBase">atKey: key 	self subclassResponsibility.</body><body package="COBase">atKey: key ifAbsent: aBlock 	| subCollection |	subCollection := self subCollectionOrNilAtKey: key.	^ subCollection notNil 		ifTrue: [ subCollection atKey: key ifAbsent: aBlock ]		ifFalse: [ aBlock value ]</body><body package="COBase">atKeys: keys 	self subclassResponsibility.</body><body package="COBase">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COBase">basicRemoveAt: pos 	self basicAt: pos put: nil.	self fixCollisionsFrom: pos.</body><body package="COBase">coastDepletedValue	^ self diffCollectionClass new</body><body package="COBase">eachKeyIn: someKeys do: eachKeyBlock 	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index.	Equivalent to 		(self atKeys: someKeys) keysDo: eachKeyBlock	but faster for some classes "	self subclassResponsibility.</body><body package="COBase">includesKey: key 	| pos |	pos := self findKeyOrNil: key.	^ pos notNil</body><body package="COBase">keys	| keys |	keys := Set new: self basicSize.	self keysDo: [: k | keys add: k ].	^ keys</body><body package="COBase">removeKey: key 	^ self removeKey: key ifAbsent: [ self notFoundError ]</body><body package="COBase">removeKey: key ifAbsent: absentBlock 	| subCollection pos |	pos := self findKeyOrNil: key.	subCollection := pos notNil 			ifTrue: [( self basicAt: pos ) value ]			ifFalse: [ nil ].	subCollection notNil ifTrue: 		[	subCollection removeKey: key ifAbsent: absentBlock.			partialCollections add: subCollection.			self basicRemoveAt: pos.			size := size - ( subCollection sizeAtKey: key )		].</body><body package="COBase">size	^ size</body><body package="COBase">values	| values |	values := self valuesCollectionClass new: self size.	self do: [: v | values add: v ].	^ values</body></methods><methods><class-id>COAST.AbstractSegmentedCollection</class-id> <category>converting</category><body package="COBase">asMultiValueDictionary	| index |	index := MultiValueDictionary new: self size.	self keysAndValuesDo: [ : k : v | index atKey: k add: v ].	^index</body></methods><methods><class-id>COAST.AbstractSegmentedCollection</class-id> <category>testing</category><body package="COBase">isEmpty	^ self size &gt; 0</body><body package="COBase">notEmpty	^ self isEmpty not</body></methods><methods><class-id>COAST.AbstractSegmentedCollection</class-id> <category>removing</category><body package="COBase">restrictToValues: rvalues 	"return a copy restricted to the given values"	| restrictedDict |	restrictedDict := self diffCollectionClass new: rvalues size.	self keysAndValuesDo: [: k : v | ( rvalues includes: v ) ifTrue: [ restrictedDict atKey: k add: v ]].	^ restrictedDict</body></methods><methods><class-id>COAST.AbstractSegmentedCollection</class-id> <category>initialize</category><body package="COBase">initialize	size := 0.	partialCollections := Set new.</body></methods><methods><class-id>COAST.AbstractSegmentedCollection class</class-id> <category>instance creation</category><body package="COBase">new	^ self new: 2</body><body package="COBase">new: anInteger 	anInteger &gt;= 0 ifFalse: [ Set improperCreationSizeSignal raiseWith: anInteger ].	^ ( super new: ( Set goodSizeFrom: anInteger ))		initialize;		yourself</body></methods><methods><class-id>COAST.CatRMMultiPartUpdateMessage</class-id> <category>accessing</category><body package="COTransactions">allTransactionIDs	^allTransactionIDs</body></methods><methods><class-id>COAST.CatRMMultiPartUpdateMessage</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	super marshallBinaryTo: aStream marshaller: aCatRMMarshall.	allTransactionIDs isNil ifTrue: [ allTransactionIDs := OrderedCollection new ].	aStream nextOptimized32Put: allTransactionIDs size.	allTransactionIDs do: [: tid | tid marshallBinaryTo: aStream marshaller: aCatRMMarshall ].</body><body package="COTransactions">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	| numOfTids |	super unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager.	numOfTids := aStream nextOptimized32.	allTransactionIDs := OrderedCollection new: numOfTids.	numOfTids timesRepeat: [ allTransactionIDs addLast: ( CatRMTransactionID new unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall )].</body></methods><methods><class-id>COAST.CatFSFrameID</class-id> <category>accessing</category><body package="COBase">= anObject 	^ anObject equalFromFrameID: self</body><body package="COBase">equalFromFrameID: anotherFrameID 	^ frameID == anotherFrameID frameID</body><body package="COBase">frameForCluster: aCatCSCluster	^ aCatCSCluster directTableAccessAt: self frameID</body><body package="COBase">frameID	^frameID</body><body package="COBase">frameID: aFrameID	frameID := aFrameID</body><body package="COBase">id	^ self frameID</body><body package="COBase">id: anID	self frameID: anID</body><body package="COBase">translatedArgumentForCluster: aCatCSCluster 	| f |	f := self frameForCluster: aCatCSCluster.	f isNil ifTrue: 		[	self 				haltOrError: 'Frame argument ' , aCatCSCluster clusterID printString , 				'/' , self printString , ' not found'		].	" hook for Mediator "	^ f translatedArgumentForCluster: aCatCSCluster</body></methods><methods><class-id>COAST.CatFSFrameID</class-id> <category>printing</category><body package="COBase">basicPrintOn: aStream 	self frameID printOn: aStream</body><body package="COTransactions">ccPrintStringOn: stream withClusterID: clusterID	stream nextPutAll: 'ID'.	clusterID printOn: stream.	stream nextPut: $_.	self basicPrintOn: stream.</body><body package="COBase">printOn: aStream 	aStream nextPutAll: self shortClassName.	aStream nextPut: $(.	self basicPrintOn: aStream.	aStream nextPut: $)</body><body package="COBase">shortClassName	^ 'frameID '</body></methods><methods><class-id>COAST.CatFSFrameID</class-id> <category>testing</category><body package="COFramesystem">isResolved	^ false</body><body package="COBase">isTempShared	^ self class isTempShared: frameID</body><body package="COFramesystem">isUnresolved	^ true</body></methods><methods><class-id>COAST.CatFSFrameID</class-id> <category>comparing</category><body package="COBase">hash	^ frameID hash</body></methods><methods><class-id>COAST.CatFSFrameID</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self class marshallID.	aStream nextOptimized32Put: self frameID.</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	self id: aStream nextOptimized32.</body></methods><methods><class-id>COAST.CatFSFrameID class</class-id> <category>instance creation</category><body package="COBase">id: anID	^ self new		id: anID;			yourself</body></methods><methods><class-id>COAST.CatFSFrameID class</class-id> <category>accessing</category><body package="COBase">errorSignal	^ CoastError</body><body package="COBase">isTempShared: frameID	^ frameID isInteger and: [ frameID &lt; 0 ]</body></methods><methods><class-id>COAST.CatFSFrameID class</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryValue: frameID to: aStream 	aStream nextPut: self marshallID.	aStream nextOptimized32Put: frameID.</body><body package="COMarshalling">marshallID	^ 1</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	^ self new		unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall;		yourself</body><body package="COMarshalling">unmarshallBinaryReferenceFrom: aStream marshaller: marshallBinary 	| id ref marshallerClusterID |	id := aStream nextOptimized32.	marshallerClusterID := marshallBinary currentClusterID.	ref := marshallBinary clusterController cluster frameFor: id.	ref isNil ifTrue: 		[	CoastLog logWarning: 'frame reference not found: cluster ' , marshallerClusterID printString , ' frame ' , id printString.			FrameNotFoundError signalWith: ( CatCSFrameLocator newFrameID: id clusterID: marshallerClusterID )		].	^ ref</body></methods><methods><class-id>COAST.CoastWeakSet</class-id> <category>private</category><body package="COBase">atNewIndex: index put: anObject 	self basicAt: index put: anObject.	tally value: tally value + 1.	self fullCheck</body><body package="COBase">changeCapacityTo: newCapacity	"Change the size of the receiver to newCapacity.  The receiver will	be regrown if necessary to fit its contents."	"Note that #rehash uses this -- don't optimize the case where	the receiver doesn't change in size."	| newSelf |	newSelf := self copyEmpty: newCapacity.	self do: [:each | newSelf noCheckAdd: each].	self become: newSelf</body><body package="COBase">find: anObject ifAbsent: aBlock 	| index |	index := self findElementOrNil: anObject.	(self basicAt: index) == nil		ifTrue: [^aBlock value]		ifFalse: [^index]</body><body package="COBase">findElementOrNil: anObject 	"Answer the index of the argument anObject, if present, or the index of a nil	entry where anObject would be placed."	| index length probe pass |	length := self basicSize.	pass := 1.	index := self initialIndexFor: anObject hash boundedBy: length.	[(probe := self basicAt: index) == nil or: [probe = anObject]]		whileFalse: [(index := index + 1) &gt; length				ifTrue: 					[index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findElementOrNil: anObject]]].	^index</body><body package="COBase">fixCollisionsFrom: index 	| myLength oldIndex nextIndex nextObject |	oldIndex := index.	myLength := self basicSize.	[oldIndex := oldIndex \\ myLength + 1.	nextObject := self basicAt: oldIndex.	nextObject == nil]		whileFalse: 			[nextIndex := self findElementOrNil: nextObject.			nextIndex = oldIndex				ifFalse: 					[self basicAt: nextIndex put: nextObject.					self basicAt: oldIndex put: nil]]</body><body package="COBase">fullCheck	"If there is insufficient capacity in the receiver to do efficient lookups,	 then grow.  Require at least 25% free slots, or 1 free slot, whichever	 is the greater."	| cap sizePlusOne |	cap := self capacity.	sizePlusOne := self size + 1.	(sizePlusOne &gt;= cap or: [cap - sizePlusOne &lt; (cap bitShift: -2)])		ifTrue: [self grow]</body><body package="COBase">initialIndexFor: aHashValue boundedBy: length	"Find the place where we should start the search.	Optimize for relatively small dictionaries."	"Objects whose hashes are based on their identityHash are restricted 	by current implementations to the range 0 to some small number 	like 16383. For collections whose sizes are much larger than this 	number, using the hash as-is would tend to cause collisions at the 	low end, leading to performance bottlenecks. To compensate, we use 	an algorithm to spread small hash values more evenly across large 	collections. Large hash values, however, are used as-is, under the 	assumption that they are more likely to have been adequately 	spread, and also to avoid LargeInteger performance loss."	^(length &gt; SmallCollectionLimit and:			[aHashValue &lt;= ObjectMemory maximumIdentityHashValue])		ifTrue: [aHashValue * (length // SmallCollectionLimit + 1) \\ length + 1]		ifFalse: [aHashValue \\ length + 1]</body><body package="COBase">noCheckAdd: anObject 	"Assume that anObject is not in the receiver and add it	without checking to make sure."	self basicAt: (self findElementOrNil: anObject)		put: anObject.	tally value: tally value + 1</body><body package="COBase">setTally	"Initialize the number of elements to be 0."	tally := nil -&gt; 0.</body><body package="COBase">species	^Set</body><body package="COBase">updateTally	| newTally |	newTally := 0.	self do: [: element | newTally := newTally + 1 ].	tally isNil 		ifTrue: [ tally := nil -&gt; newTally ]		ifFalse: [ tally value: newTally ].</body></methods><methods><class-id>COAST.CoastWeakSet</class-id> <category>accessing</category><body package="COBase">add: newObject 	"Include newObject as one of the receiver's elements.  Answer newObject."	| index |	newObject == nil ifTrue: [^newObject].	index := self findElementOrNil: newObject.	(self basicAt: index) == nil ifTrue: [self atNewIndex: index put: newObject].	^newObject</body><body package="COBase">capacity	"Answer how much space the receiver has to contain elements."	^self basicSize</body><body package="COBase">coastAsSetOrYourself	^ Set withAll: self</body><body package="COBase">size	"Answer how many elements the receiver contains."	^tally value</body></methods><methods><class-id>COAST.CoastWeakSet</class-id> <category>enumerating</category><body package="COBase">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="COBase">do: aBlock 	" special service: do not enumerate nil / death markers "	tally value == 0 ifTrue: [ ^ self ].	1 to: self basicSize		do: 		[: index | | elem |			(( elem := self basicAt: index ) ~~ nil and: [ elem ~~ 0 ]) ifTrue: [ aBlock value: elem ]		]</body><body package="COBase">do: elementBlock separatedBy: separatorBlock	"Evaluate elementBlock for each element in the collection.	Between each pair of elements, but not before the first or	after the last, evaluate the separatorBlock."	| first |	first := true.	self do:		[:elmnt |		first ifTrue: [first := false]			ifFalse: [separatorBlock value].		elementBlock value: elmnt]</body></methods><methods><class-id>COAST.CoastWeakSet</class-id> <category>copying</category><body package="COBase">, aSequenceableCollection 	self shouldNotImplement</body><body package="COBase">= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject</body><body package="COBase">hash	^ self identityHash</body><body package="COBase">postCopy	super postCopy.	tally notNil 		ifTrue: [ tally := tally copy ].</body></methods><methods><class-id>COAST.CoastWeakSet</class-id> <category>adding</category><body package="COBase">grow	"The receiver becomes roomier."	self changeCapacityTo: self capacity + self growSize</body></methods><methods><class-id>COAST.CoastWeakSet</class-id> <category>testing</category><body package="COBase">allSatisfy: aBlock	"Answer true if aBlock answers true for all elements of the receiver.	 An empty collection answers true."	self do: [:each| (aBlock value: each) ifFalse: [^false]].	^true</body><body package="COBase">anySatisfy: aBlock	"Answer true if aBlock answers true for any element of the receiver.	 An empty collection answers false."	self do: [:each| (aBlock value: each) ifTrue: [^true]].	^false</body><body package="COBase">includes: anObject 	"Answer whether anObject is one of the receiver's elements."	^nil ~~ (self basicAt: (self findElementOrNil: anObject))</body></methods><methods><class-id>COAST.CoastWeakSet</class-id> <category>removing</category><body package="COBase">remove: oldObject ifAbsent: anExceptionBlock   	"Remove oldObject as one of the receiver's elements.  If several of the	elements are equal to oldObject, only one is removed. If no element is equal to	oldObject, answer the result of evaluating anExceptionBlock.  Otherwise,	answer the argument, oldObject."	| index |	index := self find: oldObject ifAbsent: [^anExceptionBlock value].	self basicAt: index put: nil.	tally value: tally value - 1.	self fixCollisionsFrom: index.	^oldObject</body></methods><methods><class-id>COAST.CoastWeakSet</class-id> <category>finalization</category><body package="COBase">mourn	self updateTally.</body></methods><methods><class-id>COAST.CoastWeakSet class</class-id> <category>gc bug</category><body package="COBase">example	"assert engine darf hier keine assertion failures zeigen "	"self example"	| s |	s := self new.	[ | dummies |		dummies := Array new: 100000.		1 to: dummies size			do: 			[: i | | temp |				temp := i @ i.				dummies at: i put: temp			].		( Delay forMilliseconds: 10 ) wait.		InputState default ctrlDown	] whileFalse.</body></methods><methods><class-id>COAST.CoastWeakSet class</class-id> <category>instance creation</category><body package="COBase">new: anInteger 	anInteger &gt;= 0 ifFalse: [ Set improperCreationSizeSignal raiseWith: anInteger ].	^ ( super new: ( Set goodSizeFrom: anInteger )) setTally</body></methods><methods><class-id>COAST.CatRMDidRejectMessage</class-id> <category>testing</category><body package="COTransactions">didAccept	^false</body></methods><methods><class-id>COAST.CatRMDidRejectMessage</class-id> <category>initialize</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall	"nothing to do"</body></methods><methods><class-id>COAST.CatRMDidRejectMessage</class-id> <category>marshalling</category><body package="COTransactions">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	"nothing to do"</body></methods><methods><class-id>COAST.CoastWinService</class-id> <category>logging</category><body package="COBase">log: aString	CoastLog log: aString.</body><body package="COBase">logDebug: aString	CoastLog logDebugNotify: aString.</body></methods><methods><class-id>COAST.CoastWinService</class-id> <category>startup/shutdown</category><body package="COBase">startAsService: startUpBlock postStartBlock: postStartBlock shutdownBlock: shutdownBlock 	^ [ super startAsService: startUpBlock postStartBlock: postStartBlock shutdownBlock: shutdownBlock ] 		on: WinServiceStartupError		do: 		[: ex |			CoastLog logException: ex message: ex description.			ObjectMemory quit		]</body></methods><methods><class-id>COAST.CatRMSlotAccessForInvalidation</class-id> <category>comparing</category><body package="COTransactions">= anotherAccess	"arguments have to be the same too"	^super = anotherAccess		and: [ arguments = anotherAccess arguments ]</body><body package="COTransactions">frame: frame 	self frameID: frame idForMinimalInvalidation.	self frameClassSymbol: frame frameClassSymbol.</body><body package="COTransactions">hash	^ frameID hash bitXor: slotName hash</body></methods><methods><class-id>COAST.CatRMDidAcceptMessage</class-id> <category>accessing</category><body package="COTransactions">addTransactionID: id	transactionIDs add: id</body><body package="COTransactions">addTransactionIDs: someTransactionIDs	transactionIDs addAll: someTransactionIDs</body><body package="COTransactions">replacementAgendas: agendas 	replacementAgendas := agendas</body><body package="COTransactions">transactionIDs	^transactionIDs</body></methods><methods><class-id>COAST.CatRMDidAcceptMessage</class-id> <category>testing</category><body package="COTransactions">didAccept	^true</body></methods><methods><class-id>COAST.CatRMDidAcceptMessage</class-id> <category>initialize</category><body package="COTransactions">initialize	transactionIDs := OrderedCollection new</body></methods><methods><class-id>COAST.CatRMDidAcceptMessage</class-id> <category>update</category><body package="COTransactions">rollReplacementsWithCC: clusterController 	replacementAgendas do: 		[: simpleAgenda | | cc |			cc := clusterController clusterManager clusterControllerAt: simpleAgenda clusterLocator id.			cc isNil ifFalse: [ simpleAgenda rollForwardForClusterController: cc ]		]</body></methods><methods><class-id>COAST.CatRMDidAcceptMessage</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: transactionIDs size.	transactionIDs do: [: eachTransactionID | eachTransactionID marshallBinaryTo: aStream marshaller: aCatRMMarshall ].	aStream nextOptimized32Put: replacementAgendas size.	replacementAgendas do: [: access | access marshallBinaryTo: aStream marshaller: aCatRMMarshall ].</body><body package="COTransactions">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	| size volume |	volume := nil.	aStream nextOptimized32 timesRepeat: 		[ | newTransactionID transactionVolume |			newTransactionID := CatRMTransactionID new.			newTransactionID unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall.			self addTransactionID: newTransactionID.			transactionVolume := newTransactionID clusterLocator volume.			( volume notNil and: [ volume ~= transactionVolume ]) 				ifTrue: 				[	CoastTransactionError 						raiseSignal: 'Accept received for transaction that touched for more than one volume (' , newTransactionID printString , ')'				]				ifFalse: [ volume := transactionVolume ]		].	aCatRMMarshall clusterManager: (aCatCSVolumeManager clusterManagerForVolume: volume).	size := aStream nextOptimized32.	replacementAgendas := OrderedCollection new: size.	size &gt; 0 		ifTrue: 		[	aCatRMMarshall clusterManager isNil 				ifTrue: [ CoastError raiseSignal: 'No cluster manager found for unmarshalling accept message' ].			size timesRepeat: [ replacementAgendas add: ( CatRMSimpleAgenda new unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall )]		].</body></methods><methods><class-id>COAST.CatRMDidAcceptMessage class</class-id> <category>instance creation</category><body package="COTransactions">new 	^(super new)		initialize;		yourself</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferencesIfNeeded	"compute differences between pre- and post-access"</body><body package="COCellAccesses">keepDifferences	"tells me to keep differences between pre- and post-access"</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>accessing</category><body package="COTransactions">addToAgenda: agenda 	self subclassResponsibility</body><body package="COTransactions">allArgumentsDo: aBlock	1 to: self size do: [ : i |		aBlock value: (self at: i)	].</body><body package="COCellAccesses">argument	self size = 1 		ifFalse: [ CoastError raiseSignal: 'Expected 1 argument, got ', self size printString ].	^ self at: 1</body><body package="COCellAccesses">argumentAt: i	^ self at: i</body><body package="COCellAccesses">argumentsDo: aBlock	1 to: self size do: [ : i |		aBlock value: (self at: i)	].</body><body package="COCellAccesses">buildUpDependencies	^ cellOrCellWrapper buildUpDependenciesForTransaction: self transaction access: self</body><body package="COCellAccesses">cell	^ cellOrCellWrapper notNil 		ifTrue: [ cellOrCellWrapper unwrappedCell ]		ifFalse: [ nil ]</body><body package="COCellAccesses">cell: aCell 	| transactionManager |	cellOrCellWrapper isNil ifTrue: [ cellOrCellWrapper := aCell ].	transaction isNil ifTrue: 		[	transactionManager := cellOrCellWrapper transactionManager.			transaction := transactionManager notNil 					ifTrue: [ transactionManager activeTransactionOfCurrentProcess ]					ifFalse: 					[	"fishy fallBack"						Processor activeTransaction					]		].</body><body package="COCellAccesses">differencesToBeginOfTransaction	^transaction differencesToBeginOfTransaction: self</body><body package="COCellAccesses">firstArgument	^ self size &gt;= 1 		ifTrue: [ self at: 1 ]		ifFalse: [ nil ]</body><body package="COCellAccesses">isReadAccess	^self class isReadAccess</body><body package="COCellAccesses">isWriteAccess	^self class isWriteAccess</body><body package="COTransactions">maskedByValueWrite: access 	^ false</body><body package="COCellAccesses">numberOfArguments	^ self size</body><body package="COCellAccesses">secondArgument	^ self size &gt;= 2 		ifTrue: [ self at: 2 ]		ifFalse: [ nil ]</body><body package="COCellAccesses">slotName	^ self size &gt;= 1		ifTrue: [ self at: 1 ]		ifFalse: [ nil ]</body><body package="COCellAccesses">transaction	^transaction</body><body package="COCellAccesses">transaction: aTransaction	transaction := aTransaction</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>testing</category><body package="COTransactions">hasAddedTempObjects	self subclassResponsibility.</body><body package="COCellAccesses">isInvertingAccess	^ false</body><body package="COCellAccesses">isUpdateAccess	^ self class isUpdateAccess</body><body package="COCellAccesses">isValidAccess	" Answer whether the access is conforming to the COAST rules or not "	^ true</body><body package="COCellAccesses">isValueWriteAccess	^ self class isValueWriteAccess</body><body package="COCellAccesses">skipValidAccessTest	^ transaction notNil and: [ transaction skipValidAccessTest ]</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>performing</category><body package="COCellAccesses">arg1	" no bounds check "	^ self at: 1</body><body package="COCellAccesses">arg2	" no bounds check "	^ self at: 2</body><body package="COCellAccesses">performOn: aCatCSCellValueHolder	"subclasse should perform the access now "	self subclassResponsibility.</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>private</category><body package="COCellAccesses">setArgument1: aValue argument2: aValue2	self at: 1 put: aValue.	self at: 2 put: aValue2.</body><body package="COCellAccesses">setArgument: aValue 	self at: 1 put: aValue.</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>accessing - obsolete</category><body package="COCellAccesses">argument: aValue 	self haltOrError: 'Obsolete method sent'</body><body package="COCellAccesses">arguments	| args n |	args := Array new: (n := self size).	1 to: n do: [ : i | args at: i put: (self at: i) ].	^ args</body><body package="COCellAccesses">arguments: aValue 	self haltOrError: 'Obsolete method sent'</body><body package="COCellAccesses">arguments: aValue copy: copy 	self haltOrError: 'Obsolete method sent'</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>demons</category><body package="COCellAccesses">performEndTransactionDemons	self allCellDemonsDo: [ :d | d endTransactionPerform: self ].</body><body package="COCellAccesses">performPostTransactionDemons	self allCellDemonsDo: [: d | d postTransactionPerform: self ].</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>accessing - cell properties</category><body package="COCellAccesses">allCellDemonsDo: block	cellOrCellWrapper allDemonsDo: block</body><body package="COCellAccesses">cellCluster	^ cellOrCellWrapper notNil 		ifTrue: [ cellOrCellWrapper cluster ]		ifFalse: [ nil ]</body><body package="COCellAccesses">cellFrame	^ cellOrCellWrapper notNil 		ifTrue: [ cellOrCellWrapper frame ]		ifFalse: [ nil ]</body><body package="COCellAccesses">cellValueHolder	^ cellOrCellWrapper notNil 		ifTrue: [ cellOrCellWrapper valueHolder ]		ifFalse: [ nil ]</body><body package="COCellAccesses">clusterManager	^ cellOrCellWrapper notNil 		ifTrue: [ cellOrCellWrapper clusterManager ]		ifFalse: [ nil ]</body><body package="COCellAccesses">isAccessOnPrototype	^ cellOrCellWrapper notNil and: [ cellOrCellWrapper isPrototype ]</body><body package="COCellAccesses">isFrameAccess	^ cellOrCellWrapper notNil and: [ cellOrCellWrapper isCoastFrame ]</body><body package="COCellAccesses">isLocalCell	^ cellOrCellWrapper notNil and: [ cellOrCellWrapper isLocal ]</body><body package="COCellAccesses">isSharedCell	^ cellOrCellWrapper notNil and: [ cellOrCellWrapper isShared ]</body><body package="COCellAccesses">isSlotAccess	^ cellOrCellWrapper notNil and: [ cellOrCellWrapper isSlot ]</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>comparing</category><body package="COCellAccesses">= aCatCSCellAccess 	"Answer whether the receiver and the argument represent the same object. 	If = is redefined in any subclass, consider also redefining the message hash."	"cell can be a proto-Slot and non-Proto slot"	| n1 |	self class == aCatCSCellAccess class ifFalse: [ ^ false ].	self isSlotAccess 		ifTrue: [( self cell id = aCatCSCellAccess cell id and: [ self cellFrame == aCatCSCellAccess cellFrame ]) ifFalse: [ ^ false ]]		ifFalse: [ self cell == aCatCSCellAccess cell ifFalse: [ ^ false ]].	( n1 := self size ) == aCatCSCellAccess size ifFalse: [ ^ false ].	1 to: n1 do: [: i | ( self at: i ) = ( aCatCSCellAccess at: i ) ifFalse: [ ^ false ]].	^ true</body><body package="COCellAccesses">hash	| h n |	h := self cell hash bitXor: self class hash.	(n := self size) &gt;= 1		ifTrue: [ h := h bitXor: (self at: 1) hash ].	n &gt;= 2		ifTrue: [ h := h bitXor: (self at: 2) hash ].	^ h</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>printing</category><body package="COCellAccesses">printOn: stream 	stream nextPutAll: self class fullName.	stream nextPutAll: ' on '.	self cell printOn: stream</body></methods><methods><class-id>COAST.CatCSCellAccess</class-id> <category>converting</category><body package="COTransactions">asRemoteSlotAccess	" Convert this local cell access into a remote cell access. We must convert	memory addresses into IDs/locators. Also, the cell access class may be remapped,	so that the concurrency control works correctly (see the comment of method 'remap')	!!! Frame accesses are not transmitted because they can be created by examining	the slot accesses, and thus this method should not be called for frame accesses "	^ self isSlotAccess 		ifTrue: [ CatRMSlotAccess slot: self cell frame: self cellFrame accessClassID: ( self cellValueHolder remap: self class ) id arguments: self convertArgumentsForReplication ]		ifFalse: [ nil ]</body><body package="COTransactions">asSlotAccessForInvalidation	| remappedAccessClass |	^ self isSlotAccess		ifTrue: 		[	remappedAccessClass := self cellValueHolder remap: self class.			CatRMSlotAccessForInvalidation slot: self cell frame: self cellFrame accessClassID: remappedAccessClass id arguments: self convertArgumentsForMinimalInvalidation		]		ifFalse: [ nil ]</body><body package="COTransactions">convertArgumentsForMinimalInvalidation	| convertedArguments n |	n := self size.	convertedArguments := Array new: n.	1 to: n do: [ : i |		convertedArguments at: i put: ((self at: i) coastAsArgumentForMinimalInvalidation)	].	^ convertedArguments</body><body package="COTransactions">convertArgumentsForReplication	" prepare the arguments for replication. arguments which are frames must	be described by frame IDs instead of memory addresses (see class comment) "	| cellCluster convertedArguments n |	cellCluster := self cellCluster.	n := self size.	convertedArguments := Array new: n.	1 to: n do: [ : i |		convertedArguments at: i put: ((self at: i) coastAsRemoteArgumentFor: cellCluster)	].	^ convertedArguments</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>accessing</category><body package="COCellAccesses">accessClassWithID: aByte 	accessClassTable isNil ifTrue: [ self initializeAccessClassTable ].	^ accessClassTable at: aByte</body><body package="COCellAccesses">concreteCellAccessClasses	"  return all subclasses which are concrete "	^ self allSubclasses select: [ :c | c id ~= -1 ].</body><body package="COCellAccesses">id	" All abstract classes return -1, all concrete classes return a value &gt; 0 "	" used to be #index "	^ -1.</body><body package="COCellAccesses">isValueWriteAccess	^ false</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>instance creation</category><body package="COCellAccesses">argument1: aValue1 argument2: aValue2	^ (self new: 2)		setArgument1: aValue1 argument2: aValue2;		yourself.</body><body package="COCellAccesses">argument: anObject	^ (self new: 1)		setArgument: anObject;		yourself.</body><body package="COCellAccesses">cell: aCatCSCell	^ self new		cell: aCatCSCell;			yourself.</body><body package="COCellAccesses">cell: aCatCSCell argument1: aValue1 argument2: aValue2	^ (self new: 2)		cell: aCatCSCell;			setArgument1: aValue1 argument2: aValue2;		yourself.</body><body package="COCellAccesses">cell: aCatCSCell argument: anObject	^ (self new: 1)		cell: aCatCSCell;			setArgument: anObject;		yourself.</body><body package="COCellAccesses">cell: aCatCSCell argument: anObject transaction: aTransaction	^ (self new: 1)		transaction: aTransaction;		cell: aCatCSCell;			setArgument: anObject;		yourself.</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>accessing - private</category><body package="COCellAccesses">commAccesses	^ commAccesses</body><body package="COCellAccesses">commDifferentAccesses	^ commDifferentAccesses</body><body package="COCellAccesses">commEqualAccesses	^ commEqualAccesses</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">buildCommutativityTables	" convert the class names of the three commutativity lists into arrays containing Booleans.	'true' means 'is commutative', 'false' means 'is not commutative'. nil is equivalent to false "	| numberOfCellAccesses newCommAccesses newCommEqualAccesses newCommDifferentAccesses |	numberOfCellAccesses := CatCSCellAccess withAllSubclasses size.	newCommAccesses := Array new: numberOfCellAccesses.	newCommEqualAccesses := Array new: numberOfCellAccesses.	newCommDifferentAccesses := Array new: numberOfCellAccesses.	( self commutativeClasses collect: [: c | self environment at: c ])		do: [: ac | newCommAccesses at: ac id put: true ].	( self commutativeWithEqualArgumentClasses collect: [: c | self environment at: c ]) 		do: [: ac | newCommEqualAccesses at: ac id put: true ].	( self commutativeWithDifferentArgumentClasses collect: [: c | self environment at: c ]) 		do: [: ac | newCommDifferentAccesses at: ac id put: true ].	" make sure that setting each access table is an atomar statement, because it's a shared variable "	commAccesses := newCommAccesses.	commEqualAccesses := newCommEqualAccesses.	commDifferentAccesses := newCommDifferentAccesses.</body><body package="COCellAccesses">commutativeClasses	" Answer all access classes (as symbols) who are always commutative to this access class.	Two read accesses are always commutative, so they don't need to be explicitly listed here "	^ #()</body><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	" answer all access classes (as symbols) who are commutative to this access class only if	1) both have at least one argument	and 2) the arguments with the index returned by 'indexOfArgumentToCheck' of both accesses are different "	^ #()</body><body package="COCellAccesses">commutativeWithEqualArgumentClasses	" answer all access classes who (as symbols) are commutative to this access class only if	1) both have at least one argument	and 2) the arguments with the index returned by 'indexOfArgumentToCheck' of both accesses are equal "	^ #()</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>testing</category><body package="COCellAccesses">isReadAccess	self subclassResponsibility</body><body package="COCellAccesses">isUpdateAccess	^ false</body><body package="COCellAccesses">isWriteAccess	^ self isReadAccess not</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>remap</category><body package="COCellAccesses">remapForOrderedCollection	^ self</body><body package="COCellAccesses">remapForSingleValue	^ self</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>concurrency control</category><body package="COCellAccesses">compare: args against: otherArgs from: anotherAccessClass 	^ anotherAccessClass compareFirstArgOf: otherArgs against: args</body><body package="COCellAccesses">compareArgs: args against: otherArgs 	^ args first = otherArgs first</body><body package="COCellAccesses">compareFirstArgOf: args against: otherArgs 	^ args first = otherArgs first</body><body package="COCellAccesses">withArguments: args hasEqualArguments: anotherAccessClass arguments: otherArgs 	" answer whether both accesses have equal arguments. only the important arguments	are tested "	^ args size &gt;= 1 and: [ otherArgs size &gt;= 1 and: [ self compare: args against: otherArgs from: anotherAccessClass ]]</body><body package="COCellAccesses">withArguments: args isCommutative: anotherAccessClass arguments: otherArgs	" returns true only if both accesses are commutative. this may depend upon	the arguments "	self id &gt; anotherAccessClass id		ifTrue: [ 			" swap arguments, so that this class has a lower or equal id "			^ anotherAccessClass withArguments: otherArgs isCommutative: self arguments: args ].	" Read accesses are always commutative "	(self isReadAccess and: [ anotherAccessClass isReadAccess])		ifTrue: [  ^ true ].	"The array position can contain one of 3 possible values - nil, true|false, or something else.	#ifNil: gives us the following reaction:	- nil - returns false, #ifTrue: is not executed.	- true|false - #ifNil: returns the object itself, e.g. &lt;true|false&gt;	- any other object dNU's on #ifTrue:. This is proper behavior"	((commAccesses at: anotherAccessClass id) == true )		" the accesses are commutative, independent of the accesses "		ifTrue: [ ^  true ].	" check the arguments "	(self withArguments: args hasEqualArguments: anotherAccessClass arguments: otherArgs)		ifTrue:		[	" same arguments "			((commEqualAccesses at: anotherAccessClass id) ifNil: [false ])				ifTrue: [ ^ true ].		]		ifFalse:		[	" different arguments "			((commDifferentAccesses at: anotherAccessClass id) ifNil: [false ])				ifTrue: [ ^ true ]		].		" by default, accesses are not commutative "	^ false</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>initialize</category><body package="COCellAccesses">initializeAccessClassTable	" Create a table containing the concrete access classes "	| acs newAccessClassTable |	acs := self concreteCellAccessClasses asSortedCollection: [ :a :b | a id &lt;= b id ].	newAccessClassTable := Array new: acs last id.	acs do: [ :accessClass | newAccessClassTable at: accessClass id put: accessClass ].	" make sure that setting the accessClassTable is an atomar statement, because it's a shared variable "	accessClassTable := newAccessClassTable.</body><body package="COCellAccesses">initializeAccesses	self initializeAccessClassTable.	self allSubclasses do: [: each | each concreteCellAccessClasses do: [: c | c buildCommutativityTables ]].</body><body package="COCellAccesses">postLoad	self initializeAccesses.	^ super postLoad</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>instance creation - obsolete</category><body package="COCellAccesses">arguments: anArray	" use #argument: or #argument1:argument2: if possible "	self haltOrContinue: 'Obsolete method #arguments: sent'.	^ anArray size = 2		ifTrue: [ self argument1: (anArray at: 1) argument2: (anArray at: 2) ]		ifFalse: [ self argument: (anArray at: 1)  ].</body></methods><methods><class-id>COAST.CatCSCellAccess class</class-id> <category>tests</category><body package="COCellAccesses">check: c1 references: symbols with: dict 	symbols size = symbols asSet size ifFalse: [ self halt: c1 fullName , ' uses duplicates!' ].	symbols do: 		[: sym | | c2 |			c2 := dict at: sym.			c2 id &lt; c1 id ifTrue: [ self halt: c1 fullName , ' should not refer to ' , c2 fullName , '!' ]		].</body><body package="COCellAccesses">checkConsistency	"CatCSCellAccess checkConsistency "	| dict |	self concreteCellAccessClasses do: 		[: c1 |			self concreteCellAccessClasses 				do: [: c2 | ( c1 ~= c2 and: [ c1 id = c2 id ]) ifTrue: [ self halt: c1 fullName , ' and ' , c2 fullName , ' have identical indices !' ]]		].	self initializeAccesses.	dict := Dictionary new.	COAST.CatCSCellAccess allSubclasses do: [: c1 | dict at: c1 name put: c1 ].	COAST.CatCSCellAccess allSubclasses do: 		[: c1 |			c1 id ~= -1 ifTrue: 				[	self check: c1 references: c1 commutativeClasses with: dict.					self check: c1 references: c1 commutativeWithEqualArgumentClasses with: dict.					self check: c1 references: c1 commutativeWithDifferentArgumentClasses with: dict				]		].</body></methods><methods><class-id>COAST.CatCSCellWrapper</class-id> <category>accessing - frame properties</category><body package="COCellAccesses">cluster	^ frame cluster</body><body package="COCellAccesses">clusterManager	^ frame clusterManager</body><body package="COCellAccesses">frame	^ frame</body><body package="COCellAccesses">isLocal	^ frame isLocal</body><body package="COCellAccesses">isShared	^ frame isShared</body><body package="COCellAccesses">transactionManager	^ frame transactionManager</body></methods><methods><class-id>COAST.CatCSCellWrapper</class-id> <category>initialize-release</category><body package="COCellAccesses">protoSlot: aProtoSlot frame: aFrame 	protoSlot := aProtoSlot.	frame := aFrame.</body></methods><methods><class-id>COAST.CatCSCellWrapper</class-id> <category>testing</category><body package="COCellAccesses">isCoastFrame	^ false</body><body package="COCellAccesses">isPrototype	^ false</body><body package="COCellAccesses">isSlot 	^ true</body></methods><methods><class-id>COAST.CatCSCellWrapper</class-id> <category>accessing - slot properties</category><body package="COCellAccesses">allDemonsDo: block 	^ protoSlot allDemonsDo: block</body><body package="COCellAccesses">buildUpDependenciesForTransaction: aTransaction access: accessOrNil 	"  build up a bidirectional dependency if a virtual cell is currently composed, "	| ccc |	aTransaction notNil 		ifTrue: 		[	ccc := aTransaction currentlyComposedCell.			( ccc notNil and: [ self isPrototype not ]) 				ifTrue: 				[	"remember the slot we wanted to read"					ccc addObserverOnFrame: self frame slotName: self slotName				]		].</body><body package="COCellAccesses">slotName	^ protoSlot slotName</body><body package="COCellAccesses">unwrappedCell	^ protoSlot</body><body package="COCellAccesses">valueHolder	^ protoSlot valueHolder</body></methods><methods><class-id>COAST.CatCSCellWrapper class</class-id> <category>instance creation</category><body package="COCellAccesses">protoSlot: aProtoSlot frame: aFrame 	^ self new		protoSlot: aProtoSlot frame: aFrame;		beImmutable;		yourself.</body></methods><methods><class-id>COAST.SupervisorCommand</class-id> <category>testing</category><body package="COBase">isIniCommand	^commandSymbol = self class iniSymbol</body><body package="COBase">isShutdownCommand	^commandSymbol = self class shutdownSymbol</body></methods><methods><class-id>COAST.SupervisorCommand class</class-id> <category>instance creation</category><body package="COBase">iniCommand: iniFile	^ (self commandSymbol: self iniSymbol) iniFileArgument: iniFile; yourself</body><body package="COBase">shutdownCommand	^ self commandSymbol: self shutdownSymbol</body></methods><methods><class-id>COAST.SupervisorCommand class</class-id> <category>constants</category><body package="COBase">iniSymbol	^ #ini</body><body package="COBase">shutdownSymbol	^ #shutdown</body></methods><methods><class-id>COAST.CoastTriedToLoadClusterTwiceError</class-id> <category>accessing</category><body package="COBase">defaultMessageText	^  'Tried to load cluster ', (self parameter ifNil: [ '(unknown)' ]), ' twice !'</body></methods><methods><class-id>COAST.CoastTriedToLoadClusterTwiceError class</class-id> <category>raising</category><body package="COBase">raiseForClusterID: clusterID	self raiseWith: clusterID displayString</body></methods><methods><class-id>COAST.CatCSVirtualSlotDefinition</class-id> <category>accessing</category><body package="COBase">composingMethod	^ composingMethod</body><body package="COBase">composingMethod: aBlock	composingMethod := aBlock</body><body package="COBase">computeInSequence	" if true, the eager slot is computed at the end of sequenceDo: [ ... ]	if false,  the eager slot is computed at the end of transactionSequenceDo: [ ... ] "	^ computeInSequence ifNil: [ true ]</body><body package="COBase">computeInSequence: aBoolean	" if true, the eager slot is computed at the end of sequenceDo: [ ... ]	if false,  the eager slot is computed at the end of transactionSequenceDo: [ ... ] "	computeInSequence := aBoolean</body><body package="COBase">makeImmutable	^ makeImmutable ifNil: [ true ]</body><body package="COBase">makeImmutable: aBoolean	makeImmutable := aBoolean</body><body package="COBase">releaseOldValueBlock	^ releaseOldValueBlock</body><body package="COBase">releaseOldValueBlock: aBoolean 	releaseOldValueBlock := aBoolean</body><body package="COBase">revalidationBlock	^ revalidationBlock</body><body package="COBase">revalidationBlock: aBlock 	revalidationBlock := aBlock.</body></methods><methods><class-id>COAST.FrameNotFoundError</class-id> <category>accessing</category><body package="COBase">frameLocator	^parameter</body></methods><methods><class-id>COAST.FrameNotFoundError class</class-id> <category>testing</category><body package="COBase">mayResume	^ true</body></methods><methods><class-id>COAST.CatCSEndCell</class-id> <category>demons</category><body package="COBase">addDemon: aCatCSDemon	^ self definition addDemon: aCatCSDemon</body><body package="COFramesystem">afterModificationDemon: methodSelector	"The indicated method will be called after the slot is modified.	The method has to accept one parameter which is the access object."	| demon |	demon := (CatFSDemon writeOnly) 					postJob: [ :theDemon :access :slot | slot frame demonPerformer perform: methodSelector with: access ]; 					name: methodSelector; 					yourself.	self addDemon: demon</body><body package="COFramesystem">afterTransactionDemon: methodSelector	"The indicated method will be called at the end of  the transaction in which the slot is modified.	The method has to accept one parameter which is the access object."	| demon |	demon := (CatFSDemon writeOnly) 					endTransactionJob: [ :theDemon :access :slot | slot frame demonPerformer perform: methodSelector with: access ]; 					name: methodSelector; 					yourself.	self addDemon: demon</body><body package="COBase">allDemonsDo: aBlock	^ self definition allDemonsDo: aBlock</body><body package="COFramesystem">allResponsibleDemonsFor: anAccess 		^ self definition allResponsibleDemonsFor: anAccess</body><body package="COBase">canceledDemon: aDemonName 		^ self definition canceledDemon: aDemonName</body><body package="COBase">demon: aCatCSDemon	self addDemon: aCatCSDemon</body><body package="COBase">demonNamed: aName 	^ self definition demonNamed: aName</body><body package="COBase">demons	^ self definition demons</body><body package="COFramesystem">disableDemons: demonNames while: aBlock 	| disabledDemons prototype |	prototype := self prototype ifNil: [ self ].	disabledDemons := demonNames collect: [: demonName | prototype removeDemon: demonName ].	^ aBlock ensure: [ disabledDemons do: [: demon | demon isNil ifFalse: [ prototype addDemon: demon ]]]</body><body package="COFramesystem">disableDemonsWhile: aBlock 	"wirkt nur auf diesen(!) slot"	| oldDefinition |	oldDefinition := definition.	definition := definition copy.	definition removeAllDemons.	^ aBlock ensure: [ definition := oldDefinition ]</body><body package="COFramesystem">findDifferencesForAccess: cellAccess demon: demon	| differences frame |	frame := cellAccess cellFrame.	frame isNil ifFalse:	"make sure the slot has still a frame"	[		differences := cellAccess transaction differencesToBeginOfTransaction: cellAccess.		demon argument value: frame value: differences added value: differences removed.	].</body><body package="COBase">hasDemons	self allDemonsDo: [:d | ^true ].	^ false</body><body package="COFramesystem">keyRange: aClass	"ranges can be set in development mode only, see COASTDevelopment parcel"</body><body package="COFramesystem">onDifferences: aBlock 	" Create a demon which composes two collections:		- the elements added to the collection		- the elements removed from the collection	aBlock will be feeded with these collections (:frame :added :removed).	"	self onDifferences: aBlock named: #onDifferences</body><body package="COFramesystem">onDifferences: aBlock named: aSymbol	" Create a demon which composes two collections:		- the elements added to the collection		- the elements removed from the collection	aBlock will be feeded with these collections (:frame :added :removed).	"	self addDemon:(((CatFSDemon writeOnly) 		endTransactionJob: [ :demon :slotAccess :cell |			self findDifferencesForAccess: slotAccess demon: demon ]		) name: aSymbol;		argument: aBlock; 		yourself)</body><body package="COFramesystem">onDifferencesRead: aBlock 	" Create a demon which composes two collections:		- the elements added to the collection		- the elements removed from the collection	aBlock will be feeded with these collections (:frame :added :removed).	"	self addDemon:(((CatFSDemon update) 		postTransactionJob: [ :demon :slotAccess :cell |			self findDifferencesForAccess: slotAccess demon: demon ]		) name: #onDifferences;		argument: aBlock; 		yourself)</body><body package="COFramesystem">onIncrementalDifferences: aBlock named: aSymbol 	"Create a demon which composes two collections: 	- the elements added to the collection 	- the elements removed from the collection 	aBlock will be feeded with these collections (:frame :added :removed). 	"	| newDemon |	newDemon := CatFSDemon writeOnly.	newDemon preJob: [:demon :cellAccess :cell | cellAccess keepDifferences].	newDemon		postJob: 			[:demon :slotAccess :cell | 			| diff |			diff := slotAccess differences.			aBlock				value: cell frame				value: diff added				value: diff removed ].	newDemon name: aSymbol.	self addDemon: newDemon</body><body package="COFramesystem">postTransactionDemon: methodSelector	| demon |	demon := (CatFSDemon writeOnly) 					postTransactionJob: [ :theDemon :access :slot | slot frame demonPerformer perform: methodSelector with: access ]; 					name: methodSelector; 					yourself.	self addDemon: demon</body><body package="COFramesystem">range	^Object</body><body package="COFramesystem">range: aClass</body><body package="COBase">removeDemon: aCatFSDemonName	^ self definition canceledDemon: aCatFSDemonName</body></methods><methods><class-id>COAST.CatCSEndCell</class-id> <category>testing</category><body package="COBase">canFastRead	^ valueHolder notNil and: [ valueHolder canFastRead ]</body><body package="COFramesystem">canFastReadFullValue	^ valueHolder notNil and: [ valueHolder canFastReadFullValue ]</body><body package="COFramesystem">depleteSlotBeforeIsolate	"default: nope!"	^false</body><body package="COBase">hasNoDemons	^ self hasDemons not</body><body package="COFramesystem">isSlot	^ true</body><body package="COTransactions">needsCellValueCopyForRollbackIn: transaction 	^ self frame needsCellValueCopyForRollbackIn: transaction</body></methods><methods><class-id>COAST.CatCSEndCell</class-id> <category>accessing</category><body package="COFramesystem">access: aCatCSCellAccess	| rdemons returnValue |	aCatCSCellAccess cell: self.	rdemons := self allResponsibleDemonsFor: aCatCSCellAccess.	rdemons do: [ :d | d actionPreAccess: aCatCSCellAccess. ].	returnValue := self valueAccess: aCatCSCellAccess.	rdemons do: [ :d | d actionPostAccess: aCatCSCellAccess. ].	^ returnValue</body><body package="COFramesystem">clusterID	^ container clusterID</body><body package="COBase">id: newID	" prototype "	self definition slotName: newID</body><body package="COFramesystem">name	^self id</body><body package="COBase">prototype	| pr |	pr := self definition prototype.	^ pr ~~ self		ifTrue: [ pr ]		ifFalse: [ nil ].</body><body package="COBase">prototype: aCatCSCell	" the definition is betwen the slot and the slot prototype "	self definition: aCatCSCell definition</body><body package="COBase">slotName	^ self id</body></methods><methods><class-id>COAST.CatCSEndCell</class-id> <category>prototype description</category><body package="COFramesystem">canceled	self frame removeSlot: self name</body><body package="COBase">definition	" definition of the slot "	^ definition</body><body package="COBase">definition: aCatCSSlotDefinition	" definition of the slot "	definition := aCatCSSlotDefinition</body></methods><methods><class-id>COAST.CatCSEndCell</class-id> <category>initialize-release</category><body package="COBase">createSlotDefinition	" create a new slot definition. the definition holds all (static) extra information that is not stored in the prototype "	| def |	def := self slotDefinitionClass new.	self definition: def.	def prototype: self.</body><body package="COBase">initializePrototype	super initializePrototype.	self createSlotDefinition.</body><body package="COBase">slotDefinitionClass	^ CatCSSlotDefinition</body></methods><methods><class-id>COAST.CatCSEndCell</class-id> <category>observer - subject</category><body package="COBase">allObservedClusterIDs	^ self frame allObservedClusterIDs</body></methods><methods><class-id>COAST.CatCSEndCell</class-id> <category>accessing - private</category><body package="COBase">coastID	^ self definition coastID</body><body package="COBase">coastID: newID 	self prototype notNil ifTrue: [ self haltOrError ].	^ self definition coastID: newID</body></methods><methods><class-id>COAST.CatCSEndCell</class-id> <category>printing</category><body package="COBase">idPrintStringOn: stream 	stream nextPut: $[.	self id printOn: stream.	stream nextPut: $/.	container isNil 		ifTrue: [ stream nextPutAll: 'no container' ]		ifFalse: [ stream nextPutAll: container classLabel ].	stream nextPut: $].</body><body package="COBase">printOn: aStream 	self isPrototype ifTrue: [ aStream nextPutAll: 'prototype of ' ].	self idPrintStringOn: aStream.	aStream nextPutAll: ' ('.	aStream nextPutAll: self classLabel.	aStream nextPutAll: ')'.</body></methods><methods><class-id>COAST.CatCSEndCell</class-id> <category>copying - private</category><body package="COCellAccesses">copyValueHolderTo: anotherSlot with: copyContext 	| copyContainer |	self isPrototype ifFalse: 		[	" when a slot is copied, we need to know it's container right now so that it can be decided			if the slot is local or shared (except when copying the prototype) "			copyContainer := copyContext deepCopiedCellsAt: self frame ifAbsent: [ self error: 'Error while copying a cell' ].			anotherSlot cellContainer: copyContainer		].	anotherSlot id: self id.	super copyValueHolderTo: anotherSlot with: copyContext</body></methods><methods><class-id>COAST.CatCSEndCell class</class-id> <category>testing</category><body package="COBase">demonsEnabled	^ DemonsEnabled notNil 		ifTrue: [ DemonsEnabled ]		ifFalse: [ true ]</body><body package="COBase">demonsEnabled: aBoolean	aBoolean		ifTrue: [CoastLog logDebug: 'Enabling all demons!' ]		ifFalse: [CoastLog logDebug: 'Disabling all demons!' ].	DemonsEnabled := aBoolean.</body></methods><methods><class-id>COAST.CatCSEndCell class</class-id> <category>prototype access</category><body package="COBase">emptyPrototype</body></methods><methods><class-id>COAST.CatCSCellValueAndDifferences</class-id> <category>accessing</category><body package="COBase">oldValue	^ oldValue</body><body package="COBase">oldValue: theOldValue	oldValue := theOldValue</body></methods><methods><class-id>COAST.CatCSCellValueAndDifferences class</class-id> <category>instance creation</category><body package="COBase">oldValue: theOldValue	^ self new		oldValue: theOldValue;		yourself</body></methods><methods><class-id>COAST.Index</class-id> <category>accessing</category><body package="COBase">anyKey	^ keys anyElement</body><body package="COBase">asIndex		^self</body><body package="COBase">atIndex: elementIndex 	^ ( keys at: elementIndex ) -&gt; ( values at: elementIndex )</body><body package="COBase">atKey: key add: value 	| index |	index := self indexForKey: key value: value.	index &gt; keys size ifTrue: 		[	keys addLast: key.			^ values addLast: value		].	((( keys at: index ) coastCompareTo: key ) = 0 and: [(( values at: index ) coastCompareTo: value ) = 0 ]) 		ifTrue: [ ^ value ].	keys add: key beforeIndex: index.	^ values add: value beforeIndex: index</body><body package="COBase">atKey: key ifAbsent: aBlock 	| startIndex endIndex size stopIndex |	startIndex := keys coastMinIndexForInserting: key.	size := keys size.	startIndex &gt; size ifTrue: [ ^ aBlock value ].	endIndex := startIndex.	[ endIndex &lt;= size and: [(( keys at: endIndex ) coastCompareTo: key ) = 0 ]] whileTrue: [ endIndex := endIndex + 1 ].	stopIndex := endIndex - 1.	^ startIndex &lt;= stopIndex		ifTrue: [ values copyFrom: startIndex to: stopIndex ]		ifFalse: [ aBlock value ]</body><body package="COBase">atKey: key includes: value 	^ ( self indexOrNilForKey: key value: value ) notNil</body><body package="COBase">atKey: key remove: value ifAbsent: absentBlock 	| index |	index := self indexOrNilForKey: key value: value.	^ index notNil 		ifTrue: 		[	keys removeAtIndex: index.			values removeAtIndex: index		]		ifFalse: [ absentBlock value ]</body><body package="COBase">atKey: key removeAll: rValues 	rValues do: 		[: value | | index |			index := self indexOrNilForKey: key value: value.			index notNil ifTrue: 				[	keys removeAtIndex: index.					values removeAtIndex: index				]		].</body><body package="COBase">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| result |	result := OrderedCollection new.	self atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result.	^ result</body><body package="COBase">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result 	| min max |	min := keys coastMinIndexForInserting: ( keyPattern coastAsPatternPrefixIgnoreCase: ignoreCase ).	max := self size min: ( keys coastMinIndexForInserting: ( keyPattern coastAsPostPatternPrefixIgnoreCase: ignoreCase )).	( min to: max ) do: 		[: index | ( keyPattern coastMatch: ( keys at: index ) ignoreCase: ignoreCase ) ifTrue: [ result add: ( values at: index )].			( maxSize notNil and: [ result size = maxSize ]) ifTrue: [ ^ result ]		].</body><body package="COBase">atKeys: someKeys 	| result |	result := Index new.	someKeys coastAsSortedValidKeys do: [: k | ( self atKey: k ) do: [: v | result atKey: k add: v ]].	^ result</body><body package="COBase">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rValues 	| result |	result := Index new.	someKeys coastAsSortedValidKeys do: [: k | ( self atKey: k ) do: [: v | ( rValues includes: v ) ifTrue: [ result atKey: k add: v ]]].	^ result</body><body package="COBase">cropToSize: maxSize	keys := keys copyFrom: 1 to: maxSize.	values := values copyFrom: 1 to: maxSize.</body><body package="COFramesystem">fillFrom: segmentedIndex atKeys: sortedKeys 	self initializeCollectionsSized: sortedKeys size.	segmentedIndex atSortedKeys: sortedKeys		do: 		[: key : value |			"iterating will allways ensure sorted keys and values"			keys addLast: key.			values addLast: value		].</body><body package="COBase">first	^ keys first -&gt; values first</body><body package="COBase">fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	| startIndex stopIndex |	startIndex := startKeyOrNil notNil 			ifTrue: 			[	inclusive 					ifTrue: [ keys coastMinIndexForInserting: startKeyOrNil ]					ifFalse: [( keys coastMaxIndexForInserting: startKeyOrNil ) + 1 ]			]			ifFalse: [ 1 ].	stopIndex := stopKeyOrNil notNil 			ifTrue: 			[	inclusive 					ifTrue: [ keys coastMaxIndexForInserting: stopKeyOrNil ]					ifFalse: [( keys coastMinIndexForInserting: stopKeyOrNil ) - 1 ]			]			ifFalse: [ keys size ].	(startIndex &gt; values size or: [ stopIndex &lt; startIndex ]) ifTrue: [ ^ OrderedCollection new ].	^ values copyFrom: startIndex to: stopIndex</body><body package="COBase">greaterKey: key	^ self fromKey: key toKey: nil inclusive: false</body><body package="COBase">greaterOrEqualKey: key 	^ self fromKey: key toKey: nil inclusive: true</body><body package="COBase">includesKey: key 	| startIndex size |	startIndex := keys coastMinIndexForInserting: key.	size := keys size.	^ startIndex &gt; size 		ifTrue: [ false ]		ifFalse: [(( keys at: startIndex ) coastCompareTo: key ) = 0 ]</body><body package="COBase">indexOf: assoc 	^ self indexOrNilForKey: assoc key value: assoc value</body><body package="COBase">insertionIndexOf: assoc 	^self indexForKey: assoc key value: assoc value</body><body package="COBase">keys	^ keys</body><body package="COFramesystem">lastElement	^ keys isEmpty 		ifTrue: [ nil ]		ifFalse: [ keys last selfOrFrameLocator -&gt; values last selfOrFrameLocator ]</body><body package="COBase">lessKey: key	^ self fromKey: nil toKey: key inclusive: false</body><body package="COBase">lessOrEqualKey: key	^ self fromKey: nil toKey: key inclusive: true</body><body package="COBase">limitToSize: sizeOrNil 	( sizeOrNil notNil and: [ sizeOrNil &lt; self size ]) ifTrue: [ self cropToSize: sizeOrNil ].</body><body package="COBase">matchingPattern: keyPattern ignoreCase: ignoreCase into: result 	| min max |	min := keys coastMinIndexForInserting: ( keyPattern coastAsPatternPrefixIgnoreCase: ignoreCase ).	max := self size min: ( keys coastMinIndexForInserting: ( keyPattern coastAsPostPatternPrefixIgnoreCase: ignoreCase )).	( min to: max ) do: 		[: index | ( keyPattern coastMatch: ( keys at: index ) ignoreCase: ignoreCase ) ifTrue: [ result atKey: ( keys at: index ) add: ( values at: index )]		].</body><body package="COBase">matchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize 	| min max |	min := keys coastMinIndexForInserting: ( keyPattern coastAsPatternPrefixIgnoreCase: ignoreCase ).	max := self size min: ( keys coastMinIndexForInserting: ( keyPattern coastAsPostPatternPrefixIgnoreCase: ignoreCase )).	( min to: max ) do: 		[: index | (( maxSize isNil or: [ result size &lt; maxSize ]) and: [ keyPattern coastMatch: ( keys at: index ) ignoreCase: ignoreCase ]) 				ifTrue: [ result atKey: ( keys at: index ) add: ( values at: index )]		].</body><body package="COBase">matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| result |	result := Index new.	self matchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize.	^ result</body><body package="COFramesystem">referencesSharedFrame: frame 	^ ( self includesKey: frame ) or: [ self values includes: frame ]</body><body package="COBase">removeFirst	^ keys removeFirst -&gt; values removeFirst</body><body package="COBase">removeKey: key ifAbsent: absentBlock 	| startIndex endIndex size result count |	startIndex := keys coastMinIndexForInserting: key.	size := keys size.	startIndex &gt; size ifTrue: [ ^ absentBlock value ].	endIndex := startIndex.	[ endIndex &lt;= size and: [(( keys at: endIndex ) coastCompareTo: key ) = 0 ]] whileTrue: [ endIndex := endIndex + 1 ].	startIndex = endIndex ifTrue: [ ^ absentBlock value ].	count := endIndex - startIndex.	keys coastRemove: count index: startIndex.	result := values copyFrom: startIndex to: endIndex - 1.	values coastRemove: count index: startIndex.	^ result</body><body package="COBase">size	^ keys size</body><body package="COBase">values	^ values</body></methods><methods><class-id>COAST.Index</class-id> <category>iterating</category><body package="COBase">do: block 	values do: block</body><body package="COBase">keysAndValuesDo: block 	keys with: values do: block</body><body package="COBase">keysDo: block 	keys do: block</body></methods><methods><class-id>COAST.Index</class-id> <category>private</category><body package="COBase">indexForKey: key value: value 	| range startIndex endIndex |	keys isEmpty ifTrue: [ ^ 1 ].	( keys last coastLessThan: key ) ifTrue: [ ^ keys size + 1 ].	range := keys coastKeyRangeFor: key.	startIndex := range first.	endIndex := range last.	endIndex &lt; startIndex ifTrue: [ ^ startIndex ].	endIndex = startIndex ifTrue: 		[	^ (( values at: startIndex ) coastLessThan: value ) 				ifTrue: [ startIndex + 1 ]				ifFalse: [ startIndex ]		].	^ values coastMinIndexForInserting: value min: startIndex max: endIndex</body><body package="COBase">indexOrNilForKey: key value: value 	| index size |	index := self indexForKey: key value: value.	size := keys size.	^ ( index &lt;= size 		and: [(( keys at: index ) coastCompareTo: key ) = 0 and: [(( values at: index ) coastCompareTo: value ) = 0 ]]) 		ifTrue: [ index ]		ifFalse: [ nil ]</body><body package="COBase">postCopy	"Make sure to copy the contents fully."	super postCopy.	keys := keys copy.	values := values copy</body><body package="COBase">valuesCollectionClass	^OrderedCollection</body></methods><methods><class-id>COAST.Index</class-id> <category>testing</category><body package="COBase">isEmpty	^ keys isEmpty</body></methods><methods><class-id>COAST.Index</class-id> <category>initialize</category><body package="COBase">initializeCollectionsSized: anInteger 	keys := OrderedCollection new: anInteger.	values := OrderedCollection new: anInteger</body></methods><methods><class-id>COAST.Index class</class-id> <category>instance creation</category><body package="COBase">new	^ self new: 0</body><body package="COBase">new: size 	"for internal use only"	^ ( self basicNew )		initializeCollectionsSized: size;		yourself</body></methods><methods><class-id>COAST.SegmentedDictionary</class-id> <category>private</category><body package="COBase">atKey: key addSubcollection: collection 	"it is mandatory that no other index shares the same keys as index"	partialCollections add: collection.	self noCheckAdd: key -&gt; collection.	( collection includesKey: key ) ifTrue: [ size := size + 1 ].</body><body package="COBase">diffCollectionClass	^ Dictionary</body><body package="COBase">keyNotFoundErrorFor: selector index: key 	"Raise a signal indicating that the key was not found."	^ ( KeyNotFoundError receiver: self selector: selector index: key ) raiseRequest</body><body package="COBase">valuesCollectionClass	^ Set</body></methods><methods><class-id>COAST.SegmentedDictionary</class-id> <category>accessing</category><body package="COBase">add: assoc 	self atKey: assoc key put: assoc value.</body><body package="COBase">at: key put: value 	^ self atKey: key put: value</body><body package="COBase">atKey: key 	^ self atKey: key ifAbsent: [ self keyNotFoundErrorFor: #atKey: index: key ]</body><body package="COBase">atKey: key put: value 	| dict oldSize |	dict := self subcollectionNeededAtKey: key.	oldSize := dict size.	dict at: key put: value.	size := size - oldSize + dict size.	^ value</body><body package="COBase">atKeys: someKeys 	| result |	result := self diffCollectionClass new.	someKeys do: 		[: k | | v |			v := self atKey: k ifAbsent: nil.			v notNil ifTrue: [ result atKey: k put: v ]		].	^ result</body><body package="COBase">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rValues 	| result |	result := self diffCollectionClass new.	someKeys do: 		[: k | | v |			v := self atKey: k ifAbsent: nil.			( v notNil and: [ rValues includes: v ]) ifTrue: [ result atKey: k put: v ]		].	^ result</body><body package="COBase">eachKeyIn: someKeys do: eachKeyBlock 	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index.	Equivalent to 		(self atKeys: someKeys) keysDo: eachKeyBlock	but faster for some classes "	someKeys do: 		[: key | | valuesOrNil |			valuesOrNil := self atKey: key ifAbsent: nil.			valuesOrNil notNil ifTrue: [ eachKeyBlock value: key ]		].</body></methods><methods><class-id>COAST.CoastFatalError</class-id> <category>testing</category><body package="COBase">isFatalCoastError	^ true</body></methods><methods><class-id>COAST.SegmentedIndex</class-id> <category>private</category><body package="COBase">atKey: key addIndex: index 	"it is mandatory that no other index shares the same keys as index"	self noCheckAdd: key -&gt; index.	size := size + ( index atKey: key ) size.</body><body package="COBase">atKey: key addSubcollection: collection 	"it is mandatory that no other index shares the same keys as index"	partialCollections add: collection.	self noCheckAdd: key -&gt; collection.	size := size + ( collection atKey: key ) size.</body><body package="COBase">diffCollectionClass	^ Index</body><body package="COBase">valuesCollectionClass	^OrderedCollection</body></methods><methods><class-id>COAST.SegmentedIndex</class-id> <category>accessing</category><body package="COBase">add: assoc 	self atKey: assoc key add: assoc value</body><body package="COBase">atKey: key 	^ self atKey: key ifAbsent: [ self valuesCollectionClass new ]</body><body package="COBase">atKey: key add: value 	| index oldSize |	index := self subcollectionNeededAtKey: key.	oldSize := index size.	index atKey: key add: value.	size := size - oldSize + index size.	^ value</body><body package="COBase">atKey: key addAll: valueCollection	valueCollection do: [ : v | self atKey: key add: v ]</body><body package="COBase">atKey: key includes: value 	| index |	index := self subCollectionOrNilAtKey: key.	^ index notNil and: [ index atKey: key includes: value ]</body><body package="COBase">atKey: key remove: value 	^ self atKey: key remove: value ifAbsent: [ self notFoundError ]</body><body package="COBase">atKey: key remove: value ifAbsent: absentBlock 	| index oldSize result pos |	pos := self findKeyOrNil: key.	index := pos notNil 			ifTrue: [( self basicAt: pos ) value ]			ifFalse: [ ^ absentBlock value ].	^ index notNil 		ifTrue: 		[	oldSize := index size.			result := index atKey: key remove: value ifAbsent: absentBlock.	"it's save for #size when absentBlock will exit this method!"			oldSize = index size ifFalse: 				[	( index includesKey: key ) ifFalse: [ self basicRemoveAt: pos ].					size := size - 1				].			result		]		ifFalse: [ absentBlock value ]</body><body package="COBase">atKey: key removeAll: rValues 	| theIndex oldSize |	theIndex := self subCollectionOrNilAtKey: key.	theIndex notNil ifTrue: 		[	oldSize := theIndex size.			theIndex atKey: key removeAll: rValues.			size := size - oldSize + theIndex size		].</body><body package="COBase">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| result |	result := OrderedCollection new.	self atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result.	^ result</body><body package="COBase">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result 	self notYetImplemented.</body><body package="COBase">atKeys: someKeys 	| result |	result := self diffCollectionClass new.	someKeys do: [: k | ( self atKey: k ) do: [: v | result atKey: k add: v ]].	^ result</body><body package="COBase">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rValues 	| result |	result := self diffCollectionClass new.	someKeys coastAsSortedValidKeys do: [: k | ( self atKey: k ) do: [: v | ( rValues includes: v ) ifTrue: [ result atKey: k add: v ]]].	^ result</body><body package="COBase">eachKeyIn: someKeys do: eachKeyBlock	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index.	Equivalent to 		(self atKeys: someKeys) keysDo: eachKeyBlock	but faster for some classes "	someKeys do: 		[: key | | valuesOrNil |			valuesOrNil := self atKey: key ifAbsent: nil.			valuesOrNil notNil ifTrue: [ valuesOrNil do: [ : v | eachKeyBlock value: key ] ]		].</body><body package="COBase">fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	self notYetImplemented.</body><body package="COBase">greaterKey: key	^ self fromKey: key toKey: nil inclusive: false</body><body package="COBase">greaterOrEqualKey: key 	^ self fromKey: key toKey: nil inclusive: true</body><body package="COBase">keys	| keys |	keys := OrderedCollection new.	self keysAndValuesDo: [: frame : value | keys add: frame ].	^ keys</body><body package="COBase">lessKey: key	^ self fromKey: nil toKey: key inclusive: false</body><body package="COBase">lessOrEqualKey: key	^ self fromKey: nil toKey: key inclusive: true</body><body package="COBase">matchingPattern: keyPattern ignoreCase: ignoreCase into: result 	self notYetImplemented.</body><body package="COBase">matchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize	self notYetImplemented.</body><body package="COBase">matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| result |	result := Index new.	self matchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize.	^ result</body><body package="COBase">removeFirst	"keys are not sorted, but values are"	| bestKey bestValue |	bestKey := bestValue := nil.	self keysAndValuesDo: 		[: key : value | ( bestKey isNil or: [ key coastLessThan: bestKey ]) ifTrue: 				[	bestKey := key.					bestValue := value				]		].	self atKey: bestKey remove: bestValue.</body><body package="COBase">selectKeys: someKeys whichInclude: aValue 	^ someKeys select: [: key | self atKey: key includes: aValue ]</body></methods><methods><class-id>COAST.SegmentedIndex</class-id> <category>iterating</category><body package="COBase">keysDo: block 	"Evaluate aBlock for each key (multiple for many values at key)"	self haltOrContinue: 'do you realy want to perform keys multiple times'.	"super keysDo: block would be *much* faster"	self valuesAssociationsDo: 		[: assoc | | key |			key := assoc key.			( assoc value sizeAtKey: key ) timesRepeat: [ block value: key ]		].</body></methods><methods><class-id>COAST.CatCSFrameLocator</class-id> <category>comparing</category><body package="COBase">&lt; reference	^ self coastLessThan: reference</body><body package="COBase">&lt;= frameLocator 	^(self &gt; frameLocator) not</body><body package="COBase">= anObject	^ anObject equalFromFrameLocator: self</body><body package="COBase">&gt; frameLocator 	^frameLocator &lt; self</body><body package="COBase">&gt;= frameLocator 	^(self &lt; frameLocator) not</body><body package="COBase">coastCompareFrameOrReferenceTo: reference 	^ clusterID = reference clusterID 		ifTrue: [ frameID coastCompareTo: reference frameID ]		ifFalse: [ clusterID coastCompareTo: reference clusterID ]</body><body package="COBase">coastCompareTo: aFrameOrFrameLocator 	^ ( aFrameOrFrameLocator coastCompareFrameOrReferenceTo: self ) negated</body><body package="COBase">equalFromFrameID: anotherFrameID 	^ false</body><body package="COBase">equalFromFrameLocator: frameLocator	^ frameID == frameLocator frameID		and: [ clusterID == frameLocator clusterID ]</body><body package="COBase">hash	^ frameID hash</body></methods><methods><class-id>COAST.CatCSFrameLocator</class-id> <category>accessing</category><body package="COCellValueHolder">asCompactArgument	^ self</body><body package="COBase">asWeakFrameReference	"Point x: self clusterID y: self frameID"	^ self</body><body package="COBase">clusterID	" note: this is an integer ! "	^clusterID</body><body package="COBase">clusterID: clusterIDInteger	clusterID := clusterIDInteger</body><body package="COBase">frameLocator	^ self</body><body package="COCellValueHolder">isValidRPCResultWith: clusterManager 	"cluster not loaded -&gt; valid"	"cluster loaded - it might be part of a pending update..."	^ ( clusterManager hasCluster: self clusterID ) 		ifTrue: [( clusterManager getFrame: self frameID inCluster: self clusterID ) notNil ]		ifFalse: [ true ]</body><body package="COBase">translatedArgumentForCluster: aCatCSCluster	^ self</body></methods><methods><class-id>COAST.CatCSFrameLocator</class-id> <category>printing</category><body package="COBase">basicPrintOn: aStream 	self clusterID printOn: aStream.	aStream nextPut: $/.	super basicPrintOn: aStream.</body><body package="COTransactions">ccPrintStringOn: stream withClusterID: someOtherClusterID	stream nextPutAll: 'ID'.	self clusterID printOn: stream.	stream nextPut: $_.	self frameID printOn: stream.</body><body package="COBase">fullIDNumber	" 64 bit number "	^self frameID positive		ifTrue: [ (self clusterID bitShift: 32) bitOr: self frameID ]		ifFalse: [ ((self clusterID bitShift: 32) bitOr: self frameID abs) negated ]</body><body package="COBase">fullIDString	| aStream |	aStream := (String new: 16) writeStream.	self fullIDStringOn: aStream.	^ aStream contents</body><body package="COBase">fullIDStringOn: aStream	aStream nextPutAll: 'ID'.	self clusterID printOn: aStream.	aStream nextPut: $_.	self frameID printOn: aStream.</body><body package="COBase">shortClassName	^ 'frameLocator '</body></methods><methods><class-id>COAST.CatCSFrameLocator</class-id> <category>testing</category><body package="COBase">isCoastPrimitiveValue	^ true</body><body package="COBase">isFrameOrFrameReference	^true</body><body package="COBase">isLocal	^ false</body></methods><methods><class-id>COAST.CatCSFrameLocator</class-id> <category>retrieval</category><body package="COFramesystem">realFrameFrom: clusterManager 		^clusterManager getFrame: frameID inCluster: clusterID</body></methods><methods><class-id>COAST.CatCSFrameLocator</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	" marshall primitive object argument "	aStream nextPut: self class marshallID.	aStream nextOptimized32Put: self clusterID.	aStream nextOptimized32Put: self id.</body><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	self marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	clusterID := aStream nextOptimized32.	frameID := aStream nextOptimized32.</body><body package="COMarshalling">unmarshallBinaryReferenceFrom: aStream marshaller: aCatRMMarshall 	self unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CatCSFrameLocator class</class-id> <category>newish</category><body package="COBase">idString: idString do: clusterAndFrameIDBlock malformedDo: malformedBlock	| underscore clusterString frameString frameIDSign |	idString isString 		ifFalse: [ ^ malformedBlock value: idString ].	('ID*_*' match: idString ignoreCase: false)		ifFalse: [ ^ malformedBlock value: idString ].	underscore := idString indexOf: $_.	clusterString := idString copyFrom: 3 to: underscore - 1.	(clusterString notEmpty and: [ clusterString allSatisfy: [ : ch | ch isDigit ]])		ifFalse: [ ^ malformedBlock value: idString ].	"support for tempShared (negative) frame ids"	frameIDSign := (idString size &gt; underscore and: [ (idString at: underscore + 1) = $- ]) ifTrue: [ underscore := underscore + 1. -1 ] ifFalse: [ 1 ].	frameString := idString copyFrom: underscore + 1 to: idString size.	(frameString notEmpty and: [ frameString allSatisfy: [ : ch | ch isDigit ]])		ifFalse: [ ^ malformedBlock value: idString ].	^ clusterAndFrameIDBlock value: clusterString asInteger value: frameString asInteger * frameIDSign</body><body package="COBase">isValidFrameIDString: idString 	^ self idString: idString do: [: clusterID : frameID | clusterID coastIsSmallInteger and: [ clusterID &gt;= 0 and: [ frameID coastIsSmallInteger ] ] ] malformedDo: [: s | false ]</body><body package="COBase">newFrameID: aFrameID clusterID: clusterIDInteger	| newInstance |	( aFrameID coastIsSmallInteger and: [ clusterIDInteger coastIsSmallInteger ])		ifFalse: [ CoastError raiseSignal: 'can not create ' , self name ].	newInstance := self new.	newInstance frameID: aFrameID.	newInstance clusterID: clusterIDInteger.	^newInstance.</body><body package="COBase">newFullIDNumber: anInteger	^anInteger positive		ifTrue: [ self newFrameID: (anInteger bitAnd: 16rFFFFFFFF) clusterID: (anInteger bitShift: -32) ]		ifFalse: [ self newFrameID: (anInteger abs bitAnd: 16rFFFFFFFF) negated clusterID: (anInteger abs bitShift: -32) ]</body><body package="COBase">newFullIDString: idString 	^ self 		idString: idString		do: [: clusterID : frameID | self newFrameID: frameID clusterID: clusterID ]		malformedDo: 		[: s |			CoastLog logError: 'Malformed frame ID: ' , idString.			nil		]</body></methods><methods><class-id>COAST.CatCSFrameLocator class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	^ 3</body><body package="COMarshalling">unmarshallBinaryReferenceFrom: aStream marshaller: marshallBinary 	^ self new unmarshallBinaryReferenceFrom: aStream marshaller: marshallBinary</body></methods><methods><class-id>COAST.CoastWeakObservers</class-id> <category>private</category><body package="COBase">atNewIndex: index put: anObject 	"flag if elements with revalidationBlock are contained"	self basicAt: index put: anObject.	tally notNil ifTrue: 		[	anObject revalidationBlock notNil ifTrue: [ tally at: 2 put: ( tally at: 2 ) + 1 ].			tally at: 1 put: ( tally at: 1 ) + 1		].	self fullCheck.</body><body package="COBase">noCheckAdd: anObject 	"flag if elements with revalidationBlock are contained"	self basicAt: ( self findElementOrNil: anObject ) put: anObject.	tally notNil ifTrue: 		[	anObject revalidationBlock notNil ifTrue: [ tally at: 2 put: ( tally at: 2 ) + 1 ].			tally at: 1 put: ( tally at: 1 ) + 1		].</body><body package="COBase">setTally	"Initialize the number of elements to be 0."	tally := Array with: 0 with: 0.</body><body package="COBase">updateTally	| newTally revalidationCount |	newTally := 0.	revalidationCount := 0.	self do: 		[: element |			element revalidationBlock notNil ifTrue: [ revalidationCount := revalidationCount + 1 ].			newTally := newTally + 1		].	tally isNil ifTrue: [ self setTally ].	tally at: 1 put: newTally.	tally at: 2 put: revalidationCount.</body></methods><methods><class-id>COAST.CoastWeakObservers</class-id> <category>removing</category><body package="COBase">remove: oldObject ifAbsent: anExceptionBlock 	"Remove oldObject as one of the receiver's elements.  If several of the	elements are equal to oldObject, only one is removed. If no element is equal to	oldObject, answer the result of evaluating anExceptionBlock.  Otherwise,	answer the argument, oldObject."	| index |	index := self find: oldObject ifAbsent: [ ^ anExceptionBlock value ].	self basicAt: index put: nil.	tally notNil ifTrue: 		[	oldObject revalidationBlock notNil ifTrue: [ tally at: 2 put: ( tally at: 2 ) - 1 ].			tally at: 1 put: ( tally at: 1 ) - 1		].	self fixCollisionsFrom: index.	^ oldObject</body></methods><methods><class-id>COAST.CoastWeakObservers</class-id> <category>accessing</category><body package="COBase">hasObserversWithRevalidationBlock	^ tally notNil 		ifTrue: [( tally at: 2 ) &gt; 0 ]		ifFalse: [ super hasObserversWithRevalidationBlock ]</body><body package="COBase">size	"Answer how many elements the receiver contains."	^ tally notNil 		ifTrue: [ tally at: 1 ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CoastInvalidAccessError class</class-id> <category>instance creation</category><body package="COBase">raiseForAccess: aCatCSCellAccess 	"usefull for debugging: what acces /args did fail?"	| stream |	stream := String new writeStream.	stream nextPutAll: 'Invalid '.	aCatCSCellAccess class printOn: stream.	stream nextPutAll: ' on '.	aCatCSCellAccess cell printOn: stream.	stream nextPutAll: ' with #('.	aCatCSCellAccess arguments 		do: 		[: arg |			stream nextPut: $[.			arg class printOn: stream.			stream nextPutAll: '] '.			arg printOn: stream		]		separatedBy: [ stream nextPutAll: ', ' ].	self raiseSignal: stream contents.</body></methods><methods><class-id>COAST.MultiValueDictionary</class-id> <category>converting</category><body package="COBase">asMultiValueDictionary	^self</body></methods><methods><class-id>COAST.MultiValueDictionary</class-id> <category>private</category><body package="COBase">capacity	"Answer how much space the receiver has to contain elements."	^self basicSize</body><body package="COBase">changeCapacityTo: newCapacity	"Change the size of the receiver to newCapacity.  The receiver will	be regrown if necessary to fit its contents."	"Note that #rehash uses this -- don't optimize the case where	the receiver doesn't change in size."	| newSelf |	newSelf := self copyEmpty: newCapacity.	self valuesAssociationsDo: [:each | newSelf noCheckAdd: each].	self become: newSelf</body><body package="COBase">findKeyOrNil: key  	"Look for the key in the receiver.  If it is found, answer	the index of the association containing the key, otherwise	answer the index of the first unused slot."	| location length probe pass |	length := self basicSize.	pass := 1.	location := self initialIndexFor: key hash boundedBy: length.	[(probe := self basicAt: location) == nil or: [probe key = key]]		whileFalse: 			[(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body><body package="COBase">fixCollisionsFrom: index 	| myLength oldIndex nextIndex nextObject |	oldIndex := index.	myLength := self basicSize.	[	oldIndex := oldIndex \\ myLength + 1.		nextObject := self basicAt: oldIndex.		nextObject == nil	] whileFalse: 		[	nextIndex := self findKeyOrNil: nextObject key.			nextIndex = oldIndex ifFalse: 				[	self basicAt: nextIndex put: nextObject.					self basicAt: oldIndex put: nil				]		]</body><body package="COBase">grow	"The receiver becomes roomier."	self changeCapacityTo: self capacity + self growSize</body><body package="COBase">growSize	"Answer an amount by which the receiver should grow 	to make room for more elements."	^self capacity max: 2</body><body package="COBase">initialIndexFor: aHashValue boundedBy: length	"Find the place where we should start the search.	Optimize for relatively small dictionaries."	"Objects whose hashes are based on their identityHash are restricted 	by current implementations to the range 0 to some small number 	like 16383. For collections whose sizes are much larger than this 	number, using the hash as-is would tend to cause collisions at the 	low end, leading to performance bottlenecks. To compensate, we use 	an algorithm to spread small hash values more evenly across large 	collections. Large hash values, however, are used as-is, under the 	assumption that they are more likely to have been adequately 	spread, and also to avoid LargeInteger performance loss."	^(length &gt; Set.SmallCollectionLimit and:			[aHashValue &lt;= ObjectMemory maximumIdentityHashValue])		ifTrue: [aHashValue * (length // Set.SmallCollectionLimit + 1) \\ length + 1]		ifFalse: [aHashValue \\ length + 1]</body><body package="COBase">valuesCollectionClass	^Set</body></methods><methods><class-id>COAST.MultiValueDictionary</class-id> <category>accessing</category><body package="COBase">anyKey	self keysDo: [: anyKey | ^ anyKey ].	^ nil</body><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSMultiValueDictionary new )		value: self;		yourself</body><body package="COBase">atKey: key add: value 	| theSet |	theSet := self atKey: key ifAbsentPut: [ Set new ].	theSet beMutable.	theSet add: value.	theSet beImmutable.	^ value</body><body package="COBase">atKey: key addAll: valueCollection 	| theSet |	theSet := self atKey: key ifAbsentPut: [ Set new: valueCollection size ].	theSet beMutable.	theSet addAll: valueCollection.	theSet beImmutable.	^ valueCollection</body><body package="COBase">atKey: key ifAbsent: aBlock 	"Answer the value at key.  If key is not found, answer the	result of evaluating aBlock."	| index obj|	index := self findKeyOrNil: key.	obj := self basicAt: index.	^obj == nil		 ifTrue: [aBlock value]		ifFalse: [obj value]</body><body package="COBase">atKey: key ifAbsentPut: aBlock 	"Answer the value at key.  If key is not found, answer the	result of evaluating aBlock."	| index obj |	index := self findKeyOrNil: key.	obj := self basicAt: index.	^ obj == nil 		ifTrue: 		[ | valueSet |			valueSet := aBlock value.			self basicAt: index put: key -&gt; valueSet.			valueSet		]		ifFalse: [ obj value ]</body><body package="COBase">atKey: key includes: value	^ (self atKey: key ifAbsent: [ ^false ]) includes: value</body><body package="COBase">atKey: key remove: value ifAbsent: aBlock 	| theSet probe |	theSet := self atKey: key ifAbsent: nil.	theSet isNil ifTrue: [ ^ aBlock value ].	theSet beMutable.	probe := theSet remove: value ifAbsent: nil.	theSet beImmutable.	probe isNil ifTrue: [ ^ aBlock value ].	theSet isEmpty ifTrue: [ self removeKey: key ].	^ value</body><body package="COBase">atKey: key removeAll: values 	| theSet |	theSet := self atKey: key ifAbsent: nil.	theSet notNil ifTrue: 		[	theSet beMutable.			theSet removeAll: values ifAbsent: nil.			theSet beImmutable.			theSet isEmpty ifTrue: [ self removeKey: key ]		].</body><body package="COBase">atKeys: keys 	| result |	result := self species new.	keys do: 		[: key | | valuesOrNil |			valuesOrNil := self atKey: key ifAbsent: nil.			valuesOrNil notNil ifTrue: [ result atKey: key ifAbsentPut: valuesOrNil copy ]		].	^ result</body><body package="COBase">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rValues 	| result |	result := self species new.	someKeys do: 		[: key | | valuesOrNil |			valuesOrNil := self atKey: key ifAbsent: nil.			( valuesOrNil notNil and: [ valuesOrNil contains: [: v | rValues includes: v ]]) ifTrue: [ result atKey: key ifAbsentPut: valuesOrNil copy ]		].	^ result</body><body package="COBase">coastTotalByteSize	| sz |	sz := self coastObjectSize.	self valuesAssociationsDo: 		[: assoc |			sz := sz + assoc coastObjectSize + assoc key coastReferencedObjectSize 					+ assoc value coastTotalByteSize		].	^ sz</body><body package="COBase">includesKey: key 	"Answer the value at key.  If key is not found, answer the	result of evaluating aBlock."	| index |	index := self findKeyOrNil: key.	^ (self basicAt: index) ~= nil</body><body package="COBase">keysSize	| sum |	sum := 0.	1 to: self basicSize		do: 		[: i | | elem |			elem := self basicAt: i.			elem notNil ifTrue: [ sum := sum + 1 ]		].	^ sum</body><body package="COBase">noCheckAdd: anObject 	"Assume that anObject is not in the receiver and add it	without checking to make sure."	self basicAt: ( self findKeyOrNil: anObject key ) put: anObject</body><body package="COBase">postCopy	super postCopy.	1 to: self capacity		do: 		[: i | | value |			nil == ( value := self basicAt: i ) ifFalse: [ self basicAt: i put: value key -&gt; value value copy ]		]</body><body package="COBase">removeKey: key ifAbsent: absentBlock 	| index obj |	index := self findKeyOrNil: key.	obj := self basicAt: index.	^ obj == nil 		ifTrue: [ absentBlock value ]		ifFalse: 		[	self basicAt: index put: nil.			self fixCollisionsFrom: index.			obj value		]</body><body package="COBase">selectKeys: someKeys whichInclude: aValue 	| result |	result := Set new.	self valuesAssociationsDo: [: assoc | ( assoc value includes: aValue ) ifTrue: [ result add: assoc key ]].	^ result</body><body package="COBase">size	| sum |	sum := 0.	1 to: self basicSize		do: 		[: i | | elem |			elem := self basicAt: i.			elem notNil ifTrue: [ sum := sum + elem value size ]		].	^ sum</body></methods><methods><class-id>COAST.MultiValueDictionary</class-id> <category>enumerating</category><body package="COBase">do: aBlock 	self keysAndValuesDo: [: key : value | aBlock value: value ]</body><body package="COBase">isEmpty	self valuesAssociationsDo: [: elem | ^ false ].	^ true</body><body package="COBase">keys	| keys |	keys := Set new.	self valuesAssociationsDo: [: elem | keys add: elem key ].	^ keys</body><body package="COBase">keysAndValuesDo: block 	self valuesAssociationsDo: [: elem | elem value do: [: value | block value: elem key value: value ]]</body><body package="COBase">keysDo: block 	self valuesAssociationsDo: [: elem | block value: elem key ]</body><body package="COBase">values	| values |	values := Set new.	self valuesAssociationsDo: [: elem | values addAll: elem value ].	^ values</body><body package="COBase">valuesAssociationsDo: aBlock 	"Evaluate aBlock for each of the receiver's key/value-set associations."	1 to: self basicSize do: 		[:index |		| elem |		(elem := self basicAt: index) == nil ifFalse: [aBlock value: elem]]</body></methods><methods><class-id>COAST.MultiValueDictionary class</class-id> <category>instance creation</category><body package="COBase">new	^ self new: 2</body><body package="COBase">new: anInteger 	 	anInteger &gt;= 0 ifFalse: [Set improperCreationSizeSignal raiseWith: anInteger].	^(super new: (Set goodSizeFrom: anInteger))</body></methods><methods><class-id>COAST.CoastVersion</class-id> <category>testing</category><body package="COBase">isFutureCoastVersion	^ self major = self class defaultCoastMajorVersion 		ifTrue: [ self minor &gt; self class defaultCoastMinorVersion ]		ifFalse: [ self major &gt; self class defaultCoastMajorVersion ]</body></methods><methods><class-id>COAST.CoastVersion</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream	aStream nextPut: self major.	aStream nextPut: self minor.</body><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	self marshallBinaryTo: aStream</body></methods><methods><class-id>COAST.CoastVersion class</class-id> <category>utils</category><body package="COBase">buildString	^buildString isNil		ifTrue: [ '(Unknown build)' ]		ifFalse: [ 'Build ', buildString ]</body><body package="COBase">buildString: aString 	buildString := aString.	self initializeRSAKeys.</body><body package="COBase">defaultCoastMajorVersion	^ 5</body><body package="COBase">defaultCoastMinorVersion	^ 5</body><body package="COBase">defaultCoastVersion	^ self major: self defaultCoastMajorVersion minor: self defaultCoastMinorVersion</body><body package="COBase">versionOf: aName 	" get the version of the bundle / package / parcel, without querying Store "		| pundleModel registry parcel dbInfo |	registry := 'Store.Registry' asQualifiedReference valueOrDo: [ nil ].	^ ( registry isNil or: [( pundleModel := registry pundleNamed: aName ) isNil or: [ (dbInfo := pundleModel databaseInformation) isNil or: [ dbInfo dbVersion isEmpty ]]]) 		ifTrue: 		[	"no store, or store does not know about this pundle"			( parcel := Parcel parcelNamed: aName ) isNil 				ifTrue: [ 'unknown version' ]				ifFalse: [ parcel version ]		]		ifFalse: [ dbInfo dbVersion ]</body></methods><methods><class-id>COAST.CoastVersion class</class-id> <category>accessing</category><body package="COBase">buildTimestamp: aTimestamp	| aStream |	aStream := WriteStream on: (String new: 32).	(aTimestamp year \\ 100) printOn: aStream paddedWith: $0 to: 2 base: 10.	aTimestamp month printOn: aStream paddedWith: $0 to: 2 base: 10.	aTimestamp day printOn: aStream paddedWith: $0 to: 2 base: 10.	aTimestamp hour printOn: aStream paddedWith: $0 to: 2 base: 10.	self buildString: aStream contents</body><body package="COBase">printImageIdOn: stream 	self printFingerprintOn: stream.	stream nextPutAll: 'build='; nextPutAll: COAST.CoastVersion buildString; cr.	self printRSAOn: stream.</body></methods><methods><class-id>COAST.CoastVersion class</class-id> <category>instance creation</category><body package="COBase">unmarshallBinaryFrom: aStream	^ self 		major: aStream next		minor: aStream next</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	^ self unmarshallBinaryFrom: aStream</body></methods><methods><class-id>COAST.CoastVersion class</class-id> <category>crypto</category><body package="COBase">addTrustedPublicKey: publicRsaKey 	| coastMD5FingerPrint |	trustedPublicKeys isNil ifTrue: [ trustedPublicKeys := Dictionary new ].	coastMD5FingerPrint := publicRsaKey coastMD5FingerPrint.	trustedPublicKeys at: coastMD5FingerPrint put: publicRsaKey.	^ coastMD5FingerPrint</body><body package="COBase">challengeEnabled	"Developer image may skip challenge"	^ trustedPublicKeys notNil and: [ Notifier isDevelopment not ]</body><body package="COBase">coastSign: aMessageByteArray 	^ ( rsa notNil and: [ aMessageByteArray notEmpty ]) 		ifTrue: [ rsa coastSign: aMessageByteArray ]		ifFalse: [ #[ ]]</body><body package="COBase">coastVerify: aSignatureArray of: aMessageByteArray publicKey: aKey 	^ ( aMessageByteArray isEmpty and: [ aSignatureArray isEmpty ]) 		or: [ Security.RSA coastVerify: aSignatureArray of: aMessageByteArray publicKey: aKey ]</body><body package="COBase">disabledChallenge	trustedPublicKeys := nil</body><body package="COBase">dummyPublicFingerPrint	^ #[ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]</body><body package="COBase">initializeRSAKeys	"self addTrustedPublicKey: rsa publicKey"	| probe sig gen |	gen := Security.RSAKeyGenerator keySize: 1024.	rsa := Security.RSA new.	rsa privateKey: gen privateKey.	rsa publicKey: gen publicKey.	rsa useMD5.	rsa privateKey qInv == 0 ifTrue: [ rsa privateKey qInv: nil	"patch initialize error fpr private key" ].	probe := rsa publicKey coastChallenge.	sig := rsa coastSign: probe.	( Security.RSA coastVerify: sig of: probe publicKey: rsa publicKey ) ifFalse: [ CoastError raiseSignal: 'RSA implementation failed' ].</body><body package="COBase">printFingerprintOn: stream 	stream nextPut: $[.	stream nextPutAll: CoastConstant iniAccessBuildIDPrefix.	self publicKeyMD5FingerPrint do: [: byte | byte printOn: stream paddedWith: $0 to: 2 base: 16 ].	stream nextPut: $]; cr.</body><body package="COBase">printRSA: int prefix: prefix on: stream 	| digitStream digitLength offset pad |	digitLength := int digitLength.	digitStream := ( String new: digitLength \\ 2 * 2 ) readWriteStream.	int printOn: digitStream base: 16.	pad := digitStream size odd.	digitStream reset.	offset := 1.	[	stream nextPutAll: prefix.		stream nextPut: $_.		offset printOn: stream.		stream nextPut: $=.		pad ifTrue: 			[	stream nextPut: $0.				pad := false			].		stream nextPutAll: ( digitStream nextAvailable: 32 ).		stream cr.		digitStream atEnd	] whileFalse: [ offset := offset + 1 ].</body><body package="COBase">printRSAOn: stream 	self printRSA: rsa publicKey n prefix: 'rsa.n' on: stream.	self printRSA: rsa publicKey e prefix: 'rsa.e' on: stream.</body><body package="COBase">publicKey	^rsa publicKey</body><body package="COBase">publicKeyMD5FingerPrint	^ rsa notNil 		ifTrue: [ rsa publicKey coastMD5FingerPrint ]		ifFalse: [ self dummyPublicFingerPrint ]</body><body package="COBase">publicKeyMD5FingerPrintOrNil	| stream |	^ rsa notNil 		ifTrue: 		[	stream := String new writeStream.			self publicKeyMD5FingerPrint do: [: byte | byte printOn: stream paddedWith: $0 to: 2 base: 16 ].			stream contents		]		ifFalse: [ nil ]</body><body package="COBase">rsa	^rsa</body><body package="COBase">trustedPublicKeyForFingerPrint: fingerPrint 	^ trustedPublicKeys notNil 		ifTrue: [ trustedPublicKeys atKey: fingerPrint ifAbsent: nil ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CoastVersion class</class-id> <category>compatibility</category><body package="COBase">checkForBlacklistedVMVersion	VisualWorksVersion checkForBlacklistedVMVersion</body><body package="COBase">imageVersion	^ VisualWorksVersion imageVersion</body><body package="COBase">imageVersionString	^ VisualWorksVersion imageVersionString</body><body package="COBase">vmVersion	^ VisualWorksVersion vmVersion</body><body package="COBase">vmVersionString	^ VisualWorksVersion vmVersionString</body></methods><methods><class-id>COAST.VisualWorksVersion</class-id> <category>accessing</category><body package="COBase">patch	^ patch ifNil: [ 0 ]</body><body package="COBase">patch: anInteger 	(anInteger notNil and: [  anInteger &lt; 0 or: [ anInteger &gt; 255 ]]) 		ifTrue: [ self error: 'Illegal patch version' ].	patch := anInteger.</body><body package="COBase">suffix	^ suffix</body><body package="COBase">suffix: anInteger 	" a = 1, b = 2 and so on... "	(anInteger notNil and: [ anInteger &lt; 1 or: [ anInteger &gt; 26 ]]) 		ifTrue: [ self error: 'Illegal suffix' ].	suffix := anInteger.</body></methods><methods><class-id>COAST.VisualWorksVersion</class-id> <category>private</category><body package="COBase">comparisonArray	^ Array with: self major with: self minor with: self patch with: self suffix</body></methods><methods><class-id>COAST.VisualWorksVersion</class-id> <category>printing</category><body package="COBase">printOn: stream 	self major printOn: stream.	stream nextPut: $..	self minor printOn: stream.	patch notNil		ifTrue: 		[	stream nextPut: $..			self patch printOn: stream		].	(suffix notNil and: [ suffix &gt;  0 ])		ifTrue: [ stream nextPut: ( Character codePoint: $a codePoint + suffix - 1 )].</body></methods><methods><class-id>COAST.VisualWorksVersion class</class-id> <category>instance creation</category><body package="COBase">major: majorByte minor: minorByte patch: patchByte 	^ self new		major: majorByte;		minor: minorByte;		patch: patchByte;		yourself</body><body package="COBase">major: majorByte minor: minorByte patch: patchByte suffix: aSuffix 	^ self new		major: majorByte;		minor: minorByte;		patch: patchByte;		suffix: aSuffix;		yourself</body></methods><methods><class-id>COAST.VisualWorksVersion class</class-id> <category>accessing</category><body package="COBase">checkForBlacklistedVMVersion	| versionID major |	versionID := ObjectMemory versionId.	major := versionID at: 3.	" Require at least 7.7 "	major &lt; 67 		ifTrue: 		[	" many of those versions suffer from 4 GB Bugs "			CoastError raiseSignal: 'Virtual machine version is too old'		].</body><body package="COBase">imageVersion	| major minor patch |	major := ObjectMemory viReleaseSeries.	minor := ObjectMemory viReleaseMajor.	patch := ObjectMemory viReleaseMinor.	^ patch &gt; 0 		ifTrue: [ VisualWorksVersion major: major minor: minor  patch: patch ]		ifFalse: [ VisualWorksVersion major: major minor: minor  ]</body><body package="COBase">imageVersionString	" If the version should just be printed and comparison / ordering is not required, use this method instead of #imageVersion,	because the version scheme might change in the future "	^ self imageVersion printString</body><body package="COBase">vmVersion	"self vmVersion"	| versionID major minor |	versionID := ObjectMemory versionId.	major := versionID at: 3.	minor := ( versionID at: 4 ) bitShift: -4.	( major = 75 and: [ minor = 2r1001 ]) 		ifTrue: [ ^ self major: 7 minor: 10 patch: 1 suffix: 1 ].	( major = 75 and: [ minor = 2r0111 ]) 		ifTrue: [ ^ self major: 7 minor: 10 patch: 1 ].	( major = 74 and: [ minor = 2r1111 ]) 		ifTrue: [ ^ self major: 7 minor: 10 ].	( major = 73 and: [ minor = 2r0101 ]) 		ifTrue: [ ^ self major: 7 minor: 9 patch: 1 ].	( major = 73 and: [ minor = 2r0100 ]) 		ifTrue: [ ^ self major: 7 minor: 9 patch: nil suffix: 1 ].	( major = 72 and: [ minor = 2r1010 ]) 		ifTrue: [ ^ self major: 7 minor: 9 ].	( major = 72 and: [ minor = 2r1001 ]) 		ifTrue: [ ^ self major: 7 minor: 8 patch: 1 suffix: 1 ].	( major = 71 and: [ minor = 2r1100 ]) 		ifTrue: [ ^ self major: 7 minor: 8 patch: 1 ].	( major = 70 and: [ minor = 2r1111 ]) 		ifTrue: [ ^ self major: 7 minor: 8 patch: nil suffix: 1].	( major = 70 and: [ minor = 2r1000 ]) 		ifTrue: [ ^ self major: 7 minor: 8 ].	( major = 68 and: [ minor = 2r1110 ]) 		ifTrue: [ ^ self major: 7 minor: 7 patch: 1  ].	( major = 67 and: [ minor = 2r1110 ]) 		ifTrue: [ ^ self major: 7 minor: 7 patch: nil suffix: 1  ].	( major = 67 and: [ minor = 2r0010 ]) 		ifTrue: [ ^ self major: 7 minor: 7 ].		( major = 65 and: [ minor = 2r0100 ]) 		ifTrue: [ ^ self major: 7 minor: 6 patch: nil suffix: 3 ].		( major = 64 and: [ minor = 2r1111 ]) 		ifTrue: [ ^ self major: 7 minor: 6 patch: nil suffix: 2 ].		( major = 63 and: [ minor = 2r1100 ]) 		ifTrue: [ ^ self major: 7 minor: 6 ].		^ nil</body><body package="COBase">vmVersionString	" If the version should just be printed and comparison / ordering is not required, use this method instead of #vmVersion,	because the version scheme might change in the future "	^ self vmVersion ifNotNil: [ : version | version printString ] ifNil: [ 'Unknown VM version (ID: ' , ObjectMemory versionId printString , ')' ].</body></methods><methods><class-id>COAST.AccessDeniedError class</class-id> <category>accessing</category><body package="COBase">statusResponseCode	^ CoastStatusResponse codeAccessDenied</body></methods><methods><class-id>COAST.CatCSReadCellAccess</class-id> <category>accessing</category><body package="COTransactions">addToAgenda: agenda 	agenda addReadAccess: self</body></methods><methods><class-id>COAST.CatCSReadCellAccess</class-id> <category>testing</category><body package="COTransactions">hasAddedTempObjects	^ false</body></methods><methods><class-id>COAST.CatCSReadCellAccess class</class-id> <category>testing</category><body package="COCellAccesses">isReadAccess	^ true</body></methods><methods><class-id>COAST.CatCSWriteCellAccess</class-id> <category>testing</category><body package="COCellAccesses">argumentToCheck	" Before writing new objects, it must be validated that they are either frame objects or	supported primitive objects. argumentToCheck answers that that object "	^ self arg1</body><body package="COCellAccesses">isValidAccess	" Before writing new objects, it must be validated that they are either frame objects or	supported primitive objects, and that shared frames do not point to local frames "	self argumentsDo: [: elem | 		elem isValidAccessParameter ifFalse: [ ^ false ]	].	^ true</body><body package="COCellAccesses">mayIgnoreForProxies	^ true</body></methods><methods><class-id>COAST.CatCSWriteCellAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	self subclassResponsibility</body><body package="COCellAccesses">computeDifferencesIfNeeded	"compute differences between pre- and post-access"	diffs isNil ifFalse: [ self computeDifferences ].</body><body package="COCellAccesses">differences	^diffs</body><body package="COCellAccesses">keepDifferences	"tells me to keep differences between pre- and post-access"	diffs isNil ifTrue: [ diffs := CatCSCellValueDifferences new ].</body><body package="COCellAccesses">keepDifferencesAndValue	"tells me to keep differences between pre- and post-access"	diffs isNil 		ifTrue: [ diffs := CatCSCellValueAndDifferences oldValue: self cell resolvedCellValue copy ]		ifFalse: [ self error: 'keepDifferencesAndValue is not compatible with keepDifferences' ].</body><body package="COCellAccesses">removedDictAt: arg	| val removedDict |	val := self cellValueHolder value.	removedDict := Dictionary new.	(val includesKey: arg) 		ifTrue: [ removedDict at: arg put: (val at: arg) ].	^removedDict</body></methods><methods><class-id>COAST.CatCSWriteCellAccess</class-id> <category>slot initializing</category><body package="COCellAccesses">initializeSlot: slot protoSlot: protoSlot 	| clusterManager |	clusterManager := self clusterManager.	clusterManager notNil ifTrue: 		[	clusterManager useProxyValueHolder 				ifTrue: [ self cellValueHolder changeToDelegatingProxyForSlot: slot ]				ifFalse: 				[ | frame |					frame := slot initializeForArgumentsBlock: [ self arguments ] inVolume: clusterManager volume.					frame notNil ifTrue: [ slot frame at: slot id set: frame ]				]		].	self initializeSlot: slot protoValue: protoSlot valueHolder value.</body><body package="COCellAccesses">initializeSlot: slot protoValue: copiedValue 	" slots are only created when writing the slot "	copiedValue isCoastPrimitiveValue ifTrue: [ ^ slot resolvedValueHolder value: copiedValue copy	"no need to log the setting of the default value" ].	copiedValue isEmpty ifTrue: [ ^ self	"nothing to do here" ].	"inform the mediator, do a setAll for the old value. there will be a value:-access on the new slot in this transaction "	slot frame at: slot id setAll: copiedValue.</body></methods><methods><class-id>COAST.CatCSWriteCellAccess</class-id> <category>accessing</category><body package="COTransactions">addToAgenda: agenda 	"proxy accesses do not count on local clients - avoids unnecessary cluster modification"	( self cellValueHolder isProxyValueHolder and: [ self clusterManager isLocalClient ]) ifTrue: [ ^ self ].	agenda prepareWriteAccess: self.	agenda addWriteAccess: self maskOld: false.</body><body package="COTransactions">maskedByValueWrite: access 	^ self cell == access cell</body></methods><methods><class-id>COAST.CatCSWriteCellAccess class</class-id> <category>testing</category><body package="COCellAccesses">isReadAccess	^ false</body></methods><methods><class-id>COAST.CatFSFrameReference</class-id> <category>accessing</category><body package="COBase">asWeakFrameReference	^ self</body><body package="COBase">coastFrameDictKey	^ self frameClassSymbol</body><body package="COCellValueHolder">copyForRefCursor	^ self copy</body><body package="COBase">frameClass: aClass	frameClassOrSymbol := aClass</body><body package="COBase">frameClassFor: aNameSpaceManager 	| frameClass |	^ frameClassOrSymbol isCharacters 		ifTrue: 		[	frameClass := aNameSpaceManager classForCoastClassName: self frameClassName.			( frameClass isNil or: [ frameClass coastIsFrameClass ]) 				ifTrue: [ frameClass ]				ifFalse: [ nil ]		]		ifFalse: [ frameClassOrSymbol ]</body><body package="COBase">frameClassName	^self frameClassSymbol asString</body><body package="COBase">frameClassName: aString	frameClassOrSymbol := aString asSymbol</body><body package="COBase">frameClassSymbol	^frameClassOrSymbol isCharacters		ifTrue: [ frameClassOrSymbol ]		ifFalse: [ frameClassOrSymbol frameClassSymbol]</body><body package="COBase">frameClassSymbol: aSymbol	frameClassOrSymbol := aSymbol</body><body package="COBase">frameForCluster: aCatCSCluster	^ aCatCSCluster directTableAccessAt: self id</body><body package="COBase">frameKey	^ frameClassOrSymbol frameKey</body><body package="COBase">frameKey: aSymbolOrClass	aSymbolOrClass isCharacters		ifTrue: [ self frameClassName: aSymbolOrClass asString ]		ifFalse: [ self frameClass: aSymbolOrClass ]</body><body package="COBase">frameLocator	^ CatCSFrameLocator newFrameID: self frameID clusterID: self clusterID</body><body package="COBase">frameReference	^ self</body><body package="COBase">translatedArgumentForCluster: aCatCSCluster	| f |	f := aCatCSCluster clusterController clusterManager resolveFrameReference: self.	f isNil ifTrue: [self haltOrContinue: 'Frame argument ', self printString, ' not found' ].	^ f</body></methods><methods><class-id>COAST.CatFSFrameReference</class-id> <category>testing</category><body package="COBase">asValidFrameReferenceOrNil	^self</body><body package="COBase">coastIsValidRPCArgument	^true</body><body package="COBase">isCoastPrimitiveValue	^ false</body><body package="COBase">selfOrFrameLocator	^ self frameLocator</body></methods><methods><class-id>COAST.CatFSFrameReference</class-id> <category>printing</category><body package="COBase">basicPrintOn: aStream 	aStream nextPutAll: self frameClassName.	aStream nextPut: $&lt;.	super basicPrintOn: aStream.	aStream nextPut: $&gt;.</body><body package="COBase">shortClassName	^ 'frameReference '</body></methods><methods><class-id>COAST.CatFSFrameReference</class-id> <category>marshalling</category><body package="COMarshalling">asByteArray: aCatRMMarshall	| str |	str := (ByteArray new: 11) writeStream.	self marshallBinaryTo: str marshaller: aCatRMMarshall.	^ str contents</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	" marshall primitive object argument "	aStream nextPut: self class marshallID.	aStream nextOptimized32Put: self clusterID.	aStream nextOptimized32Put: self id.	aStream nextShortStringPut: self frameClassSymbol.</body><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: self clusterID.	aStream nextOptimized32Put: self id.	aCatRMMarshall writeFrameClassSymbol: self coastFrameDictKey to: aStream.</body><body package="COMarshalling">marshallBinaryValueTo: aStream marshaller: aCatRMMarshall 	aCatRMMarshall currentClusterID = self clusterID 		ifTrue: [ CatFSFrameID marshallBinaryValue: frameID to: aStream ]		ifFalse: 		[	"external frame reference"			aStream nextPut: self class marshallID.			self marshallBinaryTo: aStream marshaller: aCatRMMarshall		].</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	self clusterID: aStream nextOptimized32.	self id: aStream nextOptimized32.	self frameClassName: aStream nextShortString.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	self clusterID: aStream nextOptimized32.	self id: aStream nextOptimized32.	self frameClassSymbol: (aCatRMMarshall readFrameKeyFrom: aStream).</body><body package="COMarshalling">unmarshallBinaryReferenceFrom: aStream marshaller: aCatRMMarshall 	" load the reference and resolve it "	| marshallerClusterID |	self unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall.	marshallerClusterID := aCatRMMarshall currentClusterID.	( marshallerClusterID notNil and: [ self clusterID = marshallerClusterID ]) ifTrue: 		[ "some obsolete code in #at:setAll: did store frame references for frames in the same cluster"			| frame |			frame := aCatRMMarshall clusterController cluster frameFor: self frameID.			frame notNil ifTrue: [ ^ frame ].			self error: 'Frame reference not found: cluster ' , marshallerClusterID printString , ' frame ' , self frameID printString		].	^ aCatRMMarshall clusterManager resolveFrameReference: self</body><body package="COMarshalling">valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall	aCatRMMarshall frameSlotIndexForSymbol: self frameClassSymbol.</body></methods><methods><class-id>COAST.CatFSFrameReference class</class-id> <category>instance creation</category><body package="COBase">clusterID: clusterIDInteger id: frameID class: aClass	^ self new		clusterID: clusterIDInteger;		id: frameID;		frameClass: aClass;		yourself</body><body package="COBase">clusterID: clusterIDInteger id: frameID className: className	^ self new		clusterID: clusterIDInteger;		id: frameID;		frameClassName: className;		yourself</body><body package="COBase">clusterID: clusterIDInteger id: frameID classSymbol: classSymbol	^ self new		clusterID: clusterIDInteger;		id: frameID;		frameClassSymbol: classSymbol;		yourself</body><body package="COBase">clusterID: clusterIDInteger id: frameID frameKey: aSymbolOrClass	^ self new		clusterID: clusterIDInteger;		id: frameID;		frameKey: aSymbolOrClass;		yourself</body><body package="COBase">frame: aCatFSFrame	aCatFSFrame clusterID isNil		ifTrue: [ self error: 'Frame ', aCatFSFrame printString, ' is not yet assigned to a cluster' ].	^self		clusterID: aCatFSFrame clusterID		id: aCatFSFrame id		frameKey: aCatFSFrame coastFrameDictKey</body><body package="COBase">newFullIDNumber: anInteger frameClass: aClass 	^ ( self newFullIDNumber: anInteger )		frameClass: aClass;		yourself</body></methods><methods><class-id>COAST.CatFSFrameReference class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	^ 2</body></methods><methods><class-id>COAST.CatCSKeyIntervalAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder fromKey: self arg1 toKey: self arg2 inclusive: true</body></methods><methods><class-id>COAST.CatCSKeyIntervalAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 39</body></methods><methods><class-id>COAST.CatCSIncludesKeyAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder includesKey: self arg1</body></methods><methods><class-id>COAST.CatCSIncludesKeyAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 29</body></methods><methods><class-id>COAST.CatCSIncludesKeyAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #( #CatCSRemoveKeyAccess #CatCSAtKeyAddAccess )</body></methods><methods><class-id>COAST.CatCSAbstractRemoveAccess</class-id> <category>testing</category><body package="COCellAccesses">argumentToCheck	^ nil</body><body package="COTransactions">hasAddedTempObjects	^ false</body></methods><methods><class-id>COAST.CatCSAbstractRemoveAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	diffs removed: ( Set with: self firstArgument).</body></methods><methods><class-id>COAST.CatCSAddAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder 	aCatCSCellValueHolder coastInternalAdd: self arg1 withAccess: self.	^ self arg1</body></methods><methods><class-id>COAST.CatCSAddAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	| arg |	arg := self firstArgument.	( self cellValueHolder includes: arg ) ifFalse: 		[	diffs added: ( Set with: arg ).			self cellValueHolder isSingleValue ifTrue: [ diffs removed: ( Set with: self cellValueHolder value )]		].</body></methods><methods><class-id>COAST.CatCSAddAccess</class-id> <category>testing</category><body package="COTransactions">hasAddedTempObjects	^ self argument isTempSharedFrame</body></methods><methods><class-id>COAST.CatCSAddAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	^ #(#CatCSAtIndexPutAccess #CatCSAddFirstAccess #CatCSFirstAccess #CatCSAddAccess #CatCSAddWithOccurrencesAccess #CatCSAddBeforeIndexAccess #CatCSAtIndexAccess )</body><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #( #CatCSRemoveAllOccurrencesAccess #CatCSOccurrencesOfAccess #CatCSIncludesAccess #CatCSRemoveAccess #CatCSBeforeAccess #CatCSIndexOfAccess )</body><body package="COCellAccesses">commutativeWithEqualArgumentClasses	^ #(#CatCSAddLastAccess )</body></methods><methods><class-id>COAST.CatCSAddAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 1</body></methods><methods><class-id>COAST.CatCSAddAccess class</class-id> <category>remap</category><body package="COCellAccesses">remapForOrderedCollection	^ CatCSAddLastAccess</body><body package="COCellAccesses">remapForSingleValue	^ CatCSValueWriteAccess</body></methods><methods><class-id>COAST.CatCSIndexOfAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder indexOf: self arg1</body></methods><methods><class-id>COAST.CatCSIndexOfAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 21</body></methods><methods><class-id>COAST.CatCSAtIndexPutAccess</class-id> <category>testing</category><body package="COCellAccesses">argumentToCheck	" Before writing new objects, it must be validated that they are either frame objects or	supported primitive objects. argumentToCheck answers that that object "	^ self arg2</body><body package="COTransactions">hasAddedTempObjects	^ self arg2 isTempSharedFrame</body><body package="COCellAccesses">isValidAccess	"index must not be nil"	self firstArgument notNil ifFalse: [ ^ false ].	^ super isValidAccess</body></methods><methods><class-id>COAST.CatCSAtIndexPutAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalAt: self arg1 put: self arg2</body></methods><methods><class-id>COAST.CatCSAtIndexPutAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	| arg |	arg := self firstArgument.	(arg isInteger and: [ arg &gt;= 1 and: [ self cellValueHolder size &gt;= arg ] ]) 		ifTrue: [ diffs removed: (Set with: (self cellValueHolder at: arg)) ].	diffs added: (Set with: (self argumentAt: 2))</body></methods><methods><class-id>COAST.CatCSAtIndexPutAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #(#CatCSAtIndexPutAccess)</body></methods><methods><class-id>COAST.CatCSAtIndexPutAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 18</body></methods><methods><class-id>COAST.CatCSAtKeyAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder atKey: self arg1</body></methods><methods><class-id>COAST.CatCSAtKeyAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 27</body></methods><methods><class-id>COAST.CatCSAtKeyAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #( #CatCSAtKeyPutAccess #CatCSAtKeyAddAccess #CatCSRemoveKeyAccess )</body></methods><methods><class-id>COAST.CatCSKeyAtValueAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder keyAtValue: self arg1</body></methods><methods><class-id>COAST.CatCSKeyAtValueAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 30</body></methods><methods><class-id>COAST.CatCSRemoveAllOccurrencesAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	CoastError raiseSignal: 'differences on bags are not supported'.</body></methods><methods><class-id>COAST.CatCSRemoveAllOccurrencesAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalRemoveAllOccurrencesOf: self arg1</body></methods><methods><class-id>COAST.CatCSRemoveAllOccurrencesAccess</class-id> <category>testing</category><body package="COTransactions">hasAddedTempObjects	^ false</body></methods><methods><class-id>COAST.CatCSRemoveAllOccurrencesAccess class</class-id> <category>accessing</category><body package="COCellAccesses">commutativeClasses	" Answer all access classes (as symbols) who are always commutative to this access class.	Two read accesses are always commutative, so they don't need to be explicitly listed here "	^ #( #CatCSRemoveAllOccurrencesAccess #CatCSDepleteAccess )</body><body package="COCellAccesses">id	^ 23</body></methods><methods><class-id>COAST.CatCSDepleteAccess</class-id> <category>testing</category><body package="COCellAccesses">argumentToCheck	" Before writing new objects, it must be validated that they are either frame objects or	supported primitive objects. argumentToCheck answers that that object "	^ nil</body><body package="COTransactions">hasAddedTempObjects	^ false</body></methods><methods><class-id>COAST.CatCSDepleteAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder 	^ aCatCSCellValueHolder depleteWith: self</body></methods><methods><class-id>COAST.CatCSDepleteAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	| vh |	vh := self cellValueHolder.	diffs added: vh valueAsDepleteAddedCollection.	diffs removed: vh valueAsDepleteRemovedCollection.</body></methods><methods><class-id>COAST.CatCSDepleteAccess</class-id> <category>slot initializing</category><body package="COCellAccesses">initializeSlot: slot protoValue: copiedValue 	"nothing to do - the value will be removed"</body></methods><methods><class-id>COAST.CatCSDepleteAccess</class-id> <category>accessing</category><body package="COTransactions">addToAgenda: agenda 	agenda prepareWriteAccess: self.	agenda addWriteAccess: self maskOld: true.</body></methods><methods><class-id>COAST.CatCSDepleteAccess class</class-id> <category>accessing</category><body package="COCellAccesses">commutativeClasses	" Answer all access classes (as symbols) who are always commutative to this access class.	Two read accesses are always commutative, so they don't need to be explicitly listed here "	^ #( #CatCSDepleteAccess #CatCSRemoveAtIndexAccess )</body><body package="COCellAccesses">id	^ 34</body></methods><methods><class-id>COAST.CatCSFirstAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder first</body></methods><methods><class-id>COAST.CatCSFirstAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 20</body></methods><methods><class-id>COAST.CatCSOccurrencesOfAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder occurrencesOf: self arg1</body></methods><methods><class-id>COAST.CatCSOccurrencesOfAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 4</body></methods><methods><class-id>COAST.CatCSOccurrencesOfAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #( #CatCSRemoveAllOccurrencesAccess #CatCSRemoveAccess #CatCSAddWithOccurrencesAccess #CatCSAddLastAccess #CatCSAddFirstAccess )</body></methods><methods><class-id>COAST.CatCSAtIndexAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder at: self arg1</body></methods><methods><class-id>COAST.CatCSAtIndexAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #(#CatCSAtIndexPutAccess )</body></methods><methods><class-id>COAST.CatCSAtIndexAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 17</body></methods><methods><class-id>COAST.CatCSRemoveAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder 	^ aCatCSCellValueHolder coastInternalRemove: self arg1 withAccess: self</body></methods><methods><class-id>COAST.CatCSRemoveAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	| arg |	arg := self firstArgument.	(self cellValueHolder includes: arg) ifTrue:	[		diffs removed: (Set with: arg).	].</body></methods><methods><class-id>COAST.CatCSRemoveAccess</class-id> <category>testing</category><body package="COTransactions">hasAddedTempObjects	^ false</body></methods><methods><class-id>COAST.CatCSRemoveAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	^ #( #CatCSRemoveAccess #CatCSRemoveAllOccurrencesAccess #CatCSDepleteAccess )</body><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #(#CatCSAddLastAccess #CatCSAddWithOccurrencesAccess #CatCSAddFirstAccess )</body></methods><methods><class-id>COAST.CatCSRemoveAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 5</body></methods><methods><class-id>COAST.CatCSIncludesAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder includes: self arg1</body></methods><methods><class-id>COAST.CatCSIncludesAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 2</body></methods><methods><class-id>COAST.CatCSIncludesAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #( #CatCSRemoveAllOccurrencesAccess #CatCSRemoveAccess #CatCSAddWithOccurrencesAccess #CatCSAddLastAccess #CatCSAddFirstAccess )</body></methods><methods><class-id>COAST.CatCSBeforeAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder before: self arg1</body></methods><methods><class-id>COAST.CatCSBeforeAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 19</body></methods><methods><class-id>COAST.CatCSAfterAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder after: self arg1</body></methods><methods><class-id>COAST.CatCSAfterAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 16</body></methods><methods><class-id>COAST.CatCSValueReadAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder valueForReadAccess</body></methods><methods><class-id>COAST.CatCSValueReadAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 7</body></methods><methods><class-id>COAST.CatCSIsEmptyAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder isEmpty</body></methods><methods><class-id>COAST.CatCSIsEmptyAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 3</body></methods><methods><class-id>COAST.CatCSKeysAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder keys</body></methods><methods><class-id>COAST.CatCSKeysAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 31</body></methods><methods><class-id>COAST.CatCSValuesAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder values</body></methods><methods><class-id>COAST.CatCSValuesAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 33</body></methods><methods><class-id>COAST.CatCSExclusiveKeyIntervalAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder fromKey: self arg1 toKey: self arg2 inclusive: false</body></methods><methods><class-id>COAST.CatCSExclusiveKeyIntervalAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 40</body></methods><methods><class-id>COAST.CatCSSizeAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder size</body></methods><methods><class-id>COAST.CatCSSizeAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 6</body></methods><methods><class-id>COAST.CatCSAbstractAddAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	diffs added: ( Set with: self firstArgument)</body></methods><methods><class-id>COAST.CatCSAbstractAddAccess</class-id> <category>testing</category><body package="COTransactions">hasAddedTempObjects	^ self arg1 isTempSharedFrame</body></methods><methods><class-id>COAST.CatCSValueWriteAccess</class-id> <category>performing</category><body package="COTransactions">addToAgenda: agenda 	agenda prepareWriteAccess: self.	agenda addWriteAccess: self maskOld: true.</body><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder value: self arg1</body></methods><methods><class-id>COAST.CatCSValueWriteAccess</class-id> <category>testing</category><body package="COTransactions">hasAddedTempObjects	^ self argument isTempSharedFrame</body><body package="COCellAccesses">hasValidFirstArgument	^ self cellValueHolder isValidSingleValue: self firstArgument</body><body package="COCellAccesses">isValidAccess	" Before writing new objects, it must be validated that they are either frame objects or	supported primitive objects, and that shared frames do not point to local frames "	^ super isValidAccess and: [ self hasValidFirstArgument ]</body><body package="COCellAccesses">mayIgnoreForProxies	" used for propagating the frame locator of the real index "	^ false</body></methods><methods><class-id>COAST.CatCSValueWriteAccess</class-id> <category>private</category><body package="COCellAccesses">setArgument1: aValue argument2: aValue2	self error: 'Wrong number of arguments'</body></methods><methods><class-id>COAST.CatCSValueWriteAccess</class-id> <category>slot initializing</category><body package="COCellAccesses">initializeSlot: slot protoSlot: protoSlot 	slot valueHolder isProxyValueHolder ifTrue: [ slot valueHolder clusterManager: self clusterManager ].</body><body package="COCellAccesses">initializeSlot: slot protoValue: copiedValue 	"nothing to do - the value will be replaced"</body></methods><methods><class-id>COAST.CatCSValueWriteAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	| old new |	old := self cellValueHolder value.	new := self firstArgument.	old = new ifFalse: 		[	old notNil ifTrue: [ diffs removed: ( Array with: old )].			new notNil ifTrue: [ diffs added: ( Array with: new )]		].</body></methods><methods><class-id>COAST.CatCSValueWriteAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 8</body><body package="COCellAccesses">isValueWriteAccess	^ true</body></methods><methods><class-id>COAST.CatCSAtKeyPutAccess</class-id> <category>testing</category><body package="COCellAccesses">argumentToCheck	" Before writing new objects, it must be validated that they are either frame objects or	supported primitive objects. argumentToCheck answers that that object "	^ self arg2</body><body package="COCellAccesses">isValidAccess	self firstArgument notNil ifFalse: [ ^ false ].	( self secondArgument notNil or: [ self cell allowsNilValueAtKey ]) ifFalse: [ ^ false ].	^ super isValidAccess 		or: [ self isFrameAccess and: [ self cell isValidAccessParameter and: [ self firstArgument isSymbol and: [ self secondArgument isSlot ]]]]</body></methods><methods><class-id>COAST.CatCSAtKeyPutAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder 	^ aCatCSCellValueHolder coastInternalAt: self arg1 put: self arg2 withAccess: self</body></methods><methods><class-id>COAST.CatCSAtKeyPutAccess</class-id> <category>differences</category><body package="COCellAccesses">addedDictAt: arg	| addedDict arg2 |	addedDict := Dictionary new.	(arg2 := self secondArgument ) notNil		ifTrue:  [ addedDict at: arg put: arg2 ].	^addedDict.</body><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	| arg |	arg := self firstArgument.	diffs removed: ( self removedDictAt: arg ).	diffs added: ( self addedDictAt: arg ).</body></methods><methods><class-id>COAST.CatCSAtKeyPutAccess</class-id> <category>accessing</category><body package="COTransactions">hasAddedTempObjects	^ self arguments contains: [: argument | argument isTempSharedFrame ]</body></methods><methods><class-id>COAST.CatCSAtKeyPutAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 28</body></methods><methods><class-id>COAST.CatCSAtKeyPutAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #( #CatCSAtKeyPutAccess #CatCSRemoveKeyAccess #CatCSIncludesKeyAccess #CatCSAtKeyIncludesAccess )</body></methods><methods><class-id>COAST.CatCSAddWithOccurrencesAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	CoastError raiseSignal: 'differences on bags are not supported'.</body></methods><methods><class-id>COAST.CatCSAddWithOccurrencesAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalAdd: self arg1 withOccurrences: self arg2</body></methods><methods><class-id>COAST.CatCSAddWithOccurrencesAccess</class-id> <category>testing</category><body package="COTransactions">hasAddedTempObjects	^ self arg1 isTempSharedFrame</body><body package="COCellAccesses">isValidAccess	"count must not be nil"	self secondArgument notNil ifFalse: [ ^ false ].	^ super isValidAccess</body></methods><methods><class-id>COAST.CatCSAddWithOccurrencesAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	^ #(#CatCSAddWithOccurrencesAccess )</body><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	" answer all access classes (as symbols) who are commutative to this access class only if	1) both have at least one argument	and 2) the arguments with the index returned by 'indexOfArgumentToCheck' of both accesses are different "	^ #( #CatCSRemoveAllOccurrencesAccess )</body></methods><methods><class-id>COAST.CatCSAddWithOccurrencesAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 15</body></methods><methods><class-id>COAST.CatCSAtKeyIncludesAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder 	^ aCatCSCellValueHolder atKey: self arg1 includes: self arg2</body></methods><methods><class-id>COAST.CatCSAtKeyIncludesAccess class</class-id> <category>accessing</category><body package="COCellAccesses">compare: args against: otherArgs from: anotherAccessClass 	^ anotherAccessClass compareArgs: otherArgs against: args</body><body package="COCellAccesses">compareArgs: args against: otherArgs 	^ args = otherArgs</body><body package="COCellAccesses">id	^ 38</body></methods><methods><class-id>COAST.CatCSLastAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder last</body></methods><methods><class-id>COAST.CatCSLastAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 22</body></methods><methods><class-id>COAST.CatCSAddLastAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalAddLast: self arg1</body></methods><methods><class-id>COAST.CatCSAddLastAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	^ #(#CatCSAtIndexPutAccess #CatCSFirstAccess #CatCSAtIndexAccess )</body><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #(#CatCSBeforeAccess #CatCSIndexOfAccess )</body><body package="COCellAccesses">commutativeWithEqualArgumentClasses	^ #(#CatCSAddLastAccess )</body></methods><methods><class-id>COAST.CatCSAddLastAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 14</body></methods><methods><class-id>COAST.CatCSAddBeforeIndexAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalAdd: self arg1 beforeIndex: self arg2</body></methods><methods><class-id>COAST.CatCSAddBeforeIndexAccess</class-id> <category>testing</category><body package="COCellAccesses">isValidAccess	"index must not be nil"	self secondArgument notNil ifFalse: [ ^ false ].	^ super isValidAccess</body></methods><methods><class-id>COAST.CatCSAddBeforeIndexAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	^ #(#CatCSAddLastAccess )</body></methods><methods><class-id>COAST.CatCSAddBeforeIndexAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 12</body></methods><methods><class-id>COAST.CatCSValueUpdateAccess</class-id> <category>testing</category><body package="COTransactions">hasAddedTempObjects	^ false</body></methods><methods><class-id>COAST.CatCSValueUpdateAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ -1</body></methods><methods><class-id>COAST.CatCSValueUpdateAccess class</class-id> <category>testing</category><body package="COCellAccesses">isUpdateAccess	^ true</body></methods><methods><class-id>COAST.CatCSRemoveFirstAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalRemoveFirst</body></methods><methods><class-id>COAST.CatCSRemoveFirstAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"		| val |	val := self cellValueHolder.	val isEmpty ifFalse:	[		diffs removed: (Set with: val first).	].</body></methods><methods><class-id>COAST.CatCSRemoveFirstAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 25</body></methods><methods><class-id>COAST.CatCSRemoveFirstAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	^ #( #CatCSRemoveFirstAccess #CatCSRemoveLastAccess #CatCSDepleteAccess )</body></methods><methods><class-id>COAST.CatCSRemoveLastAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalRemoveLast</body></methods><methods><class-id>COAST.CatCSRemoveLastAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"		| val |	val := self cellValueHolder.	val isEmpty ifFalse:	[		diffs removed: (Set with: val last).	].</body></methods><methods><class-id>COAST.CatCSRemoveLastAccess class</class-id> <category>accessing</category><body package="COCellAccesses">commutativeClasses	^ #( #CatCSRemoveLastAccess #CatCSDepleteAccess )</body><body package="COCellAccesses">id	^ 26</body></methods><methods><class-id>COAST.CatCSAtKeyAddAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder 	^ aCatCSCellValueHolder coastInternalAt: self arg1 add: self arg2 withAccess: self</body></methods><methods><class-id>COAST.CatCSAtKeyAddAccess</class-id> <category>differences</category><body package="COCellAccesses">addedDictAt: arg 	| addedDict arg2 |	addedDict := Index new.	(arg2 := self secondArgument ) notNil ifTrue: [ addedDict atKey: arg add: arg2 ].	^ addedDict</body><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	| arg |	arg := self firstArgument.	diffs removed: Index new.	diffs added: ( self addedDictAt: arg )</body></methods><methods><class-id>COAST.CatCSAtKeyAddAccess class</class-id> <category>accessing</category><body package="COCellAccesses">compare: args against: otherArgs from: anotherAccessClass 	^ anotherAccessClass compareArgs: otherArgs against: args</body><body package="COCellAccesses">compareArgs: args against: otherArgs 	^ args = otherArgs</body><body package="COCellAccesses">id	^ 36</body></methods><methods><class-id>COAST.CatCSAtKeyAddAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	" Answer all access classes (as symbols) who are always commutative to this access class.	Two read accesses are always commutative, so they don't need to be explicitly listed here "	^ #( #CatCSAtKeyAddAccess )</body><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #( #CatCSAtKeyIncludesAccess )</body></methods><methods><class-id>COAST.CatCSMaxJournalSizeWriteAccess</class-id> <category>testing</category><body package="COCellAccesses">hasValidFirstArgument	^ self firstArgument isInteger</body><body package="COCellAccesses">mayIgnoreForProxies	^ true</body></methods><methods><class-id>COAST.CatCSMaxJournalSizeWriteAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	diffs removed: #( ).	diffs added: #( ).</body></methods><methods><class-id>COAST.CatCSMaxJournalSizeWriteAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder 	| valueFrame |	transaction removeProxyAccess: self.	"mediator does not propagte this access"	"Nach MÃ¶glichkeit NICHT den Frame laden"	( self cellFrame shouldHandleJournalAccess ) ifTrue: 		[	valueFrame := self cellValueHolder valueFrame.			valueFrame isCoastFrame ifTrue: 				[	valueFrame coastInternalMaxJournalSize: self arg1 in: self cell.					^ self arg1				]		].	transaction needsFlush: true.	"clients will run this as a pessimistic transaction"	^ self arg1</body></methods><methods><class-id>COAST.CatCSMaxJournalSizeWriteAccess class</class-id> <category>accessing</category><body package="COCellAccesses">commutativeClasses	"CatCSCellAccess withAllSubclasses select: [:e | e id &gt; 0 ]  "	^ #( #CatCSBeforeAccess #CatCSFirstAccess #CatCSIndexOfAccess #CatCSSizeAccess #CatCSAtKeyAccess #CatCSIsEmptyAccess #CatCSLastAccess #CatCSKeyIntervalAccess #CatCSAfterAccess #CatCSOccurrencesOfAccess #CatCSKeyAtValueAccess #CatCSAtIndexAccess #CatCSExclusiveKeyIntervalAccess #CatCSKeysAccess #CatCSValuesAccess #CatCSValueReadAccess #CatCSIncludesKeyAccess #CatCSIncludesAccess #CatCSAtKeyIncludesAccess #CatCSRemoveAllOccurrencesAccess #CatCSRemoveAccess #CatCSAtIndexPutAccess #CatCSValueWriteAccess #CatCSDepleteAccess #CatCSAddWithOccurrencesAccess #CatCSAddAccess #CatCSAtKeyPutAccess #CatCSRemoveFirstAccess #CatCSAtKeyRemoveAccess #CatCSRemoveKeyAccess #CatCSRemoveAtIndexAccess #CatCSRemoveLastAccess #CatCSAddAfterIndexAccess #CatCSAddBeforeIndexAccess #CatCSAddBeforeAccess #CatCSAddAfterAccess #CatCSAddLastAccess #CatCSAddFirstAccess #CatCSCollectionWriteAccess #CatCSMaxJournalSizeWriteAccess #CatCSAtKeyAddAccess )</body><body package="COCellAccesses">id	^ 41</body></methods><methods><class-id>COAST.CatCSAddBeforeAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalAdd: self arg1 before: self arg2</body></methods><methods><class-id>COAST.CatCSAddBeforeAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	^ #(#CatCSAddLastAccess )</body></methods><methods><class-id>COAST.CatCSAddBeforeAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 11</body></methods><methods><class-id>COAST.CatCSAtKeyRemoveAccess</class-id> <category>differences</category><body package="COCellAccesses">addedDictAt: arg 	| addedDict arg2 |	addedDict := Index new.	( arg2 := self secondArgument) notNil ifTrue: [ addedDict atKey: arg add: arg2 ].	^ addedDict</body><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	| arg |	arg := self firstArgument.	diffs added: Index new.	diffs removed: ( self addedDictAt: arg )</body></methods><methods><class-id>COAST.CatCSAtKeyRemoveAccess</class-id> <category>testing</category><body package="COCellAccesses">argumentToCheck	" Before writing new objects, it must be validated that they are either frame objects or	supported primitive objects. argumentToCheck answers that that object "	^ self arg2</body><body package="COCellAccesses">isValidAccess	"all arguments must not be nil"	self argumentsDo: [: elem | elem notNil ifFalse: [ ^ false ]].	^ super isValidAccess 		or: [ self isFrameAccess and: [ cellOrCellWrapper isValidAccessParameter and: [ self firstArgument isSymbol and: [ self secondArgument isSlot ]]]]</body></methods><methods><class-id>COAST.CatCSAtKeyRemoveAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder 	^ aCatCSCellValueHolder coastInternalAt: self arg1 remove: self arg2 withAccess: self</body></methods><methods><class-id>COAST.CatCSAtKeyRemoveAccess class</class-id> <category>accessing</category><body package="COCellAccesses">compare: args against: otherArgs from: anotherAccessClass 	^ anotherAccessClass compareArgs: otherArgs against: args</body><body package="COCellAccesses">compareArgs: args against: otherArgs 	^ args = otherArgs</body><body package="COCellAccesses">id	^ 24</body></methods><methods><class-id>COAST.CatCSAtKeyRemoveAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	" Answer all access classes (as symbols) who are always commutative to this access class.	Two read accesses are always commutative, so they don't need to be explicitly listed here "	^ #( #CatCSAtKeyRemoveAccess #CatCSRemoveKeyAccess #CatCSDepleteAccess )</body><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #( #CatCSAtKeyAddAccess #CatCSAtKeyIncludesAccess #CatCSAtKeyAccess #CatCSAtKeyPutAccess #CatCSIncludesKeyAccess )</body></methods><methods><class-id>COAST.CatCSCollectionWriteAccess</class-id> <category>accessing</category><body package="COTransactions">allArgumentsDo: aBlock	self firstArgument do: [ : a |		aBlock value: a	].</body><body package="COCellAccesses">cell: aCell 	| col prepareArgument |	"maybe I have to prepare my arguments now"	prepareArgument := self cell ~~ aCell.	super cell: aCell.	( prepareArgument and: [ (col := self argument) notNil ])		ifTrue: [ 	self setArgument: (col coastValueFor: aCell valueHolder class) ].</body><body package="COCellAccesses">convertArgumentsForMinimalInvalidation	^ self convertArgumentsForReplication</body><body package="COCellAccesses">convertArgumentsForReplication	| newValueHolder cellCluster |	cellCluster := self cellCluster.	newValueHolder := self cellValueHolder class new.	newValueHolder setCollectionValueAsRemoteArgument: collectionCopyForReplication for: cellCluster.	^ Array with: newValueHolder</body></methods><methods><class-id>COAST.CatCSCollectionWriteAccess</class-id> <category>private</category><body package="COCellAccesses">setArgument: aCollection 	" make sure the collection matches the slot collection type "	| coercedCollection |	coercedCollection := self isSlotAccess 			ifTrue: [ aCollection coastValueFor: self cellValueHolder class ]			ifFalse: [ aCollection ].	" keep a copy for replication: when  the collection is modified in the same transaction, 	the original collection must be usesd as access argument  "	collectionCopyForReplication := coercedCollection copy.	super setArgument: coercedCollection.</body></methods><methods><class-id>COAST.CatCSCollectionWriteAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	| removed added newCollection |	newCollection := self firstArgument.	self cellValueHolder isEmpty 		ifTrue: [ added := newCollection ]		ifFalse: 		[	added := self cellValueHolder valueClass new: newCollection size.			newCollection do: [: newElement | ( self cellValueHolder includes: newElement ) ifFalse: [ added add: newElement ]]		].	newCollection isEmpty 		ifTrue: [ removed := self cellValueHolder copy ]		ifFalse: 		[	removed := self cellValueHolder valueClass new: self cellValueHolder size.			self cellValueHolder do: [: oldElement | ( newCollection includes: oldElement ) ifFalse: [ removed add: oldElement ]]		].	diffs removed: removed.	diffs added: added.</body></methods><methods><class-id>COAST.CatCSCollectionWriteAccess</class-id> <category>testing</category><body package="COCellAccesses">isValidAccess	" Before writing new objects, it must be validated that they are either frame objects or	supported primitive objects, and that shared frames do not point to local frames "	| collection |	collection := self arguments singleElementOnError: [ ^ false ].	( collection isKindOf: self cellValueHolder valueClass ) ifFalse: [ ^ false ].	collection coastAllArgumentsDo: [: arg | arg isValidAccessParameter ifFalse: [ ^ false ]].	^ true</body></methods><methods><class-id>COAST.CatCSCollectionWriteAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 35</body></methods><methods><class-id>COAST.CatCSRemoveKeyAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	diffs added: Dictionary new.	diffs removed: (self removedDictAt: self firstArgument)</body></methods><methods><class-id>COAST.CatCSRemoveKeyAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder 	^ aCatCSCellValueHolder coastInternalRemoveKey: self arg1 withAccess: self</body></methods><methods><class-id>COAST.CatCSRemoveKeyAccess</class-id> <category>testing</category><body package="COCellAccesses">isValidAccess	"index must not be nil"	self firstArgument notNil ifFalse: [ ^ false ].	^ super isValidAccess</body></methods><methods><class-id>COAST.CatCSRemoveKeyAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 32</body></methods><methods><class-id>COAST.CatCSRemoveKeyAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	" Answer all access classes (as symbols) who are always commutative to this access class.	Two read accesses are always commutative, so they don't need to be explicitly listed here "	^ #( #CatCSRemoveKeyAccess #CatCSDepleteAccess )</body><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #( #CatCSAtKeyAddAccess #CatCSAtKeyIncludesAccess )</body></methods><methods><class-id>COAST.CatCSAddAfterIndexAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalAdd: self arg1 afterIndex: self arg2</body></methods><methods><class-id>COAST.CatCSAddAfterIndexAccess</class-id> <category>testing</category><body package="COCellAccesses">isValidAccess	"index must not be nil"	self secondArgument notNil ifFalse: [ ^ false ].	^ super isValidAccess</body></methods><methods><class-id>COAST.CatCSAddAfterIndexAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	^ #(#CatCSFirstAccess )</body><body package="COCellAccesses">commutativeWithEqualArgumentClasses	^ #(#CatCSAddLastAccess )</body></methods><methods><class-id>COAST.CatCSAddAfterIndexAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 10</body></methods><methods><class-id>COAST.CatCSAddFirstAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalAddFirst: self arg1</body></methods><methods><class-id>COAST.CatCSAddFirstAccess class</class-id> <category>commutatativity tables</category><body package="COCellAccesses">commutativeClasses	^ #(#CatCSAddLastAccess )</body><body package="COCellAccesses">commutativeWithDifferentArgumentClasses	^ #(#CatCSAfterAccess )</body><body package="COCellAccesses">commutativeWithEqualArgumentClasses	^ #(#CatCSAddFirstAccess )</body></methods><methods><class-id>COAST.CatCSAddFirstAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 13</body></methods><methods><class-id>COAST.CatCSRemoveAtIndexAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalRemoveAtIndex: self arg1</body></methods><methods><class-id>COAST.CatCSRemoveAtIndexAccess</class-id> <category>testing</category><body package="COCellAccesses">isValidAccess	"index must not be nil"	self firstArgument notNil ifFalse: [ ^ false ].	^ super isValidAccess</body></methods><methods><class-id>COAST.CatCSRemoveAtIndexAccess</class-id> <category>differences</category><body package="COCellAccesses">computeDifferences	"compute differences between pre- and post-access"	| arg |	arg := self firstArgument.	(arg isInteger and: [ arg &gt;= 1 and: [ self cell valueHolder size &gt;= arg ] ]) 		ifTrue: [ diffs removed: (Set with: (self cell valueHolder at: arg)) ].</body></methods><methods><class-id>COAST.CatCSRemoveAtIndexAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 37</body></methods><methods><class-id>COAST.CatCSAddAfterAccess</class-id> <category>performing</category><body package="COCellAccesses">performOn: aCatCSCellValueHolder	^ aCatCSCellValueHolder coastInternalAdd: self arg1 after: self arg2</body></methods><methods><class-id>COAST.CatCSAddAfterAccess class</class-id> <category>accessing</category><body package="COCellAccesses">id	^ 9</body></methods><methods><class-id>COAST.CatCSSingleValue</class-id> <category>remap</category><body package="COCellValueHolder">add: anObject	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">coastInternalAdd: anObject withAccess: access 	self value: anObject.	^ anObject</body><body package="COCellValueHolder">coastInternalRemove: anObject withAccess: access 	self value: nil.	^ anObject</body><body package="COCellValueHolder">includes: anObject	^ self value == anObject</body><body package="COCellValueHolder">remove: anObject	CoastError raiseSignal: 'access violation'</body></methods><methods><class-id>COAST.CatCSSingleValue</class-id> <category>accessing</category><body package="COCellValueHolder">coastTotalByteSize	" total size of the valueholder and it's values "	^ self coastObjectSize + value coastReferencedObjectSize</body><body package="COCellValueHolder">depleteWith: access 	self value: nil</body><body package="COCellValueHolder">directValuesDo: block 	block value: self value.</body><body package="COFramesystem">frame: frame at: slotname replace: oldValue with: newValue	(frame at: slotname) = oldValue		ifTrue: [ frame at: slotname set: newValue ]</body><body package="COCellValueHolder">isEmpty	^value isNil</body><body package="COCellValueHolder">remap: aCatCSCellAccessClass	^ aCatCSCellAccessClass remapForSingleValue</body><body package="COCellValueHolder">valueAsSet	^Set with: value</body><body package="COCellValueHolder">valueForReadAccess	^value</body></methods><methods><class-id>COAST.CatCSSingleValue</class-id> <category>testing</category><body package="COCellValueHolder">isSingleValue	^true</body><body package="COCellValueHolder">isValidSingleValue: newValue 	^ true</body><body package="COFramesystem">referencesSharedFrame: frame 	^ self value == frame</body></methods><methods><class-id>COAST.CatCSSingleValue</class-id> <category>garbage collect</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall	value valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall.</body><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock 	"for use of garbage-collection only!"	value isFrameOrFrameReference 		ifTrue: [ aBlock value: value ]</body></methods><methods><class-id>COAST.CatCSSingleValue</class-id> <category>copying</category><body package="COCellValueHolder">constructCopyParameters: awareness 	"before copying, ask for permission to copy (ps/00/03)"	^ OrderedCollection with: ( CatCSValueWriteAccess argument: ( self value coastCopyWith: awareness ))</body></methods><methods><class-id>COAST.CatCSSingleValue</class-id> <category>adapting</category><body package="COCellValueHolder">coastAllArgumentsDo: aBlock 	aBlock value: value.</body></methods><methods><class-id>COAST.CatCSSingleValue</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 1</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	aCatRMMarshall marshallValue: value to: aStream.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	self value: ( aCatRMMarshall unmarshallValueFrom: aStream morph: morphSelector ).</body></methods><methods><class-id>COAST.CatCSSingleValue class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#singleValue</body></methods><methods><class-id>COAST.CatCSSingleValue class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^1</body></methods><methods><class-id>COAST.CompactTransformation</class-id> <category>transforming</category><body package="COCellValueHolder">addAddsTo: compactCollection 	previous notNil ifTrue: [ previous addAddsTo: compactCollection ].</body><body package="COCellValueHolder">performMovesFrom: original to: copy 	previous notNil ifTrue: [ previous performMovesFrom: original to: copy ].</body></methods><methods><class-id>COAST.CompactTransformation</class-id> <category>accessing</category><body package="COCellValueHolder">previous	^ previous</body><body package="COCellValueHolder">previous: aPrevious 	previous := aPrevious.</body></methods><methods><class-id>COAST.CompactTransformation</class-id> <category>printing</category><body package="COCellValueHolder">printOn: stream 	previous notNil ifTrue: 		[	previous printOn: stream.			stream cr.		].</body></methods><methods><class-id>COAST.SmallIntegerArray</class-id> <category>accessing</category><body package="COCellValueHolder">at: index	"Answer the value of an indexable field in the receiver.  Fail if the  	argument index is not a SmallInteger, or is out of bounds."	^self signedLongAt: (index bitShift: 2) - 3</body><body package="COCellValueHolder">at: index put: smallInt	"Store the argument value in the indexable field of the receiver	indicated by index. Fail if the index is not a SmallInteger or	is out of bounds. Answer the value that was stored."	^self signedLongAt: (index bitShift: 2)-3 put: smallInt</body><body package="COCellValueHolder">coastOptimizedReplaceFrom: start to: stop with: replacement startingAt: repStart 	replacement class == self class 		ifTrue: 		[	self coastPrimReplaceFrom: ( start bitShift: 2 ) - 3				to: ( stop bitShift: 2 )				withDwordArray: replacement				startingAt: ( repStart bitShift: 2 ) - 3		]		ifFalse: [ super coastOptimizedReplaceFrom: start to: stop with: replacement startingAt: repStart ].</body><body package="COCellValueHolder">coastPrimReplaceFrom: start to: stop withDwordArray: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the 	receiver starting at index, repStart, in the collection, replacement. 	Answer the receiver."	"primitive to optimize #coastOptimizedReplaceFrom:to:with:startingAt:"	"this is actual the primitive of ByteArray - you must be very aware of what you do when you send it!!!"	&lt;primitive: 559&gt;</body><body package="COCellValueHolder">size	"Override this message to access 32-bit integers."	^super size bitShift: -2</body></methods><methods><class-id>COAST.SmallIntegerArray</class-id> <category>private</category><body package="COCellValueHolder">byteAt: index 	"Answer the byte at the given index."	^ self basicAt: index</body><body package="COCellValueHolder">byteAt: index put: aByte 	"Store a byte at the given index."	^ self basicAt: index put: aByte</body><body package="COCellValueHolder">signedLongAt: byteIndex	"Answer an signed integer (32 bit) quantity	starting at the given byteIndex."	&lt;primitive: 546&gt;	^self signedLongAt: byteIndex bigEndian: UninterpretedBytes isBigEndian</body><body package="COCellValueHolder">signedLongAt: byteIndex bigEndian: isBE 	"Answer a signed integer (32 bit) quantity starting at the given byteIndex."	| b0 b1 b2 w h |	isBE 		ifTrue: 		[	b0 := self byteAt: byteIndex.			b1 := self byteAt: byteIndex + 1.			b2 := self byteAt: byteIndex + 2.			w := self byteAt: byteIndex + 3		]		ifFalse: 		[	b0 := self byteAt: byteIndex + 3.			b1 := self byteAt: byteIndex + 2.			b2 := self byteAt: byteIndex + 1.			w := self byteAt: byteIndex		].	"Following sequence minimizes LargeInteger arithmetic for small results."	h := (( b0 bitAnd: 16r7F ) - ( b0 bitAnd: 16r80 ) bitShift: 8 ) + b1.	b2 = 0 ifFalse: [ w := ( b2 bitShift: 8 ) + w ].	h = 0 ifFalse: [ w := ( h bitShift: 16 ) + w ].	^ w</body><body package="COCellValueHolder">signedLongAt: byteIndex put: smallInt	"Store an signed integer (32 bit) quantity	starting at the given byteIndex."	&lt;primitive: 547&gt;	^self signedLongAt: byteIndex put: smallInt bigEndian: UninterpretedBytes isBigEndian</body><body package="COCellValueHolder">signedLongAt: byteIndex put: smallInt bigEndian: isBE 	"Store an signed integer (32 bit) quantity starting at the given byteIndex."	| b0 b1 b2 b3 |	b0 := smallInt bitShift: -24.	b0 := ( b0 bitAnd: 16r7F ) - ( b0 bitAnd: -16r80 ).	b1 := ( smallInt bitShift: -16 ) bitAnd: 16rFF.	b2 := ( smallInt bitShift: -8 ) bitAnd: 16rFF.	b3 := smallInt bitAnd: 16rFF.	isBE 		ifTrue: 		[	"Only the first store can fail."			self byteAt: byteIndex put: b0.			self byteAt: byteIndex + 1 put: b1.			self byteAt: byteIndex + 2 put: b2.			self byteAt: byteIndex + 3 put: b3		]		ifFalse: 		[	"Only the first store can fail."			self byteAt: byteIndex + 3 put: b0.			self byteAt: byteIndex + 2 put: b1.			self byteAt: byteIndex + 1 put: b2.			self byteAt: byteIndex put: b3		].	^ smallInt</body></methods><methods><class-id>COAST.SmallIntegerArray</class-id> <category>binary storage</category><body package="COCellValueHolder">postReadGeneralStructureOn: aBinaryStorageReader 	"just copied from DWordArray - not really needed"	aBinaryStorageReader stream swap ifTrue: [ self reverseByteOrder ].</body></methods><methods><class-id>COAST.SmallIntegerArray</class-id> <category>external copying</category><body package="COCellValueHolder">copyToHeap: mallocSelector 	"just copied from DWordArray - not really needed"	"Copy the receiver to the external heap.  The argument is a method selector that accepts one argument and determines how to allocate data for the receiver -- it is typically one of #malloc: or #malloc16:.  The selector's argument is the number of objects of the receiver's baseCType to allocate.  Answer a pointer to the data.  If the allocation fails a primitive failed signal is raised."	| aPointer size |	size := self basicSize.	aPointer := self baseCType referentType perform: mallocSelector with: size.	aPointer copyAt: 0 from: self size: size startingAt: 1.	^ aPointer</body></methods><methods><class-id>COAST.SmallIntegerArray</class-id> <category>converting</category><body package="COCellValueHolder">reverseByteOrder	"Swap byte order when booting up on a different-endian	machine than the image was saved on."	1 to: self basicSize - 1		by: 4		do: 		[: i | | t |			t := self basicAt: i.			self basicAt: i put: ( self basicAt: i + 3 ).			self basicAt: i + 3 put: t.			t := self basicAt: i + 1.			self basicAt: i + 1 put: ( self basicAt: i + 2 ).			self basicAt: i + 2 put: t		].</body></methods><methods><class-id>COAST.SmallIntegerArray class</class-id> <category>external accessing</category><body package="COCellValueHolder">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery."	^ CIntegerType int pointerType</body></methods><methods><class-id>COAST.SmallIntegerArray class</class-id> <category>class initialization</category><body package="COCellValueHolder">initialize 	UninterpretedBytes register: self.</body><body package="COCellValueHolder">obsolete 	UninterpretedBytes deregister: self.	super obsolete.</body></methods><methods><class-id>COAST.SmallIntegerArray class</class-id> <category>instance creation</category><body package="COCellValueHolder">new: size	^self basicNew: size * 4</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>private</category><body package="COCellValueHolder">addElement: aElementToAdd 	( self removedElementsIncludes: aElementToAdd ) 		ifTrue: [ self removedFramesRemove: aElementToAdd ]		ifFalse: [ self addedFramesAdd: aElementToAdd ]</body><body package="COCellValueHolder">addedFramesAdd: frameReference 	addedFrames isNil ifTrue: [ self initializeAddedFrames ].	addedFrames add: frameReference</body><body package="COCellValueHolder">addedFramesIncludes: frameReference 	^ addedFrames notNil and: [ addedFrames includes: frameReference ]</body><body package="COCellValueHolder">addedFramesOccurrencesOf: frameReference 	^ addedFrames notNil 		ifTrue: [ addedFrames occurrencesOf: frameReference ]		ifFalse: [ 0 ]</body><body package="COCellValueHolder">addedFramesRemove: frameReference ifAbsent: block 	^( self addedFramesIncludes: frameReference ) 		ifTrue: [ addedFrames remove: frameReference ]		ifFalse: [ block value ]</body><body package="COCellValueHolder">addedFramesSize	^addedFrames isNil ifTrue: [ 0 ] ifFalse: [ addedFrames size ]</body><body package="COCellValueHolder">at: index putLocator: aFrameLocator classIndex: classIndex	clusterIDs at: index put: aFrameLocator clusterID.	frameIDs at: index put: aFrameLocator frameID.	classIndices at: index put: classIndex.</body><body package="COCellValueHolder">atIndex: index put: elem 	self at: index putLocator: elem classIndex: ( self classIndexFor: elem )</body><body package="COCellValueHolder">basicAppendAll: otherCompactCollections 	"these collections must be conforming (my last entry &lt; other first entry)"	| subCollections |	subCollections := otherCompactCollections collect: [: anotherCompactCollection | anotherCompactCollection frameIDs ].	frameIDs := frameIDs coastOptimizedAppendAll: subCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | anotherCompactCollection clusterIDs ].	clusterIDs := clusterIDs coastOptimizedAppendAll: subCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | self patchedClassIndicesOf: anotherCompactCollection ].	classIndices := classIndices coastOptimizedAppendAll: subCollections.</body><body package="COCellValueHolder">basicClassIndexFor: classOrFrameReference 	"frameClassArray contains symbols and/or classes"	| frameKey otherFrameSymbol |	frameKey := classOrFrameReference frameKey.	frameClassArray keysAndValuesDo: [: index : classOrSymbol | classOrSymbol == frameKey ifTrue: [ ^ index ]].	otherFrameSymbol := classOrFrameReference frameClassSymbol.	frameClassArray keysAndValuesDo: [: index : classOrSymbol | classOrSymbol frameClassSymbol = otherFrameSymbol ifTrue: [ ^ index ]].	frameClassArray := frameClassArray copyWith: frameKey.	^ frameClassArray size</body><body package="COCellValueHolder">basicFrameRefAtIndex: index 	^ CatFSFrameReference clusterID: ( clusterIDs at: index )		id: ( frameIDs at: index )		classSymbol: ( self classAtIndex: index )</body><body package="COCellValueHolder">basicFrameRefAtIndex: index into: frameReference 	frameReference clusterID: ( clusterIDs at: index ).	frameReference id: ( frameIDs at: index ).	frameReference frameClassSymbol: ( self classAtIndex: index ).</body><body package="COCellValueHolder">basicGrowBy: anInteger 	clusterIDs := clusterIDs coastOptimizedGrownBy: anInteger.	frameIDs := frameIDs coastOptimizedGrownBy: anInteger.	classIndices := classIndices coastOptimizedGrownBy: anInteger.</body><body package="COCellValueHolder">binarySearchMinClusterID: cidSearch frameID: fidSearch ifAbsent: absentBlock 	"search the smallest index X where (( frameIDs at: X ) = fidSearch and: [( clusterIDs at: X ) = cidSearch ]) or nil"	"send absentBlock the potential index"	^ self binarySearchMinClusterID: cidSearch frameID: fidSearch min: 1 max: clusterIDs size ifAbsent: absentBlock</body><body package="COCellValueHolder">binarySearchMinClusterID: cidSearch frameID: fidSearch min: min max: max ifAbsent: absentBlock 	"search the smallest index X where (( frameIDs at: X ) = fidSearch and: [( clusterIDs at: X ) = cidSearch ]) or nil"	"send absentBlock the potential index"	| minIndex maxIndex |	minIndex := min.	maxIndex := max.	maxIndex == 0 ifTrue: [ ^ absentBlock value: 1	"empty collection" ].	"1 &lt;= minIndex &lt;= maxIndex &lt;= clusterIDs size"	[ minIndex &lt; maxIndex ] whileTrue: 		[ "search in interval [ minIndex .. maxIndex ]"			| midIndex cidFound |			midIndex := minIndex + maxIndex bitShift: -1.	"minIndex &lt;= index &lt; maxIndex"			cidFound := clusterIDs at: midIndex.			cidFound = cidSearch 				ifTrue: 				[ "compare frameID"					| fidFound |					fidFound := frameIDs at: midIndex.					fidFound &lt; fidSearch 						ifTrue: [ minIndex := midIndex + 1	"search behind index" ]						ifFalse: [ maxIndex := midIndex	"search at or before index" ]				]				ifFalse: 				[	"compare clusterID"					cidFound &lt; cidSearch 						ifTrue: [ minIndex := midIndex + 1	"search behind index" ]						ifFalse: [ maxIndex := midIndex - 1	"search before index" ]				]		].	^ ( clusterIDs at: minIndex ) = cidSearch 		ifTrue: 		[( frameIDs at: minIndex ) = fidSearch 				ifTrue: [ minIndex ]				ifFalse: 				[( frameIDs at: minIndex ) &gt; fidSearch 						ifTrue: [ absentBlock value: minIndex	"the min index would be here (e.g. search 2 in #(3) )" ]						ifFalse: [ absentBlock value: minIndex + 1	"the min index would be behind (e.g. search 2 in #(1) )" ]				]		]		ifFalse: 		[( clusterIDs at: minIndex ) &gt; cidSearch 				ifTrue: [ absentBlock value: minIndex	"the min index would be here (e.g. search 2 in #(3) )" ]				ifFalse: [ absentBlock value: minIndex + 1	"the min index would be behind (e.g. search 2 in #(1) )" ]		]</body><body package="COCellValueHolder">classAtIndex: index 	| classIndex |	classIndex := classIndices at: index.	^ frameClassArray at: classIndex</body><body package="COCellValueHolder">classIndexFor: frameReference 	^ self basicClassIndexFor: frameReference</body><body package="COCellValueHolder">classIndices	^ classIndices</body><body package="COCellValueHolder">clusterIDs	^ clusterIDs</body><body package="COCellValueHolder">clusterIDs: cids frameIDs: fids classIndices: cix frameClassArray: fca 	clusterIDs := cids.	frameIDs := fids.	classIndices := cix.	frameClassArray := fca</body><body package="COCellValueHolder">compactElementAtIndex: index 	| result |	result := self defaultCursor.	self compactElementAtIndex: index into: result.	^ result</body><body package="COCellValueHolder">compactElementAtIndex: index into: elem 	self basicFrameRefAtIndex: index into: elem.</body><body package="COFramesystem">cropToSize: size 	self cropFrom: 1 to: size.</body><body package="COCellValueHolder">emptyCopyForCompact	^ ( self species new: clusterIDs size + addedFrames size - removedFrames size )		clusterManager: clusterManager;		yourself</body><body package="COCellValueHolder">frameClassArray	^ frameClassArray</body><body package="COCellValueHolder">frameIDs	^ frameIDs</body><body package="COCellValueHolder">includesFrameReference: frameReference 	( self addedFramesIncludes: frameReference ) ifTrue: [ ^ true ].	( self removedFramesIncludes: frameReference ) ifTrue: [ ^ false ].	self validIndexOfReference: frameReference ifAbsent: [: indexNotFound | ^ false ].	^ true</body><body package="COCellValueHolder">initializeAddedFrames	self subclassResponsibility</body><body package="COCellValueHolder">initializeArraysSized: anInteger 	clusterIDs := DwordArray new: anInteger.	frameIDs := SmallIntegerArray new: anInteger.	classIndices := ByteArray new: anInteger.	frameClassArray := Array new</body><body package="COCellValueHolder">initializeRemovedFrames	self subclassResponsibility</body><body package="COCellValueHolder">isCompact	^ addedFrames isNil and: [ removedFrames isNil ]</body><body package="COFramesystem">lastAdd	^ addedFrames isNil 		ifTrue: [ nil ]		ifFalse: 		[ | sortedAdds |			sortedAdds := self sortedAdds.			sortedAdds isEmpty 				ifTrue: [ nil ]				ifFalse: [ sortedAdds last ]		]</body><body package="COFramesystem">lastElement	self subclassResponsibility</body><body package="COFramesystem">lastReferenceElement	| lastAdd |	lastAdd := self lastAdd.	clusterIDs size to: 1		by: -1		do: 		[: index | | element |			element := self compactElementAtIndex: index.			( self removedElementsIncludes: element ) ifFalse: 				[( lastAdd notNil and: [ element coastLessThan: lastAdd ]) ifTrue: [ ^ lastAdd ].					^ element				]		].	^ lastAdd</body><body package="COFramesystem">limitToSize: sizeOrNil 	( sizeOrNil notNil and: [ sizeOrNil &lt; self size ]) ifTrue: [ self cropToSize: sizeOrNil ].</body><body package="COFramesystem">markAsEndcellPrototypeValue	"clusterManager  is written when reading the Collection	testing a prototype-slot should NOT write the value	the clusterManager '#prototype' does not harm 		- clusterManager is needed to resolve collection elements and prototypes are empty"	clusterManager := #prototype.	super markAsEndcellPrototypeValue.</body><body package="COCellValueHolder">patchedClassIndicesOf: anotherCompactCollection 	"check if i and anotherCompactCollection agree about the class indices"	"extend my frameClassIndex, if needed"	"patch the classIndices only if needed (there is a class with my index ~= others index)"	| patchTable |	patchTable := anotherCompactCollection frameClassArray collect: [: class | self basicClassIndexFor: class ].	patchTable keysAndValuesDo: [: k : v | k ~= v ifTrue: [ ^ anotherCompactCollection classIndices collect: [: i | patchTable at: i ]]].	^ anotherCompactCollection classIndices</body><body package="COCellValueHolder">postRPCInitializeWith: delegatingProxy 	"due pending updates rpc results might contain frames of local loaded clusters"	"which are not yet known to this client - these must be hidden"	| result |	self clusterManager: delegatingProxy clusterManager.	result := self copy.	1 to: clusterIDs size		do: 		[: index | | element |			element := self compactElementAtIndex: index.			( element isValidRPCResultWith: clusterManager ) ifFalse: 				[	COAST.CoastLog logWarning: 'RPC result contains unknown frame'.	"this can happen, when updates are pending"					self removeRPCResult: element				]		].	^ result</body><body package="COCellValueHolder">referencesElementsCursorDo: aBlock 	| sortedAdds cursor |	cursor := self defaultCursor.	self isCompact ifTrue: 		[	1 to: clusterIDs size				do: 				[: index |					self compactElementAtIndex: index into: cursor.					aBlock value: cursor				].			^ self		].	sortedAdds := self sortedAdds.	1 to: clusterIDs size		do: 		[: index |			self compactElementAtIndex: index into: cursor.			( self removedElementsIncludes: cursor ) ifFalse: 				[						[ sortedAdds isEmpty or: [ cursor coastLessThan: sortedAdds first ]] whileFalse: [ aBlock value: sortedAdds removeFirst ].					aBlock value: cursor				]		].	[ sortedAdds isEmpty ] whileFalse: [ aBlock value: sortedAdds removeFirst ].</body><body package="COCellValueHolder">removeFrameReference: frameReference ifAbsent: block 	( self includes: frameReference ) 		ifTrue: [ self addedFramesRemove: frameReference ifAbsent: [ self removedFramesAdd: frameReference ]]		ifFalse: [ block value ]</body><body package="COCellValueHolder">removeRPCResult: element 	self subclassResponsibility.</body><body package="COCellValueHolder">removedElementsIncludes: elem 	^ self removedFramesIncludes: elem</body><body package="COCellValueHolder">removedFramesAdd: aFrameOrFrameReference 	removedFrames isNil ifTrue: [ self initializeRemovedFrames ].	removedFrames add: aFrameOrFrameReference asCompactArgument.</body><body package="COCellValueHolder">removedFramesIncludes: frame 	^ removedFrames notNil and: [ removedFrames includes: frame asCompactArgument ]</body><body package="COCellValueHolder">removedFramesOccurrencesOf: frameReference 	^ removedFrames notNil 		ifTrue: [ removedFrames occurrencesOf: frameReference ]		ifFalse: [ 0 ]</body><body package="COCellValueHolder">removedFramesRemove: frameReference 	^ removedFrames remove: frameReference</body><body package="COCellValueHolder">removedFramesSize	^removedFrames isNil ifTrue: [ 0 ] ifFalse: [ removedFrames size ]</body><body package="COCellValueHolder">sortedAdds	^ addedFrames isNil 		ifTrue: [ #( )]		ifFalse: [ addedFrames asSortedCollection: [: a : b | a &lt; b ]]</body><body package="COCellValueHolder">validIndexOfReference: frameReference ifAbsent: absentBlock 	^ self binarySearchMinClusterID: frameReference clusterID frameID: frameReference frameID ifAbsent: absentBlock</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>single element</category><body package="COCellValueHolder">defaultMoreBlock	^ [ self error: 'this collection should contain a single object' ]</body><body package="COCellValueHolder">defaultNoneBlock	^ [ self error: 'this collection is empty' ]</body><body package="COCellValueHolder">singleElement	^ self singleElementIfNone: self defaultNoneBlock ifMore: self defaultMoreBlock</body><body package="COCellValueHolder">singleElementIfMore: moreBlock 	^ self singleElementIfNone: self defaultNoneBlock ifMore: moreBlock</body><body package="COCellValueHolder">singleElementIfNone: noneBlock 	^ self singleElementIfNone: noneBlock ifMore: self defaultMoreBlock</body><body package="COCellValueHolder">singleElementIfNone: noneBlock ifMore: moreBlock 	self isEmpty ifTrue: [ ^ noneBlock value ].	self size &gt; 1 ifTrue: 		[	^ moreBlock numArgs = 0 				ifTrue: [ moreBlock value ]				ifFalse: [ moreBlock value: self ]		].	^ self detect: [: x | true ]</body><body package="COCellValueHolder">singleElementOnError: aBlock 	^ self singleElementIfNone: aBlock ifMore: aBlock</body><body package="COCellValueHolder">singleElementOrNil	^ self singleElementOnError: [ nil ]</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>accessing</category><body package="COCellValueHolder">add: frame 	self clusterManagerFrom: frame.	self addElement: frame asCompactArgument.	^ frame</body><body package="COCellValueHolder">anyElement	self do: [: e | ^ e ].	^ nil</body><body package="COCellValueHolder">clusterManager	^ clusterManager</body><body package="COCellValueHolder">clusterManager: newClusterManager 	( clusterManager = #prototype and: [ newClusterManager isNil ]) ifTrue: 		[	"cleanUp"			self beMutable		].	clusterManager := newClusterManager.</body><body package="COTransactions">clusterManagerForBlockCache	^self clusterManager</body><body package="COCellValueHolder">clusterManagerFrom: aFrame 	aFrame isFrameOrFrameReference 		ifFalse: [ CoastError raiseSignal: 'Only frames can be stored in CompactFrameCollections!' ].	aFrame isLocal ifTrue: [ CoastError raiseSignal: 'Local frames can not be stored in CompactFrameCollections!' ].	clusterManager isNil ifTrue: [ aFrame setCompactCollectionClusterManagerFor: self ]</body><body package="COCellValueHolder">coastCompactElementCount	^ clusterIDs size + self addedFramesSize - self removedFramesSize</body><body package="COCellValueHolder">coastDepletedValue	^ ( self class new )		clusterManager: clusterManager;		yourself</body><body package="COCellValueHolder">coastIncludesCompactKey: key 	^ self includesFrameReference: key</body><body package="COCellValueHolder">coastTotalByteSize	^ super coastTotalByteSize 		+ addedFrames coastTotalByteSize 		+ removedFrames coastTotalByteSize 		+ frameIDs coastTotalByteSize 		+ clusterIDs coastTotalByteSize 		+ classIndices coastTotalByteSize 		+ frameClassArray coastTotalByteSize</body><body package="COCellValueHolder">copyForRollback	^ self copy</body><body package="COCellValueHolder">defaultCursor	^ CatFSFrameReference new</body><body package="COCellValueHolder">includes: aFrame 	| frameReference |	frameReference := aFrame asValidFrameReferenceOrNil.	^ frameReference notNil and: [ self includesFrameReference: frameReference ]</body><body package="COFramesystem">journalIncludesReferencedElement: refElement 	self subclassResponsibility.</body><body package="COCellValueHolder">occurrencesOf: frame 	| frameReference occurrences index max |	frameReference := frame asValidFrameReferenceOrNil.	frameReference isNil ifTrue: [ ^ 0 ].	occurrences := ( self addedFramesOccurrencesOf: frameReference ) - ( self removedFramesOccurrencesOf: frameReference ).	index := self validIndexOfReference: frameReference ifAbsent: [: indexNotFound | ^ occurrences ].	max := clusterIDs size.	[	index := index + 1.		occurrences := occurrences + 1.		index &gt; max ifTrue: [ ^ occurrences ].		( frameIDs at: index ) ~~ frameReference frameID ifTrue: [ ^ occurrences ].		( clusterIDs at: index ) ~~ frameReference clusterID ifTrue: [ ^ occurrences ]	] repeat</body><body package="COCellValueHolder">remove: aFrame 	^ self remove: aFrame ifAbsent: [ ]</body><body package="COCellValueHolder">remove: aFrame ifAbsent: absentBlock 	| frameReference |	frameReference := aFrame asValidFrameReferenceOrNil.	frameReference isNil ifTrue: [ ^ absentBlock value ].	self removeFrameReference: frameReference ifAbsent: [ ^ absentBlock value ].	^ aFrame</body><body package="COCellValueHolder">simpleClass	^ self subclassResponsibility</body><body package="COCellValueHolder">size	^ self coastCompactElementCount</body><body package="COMarshalling">translatedArgumentForCluster: aCatCSCluster 	^ self copy compact</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>converting</category><body package="COCellValueHolder">asArray	^ Array withAll: self</body><body package="COCellValueHolder">asList	^ List withAll: self</body><body package="COCellValueHolder">asOrderedCollection	^ OrderedCollection withAll: self</body><body package="COCellValueHolder">asRPCArguments	^ self</body><body package="COCellValueHolder">asSet	^ Set withAll: self</body><body package="COCellValueHolder">asSortedCollection	^ SortedCollection withAll: self</body><body package="COCellValueHolder">asSortedCollection: aBlock 	^ ( SortedCollection sortBlock: aBlock )		addAll: self;		yourself</body><body package="COCellValueHolder">coastAsSet	^ self asSet</body><body package="COCellValueHolder">coastAsSetOrYourself	^ self coastAsSet</body><body package="COCellValueHolder">collectAsArray: aBlock 	| array i |	array := Array new: self size.	i := 1.	self do: 		[: element |			array at: i put: ( aBlock value: element ).			i := i + 1		].	^ array</body><body package="COCellValueHolder">sortedBy: aBlock 	| associations sortedAssociations |	associations := self collectAsArray: [: x | ( aBlock value: x ) -&gt; x ].	sortedAssociations := associations asSortedCollection: [: x : y | x key &lt;= y key ].	^ sortedAssociations asOrderedCollection collect: [: assoc | assoc value ]</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>iterating</category><body package="COCellValueHolder">allSatisfy: block 	^( self contains: [: e | ( block value: e ) not ]) not</body><body package="COCellValueHolder">anySatisfy: block 	self do: [:each| (block value: each) ifTrue: [^true]].	^false</body><body package="COCellValueHolder">coastAllArgumentsDo: aBlock 	self do: [: v | aBlock value: v ].</body><body package="COCellValueHolder">collect: aBlock 	| result |	result := self simpleClass new.	self do: [: e | result add: ( aBlock value: e )].	^ result</body><body package="COCellValueHolder">contains: detectBlock 	self 		detect: detectBlock		ifNone: [ ^ false ].	^ true</body><body package="COCellValueHolder">detect: aBlock 	^ self 		detect: aBlock		ifNone: [ Collection notFoundSignal raise ]</body><body package="COCellValueHolder">detect: detectBlock ifNone: absentBlock 	self do: [: e | ( detectBlock value: e ) ifTrue: [ ^ e ]].	^ absentBlock value</body><body package="COCellValueHolder">do: aBlock 	^ self referencesElementsCursorDo: 		[: frameReference | | frameOrNil |			frameOrNil := clusterManager resolveFrameReferenceCursor: frameReference.			frameOrNil notNil ifTrue: [ aBlock value: frameOrNil ]		]</body><body package="COCellValueHolder">do: elementBlock separatedBy: separatorBlock 	| first |	first := true.	self do: 		[: elmnt |			first 				ifTrue: [ first := false ]				ifFalse: [ separatorBlock value ].			elementBlock value: elmnt		]</body><body package="COCellValueHolder">inject: thisValue into: binaryBlock 	| nextValue |	nextValue := thisValue.	self do: [: each | nextValue := binaryBlock value: nextValue value: each ].	^ nextValue</body><body package="COCellValueHolder">reject: aBlock 	^ self select: [: e | ( aBlock value: e ) not ]</body><body package="COCellValueHolder">select: aBlock 	| copy |	self compact.	copy := self copy.	self do: [: e | ( aBlock value: e ) ifFalse: [ copy remove: e ]].	^ copy</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>testing</category><body package="COCellValueHolder">isEmpty	^ self size isZero</body><body package="COCellValueHolder">notEmpty	^ self isEmpty not</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>removal</category><body package="COCellValueHolder">coastSubstract: aSet 	^ self reject: [: e | aSet includes: e ]</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>compact</category><body package="COCellValueHolder">addAddsForCompactTo: collection 	addedFrames isNil ifFalse: 		[	addedFrames do: 				[: a | | pos |					pos := self validIndexOfReference: a ifAbsent: [: indexNotFound | indexNotFound ].					collection add: ( Array with: #add with: a with: pos with: a )				]		].</body><body package="COCellValueHolder">addRemovesForCompactTo: collection 	removedFrames isNil ifFalse: 		[	removedFrames do: 				[: a | | pos |					pos := self validIndexOfReference: a ifAbsent: [: indexNotFound | indexNotFound ].					collection add: ( Array with: #remove with: a with: pos with: a )				]		].</body><body package="COCellValueHolder">compact	| move sortedAddsAndRemoves copy |	self isCompact ifTrue: [ ^ self ].	self isImmutable ifTrue: 		[	"compact does not modify the contents"			^ self				beMutable;				compact;				beImmutable;				yourself		].	copy := self emptyCopyForCompact.	sortedAddsAndRemoves := self sortedAddsAndRemoves.	( clusterIDs size = 0 and: [ removedFrames isNil ]) 		ifTrue: [ sortedAddsAndRemoves keysAndValuesDo: [: index : typeKeyPosElem | copy atIndex: index put: ( typeKeyPosElem at: 4 )]]		ifFalse: 		[	"build moves and adds chain"			move := CompactMove size: clusterIDs size.			sortedAddsAndRemoves do: 				[: typeKeyPosElem | | elem pos |					elem := typeKeyPosElem at: 4.					pos := typeKeyPosElem at: 3.					( typeKeyPosElem at: 1 ) = #add 						ifTrue: [ move add: elem at: pos ]						ifFalse: [ move remove: elem at: pos ]				].			copy transformWith: move from: self		].	self become: copy.	^ self</body><body package="COCellValueHolder">sortedAddsAndRemoves	| sortedAddsAndRemoves |	sortedAddsAndRemoves := OrderedCollection new: addedFrames size + removedFrames size.	self addAddsForCompactTo: sortedAddsAndRemoves.	self addRemovesForCompactTo: sortedAddsAndRemoves.	sortedAddsAndRemoves := sortedAddsAndRemoves asSortedCollection: 			[: a : b | | cmp |				cmp := ( a at: 2 ) coastCompareTo: ( b at: 2 ).				cmp = 0 					ifTrue: [( a at: 1 ) = #add ]					ifFalse: [ cmp &lt; 0 ]			].	^ sortedAddsAndRemoves</body><body package="COCellValueHolder">transformWith: transformation from: original 	frameClassArray := original frameClassArray.	clusterIDs transformWith: transformation from: original clusterIDs.	frameIDs transformWith: transformation from: original frameIDs.	classIndices transformWith: transformation from: original classIndices.	transformation addAddsTo: self.</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>copying</category><body package="COCellValueHolder">copyFrom: start to: stop 	| copy |	self compact.	copy := self copy.	copy cropFrom: start to: stop.	^ copy</body><body package="COCellValueHolder">cropFrom: start to: stop 	self compact.	clusterIDs := clusterIDs copyFrom: start to: stop.	frameIDs := frameIDs copyFrom: start to: stop.	classIndices := classIndices copyFrom: start to: stop.</body><body package="COCellValueHolder">postCopy	" only copy the instVars that are modified during a transaction. 	(note that compact creates a new compact collection) "	addedFrames := addedFrames copy.	removedFrames := removedFrames copy.	^ super postCopy</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>system primitives</category><body package="COCellValueHolder">isImmutable: aBoolean 	"frameIDs etc are not supposed to be modified"	super isImmutable: aBoolean.	addedFrames isImmutable: aBoolean.	removedFrames isImmutable: aBoolean.</body></methods><methods><class-id>COAST.CompactCollection</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryFrameClassesTo: aStream marshaller: aCatRMMarshall 	| frameClassArraySize |	frameClassArraySize := frameClassArray size.	( classIndices isEmpty or: [ frameClassArraySize &gt; 1 ]) 		ifTrue: [ classIndices do: [: fc | aStream nextPut: fc ]]		ifFalse: [ aStream nextPut: 0	"optimize one class collections" ].	aStream nextOptimized32Put: frameClassArraySize.	frameClassArray do: [: aSymbolOrClass | aCatRMMarshall writeFrameClassSymbol: aSymbolOrClass to: aStream ]</body><body package="COMarshalling">marshallBinaryValueTo: aStream marshaller: aCatRMMarshall 	"optimize one class collections"	self compact.	aStream nextOptimized32Put: clusterIDs size.	aCatRMMarshall optimized32Marshall: clusterIDs to: aStream.	frameIDs do: [: fid | aStream nextOptimized32Put: fid ].	self marshallBinaryFrameClassesTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">unmarshallBinaryFrameClassesFrom: aStream marshaller: aCatRMMarshall 	| frameClassCount elementsCount |	elementsCount := classIndices size.	( classIndices isEmpty or: [ aStream peek &gt; 0 ]) 		ifTrue: [ 1 to: elementsCount do: [: index | classIndices at: index put: aStream next ]]		ifFalse: 		[	aStream next.	"optimized for one class collections"			1 to: elementsCount do: [: index | classIndices at: index put: 1 ]		].	frameClassArray := Array new: ( frameClassCount := aStream nextOptimized32 ).	1 to: frameClassCount		do: [: index | frameClassArray at: index put: ( aCatRMMarshall readFrameKeyFrom: aStream )]</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	| elementsCount |	clusterManager := aCatRMMarshall clusterManager.	self initializeArraysSized: ( elementsCount := aStream nextOptimized32 ).	aCatRMMarshall optimized32Unmarshall: clusterIDs from: aStream.	1 to: elementsCount do: [: index | frameIDs at: index put: aStream nextOptimized32 ].	self unmarshallBinaryFrameClassesFrom: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CompactCollection class</class-id> <category>instance creation private</category><body package="COCellValueHolder">new: size 	"for internal use only"	^ ( self basicNew )		initializeArraysSized: size;		yourself</body></methods><methods><class-id>COAST.CompactCollection class</class-id> <category>instance creation</category><body package="COCellValueHolder">clusterIDs: cids frameIDs: fids classIndices: cix frameClassArray: fca 	^ self basicNew 		clusterIDs: cids		frameIDs: fids		classIndices: cix		frameClassArray: fca</body><body package="COCellValueHolder">clusterManager: clusterManager 	^ self new clusterManager: clusterManager</body><body package="COCellValueHolder">new	^ self new: 0</body><body package="COCellValueHolder">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	^ self new unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector;		yourself</body><body package="COCellValueHolder">withAll: collection 	| newInst |	newInst := self new.	collection do: [: e | newInst add: e ].	newInst compact.	^ newInst</body></methods><methods><class-id>COAST.CompactCollection class</class-id> <category>constants</category><body package="COFramesystem">manyKeysThreshold	^ 1000</body></methods><methods><class-id>COAST.CatCSAbstractCollection</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">* aSet 	aSet select: [: e | self includes: e ]</body><body package="COCellValueHolder">- aSet 	self reject: [: e | aSet includes: e ]</body><body package="COCellValueHolder">allSatisfy: aBlock 	self do: [: e | ( aBlock value: e ) ifFalse: [ ^ false ]].	^ true</body><body package="COCellValueHolder">anyElement	self do: [: e | ^ e ].	^ nil</body><body package="COCellValueHolder">anySatisfy: aBlock 	^ self contains: aBlock</body><body package="COCellValueHolder">asArray	^ self collectAsArray: [: e | e ]</body><body package="COCellValueHolder">asList	^ self collect: [: e | e ] as: List</body><body package="COCellValueHolder">asOrderedCollection	^ self collectAsOrderedCollection: [: e | e ]</body><body package="COCellValueHolder">asRPCArguments	self subclassResponsibility.</body><body package="COCellValueHolder">asSet	^ self collect: [: e | e ] as: List</body><body package="COCellValueHolder">asSortedCollection	^ self collect: [: e | e ] as: SortedCollection</body><body package="COCellValueHolder">asSortedCollection: sortBlock 	| result |	result := SortedCollection sortBlock: sortBlock.	self do: [: elem | result add: elem ].	^ result</body><body package="COCellValueHolder">collect: aBlock 	^ self collect: [: e | e ] as: self valueClass</body><body package="COCellValueHolder">collectAsArray: aBlock 	^ self collect: aBlock as: Array</body><body package="COCellValueHolder">collectAsOrderedCollection: aBlock 	^ self collect: aBlock as: OrderedCollection</body><body package="COCellValueHolder">contains: aBlock 	self do: [: e | ( aBlock value: e ) ifTrue: [ ^ true ]].	^ false</body><body package="COCellValueHolder">copyWith: element 	^ self copy		add: element;		yourself</body><body package="COCellValueHolder">cutWith: anotherCollection filterSource: ignored	^ self * anotherCollection</body><body package="COCellValueHolder">detect: aBlock	^ self 		detect: aBlock		ifNone: [ Collection notFoundSignal raise ]</body><body package="COCellValueHolder">detect: aBlock ifNone: noneBlock 	self do: [: e | ( aBlock value: e ) ifTrue: [ ^ e ]].	noneBlock value</body><body package="COCellValueHolder">do: aBlock 	self subclassResponsibility.</body><body package="COCellValueHolder">do: aBlock separatedBy: anotherBlock 	| hasPrevious |	hasPrevious := false.	self do: 		[: e |			hasPrevious 				ifTrue: [ anotherBlock value ]				ifFalse: [ hasPrevious := true ].			aBlock value: e		].</body><body package="COCellValueHolder">groupedBy: aBlock 	| result |	result := Dictionary new.	self do: [: each | ( result at: ( aBlock value: each ) ifAbsentPut: [ self valueClass new ]) add: each ].	^ result</body><body package="COCellValueHolder">inject: thisValue into: binaryBlock 	| result |	result := thisValue.	self do: [: e | result := binaryBlock value: result value: e ].	^ result</body><body package="COCellValueHolder">reject: aBlock 	^ self select: [: e | ( aBlock value: e ) not ]</body><body package="COCellValueHolder">select: aBlock 	self subclassResponsibility.</body><body package="COCellValueHolder">singleElement	^ self singleElementIfNone: #() defaultNoneBlock ifMore: #() defaultMoreBlock</body><body package="COCellValueHolder">singleElementIfMore: moreBlock 	^ self singleElementIfNone: #( ) defaultNoneBlock ifMore: moreBlock</body><body package="COCellValueHolder">singleElementIfNone: noneBlock 	^ self singleElementIfNone: noneBlock ifMore: #() defaultMoreBlock</body><body package="COCellValueHolder">singleElementIfNone: noneBlock ifMore: moreBlock 	^ self size = 1 		ifTrue: [ self anyElement ]		ifFalse: 		[	self isEmpty 				ifTrue: [ noneBlock value ]				ifFalse: [ moreBlock value ]		]</body><body package="COCellValueHolder">singleElementOnError: aBlock 	^ self singleElementIfNone: aBlock ifMore: aBlock</body><body package="COCellValueHolder">singleElementOrNil	^ self singleElementOnError: nil</body><body package="COCellValueHolder">size	self subclassResponsibility.</body><body package="COCellValueHolder">sortedBy: aBlock 	self subclassResponsibility.</body></methods><methods><class-id>COAST.CatCSAbstractCollection</class-id> <category>testing</category><body package="COCellValueHolder">includes: anObject	self subclassResponsibility.</body><body package="COCellValueHolder">isEmpty	self subclassResponsibility.</body><body package="COCellValueHolder">notEmpty	^self isEmpty not.</body><body package="COCellValueHolder">occurrencesOf: anObject 	self subclassResponsibility.</body></methods><methods><class-id>COAST.CatCSAbstractCollection</class-id> <category>experimental</category><body package="COCellValueHolder">coastAsSet	^ self asSet</body><body package="COCellValueHolder">copy	self subclassResponsibility</body><body package="COCellValueHolder">doesNotUnderstand: aMessage 	| stream |	( value respondsTo: aMessage selector ) ifFalse: [ ^ super doesNotUnderstand: aMessage ].	stream := String new writeStream.	stream		nextPutAll: self class name;		nextPutAll: ' message not understood: ';		nextPutAll: aMessage selector printString;		nextPutAll: ' in method ';		nextPutAll: thisContext sender printString.	CoastLog logWarning: stream contents.	^ self iteratingDo: [ value copy perform: aMessage selector withArguments: aMessage arguments ]</body></methods><methods><class-id>COAST.CatCSAbstractCollection</class-id> <category>garbage collect</category><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock 		self subclassResponsibility.</body></methods><methods><class-id>COAST.CatCSAbstractCollection</class-id> <category>accessing</category><body package="COCellValueHolder">add: anObject	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">at: key put: anObject	CoastError raiseSignal: 'access violation'</body><body package="COFramesystem">coastAsSortedValidKeys	^ self asOrderedCollection coastAsSortedValidKeys</body><body package="COCellValueHolder">depleteWith: access 	self subclassResponsibility.</body><body package="COCellValueHolder">referencesElementsCursorDo: block 	self subclassResponsibility.</body><body package="COCellValueHolder">remove: oldObject	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">valueClass	self subclassResponsibility.</body></methods><methods><class-id>COAST.CatCSAbstractCollection</class-id> <category>iterating</category><body package="COCellValueHolder">coastAllArgumentsDo: aBlock 	self value coastAllArgumentsDo: aBlock</body></methods><methods><class-id>COAST.CatCSAbstractCollection</class-id> <category>marshaling</category><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	self subclassResponsibility.</body></methods><methods><class-id>COAST.CatCSAbstractCollection class</class-id> <category>accessing</category><body package="COCellValueHolder">isAbstractCoastValueHolder	^ true</body></methods><methods><class-id>COAST.CompactSimpleCollection</class-id> <category>removal</category><body package="COCellValueHolder">cut: aCompactSet 	^ aCompactSet cutWithCompactCollection: self</body><body package="COCellValueHolder">cutWith: anotherCollection filterSource: filterSource 	^ self cut: anotherCollection</body><body package="COCellValueHolder">cutWithCollection: aCollection 	| newSet compactCol |	compactCol := self isCompact 			ifTrue: [ self ]			ifFalse: [ self copy compact ].	newSet := self class clusterManager: self clusterManager.	aCollection referencesElementsCursorDo: [: ref | ( compactCol includes: ref ) ifTrue: [ newSet addedFramesAdd: ref copyForRefCursor frameReferenceOrSelf ]].	^ newSet</body><body package="COCellValueHolder">cutWithCompactSet: aCompactSet 	| newSet |	newSet := self class clusterManager: self clusterManager.	self size &lt; aCompactSet size 		ifTrue: [ self referencesElementsCursorDo: [: ref | ( aCompactSet includes: ref ) ifTrue: [ newSet addedFramesAdd: ref copyForRefCursor ]]]		ifFalse: [ aCompactSet referencesElementsCursorDo: [: ref | ( self includes: ref ) ifTrue: [ newSet addedFramesAdd: ref copyForRefCursor ]]].	^ newSet</body></methods><methods><class-id>COAST.CompactSimpleCollection</class-id> <category>converting</category><body package="COCellValueHolder">asCoastValueHolder	^ self subclassResponsibility</body><body package="COCellValueHolder">coastAsSortedValidKeys	self subclassResponsibility.</body></methods><methods><class-id>COAST.CompactSimpleCollection</class-id> <category>accessing</category><body package="COCellValueHolder">addAll: aCollection 	aCollection class = self class 		ifTrue: [ self compactAddAll: aCollection ]		ifFalse: [ aCollection do: [: e | self add: e ] ]</body><body package="COCellValueHolder">compactAddAll: aCompactSet 	aCompactSet referencesElementsCursorDo: [: ref | self addElement: ref copyForRefCursor ].</body><body package="COFramesystem">journalIncludesReferencedElement: element 	^ self includes: element</body><body package="COFramesystem">lastElement	^ self lastReferenceElement</body><body package="COCellValueHolder">occurrencesOf: frame 	self subclassResponsibility.</body><body package="COCellValueHolder">removeRPCResult: frame 	self subclassResponsibility.</body></methods><methods><class-id>COAST.CompactSimpleCollection</class-id> <category>iterating</category><body package="COCellValueHolder">partitionedBy: limit 	"divide myself into smaller collections with a maximum of &lt;limit&gt; elements"	| partitions resArray |	self compact.	partitions := (self size / limit) ceiling.	resArray := Array new: partitions.	1 to: partitions - 1		do: [: index | resArray at: index put: (self copyFrom: (index - 1) * limit + 1 to: index * limit) ].	resArray at: partitions put: (self copyFrom: (partitions - 1) * limit + 1 to: self size).	^ resArray</body><body package="COCellValueHolder">selectValidRPCArguments	^ self</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">* aSet	^value * aSet</body><body package="COCellValueHolder">- aSet	^value - aSet</body><body package="COCellValueHolder">allSatisfy: aBlock	^self iteratingDo: [ value allSatisfy: aBlock ]</body><body package="COCellValueHolder">anyElement	^value anyElement</body><body package="COCellValueHolder">asArray	^value asArray  "asArray always copies"</body><body package="COCellValueHolder">asList	^ value asList</body><body package="COCellValueHolder">asOrderedCollection	^value asOrderedCollection  "asOrderedCollection always copies"</body><body package="COCellValueHolder">asRPCArguments	^ value asRPCArguments</body><body package="COCellValueHolder">asSet	^value asSet</body><body package="COCellValueHolder">asSortedCollection	^value asSortedCollection</body><body package="COCellValueHolder">asSortedCollection: aBlock	^value asSortedCollection: aBlock</body><body package="COCellValueHolder">coastInternalDo: aBlock	^ value do: aBlock</body><body package="COCellValueHolder">collect: aBlock	^self iteratingDo: [ value collect: aBlock ]</body><body package="COCellValueHolder">collectAsArray: aBlock	^ value collectAsArray: aBlock</body><body package="COCellValueHolder">contains: aBlock	^self iteratingDo: [ value contains: aBlock ]</body><body package="COCellValueHolder">copyWith: element 	^ value copyWith: element</body><body package="COCellValueHolder">detect: e 	^self iteratingDo: [ value detect: e ]</body><body package="COCellValueHolder">detect: e ifNone: aBlock	| doNoneBlock result |	doNoneBlock := false.	result := self iteratingDo: [ value detect: e ifNone: [ doNoneBlock := true ]].	doNoneBlock ifTrue: [ result := aBlock value ].	^result</body><body package="COCellValueHolder">do: aBlock	^self iteratingDo: [ value do: aBlock ]</body><body package="COCellValueHolder">do: aBlock separatedBy: anotherBlock 	^self iteratingDo: [ value do: aBlock separatedBy: anotherBlock ]</body><body package="COCellValueHolder">groupedBy: groupBlock 	^ value groupedBy: groupBlock</body><body package="COCellValueHolder">inject: thisValue into: binaryBlock 	^self iteratingDo: [ value inject: thisValue into: binaryBlock ]</body><body package="COCellValueHolder">reject: aBlock	^self iteratingDo: [ value reject: aBlock ]</body><body package="COCellValueHolder">select: aBlock	^self iteratingDo: [ value select: aBlock ]</body><body package="COCellValueHolder">singleElement	^ value singleElement</body><body package="COCellValueHolder">singleElementIfMore: moreBlock 	^ value singleElementIfMore: moreBlock</body><body package="COCellValueHolder">singleElementIfNone: noneBlock	^ value singleElementIfNone: noneBlock</body><body package="COCellValueHolder">singleElementIfNone: noneBlock ifMore: moreBlock 	^ value singleElementIfNone: noneBlock ifMore: moreBlock</body><body package="COCellValueHolder">singleElementOnError: aBlock	^ value singleElementOnError: aBlock</body><body package="COCellValueHolder">singleElementOrNil	^ value singleElementOrNil</body><body package="COCellValueHolder">size	^value size</body><body package="COCellValueHolder">sortedBy: aBlock	^value sortedBy: aBlock</body><body package="COCellValueHolder">species	^value species</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>adapting</category><body package="COCellValueHolder">adaptedCoastValueHolderToClass: valueHolderClass 	^ valueHolderClass coastAdaptFromSimpleCollection: self</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>accessing</category><body package="COCellValueHolder">coastAdaptCollection: collection 	self value: ( self valueClass withAll: collection )</body><body package="COFramesystem">coastAsSortedValidKeys	^ value coastAsSortedValidKeys</body><body package="COCellValueHolder">coastIncludesCompactKey: key 	^ self value coastIncludesCompactKey: key</body><body package="COCellValueHolder">coastInternalAdd: anObject withAccess: access 	value add: anObject.	^ anObject</body><body package="COCellValueHolder">coastInternalRemove: oldObject withAccess: access 	^ value remove: oldObject ifAbsent: [ ]</body><body package="COCellValueHolder">depleteWith: access 	self value: self value coastDepletedValue</body><body package="COMarshalling">index	self subclassResponsibility</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	( frame at: slotName includes: addedFrame ) ifFalse: [ frame at: slotName add: addedFrame ]</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	frame at: slotName remove: removedFrame</body><body package="COFramesystem">journalIncludesReferencedElement: element 	^ self value journalIncludesReferencedElement: element</body><body package="COCellValueHolder">postRPCInitializeWith: delegatingProxy 	^ self value postRPCInitializeWith: delegatingProxy</body><body package="COCellValueHolder">referencesElementsCursorDo: block	self value referencesElementsCursorDo: block</body><body package="COCellValueHolder">setCollectionValueAsRemoteArgument: newValue for: aCluster	" must convert each element of the collection into a valid remote object "	self value: (newValue collect: [ : elem | elem coastAsRemoteArgumentFor: aCluster ]).</body><body package="COCellValueHolder">valueAsDepleteAddedCollection	^ self class valueClass new</body><body package="COCellValueHolder">valueAsSet	^value asSet</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>experimental</category><body package="COCellValueHolder">coastAsSet	^value asSet</body><body package="COCellValueHolder">coastAsSetOrYourself	^value asSet</body><body package="COCellValueHolder">copy	^value copy</body><body package="COCellValueHolder">innerCoastValue	^value copy</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>testing</category><body package="COCellValueHolder">includes: anObject	^value includes: anObject.</body><body package="COCellValueHolder">isEmpty	^value isEmpty</body><body package="COCellValueHolder">occurrencesOf: anObject	^value occurrencesOf: anObject.</body><body package="COFramesystem">referencesSharedFrame: frame 	^ self includes: frame</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>initialize - release</category><body package="COCellValueHolder">initialize	self value: (self valueClass newForValueHolder).</body><body package="COCellValueHolder">initializeWithSize: anInteger	self value: (self valueClass new: anInteger).</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ self class valueClass</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>garbage collect</category><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock 	"for use of garbage-collection only!"	value do: 		[: obj |			obj isFrameOrFrameReference 				ifTrue: [ aBlock value: obj ]		]</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>copying</category><body package="COCellValueHolder">constructCopyParameters: awareness 	"construct an ordered collection of arrays with accesses "	"use add as the default selector suitable for most collections"	^ self value collect: [: elem | CatCSAddAccess argument: ( elem coastCopyWith: awareness )]</body></methods><methods><class-id>COAST.CatCSCollection</class-id> <category>marshalling</category><body package="COMarshalling">coastAsArgumentForMinimalInvalidation	" must convert each value of the collection "	| col |	col := self class new.	col value: (self value collect: [ : v | v coastAsArgumentForMinimalInvalidation ]).	^ col</body><body package="COMarshalling">coastAsRemoteArgumentFor: aCluster	" must convert each value of the collection "	| col |	col := self class new.	col value: (self value collect: [ : v | v coastAsRemoteArgumentFor: aCluster ]).	^ col</body><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall	value do: 		[: val |			val valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall		].</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self class marshallID.	aStream nextPut: self index.	aStream nextOptimized32Put: value size.	value do: [: val | val marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall ].</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: value size.	value do: [: val | aCatRMMarshall marshallValue: val to: aStream ].</body><body package="COMarshalling">translatedArgumentForCluster: aCatCSCluster	^ self value collect: [ : val | val translatedArgumentForCluster: aCatCSCluster ].</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	| valueSize v |	valueSize := aStream nextOptimized32.	self value isNil ifTrue: [ self initializeWithSize: valueSize ].	v := self value.	valueSize timesRepeat: [ v add: ( aCatRMMarshall unmarshallBinaryArgumentFrom: aStream )].</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	| valueSize v |	valueSize := aStream nextOptimized32.	self value isNil ifTrue: [ self initializeWithSize: valueSize ].	v := self value.	valueSize timesRepeat: [ v add: ( aCatRMMarshall unmarshallValueFrom: aStream morph: morphSelector )].</body></methods><methods><class-id>COAST.CatCSCollection class</class-id> <category>adapting</category><body package="COCellValueHolder">coastAdaptFromSimpleCollection: collectionValueHolder 	^ ( self new )		coastAdaptCollection: collectionValueHolder value;		yourself</body></methods><methods><class-id>COAST.CatCSCollection class</class-id> <category>instance creation</category><body package="COCellValueHolder">new	^super new initialize</body><body package="COCellValueHolder">new: aSize	^self basicNew initializeWithSize: aSize</body><body package="COCellValueHolder">newWithoutValue	^self basicNew</body></methods><methods><class-id>COAST.CatCSCollection class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSCollection class</class-id> <category>accessing</category><body package="COCellValueHolder">isAbstractCoastValueHolder	^ self name = #CatCSCollection</body></methods><methods><class-id>COAST.CatCSCollection class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	^ 25</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	| index |	index := aStream next.	^ (( CatCSCellValueHolder valueHolderClassWithID: index ) new )		unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall;		yourself</body></methods><methods><class-id>COAST.CompactAbstractIndex</class-id> <category>accessing</category><body package="COCellValueHolder">add: aFrameAssoc 	self addElement: aFrameAssoc key asCompactArgument -&gt; aFrameAssoc value.	^ aFrameAssoc</body><body package="COCellValueHolder">at: frame 	^ self atKey: frame</body><body package="COCellValueHolder">atCompactKey: key includes: value 	^ ( self coastCompactValueRangeFor: key value: value ) notEmpty</body><body package="COCellValueHolder">atIndex: index 	self compact.	^ self compactElementAtIndex: index</body><body package="COCellValueHolder">atKey: frame 	^ self atKey: frame ifAbsent: nil</body><body package="COCellValueHolder">atKey: frame add: value 	self clusterManagerFrom: frame.	self addElement: frame asCompactArgument -&gt; value.	^ value</body><body package="COCellValueHolder">atKey: key ifAbsent: aBlock 	| valueRefs |	valueRefs := self basicAtKey: key ifAbsent: [ ^ aBlock value ].	^ valueRefs collect: [: valueRef | clusterManager resolveFrameReference: valueRef ]</body><body package="COCellValueHolder">atKey: key includes: value 	( self addedFramesAt: key includes: value ) ifTrue: [ ^ true ].	( self removedFramesAt: key includes: value ) ifTrue: [ ^ false ].	^ self atCompactKey: key includes: value</body><body package="COCellValueHolder">atKey: key remove: value 	^ self atKey: key remove: value ifAbsent: nil</body><body package="COCellValueHolder">atKey: key remove: value ifAbsent: absentBlock 	^ self removeKey: key value: value ifAbsent: absentBlock</body><body package="COCellValueHolder">atKeys: someKeys 	| size copy |	size := 0.	copy := self emptyCopyForCompact.	self referencesElementsCursorDo: 		[: assoc | ( someKeys coastIncludesCompactKey: assoc key ) ifTrue: 				[	size := size + 1.					copy atIndex: size put: assoc				]		].	copy size = size ifFalse: [ copy cropToSize: size ].	^ copy</body><body package="COCellValueHolder">classIndexFor: assoc 	^ self basicClassIndexFor: assoc key</body><body package="COCellValueHolder">coastCompactValueRangeFor: key value: value 	self subclassResponsibility.</body><body package="COCellValueHolder">coastKeyAtValue: val ifAbsent: exceptionBlock 	self keysAndValuesDo: [: frame : value | val = value ifTrue: [ ^ frame ]].	^ exceptionBlock value</body><body package="COCellValueHolder">collect: aBlock 	| values |	values := OrderedCollection new: self size.	self do: [: e | [ values add: ( aBlock value: e )]].	^ values</body><body package="COCellValueHolder">compactIndexForKey: aKey value: aValue 	| range |	range := self coastCompactValueRangeFor: aKey value: aValue.	^ range first</body><body package="COCellValueHolder">defaultCursor	^ self defaultKeyCursor -&gt; self defaultValueCursor</body><body package="COCellValueHolder">defaultKeyCursor	^ CatFSFrameReference new</body><body package="COCellValueHolder">defaultValueCursor	^ CatFSFrameReference new</body><body package="COCellValueHolder">do: aBlock 	self referencesElementsCursorDo: 		[: assoc | | frame |			frame := clusterManager resolveFrameReferenceCursor: assoc value.			aBlock value: frame		].</body><body package="COCellValueHolder">eachKeyIn: someKeys do: eachKeyBlock	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index.	Equivalent to 		(self atKeys: someKeys) keysDo: eachKeyBlock	but faster for some classes "	someKeys do: 		[: key | | valuesRefsOrNil |			valuesRefsOrNil := self basicAtKey: key ifAbsent: nil.			valuesRefsOrNil notNil ifTrue: [ valuesRefsOrNil do: [ : valRef | eachKeyBlock value: key ] ]		].</body><body package="COFramesystem">fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	| valueRefs |	valueRefs := self basicFromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive.	^ valueRefs collect: [: valueRef | clusterManager resolveFrameReference: valueRef ]</body><body package="COFramesystem">greaterKey: key	^ self fromKey: key toKey: nil inclusive: false</body><body package="COFramesystem">greaterOrEqualKey: key 	^ self fromKey: key toKey: nil inclusive: true</body><body package="COCellValueHolder">includesKey: key 	^ self subclassResponsibility</body><body package="COCellValueHolder">indexForKey: aKey value: aValue 	self compact.	^ self compactIndexForKey: aKey value: aValue</body><body package="COCellValueHolder">indexOf: assoc 	^ self indexOf: assoc ifAbsent: nil</body><body package="COCellValueHolder">indexOf: assoc ifAbsent: absentBlock 	| values result |	self compact.	values := self basicAtKey: assoc key ifAbsent: [ ^ absentBlock value ].	result := values indexOf: assoc value.	result = 0 ifTrue: [ ^ absentBlock value ].	^ result + ( self binarySearchMinKey: assoc key ) - 1</body><body package="COCellValueHolder">insertionIndexOf: assoc 	^ self indexForKey: assoc key value: assoc value</body><body package="COFramesystem">journalIncludesReferencedElement: assoc 	^ self atKey: assoc key includes: assoc value</body><body package="COCellValueHolder">keysDo: aBlock 	self referencesElementsCursorDo: 		[: assoc | | frame |			frame := clusterManager resolveFrameReferenceCursor: assoc key.			aBlock value: frame		].</body><body package="COFramesystem">lessKey: key	^ self fromKey: nil toKey: key inclusive: false</body><body package="COFramesystem">lessOrEqualKey: key	^ self fromKey: nil toKey: key inclusive: true</body><body package="COCellValueHolder">reject: aBlock 	| values |	values := OrderedCollection new: self size.	self do: [: e | ( aBlock value: e ) ifFalse: [ values add: e ]].	^ values</body><body package="COCellValueHolder">remove: assoc 	^ self removeKey: assoc key value: assoc value</body><body package="COCellValueHolder">removeFrameReference: frameReference ifAbsent: block 	( self includesKey: frameReference ) 		ifTrue: [ self addedFramesRemove: frameReference ifAbsent: [ self removedFramesAdd: frameReference ]]		ifFalse: [ block value ]</body><body package="COCellValueHolder">removeKey: key 	^ self removeKey: key ifAbsent: [ ]</body><body package="COCellValueHolder">removeKey: key ifAbsent: absentBlock 	| valuesToRemove |	valuesToRemove := self at: key.	valuesToRemove isNil ifTrue: [ ^ absentBlock value ].	valuesToRemove do: [: value | self removeKey: key value: value ].	^ valuesToRemove</body><body package="COCellValueHolder">removeKey: key value: value 	^ self removeKey: key value: value ifAbsent: nil</body><body package="COCellValueHolder">removeKey: key value: value ifAbsent: block 	addedFrames notNil ifTrue: 		[ | retry |			retry := false.			addedFrames atKey: key remove: value ifAbsent: [ retry := true ].			retry ifFalse: [ ^ value ]		].	( self atCompactKey: key includes: value ) 		ifTrue: 		[	self removedFramesAdd: key -&gt; value.			^ value		]		ifFalse: [ ^ block value ]</body><body package="COCellValueHolder">removeRPCResult: assoc 	self removedFramesAdd: assoc.</body><body package="COCellValueHolder">select: aBlock 	| values |	values := OrderedCollection new: self size.	self do: [: e | ( aBlock value: e ) ifTrue: [ values add: e ]].	^ values</body><body package="COCellValueHolder">selectKeys: someKeys whichInclude: aValue 	^ someKeys select: [: key | self atKey: key includes: aValue ]</body><body package="COCellValueHolder">simpleClass	^ Index</body><body package="COCellValueHolder">sizeAtKey: frame 	^ ( self atKey: frame ) size</body></methods><methods><class-id>COAST.CompactAbstractIndex</class-id> <category>private</category><body package="COCellValueHolder">addElement: assoc 	( self atKey: assoc key includes: assoc value ) ifFalse: [ self addedFramesAdd: assoc ]</body><body package="COCellValueHolder">addedFramesAt: frameReference 	^ addedFrames notNil 		ifTrue: [ addedFrames atKey: frameReference ]		ifFalse: [ #( )]</body><body package="COCellValueHolder">addedFramesAt: frameReference includes: value 	^ addedFrames notNil and: [ addedFrames atKey: frameReference includes: value ]</body><body package="COCellValueHolder">addedFramesFrom: startFrameRefOrNil to: stopFrameRefOrNil inclusive: inclusive 	^ addedFrames notNil 		ifTrue: [ addedFrames fromKey: startFrameRefOrNil toKey: stopFrameRefOrNil inclusive: inclusive  ]		ifFalse: [ #( )]</body><body package="COCellValueHolder">addedFramesIncludes: frameReference 	^ addedFrames notNil and: [ addedFrames includesKey: frameReference ]</body><body package="COCellValueHolder">addedFramesRemove: frameReference ifAbsent: block 	^ addedFrames notNil 		ifTrue: [ addedFrames removeKey: frameReference ifAbsent: block ]		ifFalse: [ block value ]</body><body package="COCellValueHolder">associations	| associations |	associations := OrderedCollection new: self size.	self associationsDo: [: a | associations add: a ].	^ associations</body><body package="COCellValueHolder">associationsDo: aBlock 	self keysAndValuesDo: [: k : v | aBlock value: k -&gt; v ].</body><body package="COCellValueHolder">basicAtKey: key ifAbsent: absentBlock 	| sortedAdds compactElements sortedRemovals |	sortedAdds := self addedFramesAt: key.	compactElements := self compactAtKey: key ifAbsent: [: index | #( )].	sortedRemovals := self removedFramesAt: key.	^ self basicCombineCompactElements: compactElements adds: sortedAdds removals: sortedRemovals ifAbsent: absentBlock</body><body package="COCellValueHolder">basicCombineCompactElements: compactElements adds: sortedAdds removals: sortedRemovals ifAbsent: absentBlock 	" create the final result collection "	| result totalSize addStream compactStream |	compactElements removeAll: sortedRemovals.	totalSize := compactElements size + sortedAdds size.	totalSize = 0 ifTrue: [ ^ absentBlock value ].	compactElements isEmpty ifTrue: [ ^ sortedAdds ].	sortedAdds isEmpty ifTrue: [ ^ compactElements ].	result := OrderedCollection new: totalSize.	addStream := ReadStream on: sortedAdds.	compactStream := ReadStream on: compactElements.	[ addStream atEnd or: [ compactStream atEnd ]] whileFalse: 		[( addStream peek coastLessThan: compactStream peek ) 				ifTrue: [ result add: addStream next ]				ifFalse: [ result add: compactStream next ]		].	addStream atEnd ifFalse: [ result addAll: addStream upToEnd ].	compactStream atEnd ifFalse: [ result addAll: compactStream upToEnd ].	^ result</body><body package="COCellValueHolder">basicFromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	| adds compactElements removals |	adds := self addedFramesFrom: startKeyOrNil to: stopKeyOrNil inclusive: inclusive.	compactElements := self compactFrom: startKeyOrNil to: stopKeyOrNil inclusive: inclusive.	removals := self removedFramesFrom: startKeyOrNil to: stopKeyOrNil inclusive: inclusive.	removals isEmpty ifFalse: [ compactElements removeAll: removals ].	compactElements isEmpty ifTrue: [ ^ adds ].	adds isEmpty ifTrue: [ ^ compactElements ].	^ adds , compactElements</body><body package="COCellValueHolder">binarySearchMaxClusterID: cidSearch frameID: fidSearch min: min 	^ self binarySearchMaxClusterID: cidSearch frameID: fidSearch min: min ifAbsent: [ : index | nil ]</body><body package="COCellValueHolder">binarySearchMaxClusterID: cidSearch frameID: fidSearch min: min ifAbsent: absentBlock 	"search the largest index X where (( frameIDs at: X ) = fidSearch and: [( clusterIDs at: X ) = cidSearch ]) or nil"	"send absentBlock the potential index"	^ self binarySearchMaxClusterID: cidSearch frameID: fidSearch min: min max: clusterIDs size ifAbsent: absentBlock</body><body package="COCellValueHolder">binarySearchMaxClusterID: cidSearch frameID: fidSearch min: min max: max ifAbsent: absentBlock 	"search the largest index X where (( frameIDs at: X ) = fidSearch and: [( clusterIDs at: X ) = cidSearch ]) or nil"	"send absentBlock the potential index"	| minIndex maxIndex size |	size := clusterIDs size.	size == 0 ifTrue: [ ^ absentBlock value: 0	"empty collection" ].	minIndex := min.	maxIndex := max.	"1 &lt;= minIndex &lt;= middle &lt;= maxIndex &lt;= size"	[ minIndex &lt; maxIndex ] whileTrue: 		[ "search in interval [ minIndex .. maxIndex ]"			| middle idFound |			middle := 1 + minIndex + maxIndex bitShift: -1.	"minIndex &lt; middle &lt;= maxIndex"			idFound := clusterIDs at: middle.			idFound = cidSearch 				ifTrue: 				[	"compare frameID"					idFound := frameIDs at: middle.					idFound &lt;= fidSearch 						ifTrue: [ minIndex := middle	"search at or behind index" ]						ifFalse: [ maxIndex := middle - 1	"search before index" ]				]				ifFalse: 				[	"compare clusterID"					idFound &lt; cidSearch 						ifTrue: [ minIndex := middle + 1	"search behind index" ]						ifFalse: [ maxIndex := middle - 1	"search before index" ]				]		].	minIndex &gt; size ifTrue: [ ^ absentBlock value: size	"the max index would be here (e.g. search 10 in #(1 2) )" ].	^ ( clusterIDs at: minIndex ) = cidSearch 		ifTrue: 		[( frameIDs at: minIndex ) = fidSearch 				ifTrue: [ minIndex ]				ifFalse: 				[( frameIDs at: minIndex ) &gt; fidSearch 						ifTrue: [ absentBlock value: minIndex - 1	"the max index would be before (e.g. search 2 in #(3) )" ]						ifFalse: [ absentBlock value: minIndex	"the max index would be here (e.g. search 2 in #(1) )" ]				]		]		ifFalse: 		[( clusterIDs at: minIndex ) &gt; cidSearch 				ifTrue: [ absentBlock value: minIndex - 1	"the max index would be before (e.g. search 2 in #(3) )" ]				ifFalse: [ absentBlock value: minIndex	"the max index would be here (e.g. search 2 in #(1) )" ]		]</body><body package="COCellValueHolder">binarySearchMinKey: key 	^ self subclassResponsibility</body><body package="COCellValueHolder">checkedAddElement: aElementToAdd 	( self removedElementsIncludes: aElementToAdd ) 		ifTrue: [ self removedFramesRemove: aElementToAdd ]		ifFalse: [ self addedFramesAdd: aElementToAdd ]</body><body package="COCellValueHolder">coastCompactKeyRangeFor: key 	self subclassResponsibility</body><body package="COFramesystem">compactAddLast: frame index: index 	clusterIDs at: index put: frame clusterID.	frameIDs at: index put: frame frameID.	classIndices at: index put: ( self basicClassIndexFor: frame )</body><body package="COFramesystem">compactAddLastKey: key value: value index: index 	self subclassResponsibility</body><body package="COCellValueHolder">compactAtKey: key ifAbsent: aBlock 	| range result |	range := self coastCompactKeyRangeFor: key.	result := OrderedCollection new: range size.	range do: [: index | result add: ( self compactValueAtIndex: index )].	^result</body><body package="COCellValueHolder">compactElementAtIndex: index into: assoc 	self compactKeyAtIndex: index into: assoc.	self compactValueAtIndex: index into: assoc.</body><body package="COCellValueHolder">compactFrom: startKeyOrNil to: stopKeyOrNil inclusive: inclusive	| range result |	range := self compactKeyRangeFrom: startKeyOrNil to: stopKeyOrNil inclusive: inclusive.	result := OrderedCollection new: range size.	range do: [: index | result add: ( self compactValueAtIndex: index )].	^result</body><body package="COCellValueHolder">compactKeyAtIndex: index 	self subclassResponsibility</body><body package="COCellValueHolder">compactKeyAtIndex: index into: assoc 	self subclassResponsibility.</body><body package="COCellValueHolder">compactKeyRangeFrom: startKeyOrNil to: stopKeyOrNil inclusive: inclusive 	| startIndex stopIndex temp |	startIndex := startKeyOrNil notNil 			ifTrue: 			[	inclusive 					ifTrue: [ self binarySearchMinClusterID: startKeyOrNil clusterID frameID: startKeyOrNil frameID ifAbsent: [: i | i ]]					ifFalse: 					[	temp := self binarySearchMaxClusterID: startKeyOrNil clusterID								frameID: startKeyOrNil frameID								min: 1								ifAbsent: [: i | i ].						temp + 1					]			]			ifFalse: [ 1 ].	stopIndex := stopKeyOrNil notNil 			ifTrue: 			[	inclusive 					ifTrue: 					[	self binarySearchMaxClusterID: stopKeyOrNil clusterID							frameID: stopKeyOrNil frameID							min: startIndex							ifAbsent: [: i | i ]					]					ifFalse: 					[	temp := self binarySearchMinClusterID: stopKeyOrNil clusterID frameID: stopKeyOrNil frameID ifAbsent: [: i | i ].						temp - 1					]			]			ifFalse: [ clusterIDs size ].	^ startIndex to: stopIndex</body><body package="COCellValueHolder">compactValueAtIndex: index 	self subclassResponsibility</body><body package="COCellValueHolder">compactValueAtIndex: index into: assoc 	self subclassResponsibility.</body><body package="COFramesystem">fillFrom: segmentedIndex atKeys: sortedKeys 	"fill into the compact structures. grow when needed to ensure compact writing"	| size |	self clusterManagerFrom: segmentedIndex.	self initializeArraysSized: sortedKeys size.	size := 0.	segmentedIndex atSortedKeys: sortedKeys		do: 		[: key : value |			"iterating will allways ensure sorted keys and values"			size := size + 1.			size &gt; clusterIDs size ifTrue: [ self basicGrowBy: (sortedKeys size max: 500)	"grow now" ].			self 				compactAddLastKey: key				value: value				index: size	"write compact" 		].	size &lt; clusterIDs size ifTrue: [ self cropToSize: size	"remove empty spaces at end" ]</body><body package="COCellValueHolder">initializeAddedFrames	addedFrames := Index new</body><body package="COCellValueHolder">initializeRemovedFrames	removedFrames := Index new</body><body package="COCellValueHolder">insertionIndexOfKey: assoc 	^ self subclassResponsibility</body><body package="COCellValueHolder">keys	| keys |	keys := OrderedCollection new.	self keysAndValuesDo: [: frame : value | keys add: frame ].	^ keys</body><body package="COCellValueHolder">keysAndValuesDo: aBlock 	self referencesElementsCursorDo: 		[: assoc | | key value |			key := assoc key.			value := assoc value.			key isFrameOrFrameReference ifTrue: [ key := clusterManager resolveFrameReferenceCursor: key ].			value isFrameOrFrameReference ifTrue: [ value := clusterManager resolveFrameReferenceCursor: value ].			aBlock value: key value: value		].</body><body package="COFramesystem">lastAdd	^ addedFrames isNil 		ifTrue: [ nil ]		ifFalse: [ addedFrames lastElement ]</body><body package="COFramesystem">lastElement	^ self lastReferenceElement</body><body package="COCellValueHolder">removedElementsAtKey: key includes: value 	^ removedFrames notNil and: [ removedFrames atKey: key includes: value ]</body><body package="COCellValueHolder">removedElementsIncludes: elem 	^ self removedElementsAtKey: elem key includes: elem value</body><body package="COCellValueHolder">removedFramesAdd: assoc 	removedFrames isNil ifTrue: [ self initializeRemovedFrames ].	removedFrames add: assoc</body><body package="COCellValueHolder">removedFramesAt: key 	^ removedFrames notNil 		ifTrue: [ removedFrames atKey: key ]		ifFalse: [ #( )]</body><body package="COCellValueHolder">removedFramesAt: key includes: value 	^ removedFrames notNil and: [ removedFrames atKey: key includes: value ]</body><body package="COCellValueHolder">removedFramesFrom: startFrameRefOrNil to: stopFrameRefOrNil inclusive: inclusive 	^ removedFrames notNil 		ifTrue: [ removedFrames fromKey: startFrameRefOrNil toKey: stopFrameRefOrNil inclusive: inclusive  ]		ifFalse: [ #( )]</body><body package="COCellValueHolder">removedFramesRemove: assoc 	removedFrames notNil		ifTrue: [ removedFrames atKey: assoc key remove: assoc value ifAbsent: [ nil ] ]</body><body package="COCellValueHolder">sortedAdds	^ addedFrames isNil 		ifTrue: [ #( )]		ifFalse: [ addedFrames copy ]</body></methods><methods><class-id>COAST.CompactAbstractIndex</class-id> <category>converting</category><body package="COCellValueHolder">asIndex	| index |	index := Index new: self size.	self keysAndValuesDo: [ : k : v | index atKey: k add: v ].	^index</body><body package="COCellValueHolder">asMultiValueDictionary	| index |	index := MultiValueDictionary new: self size.	self keysAndValuesDo: [ : k : v | index atKey: k add: v ].	^index</body></methods><methods><class-id>COAST.CompactAbstractIndex</class-id> <category>values</category><body package="COCellValueHolder">values	| values |	values := OrderedCollection new.	self do: [: frame | values add: frame ].	^ values</body></methods><methods><class-id>COAST.CompactAbstractIndex</class-id> <category>compact</category><body package="COCellValueHolder">addAddsForCompactTo: collection 	addedFrames isNil ifFalse: 		[	addedFrames keysAndValuesDo: 				[: key :value | | pos |					pos := self compactIndexForKey: key value: value.					collection add: ( Array with: #add with: key-&gt;value with: pos with: key-&gt;value )				]		].</body><body package="COCellValueHolder">addRemovesForCompactTo: collection 	removedFrames notNil ifTrue: 		[	removedFrames keysAndValuesDo: 				[: key : value | | pos |					pos := self compactIndexForKey: key value: value.					collection add: ( Array with: #remove with: key -&gt; value with: pos with: key -&gt; value )				]		].</body></methods><methods><class-id>COAST.CompactAbstractIndex</class-id> <category>iterating</category><body package="COFramesystem">coastAllArgumentsDo: aBlock 	self keysAndValuesDo: 		[: k : v |			aBlock value: k.			aBlock value: v		].</body></methods><methods><class-id>COAST.CompactAbstractIndex</class-id> <category>marshalling</category><body package="COMarshalling">translatedArgumentForCluster: aCatCSCluster 	" addedFrames contains frame references "	self error: 'Set all for indices not supported'</body></methods><methods><class-id>COAST.CatCSProxyValueHolder</class-id> <category>private</category><body package="COMarshalling">basicValue	^ value</body><body package="COCellValueHolder">clusterManager	^ clusterManager</body><body package="COCellValueHolder">clusterManager: aClusterManager	clusterManager := aClusterManager</body><body package="COCellValueHolder">clusterManagerIfNeeded: aClusterManager	clusterManager isNil 		ifTrue: [ clusterManager := aClusterManager ].</body><body package="COCellValueHolder">delegatingProxyClass	self subclassResponsibility</body><body package="COCellValueHolder">doesNotUnderstand: aMessage 	( self value respondsTo: aMessage selector ) ifFalse: [ ^ super doesNotUnderstand: aMessage ].	CoastLog logWarning: self class name asString , ' message not understood: ' , aMessage selector printString , ' in method ' , thisContext sender printString.	^ self copy perform: aMessage selector withArguments: aMessage arguments</body><body package="COCellValueHolder">prepareProxyAccess: access argumentsBlock: argumentsBlock 	" first access to a new proxy index. find out if arguments are frames or primitives, and create a real (segmented) index frame "	self removeAccessFromAgenda: access.	value isFrameOrFrameReference ifFalse: 		[	access cell initializeForArgumentsBlock: argumentsBlock inVolume: access cell volume.			access cellFrame at: access cell id set: value		]</body><body package="COCellValueHolder">removeAccessFromAgenda: access 	access transaction removeProxyAccess: access</body><body package="COCellValueHolder">value	" value is possibly a frame reference "	| valueFrame |	^ value isFrameOrFrameReference 		ifTrue: 		[	value isCoastFrame 				ifTrue: [ value ]				ifFalse: 				[	valueFrame := self clusterManager getFrame: value.					valueFrame isNil ifTrue: [ CoastFatalError raiseSignal: 'Value frame for ' , value printString , ' not found' ].					valueFrame				]		]		ifFalse: [ value ifNil: [ self class defaultValue ]]</body><body package="COCellValueHolder">value: anObject	value := anObject isCoastFrame		ifTrue: [ 			self clusterManagerIfNeeded: anObject clusterManager.			" never store frames directly "			anObject frameLocator		]		ifFalse: [ 			anObject		].</body><body package="COCellValueHolder">valueFrame	^ self value</body></methods><methods><class-id>COAST.CatCSProxyValueHolder</class-id> <category>accessing</category><body package="COCellValueHolder">allSatisfy: aBlock	^ self value allSatisfy: aBlock</body><body package="COCellValueHolder">asArray	^ self value asArray</body><body package="COCellValueHolder">asOrderedCollection	^ self value asOrderedCollection</body><body package="COCellValueHolder">changeToDelegatingProxy	value := nil.	self changeClassTo: self delegatingProxyClass.</body><body package="COCellValueHolder">changeToDelegatingProxyForSlot: aCoastSlot	self changeToDelegatingProxy		slot: aCoastSlot;		initializeSpawned.</body><body package="COCellValueHolder">collect: aBlock	^ self value collect: aBlock</body><body package="COCellValueHolder">constructCopyParameters: awareness 	CoastError raiseSignal: 'CoastCopy of SegmentedCollection is not supported'</body><body package="COCellValueHolder">copyForRollback	^ value isCoastFrame		ifTrue: [ value frameLocator ]		ifFalse: [ value ]</body><body package="COCellValueHolder">detect: detectBlock ifNone: noneBlock	self do: [ :each | (detectBlock value: each) ifTrue: [ ^ each ] ].	^ noneBlock value</body><body package="COCellValueHolder">do: aBlock	^ self value do: aBlock</body><body package="COCellValueHolder">includes: anObject	^ self value includes: anObject.</body><body package="COCellValueHolder">initializeForArgumentsBlock: argumentsBlock inVolume: volume 	" use a replacement value for the slot "	self value: ( self valueForArgs: argumentsBlock value inVolume: volume ).	^ self value</body><body package="COCellValueHolder">referencesElementsCursorDo: aBlock 	^ self value referencesElementsCursorDo: aBlock</body><body package="COCellValueHolder">reject: aBlock	^ self value reject: aBlock</body><body package="COCellValueHolder">select: aBlock	^ self value select: aBlock</body><body package="COCellValueHolder">size	^ self value size</body><body package="COCellValueHolder">sortedBy: aBlock	^ self value sortedBy: aBlock</body><body package="COCellValueHolder">valueAsSet	^ self value asSet</body><body package="COCellValueHolder">valueClass	^ self class valueClass</body><body package="COCellValueHolder">valueForArgs: args inVolume: volume 	" return a replacement value for the slot "	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSProxyValueHolder</class-id> <category>testing</category><body package="COFramesystem">allowsSlotModification	"remote writing would not match the mediators concurrency control"	"only empty valueFrames can be set"	^ self clusterManager responsibleForVolume or: [ self valueFrame isCoastFrame not ]</body><body package="COCellValueHolder">canFastRead	^ false</body><body package="COFramesystem">canFastReadFullValue	^ true</body><body package="COCellValueHolder">isEmpty	^ self value isEmpty</body><body package="COCellValueHolder">isProxyValueHolder	^ true</body><body package="COCellValueHolder">isValidSingleValue: newValue 	^ newValue isNil or: [ value == newValue or: [ newValue isCoastCollectionFrame ]]</body><body package="COCellValueHolder">occurrencesOf: anObject 	^ self value occurrencesOf: anObject</body><body package="COFramesystem">referencesSharedFrame: sharedFrame 	^ value notNil  and: [ self valueFrame referencesSharedFrame: sharedFrame ]</body></methods><methods><class-id>COAST.CatCSProxyValueHolder</class-id> <category>garbage collect</category><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock 	value isFrameOrFrameReference 		ifTrue: [ aBlock value: value ]</body></methods><methods><class-id>COAST.CatCSProxyValueHolder</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">asRPCArguments	| anArray index |	anArray := Array new: self size.	index := 0.	self referencesElementsCursorDo: [: assocOrElem | anArray at: ( index := index + 1 ) put: assocOrElem value copyForRefCursor ].	^ anArray asRPCArguments</body></methods><methods><class-id>COAST.CatCSProxyValueHolder</class-id> <category>initialize - release</category><body package="COCellValueHolder">initialize	super initialize.	self value: self valueClass new.</body></methods><methods><class-id>COAST.CatCSProxyValueHolder</class-id> <category>journal accessing</category><body package="COFramesystem">journalSize	| valueFrame |	valueFrame := self valueFrame.	^ valueFrame isCoastFrame 		ifTrue: [ valueFrame journalSize ]		ifFalse: [ 0 ]</body><body package="COFramesystem">maxJournalSize	| valueFrame |	valueFrame := self valueFrame.	^ valueFrame isCoastFrame 		ifTrue: [ valueFrame maxJournalSize ]		ifFalse: [ 0 ]</body></methods><methods><class-id>COAST.CatCSProxyValueHolder</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall	self basicValue valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall.</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	self basicValue marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	aCatRMMarshall clusterManager useProxyValueHolder ifTrue: [ self changeToDelegatingProxy ].	super unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.</body></methods><methods><class-id>COAST.CatCSProxyValueHolder class</class-id> <category>instance creation</category><body package="COCellValueHolder">isAbstractCoastValueHolder	^ self name = #CatCSProxyValueHolder</body><body package="COCellValueHolder">new	^super new initialize</body></methods><methods><class-id>COAST.CatCSProxyValueHolder class</class-id> <category>accessing</category><body package="COCellValueHolder">defaultValue	defaultValue isNil ifTrue: 		[	defaultValue := ( self valueClass new: 0 )					beImmutable;					yourself		].	^ defaultValue</body><body package="COCellValueHolder">valueClass	^ self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSDelegatingValueHolder</class-id> <category>testing</category><body package="COCellValueHolder">canFastRead	^ false</body><body package="COFramesystem">canFastReadFullValue	^ true</body><body package="COCellValueHolder">isDepleted	^ self delegationContextAt: #depleted ifAbsent: [ false ]</body><body package="COCellValueHolder">isDirty	^ self uncleandRemovedSize &gt; 0 or: [ self addedSize &gt; 0 ]</body><body package="COCellValueHolder">isEmpty	| maxSize removedSize |	self addedIsEmpty ifFalse: [ ^ false ].	removedSize := self uncleandRemovedSize.	removedSize = 0 ifTrue: [ ^ self valueFrameIsEmpty	"avoid size computation" ].	maxSize := self addedSize + self valueFrameSize.	removedSize &lt; maxSize ifTrue: [ ^ false	"clean removed can not be big enough to make me empty" ].	^ maxSize - self removedSize = 0</body><body package="COCellValueHolder">isNew	^ self delegationContextAt: #new ifAbsent: [ false ]</body><body package="COCellValueHolder">isProxyValueHolder	^ true</body><body package="COFramesystem">isValidSingleValue: newValue 	^ newValue isNil or: [ newValue isCoastCollectionFrame ]</body></methods><methods><class-id>COAST.CatCSDelegatingValueHolder</class-id> <category>private - context</category><body package="COCellValueHolder">delegationContextAt: aSymbol ifAbsent: absentBlock	| activeTransaction dictOrNil |	activeTransaction := Processor activeTransaction.	activeTransaction isNil ifTrue: [ ^ absentBlock value ].	dictOrNil := activeTransaction delegationContextAt: self.	^ dictOrNil notNil 		ifTrue: [ dictOrNil at: aSymbol ifAbsent:absentBlock]		ifFalse: [ absentBlock value ]</body><body package="COCellValueHolder">delegationContextAtKey: key put: aValue 	| activeTransaction |	activeTransaction := Processor activeTransaction.	activeTransaction isNil ifTrue: [ ^ nil ].	^ ( activeTransaction delegationContextNeededAt: self ) at: key put: aValue</body><body package="COCellValueHolder">delegationContextIn: activeTransaction 	^ activeTransaction notNil 		ifTrue: [ activeTransaction delegationContextAt: self ]		ifFalse: [ nil ]</body><body package="COCellValueHolder">delegationContextNeeded	| activeTransaction |	activeTransaction := Processor activeTransaction.	activeTransaction isNil ifTrue: [ ^ self haltOrError: 'Access on ' , self slot printString , ' outside a transaction'  ].	^ activeTransaction delegationContextNeededAt: self.</body><body package="COCellValueHolder">initializeKey: key collectionType: collectionType 	^self delegationContextAtKey: key put: collectionType new</body></methods><methods><class-id>COAST.CatCSDelegatingValueHolder</class-id> <category>private</category><body package="COCellValueHolder">added	^ self delegationContextAt: #added ifAbsent: [ nil ]</body><body package="COCellValueHolder">addedIsEmpty	| probe |	^ ( probe := self added ) isNil or: [ probe isEmpty ]</body><body package="COCellValueHolder">addedSize	| probe |	^ ( probe := self added ) isNil 		ifTrue: [ 0 ]		ifFalse: [ probe size ]</body><body package="COCellValueHolder">allSatisfy: block 	self do: [: any | ( block value: any ) ifFalse: [ ^ false ]].	^ true</body><body package="COCellValueHolder">anyElement	self do: [: any | ^ any ].	^ nil</body><body package="COCellValueHolder">asArray	| anArray index |	anArray := Array new: self size.	index := 0.	self do: [: each | anArray at: ( index := index + 1 ) put: each ].	^ anArray</body><body package="COCellValueHolder">asList	^ List withAll: self</body><body package="COCellValueHolder">asOrderedCollection	^ self collectAsOrderedCollection: [: elem | elem ]</body><body package="COCellValueHolder">asRPCArguments	| anArray index |	anArray := Array new: self size.	index := 0.	self referencesElementsCursorDo: [: assocOrElem | anArray at: ( index := index + 1 ) put: assocOrElem value copyForRefCursor ].	^ anArray asRPCArguments</body><body package="COCellValueHolder">asSet	^ self collect: [: elem | elem ] as: Set</body><body package="COCellValueHolder">asSortedCollection	^ self collect: [: elem | elem ] as: SortedCollection</body><body package="COCellValueHolder">asSortedCollection: sortBlock 	| result |	result := SortedCollection sortBlock: sortBlock.	self do: [: elem | result add: elem ].	^ result</body><body package="COCellValueHolder">clusterManager	^ self slot clusterManager</body><body package="COCellValueHolder">collect: block 	^ self collect: block as: self collectionTypeForCollect</body><body package="COCellValueHolder">collectionType	self subclassResponsibility</body><body package="COCellValueHolder">collectionTypeForCollect	self subclassResponsibility</body><body package="COCellValueHolder">depleteWith: access 	| dictionary |	" remember that this value has been depleted "	dictionary := self delegationContextNeeded.	dictionary isNil ifTrue: [ ^ self ].	dictionary removeKey: #removedIsDirty ifAbsent: nil.	dictionary removeKey: #added ifAbsent: nil.	dictionary removeKey: #removed ifAbsent: nil.	dictionary at: #depleted put: true</body><body package="COCellValueHolder">initializeAdded	^ self initializeKey: #added collectionType: self collectionType</body><body package="COCellValueHolder">initializeRemoved	^ self initializeKey: #removed collectionType: self collectionType</body><body package="COCellValueHolder">isRPCPossible	^ value notNil and: [ self isNew not and: [ self isDepleted not ]]</body><body package="COCellValueHolder">reject: block 	^ self reject: block as: self collectionTypeForCollect</body><body package="COCellValueHolder">reject: block as: collectionClass 	| result |	result := collectionClass new: self size.	self do: [: elem | ( block value: elem ) ifFalse: [ result add: elem ]].	^ result</body><body package="COCellValueHolder">removed	| uncleanedRemoved |	uncleanedRemoved := self uncleanedRemoved.	( uncleanedRemoved notNil and: [ self removedIsDirty ]) ifTrue: 		[	self cleanRemoved: uncleanedRemoved.			self delegationContextAtKey: #removedIsDirty put: false		].	^ uncleanedRemoved</body><body package="COCellValueHolder">removedSize	| probe |	^ ( probe := self removed ) isNil 		ifTrue: [ 0 ]		ifFalse: [ probe size ]</body><body package="COCellValueHolder">resolveFrameReference: reference 	^ self clusterManager resolveFrameReference: reference</body><body package="COCellValueHolder">select: block 	^ self select: block as: self collectionTypeForCollect</body><body package="COCellValueHolder">select: block as: collectionClass 	| result |	result := collectionClass new: self size.	self do: [: elem | ( block value: elem ) ifTrue: [ result add: elem ]].	^ result</body><body package="COCellValueHolder">size	^ self addedSize + self valueFrameSize - self removedSize</body><body package="COCellValueHolder">slot	^ slot</body><body package="COCellValueHolder">slot: aCatFSSlot	slot := aCatFSSlot</body><body package="COCellValueHolder">sortedBy: aBlock	^ self asOrderedCollection sortedBy: aBlock</body><body package="COCellValueHolder">uncleandRemovedSize	| probe |	^ ( probe := self uncleanedRemoved ) isNil 		ifTrue: [ 0 ]		ifFalse: [ probe size ]</body><body package="COCellValueHolder">valueFrame	| locator |	locator := self value.	locator isFrameOrFrameReference ifFalse:		[	" ask the mediator for a locator to the segmented collection "			locator := self valuePerform: #frameLocator withArguments: Array new default: [ nil ].			self value: locator		].	^ locator notNil 		ifTrue: [ self clusterManager getFrame: locator ]		ifFalse: [ nil ]</body><body package="COCellValueHolder">valueFrameAtKeys: someKeys 	"only for Dictionary &amp; Index!"	| rpcKeys rpcResultIndex limit allResults |	rpcKeys := someKeys selectValidRPCArguments.	rpcKeys isEmpty ifTrue: [ ^ self collectionType new ].	( self isRPCPossible and: [ self slot allowRPCs ]) 		ifFalse: [ ^ self valuePerform: #atKeys: withArguments: ( Array with: rpcKeys ) default: [ self collectionType new ]].	limit := 1024.	rpcKeys := rpcKeys asRPCArguments.	allResults := ( rpcKeys partitionedBy: limit ) collect: 			[: part | | partResult |				partResult := self valuePerform: #atKeys: withArguments: ( Array with: part asCoastValueHolder ) default: [ self collectionType new ].				partResult value			].	"new style:"	"rpcResultIndex := allResults singleElementIfMore: [: more | self segmentedRPCResultClass fromRPCResults: more ]."	"old style:"	rpcResultIndex := allResults singleElementIfMore: 			[: more | ( more anyElement class new )					basicAppendAll: more;					yourself			].	^ rpcResultIndex postRPCInitializeWith: self</body><body package="COCellValueHolder">valueFrameIsEmpty	^ self valuePerform: #isEmpty withArguments: Array new default: [ true ]</body><body package="COCellValueHolder">valueFrameIsPresent	^ self valueFrame notNil and: [ self isDepleted not ]</body><body package="COCellValueHolder">valueFrameSize	^ self valuePerform: #size withArguments: Array new default: [ 0 ]</body><body package="COCellValueHolder">valuePerform: selector withArguments: args default: defaultBlock 	^ self valuePerform: selector withArguments: args default: defaultBlock allowCache: true</body><body package="COCellValueHolder">valuePerform: selector withArguments: args default: defaultBlock allowCache: allowCache 	| frame |	^ self isRPCPossible 		ifTrue: 		[	self slot allowRPCs 				ifTrue: 				[	frame := self slot frame.					frame at: self slot slotName rpcPerform: selector withArguments: args allowCache: allowCache				]				ifFalse: [ self valueFrame perform: selector withArguments: args ]		]		ifFalse: [ defaultBlock value ]</body></methods><methods><class-id>COAST.CatCSDelegatingValueHolder</class-id> <category>private dirty remove</category><body package="COCellValueHolder">cleanRemoved: removed 	self subclassResponsibility</body><body package="COCellValueHolder">markRemovedAsDirty	"removed somthing that might not be included	for speedup, blind removes do not care!"	self delegationContextAtKey: #removedIsDirty put: true</body><body package="COCellValueHolder">removedIsDirty	^ self delegationContextAt: #removedIsDirty ifAbsent: [ false ]</body><body package="COCellValueHolder">uncleanedRemoved	^ self delegationContextAt: #removed ifAbsent: [ nil ]</body></methods><methods><class-id>COAST.CatCSDelegatingValueHolder</class-id> <category>initialize-release</category><body package="COCellValueHolder">initializeSpawned	" my slot was just spawned "	super initializeSpawned.	self delegationContextNeeded at: #new put: true.</body></methods><methods><class-id>COAST.CatCSDelegatingValueHolder</class-id> <category>accessing</category><body package="COCellValueHolder">constructCopyParameters: awareness 	CoastError raiseSignal: 'CoastCopy of SegmentedCollection is not supported'</body><body package="COCellValueHolder">directValuesDo: block 	"not supported here"</body><body package="COCellValueHolder">performUpdateAccess: aCatCSCellAccess 	"only keep my local stuff up to date - the remote values are already updated!"	| ctx |	aCatCSCellAccess mayIgnoreForProxies ifFalse: [ ^ super performUpdateAccess: aCatCSCellAccess ].	ctx := self delegationContextIn: aCatCSCellAccess transaction.	( ctx notNil and: [( ctx includesKey: #added ) or: [ ctx includesKey: #removed ]]) ifTrue: 		[	aCatCSCellAccess transaction isUpdateTransaction 				ifTrue: [ CoastError raiseSignal: 'This should not happen - Update to a locally modified delegating proxy' ]				ifFalse: [ super performUpdateAccess: aCatCSCellAccess ]		].</body><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock	" no client GC currently possible "	self unfixedHans; unfixedHolger.	self shouldNotImplement.</body><body package="COFramesystem">referencesSharedFrame: sharedFrame 	^ self valueFrame ifNil: [ false ] ifNotNil: [ : vf | vf referencesSharedFrame: sharedFrame ]</body><body package="COCellValueHolder">removeAccessFromAgenda: access 	self subclassResponsibility.</body><body package="COCellValueHolder">valueAsSet	^ self valueFrame asSet</body><body package="COCellValueHolder">valueForArgs: args inVolume: volume 	self subclassResponsibility.</body></methods><methods><class-id>COAST.CatCSDelegatingValueHolder</class-id> <category>journal accessing</category><body package="COFramesystem">journalSize	^ self valuePerform: #journalSize withArguments: Array new default: [ 0 ]</body><body package="COFramesystem">maxJournalSize	^ self valuePerform: #maxJournalSize withArguments: Array new default: [ 0 ]</body></methods><methods><class-id>COAST.CatCSDelegatingValueHolder</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall	self value valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall.</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	self value marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CatCSDelegatingValueHolder class</class-id> <category>instance creation</category><body package="COCellValueHolder">isAbstractCoastValueHolder	^ self name = #CatCSDelegatingValueHolder</body></methods><methods><class-id>COAST.CatCSVirtualValue</class-id> <category>accessing</category><body package="COCellValueHolder">access: aCatCSCellAccess 	"may be needed before recording the access"	aCatCSCellAccess computeDifferencesIfNeeded.	aCatCSCellAccess transaction recordAccess: aCatCSCellAccess.	aCatCSCellAccess isWriteAccess 		ifTrue: [ self checkBeforeAccess: aCatCSCellAccess ].	^ aCatCSCellAccess performOn: self</body><body package="COCellValueHolder">value: anObject	value := anObject innerCoastValue</body></methods><methods><class-id>COAST.CatCSVirtualValue class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^nil</body></methods><methods><class-id>COAST.CatCSVirtualValue class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^nil</body></methods><methods><class-id>COAST.CompactAdd</class-id> <category>printing</category><body package="COCellValueHolder">printOn: stream	super printOn: stream.		stream nextPutAll: 'add at '.	pos printOn: stream .</body></methods><methods><class-id>COAST.CompactAdd</class-id> <category>accessing</category><body package="COCellValueHolder">elem	^ elem</body><body package="COCellValueHolder">elem: aElem 	elem := aElem.</body><body package="COCellValueHolder">pos	^ pos</body><body package="COCellValueHolder">pos: aPos 	pos := aPos.</body></methods><methods><class-id>COAST.CompactAdd</class-id> <category>transforming</category><body package="COCellValueHolder">addAddsTo: compactCollection 	compactCollection atIndex: pos put: elem.	super addAddsTo: compactCollection.</body></methods><methods><class-id>COAST.CompactAdd class</class-id> <category>instance creation</category><body package="COCellValueHolder">elem: aElem pos: aPos 	^ ( self new )		elem: aElem;		pos: aPos;		yourself</body></methods><methods><class-id>COAST.CompactMove</class-id> <category>printing</category><body package="COCellValueHolder">printOn: stream 	super printOn: stream."	( previous notNil and: [ by = 0 or: [ start &gt; stop ]]) ifTrue: [ ^ self ]."	stream nextPutAll: 'move '.	start printOn: stream.	stream nextPutAll: ' to '.	stop printOn: stream.	stream nextPutAll: ' by '.	by printOn: stream.</body></methods><methods><class-id>COAST.CompactMove</class-id> <category>accessing</category><body package="COCellValueHolder">add: elem at: pos 	stop &lt; pos ifTrue: 		[	previous := self copy.			start := pos		].	start = pos ifFalse: 		[	previous := self copy stop: pos - 1.			start := pos	"split"		].	previous := ( CompactAdd elem: elem pos: pos + by ) previous: previous.	by := by + 1.	"move down"</body><body package="COCellValueHolder">by	^ by</body><body package="COCellValueHolder">by: aBy 	by := aBy.</body><body package="COCellValueHolder">remove: elem at: pos 	"start &lt;= pos &lt;= stop"	start = pos ifFalse: [ previous := self copy stop: pos - 1	"split" ].	start := pos + 1.	by := by - 1.</body><body package="COCellValueHolder">start	^ start</body><body package="COCellValueHolder">start: aStart 	start := aStart.</body><body package="COCellValueHolder">stop	^ stop</body><body package="COCellValueHolder">stop: aStop 	stop := aStop.</body></methods><methods><class-id>COAST.CompactMove</class-id> <category>transforming</category><body package="COCellValueHolder">performMovesFrom: original to: copy 	start &gt; stop ifFalse: [ copy replaceFrom: start + by to: stop + by with: original startingAt: start ].	super performMovesFrom: original to: copy.</body></methods><methods><class-id>COAST.CompactMove class</class-id> <category>instance creation</category><body package="COCellValueHolder">size: size 	^ ( CompactMove new )		start: 1;		stop: size;		by: 0;		yourself</body></methods><methods><class-id>COAST.CompactSet</class-id> <category>private</category><body package="COCellValueHolder">addElement: aElementToAdd 	( self includes: aElementToAdd ) ifFalse: [ super addElement: aElementToAdd ]</body><body package="COMessages">asCoastPrimitive	^ (COAST.CatCSCompactSet new)		value: self;		yourself</body><body package="COCellValueHolder">initializeAddedFrames	addedFrames := Set new</body><body package="COCellValueHolder">initializeRemovedFrames	^ removedFrames := Set new</body></methods><methods><class-id>COAST.CompactSet</class-id> <category>accessing</category><body package="COCellValueHolder">* collection 	^ collection cutWithCompactCollection: self</body><body package="COCellValueHolder">coastAsSetOrYourself	^ self</body><body package="COCellValueHolder">cutWithCompactCollection: aCompactCollection	^ aCompactCollection cutWithCompactSet: self</body><body package="COCellValueHolder">occurrencesOf: frame 	^( self includes: frame ) 		ifTrue: [ 1 ]		ifFalse: [ 0 ]</body><body package="COCellValueHolder">removeRPCResult: frame 	self removedFramesAdd: frame.</body><body package="COCellValueHolder">simpleClass	^ Set</body></methods><methods><class-id>COAST.CompactSet</class-id> <category>enumerating</category><body package="COCellValueHolder">- aSet 	"Answer those elements present in the receiver and absent from aSet."	^ self reject: [: i | aSet includes: i ]</body></methods><methods><class-id>COAST.CompactSet</class-id> <category>converting</category><body package="COCellValueHolder">asCoastValueHolder	^ (COAST.CatCSCompactSet new)		value: self;		yourself</body><body package="COCellValueHolder">coastAsSortedValidKeys	^ self</body></methods><methods><class-id>COAST.CatCSKeyedCollection</class-id> <category>accessing</category><body package="COCellValueHolder">associationsDo: aBlock 	^ self iteratingDo: [ self value associationsDo: aBlock ]</body><body package="COCellValueHolder">atKey: key 	^ self value atKey: key</body><body package="COCellValueHolder">atKey: key ifAbsent: aBlock 	^ self value atKey: key ifAbsent: aBlock</body><body package="COCellValueHolder">atKey: key includes: someValue 	^ self value atKey: key includes: someValue</body><body package="COCellValueHolder">atKeys: someKeys	^ value atKeys: someKeys</body><body package="COCellValueHolder">coastInternalAdd: anObject withAccess: access 	" adding associations is not allowed "	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">coastInternalAt: key add: anObject withAccess: access 	^ self value atKey: key add: anObject</body><body package="COCellValueHolder">coastInternalAt: key remove: anObject withAccess: anObject1 	^ self value atKey: key remove: anObject ifAbsent: nil .</body><body package="COCellValueHolder">coastInternalRemove: anObject withAccess: access 	"???"	^ CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">eachKeyIn: someKeys do: eachKeyBlock 	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index. "	" default fallback implementation "	(self atKeys: someKeys) keysDo: eachKeyBlock</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue 	self frame: frame atKeyedSlotNamed: slotName replace: oldValue with: newValue</body><body package="COCellValueHolder">includesKey: key	^self value includesKey: key.</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	| key |	key := demon keyFor: addedFrame.	key notNil 		ifTrue: 		[(( frame at: slotName atKey: key includes: addedFrame) ) 				ifFalse: [ frame at: slotName atKey: key add: addedFrame ]		]		ifFalse: [ self error: 'can not invert' ]</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	| key |	key := demon keyFor: removedFrame.	key notNil 		ifTrue: 		[(( frame at: slotName atKey: key ) includes: removedFrame ) 				ifTrue: [ frame at: slotName atKey: key remove: removedFrame ]		]		ifFalse: [ self error: 'can not invert' ]</body><body package="COCellValueHolder">keys	^self value keys.</body><body package="COCellValueHolder">keysAndValuesDo: aBlock 	^ self iteratingDo: [ self value keysAndValuesDo: aBlock ]</body><body package="COCellValueHolder">keysDo: block 	^ self iteratingDo: [ self value keysDo: block ]</body><body package="COCellValueHolder">selectKeys: someKeys whichInclude: aValue 	^ value selectKeys: someKeys whichInclude: aValue</body><body package="COMarshalling">translatedArgumentForCluster: aCatCSCluster	^ self value translatedArgumentForCluster: aCatCSCluster</body><body package="COCellValueHolder">valueAsSet	^ self value values asSet</body><body package="COCellValueHolder">values	^self value values.</body></methods><methods><class-id>COAST.CatCSKeyedCollection</class-id> <category>copying</category><body package="COCellValueHolder">constructCopyParameters: awareness 	| params |	params := OrderedCollection new.	self value keysAndValuesDo: 		[: key : val |			params addLast: ( CatCSAtKeyAddAccess argument1: ( key coastCopyWith: awareness ) argument2: ( val coastCopyWith: awareness ))		].	^ params</body></methods><methods><class-id>COAST.CatCSKeyedCollection</class-id> <category>testing</category><body package="COFramesystem">referencesSharedFrame: frame 	^ ( self includesKey: frame ) or: [ self values includes: frame ]</body></methods><methods><class-id>COAST.CatCSKeyedCollection class</class-id> <category>testing</category><body package="COCellValueHolder">isAbstractCoastValueHolder	^ self name = #CatCSKeyedCollection</body></methods><methods><class-id>COAST.CatCSKeyedCollection class</class-id> <category>adapting</category><body package="COCellValueHolder">coastAdaptFromSimpleCollection: aCollection 	"nope"	^ aCollection</body></methods><methods><class-id>COAST.CompactKeyIndex</class-id> <category>accessing</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSCompactKeyIndex new )		value: self;		yourself</body><body package="COCellValueHolder">atCompactKey: key includes: value 	^super atCompactKey: key asCompactArgument includes: value</body><body package="COCellValueHolder">atKey: keyFrame add: value 	| keyRef |	self clusterManagerFrom: keyFrame.	keyRef := keyFrame asCompactArgument.	( self atKey: keyRef includes: value ) ifFalse: [ self checkedAddElement: keyRef -&gt; value ].	^ value</body><body package="COCellValueHolder">atKey: key ifAbsent: aBlock 	| frameReference |	frameReference := key asValidFrameReferenceOrNil.	^ frameReference notNil 		ifTrue: [ self basicAtKey: frameReference ifAbsent: [ aBlock value ]]		ifFalse: [ aBlock value ]</body><body package="COCellValueHolder">atKey: frameK includes: value 	| refKey |	refKey := frameK asValidFrameReferenceOrNil.	^ refKey notNil and: 		[	value coastIsValidRPCArgument and: 				[	self clusterManagerFrom: frameK.					super atKey: refKey includes: value				]		]</body><body package="COCellValueHolder">coastCompactValueRangeFor: key value: value 	| range min max |	range := self coastCompactKeyRangeFor: key.	^ range size &lt; 1 		ifTrue: [ range ]		ifFalse: 		[	min := values coastMinIndexForInserting: value min: range first max: range last.			min &gt; range last 				ifTrue: [ min to: range last ]				ifFalse: 				[	max := values coastMaxIndexForInserting: value min: min max: range last.					min to: max				]		]</body><body package="COCellValueHolder">coastTotalByteSize	^ super coastTotalByteSize		+ values coastTotalByteSize</body><body package="COCellValueHolder">compactIndexForKey: aKey value: aValue 	^ super compactIndexForKey: aKey asCompactArgument value: aValue</body><body package="COCellValueHolder">do: aBlock 	self referencesElementsCursorDo: [: assoc | aBlock value: assoc value ].</body><body package="COCellValueHolder">fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	^ self basicFromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive</body><body package="COCellValueHolder">includesKey: frame 	| frameReference |	frameReference := frame asValidFrameReferenceOrNil.	^ frameReference notNil and: [ self includesFrameReference: frameReference ]</body></methods><methods><class-id>COAST.CompactKeyIndex</class-id> <category>private</category><body package="COCellValueHolder">at: index putLocator: assoc classIndex: classIndex 	super at: index putLocator: assoc key classIndex: classIndex.	self valuesAt: index put: assoc value</body><body package="COCellValueHolder">basicAppendAll: otherCompactCollections 	| subCollections |	super basicAppendAll: otherCompactCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | anotherCompactCollection values ].	values := values coastOptimizedAppendAll: subCollections.</body><body package="COCellValueHolder">basicGrowBy: anInteger 	super basicGrowBy: anInteger.	values := values coastOptimizedGrownBy: anInteger.</body><body package="COCellValueHolder">binarySearchMinKey: frameReference 	^ self validIndexOfReference: frameReference ifAbsent: [: indexNotFound | nil ]</body><body package="COCellValueHolder">coastCompactKeyRangeFor: key 	| min max |	max := clusterIDs size.	min := self binarySearchMinClusterID: key clusterID frameID: key frameID ifAbsent: [: index | ^ index to: 0 ].	max := self binarySearchMaxClusterID: key clusterID frameID: key frameID min: min.	^ min to: max</body><body package="COCellValueHolder">compactAddLastKey: key value: value index: index 	self compactAddLast: key index: index.	values at: index put: value.</body><body package="COCellValueHolder">compactKeyAtIndex: index 	^ self basicFrameRefAtIndex: index</body><body package="COCellValueHolder">compactKeyAtIndex: index into: assoc 	self basicFrameRefAtIndex: index into: assoc key.</body><body package="COCellValueHolder">compactValueAtIndex: index 	^ values at: index</body><body package="COCellValueHolder">compactValueAtIndex: index into: assoc 	| value |	value := values at: index.	assoc value: value.</body><body package="COCellValueHolder">defaultValueCursor	^ nil</body><body package="COCellValueHolder">initializeArraysSized: anInteger 	super initializeArraysSized: anInteger.	values := Array new: anInteger</body><body package="COCellValueHolder">insertionIndexOfKey: keyReference 	^ self validIndexOfReference: keyReference ifAbsent: [: indexNotFound | indexNotFound ]</body><body package="COCellValueHolder">keys	self compact.	^( CompactRPCResultCollection new )		clusterIDs: clusterIDs copy frameIDs: frameIDs copy classIndices: classIndices copy frameClassArray: frameClassArray copy;		clusterManager: clusterManager;		yourself</body><body package="COCellValueHolder">values	self compact.	^ values</body><body package="COCellValueHolder">valuesAt: index put: value 	values at: index put: value</body></methods><methods><class-id>COAST.CompactKeyIndex</class-id> <category>compact</category><body package="COCellValueHolder">transformWith: transformation from: original 	values transformWith: transformation from: original valuesForCompact.	super transformWith: transformation from: original.</body><body package="COCellValueHolder">valuesForCompact	^ values</body></methods><methods><class-id>COAST.CompactKeyIndex</class-id> <category>copying</category><body package="COCellValueHolder">cropFrom: start to: stop	super cropFrom: start to: stop.	values := values copyFrom: start to: stop</body></methods><methods><class-id>COAST.CompactKeyIndex</class-id> <category>system primitives</category><body package="COCellValueHolder">isImmutable: aBoolean 	"frameIDs etc are not supposed to be modified"	super isImmutable: aBoolean.	values isImmutable: aBoolean.</body></methods><methods><class-id>COAST.CompactKeyIndex</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryValueTo: aStream marshaller: aCatRMMarshall 	super marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.	self marshallValuesTo: aStream marshaller: aCatRMMarshall forCluster: nil.</body><body package="COMarshalling">marshallValuesTo: aStream marshaller: aCatRMMarshall forCluster: aCluster 	aCatRMMarshall optimizedMarshall: values to: aStream.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	super unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.	self unmarshallValuesFrom: aStream marshaller: aCatRMMarshall forCluster: nil morph: morphSelector.</body><body package="COMarshalling">unmarshallValuesFrom: aStream marshaller: aCatRMMarshall forCluster: aCluster morph: morphSelector 	aCatRMMarshall optimizedUnmarshall: values from: aStream morph: morphSelector.</body></methods><methods><class-id>COAST.CatCSSet</class-id> <category>experimental</category><body package="COCellValueHolder">coastAsSet	^value copy</body></methods><methods><class-id>COAST.CatCSSet</class-id> <category>initialize - release</category><body package="COCellValueHolder">initializeWithSize: anInteger	self value: (self valueClass new: ((anInteger * 4 // 3) max: 3)).</body></methods><methods><class-id>COAST.CatCSSet</class-id> <category>accessing</category><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue 	self frame: frame atCollectionSlotNamed: slotName replace: oldValue with: newValue</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	frame at: slotName add: addedFrame</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	frame at: slotName remove: removedFrame</body></methods><methods><class-id>COAST.CatCSSet</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall 	self value do: [: elem | elem valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall ].</body><body package="COMarshalling">index	^ 2</body></methods><methods><class-id>COAST.CatCSSet class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ Set</body></methods><methods><class-id>COAST.CatCSSet class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#set</body></methods><methods><class-id>COAST.CatCSSet class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^2</body></methods><methods><class-id>COAST.CatCSProxyIndex</class-id> <category>accessing</category><body package="COCellValueHolder">at: elementIndex 	^ self value atIndex: elementIndex</body><body package="COCellValueHolder">atKey: key 	^ self value atKey: key</body><body package="COCellValueHolder">atKey: aKey includes: aValue	^self value atKey: aKey includes: aValue</body><body package="COCellValueHolder">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	^ self value atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize</body><body package="COCellValueHolder">atKeys: someKeys	^ self value atKeys: someKeys</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues	^ self value atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues</body><body package="COCellValueHolder">coastInternalAt: aKey add: aValue withAccess: access 	self prepareProxyAccess: access argumentsBlock: [ Array with: aKey with: aValue ].	^ self value atKey: aKey add: aValue</body><body package="COCellValueHolder">coastInternalAt: aKey remove: aValue withAccess: access 	self prepareProxyAccess: access argumentsBlock: [ Array with: aKey with: aValue ].	^ self value atKey: aKey remove: aValue ifAbsent: nil</body><body package="COCellValueHolder">copy	| copy |	copy := Index new.	self keysAndValuesDo: [: k : v | copy atKey: k add: v ].	^ copy</body><body package="COCellValueHolder">delegatingProxyClass	^ CatCSDelegatingProxyIndex.</body><body package="COCellValueHolder">depleteWith: access 	| frame |	self isEmpty ifTrue: [ ^ self ].	frame := access clusterManager getFrame: value frameID inCluster: value clusterID.	frame depleteProxy</body><body package="COCellValueHolder">directValuesDo: block 	"not supported here"</body><body package="COCellValueHolder">eachKeyIn: someKeys do: eachKeyBlock 	^self value eachKeyIn: someKeys do: eachKeyBlock</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue 	self frame: frame atKeyedSlotNamed: slotName replace: oldValue with: newValue</body><body package="COCellValueHolder">fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	^ self value fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive</body><body package="COCellValueHolder">includesKey: key 	^ self value includesKey: key</body><body package="COCellValueHolder">indexOf: assoc 	^ self valueFrame indexOf: assoc</body><body package="COFramesystem">insertionIndexOf: assoc 	^ self valueFrame insertionIndexOf: assoc</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	| key |	key := demon keyFor: addedFrame.	key notNil 		ifTrue: [ frame at: slotName atKey: key add: addedFrame ]		ifFalse: [ self error: 'can not invert' ]</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	| key |	key := demon keyFor: removedFrame.	key notNil 		ifTrue: [ frame at: slotName atKey: key remove: removedFrame ]		ifFalse: [ self error: 'can not invert' ]</body><body package="COCellValueHolder">keys	^ self value keys</body><body package="COCellValueHolder">keysDo: block 	^ self value keysDo: block</body><body package="COCellValueHolder">matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	^ self value matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize</body><body package="COCellValueHolder">selectKeys: someKeys whichInclude: aValue 	^ self value selectKeys: someKeys whichInclude: aValue</body><body package="COCellValueHolder">valueClass	^ Index</body><body package="COFramesystem">valueForArgs: args inVolume: volume 	^ args first isFrameOrFrameReference 		ifTrue: 		[	args last isFrameOrFrameReference 				ifTrue: [ CoastSegmentedIndex newInVolume: volume ]				ifFalse: [ CoastSegmentedKeyIndex newInVolume: volume ]		]		ifFalse: [ CoastSegmentedValueIndex newInVolume: volume ]</body><body package="COCellValueHolder">values	^ self value values</body></methods><methods><class-id>COAST.CatCSProxyIndex</class-id> <category>adapting</category><body package="COCellValueHolder">selfOrAdaptedCoastValueHolderToClass: valueHolderClass 	^ self</body></methods><methods><class-id>COAST.CatCSProxyIndex</class-id> <category>enumerating</category><body package="COCellValueHolder">associationsDo: block 	self value associationsDo: block.</body><body package="COCellValueHolder">keysAndValuesDo: aBlock 	^ self value keysAndValuesDo: aBlock</body></methods><methods><class-id>COAST.CatCSProxyIndex</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">groupedBy: aBlock 	| result |	result := Dictionary new.	self keysAndValuesDo: [: key : each | ( result at: ( aBlock value: each ) ifAbsentPut: [ Index new ]) atKey: key add: each ].	^ result</body></methods><methods><class-id>COAST.CatCSProxyIndex</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 12</body></methods><methods><class-id>COAST.CatCSProxyIndex class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#indexProxy</body><body package="COCellValueHolder">valueClass	^ Index</body><body package="COCellValueHolder">valueHolderIndex	^12</body></methods><methods><class-id>COAST.CatCSBag</class-id> <category>adapting</category><body package="COCellValueHolder">adaptedCoastValueHolderToClass: valueHolderClass 	^ valueHolderClass coastAdaptFromBag: self</body></methods><methods><class-id>COAST.CatCSBag</class-id> <category>accessing</category><body package="COCellValueHolder">add: anObject withOccurrences: anInteger	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">coastInternalAdd: anObject withOccurrences: anInteger	^value add: anObject withOccurrences: anInteger.</body><body package="COCellValueHolder">coastInternalRemoveAllOccurrencesOf: anObject	^value removeAllOccurrencesOf: anObject ifAbsent: [].</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue	self frame: frame atBagSlotNamed: slotName replace: oldValue with: newValue</body><body package="COCellValueHolder">numberOfKeys	^ self value numberOfKeys</body></methods><methods><class-id>COAST.CatCSBag</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">valuesAndCountsDo: block 	^ self iteratingDo: [ self value valuesAndCountsDo: block ]</body></methods><methods><class-id>COAST.CatCSBag</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 5</body></methods><methods><class-id>COAST.CatCSBag class</class-id> <category>adapting</category><body package="COCellValueHolder">coastAdaptFromBag: bagValueHolder 	^ ( self new )		coastAdaptCollection: bagValueHolder value;		yourself</body><body package="COCellValueHolder">coastAdaptFromSimpleCollection: bagValueHolder 	^ bagValueHolder</body></methods><methods><class-id>COAST.CatCSBag class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ Bag</body></methods><methods><class-id>COAST.CatCSBag class</class-id> <category>pragma</category><body package="COCellValueHolder">slotSymbol	^#bag</body><body package="COCellValueHolder">valueHolderIndex	^5</body></methods><methods><class-id>COAST.CatCSProxySet</class-id> <category>accessing</category><body package="COCellValueHolder">* collection 	^ self value * collection</body><body package="COCellValueHolder">coastInternalAdd: aKey withAccess: access 	self prepareProxyAccess: access argumentsBlock: [ Array with: aKey ].	self value add: aKey.	^ aKey</body><body package="COCellValueHolder">coastInternalRemove: aKey withAccess: access 	self prepareProxyAccess: access argumentsBlock: [ Array with: aKey ].	^ self value remove: aKey ifAbsent: nil</body><body package="COCellValueHolder">copy	^ Set withAll: self</body><body package="COCellValueHolder">delegatingProxyClass	^  CatCSDelegatingProxySet.</body><body package="COCellValueHolder">depleteWith: access 	| frame |	self isEmpty ifTrue: [ ^ self ].	frame := access clusterManager getFrame: value frameID inCluster: value clusterID.	frame depleteProxy</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue 	self frame: frame atCollectionSlotNamed: slotName replace: oldValue with: newValue</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	frame at: slotName add: addedFrame</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	frame at: slotName remove: removedFrame</body><body package="COCellValueHolder">valueClass	^ Set</body><body package="COFramesystem">valueForArgs: args inVolume: volume 	^ ( args allSatisfy: [: arg | arg isFrameOrFrameReference ]) 		ifTrue: [ CoastSegmentedSet newInVolume: volume ]		ifFalse: [ CoastSegmentedMixedSet newInVolume: volume ]</body></methods><methods><class-id>COAST.CatCSProxySet</class-id> <category>adapting</category><body package="COCellValueHolder">selfOrAdaptedCoastValueHolderToClass: valueHolderClass 	^ self</body></methods><methods><class-id>COAST.CatCSProxySet</class-id> <category>converting</category><body package="COCellValueHolder">asSet	^ Set withAll: self</body></methods><methods><class-id>COAST.CatCSProxySet</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 13</body></methods><methods><class-id>COAST.CatCSProxySet class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#setProxy</body><body package="COCellValueHolder">valueClass	^ Set</body><body package="COCellValueHolder">valueHolderIndex	^13</body></methods><methods><class-id>COAST.CompactRPCResultCollection</class-id> <category>utility - asSet</category><body package="COCellValueHolder">basicSwap: i with: j 	frameIDs swap: i with: j.	clusterIDs swap: i with: j.	classIndices swap: i with: j.</body><body package="COCellValueHolder">compareAt: i with: j 	| ci cj |	ci := clusterIDs at: i.	cj := clusterIDs at: j.	^ ci = cj 		ifTrue: [( frameIDs at: i ) &lt;= ( frameIDs at: j )]		ifFalse: [ ci &lt; cj ]</body><body package="COCellValueHolder">removeDuplicates	"i must be compact and sorted by cid/fid"	| newSize |	newSize := clusterIDs size.	clusterIDs size to: 2		by: -1		do: 		[: i | (( clusterIDs at: i - 1 ) = ( clusterIDs at: i ) and: [( frameIDs at: i - 1 ) = ( frameIDs at: i )]) ifTrue: 				[	"remove where we will not iterate again"					newSize := newSize - 1.					frameIDs coastOptimizedReplaceFrom: i to: newSize with: frameIDs startingAt: i + 1.					clusterIDs coastOptimizedReplaceFrom: i to: newSize with: clusterIDs startingAt: i + 1.					classIndices coastOptimizedReplaceFrom: i to: newSize with: classIndices startingAt: i + 1				]		].	newSize = clusterIDs size ifFalse: 		[	frameIDs := frameIDs copyFrom: 1 to: newSize.			clusterIDs := clusterIDs copyFrom: 1 to: newSize.			classIndices := classIndices copyFrom: 1 to: newSize		].</body><body package="COCellValueHolder">resortForSet	self compact.	self resortForSetFrom: 1 to: self size.</body><body package="COCellValueHolder">resortForSetFrom: i to: j 	"	frameIDs clusterIDs classIndices"	| ij k l n |	( n := j + 1 - i ) &lt;= 1 		ifTrue: [ ^ self ].	"Sort ci,cj."	( self compareAt: i with: j ) 		ifFalse: [ self basicSwap: i with: j ].	"i.e., should ci precede cj?"	n &gt; 2 		ifTrue: 		[	"More than two elements."			ij := ( i + j ) // 2.	"ij is the midpoint of i and j."			( self compareAt: i with: ij ) 				ifTrue: 				[( self compareAt: ij with: j ) 						ifFalse: 						[	"i.e., should cij precede cj?"							self basicSwap: j with: ij						]				]				ifFalse: 				[	"i.e. ci should come after cij"					self basicSwap: i with: ij				].	"i.e. should ci precede cij?"			n &gt; 3 				ifTrue: 				[	"More than three elements."					"Find k&gt;i and l&lt;j such that dk,dij,dl are in reverse order.			 Swap k and l.  Repeat this procedure until k and l pass each other."					k := i.					l := j.					[							[	l := l - 1.							k &lt;= l and: [ self compareAt: ij with: l ]						] whileTrue.	"i.e. while dl succeeds dij"						[	k := k + 1.							k &lt;= l and: [ self compareAt: k with: ij ]						] whileTrue.	"i.e. while dij succeeds dk"						k &lt;= l					] whileTrue: [ self basicSwap: k with: l ].					"Skip already sorted ranges."					[ k &lt; j and: [ self compareAt: k with: ij ]] whileTrue: [ k := k + 1 ].					"Now l&lt;k (either 1 or 2 less), and di through dl are all less than or equal to dk			 through dj.  Sort those two segments."					self resortForSetFrom: i to: l.					self resortForSetFrom: k to: j				]		].</body></methods><methods><class-id>COAST.CompactRPCResultCollection</class-id> <category>converting</category><body package="COCellValueHolder">asCoastValueHolder	^ ( COAST.CatCSCompactRPCResultCollection new )		value: self;		yourself</body><body package="COCellValueHolder">asRPCArguments	^ self coastAsSet</body><body package="COCellValueHolder">coastAsSortedValidKeys	^ self coastAsSet</body></methods><methods><class-id>COAST.CompactRPCResultCollection</class-id> <category>accessing</category><body package="COCellValueHolder">at: index 	self compact.	^ self compactElementAtIndex: index</body><body package="COCellValueHolder">binarySearchMinClusterID: cidSearch frameID: fidSearch ifAbsent: absentBlock 	"search the smallest index X where (( frameIDs at: X ) = fidSearch and: [( clusterIDs at: X ) = cidSearch ]) or nil"	"send absentBlock the potential index"	"this is not a binary search - but changing this method will have the smallest changeset for this class"	1 to: clusterIDs size do: [: i | (( clusterIDs at: i ) = cidSearch and: [( frameIDs at: i ) = fidSearch ]) ifTrue: [ ^ i ]].	^ absentBlock value: clusterIDs size + 1</body><body package="COCellValueHolder">coastAsSet	self compact.	^ ( self copy )		resortForSet;		removeDuplicates;		coastAsSetWithoutDuplicates	"do not use changeClassTo: "</body><body package="COCellValueHolder">coastAsSetWithoutDuplicates	"only needed for coastAsSet - no copy of instvars needed - this instance has no use after calling!!!"	self compact.	^ CompactSet new clusterIDs: clusterIDs frameIDs: frameIDs classIndices: classIndices frameClassArray: frameClassArray;		clusterManager: clusterManager;		yourself</body><body package="COCellValueHolder">journalIncludesReferencedElement: refElement	" *** This method was defined by COAST.CompactCollection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="COCellValueHolder">keysAndValuesDo: aBlock	| idx |	idx := 1.	self do: [ : elem | aBlock value: idx value: elem. idx := idx + 1 ].</body><body package="COCellValueHolder">occurrencesOf: frame	" *** This method was defined by COAST.CompactSimpleCollection as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="COCellValueHolder">referencesElementsCursorDo: aBlock 	| cursor toRemove |	toRemove := removedFrames copy.	cursor := self defaultCursor.	1 to: clusterIDs size		do: 		[: index | | dup |			self compactElementAtIndex: index into: cursor.			dup := toRemove notNil 					ifTrue: 					[	toRemove 							detect: [: x | x clusterID = cursor clusterID and: [ x frameID = cursor frameID ]]							ifNone: nil					]					ifFalse: [ nil ].			dup notNil 				ifTrue: [ toRemove remove: dup ]				ifFalse: [ aBlock value: cursor ]		].	addedFrames notNil ifTrue: [ addedFrames do: aBlock ].</body><body package="COCellValueHolder">removeRPCResult: frame 	self removedFramesAdd: frame.</body><body package="COCellValueHolder">simpleClass	^ OrderedCollection</body></methods><methods><class-id>COAST.CompactRPCResultCollection</class-id> <category>private</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSCompactRPCResultCollection new )		value: self;		yourself</body><body package="COCellValueHolder">initializeAddedFrames	addedFrames := OrderedCollection new.</body><body package="COCellValueHolder">initializeRemovedFrames	removedFrames := OrderedCollection new.</body></methods><methods><class-id>COAST.CatCSDelegatingProxySet</class-id> <category>private</category><body package="COCellValueHolder">* aSet 	| result probe |	result := self valueFrame * aSet.	probe := self uncleanedRemoved.	probe notNil ifTrue: [ result removeAll: probe ].	probe := self added.	probe notNil ifTrue: [ result addAll: probe ].	^ result</body><body package="COCellValueHolder">- aSet 	"Answer those elements present in the receiver and absent from aSet."	^ self reject: [: i | aSet includes: i ]</body><body package="COCellValueHolder">addedAdd: aValue 	| probe |	probe := self added.	probe isNil ifTrue: [ probe := self initializeAdded ].	probe add: aValue</body><body package="COCellValueHolder">addedIncludes: aValue 	| probe |	^ ( probe := self added ) notNil and: [ probe includes: aValue ]</body><body package="COCellValueHolder">addedRemove: aValue ifAbsent: absentBlock 	| probe |	( probe := self added ) isNil ifTrue: [ ^ absentBlock value ].	^ probe remove: aValue ifAbsent: absentBlock</body><body package="COCellValueHolder">coastInternalAdd: aValue 	^ self removedRemove: aValue ifAbsent: [( self valueFrameIncludes: aValue ) ifFalse: [ self addedAdd: aValue ]]</body><body package="COCellValueHolder">coastInternalRemove: aValue ifAbsent: absentBlock 	^ self addedRemove: aValue		ifAbsent: 		[( absentBlock isNil or: [ self valueFrameIncludes: aValue ]) 				ifTrue: 				[	self removedAdd: aValue dirty: absentBlock isNil.					aValue				]				ifFalse: [ absentBlock value ]		]</body><body package="COCellValueHolder">collectionType	^ Set</body><body package="COCellValueHolder">collectionTypeForCollect	^ Set</body><body package="COCellValueHolder">copy	| copy |	copy := Set new.	self do: [: aValue | copy add: aValue ].	^ copy</body><body package="COCellValueHolder">do: block 	"valueFrame must be realy loaded"	| added uncleanedRemoved |	( added := self added ) isNil ifFalse: [ added do: block ].	self valueFrameIsPresent ifFalse: [ ^ self ].	uncleanedRemoved := self uncleanedRemoved.	self valueFrame 		do: [: aValue | ( uncleanedRemoved notNil and: [ uncleanedRemoved includes: aValue ]) ifFalse: [ block value: aValue ]]</body><body package="COCellValueHolder">includes: aValue 	( self uncleanedRemovedIncludes: aValue ) ifTrue: [ ^ false ].	( self addedIncludes: aValue ) ifTrue: [ ^ true ].	^ self valueFrameIncludes: aValue</body><body package="COCellValueHolder">occurrencesOf: aValue 	^ ( self includes: aValue ) 		ifTrue: [ 1 ]		ifFalse: [ 0 ]</body><body package="COCellValueHolder">removedAdd: aValue 	| probe |	probe := self uncleanedRemoved.	probe isNil ifTrue: [ probe := self initializeRemoved ].	probe add: aValue</body><body package="COCellValueHolder">removedAdd: aValue dirty: dirty 	dirty ifTrue: [ self markRemovedAsDirty ].	^ self removedAdd: aValue</body><body package="COCellValueHolder">removedRemove: aValue ifAbsent: absentBlock 	| probe |	( probe := self removed ) isNil ifTrue: [ ^ absentBlock value ].	^ probe remove: aValue ifAbsent: absentBlock</body><body package="COCellValueHolder">uncleanedRemovedIncludes: aValue 	| probe |	^ ( probe := self uncleanedRemoved ) notNil and: [ probe includes: aValue ]</body><body package="COCellValueHolder">valueFrameIncludes: aValue 	aValue coastIsValidRPCArgument ifFalse: [ ^ false ].	^ self valuePerform: #includes: withArguments: ( Array with: aValue ) default: [ false ]</body></methods><methods><class-id>COAST.CatCSDelegatingProxySet</class-id> <category>private dirty remove</category><body package="COCellValueHolder">cleanRemoved: removed 	removed copy do: 		[: key | ( self valueFrameIncludes: key ) ifFalse: 				[	"not included in remote frame, not removed at all"					removed remove: key				]		]</body></methods><methods><class-id>COAST.CatCSDelegatingProxySet</class-id> <category>accessing</category><body package="COCellValueHolder">coastInternalAdd: aKey withAccess: access 	access transaction needsFlush: true.	self coastInternalAdd: aKey.	^ aKey</body><body package="COCellValueHolder">coastInternalRemove: aKey withAccess: access 	access transaction needsFlush: true.	^ self coastInternalRemove: aKey ifAbsent: nil</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue 	self frame: frame atCollectionSlotNamed: slotName replace: oldValue with: newValue</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	frame at: slotName add: addedFrame</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	frame at: slotName remove: removedFrame</body><body package="COCellValueHolder">referencesElementsCursorDo: block 	"elemente enumerieren, ohne resolving"	"lÃ¤stigerweise enthalten added und removed echte frames und keine refs"	| added removed |	( added := self added ) isNil ifFalse: 		[	added := added collect: 					[: e | | frameReference |						frameReference := e frameReferenceOrSelf.						block value: frameReference.						frameReference					]		].	self valueFrameIsPresent ifFalse: [ ^ self ].	removed := self removed.	removed notNil ifTrue: [ removed := removed collect: [: e | e frameReferenceOrSelf ]].	self valueFrame referencesElementsCursorDo: 		[: frameReference | (( added notNil and: [ added includes: frameReference ]) or: [ removed notNil and: [ removed includes: frameReference ]]) 				ifFalse: [ block value: frameReference ]		].</body><body package="COCellValueHolder">removeAccessFromAgenda: access 	self shouldNotImplement</body><body package="COCellValueHolder">selectValidRPCArguments	^ self valueAsSet</body><body package="COCellValueHolder">valueClass	^ Set</body><body package="COCellValueHolder">valueForArgs: args inVolume: volume 	^ nil</body></methods><methods><class-id>COAST.CatCSDelegatingProxySet</class-id> <category>converting</category><body package="COCellValueHolder">coastAsSet	^ self asSet</body></methods><methods><class-id>COAST.CatCSDelegatingProxySet</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 13</body></methods><methods><class-id>COAST.CatCSProxyBag</class-id> <category>adapting</category><body package="COCellValueHolder">selfOrAdaptedCoastValueHolderToClass: valueHolderClass 	^ self</body></methods><methods><class-id>COAST.CatCSProxyBag</class-id> <category>accessing</category><body package="COCellValueHolder">* collection 	^ self value * collection</body><body package="COCellValueHolder">coastInternalAdd: aKey withAccess: access 	self prepareProxyAccess: access argumentsBlock: [ Array with: aKey ].	self value add: aKey.	^ aKey</body><body package="COCellValueHolder">coastInternalRemove: aKey withAccess: access 	self prepareProxyAccess: access argumentsBlock: [ Array with: aKey ].	^ self value remove: aKey ifAbsent: nil</body><body package="COCellValueHolder">copy	| copy |	copy := Bag new.	self valuesAndCountsDo: [: val : count | copy add: val withOccurrences: count ].	^ copy</body><body package="COCellValueHolder">delegatingProxyClass	^ CatCSDelegatingProxyBag.</body><body package="COCellValueHolder">depleteWith: access 	| frame |	self isEmpty ifTrue: [ ^ self ].	frame := access clusterManager getFrame: value frameID inCluster: value clusterID.	frame depleteProxy.</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue	self frame: frame atBagSlotNamed: slotName replace: oldValue with: newValue</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	( frame at: slotName includes: addedFrame ) ifFalse: [ frame at: slotName add: addedFrame ]</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	frame at: slotName remove: removedFrame</body><body package="COCellValueHolder">valueClass	^ Bag</body><body package="COFramesystem">valueForArgs: args inVolume: volume 	^ CoastSegmentedBag newInVolume: volume</body><body package="COCellValueHolder">valuesAndCountsDo: block 	^ self value valuesAndCountsDo: block</body></methods><methods><class-id>COAST.CatCSProxyBag</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 15</body></methods><methods><class-id>COAST.CatCSProxyBag class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#bagProxy</body><body package="COCellValueHolder">valueClass	^ Bag</body><body package="COCellValueHolder">valueHolderIndex	^15</body></methods><methods><class-id>COAST.CatCSProxyDictionary</class-id> <category>accessing</category><body package="COCellValueHolder">atKey: key 	^ self value atKey: key</body><body package="COCellValueHolder">atKeys: someKeys	^ self value atKeys: someKeys</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues	^ self value atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues</body><body package="COCellValueHolder">coastInternalAt: aKey put: aValue withAccess: access 	self prepareProxyAccess: access argumentsBlock: [ Array with: aKey with: aValue ].	^ self value atKey: aKey put: aValue</body><body package="COCellValueHolder">coastInternalRemoveKey: aKey withAccess: access 	self prepareProxyAccess: access argumentsBlock: [ Array with: aKey with: '' ].	^ self value removeKey: aKey ifAbsent: nil</body><body package="COCellValueHolder">copy	| copy |	copy := Dictionary new.	self keysAndValuesDo: [: key : aValue | copy at: key put: aValue ].	^ copy</body><body package="COCellValueHolder">delegatingProxyClass	^  CatCSDelegatingProxyDictionary.</body><body package="COCellValueHolder">depleteWith: access 	| frame |	self isEmpty ifTrue: [ ^ self ].	frame := access clusterManager getFrame: value frameID inCluster: value clusterID.	frame depleteProxy</body><body package="COCellValueHolder">eachKeyIn: someKeys do: eachKeyBlock 	^self value eachKeyIn: someKeys do: eachKeyBlock</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue 	self frame: frame atKeyedSlotNamed: slotName replace: oldValue with: newValue</body><body package="COCellValueHolder">includesKey: key 	^ self value includesKey: key</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	| key |	key := demon keyFor: addedFrame.	key notNil 		ifTrue: [ frame at: slotName atKey: key put: addedFrame ]		ifFalse: [ self error: 'can not invert' ]</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	| key |	key := demon keyFor: removedFrame.	key notNil 		ifTrue: [( frame at: slotName atKey: key ) = removedFrame ifTrue: [ frame at: slotName removeKey: key ]]		ifFalse: [ self error: 'can not invert' ]</body><body package="COCellValueHolder">keys	^ self value keys</body><body package="COCellValueHolder">keysDo: block 	^ self value keysDo: block</body><body package="COCellValueHolder">valueClass	^ Dictionary</body><body package="COFramesystem">valueForArgs: args inVolume: volume 	^ args last isFrameOrFrameReference 			ifTrue: [ CoastSegmentedDictionary newInVolume: volume ]			ifFalse: [ CoastSegmentedKeyDictionary newInVolume: volume ]</body><body package="COCellValueHolder">values	^ self value values</body></methods><methods><class-id>COAST.CatCSProxyDictionary</class-id> <category>enumerating</category><body package="COCellValueHolder">associationsDo: aBlock 	^ self value associationsDo: aBlock</body><body package="COCellValueHolder">keysAndValuesDo: aBlock 	^ self value keysAndValuesDo: aBlock</body></methods><methods><class-id>COAST.CatCSProxyDictionary</class-id> <category>adapting</category><body package="COCellValueHolder">selfOrAdaptedCoastValueHolderToClass: valueHolderClass 	^ self</body></methods><methods><class-id>COAST.CatCSProxyDictionary</class-id> <category>compatibility</category><body package="COCellValueHolder">compactElementAtIndex: index 	^ self value compactElementAtIndex: index</body></methods><methods><class-id>COAST.CatCSProxyDictionary</class-id> <category>compact</category><body package="COCellValueHolder">compact	"nothing to do"</body></methods><methods><class-id>COAST.CatCSProxyDictionary</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">groupedBy: aBlock 	| result |	result := Dictionary new.	self keysAndValuesDo: [: key : each | ( result at: ( aBlock value: each ) ifAbsentPut: [ Dictionary new ]) at: key put: each ].	^ result</body></methods><methods><class-id>COAST.CatCSProxyDictionary</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 14</body></methods><methods><class-id>COAST.CatCSProxyDictionary class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#proxyDictionary</body><body package="COCellValueHolder">valueClass	^ Dictionary</body><body package="COCellValueHolder">valueHolderIndex	^14</body></methods><methods><class-id>COAST.CompactValueIndex</class-id> <category>private</category><body package="COFramesystem">addedAtKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result 	addedFrames notNil ifTrue: [ addedFrames atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result ].</body><body package="COCellValueHolder">addedKeysIncludes: key 	^ addedFrames notNil and: [ addedFrames includesKey: key ]</body><body package="COFramesystem">addedMatchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize 	addedFrames notNil ifTrue: [ addedFrames matchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize ].</body><body package="COCellValueHolder">at: index putLocator: assoc classIndex: classIndex 	super at: index putLocator: assoc value classIndex: classIndex.	keys at: index put: assoc key</body><body package="COCellValueHolder">basicAppendAll: otherCompactCollections 	| subCollections |	super basicAppendAll: otherCompactCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | anotherCompactCollection keys ].	keys := keys coastOptimizedAppendAll: subCollections.</body><body package="COCellValueHolder">basicGrowBy: size 	super basicGrowBy: size.	keys := keys coastOptimizedGrownBy: size.</body><body package="COCellValueHolder">binarySearchMinKey: keySearch 	"search the smallest index X where (( keys at: X ) = key or nil"	| index |	index := self insertionIndexOfKey: keySearch.	^ ( keys size &gt;= index and: [( keys at: index ) = keySearch ]) 		ifTrue: [ index ]		ifFalse: [ nil ]</body><body package="COCellValueHolder">coastCompactKeyRangeFor: key 	^ keys coastKeyRangeFor: key</body><body package="COFramesystem">compactAddLastKey: key value: value index: index 	self compactAddLast: value index: index.	keys at: index put: key</body><body package="COCellValueHolder">compactKeyAtIndex: index 	^  keys at: index</body><body package="COCellValueHolder">compactKeyAtIndex: index into: assoc 	| key |	key := keys at: index.	assoc key: key.</body><body package="COCellValueHolder">compactKeyRangeFrom: startKeyOrNil to: stopKeyOrNil inclusive: inclusive	| startIndex stopIndex max temp |	startIndex := startKeyOrNil notNil 			ifTrue: 			[	inclusive 					ifTrue: [ keys coastMinIndexForInserting: startKeyOrNil ]					ifFalse: [( keys coastMaxIndexForInserting: startKeyOrNil ) + 1 ]			]			ifFalse: [ 1 ].	max := keys size.	stopIndex := stopKeyOrNil notNil 			ifTrue: 			[	temp := inclusive 					ifTrue: [ keys coastMaxIndexForInserting: stopKeyOrNil ]					ifFalse: [( keys coastMinIndexForInserting: stopKeyOrNil ) - 1 ].				temp min: max.			]			ifFalse: [ max ].	^ startIndex to: stopIndex</body><body package="COCellValueHolder">compactValueAtIndex: index 	^ CatFSFrameReference clusterID: ( clusterIDs at: index )		id: ( frameIDs at: index )		classSymbol: ( self classAtIndex: index )</body><body package="COCellValueHolder">compactValueAtIndex: index into: assoc 	| frameReference |	frameReference := assoc value.	frameReference clusterID: ( clusterIDs at: index ).	frameReference id: ( frameIDs at: index ).	frameReference frameClassSymbol: ( self classAtIndex: index ).</body><body package="COCellValueHolder">defaultKeyCursor	^ nil</body><body package="COCellValueHolder">initializeArraysSized: size 	super initializeArraysSized: size.	keys := Array new: size</body><body package="COCellValueHolder">insertionIndexOfKey: keySearch 	"search the smallest index X where (( keys at: X ) &lt;= key "	^ keys coastMinIndexForInserting: keySearch</body><body package="COCellValueHolder">keys	self compact.	^ keys</body><body package="COCellValueHolder">removedKeysIncludes: key 	^ removedFrames notNil and: [ removedFrames includesKey: key ]</body></methods><methods><class-id>COAST.CompactValueIndex</class-id> <category>accessing</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSCompactValueIndex new )		value: self;		yourself</body><body package="COCellValueHolder">atCompactKey: key includes: value 	^super atCompactKey: key includes: value asCompactArgument</body><body package="COCellValueHolder">atIndex: index 	| assoc value |	assoc := super atIndex: index.	assoc isNil ifTrue: [ ^ nil ].	value := clusterManager resolveFrameReference: assoc value.	^ assoc key -&gt; value</body><body package="COCellValueHolder">atKey: key add: valueFrame 	| valueRef |	self clusterManagerFrom: valueFrame.	valueRef := valueFrame asCompactArgument.	( self atKey: key includes: valueRef ) ifFalse: [ self addedFramesAdd: key -&gt; valueRef ].	^ valueFrame</body><body package="COCellValueHolder">atKey: key includes: frameV 	| refValue |	refValue := frameV asValidFrameReferenceOrNil.	^ key coastIsValidRPCArgument and: 		[	refValue notNil and: 				[	self clusterManagerFrom: frameV.					super atKey: key includes: refValue				]		]</body><body package="COFramesystem">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| min max result |	result := CompactRPCResultCollection clusterManager: self clusterManager.	self addedAtKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result.	( maxSize isNil or: [ result size &lt; maxSize ]) 		ifTrue: 		[	min := keys coastMinIndexForInserting: ( keyPattern coastAsPatternPrefixIgnoreCase: ignoreCase ).			max := keys size min: ( keys coastMinIndexForInserting: ( keyPattern coastAsPostPatternPrefixIgnoreCase: ignoreCase )).			( min to: max ) do: 				[: index | | key |					key := keys at: index.					( keyPattern coastMatch: key ignoreCase: ignoreCase ) 						ifTrue: 						[ | valueRef |							valueRef := self compactValueAtIndex: index.							( self removedElementsAtKey: key includes: valueRef ) 								ifFalse: 								[	result add: valueRef.									( maxSize notNil and: [ result size &gt;= maxSize ]) 										ifTrue: [ ^ result ]								]						]				]		].	^ result</body><body package="COCellValueHolder">classIndexFor: assoc 	^ self basicClassIndexFor: assoc value</body><body package="COCellValueHolder">coastCompactValueRangeFor: key value: value  	| range min max |	range := self coastCompactKeyRangeFor: key.	^ range isEmpty 		ifTrue: [ range ]		ifFalse: 		[	min := self binarySearchMinClusterID: value clusterID frameID: value frameID min: range first max: range last ifAbsent: [: index | ^ index to: 0 ].			max := self binarySearchMaxClusterID: value clusterID frameID: value frameID min: min max: range last ifAbsent: [: index | ^ index to: 0 ].			min to: max		]</body><body package="COCellValueHolder">coastTotalByteSize	^ super coastTotalByteSize		+ keys coastTotalByteSize</body><body package="COCellValueHolder">compactIndexForKey: aKey value: aValue 	^ super compactIndexForKey: aKey value: aValue asCompactArgument</body><body package="COCellValueHolder">includesKey: key 	^ ( self addedKeysIncludes: key ) or: 		[( self removedKeysIncludes: key ) 				ifTrue: [ false ]				ifFalse: [( self binarySearchMinKey: key ) notNil ]		]</body><body package="COCellValueHolder">keysDo: aBlock 	"No need to convert/copy cursors because keys are no frame references"	self referencesElementsCursorDo: [: assoc | aBlock value: assoc key ].</body><body package="COFramesystem">matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| min max result limit |	result := CompactValueIndex clusterManager: self clusterManager.	self addedMatchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize.	limit := maxSize.	maxSize notNil ifTrue: [ limit := maxSize + result size ].	min := keys coastMinIndexForInserting: ( keyPattern coastAsPatternPrefixIgnoreCase: ignoreCase ).	max := keys size min: ( keys coastMinIndexForInserting: ( keyPattern coastAsPostPatternPrefixIgnoreCase: ignoreCase )).	( min to: max ) do: 		[: index | | key |			( limit isNil or: [ result size &lt; limit ]) ifTrue: 				[	key := keys at: index.					( keyPattern coastMatch: key ignoreCase: ignoreCase ) ifTrue: 						[ | valueRef |							valueRef := self compactValueAtIndex: index.							( self removedElementsAtKey: key includes: valueRef ) ifFalse: [ result atKey: key add: valueRef ]						]				]		].	^ result limitToSize: maxSize</body><body package="COCellValueHolder">removeKey: key value: valueFrame ifAbsent: block 	self clusterManagerFrom: valueFrame.	^ super removeKey: key value: valueFrame asCompactArgument ifAbsent: block</body><body package="COCellValueHolder">removedFramesAdd: assoc 	removedFrames isNil ifTrue: [ self initializeRemovedFrames ].	removedFrames add: assoc key -&gt; assoc value asCompactArgument.</body></methods><methods><class-id>COAST.CompactValueIndex</class-id> <category>compact</category><body package="COCellValueHolder">keysForCompact	^ keys</body><body package="COCellValueHolder">transformWith: transformation from: original 	keys transformWith: transformation from: original keysForCompact.	super transformWith: transformation from: original.</body></methods><methods><class-id>COAST.CompactValueIndex</class-id> <category>copying</category><body package="COCellValueHolder">cropFrom: start to: stop	super cropFrom: start to: stop.	keys := keys copyFrom: start to: stop</body></methods><methods><class-id>COAST.CompactValueIndex</class-id> <category>marshalling</category><body package="COCellValueHolder">marshallBinaryValueTo: aStream marshaller: aCatRMMarshall 	super marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.	self marshallKeysTo: aStream marshaller: aCatRMMarshall forCluster: nil.</body><body package="COMarshalling">marshallKeysTo: aStream marshaller: aCatRMMarshall forCluster: aCluster 	aCatRMMarshall optimizedMarshall: keys to: aStream.</body><body package="COCellValueHolder">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	super unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.	self unmarshallKeysFrom: aStream marshaller: aCatRMMarshall forCluster: nil morph: morphSelector.</body><body package="COMarshalling">unmarshallKeysFrom: aStream marshaller: aCatRMMarshall forCluster: aCluster morph: morphSelector 	aCatRMMarshall optimizedUnmarshall: keys from: aStream morph: morphSelector.</body></methods><methods><class-id>COAST.CompactValueIndex</class-id> <category>system primitives</category><body package="COCellValueHolder">isImmutable: aBoolean 	"frameIDs etc are not supposed to be modified"	super isImmutable: aBoolean.	keys isImmutable: aBoolean.</body></methods><methods><class-id>COAST.CatCSDelegatingProxyIndex</class-id> <category>private</category><body package="COCellValueHolder">addedAtKey: key 	| probe |	^ ( probe := self added ) isNil 		ifTrue: [ #( )]		ifFalse: [ probe atKey: key ]</body><body package="COCellValueHolder">addedAtKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result 	| probe |	probe := self added.	probe notNil ifTrue: [ probe atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result ].</body><body package="COCellValueHolder">addedFromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive	| probe |	^ ( probe := self added ) isNil 		ifTrue: [ #( )]		ifFalse: [ probe fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive ]</body><body package="COCellValueHolder">addedIndexForKey: key value: aValue 	| probe |	^ ( probe := self added ) isNil 		ifTrue: [ 1 ]		ifFalse: [ probe indexForKey: key value: aValue ]</body><body package="COCellValueHolder">addedKey: key add: aValue 	| probe |	probe := self added.	probe isNil ifTrue: [ probe := self initializeAdded ].	probe atKey: key add: aValue</body><body package="COCellValueHolder">addedKey: key includes: aValue 	| probe |	^ ( probe := self added ) notNil and: [ probe atKey: key includes: aValue ]</body><body package="COCellValueHolder">addedKey: key remove: aValue ifAbsent: absentBlock 	| probe |	( probe := self added ) isNil ifTrue: [ ^ absentBlock value ].	^ probe atKey: key remove: aValue ifAbsent: absentBlock</body><body package="COCellValueHolder">addedMatchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize 	| probe |	probe := self added.	probe notNil ifTrue: [ probe matchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize ].</body><body package="COCellValueHolder">addedSelectKeys: key whichInclude: aValue 	| probe |	probe := self added.	^ probe isNil 		ifTrue: [ #()]		ifFalse: [ probe selectKeys: key whichInclude: aValue ]</body><body package="COCellValueHolder">at: index 	| added removed modified countDiff |	added := self added.	removed := self removed.	( added isNil and: [ removed isNil ]) ifTrue: [ ^ self valueFrameAtIndex: index ].	modified := Index new.	added notNil ifTrue: [ added keysAndValuesDo: [: rKey : rValue | modified atKey: rKey add: rValue ]].	removed notNil ifTrue: [ removed keysAndValuesDo: [: rKey : rValue | modified atKey: rKey add: rValue ]].	countDiff := 0.	modified keysAndValuesDo: 		[: mKey : mValue | | modifiedIndex |			modifiedIndex := self valueFrameIndexOfKey: mKey value: mValue.			modifiedIndex isNil ifTrue: [ modifiedIndex := self valueFrameSize + 1 ].			modifiedIndex + countDiff &gt; index ifTrue: [ ^ self valueFrameAtIndex: index - countDiff ].			( added notNil and: [ added atKey: mKey includes: mValue ]) 				ifTrue: 				[	modifiedIndex + countDiff = index ifTrue: [ ^ mKey -&gt; mValue ].					countDiff := countDiff + 1				]				ifFalse: [ countDiff := countDiff - 1 ]		].	^ self valueFrameAtIndex: index - countDiff</body><body package="COCellValueHolder">atKey: key includes: aValue 	( self removedKey: key includes: aValue ) ifTrue: [ ^ false ].	( self addedKey: key includes: aValue ) ifTrue: [ ^ true ].	^ self valueFrameAtKey: key includes: aValue</body><body package="COCellValueHolder">atKey: key remove: aValue 	^ self atKey: key remove: aValue ifAbsent: nil</body><body package="COCellValueHolder">atKey: key remove: aValue ifAbsent: absentBlock 	^ self addedKey: key		remove: aValue		ifAbsent: 		[( absentBlock isNil or: [ self valueFrameAtKey: key includes: aValue ]) 				ifTrue: 				[	( self removedKey: key includes: aValue ) ifTrue: [ ^ absentBlock value ].					self removedKey: key add: aValue dirty: absentBlock isNil.					aValue				]				ifFalse: [ absentBlock value ]		]</body><body package="COCellValueHolder">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| result sizeToAdd |	result := CompactRPCResultCollection clusterManager: self clusterManager.	self addedAtKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result.	maxSize notNil 		ifTrue: 		[	sizeToAdd := maxSize - result size.			sizeToAdd &gt; 0 				ifTrue: [ sizeToAdd := sizeToAdd + self removedSize ]				ifFalse: [ ^ result ]		]		ifFalse: [ sizeToAdd := nil ].	result compactAddAll: ( self valueFrameAtKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: sizeToAdd ).	( self removedAtKeyPattern: keyPattern ignoreCase: ignoreCase ) do: [: removedValue | result remove: removedValue ifAbsent: nil ].	^ ( maxSize notNil and: [ result size &gt; maxSize ]) 		ifTrue: [ result copyFrom: 1 to: maxSize ]		ifFalse: [ result ]</body><body package="COCellValueHolder">cleanRemoved: removed 	removed copy keysAndValuesDo: 		[: key : aValue | ( self valueFrameAtKey: key includes: aValue ) ifFalse: 				[	"not included in remote frame, not removed at all"					removed atKey: key remove: aValue				]		]</body><body package="COCellValueHolder">collectionType	^ Index</body><body package="COCellValueHolder">collectionTypeForCollect	^ OrderedCollection</body><body package="COCellValueHolder">copy	| copy |	copy := Index new.	self keysAndValuesDo: [: key : aValue | copy atKey: key add: aValue ].	^ copy</body><body package="COCellValueHolder">do: block 	self keysAndValuesDo: [: key : aValue | block value: aValue ]</body><body package="COCellValueHolder">fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	| result |	result := self valueFrameFromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive.	( self addedFromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive ) do: 		[: addedValue |			"( result includes: addedValue ) ifFalse: "			result add: addedValue		].	( self removedFromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive ) 		do: [: removedValue | result remove: removedValue ifAbsent: nil ].	^ result</body><body package="COCellValueHolder">hasAnyAdded	^ self added notNil</body><body package="COCellValueHolder">hasAnyRemoved	^ self uncleanedRemoved notNil</body><body package="COCellValueHolder">includesKey: key 	| removedElements |	( self addedAtKey: key ) do: [: addedValue | ^ true ].	removedElements := self removedAtKey: key.	^ removedElements isEmpty 		ifTrue: [ self valueFrameIncludesKey: key ]		ifFalse: [( self valueFrameAtKey: key ) contains: [: elem | ( removedElements includes: elem ) not ]]</body><body package="COCellValueHolder">keys	| keys |	keys := Set new.	self keysAndValuesDo: [: key : aValue | keys add: key ].	^ keys</body><body package="COCellValueHolder">matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| result limit |	result := CompactValueIndex clusterManager: self clusterManager.	limit := maxSize.	limit notNil ifTrue: [ self uncleanedRemoved ifNotNil: [: uncleanedRemoved | limit := maxSize + uncleanedRemoved size ]].	self addedMatchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: limit.	( self valueFrameMatchingPattern: keyPattern ignoreCase: ignoreCase maxSize: limit ) 		referencesElementsCursorDo: [: cursor | result addElement: cursor copyForRefCursor ].	( self removedAtKeyPattern: keyPattern ignoreCase: ignoreCase ) 		keysAndValuesDo: [: removedKey : removedValue | result atKey: removedKey remove: removedValue ifAbsent: nil ].	^ result limitToSize: maxSize</body><body package="COCellValueHolder">removedAtKey: key 	| probe |	^ ( probe := self uncleanedRemoved ) isNil 		ifTrue: [ #( )]		ifFalse: [ probe atKey: key ]</body><body package="COCellValueHolder">removedAtKeyPattern: keyPattern ignoreCase: anObject 	| probe |	^ ( probe := self removed ) isNil 		ifTrue: [ OrderedCollection new ]		ifFalse: [ probe atKeyPattern: keyPattern ignoreCase: true maxSize: nil ]</body><body package="COCellValueHolder">removedFromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive	| probe |	^ ( probe := self removed ) isNil 		ifTrue: [ #( )]		ifFalse: [ probe fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive ]</body><body package="COCellValueHolder">removedIndexForKey: key value: aValue 	| probe |	^ ( probe := self removed ) isNil 		ifTrue: [ 1 ]		ifFalse: [ probe indexForKey: key value: aValue ]</body><body package="COCellValueHolder">removedKey: key add: aValue 	| probe |	" wenn der key -&gt; value schon zu removed hinzugefÃ¼gt wurde,	macht es nichts, es noch mal zu hinzuzufÃ¼gen.	dagegen leidet die Performance, wenn man dauernd removed aufrÃ¤umt "	probe := self uncleanedRemoved.	probe isNil ifTrue: [ probe := self initializeRemoved ].	probe atKey: key add: aValue</body><body package="COCellValueHolder">removedKey: key add: aValue dirty: dirty 	dirty ifTrue: [ self markRemovedAsDirty ].	^ self removedKey: key add: aValue</body><body package="COCellValueHolder">removedKey: key includes: aValue 	| probe |	^ ( probe := self uncleanedRemoved ) notNil and: [ probe atKey: key includes: aValue ]</body><body package="COCellValueHolder">removedKey: key remove: aValue ifAbsent: absentBlock 	| probe |	( probe := self uncleanedRemoved ) isNil ifTrue: [ ^ absentBlock value ].	( probe atKey: key includes: aValue ) ifFalse: [ ^ absentBlock value ].	probe := self removed.	"must be clean now ..."	^ probe atKey: key remove: aValue ifAbsent: absentBlock</body><body package="COCellValueHolder">removedSelectKeys: keys whichInclude: aValue 	| probe |	probe := self removed.	^ probe isNil 		ifTrue: [ #()]		ifFalse: [ probe selectKeys: keys whichInclude: aValue ]</body><body package="COCellValueHolder">selectKeys: someKeys whichInclude: aValue 	| result toCheck badKeys sharedResult |	result := self addedSelectKeys: someKeys whichInclude: aValue.	badKeys := self removedSelectKeys: someKeys whichInclude: aValue.	toCheck := someKeys copy.	toCheck removeAll: result.	toCheck removeAll: badKeys.	sharedResult := self valueFrameSelectKeys: toCheck whichInclude: aValue.	result isEmpty ifTrue: [ ^ sharedResult ].	sharedResult isEmpty ifTrue: [ ^ result ].	result addAll: sharedResult.	^ someKeys isSequenceable 		ifTrue: [ someKeys mergeOrdered: result with: sharedResult ]		ifFalse: 		[	result addAll: sharedResult.			result		]</body><body package="COCellValueHolder">valueFrameAtIndex: index 	| arrayOrNil aKey aValue |	arrayOrNil := self valuePerform: #rpcAtIndex: withArguments: ( Array with: index ) default: [ ^ nil ].	arrayOrNil isNil ifTrue: [ ^ arrayOrNil ].	aKey := arrayOrNil first.	aValue := arrayOrNil last.	aKey isCoastPrimitiveValue ifFalse: [ aKey := self resolveFrameReference: aKey ].	aValue isCoastPrimitiveValue ifFalse: [ aValue := self resolveFrameReference: aValue ].	^ aKey -&gt; aValue</body><body package="COCellValueHolder">valueFrameAtKey: key 	| refs |	key coastIsValidRPCArgument ifFalse: [ ^ OrderedCollection new ].	refs := self valuePerform: #atKey: withArguments: ( Array with: key ) default: [ ^ OrderedCollection new ].	^ refs postRPCInitializeWith: self</body><body package="COCellValueHolder">valueFrameAtKey: key includes: aValue 	key coastIsValidRPCArgument ifFalse: [ ^ false ].	aValue coastIsValidRPCArgument ifFalse: [ ^ false ].	^ self valuePerform: #atKey:includes: withArguments: ( Array with: key with: aValue ) default: [ false ]</body><body package="COCellValueHolder">valueFrameAtKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| refs |	refs := self valuePerform: #atKeyPattern:ignoreCase:maxSize:			withArguments: ( Array with: keyPattern with: ignoreCase with: maxSize )			default: [ ^ OrderedCollection new ].	^ refs postRPCInitializeWith: self</body><body package="COCellValueHolder">valueFrameFromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	| refs |	refs := self valuePerform: #fromKey:toKey:inclusive:			withArguments: ( Array with: startKeyOrNil with: stopKeyOrNil with: inclusive )			default: [ ^ OrderedCollection new ].	^ refs postRPCInitializeWith: self</body><body package="COCellValueHolder">valueFrameIncludesKey: key 	key coastIsValidRPCArgument ifFalse: [ ^ false ].	^ self valuePerform: #includesKey: withArguments: ( Array with: key ) default: [ false ]</body><body package="COCellValueHolder">valueFrameIndexOfKey: key value: aValue 	| insertionIndex |	insertionIndex := self valuePerform: #rpcIndexOfKey:value: withArguments: ( Array with: key with: aValue ) default: [ 1 ].	^ insertionIndex</body><body package="COCellValueHolder">valueFrameMatchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| refs |	refs := self valuePerform: #matchingPattern:ignoreCase:maxSize:			withArguments: ( Array with: keyPattern with: ignoreCase with: maxSize )			default: [ ^ Index new ].	^ refs postRPCInitializeWith: self</body><body package="COCellValueHolder">valueFrameSelectKeys: keys whichInclude: aValue 	| result rpcKeys booleans |	result := OrderedCollection new.	aValue coastIsValidRPCArgument ifFalse: [ ^ result ].	rpcKeys := CatCSOrderedCollection new: keys size.	keys do: [: key | key coastIsValidRPCArgument ifTrue: [ rpcKeys coastInternalAddLast: key ]].	booleans := self valuePerform: #rpcSelectKeys:whichInclude:			withArguments: ( Array with: rpcKeys with: aValue )			default: [ ^ result ].	rpcKeys with: booleans do: [: key : boolean | boolean ifTrue: [ result add: key ]].	^ result</body><body package="COCellValueHolder">values	| values |	values := Set new.	self do: [: aValue | values add: aValue ].	^ values</body></methods><methods><class-id>COAST.CatCSDelegatingProxyIndex</class-id> <category>accessing</category><body package="COCellValueHolder">addedSize	| probe |	^ ( probe := self added ) isNil 		ifTrue: [ 0 ]		ifFalse: 		[ "compute the differences to the shared frame!"			| sum isDepleted |			sum := 0.			isDepleted := self isDepleted.			probe keysAndValuesDo: [: k : v | ( isDepleted not and: [ self valueFrameAtKey: k includes: v ]) ifFalse: [ sum := sum + 1 ]].			^ sum		]</body><body package="COCellValueHolder">associationsDo: block 	"valueFrame must be really loaded, added and removed must be empty/nil"	| addedProbe removedProbe |	addedProbe := self added.	removedProbe := self removed.	(addedProbe notNil or: [ removedProbe notNil ]) ifTrue: [ ^self keysAndValuesDo: [ : k : v | block value: k -&gt; v ] ].	self valueFrameIsPresent ifFalse: [ ^ self ].	self valueFrame associationsDo: block.</body><body package="COCellValueHolder">atKey: key 	| result |	result := self valueFrameAtKey: key.	( self addedAtKey: key ) do: [: addedValue | ( result includes: addedValue ) ifFalse: [ result add: addedValue ]].	( self removedAtKey: key ) do: [: removedValue | result remove: removedValue ifAbsent: nil ].	^ result</body><body package="COCellValueHolder">atKey: key add: aValue 	^ self removedKey: key remove: aValue ifAbsent: [ self addedKey: key add: aValue ]</body><body package="COCellValueHolder">atKeys: someKeys 	| remoteKeys result |	remoteKeys := someKeys coastAsSortedValidKeys.	remoteKeys isEmpty ifTrue: [ ^ Index new ].	result := self valueFrameAtKeys: someKeys.	self hasAnyAdded ifTrue:	[		remoteKeys do: 			[: key | ( self addedAtKey: key ) 					do: [: addedValue | ( result atKey: key includes: addedValue ) ifFalse: [ result atKey: key add: addedValue ]]			].	].	self hasAnyRemoved ifTrue:	[		remoteKeys 			do: [: key | ( self removedAtKey: key ) do: [: removedValue | result atKey: key remove: removedValue ifAbsent: nil ]].	].	^ result</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize	^ someKeys size &lt;= maxKeysSize		ifTrue: [ self atKeys: someKeys ]		ifFalse: [ self valueFrame atKeys: someKeys ]</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues 	^ someKeys size &lt;= maxKeysSize 		ifTrue: [( self atKeys: someKeys ) restrictToValues: rvalues ]		ifFalse: [ self valueFrame atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues ]</body><body package="COCellValueHolder">coastInternalAt: aKey add: aValue withAccess: access 	access transaction needsFlush: true.	^ self atKey: aKey add: aValue</body><body package="COCellValueHolder">coastInternalAt: aKey remove: aValue withAccess: access 	access transaction needsFlush: true.	^ self atKey: aKey remove: aValue ifAbsent: nil</body><body package="COCellValueHolder">eachKeyIn: someKeys do: eachKeyBlock 	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index. "	| result rpcKeys limit cleanedRemoved keysCheckAndPerformBlock added |	rpcKeys := someKeys selectValidRPCArguments.	rpcKeys isEmpty ifTrue: [ ^ self ].	cleanedRemoved := self removed.	keysCheckAndPerformBlock := cleanedRemoved notNil 			ifTrue: 			[				[: partResult |				partResult 						keysAndValuesDo: [: partialKey : partialValue | ( cleanedRemoved atKey: partialKey includes: partialValue ) ifFalse: [ eachKeyBlock value: partialKey ]]			]			]			ifFalse: [ [: partResult | partResult keysDo: eachKeyBlock ]].	( self isRPCPossible and: [ self slot allowRPCs ]) 		ifTrue: 		[	limit := 1024.			rpcKeys := rpcKeys asRPCArguments.			( rpcKeys partitionedBy: limit ) do: 				[: part | | partResult |					partResult := self valuePerform: #atKeys: withArguments: ( Array with: part asCoastValueHolder ) default: [ self collectionType new ].					keysCheckAndPerformBlock value: partResult				]		]		ifFalse: 		[	result := self valuePerform: #atKeys: withArguments: ( Array with: rpcKeys ) default: [ self collectionType new ].			keysCheckAndPerformBlock value: result		].	( added := self added ) notNil ifTrue: [ keysCheckAndPerformBlock value: ( added atKeys: rpcKeys )].</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue 	self frame: frame atKeyedSlotNamed: slotName replace: oldValue with: newValue</body><body package="COCellValueHolder">indexOf: assoc 	| dummy |	dummy := (self valueFrameIndexOfKey: assoc key value: assoc value) ifNil: [ 1 ].	dummy := dummy + ( self addedIndexForKey: assoc key value: assoc value ).	^ dummy - ( self removedIndexForKey: assoc key value: assoc value )</body><body package="COCellValueHolder">insertionIndexOf: assoc 	^ self indexOf: assoc</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	| key |	key := demon keyFor: addedFrame.	key notNil 		ifTrue: [ frame at: slotName atKey: key add: addedFrame ]		ifFalse: [ self error: 'can not invert' ]</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	| key |	key := demon keyFor: removedFrame.	key notNil 		ifTrue: [ frame at: slotName atKey: key remove: removedFrame ]		ifFalse: [ self error: 'can not invert' ]</body><body package="COCellValueHolder">removeAccessFromAgenda: access 	self shouldNotImplement</body><body package="COCellValueHolder">valueClass	^ Index</body><body package="COCellValueHolder">valueForArgs: args inVolume: volume 	^ nil</body></methods><methods><class-id>COAST.CatCSDelegatingProxyIndex</class-id> <category>enumerating</category><body package="COCellValueHolder">keysAndValuesDo: block 	"valueFrame must be realy loaded"	| probe |	( probe := self added ) isNil ifFalse: [ probe keysAndValuesDo: block ].	self valueFrameIsPresent ifFalse: [ ^ self ].	self valueFrame keysAndValuesDo: 		[: key : aValue | (( self addedKey: key includes: aValue ) or: [ self removedKey: key includes: aValue ]) 				ifFalse: [ block value: key value: aValue ]		]</body><body package="COCellValueHolder">keysDo: block 	self keysAndValuesDo: [: key : aValue | block value: key ]</body><body package="COCellValueHolder">referencesElementsCursorDo: block 	"elemente enumerieren, ohne resolving"	"lÃ¤stigerweise enthalten added und removed ggf. echte frames und keine refs"	| added removed skipUnresolved |	( added := self added ) isNil ifFalse: 		[	skipUnresolved := Index new: added size.			added keysAndValuesDo: 				[: k : v | | frK frV |					frK := k frameReferenceOrSelf.					frV := v frameReferenceOrSelf.					skipUnresolved atKey: frK add: frV.					block value: frK -&gt; frV				]		].	self valueFrameIsPresent ifFalse: [ ^ self ].	removed := self uncleanedRemoved.	removed notNil ifTrue: 		[	skipUnresolved isNil ifTrue: [ skipUnresolved := Index new: removed size ].			removed keysAndValuesDo: [: k : v | skipUnresolved atKey: k frameReferenceOrSelf add: v frameReferenceOrSelf ]		].	self valueFrame referencesElementsCursorDo: 		[: assoc | ( skipUnresolved notNil and: [ skipUnresolved atKey: assoc key includes: assoc value ]) ifFalse: [ block value: assoc ]		].</body></methods><methods><class-id>COAST.CatCSDelegatingProxyIndex</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">groupedBy: aBlock 	| result |	result := Dictionary new.	self keysAndValuesDo: [: key : each | ( result at: ( aBlock value: each ) ifAbsentPut: [ Index new ]) atKey: key add: each ].	^ result</body></methods><methods><class-id>COAST.CatCSDelegatingProxyIndex</class-id> <category>testing</category><body package="COCellValueHolder">includes: assoc 	^( assoc coastIsAssociation and: [ self atKey: assoc key includes: assoc value ])</body><body package="COCellValueHolder">occurrencesOf: assoc 	^ ( self includes: assoc ) 		ifTrue: [ 1 ]		ifFalse: [ 0 ]</body></methods><methods><class-id>COAST.CatCSDelegatingProxyIndex</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 12</body></methods><methods><class-id>COAST.CatCSSequenceableCollection</class-id> <category>accessing</category><body package="COCellValueHolder">add: anObject after: oldObject	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">add: anObject before: oldObject	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">add: anObject beforeIndex: anIndex	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">addFirst: anObject	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">addLast: anObject	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">after: anObject	^value after: anObject.</body><body package="COCellValueHolder">at: index	^value at: index.</body><body package="COCellValueHolder">atIndex: index	self haltOrContinue: 'Achtung SequenceableCollection&gt;&gt;atIndex: ist nicht Teil von ST-Core'.	^value atIndex: index</body><body package="COCellValueHolder">before: anObject	^value before: anObject.</body><body package="COCellValueHolder">coastInternalAddFirst: anObject	^value addFirst: anObject.</body><body package="COCellValueHolder">coastInternalAddLast: anObject	^value addLast: anObject.</body><body package="COCellValueHolder">coastInternalAt: index put: anObject	^value at: index put: anObject.</body><body package="COCellValueHolder">coastInternalRemove: oldObject withAccess: access 	self shouldNotImplement</body><body package="COCellValueHolder">coastInternalRemoveFirst	^value removeFirst.</body><body package="COCellValueHolder">coastInternalRemoveLast	^value removeLast.</body><body package="COCellValueHolder">coastMaxIndexForInserting: anObject 	^ self value coastMaxIndexForInserting: anObject</body><body package="COCellValueHolder">coastMaxIndexForInserting: anObject min: min max: max 	^ self value coastMaxIndexForInserting: anObject min: min max: max</body><body package="COCellValueHolder">coastMinIndexForInserting: anObject 	^ self value coastMinIndexForInserting: anObject</body><body package="COCellValueHolder">coastMinIndexForInserting: anObject min: min max: max 	^ self value coastMinIndexForInserting: anObject min: min max: max</body><body package="COCellValueHolder">copyFrom: startIndex to: endIndex	^ value copyFrom: startIndex to: endIndex</body><body package="COCellValueHolder">first	^value first</body><body package="COCellValueHolder">firstOrNil	^value firstOrNil</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue 	( frame at: slotName ) copy keysAndValuesDo: 		[: index : slotValue |			slotValue = oldValue 				ifTrue: [ frame at: slotName atIndex: index put: newValue ]		].</body><body package="COCellValueHolder">indexOf: anObject	^value indexOf: anObject ifAbsent:[].</body><body package="COCellValueHolder">last	^value last</body><body package="COCellValueHolder">removeAtIndex: anIndex	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">removeFirst	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">removeLast	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">reverse	^ self value reverse</body><body package="COCellValueHolder">selectValidRPCArguments	^self value selectValidRPCArguments</body></methods><methods><class-id>COAST.CatCSSequenceableCollection</class-id> <category>testing</category><body package="COCellValueHolder">isSequenceable	"Answers true."	^true</body></methods><methods><class-id>COAST.CatCSSequenceableCollection</class-id> <category>experimental</category><body package="COCellValueHolder">reverseDo: aBlock	^self iteratingDo: [ value reverseDo: aBlock ]</body><body package="COCellValueHolder">startingAt: repStart replaceElementsIn: collection from: start to: stop	^ self value 		startingAt: repStart		replaceElementsIn: collection		from: start		to: stop</body><body package="COCellValueHolder">with: aSequenceableCollection do: aBlock 	"Evaluate aBlock with each of the receiver's elements along with the corresponding	element from aSequencableCollection."	^ self iteratingDo: [ self value with: aSequenceableCollection do: aBlock ]</body></methods><methods><class-id>COAST.CatCSSequenceableCollection</class-id> <category>enumerating</category><body package="COCellValueHolder">associationsDo: aBlock	self value associationsDo: aBlock</body><body package="COCellValueHolder">keysAndValuesDo: aBlock	self value keysAndValuesDo: aBlock</body></methods><methods><class-id>COAST.CatCSSequenceableCollection</class-id> <category>copying</category><body package="COCellValueHolder">constructCopyParameters: awareness 	^ OrderedCollection with: ( CatCSCollectionWriteAccess argument: ( self value collect: [: elem | elem coastCopyWith: awareness ]))</body><body package="COCellValueHolder">copyWithout: argument 	^ self value copyWithout: argument</body></methods><methods><class-id>COAST.CatCSSequenceableCollection</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">indexOf: anElement ifAbsent: exceptionBlock 	^ value indexOf: anElement ifAbsent: exceptionBlock</body></methods><methods><class-id>COAST.CatCSSequenceableCollection class</class-id> <category>accessing</category><body package="COCellValueHolder">isAbstractCoastValueHolder	^ self name = #CatCSSequenceableCollection</body></methods><methods><class-id>COAST.CompactIndex</class-id> <category>accessing</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSCompactIndex new )		value: self;		yourself</body><body package="COCellValueHolder">atCompactKey: key includes: value 	^super atCompactKey: key asCompactArgument includes: value asCompactArgument</body><body package="COCellValueHolder">atIndex: index 	| assoc key value |	assoc := super atIndex: index.	assoc isNil ifTrue: [ ^ nil ].	key := clusterManager resolveFrameReference: assoc key.	value := clusterManager resolveFrameReference: assoc value.	^ key -&gt; value</body><body package="COCellValueHolder">atKey: keyFrame add: valueFrame 	| keyRef valueRef |	self clusterManagerFrom: keyFrame.	self clusterManagerFrom: valueFrame.	keyRef := keyFrame asCompactArgument.	valueRef := valueFrame asCompactArgument.	( self atKey: keyRef includes: valueRef ) ifFalse: [ self addedFramesAdd: keyRef -&gt; valueRef ].	^ valueFrame</body><body package="COCellValueHolder">atKey: frame ifAbsent: aBlock 	| frameReference |	frameReference := frame asValidFrameReferenceOrNil.	^ ( frameReference notNil )		ifTrue: [ super atKey: frameReference ifAbsent: aBlock ]		ifFalse: [ aBlock value ]</body><body package="COCellValueHolder">atKey: frameK includes: frameV 	| refKey refValue |	refKey := frameK asValidFrameReferenceOrNil.	refValue := frameK asValidFrameReferenceOrNil.	^ refKey notNil and: 		[	refValue notNil and: 				[	self clusterManagerFrom: frameK.					super atKey: refKey includes: frameV				]		]</body><body package="COCellValueHolder">atKey: keyFrame remove: valueFrame 	self clusterManagerFrom: keyFrame.	self clusterManagerFrom: valueFrame.	self removeKey: keyFrame asCompactArgument value: valueFrame asCompactArgument.	^ valueFrame</body><body package="COCellValueHolder">coastTotalByteSize	^ super coastTotalByteSize		+ valueClassIndices coastTotalByteSize		+ valueFrameIDs coastTotalByteSize		+ valueClusterIDs coastTotalByteSize		+ valueFrameClassArray coastTotalByteSize</body><body package="COCellValueHolder">compactIndexForKey: aKey value: aValue 	^ super compactIndexForKey: aKey asCompactArgument value: aValue asCompactArgument</body><body package="COCellValueHolder">includesKey: frame 	| frameReference |	frameReference := frame asValidFrameReferenceOrNil.	^ frameReference notNil and: [ self includesFrameReference: frameReference ]</body><body package="COCellValueHolder">removeKey: frame ifAbsent: absentBlock 	| frameReference |	frameReference := frame asValidFrameReferenceOrNil.	^ frameReference isNil		ifTrue: [ absentBlock value ]		ifFalse: [ super removeKey: frameReference ifAbsent: absentBlock ]</body><body package="COCellValueHolder">removeKey: keyFrame value: valueFrame ifAbsent: block 	self clusterManagerFrom: keyFrame.	self clusterManagerFrom: valueFrame.	^ super removeKey: keyFrame asCompactArgument value: valueFrame asCompactArgument ifAbsent: block</body><body package="COCellValueHolder">removedFramesAdd: assoc 	removedFrames isNil ifTrue: [ self initializeRemovedFrames ].	removedFrames add: assoc key asCompactArgument -&gt; assoc value asCompactArgument.</body></methods><methods><class-id>COAST.CompactIndex</class-id> <category>private</category><body package="COCellValueHolder">at: index putLocator: assoc classIndex: classIndex 	super at: index putLocator: assoc key classIndex: classIndex.	self valuesAt: index put: assoc value</body><body package="COCellValueHolder">basicAppendAll: otherCompactCollections 	| subCollections |	super basicAppendAll: otherCompactCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | anotherCompactCollection valueFrameIDs ].	valueFrameIDs := valueFrameIDs coastOptimizedAppendAll: subCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | anotherCompactCollection valueClusterIDs ].	valueClusterIDs := valueClusterIDs coastOptimizedAppendAll: subCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | self patchedValueClassIndicesOf: anotherCompactCollection ].	valueClassIndices := valueClassIndices coastOptimizedAppendAll: subCollections.</body><body package="COCellValueHolder">basicGrowBy: size 	super basicGrowBy: size.	valueFrameIDs := valueFrameIDs coastOptimizedGrownBy: size.	valueClusterIDs := valueClusterIDs coastOptimizedGrownBy: size.	valueClassIndices := valueClassIndices coastOptimizedGrownBy: size.</body><body package="COCellValueHolder">binarySearchMinKey: frameReference 	^ self validIndexOfReference: frameReference ifAbsent: [: indexNotFound | nil ]</body><body package="COCellValueHolder">binaryValuesSearchMaxClusterID: cidSearch frameID: fidSearch min: min max: max ifAbsent: absentBlock 	"search the largest index X where (( frameIDs at: X ) = fidSearch and: [( clusterIDs at: X ) = cidSearch ]) or nil"	"send absentBlock the potential index"	| minIndex maxIndex |	minIndex := min.	maxIndex := max.	maxIndex == 0 ifTrue: [ ^ absentBlock value: maxIndex	"empty collection" ].	"1 &lt;= minIndex &lt;= maxIndex &lt;= valueClusterIDs size"	[ minIndex &lt; maxIndex ] whileTrue: 		[ "search in interval [ minIndex .. maxIndex ]"			| midIndex cidFound |			midIndex := 1 + minIndex + maxIndex bitShift: -1.	"minIndex &lt; index &lt;= maxIndex"			cidFound := valueClusterIDs at: midIndex.			cidFound = cidSearch 				ifTrue: 				[ "compare frameID"					| fidFound |					fidFound := valueFrameIDs at: midIndex.					fidFound &lt;= fidSearch 						ifTrue: [ minIndex := midIndex	"search before index" ]						ifFalse: [ maxIndex := midIndex - 1	"search at or behind index" ]				]				ifFalse: 				[	"compare clusterID"					cidFound &lt; cidSearch 						ifTrue: [ minIndex := midIndex + 1	"search behind index" ]						ifFalse: [ maxIndex := midIndex - 1	"search before index" ]				]		].	minIndex &gt; maxIndex ifTrue: [ ^ absentBlock value: minIndex ].	^ ( valueClusterIDs at: minIndex ) = cidSearch 		ifTrue: 		[( valueFrameIDs at: minIndex ) = fidSearch 				ifTrue: [ minIndex ]				ifFalse: 				[( valueFrameIDs at: minIndex ) &gt; fidSearch 						ifTrue: [ absentBlock value: minIndex - 1	"the max index would be before (e.g. search 2 in #(3) )" ]						ifFalse: [ absentBlock value: minIndex	"the max index would be here (e.g. search 2 in #(1) )" ]				]		]		ifFalse: 		[( valueClusterIDs at: minIndex ) &gt; cidSearch 				ifTrue: [ absentBlock value: minIndex - 1	"the max index would be before (e.g. search 2 in #(3) )" ]				ifFalse: [ absentBlock value: minIndex	"the max index would be here (e.g. search 2 in #(1) )" ]		]</body><body package="COCellValueHolder">binaryValuesSearchMinClusterID: cidSearch frameID: fidSearch min: min max: max ifAbsent: absentBlock 	"search the smallest index X where (( frameIDs at: X ) = fidSearch and: [( clusterIDs at: X ) = cidSearch ]) or nil"	"send absentBlock the potential index"	| minIndex maxIndex |	minIndex := min.	maxIndex := max.	maxIndex == 0 ifTrue: [ ^ absentBlock value: 1	"empty collection" ].	"1 &lt;= minIndex &lt;= maxIndex &lt;= valueClusterIDs size"	[ minIndex &lt; maxIndex ] whileTrue: 		[ "search in interval [ minIndex .. maxIndex ]"			| midIndex cidFound |			midIndex := minIndex + maxIndex bitShift: -1.	"minIndex &lt;= index &lt; maxIndex"			cidFound := valueClusterIDs at: midIndex.			cidFound = cidSearch 				ifTrue: 				[ "compare frameID"					| fidFound |					fidFound := valueFrameIDs at: midIndex.					fidFound &lt; fidSearch 						ifTrue: [ minIndex := midIndex + 1	"search behind index" ]						ifFalse: [ maxIndex := midIndex	"search at or before index" ]				]				ifFalse: 				[	"compare clusterID"					cidFound &lt; cidSearch 						ifTrue: [ minIndex := midIndex + 1	"search behind index" ]						ifFalse: [ maxIndex := midIndex - 1	"search before index" ]				]		].	^ ( valueClusterIDs at: minIndex ) = cidSearch 		ifTrue: 		[( valueFrameIDs at: minIndex ) = fidSearch 				ifTrue: [ minIndex ]				ifFalse: 				[( valueFrameIDs at: minIndex ) &gt; fidSearch 						ifTrue: [ absentBlock value: minIndex	"the min index would be here (e.g. search 2 in #(3) )" ]						ifFalse: [ absentBlock value: minIndex + 1	"the min index would be behind (e.g. seatch 2 in #(1) )" ]				]		]		ifFalse: 		[( valueClusterIDs at: minIndex ) &gt; cidSearch 				ifTrue: [ absentBlock value: minIndex	"the min index would be here (e.g. search 2 in #(3) )" ]				ifFalse: [ absentBlock value: minIndex + 1	"the min index would be behind (e.g. seatch 2 in #(1) )" ]		]</body><body package="COCellValueHolder">coastCompactKeyRangeFor: key 	| min max |	min := self binarySearchMinClusterID: key clusterID frameID: key frameID ifAbsent: [: index | ^ index to: 0 ].	max := self binarySearchMaxClusterID: key clusterID frameID: key frameID min: min.	^ min to: max</body><body package="COCellValueHolder">coastCompactValueRangeFor: key value: value 	| min max |	min := self binarySearchMinClusterID: key clusterID frameID: key frameID ifAbsent: [: index | ^ index to: 0 ].	max := min = clusterIDs size 			ifTrue: [ min ]			ifFalse: [ self binarySearchMaxClusterID: key clusterID frameID: key frameID min: min ].	min := self binaryValuesSearchMinClusterID: value clusterID frameID: value frameID min: min max: max ifAbsent: [: index | ^ index to: 0 ].	max := self binaryValuesSearchMaxClusterID: value clusterID frameID: value frameID min: min max: max ifAbsent: [: index | ^ index to: 0 ].	^ min to: max</body><body package="COCellValueHolder">coastCompactValueRangeFor: key value: value 	| min max |	min := self binarySearchMinClusterID: key clusterID frameID: key frameID ifAbsent: [: index | ^ index to: 0 ].	max := min = clusterIDs size 			ifTrue: [ min ]			ifFalse: [ self binarySearchMaxClusterID: key clusterID frameID: key frameID min: min ].	min := self binaryValuesSearchMinClusterID: value clusterID frameID: value frameID min: min max: max ifAbsent: [: index | ^ index to: 0 ].	max := self binaryValuesSearchMaxClusterID: value clusterID frameID: value frameID min: min max: max ifAbsent: [: index | ^ index to: 0 ].	^ min to: max</body><body package="COFramesystem">compactAddLastKey: key value: value index: index 	self compactAddLast: key index: index.	valueClusterIDs at: index put: value clusterID.	valueFrameIDs at: index put: value frameID.	valueClassIndices at: index put: ( self valueClassIndexFor: value )</body><body package="COCellValueHolder">compactKeyAtIndex: index 	^ self basicFrameRefAtIndex: index</body><body package="COCellValueHolder">compactKeyAtIndex: index into: assoc 	self basicFrameRefAtIndex: index into: assoc key.</body><body package="COCellValueHolder">compactValueAtIndex: index 	^ CatFSFrameReference clusterID: ( valueClusterIDs at: index )		id: ( valueFrameIDs at: index )		classSymbol: ( self valueClassAtIndex: index )</body><body package="COCellValueHolder">compactValueAtIndex: index into: assoc 	| frameReference |	frameReference := assoc value.	frameReference clusterID: ( valueClusterIDs at: index ).	frameReference id: ( valueFrameIDs at: index ).	frameReference frameClassSymbol: ( self valueClassAtIndex: index ).</body><body package="COCellValueHolder">initializeArraysSized: size 	super initializeArraysSized: size.	valueFrameIDs := SmallIntegerArray new: size.	valueClusterIDs := SmallIntegerArray new: size.	valueClassIndices := ByteArray new: size.	valueFrameClassArray := Array new</body><body package="COCellValueHolder">insertionIndexOfKey: keyReference 	^ self validIndexOfReference: keyReference ifAbsent: [: indexNotFound | indexNotFound ]</body><body package="COCellValueHolder">keys	self compact.	^( CompactRPCResultCollection new )		clusterIDs: clusterIDs copy frameIDs: frameIDs copy classIndices: classIndices copy frameClassArray: frameClassArray copy;		clusterManager: clusterManager;		yourself</body><body package="COCellValueHolder">patchedValueClassIndicesOf: anotherCompactCollection 	"check if i and anotherCompactCollection agree about the class indices"	"extend my frameClassIndex, if needed"	"patch the classIndices only if needed (there is a class with my index ~= others index)"	| patchTable |	patchTable := anotherCompactCollection valueFrameClassArray collect: [: class | self valueClassIndexFor: class ].	patchTable keysAndValuesDo: [: k : v | k ~= v ifTrue: [ ^ anotherCompactCollection valueClassIndices collect: [: i | patchTable at: i ]]].	^ anotherCompactCollection valueClassIndices</body><body package="COCellValueHolder">removedElementsAtKey: key includes: value 	^ removedFrames notNil and: [ removedFrames atKey: key asCompactArgument includes: value asCompactArgument ]</body><body package="COCellValueHolder">valueClassAtIndex: index 	| classIndex |	classIndex := valueClassIndices at: index.	^ valueFrameClassArray at: classIndex</body><body package="COCellValueHolder">valueClassIndexFor: frameReference 	"valueFrameClassArray contains symbols and/or classes"	| frameKey otherFrameSymbol |	frameKey := frameReference frameKey.	valueFrameClassArray keysAndValuesDo: [: index : classOrSymbol | classOrSymbol == frameKey ifTrue: [ ^ index ]].	otherFrameSymbol := frameReference frameClassSymbol.	valueFrameClassArray keysAndValuesDo: [: index : classOrSymbol | classOrSymbol frameClassSymbol = otherFrameSymbol ifTrue: [ ^ index ]].	valueFrameClassArray := valueFrameClassArray copyWith: frameKey.	^ valueFrameClassArray size</body><body package="COCellValueHolder">valueClassIndices	^ valueClassIndices</body><body package="COCellValueHolder">valueClusterIDs	^ valueClusterIDs</body><body package="COCellValueHolder">valueFrameClassArray	^ valueFrameClassArray</body><body package="COCellValueHolder">valueFrameIDs	^ valueFrameIDs</body><body package="COCellValueHolder">valuesAt: index put: aFrameLocator 	valueClusterIDs at: index put: aFrameLocator clusterID.	valueFrameIDs at: index put: aFrameLocator frameID.	valueClassIndices at: index put: ( self valueClassIndexFor: aFrameLocator )</body></methods><methods><class-id>COAST.CompactIndex</class-id> <category>compact</category><body package="COCellValueHolder">transformWith: transformation from: original 	valueFrameClassArray := original valueFrameClassArray.	valueClusterIDs transformWith: transformation from: original valueClusterIDs.	valueFrameIDs transformWith: transformation from: original valueFrameIDs.	valueClassIndices transformWith: transformation from: original valueClassIndices.	super transformWith: transformation from: original.</body></methods><methods><class-id>COAST.CompactIndex</class-id> <category>copying</category><body package="COCellValueHolder">cropFrom: start to: stop	super cropFrom: start to: stop.	valueFrameIDs := valueFrameIDs copyFrom: start to: stop.	valueClusterIDs := valueClusterIDs copyFrom: start to: stop.	valueClassIndices := valueClassIndices copyFrom: start to: stop</body></methods><methods><class-id>COAST.CompactIndex</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryValueFrameClassesTo: aStream marshaller: aCatRMMarshall 	| valueFrameClassArraySize |	valueFrameClassArraySize := valueFrameClassArray size.	( valueClassIndices isEmpty or: [ valueFrameClassArraySize &gt; 1 ]) 		ifTrue: [ valueClassIndices do: [: fc | aStream nextPut: fc ]]		ifFalse: [ aStream nextPut: 0	"optimize one class collections" ].	aStream nextOptimized32Put: valueFrameClassArraySize.	valueFrameClassArray do: [: aSymbolOrClass | aCatRMMarshall writeFrameClassSymbol: aSymbolOrClass to: aStream ]</body><body package="COCellValueHolder">marshallBinaryValueTo: aStream marshaller: aCatRMMarshall 	super marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.	self marshallValuesTo: aStream marshaller: aCatRMMarshall forCluster: nil.</body><body package="COMarshalling">marshallValuesTo: aStream marshaller: aCatRMMarshall forCluster: aCluster 	aCatRMMarshall optimized32Marshall: valueClusterIDs to: aStream.	valueFrameIDs do: [: fid | aStream nextOptimized32Put: fid ].	self marshallBinaryValueFrameClassesTo: aStream marshaller: aCatRMMarshall.</body><body package="COCellValueHolder">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	super unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.	self unmarshallValuesFrom: aStream marshaller: aCatRMMarshall forCluster: nil morph: morphSelector.</body><body package="COMarshalling">unmarshallBinaryValueFrameClassesFrom: aStream marshaller: aCatRMMarshall 	| valueFrameClassCount elementsCount |	elementsCount := valueClassIndices size.	( valueClassIndices isEmpty or: [ aStream peek &gt; 0 ]) 		ifTrue: [ 1 to: elementsCount do: [: index | valueClassIndices at: index put: aStream next ]]		ifFalse: 		[	aStream next.	"optimized for one class collections"			1 to: elementsCount do: [: index | valueClassIndices at: index put: 1 ]		].	valueFrameClassArray := Array new: ( valueFrameClassCount := aStream nextOptimized32 ).	1 to: valueFrameClassCount		do: [: index | valueFrameClassArray at: index put: ( aCatRMMarshall readFrameKeyFrom: aStream )]</body><body package="COMarshalling">unmarshallValuesFrom: aStream marshaller: aCatRMMarshall forCluster: aCluster morph: morphSelector 	| elementsCount |	elementsCount := clusterIDs size.	aCatRMMarshall optimized32Unmarshall: valueClusterIDs from: aStream.	"except clusterID to be a storeable in two byte"	1 to: elementsCount do: [: index | valueFrameIDs at: index put: aStream nextOptimized32 ].	self unmarshallBinaryValueFrameClassesFrom: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CompactAbstractDictionary</class-id> <category>private</category><body package="COCellValueHolder">addElement: aElementToAdd 	| frame |	frame := aElementToAdd key.	self removeKey: frame.	self addedFramesAdd: aElementToAdd</body><body package="COCellValueHolder">addedFramesIncludes: frameReference 	^ addedFrames notNil and: [ addedFrames includesKey: frameReference ]</body><body package="COCellValueHolder">addedFramesRemove: frameReference ifAbsent: block 	^ addedFrames notNil 		ifTrue: [ addedFrames removeKey: frameReference ifAbsent: block ]		ifFalse: [ block value ]</body><body package="COCellValueHolder">associationsDo: aBlock 	self keysAndValuesDo: [: k : v | aBlock value: k -&gt; v ].</body><body package="COCellValueHolder">at: index putLocator: assoc classIndex: classIndex 	super at: index putLocator: assoc key classIndex: classIndex.	self valuesAt: index put: assoc value</body><body package="COCellValueHolder">atFrameReference: frameReference ifAbsent: aBlock 	| index |	( self addedFramesIncludes: frameReference ) ifTrue: [ ^ addedFrames at: frameReference ].	( self removedFramesIncludes: frameReference ) ifTrue: [ ^ aBlock value ].	index := self validIndexOfReference: frameReference ifAbsent: [: ignoreIndex | ^ aBlock value ].	^ self compactValueAtIndex: index</body><body package="COFramesystem">compactAddLast: frame index: index 	clusterIDs at: index put: frame clusterID.	frameIDs at: index put: frame frameID.	classIndices at: index put: ( self basicClassIndexFor: frame )</body><body package="COFramesystem">compactAddLastKey: key value: value index: index 	self subclassResponsibility</body><body package="COCellValueHolder">compactElementAtIndex: index into: assoc 	self compactKeyAtIndex: index into: assoc.	self compactValueAtIndex: index into: assoc.</body><body package="COCellValueHolder">compactKeyAtIndex: index 	^ self basicFrameRefAtIndex: index</body><body package="COCellValueHolder">compactKeyAtIndex: index into: assoc 	self basicFrameRefAtIndex: index into: assoc key.</body><body package="COFramesystem">fillFrom: segmentedDict atKeys: sortedKeys 	"fill into the compact structures up to optimizedSize, the use the normal differences index"	^self fillFrom: segmentedDict atKeys: sortedKeys restrictToValues: nil</body><body package="COFramesystem">fillFrom: segmentedDict atKeys: sortedKeys restrictToValues: rvaluesOrNil 	"fill into the compact structures - grow max. once"	| optimizedSize size |	self clusterManagerFrom: segmentedDict.	optimizedSize := rvaluesOrNil isNil 			ifTrue: [ sortedKeys size ]			ifFalse: [ sortedKeys size min: rvaluesOrNil size ].	self initializeArraysSized: optimizedSize.	size := 0.	sortedKeys do: 		[: key | | value |			value := segmentedDict atKey: key.			( value notNil and: [ rvaluesOrNil isNil or: [ rvaluesOrNil includes: value ]]) ifTrue: 				[	size := size + 1.					size &gt; clusterIDs size ifTrue: [ self basicGrowBy: sortedKeys size - optimizedSize	"grow only when rvaluesOrNil are multi referenced" ].					self compactAddLastKey: key value: value index: size	"write compact"				]		].	size &lt; clusterIDs size ifTrue: [ self cropToSize: size ].</body><body package="COCellValueHolder">initializeAddedFrames	addedFrames := Dictionary new</body><body package="COCellValueHolder">keysAndValuesDo: aBlock 	self referencesElementsCursorDo: 		[: assoc | | frame |			frame := clusterManager resolveFrameReferenceCursor: assoc key.			aBlock value: frame value: assoc value		].</body><body package="COCellValueHolder">removedElementsIncludes: elem 	^ self removedFramesIncludes: elem key</body><body package="COCellValueHolder">sortedAdds	^ addedFrames isNil 		ifTrue: [ #( )]		ifFalse: [ addedFrames associations asSortedCollection: [: a : b | a key &lt; b key ]]</body></methods><methods><class-id>COAST.CompactAbstractDictionary</class-id> <category>accessing</category><body package="COCellValueHolder">add: aFrameAssoc 	self addElement: aFrameAssoc key asCompactArgument -&gt; aFrameAssoc value.	^ aFrameAssoc</body><body package="COCellValueHolder">associationAt: key 	^ self associationAt: key ifAbsent: [ ]</body><body package="COCellValueHolder">associationAt: key ifAbsent: block 	| value |	value := self atKey: key ifAbsent: [ ^ block value ].	^ key -&gt; value</body><body package="COCellValueHolder">associations	| associations |	associations := Set new.	self associationsDo: [: a | associations add: a ].	^ associations</body><body package="COCellValueHolder">at: frame 	^ self atKey: frame ifAbsent: [( KeyNotFoundError receiver: self selector: #at: index: frame ) raiseRequest ]</body><body package="COCellValueHolder">at: frame put: value 	self clusterManagerFrom: frame.	self addElement: frame asCompactArgument -&gt; value.	^ value</body><body package="COCellValueHolder">atKey: frame 	^ self atKey: frame ifAbsent: nil</body><body package="COCellValueHolder">atKey: frame ifAbsent: aBlock 	^ self basicAtKey: frame ifAbsent: aBlock</body><body package="COCellValueHolder">atKeys: someKeys 	| size copy |	size := 0.	copy := ( self species new: ( self size min: someKeys size ))			clusterManager: clusterManager;			yourself.	self referencesElementsCursorDo: 		[: assoc | ( someKeys coastIncludesCompactKey: assoc key ) ifTrue: 				[	size := size + 1.					copy atIndex: size put: assoc				]		].	copy cropToSize: size.	^ copy</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues 	^ ( self atKeys: someKeys ) restrictToValues: rvalues</body><body package="COCellValueHolder">basicAtKey: frame ifAbsent: aBlock 	| frameReference |	frameReference := frame asValidFrameReferenceOrNil.	^frameReference isNil 		ifTrue: [ aBlock value ]		ifFalse: [ self atFrameReference: frameReference ifAbsent: aBlock ]</body><body package="COCellValueHolder">classIndexFor: assoc 	^ self basicClassIndexFor: assoc key</body><body package="COCellValueHolder">coastAsSetOrYourself	^ self asSet</body><body package="COCellValueHolder">coastKeyAtValue: val ifAbsent: exceptionBlock 	self keysAndValuesDo: [: frame : value | val = value ifTrue: [ ^ frame ]].	^ exceptionBlock value</body><body package="COCellValueHolder">compactAtKey: key 	^ self basicAtKey: key ifAbsent: nil</body><body package="COCellValueHolder">defaultCursor	^ self defaultKeyCursor -&gt; self defaultValueCursor</body><body package="COCellValueHolder">defaultKeyCursor	^ CatFSFrameReference new</body><body package="COCellValueHolder">defaultValueCursor	^ CatFSFrameReference new</body><body package="COCellValueHolder">do: aBlock 	self referencesElementsCursorDo: [: assoc | aBlock value: assoc value ].</body><body package="COCellValueHolder">eachKeyIn: someKeys do: eachKeyBlock 	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index.	Equivalent to 		(self atKeys: someKeys) keysDo: eachKeyBlock	but faster for some classes "	someKeys do: 		[: key | | valuesRefsOrNil |			valuesRefsOrNil := self basicAtKey: key ifAbsent: nil.			valuesRefsOrNil notNil 				ifTrue: [ valuesRefsOrNil do: [: valRef | eachKeyBlock value: key ]]		].</body><body package="COCellValueHolder">includesKey: frame 	| frameReference |	frameReference := frame asValidFrameReferenceOrNil.	^ frameReference notNil and: [ self includesFrameReference: frameReference ]</body><body package="COFramesystem">journalIncludesReferencedElement: assoc 	^ self includesKey: assoc key</body><body package="COCellValueHolder">keys	self compact.	^ ( CompactSet new )		clusterIDs: clusterIDs copy frameIDs: frameIDs copy classIndices: classIndices copy frameClassArray: frameClassArray copy;		clusterManager: clusterManager;		yourself</body><body package="COCellValueHolder">keysDo: aBlock 	self referencesElementsCursorDo: 		[: assoc | | frame |			frame := clusterManager resolveFrameReferenceCursor: assoc key.			aBlock value: frame		].</body><body package="COFramesystem">lastElement	| lastAssoc |	lastAssoc := self lastReferenceElement.	lastAssoc isNil ifTrue: [ ^ nil ].	^ lastAssoc key selfOrFrameLocator</body><body package="COCellValueHolder">remove: assoc 	^ self removeKey: assoc key</body><body package="COCellValueHolder">removeKey: frame 	^ self removeKey: frame ifAbsent: [ ]</body><body package="COCellValueHolder">removeKey: frame ifAbsent: block 	| frameReference |	frameReference := frame asValidFrameReferenceOrNil.	frameReference isNil ifTrue: [ ^ block value ].	self removeFrameReference: frameReference ifAbsent: [ ^ block value ].	^ frame</body><body package="COCellValueHolder">removeRPCResult: assoc 	self removedFramesAdd: assoc key.</body><body package="COCellValueHolder">simpleClass	^ Dictionary</body><body package="COCellValueHolder">sizeAtKey: frame 	^ ( self includesKey: frame ) 		ifTrue: [ 1 ]		ifFalse: [ 0 ]</body></methods><methods><class-id>COAST.CompactAbstractDictionary</class-id> <category>values</category><body package="COCellValueHolder">compactValueAtIndex: index 	^ self subclassResponsibility</body><body package="COCellValueHolder">compactValueAtIndex: index into: assoc 	self subclassResponsibility.</body><body package="COCellValueHolder">values	^ self subclassResponsibility</body><body package="COCellValueHolder">valuesAt: index put: value 	^ self subclassResponsibility</body></methods><methods><class-id>COAST.CompactAbstractDictionary</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryValueTo: aStream marshaller: aCatRMMarshall 	super marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.	self marshallValuesTo: aStream marshaller: aCatRMMarshall forCluster: nil.</body><body package="COMarshalling">marshallValuesTo: aStream marshaller: aCatRMMarshall forCluster: aCluster 	^ self subclassResponsibility</body><body package="COCellValueHolder">translatedArgumentForCluster: aCatCSCluster 	" addedFrames contains frame references "	self error: 'Set all for dictionaries not supported'</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	super unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.	self unmarshallValuesFrom: aStream marshaller: aCatRMMarshall forCluster: nil morph: morphSelector.</body><body package="COMarshalling">unmarshallValuesFrom: aStream marshaller: aCatRMMarshall forCluster: aCluster morph: morphSelector 	^ self subclassResponsibility</body></methods><methods><class-id>COAST.CompactAbstractDictionary</class-id> <category>compact</category><body package="COCellValueHolder">addAddsForCompactTo: collection 	addedFrames isNil ifFalse: 		[	addedFrames keysAndValuesDo: 				[: key :value | | pos |					pos := self validIndexOfReference: key ifAbsent: [: indexNotFound | indexNotFound ].					collection add: ( Array with: #add with: key with: pos with: key-&gt;value )				]		].</body></methods><methods><class-id>COAST.CompactAbstractDictionary</class-id> <category>iterating</category><body package="COCellValueHolder">coastAllArgumentsDo: aBlock 	self keysAndValuesDo: 		[: k : v |			aBlock value: k.			aBlock value: v		].</body></methods><methods><class-id>COAST.CatCSAbstractIndex</class-id> <category>adaption</category><body package="COCellValueHolder">adaptedCoastValueHolderToClass: valueHolderClass 	^ valueHolderClass coastAdaptFromIndex: self</body><body package="COCellValueHolder">coastAdaptCollection: dict 	self value: ( self valueClass withAll: dict associations )</body></methods><methods><class-id>COAST.CatCSAbstractIndex</class-id> <category>accessing</category><body package="COCellValueHolder">asMultiValueDictionary	^ self value asMultiValueDictionary</body><body package="COCellValueHolder">at: elementIndex 	^ self value atIndex: elementIndex</body><body package="COCellValueHolder">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	^ self value atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize</body><body package="COCellValueHolder">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result 	^ self value atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize into: result</body><body package="COCellValueHolder">directValuesDo: block 	self value keysAndValuesDo: 		[: k : v |			block value: k.			block value: v		].</body><body package="COCellValueHolder">fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	^ self value fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive</body><body package="COCellValueHolder">indexForKey: aKey value: aValue 	^ value indexForKey: aKey value: aValue</body><body package="COCellValueHolder">indexOf: element 	^ self value indexOf: element</body><body package="COCellValueHolder">insertionIndexOf: element 	^ self value insertionIndexOf: element</body><body package="COFramesystem">lastElement	^ self value lastElement</body><body package="COCellValueHolder">matchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize	^ self value matchingPattern: keyPattern ignoreCase: ignoreCase into: result maxSize: maxSize</body><body package="COCellValueHolder">matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	^ self value matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize</body><body package="COCellValueHolder">referencesElementsCursorDo: aBlock 	^ self value referencesElementsCursorDo: aBlock</body><body package="COCellValueHolder">removeKey: oldKey	CoastError raiseSignal: 'access violation'</body></methods><methods><class-id>COAST.CatCSAbstractIndex</class-id> <category>initialize - release</category><body package="COCellValueHolder">initializeWithSize: anInteger	self value: (self valueClass new: anInteger)</body></methods><methods><class-id>COAST.CatCSAbstractIndex</class-id> <category>garbage collect</category><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock 	self value referencesElementsCursorDo: 		[: assoc |			assoc key isFrameOrFrameReference ifTrue: [ aBlock value: assoc key ].			assoc value isFrameOrFrameReference ifTrue: [ aBlock value: assoc value ]		].</body></methods><methods><class-id>COAST.CatCSAbstractIndex</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall	self value valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall.</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	"cluster can be set to nil for compact collections"	aStream nextPut: self class marshallID.	aStream nextPut: self index.	self marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	self value marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	"cluster and morph selector can be set to nil for compact collections"	self unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: nil.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	value := self valueClass unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.</body></methods><methods><class-id>COAST.CatCSAbstractIndex class</class-id> <category>adapting</category><body package="COCellValueHolder">coastAdaptFromIndex: indexValueHolder 	^ ( self new )		coastAdaptCollection: indexValueHolder value;		yourself</body></methods><methods><class-id>COAST.CatCSAbstractIndex class</class-id> <category>accessing</category><body package="COCellValueHolder">valueClass	^ Index</body></methods><methods><class-id>COAST.CatCSAbstractIndex class</class-id> <category>testing</category><body package="COCellValueHolder">isAbstractCoastValueHolder	^ self name = #CatCSAbstractIndex</body></methods><methods><class-id>COAST.CatCSDictionary</class-id> <category>adaption</category><body package="COCellValueHolder">adaptedCoastValueHolderToClass: valueHolderClass 	^ valueHolderClass coastAdaptFromDictionary: self</body><body package="COCellValueHolder">coastAdaptCollection: dict 	self value: ( self valueClass withAll: dict associations )</body></methods><methods><class-id>COAST.CatCSDictionary</class-id> <category>accessing</category><body package="COCellValueHolder">anyKey	^value anyKey</body><body package="COCellValueHolder">associationAt: key	^value associationAt: key ifAbsent: [].</body><body package="COCellValueHolder">associations	^value associations.</body><body package="COCellValueHolder">at: key	^value at: key ifAbsent: [].</body><body package="COCellValueHolder">at: key ifAbsent: aBlock	^value at: key ifAbsent: aBlock</body><body package="COCellValueHolder">atKey: key 	^ value atKey: key</body><body package="COCellValueHolder">atKey: key ifAbsent: aBlock	^self at: key ifAbsent: aBlock</body><body package="COCellValueHolder">atKeys: someKeys	| result |	result := Dictionary new.	someKeys do: [ : k | 		| v |		(v := self atKey: k) notNil			ifTrue: [ result at: k put: v ]	].	^ result</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues 	^ ( self atKeys: someKeys ) restrictToValues: rvalues</body><body package="COCellValueHolder">coastInternalAdd: anObject withAccess: access 	" adding associations is not allowed "	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">coastInternalAt: key put: anObject	^value at: key put: anObject.</body><body package="COCellValueHolder">coastInternalAt: key put: anObject withAccess: access 	^ self coastInternalAt: key put: anObject</body><body package="COCellValueHolder">coastInternalRemove: anObject withAccess: access 	"needed for inverting demons"	| key |	key := anObject coastIsAssociation 			ifTrue: [ anObject key ]			ifFalse: [( self keyAtValue: anObject ) ifNil: [ anObject ]].	^ self coastInternalRemoveKey: key withAccess: access</body><body package="COCellValueHolder">coastInternalRemoveKey: oldKey 	^ value removeKey: oldKey ifAbsent: [ ]</body><body package="COCellValueHolder">coastInternalRemoveKey: oldKey withAccess: access 	^ self coastInternalRemoveKey: oldKey</body><body package="COCellValueHolder">coastKeyAtValue: val ifAbsent: absentBlock	^value coastKeyAtValue: val ifAbsent: absentBlock</body><body package="COCellValueHolder">directValuesDo: block 	self value keysAndValuesDo: 		[: k : v |			block value: k.			block value: v		].</body><body package="COCellValueHolder">eachKeyIn: someKeys do: eachKeyBlock 	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index. "	" default fallback implementation "	(self atKeys: someKeys) keysDo: eachKeyBlock</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue 	self frame: frame atKeyedSlotNamed: slotName replace: oldValue with: newValue</body><body package="COCellValueHolder">includesKey: key	^value includesKey: key.</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	| key |	key := demon keyFor: addedFrame.	key notNil 		ifTrue: [( frame at: slotName atKey: key ) = addedFrame ifFalse: [ frame at: slotName atKey: key put: addedFrame ]]		ifFalse: [ self error: 'Cannot invert ', frame class fullName, ' #', slotName, ' with ', addedFrame class fullName, ', no key specified' ]</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	| key |	key := demon keyFor: removedFrame.	key notNil 		ifTrue: [( frame at: slotName atKey: key ) = removedFrame ifTrue: [ frame at: slotName removeKey: key ]]		ifFalse: [ self error: 'can not invert' ]</body><body package="COCellValueHolder">keyAtValue: aValue	^value coastKeyAtValue: aValue ifAbsent: [].</body><body package="COCellValueHolder">keys	^value keys.</body><body package="COCellValueHolder">keysDo: aBlock 	^ self iteratingDo: [ self value keysDo: aBlock ]</body><body package="COCellValueHolder">removeKey: oldKey	CoastError raiseSignal: 'access violation'</body><body package="COCellValueHolder">valueAsDepleteRemovedCollection	| assocs d |	assocs := self associations.	d := Dictionary new: assocs size.	assocs do: [ : assoc | d add: assoc ].	^ d</body><body package="COCellValueHolder">valueAsSet	^value values</body><body package="COCellValueHolder">values	^value values.</body></methods><methods><class-id>COAST.CatCSDictionary</class-id> <category>enumerating</category><body package="COFramesystem">associationsDo: block 	^ self iteratingDo: [ self value associationsDo: block ]</body><body package="COCellValueHolder">keysAndValuesDo: aBlock 	^ self iteratingDo: [ self value keysAndValuesDo: aBlock ]</body><body package="COFramesystem">valuesDo: block 	^ self do: block</body></methods><methods><class-id>COAST.CatCSDictionary</class-id> <category>garbage collect</category><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock 	"for use of garbage-collection only!"	self values do: 		[: obj |			obj isFrameOrFrameReference 				ifTrue: [ aBlock value: obj ]		].	self keys do: 		[: obj |			obj isFrameOrFrameReference 				ifTrue: [ aBlock value: obj ]		]</body></methods><methods><class-id>COAST.CatCSDictionary</class-id> <category>testing</category><body package="COCellValueHolder">canCheckKeyRange		^ true</body><body package="COFramesystem">referencesSharedFrame: frame 	^ ( self includesKey: frame ) or: [ self values includes: frame ]</body></methods><methods><class-id>COAST.CatCSDictionary</class-id> <category>copying</category><body package="COCellValueHolder">constructCopyParameters: awareness 	| params |	params := OrderedCollection new.	self value keysAndValuesDo: 		[: key : val |			params addLast: ( CatCSAtKeyPutAccess argument1: ( key coastCopyWith: awareness ) argument2: ( val coastCopyWith: awareness ))		].	^ params</body></methods><methods><class-id>COAST.CatCSDictionary</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall	self keysAndValuesDo: 		[: key : val |			key valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall.			val valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall		].</body><body package="COMarshalling">index	^ 4</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self class marshallID.	aStream nextPut: self index.	aStream nextOptimized32Put: value size.	self keysAndValuesDo: 		[: key : val |			key marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall.			val marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall		].</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: value size.	self keysAndValuesDo: 		[: key : val |			aCatRMMarshall marshallValue: key to: aStream.			aCatRMMarshall marshallValue: val to: aStream		].</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	| valueSize |	valueSize := aStream nextOptimized32.	self value isNil ifTrue: [ self value: ( self valueClass new: valueSize )].	valueSize timesRepeat: 		[ | key val |			key := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.			val := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.			value at: key put: val		].</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	| valueSize |	valueSize := aStream nextOptimized32.	self value isNil ifTrue: [ self initializeWithSize: valueSize ].	valueSize timesRepeat: 		[ | key val |			key := aCatRMMarshall unmarshallValueFrom: aStream morph: morphSelector.			val := aCatRMMarshall unmarshallValueFrom: aStream morph: morphSelector.			value at: key put: val		].</body></methods><methods><class-id>COAST.CatCSDictionary class</class-id> <category>adapting</category><body package="COCellValueHolder">coastAdaptFromDictionary: dictValueHolder 	^ ( self new )		coastAdaptCollection: dictValueHolder value;		yourself</body><body package="COCellValueHolder">coastAdaptFromSimpleCollection: bagValueHolder 	^ bagValueHolder</body></methods><methods><class-id>COAST.CatCSDictionary class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ Dictionary</body></methods><methods><class-id>COAST.CatCSDictionary class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^4</body></methods><methods><class-id>COAST.CatCSDictionary class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#dictionary</body></methods><methods><class-id>COAST.CatCSCompactBag</class-id> <category>accessing</category><body package="COFramesystem">lastElement	^ self value lastElement</body><body package="COCellValueHolder">referencesElementsCursorDo: aBlock 	^ self value referencesElementsCursorDo: aBlock</body><body package="COMarshalling">translatedArgumentForCluster: aCatCSCluster	^ self value translatedArgumentForCluster: aCatCSCluster</body></methods><methods><class-id>COAST.CatCSCompactBag</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall	self value valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall.</body><body package="COMarshalling">index	^ 8</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	"cluster can be set to nil for compact collections"	aStream nextPut: self class marshallID.	aStream nextPut: self index.	self marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	self value marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	"cluster and morph selector can be set to nil for compact collections"	self unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: nil.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	value := self valueClass unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.</body></methods><methods><class-id>COAST.CatCSCompactBag class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ CompactBag</body></methods><methods><class-id>COAST.CatCSCompactBag class</class-id> <category>pragma</category><body package="COCellValueHolder">slotSymbol	^#compactBag</body><body package="COCellValueHolder">valueHolderIndex	^8</body></methods><methods><class-id>COAST.CatCSDelegatingProxyDictionary</class-id> <category>private</category><body package="COCellValueHolder">addedAtKey: key ifAbsent: absentBlock 	| probe |	^ ( probe := self added ) isNil 		ifTrue: [ absentBlock value ]		ifFalse: [ probe at: key ifAbsent: absentBlock ]</body><body package="COCellValueHolder">addedAtKey: key put: aValue 	| probe |	probe := self added.	probe isNil ifTrue: [ probe := self initializeAdded ].	probe at: key put: aValue</body><body package="COCellValueHolder">addedIncludes: aValue 	self haltOrContinue: 'you might want to send #addedIncludesKey:'.	^ super addedIncludes: aValue</body><body package="COCellValueHolder">addedIncludesKey: key 	| probe |	^ ( probe := self added ) notNil and: [ probe includesKey: key ]</body><body package="COCellValueHolder">addedRemoveKey: key ifAbsent: absentBlock 	| probe |	( probe := self added ) isNil ifTrue: [ ^ absentBlock value ].	^ probe removeKey: key ifAbsent: absentBlock</body><body package="COCellValueHolder">associations	| associations |	associations := Set new.	self keysAndValuesDo: [: k : v | associations add: k -&gt; v ].	^ associations</body><body package="COCellValueHolder">atKey: key 	^ self atKey: key ifAbsent: nil</body><body package="COCellValueHolder">atKey: key ifAbsent: absentBlock 	^ self addedAtKey: key		ifAbsent: 		[( self uncleanedRemovedIncludes: key ) 				ifTrue: [ absentBlock value ]				ifFalse: [( self valueFrameAtKey: key ) ifNil: absentBlock ]		]</body><body package="COCellValueHolder">atKey: key put: aValue 	self removedAdd: key dirty: true.	^ self addedAtKey: key put: aValue</body><body package="COCellValueHolder">collectionType	^ Dictionary</body><body package="COCellValueHolder">copy	| copy |	copy := Dictionary new.	self keysAndValuesDo: [: key : aValue | copy at: key put: aValue ].	^ copy</body><body package="COCellValueHolder">do: block 	"valueFrame must be realy loaded"	| added uncleanedRemoved |	( added := self added ) isNil ifFalse: [ added do: block ].	self valueFrameIsPresent ifFalse: [ ^ self ].	uncleanedRemoved := self uncleanedRemoved.	self valueFrame keysAndValuesDo: 		[: aKey : aValue | (( added notNil and: [ added includesKey: aKey ]) 				or: [ uncleanedRemoved notNil and: [ uncleanedRemoved includes: aValue ]]) ifFalse: [ block value: aValue ]		]</body><body package="COCellValueHolder">includesKey: key 	( self addedIncludesKey: key ) ifTrue: [ ^ true ].	( self uncleanedRemovedIncludes: key ) ifTrue: [ ^ false ].	^ self valueFrameIncludesKey: key</body><body package="COCellValueHolder">initializeRemoved	^ self initializeKey: #removed collectionType: Set</body><body package="COCellValueHolder">keys	| keys |	keys := OrderedCollection new.	self keysDo: [: key | keys add: key ].	^ keys</body><body package="COCellValueHolder">keysDo: block 	"valueFrame must be realy loaded"	| added removed |	( added := self added ) isNil ifFalse: [ added keysDo: block ].	self valueFrameIsPresent ifFalse: [ ^ self ].	removed := self removed.	self valueFrame keysDo: 		[: key | (( added notNil and: [ added includesKey: key ]) or: [ removed notNil and: [ removed includes: key ]]) 				ifFalse: [ block value: key ]		]</body><body package="COCellValueHolder">removeKey: key 	self removeKey: key ifAbsent: nil</body><body package="COCellValueHolder">removeKey: key ifAbsent: absentBlock 	self addedRemoveKey: key		ifAbsent: 		[( absentBlock isNil or: [ self valueFrameIncludesKey: key ]) 				ifTrue: [ self removedAdd: key ifIncluded: absentBlock ]				ifFalse: [ absentBlock value ]		]</body><body package="COCellValueHolder">removedAdd: aValue ifIncluded: includedBlock 	" wenn der key schon zu removed hinzugefÃ¼gt wurde,	macht es nichts, es noch mal zu hinzuzufÃ¼gen.	dagegen leidet die Performance, wenn man dauernd removed aufrÃ¤umt "	| probe |	( includedBlock notNil and: [ self removed includes: aValue ]) ifTrue: [ ^ includedBlock value ].	probe := self uncleanedRemoved.	self markRemovedAsDirty.	probe isNil ifTrue: [ probe := self initializeRemoved ].	probe add: aValue</body><body package="COCellValueHolder">valueFrameAtKey: key 	| result |	key coastIsValidRPCArgument ifFalse: [ ^ nil ].	result := self valuePerform: #atKey: withArguments: ( Array with: key ) default: nil.	^ result isCoastPrimitiveValue 		ifTrue: [ result ]		ifFalse: [ self resolveFrameReference: result ]</body><body package="COCellValueHolder">valueFrameIncludesKey: key 	key coastIsValidRPCArgument ifFalse: [ ^ false ].	^ self valuePerform: #includesKey: withArguments: ( Array with: key ) default: [ false ]</body></methods><methods><class-id>COAST.CatCSDelegatingProxyDictionary</class-id> <category>accessing</category><body package="COCellValueHolder">atKeys: someKeys 	| localResult result remoteKeys added removed |	remoteKeys := someKeys coastAsSortedValidKeys.	removed := self removed.	removed notNil ifTrue: [ remoteKeys := remoteKeys reject: [: k | removed includes: k ]	"no need to ask the shared frame about these" ].	added := self added.	localResult := added notNil 			ifTrue: 			[	remoteKeys := remoteKeys reject: [: k | added includesKey: k ].	"no need to ask the shared frame about these"				added atKeys: someKeys			]			ifFalse: [ nil ].	remoteKeys isEmpty ifTrue: [ ^ localResult ifNil: [ Dictionary new ]].	result := self valueFrameAtKeys: remoteKeys.	localResult notNil ifTrue: [ localResult keysAndValuesDo: [: k : v | result at: k put: v ]].	^ result</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize	^ someKeys size &lt;= maxKeysSize		ifTrue: [ self atKeys: someKeys ]		ifFalse: [ self valueFrame atKeys: someKeys ]</body><body package="COCellValueHolder">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues 	^ someKeys size &lt;= maxKeysSize 		ifTrue: [ (self atKeys: someKeys) restrictToValues: rvalues ]		ifFalse: [ self valueFrame atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues ]</body><body package="COCellValueHolder">coastInternalAt: aKey put: aValue withAccess: access 	access transaction needsFlush: true.	^ self atKey: aKey put: aValue</body><body package="COCellValueHolder">coastInternalRemoveKey: aKey withAccess: access 	access transaction needsFlush: true.	^ self removeKey: aKey ifAbsent: nil</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue 	self frame: frame atKeyedSlotNamed: slotName replace: oldValue with: newValue</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	| key |	key := demon keyFor: addedFrame.	key notNil 		ifTrue: [ frame at: slotName atKey: key put: addedFrame ]		ifFalse: [ self error: 'can not invert' ]</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	| key |	key := demon keyFor: removedFrame.	key notNil 		ifTrue: [( frame at: slotName atKey: key ) = removedFrame ifTrue: [ frame at: slotName removeKey: key ]]		ifFalse: [ self error: 'can not invert' ]</body><body package="COCellValueHolder">valueClass	^ Dictionary</body><body package="COCellValueHolder">values	| result added removed |	removed := self removed.	added := self added.	removed isNil 		ifTrue: 		[	result := self valueFrame values coastAsSetOrYourself.			added notNil ifTrue: [ result addAll: added values ]		]		ifFalse: 		[	result := Set new: self size.			self do: [: e | result add: e ]		].	^ result</body></methods><methods><class-id>COAST.CatCSDelegatingProxyDictionary</class-id> <category>enumerating</category><body package="COCellValueHolder">associationsDo: block 	self keysAndValuesDo: [ : k : v | block value: k -&gt; v ].</body><body package="COCellValueHolder">keysAndValuesDo: block 	"valueFrame must be realy loaded"	| added removed |	( added := self added ) isNil ifFalse: [ added keysAndValuesDo: block ].	removed := self removed.	self valueFrameIsPresent ifFalse: [ ^ self ].	self valueFrame keysAndValuesDo: 		[: key : aValue | (( added notNil and: [ added includesKey: key ]) 				or: [ removed notNil and: [ removed includes: key ]]) ifFalse: [ block value: key value: aValue ]		]</body><body package="COCellValueHolder">referencesElementsCursorDo: block 	"elemente enumerieren, ohne resolving"	"lÃ¤stigerweise enthalten added und removed echte frames und keine refs"	| added removed skipUnresolved |	( added := self added ) isNil ifFalse: 		[	skipUnresolved := Set new: added size.			added keysAndValuesDo: 				[: k : v | | frK frV |					frK := k frameReferenceOrSelf.					frV := v frameReferenceOrSelf.					skipUnresolved add: frK.					block value: frK -&gt; frV				]		].	self valueFrameIsPresent ifFalse: [ ^ self ].	removed := self uncleanedRemoved.	removed notNil ifTrue: 		[	skipUnresolved isNil 				ifTrue: [ skipUnresolved := removed collect: [: e | e frameReferenceOrSelf ]]				ifFalse: [ removed do: [: e | skipUnresolved add: e frameReferenceOrSelf ]]		].	self valueFrame 		referencesElementsCursorDo: [: assoc | ( skipUnresolved notNil and: [ skipUnresolved includes: assoc key ]) ifFalse: [ block value: assoc ]].</body></methods><methods><class-id>COAST.CatCSDelegatingProxyDictionary</class-id> <category>private dirty remove</category><body package="COCellValueHolder">cleanRemoved: removed 	removed copy do: 		[: key | ( self valueFrameIncludesKey: key ) ifFalse: 				[	"not included in remote frame, not removed at all"					removed remove: key				]		]</body></methods><methods><class-id>COAST.CatCSDelegatingProxyDictionary</class-id> <category>compatibility</category><body package="COCellValueHolder">compactElementAtIndex: index 	^ ( self resolveFrameReference: self value ) compactElementAtIndex: index</body></methods><methods><class-id>COAST.CatCSDelegatingProxyDictionary</class-id> <category>compact</category><body package="COCellValueHolder">compact	"nothing to do"</body></methods><methods><class-id>COAST.CatCSDelegatingProxyDictionary</class-id> <category>experimental collection protocol</category><body package="COCellValueHolder">groupedBy: aBlock 	| result |	result := Dictionary new.	self keysAndValuesDo: [: key : each | ( result at: ( aBlock value: each ) ifAbsentPut: [ Dictionary new ]) at: key put: each ].	^ result</body></methods><methods><class-id>COAST.CatCSDelegatingProxyDictionary</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 14</body></methods><methods><class-id>COAST.CatCSMultiValueDictionary</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall	self value valuesAssociationsDo: 		[: assoc | | |			assoc key valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall.			assoc value do: [: val | val valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall ]		].</body><body package="COCellValueHolder">index	^ 17</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self class marshallID.	aStream nextPut: self index.	aStream nextOptimized32Put: self keysSize.	self value valuesAssociationsDo: 		[: assoc | | values |			assoc key marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall.			values := assoc value.			aStream nextOptimized32Put: values size.			values do: [: val | val marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall ]		].</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: self keysSize.	self value valuesAssociationsDo: 		[: assoc | | values |			aCatRMMarshall marshallValue: assoc key to: aStream.			values := assoc value.			aStream nextOptimized32Put: values size.			values do: [: val | aCatRMMarshall marshallValue: val to: aStream ]		].</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	| keySize |	keySize := aStream nextOptimized32.	self value isNil ifTrue: [ self initializeWithSize: keySize ].	keySize timesRepeat: 		[ | key val valSize |			key := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.			valSize := aStream nextOptimized32.			valSize timesRepeat: 				[	val := aCatRMMarshall unmarshallBinaryArgumentFrom: aStream.					value atKey: key add: val				]		].</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	| keySize |	keySize := aStream nextOptimized32.	self value isNil ifTrue: [ self initializeWithSize: keySize ].	keySize timesRepeat: 		[ | key val valSize |			key := aCatRMMarshall unmarshallValueFrom: aStream morph: morphSelector.			valSize := aStream nextOptimized32.			valSize timesRepeat: 				[	val := aCatRMMarshall unmarshallValueFrom: aStream morph: morphSelector.					value atKey: key add: val				]		].</body></methods><methods><class-id>COAST.CatCSMultiValueDictionary</class-id> <category>accessing</category><body package="COCellValueHolder">adaptedCoastValueHolderToClass: valueHolderClass 	^ valueHolderClass coastAdaptFromIndex: self</body><body package="COCellValueHolder">coastInternalRemoveKey: oldKey 	^ value removeKey: oldKey ifAbsent: [ Set new ]</body><body package="COCellValueHolder">coastInternalRemoveKey: oldKey withAccess: access 	^ self coastInternalRemoveKey: oldKey</body><body package="COCellValueHolder">directValuesDo: block 	self value keysAndValuesDo: 		[: k : v |			block value: k.			block value: v		].</body><body package="COCellValueHolder">keysSize	^ self value keysSize</body><body package="COCellValueHolder">valueAsSet	^ self value values</body><body package="COCellValueHolder">values	^ self valueAsSet</body><body package="COCellValueHolder">valuesAssociationsDo: aBlock 	^ self iteratingDo: [ value valuesAssociationsDo: aBlock ]</body></methods><methods><class-id>COAST.CatCSMultiValueDictionary</class-id> <category>garbage collect</category><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock 	self value keysAndValuesDo: 		[: key : val |			key isFrameOrFrameReference ifTrue: [ aBlock value: key ].			val isFrameOrFrameReference ifTrue: [ aBlock value: val ]		]</body></methods><methods><class-id>COAST.CatCSMultiValueDictionary</class-id> <category>testing</category><body package="COCellValueHolder">canCheckKeyRange	^ true</body></methods><methods><class-id>COAST.CatCSMultiValueDictionary class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#multiValueDictionary</body><body package="COCellValueHolder">valueClass	^ MultiValueDictionary</body></methods><methods><class-id>COAST.CatCSMultiValueDictionary class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^17</body></methods><methods><class-id>COAST.CatCSSortedSet</class-id> <category>accessing</category><body package="COFramesystem">lastElement	^ self value last</body><body package="COCellValueHolder">setCollectionValueAsRemoteArgument: newValue for: aCluster 	self class valueClass = newValue class 		ifTrue: [ self value: newValue copy ]		ifFalse: [ super setCollectionValueAsRemoteArgument: newValue for: aCluster ].</body><body package="COMarshalling">translatedArgumentForCluster: aCatCSCluster	^ self value translatedArgumentForCluster: aCatCSCluster</body></methods><methods><class-id>COAST.CatCSSortedSet</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 19</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	"cluster can be set to nil for compact collections"	aStream nextPut: self class marshallID.	aStream nextPut: self index.	self marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	"cluster and morph selector can be set to nil for compact collections"	self unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: nil.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	value := self valueClass unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.</body></methods><methods><class-id>COAST.CatCSSortedSet class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ CoastSortedSet</body></methods><methods><class-id>COAST.CatCSSortedSet class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^19</body></methods><methods><class-id>COAST.CatCSSortedSet class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#sortedSet</body></methods><methods><class-id>COAST.CatCSCompactSet</class-id> <category>initialize - release</category><body package="COCellValueHolder">initializeWithSize: anInteger	self value: (self valueClass new: anInteger)</body></methods><methods><class-id>COAST.CatCSCompactSet</class-id> <category>accessing</category><body package="COFramesystem">lastElement	^ self value lastElement</body><body package="COCellValueHolder">referencesElementsCursorDo: aBlock 	^ self value referencesElementsCursorDo: aBlock</body><body package="COCellValueHolder">setCollectionValueAsRemoteArgument: newValue for: aCluster	self class valueClass = newValue class		ifTrue: [ 	self value: newValue copy ]		ifFalse: [ super setCollectionValueAsRemoteArgument: newValue for: aCluster ]</body><body package="COMarshalling">translatedArgumentForCluster: aCatCSCluster	^ self value translatedArgumentForCluster: aCatCSCluster</body></methods><methods><class-id>COAST.CatCSCompactSet</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 6</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	"cluster can be set to nil for compact collections"	aStream nextPut: self class marshallID.	aStream nextPut: self index.	self marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	self value marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	"cluster and morph selector can be set to nil for compact collections"	self unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: nil.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	value := self valueClass unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.</body></methods><methods><class-id>COAST.CatCSCompactSet class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ CompactSet</body></methods><methods><class-id>COAST.CatCSCompactSet class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#compactSet</body></methods><methods><class-id>COAST.CatCSCompactSet class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^6</body></methods><methods><class-id>COAST.CatCSCompactRPCResultCollection</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall	self value valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall.</body><body package="COMarshalling">index	^ 18</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	"cluster can be set to nil for compact collections"	aStream nextPut: self class marshallID.	aStream nextPut: self index.	self marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	self value marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	"cluster and morph selector can be set to nil for compact collections"	self unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: nil.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	value := self valueClass unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.</body></methods><methods><class-id>COAST.CatCSCompactRPCResultCollection class</class-id> <category>marshalling</category><body package="COCellValueHolder">valueClass	^ CompactRPCResultCollection</body></methods><methods><class-id>COAST.CatCSCompactRPCResultCollection class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^18</body></methods><methods><class-id>COAST.CatCSCompactRPCResultCollection class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^nil</body></methods><methods><class-id>COAST.CatCSOrderedCollection</class-id> <category>accessing</category><body package="COCellValueHolder">coastInternalAdd: anObject after: oldObject	^value add: anObject after: oldObject.</body><body package="COCellValueHolder">coastInternalAdd: anObject afterIndex: anIndex	^value coastAdd: anObject afterIndex: anIndex</body><body package="COCellValueHolder">coastInternalAdd: anObject before: oldObject	^value add: anObject before: oldObject.</body><body package="COCellValueHolder">coastInternalAdd: anObject beforeIndex: anIndex	^value add: anObject beforeIndex: anIndex.</body><body package="COCellValueHolder">coastInternalAdd: anObject withAccess: access 	^ value addLast: anObject</body><body package="COCellValueHolder">coastInternalRemove: oldObject withAccess: access 	^ value remove: oldObject ifAbsent: [ ]</body><body package="COCellValueHolder">coastInternalRemoveAtIndex: anIndex	^value removeAtIndex: anIndex.</body><body package="COCellValueHolder">coastKeyRangeFor: object 	^ self value coastKeyRangeFor: object</body><body package="COCellValueHolder">remap: aCatCSCellAccessClass	^ aCatCSCellAccessClass remapForOrderedCollection</body></methods><methods><class-id>COAST.CatCSOrderedCollection</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 3</body></methods><methods><class-id>COAST.CatCSOrderedCollection class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ OrderedCollection</body></methods><methods><class-id>COAST.CatCSOrderedCollection class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#orderedCollection</body></methods><methods><class-id>COAST.CatCSOrderedCollection class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^3</body></methods><methods><class-id>COAST.CompactKeyDictionary</class-id> <category>private</category><body package="COCellValueHolder">basicAppendAll: otherCompactCollections 	| subCollections |	super basicAppendAll: otherCompactCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | anotherCompactCollection values ].	values := values coastOptimizedAppendAll: subCollections.</body><body package="COCellValueHolder">basicGrowBy: size 	super basicGrowBy: size.	values := values coastOptimizedGrownBy: size.</body><body package="COFramesystem">compactAddLastKey: key value: value index: index 	self compactAddLast: key index: index.	values at: index put: value</body><body package="COCellValueHolder">compactValueAtIndex: index 	^ values at: index</body><body package="COCellValueHolder">compactValueAtIndex: index into: assoc 	| value |	value := values at: index.	assoc value: value.</body><body package="COCellValueHolder">defaultValueCursor	^ nil</body><body package="COCellValueHolder">initializeArraysSized: size	super initializeArraysSized:size.	values := Array new: size.</body><body package="COCellValueHolder">values	self compact.	^ values</body><body package="COCellValueHolder">valuesAt: index put: value 	values at: index put: value</body></methods><methods><class-id>COAST.CompactKeyDictionary</class-id> <category>accessing</category><body package="COCellValueHolder">coastTotalByteSize	^ super coastTotalByteSize		+ values coastTotalByteSize</body></methods><methods><class-id>COAST.CompactKeyDictionary</class-id> <category>compact</category><body package="COCellValueHolder">transformWith: transformation from: original 	values transformWith: transformation from: original valuesForCompact.	super transformWith: transformation from: original.</body><body package="COCellValueHolder">valuesForCompact	^ values</body></methods><methods><class-id>COAST.CompactKeyDictionary</class-id> <category>copying</category><body package="COCellValueHolder">cropFrom: start to: stop	super cropFrom: start to: stop.	values := values copyFrom: start to: stop</body></methods><methods><class-id>COAST.CompactKeyDictionary</class-id> <category>system primitives</category><body package="COCellValueHolder">isImmutable: aBoolean 	"frameIDs etc are not supposed to be modified"	super isImmutable: aBoolean.	values isImmutable: aBoolean.</body></methods><methods><class-id>COAST.CompactKeyDictionary</class-id> <category>marshalling</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSCompactKeyDictionary new )		value: self;		yourself</body><body package="COMarshalling">marshallValuesTo: aStream marshaller: aCatRMMarshall forCluster: aCluster 	aCatRMMarshall optimizedMarshall: values to: aStream.</body><body package="COMarshalling">unmarshallValuesFrom: aStream marshaller: aCatRMMarshall forCluster: aCluster morph: morphSelector 	aCatRMMarshall optimizedUnmarshall: values from: aStream morph: morphSelector.</body></methods><methods><class-id>COAST.CatCSSlotDictionary</class-id> <category>accessing</category><body package="COCellValueHolder">associationAt: key	self halt: 'not yet implemented'</body><body package="COCellValueHolder">associations	self halt: 'not yet implemented'</body><body package="COCellValueHolder">at: key	1 to: value size		do: 		[: i | | slot |			slot := value at: i.			slot id == key ifTrue: [ ^ slot ]		].	^ nil</body><body package="COCellValueHolder">atKey: key 	1 to: value size		do: 		[: i | | slot |			slot := value at: i.			slot id = key ifTrue: [ ^ slot ]		].	^ nil</body><body package="COCellValueHolder">coastInternalAt: key put: aSlot	| idx |	idx := self findIndexFor: key.	idx isNil		ifTrue: [ self growWithKey: key value: aSlot ]		ifFalse: [ value at: idx put: aSlot ].	^aSlot</body><body package="COCellValueHolder">coastInternalRemoveKey: oldKey 	| toBeRemoved |	toBeRemoved := self at: oldKey.	toBeRemoved isNil ifTrue: [ ^ nil ].	value := value copyWithout: toBeRemoved.	^ toBeRemoved</body><body package="COCellValueHolder">coastTotalByteSize	" total size of the valueholder and it's values "	^ self coastObjectSize + (value inject: self coastObjectSize into: [ : sz : val | sz + val coastTotalByteSize ])</body><body package="COCellValueHolder">includesKey: key 	1 to: value size		do: 		[: i | | slot |			slot := value at: i.			( slot notNil and: [ slot id == key ]) ifTrue: [ ^ true ]		].	^ false</body><body package="COCellValueHolder">keyAtValue: aValue	self halt: 'not supported'</body><body package="COCellValueHolder">keys	^self halt: 'check if needed'</body><body package="COCellValueHolder">keysAndValuesDo: aBlock	value do: [ :slot | aBlock value: slot id value: slot ]</body><body package="COCellValueHolder">removeKey: oldKey	self halt: 'not supported'</body><body package="COCellValueHolder">removeSlot: oldKey	"warning: only works in single-user mode"	value := (value asOrderedCollection reject: [ :slot | slot id = oldKey ]) asArray.</body><body package="COCellValueHolder">values	^value</body></methods><methods><class-id>COAST.CatCSSlotDictionary</class-id> <category>private</category><body package="COCellValueHolder">findIndexFor: key	"find the index for the given key. an empty place serves as well"	1 to: value size do: [ :idx | | val |		val := value at: idx.		val isNil ifTrue: [ ^idx ].		val id = key ifTrue: [ ^idx ].	].	^nil</body><body package="COCellValueHolder">growWithKey: key value: anObject	value := value copyWith: anObject.	^anObject</body></methods><methods><class-id>COAST.CatCSSlotDictionary</class-id> <category>initialize - release</category><body package="COCellValueHolder">initializeWithSize: anInteger	self value: (self valueClass new: anInteger)</body></methods><methods><class-id>COAST.CatCSSlotDictionary</class-id> <category>garbage collect</category><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock 	"for use of garbage-collection only!"</body></methods><methods><class-id>COAST.CatCSSlotDictionary</class-id> <category>testing</category><body package="COClusterManagement">hasNonWeakObservers	^value contains: [ : slot | slot hasNonWeakObservers ]</body><body package="COClusterManagement">hasObservers	^value contains: [ : slot | slot hasObservers ]</body><body package="COCellValueHolder">isDefect	^false</body></methods><methods><class-id>COAST.CatCSSlotDictionary</class-id> <category>copying</category><body package="COCellValueHolder">constructCopyParameters: coastCopyContext 	self shouldNotImplement.</body></methods><methods><class-id>COAST.CatCSSlotDictionary</class-id> <category>marshalling</category><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: value size.	value do: 		[: slot |			aCatRMMarshall marshallValue: slot id to: aStream.			aCatRMMarshall marshallValue: slot to: aStream		].</body></methods><methods><class-id>COAST.CatCSSlotDictionary class</class-id> <category>accessing</category><body package="COCellValueHolder">isAbstractCoastValueHolder	^ true</body><body package="COCellValueHolder">slotSymbol	^nil</body></methods><methods><class-id>COAST.CatCSSlotDictionary class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ Array</body></methods><methods><class-id>COAST.CatCSSlotDictionary class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^nil</body></methods><methods><class-id>COAST.CatCSCompactValueIndex</class-id> <category>marshalling</category><body package="COCellValueHolder">index	^ 11</body></methods><methods><class-id>COAST.CatCSCompactValueIndex</class-id> <category>compact</category><body package="COCellValueHolder">compact		self value compact</body></methods><methods><class-id>COAST.CatCSCompactValueIndex</class-id> <category>testing</category><body package="COFramesystem">referencesSharedFrame: frame 	^ self values includes: frame</body></methods><methods><class-id>COAST.CatCSCompactValueIndex class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ CompactValueIndex</body></methods><methods><class-id>COAST.CatCSCompactValueIndex class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#compactValueIndex</body></methods><methods><class-id>COAST.CatCSCompactValueIndex class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^11</body></methods><methods><class-id>COAST.CatCSDelegatingProxyBag</class-id> <category>private</category><body package="COCellValueHolder">* aSet 	| result probe |	result := self valueFrame * aSet.	probe := self uncleanedRemoved.	probe notNil ifTrue: [ probe do: [: e | result removeAllOccurrencesOf: e ifAbsent: nil ]].	probe := self added.	probe notNil ifTrue: [ result addAll: probe ].	^ result</body><body package="COCellValueHolder">addedSize	| probe |	^ ( probe := self added ) isNil 		ifTrue: [ 0 ]		ifFalse: 		[ "compute the differences to the shared frame!"			"addedSize can be negative (e.g. 4x myObject, 1x removed ==&gt; added: 3xObject, addedSize = -1"			| sum isDepleted |			sum := 0.			isDepleted := self isDepleted.			probe keysAndValuesDo: 				[: aValue : newCount | | oldCount |					oldCount := isDepleted 							ifTrue: [ 0 ]							ifFalse: [( self valueFrameAtKey: aValue ) ifNil: [ 0 ]].					sum := sum + newCount - oldCount				].			^ sum		]</body><body package="COCellValueHolder">coastInternalAdd: key 	| count |	count := ( self atKey: key ifAbsent: [ 0 ]) + 1.	self addedAtKey: key put: count.	self removedRemove: key ifAbsent: nil.	^ key</body><body package="COCellValueHolder">coastInternalRemove: key ifAbsent: absentBlock 	| count |	count := self atKey: key ifAbsent: [ ^ absentBlock value ].	count &lt; 1 ifTrue: [ ^ absentBlock value "can be &lt; 0 when key was removed in this transaction while the key was removed remote"].	count = 1 		ifTrue: 		[	self addedRemoveKey: key ifAbsent: nil.			self removedAdd: key		]		ifFalse: [ self addedAtKey: key put: count - 1 ].	^ key</body><body package="COCellValueHolder">collectionTypeForCollect	^ Bag</body><body package="COCellValueHolder">copy	| copy |	copy := Bag new.	self valuesAndCountsDo: [: aValue : count | copy add: aValue withOccurrences: count ].	^ copy</body><body package="COCellValueHolder">markRemovedAsDirty	self shouldNotImplement</body><body package="COCellValueHolder">occurrencesOf: aValue 	^ self atKey: aValue</body><body package="COCellValueHolder">removedSize	| probe |	^ ( probe := self removed ) isNil 		ifTrue: [ 0 ]		ifFalse: 		[ "compute the differences to the shared frame!"			| sum |			sum := 0.			probe do: 				[: aValue | | oldCount |					oldCount := ( self valueFrameAtKey: aValue ) ifNil: [ 0 ].					sum + oldCount				].			^ sum		]</body><body package="COCellValueHolder">uncleandRemovedSize	| probe |	^ ( probe := self uncleanedRemoved ) isNil 		ifTrue: [ 0 ]		ifFalse: 		[ "compute the differences to the shared frame!"			| sum |			sum := 0.			probe do: 				[: aValue | | oldCount |					oldCount := ( self valueFrameAtKey: aValue ) ifNil: [ 0 ].					sum + oldCount				].			^ sum		]</body><body package="COCellValueHolder">valueFrameAtKey: key 	key coastIsValidRPCArgument ifFalse: [ ^ 0 ].	^ self valuePerform: #occurrencesOf: withArguments: ( Array with: key ) default: nil</body><body package="COCellValueHolder">valuesAndCountsDo: block 	"valueFrame must be realy loaded"	| probe |	( probe := self added ) isNil ifFalse: [ probe keysAndValuesDo: block ].	self valueFrameIsPresent ifFalse: [ ^ self ].	self valueFrame valuesAndCountsDo: 		[: key : aValue | (( self addedIncludesKey: key ) or: [ self uncleanedRemovedIncludes: key ]) 				ifFalse: [ block value: key value: aValue ]		]</body></methods><methods><class-id>COAST.CatCSDelegatingProxyBag</class-id> <category>accessing</category><body package="COCellValueHolder">addedIncludes: aValue 	| probe |	^ ( probe := self added ) notNil and: [( probe at: aValue ifAbsent: [ 0 ]) &gt; 0 ]</body><body package="COCellValueHolder">do: block 	self valuesAndCountsDo: [: aValue : count | count timesRepeat: [ block value: aValue ]]</body><body package="COFramesystem">frame: frame at: slotName replace: oldValue with: newValue	self frame: frame atBagSlotNamed: slotName replace: oldValue with: newValue</body><body package="COFramesystem">invertFrame: frame slotName: slotName added: addedFrame with: demon 	( frame at: slotName includes: addedFrame ) ifFalse: [ frame at: slotName add: addedFrame ]</body><body package="COFramesystem">invertFrame: frame slotName: slotName removed: removedFrame with: demon 	frame at: slotName remove: removedFrame</body><body package="COCellValueHolder">valueClass	^ Bag</body></methods><methods><class-id>COAST.CatCSDelegatingProxyBag</class-id> <category>marshalling</category><body package="COMarshalling">index	^ 15</body></methods><methods><class-id>COAST.CatCSCompactKeyDictionary</class-id> <category>initialize - release</category><body package="COCellValueHolder">initializeWithSize: anInteger	self value: (self valueClass new: anInteger)</body></methods><methods><class-id>COAST.CatCSCompactKeyDictionary</class-id> <category>accessing</category><body package="COCellValueHolder">compactElementAtIndex: index 	^ self value compactElementAtIndex: index</body><body package="COFramesystem">lastElement	^ self value lastElement</body><body package="COCellValueHolder">referencedFramesOrLocatorsCursorDo: aBlock 	self value referencesElementsCursorDo: 		[: assoc |			assoc key isFrameOrFrameReference ifTrue: [ aBlock value: assoc key ].			assoc value isFrameOrFrameReference ifTrue: [ aBlock value: assoc value ]		].</body><body package="COMarshalling">translatedArgumentForCluster: aCatCSCluster	^ self value translatedArgumentForCluster: aCatCSCluster</body></methods><methods><class-id>COAST.CatCSCompactKeyDictionary</class-id> <category>private</category><body package="COCellValueHolder">referencesElementsCursorDo: aBlock 	^ self value referencesElementsCursorDo: aBlock</body></methods><methods><class-id>COAST.CatCSCompactKeyDictionary</class-id> <category>compact</category><body package="COCellValueHolder">compact	self value compact.</body></methods><methods><class-id>COAST.CatCSCompactKeyDictionary</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall	self value valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall.</body><body package="COMarshalling">index	^ 7</body><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall 	"cluster can be set to nil for compact collections"	aStream nextPut: self class marshallID.	aStream nextPut: self index.	self marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall 	self value marshallBinaryValueTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">unmarshallBinaryArgumentFrom: aStream marshaller: aCatRMMarshall 	"cluster and morph selector can be set to nil for compact collections"	self unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: nil.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	value := self valueClass unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.</body></methods><methods><class-id>COAST.CatCSCompactKeyDictionary class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ CompactKeyDictionary</body></methods><methods><class-id>COAST.CatCSCompactKeyDictionary class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^7</body></methods><methods><class-id>COAST.CatCSCompactKeyDictionary class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#compactKeyDictionary</body></methods><methods><class-id>COAST.CatCSFrameDictionary</class-id> <category>copying</category><body package="COCellValueHolder">copyForRollback	" rollback is done by looking at the agenda "	^ nil</body></methods><methods><class-id>COAST.CatCSFrameDictionary</class-id> <category>initialize - release</category><body package="COCellValueHolder">initializeWithSize: anInteger	self value: (self valueClass new: (anInteger * 3 // 2) )</body></methods><methods><class-id>COAST.CatCSFrameDictionary</class-id> <category>testing</category><body package="COClusterManagement">hasNonWeakObservers	^value contains: [ : frame | frame hasNonWeakObservers ]</body><body package="COClusterManagement">hasObservers	^value contains: [ : frame | frame hasObservers ]</body></methods><methods><class-id>COAST.CatCSFrameDictionary class</class-id> <category>accessing</category><body package="COCellValueHolder">isAbstractCoastValueHolder	^ true</body><body package="COCellValueHolder">slotSymbol	^nil</body></methods><methods><class-id>COAST.CatCSFrameDictionary class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ CatCOIntegerKeyDictionary</body></methods><methods><class-id>COAST.CatCSFrameDictionary class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^nil</body></methods><methods><class-id>COAST.CompactDictionary</class-id> <category>accessing</category><body package="COCellValueHolder">at: frame ifAbsent: aBlock 	| valueRef frameReference |	frameReference := frame asValidFrameReferenceOrNil.	frameReference isNil ifTrue: [ ^ aBlock value ].	valueRef := self atFrameReference: frameReference ifAbsent: [ ^ aBlock value ].	^ clusterManager resolveFrameReference: valueRef</body><body package="COCellValueHolder">at: frame ifAbsentPut: aBlock 	^ self at: frame		ifAbsent: 		[ | obj |			obj := aBlock value.			self at: frame put: obj.			obj		]</body><body package="COCellValueHolder">at: keyFrame put: valueFrame 	self clusterManagerFrom: keyFrame.	self clusterManagerFrom: valueFrame.	self addElement: keyFrame asCompactArgument -&gt; valueFrame asCompactArgument.	^ valueFrame</body><body package="COCellValueHolder">atKey: frame ifAbsent: aBlock 	| valueRefOrNil |	valueRefOrNil := super atKey: frame ifAbsent: aBlock.	^ valueRefOrNil notNil 		ifTrue: [ clusterManager resolveFrameReference: valueRefOrNil ]		ifFalse: [ valueRefOrNil ]</body><body package="COCellValueHolder">coastTotalByteSize	^ super coastTotalByteSize		+ valueClassIndices coastTotalByteSize		+ valueFrameIDs coastTotalByteSize		+ valueClusterIDs coastTotalByteSize		+ valueFrameClassArray coastTotalByteSize</body><body package="COCellValueHolder">restrictToValues: rvalues	"return a copy restricted to the given values"	| restrictedDict |	restrictedDict := Dictionary new: rvalues size.	self keysAndValuesDo: [ : k : v | (rvalues includes: v) ifTrue: [ restrictedDict at: k put: v ] ].	^restrictedDict</body></methods><methods><class-id>COAST.CompactDictionary</class-id> <category>private</category><body package="COCellValueHolder">basicAppendAll: otherCompactCollections 	| subCollections |	super basicAppendAll: otherCompactCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | anotherCompactCollection valueFrameIDs ].	valueFrameIDs := valueFrameIDs coastOptimizedAppendAll: subCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | anotherCompactCollection valueClusterIDs ].	valueClusterIDs := valueClusterIDs coastOptimizedAppendAll: subCollections.	subCollections := otherCompactCollections collect: [: anotherCompactCollection | self patchedValueClassIndicesOf: anotherCompactCollection ].	valueClassIndices := valueClassIndices coastOptimizedAppendAll: subCollections.</body><body package="COCellValueHolder">basicGrowBy: size 	super basicGrowBy: size.	valueFrameIDs := valueFrameIDs coastOptimizedGrownBy: size.	valueClusterIDs := valueClusterIDs coastOptimizedGrownBy: size.	valueClassIndices := valueClassIndices coastOptimizedGrownBy: size.</body><body package="COFramesystem">compactAddLastKey: key value: value index: index 	self compactAddLast: key index: index.	valueClusterIDs at: index put: value clusterID.	valueFrameIDs at: index put: value frameID.	valueClassIndices at: index put: ( self valueClassIndexFor: value )</body><body package="COCellValueHolder">compactValueAtIndex: index 	^ CatFSFrameReference clusterID: ( valueClusterIDs at: index ) id: ( valueFrameIDs at: index ) classSymbol: ( self valueClassAtIndex: index )</body><body package="COCellValueHolder">compactValueAtIndex: index into: assoc 	| frameReference |	frameReference := assoc value.	frameReference clusterID: ( valueClusterIDs at: index ).	frameReference id: ( valueFrameIDs at: index ).	frameReference frameClassSymbol: ( self valueClassAtIndex: index ).</body><body package="COCellValueHolder">do: aBlock 	self referencesElementsCursorDo: [: assoc | aBlock value: ( clusterManager resolveFrameReferenceCursor: assoc value )].</body><body package="COCellValueHolder">initializeArraysSized: size 	super initializeArraysSized: size.	valueFrameIDs := SmallIntegerArray new: size.	valueClusterIDs := SmallIntegerArray new: size.	valueClassIndices := ByteArray new: size.	valueFrameClassArray := Array new</body><body package="COCellValueHolder">keysAndValuesDo: aBlock 	super keysAndValuesDo: 		[: keyFrame : valueRef | | valueFrame |			valueFrame := clusterManager resolveFrameReferenceCursor: valueRef.			aBlock value: keyFrame value: valueFrame		].</body><body package="COCellValueHolder">patchedValueClassIndicesOf: anotherCompactCollection 	"check if i and anotherCompactCollection agree about the class indices"	"extend my frameClassIndex, if needed"	"patch the classIndices only if needed (there is a class with my index ~= others index)"	| patchTable |	patchTable := anotherCompactCollection valueFrameClassArray collect: [: class | self valueClassIndexFor: class ].	patchTable keysAndValuesDo: [: k : v | k ~= v ifTrue: [ ^ anotherCompactCollection valueClassIndices collect: [: i | patchTable at: i ]]].	^ anotherCompactCollection valueClassIndices</body><body package="COCellValueHolder">valueClassAtIndex: index 	| classIndex |	classIndex := valueClassIndices at: index.	^ valueFrameClassArray at: classIndex</body><body package="COCellValueHolder">valueClassIndexFor: frameReference 	"valueFrameClassArray contains symbols and/or classes"	| frameKey otherFrameSymbol |	frameKey := frameReference frameKey.	valueFrameClassArray keysAndValuesDo: [: index : classOrSymbol | classOrSymbol == frameKey ifTrue: [ ^ index ]].	otherFrameSymbol := frameReference frameClassSymbol.	valueFrameClassArray keysAndValuesDo: [: index : classOrSymbol | classOrSymbol frameClassSymbol = otherFrameSymbol ifTrue: [ ^ index ]].	valueFrameClassArray := valueFrameClassArray copyWith: frameKey.	^ valueFrameClassArray size</body><body package="COCellValueHolder">valueClassIndices	^ valueClassIndices</body><body package="COCellValueHolder">valueClusterIDs	^ valueClusterIDs</body><body package="COCellValueHolder">valueFrameClassArray	^ valueFrameClassArray</body><body package="COCellValueHolder">valueFrameIDs	^ valueFrameIDs</body><body package="COCellValueHolder">values	| values |	values := OrderedCollection new.	self keysAndValuesDo: [: frame : value | values add: value ].	^ values</body><body package="COCellValueHolder">valuesAt: index put: aFrameLocator 	valueClusterIDs at: index put: aFrameLocator clusterID.	valueFrameIDs at: index put: aFrameLocator frameID.	valueClassIndices at: index put: ( self valueClassIndexFor: aFrameLocator )</body></methods><methods><class-id>COAST.CompactDictionary</class-id> <category>compact</category><body package="COCellValueHolder">transformWith: transformation from: original 	valueFrameClassArray := original valueFrameClassArray.	valueClusterIDs transformWith: transformation from: original valueClusterIDs.	valueFrameIDs transformWith: transformation from: original valueFrameIDs.	valueClassIndices transformWith: transformation from: original valueClassIndices.	super transformWith: transformation from: original.</body></methods><methods><class-id>COAST.CompactDictionary</class-id> <category>copying</category><body package="COCellValueHolder">cropFrom: start to: stop	super cropFrom: start to: stop.	valueFrameIDs := valueFrameIDs copyFrom: start to: stop.	valueClusterIDs := valueClusterIDs copyFrom: start to: stop.	valueClassIndices := valueClassIndices copyFrom: start to: stop</body></methods><methods><class-id>COAST.CompactDictionary</class-id> <category>marshalling</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSCompactDictionary new )		value: self;		yourself</body><body package="COMarshalling">marshallBinaryValueFrameClassesTo: aStream marshaller: aCatRMMarshall 	| valueFrameClassArraySize |	valueFrameClassArraySize := valueFrameClassArray size.	( valueClassIndices isEmpty or: [ valueFrameClassArraySize &gt; 1 ]) 		ifTrue: [ valueClassIndices do: [: fc | aStream nextPut: fc ]]		ifFalse: [ aStream nextPut: 0	"optimize one class collections" ].	aStream nextOptimized32Put: valueFrameClassArraySize.	valueFrameClassArray do: [: aSymbolOrClass | aCatRMMarshall writeFrameClassSymbol: aSymbolOrClass to: aStream ]</body><body package="COMarshalling">marshallValuesTo: aStream marshaller: aCatRMMarshall forCluster: aCluster 	aCatRMMarshall optimized32Marshall: valueClusterIDs to: aStream.	valueFrameIDs do: [: fid | aStream nextOptimized32Put: fid ].	self marshallBinaryValueFrameClassesTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">unmarshallBinaryValueFrameClassesFrom: aStream marshaller: aCatRMMarshall 	| valueFrameClassCount elementsCount |	elementsCount := valueClassIndices size.	( valueClassIndices isEmpty or: [ aStream peek &gt; 0 ]) 		ifTrue: [ 1 to: elementsCount do: [: index | valueClassIndices at: index put: aStream next ]]		ifFalse: 		[	aStream next.	"optimized for one class collections"			1 to: elementsCount do: [: index | valueClassIndices at: index put: 1 ]		].	valueFrameClassArray := Array new: ( valueFrameClassCount := aStream nextOptimized32 ).	1 to: valueFrameClassCount		do: [: index | valueFrameClassArray at: index put: ( aCatRMMarshall readFrameKeyFrom: aStream )]</body><body package="COMarshalling">unmarshallValuesFrom: aStream marshaller: aCatRMMarshall forCluster: aCluster morph: morphSelector 	| elementsCount |	elementsCount := clusterIDs size.	aCatRMMarshall optimized32Unmarshall: valueClusterIDs from: aStream.	"except clusterID to be a storeable in two byte"	1 to: elementsCount do: [: index | valueFrameIDs at: index put: aStream nextOptimized32 ].	self unmarshallBinaryValueFrameClassesFrom: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CatCSCompactKeyIndex</class-id> <category>accessing</category><body package="COCellValueHolder">index	^ 16</body></methods><methods><class-id>COAST.CatCSCompactKeyIndex</class-id> <category>compact</category><body package="COCellValueHolder">compact		self value compact</body></methods><methods><class-id>COAST.CatCSCompactKeyIndex</class-id> <category>testing</category><body package="COFramesystem">referencesSharedFrame: frame 	^ self includesKey: frame</body></methods><methods><class-id>COAST.CatCSCompactKeyIndex class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#compactKeyIndex</body><body package="COCellValueHolder">valueClass	^ CompactKeyIndex</body></methods><methods><class-id>COAST.CatCSCompactKeyIndex class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^16</body></methods><methods><class-id>COAST.CatCSCompactIndex</class-id> <category>marshalling</category><body package="COCellValueHolder">index	^ 10</body></methods><methods><class-id>COAST.CatCSCompactIndex</class-id> <category>compact</category><body package="COCellValueHolder">compact	self value compact.</body></methods><methods><class-id>COAST.CatCSCompactIndex class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ CompactIndex</body></methods><methods><class-id>COAST.CatCSCompactIndex class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#compactIndex</body></methods><methods><class-id>COAST.CatCSCompactIndex class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^10</body></methods><methods><class-id>COAST.CompactBag</class-id> <category>accessing</category><body package="COCellValueHolder">* collection 	^ self coastAsSet * collection</body><body package="COCellValueHolder">add: frame 	^ self add: frame withOccurrences: 1</body><body package="COCellValueHolder">add: frame withOccurrences: anInteger 	| occ |	self clusterManagerFrom: frame.	occ := self occurrencesOf: frame.	self at: frame put: occ + anInteger.	^ frame</body><body package="COCellValueHolder">atKeys: badArgument 	^ self shouldNotImplement</body><body package="COCellValueHolder">coastAsSet	self compact.	^( CompactSet new )		clusterIDs: clusterIDs copy frameIDs: frameIDs copy classIndices: classIndices copy frameClassArray: frameClassArray copy;		clusterManager: clusterManager;		yourself</body><body package="COCellValueHolder">coastAsSetOrYourself	^ self coastAsSet</body><body package="COCellValueHolder">do: aBlock 	self keysAndValuesDo: [: frame : occ | occ timesRepeat: [ aBlock value: frame ]]</body><body package="COCellValueHolder">includes: frame 	^ self includesKey: frame</body><body package="COCellValueHolder">numberOfKeys	^ self coastCompactElementCount</body><body package="COCellValueHolder">occurrencesOf: frame 	^ self atKey: frame ifAbsent: [ 0 ]</body><body package="COCellValueHolder">remove: frame ifAbsent: absentBlock 	| occ |	occ := self atKey: frame ifAbsent: [ ^ absentBlock value ].	^ occ = 1 		ifTrue: [ self removeKey: frame ]		ifFalse: [ self at: frame put: occ - 1 ]</body><body package="COCellValueHolder">removeAllOccurrencesOf: frame ifAbsent: absentBlock 	^ self removeKey: frame ifAbsent: absentBlock</body><body package="COCellValueHolder">simpleClass	^ Bag</body><body package="COCellValueHolder">size	| sum |	sum := 0.	self referencesElementsCursorDo: [: assoc | sum := sum + assoc value ].	^ sum</body><body package="COCellValueHolder">valuesAndCountsDo: block 	self keysAndValuesDo: block</body></methods><methods><class-id>COAST.CompactBag</class-id> <category>marshalling</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSCompactBag new )		value: self;		yourself</body><body package="COMarshalling">marshallValuesTo: aStream marshaller: aCatRMMarshall forCluster: aCluster 	values do: [: each | aStream nextOptimized32Put: each ]</body><body package="COMarshalling">unmarshallValuesFrom: aStream marshaller: aCatRMMarshall forCluster: aCluster morph: morphSelector 	1 to: values size do: [: index | values at: index put: aStream nextOptimized32 ]</body></methods><methods><class-id>COAST.CatCSDefectSlotDictionary</class-id> <category>testing</category><body package="COCellValueHolder">isDefect	^true</body></methods><methods><class-id>COAST.CatCSDefectSlotDictionary</class-id> <category>accessing</category><body package="COCellValueHolder">coastInternalAt: key put: aSlot	CoastError raiseSignal: 'new slots cannot be added to defect frames'</body></methods><methods><class-id>COAST.CatCSCompactDictionary</class-id> <category>marshalling</category><body package="COCellValueHolder">index	^ 9</body></methods><methods><class-id>COAST.CatCSCompactDictionary class</class-id> <category>constants</category><body package="COCellValueHolder">valueClass	^ CompactDictionary</body></methods><methods><class-id>COAST.CatCSCompactDictionary class</class-id> <category>accessing</category><body package="COCellValueHolder">slotSymbol	^#compactDictionary</body></methods><methods><class-id>COAST.CatCSCompactDictionary class</class-id> <category>pragma</category><body package="COCellValueHolder">valueHolderIndex	^9</body></methods><methods><class-id>COAST.CatMARepeatedObject</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	self subclassResponsibility.</body></methods><methods><class-id>COAST.CatMARepeatedObject</class-id> <category>accessing</category><body package="COMarshalling">asInteger	self subclassResponsibility.</body></methods><methods><class-id>COAST.CatMARepeatedObject</class-id> <category>testing</category><body package="COMarshalling">isCoastOptimizedInteger	^ true</body></methods><methods><class-id>COAST.CatMARepeatedObject class</class-id> <category>instance creation</category><body package="COMarshalling">flushSingletons</body><body package="COMarshalling">fromCount: count 	^ count = 1 		ifTrue: [ CatMASingleRepeatedObject fromCount: count ]		ifFalse: 		[	count &gt; 255 				ifTrue: [ CatMALongRepeatedObject fromCount: count ]				ifFalse: [ CatMAShortRepeatedObject fromCount: count ]		]</body><body package="COMarshalling">obsolete	self flushSingletons.	self allInstances do: [ : inst | inst beMutable ].	super obsolete</body></methods><methods><class-id>COAST.CatMARepeatedObject class</class-id> <category>unmarshalling</category><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	self subclassResponsibility.</body></methods><methods><class-id>COAST.CoastVirtualInteger class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	self subclassResponsibility</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	self subclassResponsibility</body></methods><methods><class-id>COAST.SizeCalculatingStream</class-id> <category>accessing</category><body package="COMarshalling">byteSize	^ byteSize</body><body package="COMarshalling">byteSize: newByteSize 	byteSize := newByteSize</body></methods><methods><class-id>COAST.SizeCalculatingStream</class-id> <category>initialize - release</category><body package="COMarshalling">initialize	byteSize := 0</body></methods><methods><class-id>COAST.SizeCalculatingStream</class-id> <category>stream protocol</category><body package="COMarshalling">next16Put: dummy 	byteSize := byteSize + 2</body><body package="COMarshalling">next24Put: dummy 	byteSize := byteSize + 3</body><body package="COMarshalling">next32Put: dummy 	byteSize := byteSize + 4</body><body package="COMarshalling">next: anInteger putAll: aSequenceableCollection startingAt: startIndex 	byteSize := byteSize + anInteger + 1 - startIndex</body><body package="COMarshalling">nextCoastByteStringPut: aString 	aString size &lt; 255 		ifTrue: [ self nextPut: nil ]		ifFalse: 		[	self nextPut: 255.			self nextOptimized32Put: aString size		].	byteSize := byteSize + aString size.</body><body package="COMarshalling">nextCoastStringPut: aString 	"try as ByteString, dispatch for Non-ByteStrings"	| aByteString |	( aByteString := aString asByteString ) class = ByteString 		ifTrue: [ self nextCoastByteStringPut: aByteString ]		ifFalse: [ self nextCoastUTF8StringPut: aByteString ].</body><body package="COMarshalling">nextCoastTwoByteStringPut: twoByteString 	self nextOptimized32Put: twoByteString size.	byteSize := byteSize + ( twoByteString size * 2 ).</body><body package="COMarshalling">nextCoastUTF8StringPut: aString 	self nextPut: 255.	self nextOptimized32Put: aString size negated.	( EncodedStream on: self encodedBy: UTF8StreamEncoder new ) nextPutAll: aString.</body><body package="COMarshalling">nextOptimized32Put: a32BitVal 	byteSize := byteSize + ( self class nextOptimized32SizeOf: a32BitVal ).</body><body package="COMarshalling">nextPut: aByte 	byteSize := byteSize + 1</body><body package="COMarshalling">nextPutAll: byteArray 	byteSize := byteSize + byteArray size</body><body package="COMarshalling">nextShortStringPut: aString 	aString size &gt; 255 ifTrue: [ self error: 'String to long for this method. Use nextStringPut:' ].	byteSize := byteSize + aString size + 1</body><body package="COMarshalling">nextUnsigned32Put: dummy 	byteSize := byteSize + 4</body><body package="COMarshalling">position	^ byteSize</body></methods><methods><class-id>COAST.SizeCalculatingStream class</class-id> <category>calculating</category><body package="COMarshalling">nextOptimized32SizeOf: a32BitVal 	^ a32BitVal &lt; 64 		ifTrue: 		[	a32BitVal &lt; 0 				ifTrue: 				[	a32BitVal &lt; -2097152 						ifTrue: [ 4	"minVal .. -2097153" ]						ifFalse: [ 3	"-2097152 .. 0" ]				]				ifFalse: [ 1	"0..63" ]		]		ifFalse: 		[	a32BitVal &lt; 16384 				ifTrue: [ 2	"64 .. 16383" ]				ifFalse: 				[	a32BitVal &lt; 2097152 						ifTrue: [ 3	"16384 .. 2097151" ]						ifFalse: [ 4	"2097152 .. maxVal" ]				]		]</body></methods><methods><class-id>COAST.CoastHashStream</class-id> <category>accessing</category><body package="COMarshalling">atEnd	^ originalStream atEnd</body><body package="COMarshalling">contents	| writeStream |	writeStream := self contentsSpecies new readWriteStream.	[ self atEnd ] whileFalse: [ writeStream nextPut: self next ].	^ writeStream contents</body><body package="COMarshalling">contentsSpecies	^ ByteArray</body><body package="COMarshalling">coreStream	^ originalStream coreStream</body><body package="COMarshalling">flush	^ originalStream flush</body><body package="COMarshalling">next	| next |	next := originalStream next.	nil == next ifTrue: [ ^ nil ].	0 &lt; ignoreBytesCount 		ifTrue: [ ignoreBytesCount := ignoreBytesCount - 1 ]		ifFalse: 		[	bufferSize := 16 == bufferSize 					ifTrue: [ 1 ]					ifFalse: [ bufferSize + 1 ].			buffer at: bufferSize put: (( buffer at: bufferSize ) bitXor: next )		].	^ next</body><body package="COMarshalling">next: anInteger putAll: aSequenceableCollection startingAt: startIndex 	0 == ignoreBytesCount ifFalse: [ CoastFatalError raiseSignal: 'can not write after skip on hash stream' ].	startIndex to: startIndex + anInteger - 1 do: [: i | self hash: (aSequenceableCollection at: i) ].	^ originalStream 		next: anInteger		putAll: aSequenceableCollection		startingAt: startIndex</body><body package="COMarshalling">nextPut: next 	0 == ignoreBytesCount ifFalse: [ CoastFatalError raiseSignal: 'can not write after skip on hash stream' ].	self hash: next.	^ originalStream nextPut: next</body><body package="COMarshalling">originalStream	^ originalStream</body><body package="COMarshalling">originalStream: externalStream 	buffer := self class initialBuffer copy.	bufferSize := 0.	ignoreBytesCount := 0.	originalStream := externalStream.</body><body package="COMarshalling">peek	^ originalStream peek</body><body package="COMarshalling">position	^ originalStream position</body><body package="COMarshalling">size	^ originalStream size</body><body package="COMarshalling">skip: skip 	skip &gt; 0 		ifTrue: [ skip timesRepeat: [ self next ]]		ifFalse: 		[	ignoreBytesCount := ignoreBytesCount - skip.			originalStream skip: skip		].</body></methods><methods><class-id>COAST.CoastHashStream</class-id> <category>testing</category><body package="COMarshalling">closed	^ originalStream closed</body><body package="COMarshalling">isReadable	^ originalStream isReadable</body><body package="COMarshalling">isWritable	^ originalStream isWritable</body></methods><methods><class-id>COAST.CoastHashStream</class-id> <category>coast hash</category><body package="COMarshalling">storeCoastHash	originalStream nextPutAll: buffer.</body><body package="COMarshalling">verifyCoastHash	| readHash |	readHash := originalStream nextAvailable: 16.	^ readHash = buffer</body></methods><methods><class-id>COAST.CoastHashStream</class-id> <category>private</category><body package="COMarshalling">hash: next 	bufferSize := 16 == bufferSize 				ifTrue: [ 1 ]				ifFalse: [ bufferSize + 1 ].	buffer at: bufferSize put: ((buffer at: bufferSize) bitXor: next)</body></methods><methods><class-id>COAST.CoastHashStream class</class-id> <category>instance creation</category><body package="COMarshalling">originalStream: externalStream 	^ ( self basicNew )		originalStream: externalStream;		yourself</body></methods><methods><class-id>COAST.CoastHashStream class</class-id> <category>accessing</category><body package="COMarshalling">hashOf: byteArray stream: stream 	| checksum checksumSize limit |	limit := stream size.	checksum := self initialBuffer copy.	checksumSize := checksum size.	stream nextPutAll: ( ByteArray new: checksumSize ).	COBinaryExternal tryLibToXorFold: byteArray limit: limit checksum: checksum.</body><body package="COMarshalling">initialBuffer	"	 | ran buffer |       ran := Random fromGenerator: 5 seededWith: 2.       buffer := ByteArray new: 16.      1 to: 16 do: [: i | buffer at: i put: ( ran next * 256 ) floor ].	buffer"	^ #[ 61 109 186 48 137 251 3 50 250 126 87 106 175 254 222 82 ]</body></methods><methods><class-id>COAST.HuffmanDecodingNode</class-id> <category>accessing</category><body package="COMarshalling">nodeAt: byte	^ self at: byte + 1</body><body package="COMarshalling">nodeAt: byte put: node	self at: byte + 1 put: node</body></methods><methods><class-id>COAST.HuffmanDecodingNode</class-id> <category>testing</category><body package="COMarshalling">isLeaf	^ false</body></methods><methods><class-id>COAST.COBinaryExternal class</class-id> <category>accessing</category><body package="COMarshalling">libAvailable	libAvailable isNil ifTrue: 		[	libAvailable :=				[	self singleton xorFold: ( ByteArray new: 2 ) limit: 1 checksum: ( ByteArray new: 0 ).					CoastLog log: 'loaded &lt;coastbinary&gt; library'.					true				] on: Error					do: 					[: ex |						CoastLog log: 'failed to load &lt;coastbinary&gt; library: ', ex description.						false					]		].	^ libAvailable</body><body package="COMarshalling">resetLibAvailable	libAvailable := singleton := nil.</body><body package="COMarshalling">singleton	singleton isNil ifTrue: [ singleton := self new ].	^ singleton</body><body package="COMarshalling">tryLibToXorFold: byteArray limit: limit checksum: checksum 	self libAvailable 		ifTrue: [ singleton xorFold: byteArray limit: limit checksum: checksum ]		ifFalse: [ self xorFold: byteArray limit: limit checksum: checksum ].</body><body package="COMarshalling">xorFold: byteArray limit: limit checksum: checksum 	1 to: checksum size		do: 		[: startPos | | value |			value := checksum at: startPos.			startPos to: limit by: checksum size do: [: i | value := value bitXor: ( byteArray at: i )].			byteArray at: limit + startPos put: value		].</body></methods><methods><class-id>COAST.HuffmanStringCodec</class-id> <category>accessing</category><body package="COMarshalling">arrayStack	^ self class arrayStack</body><body package="COMarshalling">characterArray	^ self class characterArray</body><body package="COMarshalling">decode: string from: stream 	^self class decode: string from: stream</body><body package="COMarshalling">encode: string on: stream 	^self class encode: string on: stream</body><body package="COMarshalling">shouldCompress: string 	^ false " Performance, ungÃ¼nstiger statischer Baum ""	| maxSize |"	"only check first 16 characters""	maxSize := ( string size min: 16 ) * 8.	1 to: ( string size min: 16 )		do: 		[: i |			maxSize := maxSize - ( self characterArray at: ( string at: i ) asInteger + 1 ) size.			maxSize &lt; 0 ifTrue: [ ^ false ]		].	^ true"</body><body package="COMarshalling">sizeOf: string 	"string asArray collect: [: c | ( self characterArray at: c asInteger + 1 ) size ]."	^self class sizeOf: string</body></methods><methods><class-id>COAST.HuffmanStringCodec</class-id> <category>private</category><body package="COMarshalling">nextPutBytes: aByteArray on: stream bits: numBits encodeStatus: aHuffmanEncodeStatus	| sz last byte bitPos |	byte := aHuffmanEncodeStatus byte.	bitPos := aHuffmanEncodeStatus bitPos.	byte isNil 		ifTrue: 		[	" Start genau an der Bytegrenze "			bitPos := 0.			byte := aByteArray at: 1		]		ifFalse: 		[	" wenn nicht am Anfang: Bytes mergen "			byte := byte bitOr: ( aByteArray at: 1 )		].	" komplett innerhalb der Bytegrenze? "	(bitPos := bitPos + numBits) &gt;= 8 		ifTrue: 		[				bitPos := bitPos \\ 8.			stream nextPut: byte.			sz := aByteArray size.			bitPos = 0 				ifTrue: 				[	" Ende genau an der Bytegrenze "					last := sz.					byte := nil				]				ifFalse: 				[	" wenn nicht am Ende: Bytes mergen "					last := sz - 1.					byte := aByteArray at: sz				].			" der Rest kann so rausgekloppt werden "			2 to: last do: [: j | stream nextPut: ( aByteArray at: j )].		].	aHuffmanEncodeStatus byte: byte.	aHuffmanEncodeStatus bitPos: bitPos</body></methods><methods><class-id>COAST.HuffmanStringCodec class</class-id> <category>utility</category><body package="COMarshalling">addDecodingLeafTo: decodingNode forByte: byte character: char numberOfBits: numBits shift: bitShift 	" leaf. byte auffÃ¼llen und alle Varianten speichern "	| fillShift node |	fillShift := ( 8 - numBits - bitShift ) \\ 8.	0 to: ( 1 bitShift: fillShift ) - 1		do: 		[: fillByte | | leafByte leaf |			leafByte := byte bitOr: fillByte.			node := decodingNode nodeAt: leafByte.			node notNil 				ifTrue: [ self error: 'Corrupt Huffman tree' ].			leaf := HuffmanDecodingLeaf character: char numberOfBits: numBits.			decodingNode nodeAt: leafByte put: leaf		].	^ nil</body><body package="COMarshalling">addDecodingNodeTo: decodingNode forByte: byte character: char numberOfBits: numBits shift: bitShift 	| node |	node := decodingNode nodeAt: byte.	node isNil 		ifTrue: 		[	node := HuffmanDecodingNode new: 256.			decodingNode nodeAt: byte put: node		]		ifFalse: 		[	node isLeaf 				ifTrue: 				[	" kein leaf hier erwartet "					self error: 'Corrupt Huffman tree'				]		].	^ node</body><body package="COMarshalling">addDecodingNodesTo: decodingRoot bytes: bytes character: char numberOfBits: numBits shift: bitShift 	| decodingNode |	decodingNode := decodingRoot.	1 to: bytes size		do: 		[: i | | byte |			byte := bytes at: i.			decodingNode := i = bytes size 					ifTrue: [ self addDecodingLeafTo: decodingNode forByte: byte character: char numberOfBits: numBits shift: bitShift ]					ifFalse: [ self addDecodingNodeTo: decodingNode forByte: byte character: char numberOfBits: numBits shift: bitShift ]		].</body><body package="COMarshalling">arrayStackFrom: dict	[ dict size &gt; 1 ] whileTrue: 		[ | sortedKeys min1 min2 |			sortedKeys := dict keys asSortedCollection: 					[: a1 : a2 | | c1 c2 |						c1 := dict at: a1.						c2 := dict at: a2.						c1 = c2 ifTrue: 							[	c1 := a1.								c2 := a2.								[ c1 class = Array ] whileTrue: [ c1 := c1 first ].								[ c2 class = Array ] whileTrue: [ c2 := c2 first ]							].						c1 &lt; c2					].			min1 := sortedKeys at: 1.			min2 := sortedKeys at: 2.			dict at: ( Array with: min1 with: min2 ) put: ( dict removeKey: min1 ) + ( dict removeKey: min2 )		].	^ dict keys anyElement</body><body package="COMarshalling">bitsToBytes: bitArray 	"		self bitsToBytes: #[1 0 0 0 0 0 0 1].		self bitsToBytes: #[1 0 0 0 0 0 0 1 1].		self bitsToBytes: #[1 0 0 0 0 0 0].		self bitsToBytes: #[1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1].	"	| bytesStr bitStr byte bit |	bytesStr := ByteArray new writeStream.	bitStr := bitArray readStream.	byte := 0.	bit := 2r10000000.	[ bitStr atEnd ] whileFalse: 		[	bitStr next &gt; 0 				ifTrue: [ byte := byte bitOr: bit ].			bit := bit bitShift: -1.			bit = 0 				ifTrue: 				[	bytesStr nextPut: byte.					byte := 0.					bit := 2r10000000				]		].	bit = 2r10000000		ifFalse: [ bytesStr nextPut: byte ].	^ bytesStr contents</body><body package="COMarshalling">characterArrayFrom: array to: dict path: byteArray 	array first class = Array 		ifTrue: [ self characterArrayFrom: array first to: dict path: byteArray , #[ 0 ]]		ifFalse: [ dict at: array first put: byteArray , #[ 0 ]].	array last class = Array 		ifTrue: [ self characterArrayFrom: array last to: dict path: byteArray , #[ 1 ]]		ifFalse: [ dict at: array last put: byteArray , #[ 1 ]].</body><body package="COMarshalling">defaultArray	^ #( 10 1 1 1 1 1 1 1 1 10 10 1 10 10 1 1 1 1 1 1 1 1 1 1 1 1 10 1 1 1 1 1 383184256 668160 6572032 5888 4096 14976 487680 1344384 532352 531712 30720 168704 14638848 21243392 3650304 616960 6536384 5243392 12083328 5794944 9501568 6217280 4098688 3593792 3747776 4561472 4385280 45952 3456 8192 3456 1807488 21504 77844224 46388992 18568192 42403328 56864000 34241024 34890496 31971584 28623872 12252416 42481408 27470336 39800832 30858752 14963200 31970816 1131264 38253568 79074048 39953152 21187328 20712448 31579392 350720 1364224 16271616 2304 5248 2432 1 54 656 353348864 97962752 162258944 183828736 881659392 115905536 158123776 230592768 441847552 4982528 88918784 259011328 137678592 519651328 194923776 62343936 1301504 492267264 329502720 403544832 231781376 36506368 52312832 5693696 15659776 59553792 640 15104 640 1 1 1 1 1 1 112 1 1 1 1 1 1 1 1 1 1 1 1 1 12 112 1 1 10 1 1 1 1 1 1 1 1 1 194 2 1 1 1 1 2 24 1 2 1 6812 1 134 4 1 6 1 2 1 194 1 1 296 1 1 2 6810 1 1 1 1 1280 3072 512 100 1247232 1280 1 2048 100 5376 100 100 256 512 100 100 1 512 100 512 4864 100 1524992 22 768 256 100 256 3121152 100 1 4497152 44800 159232 3584 17920 32915968 2560 18 38656 55040 651776 4096 14848 1536 49920 2304 5632 32 13056 5632 59392 13824 256 15388928 1 7936 1792 9216 512 50597376 1280 1 512 )	"	| array result |	array := #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 2993627 5220 51344 46 32 117 3810 10503 4159 4154 240 1318 114366 165964 28518 4820 102131 81928 188802 90546 148462 97145 64042 56153 58559 71273 34260 359 27 64 27 14121 168 304079 181207 72532 165638 222125 133754 136291 124889 111812 47861 165943 107306 155472 120542 58450 124886 4419 149428 308883 156067 82763 80908 123357 1370 5329 63561 18 41 19 nil 27 328 1380269 382667 633824 718081 3443982 452756 617671 900753 1725967 19463 347339 1011763 537807 2029888 761421 243531 5084 1922919 1287120 1576347 905396 142603 204347 22241 61171 232632 5 118 5 nil nil nil nil nil nil 56 nil nil nil nil nil nil nil nil nil nil nil nil nil 6 56 nil nil 5 nil nil nil nil nil nil nil nil nil 97 1 nil nil nil nil 1 12 nil 1 nil 3406 nil 67 2 nil 3 nil 1 nil 97 nil nil 148 nil nil 1 3405 nil nil nil nil 5 12 2 nil 4872 5 nil 8 nil 21 nil nil 1 2 nil nil nil 2 nil 2 19 nil 5957 11 3 1 nil 1 12192 nil nil 35134 175 622 14 70 128578 10 9 151 215 2546 16 58 6 195 9 22 16 51 22 232 54 1 60113 nil 31 7 36 2 197646 5 nil 2 ).	result := Array new: 256.	array keysAndValuesDo: 		[: value : countOrNil | | char count |			char := Character value: value - 1.			( countOrNil notNil or: [ char basePart = char ]) ifFalse: 				[	count := array at: char basePart asInteger.					count notNil ifTrue: [ count := ( count + 1 ) // 256 ]				].			count := countOrNil notNil 					ifTrue: 					[	char basePart isAlphaNumeric 							ifTrue: 							[	char isDigit 									ifTrue: [ countOrNil * 64 ]									ifFalse: [ countOrNil * 256 ]							]							ifFalse: 							[( #( 9 13 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 64 91 92 93 123 124 125 126 196 214 220 223 228 246 252 ) 									includes: char asInteger ) 									ifTrue: [ countOrNil * 128 ]									ifFalse: [ countOrNil * 2 ]							]					]					ifFalse: 					[	char basePart isAlphaNumeric 							ifTrue: 							[	char isDigit 									ifTrue: [ 10 ]									ifFalse: [ 100 ]							]							ifFalse: 							[	char isSeparator 									ifTrue: [ 10 ]									ifFalse: [ 1 ]							]					].			result at: value put: count		].	^ result"</body><body package="COMarshalling">defaultDictionary	| dict |	dict := IdentityDictionary new.	self defaultArray keysAndValuesDo: [: value : count | dict at: value put: count ].	^ dict</body><body package="COMarshalling">initializeByteEncodingArrays	" byteEncoding := nil.	byteDecodingRoots := nil.	self initializeByteEncodingArrays "	| charArray shiftedBits encodingArrays decodingRoots |	charArray := self characterArray.	encodingArrays := Array new: charArray size.	decodingRoots := Array new: 8.	0 to: 7		do: 		[: bitShift | | decodingRoot |			decodingRoot := HuffmanDecodingNode new: charArray size.			decodingRoots at: bitShift + 1 put: decodingRoot		].	charArray keysAndValuesDo: 		[: int : bits | | encodingArray char numBits |			char := Character value: int - 1.			numBits := bits size.			encodingArray := HuffmanEncodingArray character: char numberOfBits: bits size.			shiftedBits := bits.			0 to: 7				do: 				[: shift | | shiftedBytes |					shiftedBytes := self bitsToBytes: shiftedBits.					encodingArray bytesShiftedBy: shift put: shiftedBytes.					encodingArrays at: int put: encodingArray.					" decoding "					self addDecodingNodesTo: ( decodingRoots at: shift + 1 ) bytes: shiftedBytes character: char numberOfBits: numBits shift: shift.					" shift 1 right "					shiftedBits := #[ 0 ] , shiftedBits				]		].	byteEncoding := encodingArrays.	byteDecodingRoots := decodingRoots.</body><body package="COMarshalling">nextPutBytes: aByteArray on: stream bits: numBits encodeStatus: aHuffmanEncodeStatus	| sz last byte bitPos |	byte := aHuffmanEncodeStatus byte.	bitPos := aHuffmanEncodeStatus bitPos.	byte isNil 		ifTrue: 		[	" Start genau an der Bytegrenze "			bitPos := 0.			byte := aByteArray at: 1		]		ifFalse: 		[	" wenn nicht am Anfang: Bytes mergen "			byte := byte bitOr: ( aByteArray at: 1 )		].	" komplett innerhalb der Bytegrenze? "	(bitPos := bitPos + numBits) &gt;= 8 		ifTrue: 		[				bitPos := bitPos \\ 8.			stream nextPut: byte.			sz := aByteArray size.			bitPos = 0 				ifTrue: 				[	" Ende genau an der Bytegrenze "					last := sz.					byte := nil				]				ifFalse: 				[	" wenn nicht am Ende: Bytes mergen "					last := sz - 1.					byte := aByteArray at: sz				].			" der Rest kann so rausgekloppt werden "			2 to: last do: [: j | stream nextPut: ( aByteArray at: j )].		].	aHuffmanEncodeStatus byte: byte.	aHuffmanEncodeStatus bitPos: bitPos</body></methods><methods><class-id>COAST.HuffmanStringCodec class</class-id> <category>accessing</category><body package="COMarshalling">arrayStack	"self arrayStackFrom: self defaultDictionary"	arrayStack isNil ifTrue: [ arrayStack := self arrayStackFrom: self defaultDictionary ].	^ arrayStack</body><body package="COMarshalling">byteDecodingRoots	byteDecodingRoots isNil ifTrue: [ self initializeByteEncodingArrays ].	^ byteDecodingRoots</body><body package="COMarshalling">byteEncodingArrays	byteEncoding isNil ifTrue: [ self initializeByteEncodingArrays ].	^ byteEncoding</body><body package="COMarshalling">characterArray	"| array |	array := Array new: 35 withAll: ''.	characterArray := Array new: 256.	self characterArrayFrom: self arrayStack to: characterArray path: #[ ].	characterArray keysAndValuesDo: 		[: i : byteArray | | string |			string := array at: byteArray size .			array at: byteArray size put: ( string copyWith: ( Character value: i - 1 ))		].	array."	characterArray isNil ifTrue: 		[	characterArray := Array new: 256.			self characterArrayFrom: self arrayStack to: characterArray path: #[ ]		].	^ characterArray</body></methods><methods><class-id>COAST.HuffmanStringCodec class</class-id> <category>api</category><body package="COMarshalling">decode: string from: stream 	| bitPos thisByte nextByte |	bitPos := 0.	thisByte := nil.	nextByte := nil.	1 to: string size		do: 		[: i | | currentDecodingNode node numBits seenBits byte |			numBits := nil.			seenBits := 0.			currentDecodingNode := self byteDecodingRoots at: bitPos + 1.			[	thisByte isNil 					ifTrue: [ thisByte := stream next ].				byte := seenBits = 0 						ifTrue: 						[	" alte, schon gelesene Bits herausfiltern "							thisByte bitAnd: ( 16rFF bitShift: bitPos negated )						]						ifFalse: [ thisByte ].				node := currentDecodingNode nodeAt: byte.				node isLeaf 					ifTrue: 					[	" Bitfolge fÃ¼r dieses Zeichen ist fertig "						numBits := node numberOfBits.						bitPos := bitPos + numBits - seenBits.						seenBits := numBits					]					ifFalse: 					[	seenBits := seenBits + 8.						bitPos := bitPos + 8					].				bitPos &gt;= 8 					ifTrue: 					[	bitPos := bitPos \\ 8.						" wir brauchen beim nÃ¤chsten mal ein weiteres Byte aus dem Stream "						thisByte := nextByte.						nextByte := nil					].				node isLeaf			] whileFalse: 				[	" noch nicht genÃ¼gend bits gelesen, weitermachen "					currentDecodingNode := node				].			" Bitfolge fÃ¼r dieses Zeichen ist fertig "			string at: i put: node character		].	^ string</body><body package="COMarshalling">encode: string on: stream 	| characterBytesArrays encodeStatus lastByte |	encodeStatus := HuffmanEncodeStatus new.	characterBytesArrays := self byteEncodingArrays.	string do: 		[: c | | huffmanEncodingArray |			huffmanEncodingArray := characterBytesArrays at: c asInteger + 1.			self 					nextPutBytes: ( huffmanEncodingArray bytesShiftedBy: encodeStatus bitPos )					on: stream					bits: huffmanEncodingArray numberOfBits					encodeStatus: encodeStatus		].	"complete the current byte"	(lastByte := encodeStatus byte) notNil 		ifTrue: [ stream nextPut: lastByte ].</body><body package="COMarshalling">sizeOf: string 	"string asArray collect: [: c | ( self characterArray at: c asInteger + 1 ) size ]."	| bitSize |	bitSize := string inject: 0 into: [: size : c | size + ( self characterArray at: c asInteger + 1 ) size ].	[ bitSize \\ 8 = 0 ] whileFalse: [ bitSize := bitSize + 1 ].	^ bitSize / 8</body></methods><methods><class-id>COAST.HuffmanEncodingArray</class-id> <category>accessing</category><body package="COMarshalling">bytesShiftedBy: shift	^ self at: shift + 1</body><body package="COMarshalling">bytesShiftedBy: shift put: bytes	self at: shift + 1 put: bytes</body><body package="COMarshalling">character	^ character</body><body package="COMarshalling">character: aCharacter 	character := aCharacter.</body><body package="COMarshalling">numberOfBits	^ numberOfBits</body><body package="COMarshalling">numberOfBits: aNumberOfBits 	numberOfBits := aNumberOfBits.</body></methods><methods><class-id>COAST.HuffmanEncodingArray class</class-id> <category>instance creation</category><body package="COMarshalling">character: aCharacter numberOfBits: aNumberOfBits 	^ (self new: 8)		character: aCharacter;		numberOfBits: aNumberOfBits;		yourself</body></methods><methods><class-id>COAST.CatCSTempBytesPool</class-id> <category>accessing</category><body package="COMarshalling">tempBytesDo: aBlock	" do not allocate ByteArrays all the time, instead use a pool of ByteArrays "	exclusiveLock critical: [		tempBytesCounter := tempBytesCounter + 1.		[			tempBytesCounter &gt; tempBytesPool size				ifTrue: [					CoastLog logDebug: [ 'Allocating new ByteArray for tempBytes pool' ].					tempBytesPool add: (ByteArray new: 1000).				].			aBlock value: (tempBytesPool at: tempBytesCounter).		] ensure: [			tempBytesCounter := tempBytesCounter - 1.		].	].</body></methods><methods><class-id>COAST.CatCSTempBytesPool</class-id> <category>initialize - release</category><body package="COMarshalling">initialize	exclusiveLock := RecursionLock new.	tempBytesPool := OrderedCollection new.	tempBytesCounter := 0.</body></methods><methods><class-id>COAST.CatCSTempBytesPool class</class-id> <category>instance creation</category><body package="COMarshalling">new	^super new initialize</body></methods><methods><class-id>COAST.HuffmanDecodingLeaf</class-id> <category>accessing</category><body package="COMarshalling">character	^ character</body><body package="COMarshalling">character: aCharacter 	character := aCharacter.</body><body package="COMarshalling">numberOfBits	^ numberOfBits</body><body package="COMarshalling">numberOfBits: aNumberOfBits 	numberOfBits := aNumberOfBits.</body></methods><methods><class-id>COAST.HuffmanDecodingLeaf</class-id> <category>testing</category><body package="COMarshalling">isLeaf	^ true</body></methods><methods><class-id>COAST.HuffmanDecodingLeaf</class-id> <category>printing</category><body package="COMarshalling">printOn: aStream	aStream nextPut: character.	aStream nextPutAll: ' ['.	numberOfBits printOn: aStream.	aStream nextPutAll: ']'.</body></methods><methods><class-id>COAST.HuffmanDecodingLeaf class</class-id> <category>instance creation</category><body package="COMarshalling">character: aCharacter numberOfBits: aNumberOfBits 	^ self new		character: aCharacter;		numberOfBits: aNumberOfBits;		yourself</body></methods><methods><class-id>COAST.HuffmanEncodeStatus</class-id> <category>accessing</category><body package="COMarshalling">bitPos	^ bitPos</body><body package="COMarshalling">bitPos: aBitPos 	bitPos := aBitPos.</body><body package="COMarshalling">byte	^ byte</body><body package="COMarshalling">byte: aByte 	byte := aByte.</body></methods><methods><class-id>COAST.HuffmanEncodeStatus</class-id> <category>initialize-release</category><body package="COMarshalling">initialize	bitPos := 0.</body></methods><methods><class-id>COAST.HuffmanEncodeStatus class</class-id> <category>instance creation</category><body package="COMarshalling">new	^ ( super new ) initialize;		yourself</body></methods><methods><class-id>COAST.CatRMFileDownloadTarget</class-id> <category>accessing</category><body package="COMessages">bytesOnly	^ bytesOnly</body><body package="COMessages">bytesOnly: aBoolean 	bytesOnly := aBoolean.</body><body package="COMessages">targetStream	^ targetStream</body><body package="COMessages">targetStream: aWriteStream 	targetStream := aWriteStream.</body></methods><methods><class-id>COAST.CatRMFileDownloadTarget</class-id> <category>initialize-release</category><body package="COMessages">deregister	" register the download target and return the registered key"	self class deregisterDownloadTargetForKey: key</body><body package="COMessages">register	" register the download target and return the registered key"	key := self class registerDownloadTarget: self.	^ key</body></methods><methods><class-id>COAST.CatRMFileDownloadTarget class</class-id> <category>accessing</category><body package="COMessages">deregisterDownloadTargetForKey: key 	" deregister and return the download target "	| internalKey |	^ ( self isTargetStreamName: key ) 		ifTrue: 		[	internalKey := key copyFrom: self targetStreamMarker size + 1 to: key size.			self downloadTargets removeKey: internalKey ifAbsent: [ nil ]		]		ifFalse: [ nil ]</body><body package="COMessages">downloadTargets	DownloadTargets isNil 		ifTrue: [ DownloadTargets := Dictionary new ].	^ DownloadTargets</body><body package="COMessages">isTargetStreamName: aString 	^ aString notNil and: [ aString startsWith: self targetStreamMarker ]</body><body package="COMessages">registerDownloadTarget: downloadTarget	| internalKey | 	[	TargetKeyCounter := ( TargetKeyCounter ifNil: [ 0 ]) + 1.		internalKey := TargetKeyCounter printString.		self downloadTargets includesKey: internalKey	] whileTrue.	"repeat generating keys until key is unique"	self downloadTargets at: internalKey put: downloadTarget.	^ self targetStreamMarker, internalKey</body></methods><methods><class-id>COAST.CatRMFileDownloadTarget class</class-id> <category>private</category><body package="COMessages">targetStreamMarker	^ '&gt;&gt;'</body></methods><methods><class-id>COAST.CatRMFileDownloadTarget class</class-id> <category>instance creation</category><body package="COMessages">targetStream: aWriteStream bytesOnly: aBoolean 	^ self new 		targetStream: aWriteStream;		bytesOnly: aBoolean;		yourself</body></methods><methods><class-id>COAST.CatCSClusterInfo</class-id> <category>accessing</category><body package="COClusterManagement">accessCount	^accessCount</body><body package="COClusterManagement">accessTime	^accessTime</body><body package="COClusterManagement">loadFromCacheCount	^loadFromCacheCount</body><body package="COClusterManagement">loadFromMediatorCount	^loadFromMediatorCount</body><body package="COClusterManagement">loadTime	^ loadTime</body></methods><methods><class-id>COAST.CatCSClusterInfo</class-id> <category>initialize</category><body package="COClusterManagement">initialize	loadFromMediatorCount := 0.	loadFromCacheCount := 0.	accessCount := 0.	accessTime := 0.</body></methods><methods><class-id>COAST.CatCSClusterInfo</class-id> <category>interface</category><body package="COClusterManagement">flushHistory</body><body package="COClusterManagement">logAccess	accessTime := Time secondClock.	accessCount := accessCount + 1.	loadTime isNil ifTrue: [ loadTime := accessTime ]</body><body package="COClusterManagement">logCacheLoad	loadFromCacheCount := self loadFromCacheCount + 1.	self logAccess.</body><body package="COClusterManagement">logLoad	loadFromMediatorCount := self loadFromMediatorCount + 1.	self logAccess.</body><body package="COClusterManagement">logUnload	loadTime := nil</body></methods><methods><class-id>COAST.CatCSClusterInfo</class-id> <category>display</category><body package="COClusterManagement">printOn: stream 	stream nextPutAll: 'ClusterInfo( loaded: '.	loadTime notNil 		ifTrue: 		[	stream nextPutAll: 'at:'.			loadTime printOn: stream		]		ifFalse: [ stream nextPutAll: 'not' ].	stream nextPutAll: ' last access:'.	accessTime printOn: stream.	stream nextPutAll: '  #accesses: '.	accessCount printOn: stream.	stream nextPutAll: ' #loads:'.	loadFromMediatorCount printOn: stream.	stream nextPutAll: ' #cacheloads:'.	loadFromCacheCount printOn: stream.	stream nextPutAll: ' )'</body></methods><methods><class-id>COAST.CatCSClusterInfo class</class-id> <category>instance-creation</category><body package="COClusterManagement">new	| newInst |	newInst := super new.	newInst initialize.	^newInst</body></methods><methods><class-id>COAST.CatCSFrameClassIndex</class-id> <category>copy</category><body package="COClusterManagement">copyValuesFromTable: aFrameClassTable	(aFrameClassTable includes: nil) 		ifTrue: [ self error: 'New frame class table contains nil' ].	frameClassTable size &gt; aFrameClassTable size		 ifTrue: [ self error: 'New frame class is smaller than existing index' ].	frameClassTable := Array new: aFrameClassTable size.	frameClassDict := Dictionary new: frameClassDict size.	aFrameClassTable keysAndValuesDo: [ : i : fsi | 		| fsiCopy extraKey |		fsiCopy := fsi copy.		frameClassTable at: i put: fsiCopy.		(extraKey := fsiCopy frameClass) notNil			ifTrue: [ 	frameClassDict at: extraKey put: fsiCopy ].		frameClassDict at: fsiCopy frameClassSymbol put: fsiCopy	].</body><body package="COClusterManagement">newFrameClassIndex	| newFrameClassIndex |	newFrameClassIndex := self class classNameManager: self classNameManager.	newFrameClassIndex copyValuesFromTable: frameClassTable.	^newFrameClassIndex</body><body package="COClusterManagement">updateWith: aFrameClassIndex	hasUpdates		ifTrue: 		[	aFrameClassIndex copyValuesFromTable: frameClassTable.			hasUpdates := false		]</body></methods><methods><class-id>COAST.CatCSFrameClassIndex</class-id> <category>accessing</category><body package="COClusterManagement">classNameManager	^ classNameManager</body><body package="COClusterManagement">clusterManager: aClusterManager 	self classNameManager: aClusterManager classNameManager.</body><body package="COClusterManagement">frameClassAt: dictKey put: fsi	( frameClassDict includesKey: dictKey ) ifTrue:[ CoastError raiseSignal: 'duplicate entry in index.ini for: ' , fsi frameClassName ].	frameClassDict at: dictKey put: fsi.</body><body package="COClusterManagement">frameSlotIndexClass	^ CatCSFrameSlotIndex</body><body package="COClusterManagement">frameSlotIndexForIndex: anInteger 	anInteger &gt; frameClassTable size ifTrue: [ CoastFrameClassIndexError raiseSignal: 'unkown frame class index: ' , anInteger printString ].	^ frameClassTable at: anInteger</body><body package="COClusterManagement">frameSlotIndexForIndex: newIndex put: newFsi 	| frameClass |	newFsi key: newIndex.	frameClassDict at: newFsi frameClassSymbol put: newFsi.	( frameClass := newFsi frameClass ) notNil ifTrue: [ frameClassDict at: frameClass put: newFsi ].	frameClassTable := Array new: ( newIndex max: frameClassTable size ).	frameClassDict do: [: fsi | frameClassTable at: fsi key put: fsi ].	^ newFsi</body><body package="COClusterManagement">frameSlotIndexForSymbol: aSymbolOrClass	^ frameClassDict at: aSymbolOrClass ifAbsent: [ nil ]</body><body package="COClusterManagement">missingSlot: slotName for: frameSlotIndex 	^ 0</body><body package="COClusterManagement">newFrameSlotIndexFor: frameClassSymbol classNameManager: aClassNameManager 	^ self frameSlotIndexClass frameClassSymbol: frameClassSymbol classNameManager: aClassNameManager frameClassIndex: self</body><body package="COClusterManagement">withNameSpaceFrom: aString 	^ namespaceDict at: aString		ifAbsent: 		[ | wildcarded |			wildcarded := '*.' , aString.			frameClassTable do: 				[: fsi | ( fsi notNil and: [ wildcarded match: fsi frameClassSymbol ]) ifTrue: 						[	CoastLog logDebugDo: [ 'Patched Namespace for class ' , fsi frameClassSymbol ].							^ namespaceDict at: aString put: fsi frameClassSymbol						]				].			CoastLog log: 'old style classname: ' , aString.			^ namespaceDict at: aString put: aString asSymbol		]</body></methods><methods><class-id>COAST.CatCSFrameClassIndex</class-id> <category>testing</category><body package="COClusterManagement">hasUpdates	^ hasUpdates</body></methods><methods><class-id>COAST.CatCSFrameClassIndex</class-id> <category>initialize</category><body package="COClusterManagement">initialize	frameClassDict := IdentityDictionary new.	namespaceDict := Dictionary new.	frameClassTable := Array new.	hasUpdates := false.</body></methods><methods><class-id>COAST.CatCSFrameClassIndex</class-id> <category>ini</category><body package="COClusterManagement">flushUpdates	hasUpdates := false.</body><body package="COClusterManagement">loadIndex: indexIniAccess for: aClusterManager 	| maxKey |	frameClassDict := IdentityDictionary new.	maxKey := 0.	self classNameManager: aClusterManager classNameManager.	indexIniAccess categorySet do: 		[: frameClassName | | fsi frameClassSymbol frameClass |			frameClassSymbol := frameClassName asSymbol.			fsi := frameClassDict at: frameClassSymbol ifAbsentPut: [ self newFrameSlotIndexFor: frameClassSymbol classNameManager: classNameManager ].			fsi readFromIni: indexIniAccess.			maxKey := maxKey max: fsi key.			( frameClass := fsi frameClass ) notNil ifTrue: 				[	frameClass frameClassSymbol = frameClassSymbol 						ifTrue: [ self frameClassAt: frameClass put: fsi ]						ifFalse: [ CoastError raiseSignal: 'Invalid entry in FrameClassIndex: ' , frameClass displayString , ' not matching coast class name ' , frameClassName displayString ]				].			fsi hasNameSpace ifFalse: [ CoastError raiseSignal: 'index.ini has bad entry: ' , frameClassName ]		].	frameClassTable := Array new: maxKey.	frameClassDict do: [: fsi | frameClassTable at: fsi key put: fsi ].</body><body package="COClusterManagement">saveIndex: indexIniAccess 	frameClassDict isEmpty ifTrue: [ ^ nil ].	indexIniAccess initialize.	frameClassTable do: [: fsi | fsi notNil ifTrue: [ fsi writeToIni: indexIniAccess ]].	[ indexIniAccess writeFrameIndexFile ] on: Error		do: [: ex | CoastError raiseSignal: 'cannot write index: ' , ex description ]</body><body package="COClusterManagement">unflushUpdates	hasUpdates := true.</body><body package="COClusterManagement">updateIndexIni: indexIniAccess 	frameClassDict isEmpty ifTrue: [ ^ nil ].	indexIniAccess initialize.	frameClassTable do: [: fsi | fsi notNil ifTrue: [ fsi writeToIni: indexIniAccess ]].</body></methods><methods><class-id>COAST.CatCSFrameClassIndex</class-id> <category>private</category><body package="COClusterManagement">classNameManager: aClassNameManager	aClassNameManager isNil ifTrue: [ self error: 'a class name manager is required for frame class indexes' ].	classNameManager := aClassNameManager</body><body package="COClusterManagement">notifyUpdate	"not for remote clients"	self error: 'should not update FrameClassIndex'.</body><body package="COClusterManagement">refreshFrameIndexAt: idx	"this is for remote clients only"	self error: 'should not refresh FrameClassIndex'.</body></methods><methods><class-id>COAST.CatCSFrameClassIndex class</class-id> <category>instance creation</category><body package="COClusterManagement">classNameManager: aNameSpaceManager	^ self new		classNameManager: aNameSpaceManager;		yourself</body><body package="COClusterManagement">clusterManager: clusterManager 	^ ( self new )		clusterManager: clusterManager;		yourself</body><body package="COClusterManagement">new	^( super new ) 		initialize;		yourself</body></methods><methods><class-id>COAST.StreamableCluster</class-id> <category>accessing</category><body package="COClusterManagement">approxByteSize	self subclassResponsibility</body><body package="COClusterManagement">clusterController: clusterController marshaller: marshaller	self subclassResponsibility</body><body package="COClusterManagement">clusterID	self subclassResponsibility</body></methods><methods><class-id>COAST.StreamableCluster</class-id> <category>streaming</category><body package="COClusterManagement">saveClusterOn: writeStream	self subclassResponsibility</body></methods><methods><class-id>COAST.StreamableCluster class</class-id> <category>instance creation</category><body package="COClusterManagement">clusterController: clusterController marshaller: marshaller 	^ self new clusterController: clusterController marshaller: marshaller;		yourself</body></methods><methods><class-id>COAST.AbstractStorageInterface</class-id> <category>accessing</category><body package="COClusterManagement">clusterManager	^ clusterManager</body><body package="COClusterManagement">clusterManager: aClusterManager 	clusterManager := aClusterManager.</body></methods><methods><class-id>COAST.AbstractStorageInterface</class-id> <category>binary storage</category><body package="COClusterManagement">deleteBinaryStore	"to be extended by subclasses"	self releaseBinaryStoreInterfaces.</body><body package="COClusterManagement">moveBinaryStoreTo: backupDirectory	"to be extended by subclasses"	self releaseBinaryStoreInterfaces.</body><body package="COClusterManagement">releaseBinaryStoreInterfaces	binaryStoreInterfaces notNil ifTrue: 		[	binaryStoreInterfaces do: [: interface | interface release ].			ObjectMemory garbageCollect. "To finalize externals"			binaryStoreInterfaces := nil		].</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>saving</category><body package="COClusterManagement">autoSaveInterval	^clusterManager autoSaveInterval</body><body package="COClusterManagement">autoSaveTimeInterval	^clusterManager autoSaveTimeInterval</body><body package="COClusterManagement">ensureUpdatedFrameSlotIndexWith: aMarshaller	"ensure frame-slot-index has no missing entries"	cluster valueHolder do: [: frame | frame ensureUpdatedFrameSlotIndexWith: aMarshaller ].</body><body package="COClusterManagement">lastSaveTime	^lastSaveTime ifNil: [ 0 ]</body><body package="COClusterManagement">processAutoSave	(changeCount &gt; self autoSaveInterval)		ifTrue: [ self clusterManager setAutosaveTime: Time secondClock ]		ifFalse: [ self clusterManager setAutosaveTime: (self lastSaveTime + self autoSaveTimeInterval) ]</body><body package="COClusterManagement">saveClusterOn: aStream marshaller: marshaller 	marshaller marshall: self cluster to: aStream.	self setLastSaveTime.	" don't forget to send 'modified: false' when the cluster save	has really finished and everything went well "</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>accessing</category><body package="COClusterManagement">approxByteSize	^ cluster notNil		ifTrue: [ cluster approxByteSize ]		ifFalse: [ 0 ]</body><body package="COClusterManagement">basicCluster	" do not resolve, do nothing except returning the cluster "	^ cluster</body><body package="COClusterManagement">basicCluster: aCatCSCluster 	cluster := aCatCSCluster.	(clusterID notNil and: [ aCatCSCluster notNil and: [ clusterID ~= aCatCSCluster id ]])		ifTrue: [			self error: 'ID of cluster controller (', clusterID printString, ') does not match ID of loaded cluster (', aCatCSCluster id printString, ')'.		]</body><body package="COClusterManagement">byteArrayFilename: aFilenameOrString	cluster notNil ifTrue: [ cluster closeClusterStream ].	byteArrayFilename := aFilenameOrString asFilename.</body><body package="COClusterManagement">clientID	^ nil</body><body package="COClusterManagement">cluster	^self clusterStub</body><body package="COClusterManagement">cluster: aCatCSCluster 	"Be sure only top call cluster: of ClusterController. Do not call 	clusterController: of Cluster directly - these are the problems people have 	without inverting ... :-("	self basicCluster: aCatCSCluster.	aCatCSCluster clusterController: self</body><body package="COClusterManagement">clusterID	^ clusterID ifNil: [ self clusterStub clusterID ]</body><body package="COClusterManagement">clusterID: anInteger	clusterID := anInteger</body><body package="COClusterManagement">clusterManager	^clusterManager</body><body package="COClusterManagement">clusterManager: aCatCSClusterManager 	clusterManager := aCatCSClusterManager.</body><body package="COClusterManagement">clusterStub	^self basicCluster</body><body package="COClusterManagement">hasOldStyleFrames	^oldStyleFrameDetected</body><body package="COClusterManagement">incChangeCount	changeCount := changeCount + 1</body><body package="COClusterManagement">modified	^modified</body><body package="COClusterManagement">modified: aBoolean 	aBoolean 		ifFalse: [ oldStyleFrameDetected := false ].	( aBoolean and: [ modified not ]) 		ifTrue: [ self setLastSaveTime ].	modified := aBoolean.	modified 		ifTrue: 		[	self incChangeCount.			self processAutoSave		]		ifFalse: [ changeCount := 0 ].</body><body package="COClusterManagement">notifyFastRead: aFrame in: aCluster</body><body package="COClusterManagement">oldStyleFrameDetected	oldStyleFrameDetected ifTrue: [ ^ self ].	CoastLog logDebugDo: [ 		self basicCluster notNil			ifTrue: [ 'old style frames detected in ' , self clusterID printString ]			ifFalse: [ 'old style frames detected in' ]	 ].	oldStyleFrameDetected := true</body><body package="COTransactions">rollForwardDebugString	| stream |	stream := String new writeStream.	stream nextPutAll: ' Roll forward cluster '.	self clusterID printOn: stream.	^ stream contents</body><body package="COClusterManagement">statusError: aString	CoastLog logError: 'Error in cluster controller: ', aString.</body><body package="COClusterManagement">statusLog: aString	CoastLog log: 'CC: ', aString.</body><body package="COClusterManagement">volumeManager	^clusterManager ifNotNil: [ : cm | cm volumeManager ]</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>cluster creation</category><body package="COClusterManagement">clusterLoaded: aCatCSCluster	self cluster: aCatCSCluster.</body><body package="COClusterManagement">createCluster: clusterIDInteger 	"create the Cluster specified by clusterIDInteger"	self cluster: ( CatCSCluster named: clusterIDInteger ).	"self modified: true"</body><body package="COClusterManagement">loadCluster: clusterIDInteger 	"load the Cluster - do not create it as a new cluster, if it doesn't exist yet"	| marshaller newCluster |	self clusterManager exclusiveUseDo: 		[	marshaller := self clusterManager loadMarshaller.			marshaller clusterController: self.			marshaller currentClusterID: clusterIDInteger.			newCluster := marshaller loadCluster: clusterIDInteger fromStore: self clusterManager storageInterface.			newCluster notNil 				ifTrue: 				[	newCluster id == clusterIDInteger 						ifFalse: [ self error: 'Cluster ' , clusterIDInteger printString , ' is corrupt (wrong cluster ID)' ].					self clusterLoaded: newCluster				]				ifFalse: 				[	"self clusterManager notifyImplicitCreatedClusterID: clusterIDInteger.					self createCluster: clusterIDInteger"					ClusterNotFoundError raiseSignal: 'try to load non-existent cluster'				] "no implicit creation anymore!"		]</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>testing</category><body package="COClusterManagement">hasLog	^false</body><body package="COClusterManagement">lazyLoad	^false</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>initialize</category><body package="COClusterManagement">initialize	self modified: false.	self setLastSaveTime.	oldStyleFrameDetected := false.</body><body package="COClusterManagement">setLastSaveTime	lastSaveTime := Time secondClock.</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>release</category><body package="COClusterManagement">releaseClusterAndNotifyMediator: doNotify	self basicCluster notNil ifTrue: [ self basicCluster releaseCluster ]</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>private</category><body package="COClusterManagement">clientOnlyOperationError: aString	CoastError raiseSignal: 'Only supported by client cluster controllers: ', aString</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>local transactions</category><body package="COClusterManagement">nextTransactionID	self clientOnlyOperationError: 'Next transaction ID'</body><body package="COClusterManagement">tryAndTell: aTransaction 	self clientOnlyOperationError: 'Try and tell'</body></methods><methods><class-id>COAST.CatCSClusterController</class-id> <category>frame creation</category><body package="COTransactions">createFrame: aCatRMFrameCreation 	| frameClass newFrame |	frameClass := aCatRMFrameCreation frameClassFor: self clusterManager classNameManager.	newFrame := frameClass notNil 			ifTrue: [ frameClass basicNew ]			ifFalse: [ CatFSUniversalFrame newWithFrameClassName: aCatRMFrameCreation frameClassName ].	newFrame		id: aCatRMFrameCreation frameID;		cellContainer: self cluster;		valueHolder: CatCSSlotDictionary new.	self cluster directTableAccessAt: newFrame id put: newFrame</body></methods><methods><class-id>COAST.CatCSClusterController class</class-id> <category>instance creation</category><body package="COClusterManagement">new	| newInst |	newInst := super new initialize.	^newInst.</body></methods><methods><class-id>COAST.UnloadableClustersCollection</class-id> <category>accessing</category><body package="COClusterManagement">add: clusterID	self ensureLastElement: clusterID</body><body package="COClusterManagement">addAll: clusterIDSet	clusterIDSet do: [ : clusterID | self ensureLastElement: clusterID ]</body><body package="COClusterManagement">asArray	orderDict size &lt; orderedClusters size ifTrue: [ self compress ].	^orderedClusters asArray</body><body package="COClusterManagement">do: block 	orderedClusters do: [: each | each notNil ifTrue: [ block value: each ]]</body><body package="COClusterManagement">ensureLastElement: clusterID	| oldIndex |	oldIndex := orderDict at: clusterID ifAbsent: nil.	oldIndex isNil ifTrue: [ ^self addNonExisting: clusterID ].	oldIndex = orderedClusters size ifTrue: [ ^self ]. "already last"	"move it"	orderedClusters at: oldIndex put: nil.	orderedClusters addLast: clusterID.	orderDict at: clusterID put: orderedClusters size.	self compressIfNecessary.</body><body package="COClusterManagement">first	^ orderedClusters detect: [: clusterOrNil | clusterOrNil notNil ]</body><body package="COClusterManagement">includes: clusterID	^orderDict includesKey: clusterID</body><body package="COClusterManagement">last	orderedClusters reverseDo: [: clusterOrNil | clusterOrNil notNil ifTrue: [ ^ clusterOrNil ]].	Collection notFoundSignal raise</body><body package="COClusterManagement">remove: clusterID ifAbsent: aBlock 	| oldValue |	oldValue := orderDict removeKey: clusterID ifAbsent: nil.	oldValue isNil ifTrue: [ ^ aBlock value ].	orderedClusters at: oldValue put: nil.	self compressIfNecessary.</body><body package="COClusterManagement">removeAll: clusterIDSet ifAbsent: aBlock	clusterIDSet do: [ : clusterID | self remove: clusterID ifAbsent: aBlock ]</body><body package="COClusterManagement">select: aBlock 	^ orderedClusters select: [: clusterOrNil | clusterOrNil notNil and: [ aBlock value: clusterOrNil ]]</body><body package="COClusterManagement">size	^orderDict size</body><body package="COClusterManagement">with: aSequenceableCollection do: block 	| otherCollection |	self size ~= aSequenceableCollection size ifTrue: [ ^ aSequenceableCollection noMatchError ].	otherCollection := ReadStream on: aSequenceableCollection.	orderedClusters do: [: each | each notNil ifTrue: [ block value: each value: otherCollection next ]]</body></methods><methods><class-id>COAST.UnloadableClustersCollection</class-id> <category>testing</category><body package="COClusterManagement">isEmpty	^orderDict isEmpty</body></methods><methods><class-id>COAST.UnloadableClustersCollection</class-id> <category>initialize-release</category><body package="COClusterManagement">initialize	"Initialize a newly created instance. This method must answer the receiver."	orderDict := CatCOIntegerKeyDictionary new.	orderedClusters := OrderedCollection new.	^self</body></methods><methods><class-id>COAST.UnloadableClustersCollection</class-id> <category>private</category><body package="COClusterManagement">addNonExisting: clusterID	orderDict at: clusterID put: orderedClusters size + 1.	orderedClusters addLast: clusterID.</body><body package="COClusterManagement">compress	| newOrderedClusters |	newOrderedClusters := OrderedCollection new: orderDict size.	orderedClusters do: 		[: clusterIDOrNil |			clusterIDOrNil notNil ifTrue: 				[	newOrderedClusters addLast: clusterIDOrNil.					orderDict at: clusterIDOrNil put: newOrderedClusters size				]		].	orderedClusters := newOrderedClusters</body><body package="COClusterManagement">compressIfNecessary	orderedClusters size - orderDict size &gt; 2048 ifTrue: [ self compress ].</body></methods><methods><class-id>COAST.UnloadableClustersCollection class</class-id> <category>instance creation</category><body package="COClusterManagement">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>accessing</category><body package="COClusterManagement">autoSaveTimeInterval	"max time between saves in seconds"	autoSaveTimeInterval isNil		ifTrue: [ autoSaveTimeInterval := 60 ].	^ autoSaveTimeInterval</body><body package="COClusterManagement">autoSaveTimeInterval: anInteger 	"max time between saves in seconds"	self basicAutoSaveTimeInterval: ( anInteger notNil 				ifTrue: [ anInteger min: 300	" hardcode: &lt;= 5 min " ]				ifFalse: [ nil ]).</body><body package="COClusterManagement">availableVolumes	self subclassResponsibility</body><body package="COClusterManagement">checkVolumes	self volumeInterface checkVolumes</body><body package="COClusterManagement">clientID	^ nil</body><body package="COClusterManagement">clusterManagerClass	^self subclassResponsibility</body><body package="COClusterManagement">clusterManagerForVolume: aVolume 	^clusterManagers at: aVolume		ifAbsent: [self newClusterManagerForVolume: aVolume]</body><body package="COClusterManagement">clusterManagerForVolume: aVolume ifAbsent: absentBlock 	^ clusterManagers at: aVolume ifAbsent: absentBlock</body><body package="COClusterManagement">clusterManagers	^clusterManagers values</body><body package="COClusterManagement">createClusterInVolume: volume 	^(self clusterManagerForVolume: volume) createCluster</body><body package="COClusterManagement">ensureVolumeAccessorOfClass: aClass	volumeInterface isNil		ifTrue: [ volumeInterface := LocalVolumeStorageInterface onAccessorClass: aClass ]		ifFalse: [ (volumeInterface volumeAccessor isKindOf: aClass) ifFalse: [ self error: 'wrong volume accessor' ] ].	^ volumeInterface</body><body package="COClusterManagement">exclusiveLockOwner	^ exclusiveLock owner</body><body package="COClusterManagement">getRootClusterInVolume: volume 	^(self clusterManagerForVolume: volume) rootClusterNeeded</body><body package="COClusterManagement">maxModifiedClusters	maxModifiedClusters isNil		ifTrue: [ maxModifiedClusters := 30 ].	^ maxModifiedClusters max: 1		" &lt;1 doesn't make sense "</body><body package="COClusterManagement">maxModifiedClusters: anInteger	maxModifiedClusters := anInteger</body><body package="COClusterManagement">newClusterManagerForVolume: aVolume	" create and register a new cluster manager "	self subclassResponsibility</body><body package="COClusterManagement">recoverVolume: oldVolume version: version to: recoverVolume 	^ self volumeInterface recoverVolume: oldVolume version: version to: recoverVolume</body><body package="COClusterManagement">recoverableVolumes	^self volumeInterface recoverableVolumes</body><body package="COClusterManagement">removeClusterManager: name	clusterManagers removeKey: name ifAbsent: []</body><body package="COClusterManagement">segmentSplitSize	^segmentSplitSize</body><body package="COClusterManagement">segmentSplitSize: anInteger	segmentSplitSize := (anInteger min: 8192) max: 256</body><body package="COClusterManagement">sizeOfBlobOrCluster: clusterID in: volume 	^ self volumeInterface sizeOfBlobOrCluster: clusterID in: volume</body><body package="COClusterManagement">volumeAccessor	self haltOrContinue: 'this is deprecated! Do you mean: volumeInterface?'.	^self volumeInterface volumeAccessor</body><body package="COClusterManagement">volumeInterface	volumeInterface isNil		ifTrue: [ volumeInterface := LocalVolumeStorageInterface onAccessorClass: self class defaultStorageClass ].	^ volumeInterface</body><body package="COClusterManagement">volumes	^clusterManagers keys</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>debug info</category><body package="COClusterManagement">coastIsBlockedByDebugger	" hook fÃ¼r developer-images "	^ false</body><body package="COClusterManagement">debugToStream: aStream	clusterManagers do: [ :cm |		 	aStream tab; nextPutAll: 'cluster manager on: '; nextPutAll: cm printString; cr.			cm clusterController do: [ :cc | 			aStream tab; tab; nextPutAll: 'cluster: '; nextPutAll: cc clusterStub id printString; cr. ]]</body><body package="COClusterManagement">logError: exception message: message	CoastLog logException: exception message: message</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>accessing - load state</category><body package="COClusterManagement">currentLoadedClusterID	^currentLoadedClusterID value</body><body package="COClusterManagement">currentLoadedClusterID: clusterIDInteger	^currentLoadedClusterID value: clusterIDInteger</body><body package="COClusterManagement">currentLoadedClusterIDAddDependent: dependent	currentLoadedClusterID addDependent: dependent</body><body package="COClusterManagement">maxClusterCount	^self clusterManagers inject: 0 into: [: sum : cm | sum + cm maxClusterCount ]</body><body package="COClusterManagement">totalClusterCount	^self clusterManagers inject: 0 into: [: sum : cm | sum + cm numberOfClustersLoaded ]</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>saving</category><body package="COClusterManagement">backupVolume: volumeName 	^ self exclusiveUseDo: [		(self clusterManagerForVolume: volumeName) backupVolume ]</body><body package="COClusterManagement">blockUntilBackupIsDone: aVolume 	" wait until the current asynchronous backup of the volume has finished.	returns a CoastStatusResponse "	^ self exclusiveUseDo: [		(self clusterManagerForVolume: aVolume) blockUntilBackupIsDone ]</body><body package="COClusterManagement">checkAutoSaveAndRelease	^ clusterManagers copy do: 		[: cm |			[ cm checkAutoSaveAndRelease ] 				on: Error				do: 				[: ex |					CoastLog logFatalException: ex message: 'Error in checkAutoSaveAndRelease'.					cm emergencyShutDown				]		]</body><body package="COClusterManagement">copyVolume: aVolume to: newVolume 	" copies the volume. raises an error or returns a CoastStatusResponse "	^ self exclusiveUseDo: [		(self clusterManagerForVolume: aVolume) copyVolumeTo: newVolume ]</body><body package="COClusterManagement">deleteBackup: backupVolume version: version	^self exclusiveUseDo: [		self tryDeleteBackup: backupVolume version: version ].</body><body package="COClusterManagement">deleteVolume: aVolume 	^ self exclusiveUseDo: [		(self clusterManagerForVolume: aVolume) deleteVolume ]</body><body package="COClusterManagement">deleteVolumeNoBackup: aVolume 	self exclusiveUseDo: [		(self clusterManagerForVolume: aVolume) deleteVolumeNoBackup ]</body><body package="COClusterManagement">recoverToVolume: targetVolume fromVolume: backupVolume version: version	" try to restore a backup of the volume. returns a CoastStatusResponse "	^self exclusiveUseDo: [		self tryRecoverToVolume: targetVolume fromVolume: backupVolume version: version ].</body><body package="COClusterManagement">recoverVolume: targetVolume 	targetVolume isValidVolumeString 		ifFalse: [ CoastError raiseSignal: 'bad target volume!' ].	( volumeInterface volumeExists: targetVolume ) 		ifFalse: [ CoastError raiseSignal: 'can not recover non existinging volume!' ].	volumeInterface recoverVolume: targetVolume.</body><body package="COClusterManagement">tryDeleteBackup: backupVolume version: version 	(( self volumeInterface recoverableVolumes at: backupVolume ifAbsent: [ #( )]) includes: version ) 		ifFalse: [ CoastError raiseSignal: 'can not delete absent version!' ].	"absent version!"	self volumeInterface deleteBackup: backupVolume version: version.</body><body package="COClusterManagement">tryRecoverToVolume: targetVolume fromVolume: backupVolume version: version 	(( self volumeInterface recoverableVolumes at: backupVolume ifAbsent: [ #( )]) includes: version ) 		ifFalse: [ CoastError raiseSignal: 'can not recover from absent version!' ].	"absent version!"	targetVolume isValidVolumeString 		ifFalse: [ CoastError raiseSignal: 'bad target volume!' ].	( self volumeInterface volumeExists: targetVolume ) 		ifTrue: [ CoastError raiseSignal: 'can not overwrite existing volume!' ].	"can not overwrite!"	self volumeInterface recoverVolume: backupVolume version: version to: targetVolume.	^ CoastStatusResponse okCode: #volumeRecovered message: 'Restored backup of volume ', backupVolume, ' as ', targetVolume</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>packet stations</category><body package="COClusterManagement">disconnectAllPacketStations	| activePacketStations |	activePacketStations := packetStations values.	activePacketStations do:	[ :ps |		ps closeConnection.	].	packetStations := Dictionary new.</body><body package="COClusterManagement">packetStationForHost: hostname	^packetStations at: hostname ifAbsent: [ nil ]</body><body package="COClusterManagement">packetStations	^ packetStations values</body><body package="COClusterManagement">stationIrreversibleLostConnection: aStation	self subclassResponsibility</body><body package="COClusterManagement">waitUntilSendQueueIsEmpty	packetStations do: [ : packetStation | packetStation waitUntilSendQueueIsEmpty ]</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>exclusive use</category><body package="COClusterManagement">exclusiveAndInterruptProtectDo: block  	^ self exclusiveUseDo: block</body><body package="COClusterManagement">exclusiveUseDo: aBlock	"evaluate a block ensuring exclusive use of all clusters"	^exclusiveLock critical: aBlock</body><body package="COClusterManagement">interruptProtectDo: aBlock	^ aBlock value</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>status</category><body package="COClusterManagement">statusError: aString	CoastLog logError: 'Error in volume Manager: ', aString.</body><body package="COClusterManagement">statusLog: aString	CoastLog log: aString.</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>initialize - release</category><body package="COClusterManagement">initialize	COAST.CatFSSlot buildTypeDictionary.	COAST.CatCSCellAccess postLoad.	COAST.CatCSCellValueHolder initializeIndexArray.	COBinaryExternal resetLibAvailable.	clusterManagers := Dictionary new.	exclusiveLock := RecursionLock new.	currentLoadedClusterID := nil asValue.	packetStations := Dictionary new.	segmentSplitSize := 4096.</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>private</category><body package="COClusterManagement">applicationDescription	" Return a dictionary with string keys and coast primitive values that describes the application "	| applicationDescription |	applicationDescription := Dictionary new.	applicationDescription at: CoastConstant applicationOS put: OSHandle currentPlatformID.	applicationDescription at: CoastConstant clientProcessID put: OSHandle currentProcessID printString.	applicationDescription at: CoastConstant applicationCoastVersion put: CoastVersion defaultCoastVersion displayString.	applicationDescription at: CoastConstant applicationImageVersion put: CoastVersion imageVersionString.	applicationDescription at: CoastConstant applicationVMVersion put: CoastVersion vmVersionString.	applicationDescription at: CoastConstant applicationBuildString put: CoastVersion buildString.	CoastVersion publicKeyMD5FingerPrintOrNil ifNotNil: [ : fingerPrint |		applicationDescription at: CoastConstant applicationMD5FingerPrint put: fingerPrint.	].	^ applicationDescription</body><body package="COClusterManagement">basicAutoSaveTimeInterval: anInteger	"max time between saves in seconds"	autoSaveTimeInterval := anInteger</body><body package="COClusterManagement">clientOnlyOperationError: aString	CoastError raiseSignal: 'Only supported by client cluster managers: ', aString</body><body package="COClusterManagement">initializeClusterManager: clusterManager forVolume: aVolume	" initialize the cluster manager, but do not register it yet "	clusterManager volumeManager: self.	clusterManager volume: aVolume.</body><body package="COClusterManagement">registerClusterManager: cm volume: aVolume 	clusterManagers at: aVolume put: cm.</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>naming service</category><body package="COClusterManagement">addNamedFrame: aFrame inVolume: aVolume	^ (self clusterManagerForVolume: aVolume) addNamedFrame: aFrame</body><body package="COClusterManagement">findOrCreate: aClass named: aString inVolume: aVolume 	^ (self clusterManagerForVolume: aVolume) findOrCreate: aClass named: aString</body><body package="COClusterManagement">modelNamed: aString inExistingVolume: aVolume 	| cm |	cm := self clusterManagerForVolume: aVolume ifAbsent: [ nil ].	^ cm notNil 		ifTrue: [ cm modelNamed: aString ]		ifFalse: [ nil ]</body><body package="COClusterManagement">modelNamed: aString inVolume: aVolume	^ (self clusterManagerForVolume: aVolume) modelNamed: aString</body><body package="COClusterManagement">namedModelsInVolume: aVolume 	^ (self clusterManagerForVolume: aVolume) namedModels</body><body package="COClusterManagement">removeFrameNamed: aString inVolume: aVolume	^ (self clusterManagerForVolume: aVolume) removeFrameNamed: aString</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>requests</category><body package="COClusterManagement">backupVolume: volumeName remotePassword:  remotePassword	" backup volume. returns a CoastStatusResponse "	^ self backupVolume: volumeName</body><body package="COClusterManagement">copyVolume: volumename to: newName remotePassword: remotePassword 	" copy volume. returns a CoastStatusResponse "	^ self copyVolume: volumename to: newName</body><body package="COClusterManagement">deleteBackup: backupVolume version: version remotePassword: remotePassword 	" delete backup. returns a CoastStatusResponse "	^self deleteBackup: backupVolume version: version</body><body package="COClusterManagement">deleteVolume: volumeName remotePassword: remotePassword 	" delete volume. returns a CoastStatusResponse "	^ self deleteVolume: volumeName</body><body package="COClusterManagement">recoverToVolume: targetVolume fromVolume: backupVolume version: version remotePassword: remotePassword 	" try to restore a backup of the volume. returns a CoastStatusResponse "	^self recoverToVolume: targetVolume fromVolume: backupVolume version: version</body></methods><methods><class-id>COAST.CatCSVolumeManager</class-id> <category>initialize</category><body package="COClusterManagement">shutDown	self exclusiveUseDo:	[	[ self waitUntilSendQueueIsEmpty ] coastValueWithinMilliseconds: 1000 orDo: [ CoastLog log: 'Send queue is not empty, continuing shutdown anyway' ].		clusterManagers copy do: [ :cm | cm releaseAllClusters ].		self disconnectAllPacketStations.	].	volumeInterface notNil ifTrue: [ volumeInterface shutDown ].	currentLoadedClusterID changed: #shutDown.</body></methods><methods><class-id>COAST.CatCSVolumeManager class</class-id> <category>defaults</category><body package="COClusterManagement">defaultStorageClass	^ DefaultStorageClass ifNil: 		[	"dynamically uses BFS by default if available"			( CatCSAbstractDiskVolumeAccessor subclasses select: [: cl | cl isAbstract not ]) 				singleElementIfMore: [: classes | classes detect: [: cl | cl ~~ CatCSVolumeFileStorageAccessor ]]		]</body><body package="COClusterManagement">defaultStorageClass: aClass	DefaultStorageClass := aClass</body></methods><methods><class-id>COAST.CatCSVolumeManager class</class-id> <category>instance creation</category><body package="COClusterManagement">new	^super new initialize; yourself</body></methods><methods><class-id>COAST.CatCSVolumeManager class</class-id> <category>utilities</category><body package="COClusterManagement">checkVolumeName: volume	(volume notNil and: [ volume isValidVolumeString ]) 		ifFalse: [ CoastError raiseSignal: 'Bad volume name: ', volume printString ]</body><body package="COClusterManagement">descriptionForBackupVersion: version 	^ ( self timestampOfBackupVersion: version ) coastShortPrintString</body><body package="COClusterManagement">timestampOfBackupVersion: version 	^ Timestamp fromSeconds: version asInteger</body></methods><methods><class-id>COAST.CatRMPacketStation</class-id> <category>private: accessing</category><body package="COClusterManagement">authenticationOK	^ CoastConstant authenticationOK</body><body package="COClusterManagement">closeConnection	" irreversibly close the connection. 	notify the peer by sending a close message first "	isInShutdown := true.	self sendClosePacket.	self shutDown.</body><body package="COClusterManagement">disconnectIrreversible	"disonnect the packet station. streams and sockets will be closed, processes be terminated.	connection errors may be raised.	! do not send this from a receive/send-process ! "	connected := false.	[		self terminateProcessesAndStreams.	] on: Error do: [:ex |		ex return	].	volumeManager stationIrreversibleLostConnection: self</body><body package="COClusterManagement">flushSocket"	| res |	sysSupport isNil			ifTrue: [ sysSupport := OSSystemSupport concreteClass new ].	res := sysSupport coastFlushFileBuffers: socketAccessor coastHandle.	res = 0 ifFalse: [ CoastLog logError: 'Dang! flush failed ', res printString ]."</body><body package="COClusterManagement">messageClassFor: messageClassName 	| msgClass |	msgClass := self class environment at: messageClassName asSymbol ifAbsent: [ nil ].	^ ( msgClass notNil and: [ msgClass includesBehavior: CatRMMessage ]) 		ifTrue: [ msgClass ]		ifFalse: 		[	self error: 'Unknown message class name: ' , messageClassName.			self unsetConnected.			nil		]</body><body package="COClusterManagement">psPrintString	self subclassResponsibility</body><body package="COClusterManagement">shutDown	"do a proper shutdown. streams and sockets will be closed, processes be terminated.	no connection errors will be raised. however, we do not notify the peer,	the peer must notice the shutdown independently "	isInShutdown := true.	self disconnectIrreversible.</body><body package="COClusterManagement">socketAccessor	^ socketAccessor</body><body package="COClusterManagement">terminateProcessesAndStreams	self terminateReceiveAndSendViaSocket: socketAccessor.</body><body package="COClusterManagement">terminateReceiveAndSendViaSocket: aSocketAccessor	receiveProcess notNil		ifTrue: [			receiveProcess terminate.			receiveProcess := nil		].	sendProcess  notNil		ifTrue: [			sendProcess terminate.			sendProcess := nil.		].	receiveStream close.	sendStream close.	[		aSocketAccessor close.	] on: Error do: [ : ex |		CoastLog logWarning: 'Could not close socket: ', ex description.	].</body><body package="COClusterManagement">unsetConnected		connected ifTrue:	[		self disconnectIrreversible	].</body></methods><methods><class-id>COAST.CatRMPacketStation</class-id> <category>state acessing</category><body package="COClusterManagement">connected	^connected</body><body package="COClusterManagement">isInShutdown	" true if the packet station is performing an intented shutdown "	^ isInShutdown</body></methods><methods><class-id>COAST.CatRMPacketStation</class-id> <category>status reports</category><body package="COClusterManagement">connectionLostError	(connected and: [ self isInShutdown not ])		ifTrue: [ self statusLog: 'Lost connection' ].</body><body package="COClusterManagement">statusError: aString	CoastLog logError: 'Error in ', self psPrintString, ': ', aString.	CoastLog log: (self callStackStringOfSize: 30).</body><body package="COClusterManagement">statusLog: aStringOrBlock	CoastLog logDebugDo: [ self psPrintString, ': ', aStringOrBlock value ].</body></methods><methods><class-id>COAST.CatRMPacketStation</class-id> <category>private: send/receive</category><body package="COClusterManagement">connectionLostTo: oldSocket	(connected not or: [ self isInShutdown ])		ifFalse: [ self handleConnectionLostTo: oldSocket ]</body><body package="COClusterManagement">deliverReceivedMessage: aCatRMMessage 	"deliver the message to the cluster manager"	volumeManager handleMessage: aCatRMMessage.</body><body package="COClusterManagement">handleConnectionLostTo: oldSocket	self disconnectIrreversible</body><body package="COClusterManagement">ignoreMessageLoopErrors	^ isInShutdown == true</body><body package="COClusterManagement">logExpected: expectedID received: messageID 	CoastLog log: [ 'Expected message ID ' , expectedID printString , ', received ' , messageID printString ].</body><body package="COClusterManagement">messageLoopDo: aBlock description: description 	| lastSocket |	lastSocket := nil.	[			[				[					[					lastSocket := socketAccessor.					aBlock value.				] 					on: CoastConnectionLostError , OsError					do: 					[: ex |						self ignoreMessageLoopErrors 							ifFalse: [ CoastLog logError: 'Connection probably lost at ' , self printString, ': ', ex description ].						false					]			] 				on: UserInterrupt				do: 				[: ex |					CoastLog log: 'Ignore user interrupt in message loop'.					ex resume				]		] 			on: Error 			do: 			[: ex |				self ignoreMessageLoopErrors 					ifFalse: [ CoastLog logExceptionShort: ex message: 'Error in message loop of ' , self printString ].				lastSocket := nil.				connected := false.				[ self disconnectIrreversible ] fork.				false			]	] whileTrue: [ ].	self ignoreMessageLoopErrors 		ifFalse: 		[	"reconnect will terminate this process, so be careful and fork another one"			[ self connectionLostTo: lastSocket ] fork		]</body><body package="COClusterManagement">pseudoMessageName	^ 'Coast'</body><body package="COClusterManagement">receiveBlock	^ [		self 			messageLoopDo: [ self receiveCommandOrMessage ]			description: 'receive block'.	]</body><body package="COClusterManagement">receiveCommandOrMessage	| command wrappedStream |	" we don't know yet, if the next message is checksummed, so start hashing, result can be discarded later if not needed"	wrappedStream := CoastHashStream originalStream: receiveStream.	command := self receiveNextCommandFrom: wrappedStream.	command isNil 		ifTrue: [ ^ false ].	command == 0 		ifTrue: 		[				[ self receivedRegularDisconnect. self disconnectIrreversible ] fork.			^ false		].	"close command"	command == 1 		ifTrue: [ ^ true ].	"alive command"	^ self receiveMessageFrom: wrappedStream</body><body package="COClusterManagement">receiveMessageFrom: checksummedStream 	| delivered newMessage version marshall header messageClass messageID expectedID |	delivered := false.	version := nil.	[ | wrappedStream |		CoastLog logDebugCoast: [ 'About to receive a message' ].		header := checksummedStream nextCoastString.		messageClass := self messageClassFor: header.		newMessage := messageClass new.		" discard and stop hashing if not required "		wrappedStream := newMessage needsChecksum 				ifTrue: [ checksummedStream ]				ifFalse: [ checksummedStream originalStream ].		newMessage receiverPacketStation: self.		marshall := CatMAMarshallBinary new.		version := CoastVersion unmarshallBinaryFrom: wrappedStream marshaller: marshall.		messageID := wrappedStream next.		newMessage unmarshallMessageFrom: wrappedStream marshaller: marshall withVolumeManager: volumeManager.		CoastLog logDebugCoast: [ 'Received ' , newMessage printString ].		newMessage needsChecksum ifTrue: 			[	checksummedStream verifyCoastHash 					ifFalse: [ CoastOsStreamError raiseSignal: 'Hash failed for message ' , messageClass fullName , ' from ' , self printString ]			].		( lastReceiveID notNil and: [( expectedID := ( lastReceiveID + 1 ) \\ 256 ) ~= messageID ]) 			ifTrue: [ self logExpected: expectedID received: messageID ].		messageID ~= lastReceiveID 			ifTrue: [ self deliverReceivedMessage: newMessage ]			ifFalse: [ CoastLog log: [ 'Duplicate message ' , messageID printString , ', already received' ]].		lastReceiveID := messageID.		delivered := true	] on: StreamError , EndOfStreamNotification from: checksummedStream coreStream do: [: ex | CoastOsStreamError raiseSignal: ex description ].	delivered ifTrue: [ CoastLog logDebugCoast: [ 'Delivered ' , newMessage printString ]].	^ delivered</body><body package="COClusterManagement">receiveNextCommandFrom: readSteam 	^ self receiveNextCommandRetries: 10 from: readSteam</body><body package="COClusterManagement">receiveNextCommandRetries: retries from: readStream 	| nextByte exceptionDescription tries |	tries := 1.	exceptionDescription := 'unknown reason'.	[	nextByte := nil.		readStream closed 			ifTrue: [ ^ nil ].	"already closed"		[				[ nextByte := readStream next ] on: OsIllegalOperation do: [: ex | exceptionDescription := ex description]		] 			on: StreamError , EndOfStreamNotification			from: readStream coreStream			do: 			[: ex |				( socketAccessor notNil and: [ socketAccessor errorCode notNil ]) 					ifTrue: [ CoastOsStreamError raiseSignal: ex description ].				exceptionDescription := ex description			].		nextByte isNil	] whileTrue: 		[	tries = retries				ifTrue: [ CoastOsStreamError raiseSignal: 'Giving up receiving next command: ', exceptionDescription ].			tries := tries + 1		].	( tries &gt; 1 and: [ self ignoreMessageLoopErrors not ]) 		ifTrue: [ CoastLog logWarning: 'Skipped error while receiving next command: ' , exceptionDescription ].	^ nextByte</body><body package="COClusterManagement">receivedRegularDisconnect	"notify regular peer disconnect"</body><body package="COClusterManagement">send: aCatRMMessage 	" a transmitted message consists of the classname and the marshalled message "	"remember the message to be sent for later re-send in case of failure"	"we assume that the tcp-ip streaming protocol ensures safe delivery,	i.e. multiple messages can not be lost in the network"	| sendOk |	trySendMessage := aCatRMMessage.	CoastLog logDebug: [ 'try to send ' , aCatRMMessage printString ] channel: #coastIO.	connected ifFalse: [ ^ false ].	sendOk := false.	[ | marshall wrappedStream needsChecksum |		needsChecksum := aCatRMMessage needsChecksum.		wrappedStream := needsChecksum 				ifTrue: [ CoastHashStream originalStream: sendStream ]				ifFalse: [ sendStream ].		wrappedStream nextPut: aCatRMMessage commandID.		aCatRMMessage isCommand ifFalse: 			[	marshall := CatMAMarshallBinary new.				aCatRMMessage prepareMarshaller: marshall volumeManager: self volumeManager.				aCatRMMessage marshallBinaryHeaderTo: wrappedStream marshaller: marshall.				marshall marshall: aCatRMMessage to: wrappedStream			].		needsChecksum ifTrue: [ wrappedStream storeCoastHash ].		sendStream flush.		aCatRMMessage delivered.		sendOk := true	] on: OsTransferFaultError , OsInvalidArgumentsError , OsIllegalOperation		do: 		[: ex |			aCatRMMessage deliverError.			CoastOsStreamError raiseSignal: ex description		].	sendOk ifTrue: [ CoastLog logDebug: [ 'successful sent ' , aCatRMMessage printString ] channel: #coastIO ].	^ sendOk	"answer true if sending was succesful"</body><body package="COClusterManagement">sendAlivePacket	self transmitMessage: CatRMAliveCommand new</body><body package="COClusterManagement">sendBlock	^ [		self 			messageLoopDo: [ self send: sendQueue next]			description: 'send block'.	]</body><body package="COClusterManagement">sendClosePacket	| cmd |	connected 		ifTrue: 		[				[	cmd := CatRMCloseCommand new.				self transmitMessage: cmd.				cmd waitForDelivery			] coastValueWithinSeconds: self class closePacketTimeout		].</body><body package="COClusterManagement">timeoutAfter: requestTimeout whileWaitingFor: aCatRMRequestMessage 	| msg |	msg := 'Timeout after ' , requestTimeout printString , ' seconds while waiting for response to ' , aCatRMRequestMessage printString.	CoastLog logError: msg.	self connectionLostTo: socketAccessor.	CoastConnectionLostError raiseSignal: msg.</body><body package="COClusterManagement">waitUntilSendQueueIsEmpty	[ sendQueue isEmpty ] whileFalse: [		100 milliseconds wait	]</body></methods><methods><class-id>COAST.CatRMPacketStation</class-id> <category>private: initialize</category><body package="COClusterManagement">initialize	connected := false.	lastSendID := 0.	lastReceiveID := 0.	isInShutdown := false.</body><body package="COClusterManagement">initializeProcesses	Notifier isDevelopment ifTrue: [ self class register ].	sendQueue := SharedQueue new.	self startSendProcess.	self startReceiveProcess.</body><body package="COClusterManagement">processNamePrefix	self subclassResponsibility.</body><body package="COClusterManagement">restartReceiveProcess	self startReceiveProcess.</body><body package="COClusterManagement">restartSendProcess	"we are connected again, try restarting the send process"	"maybe there was an unsuccessful send last time, send this first"	trySendMessage notNil ifTrue:	[		self statusLog: 're-sending ', trySendMessage printString.		(self send: trySendMessage) 			ifTrue: [ 	self statusLog: 're-sending successful'. ]			ifFalse: [ 				CoastLog logError: 're-sending failed  re-connect failed'.				^nil ]. "argh, failed again"	].	self startSendProcess.</body><body package="COClusterManagement">secureHandshakeWithReceiveStream: aReceiveStream SendStream: aSendStream 	| otherFingerprint otherPK size coastChallenge peerChallenge myResponse |	CoastLog logDebug: 'initiate secure Handshake' channel: #crypto.	"1 exchange fingerprint"	"1 A send fingerprint"	aSendStream nextPutAll: CoastVersion publicKeyMD5FingerPrint.	aSendStream flush.	"1 B receive fingerprint"	otherFingerprint := aReceiveStream nextAvailable: 16.	otherPK := CoastVersion trustedPublicKeyForFingerPrint: otherFingerprint.	( otherPK isNil and: [ CoastVersion challengeEnabled ]) ifTrue: [ ^ 'unknown fingerprint' ].	CoastLog logDebug: [ 'peer fingerprint ' , otherFingerprint asHexString ] channel: #crypto.	"2 exchange challenge"	"2A send challenge"	coastChallenge := otherPK notNil 			ifTrue: [ otherPK coastChallenge ]			ifFalse: [ #[ ]].	aSendStream nextOptimized32Put: coastChallenge size.	aSendStream nextPutAll: coastChallenge.	aSendStream flush.	"2B receive challenge"	size := aReceiveStream nextOptimized32.	size &lt; 0 ifTrue: [ ^ 'fingerprint rejected by peer' ].	peerChallenge := aReceiveStream nextAvailable: size.	CoastLog logDebug: 		[	'challenge from peer: ' , ( peerChallenge isEmpty 						ifTrue: [ '-none-' ]						ifFalse: [ peerChallenge asHexString ])		]		channel: #crypto.	"3 exchange response"	"3A send response"	myResponse := CoastVersion coastSign: peerChallenge.	aSendStream nextOptimized32Put: myResponse size.	aSendStream nextPutAll: myResponse.	aSendStream flush.	"3B receive response"	size := aReceiveStream nextOptimized32.	( CoastVersion coastVerify: ( aReceiveStream nextAvailable: size ) of: coastChallenge publicKey: otherPK ) ifFalse: [ ^ 'challange rejected' ].	CoastLog logDebug: [ 'peer response valid' ] channel: #crypto.	"exchange response confirm"	aSendStream nextOptimized32Put: 1.	"confirme response"	aSendStream flush.	aReceiveStream nextOptimized32 = 1 ifFalse: [ ^ 'peer rejected my response' ].	^ nil</body><body package="COClusterManagement">startReceiveProcess	receiveProcess := self receiveBlock newProcess.	receiveProcess priority: Processor lowIOPriority - 3.	receiveProcess name: self processNamePrefix , ' - receive process'.	receiveProcess resume.</body><body package="COClusterManagement">startSendProcess	sendProcess := self sendBlock newProcess.	sendProcess priority: Processor lowIOPriority - 2.	sendProcess name: self processNamePrefix , ' - send process'.	sendProcess resume.</body></methods><methods><class-id>COAST.CatRMPacketStation</class-id> <category>accessing</category><body package="COClusterManagement">ipAdressString	^ ipAdressString ifNil: 		[				[ ipAdressString := self peerIPNumber asIPAdressString ] on: Error do: [: ex | 'unreachable ip'	"maybe later?!" ]		]</body><body package="COClusterManagement">peerIPNumber	^socketAccessor getPeer hostAddress</body><body package="COClusterManagement">peerString	| stream |	stream := String new writeStream.	self peerStringTo: stream.	^ stream contents</body><body package="COClusterManagement">peerStringTo: stream 	self printPeerTypeOn: stream.	stream		space;		nextPut: $(;		nextPutAll: self ipAdressString;		nextPut: $)</body><body package="COClusterManagement">printPeerTypeOn: stream 	self subclassResponsibility</body><body package="COClusterManagement">volumeManager	^ volumeManager</body><body package="COClusterManagement">volumeManager: aVolumeManager	volumeManager := aVolumeManager</body></methods><methods><class-id>COAST.CatRMPacketStation</class-id> <category>sending</category><body package="COClusterManagement">transmitMessage: aCatRMAsynchronousMessage	"puts aCatRMAsynchronousMessage into the sendQueue for later transmission "	aCatRMAsynchronousMessage isCommand		ifFalse: [ lastSendID := (lastSendID + 1) \\ 256 ].	aCatRMAsynchronousMessage messageID: lastSendID.	sendQueue nextPut: aCatRMAsynchronousMessage.	^aCatRMAsynchronousMessage</body></methods><methods><class-id>COAST.CatRMPacketStation class</class-id> <category>initialize-release</category><body package="COClusterManagement">deregister	ObjectMemory removeDependent: self</body><body package="COClusterManagement">obsolete	self deregister.	super obsolete.</body><body package="COClusterManagement">register	(ObjectMemory dependents includes: self)		ifFalse: [ ObjectMemory addDependent: self ]</body><body package="COClusterManagement">shutDownAll	"self shutDownAll"	self allInstances do: [ : inst |		inst disconnectIrreversible	].</body><body package="COClusterManagement">update: anAspect	(#(aboutToSnapshot) includes: anAspect)		ifTrue: [ self shutDownAll ].</body></methods><methods><class-id>COAST.CatRMPacketStation class</class-id> <category>instance creation</category><body package="COClusterManagement">new	^super new initialize; yourself</body></methods><methods><class-id>COAST.CatRMPacketStation class</class-id> <category>accessing</category><body package="COClusterManagement">closePacketTimeout	" timeout in seconds "	^ 3</body></methods><methods><class-id>COAST.CatRMPacketStation class</class-id> <category>utility</category><body package="COClusterManagement">marshallVersionOn: aStream	CoastVersion defaultCoastVersion marshallBinaryTo: aStream marshaller: nil.	aStream nextOptimized32Put:  CoastConstant protocolVersion.</body></methods><methods><class-id>COAST.CoastCSVLogColumn</class-id> <category>accessing</category><body package="COClusterManagement">index	^index</body><body package="COClusterManagement">index: anObject	index := anObject</body><body package="COClusterManagement">isQuoted	^isQuoted</body><body package="COClusterManagement">isQuoted: aBoolean	isQuoted := aBoolean</body><body package="COClusterManagement">isUnknown	" true if the column was not specified in the ini file "	^ isUnknown</body><body package="COClusterManagement">isUnknown: aBoolean	" true if the column was not specified in the ini file "	isUnknown := aBoolean</body><body package="COClusterManagement">key	^ self name</body><body package="COClusterManagement">name	^name</body><body package="COClusterManagement">name: anObject	name := anObject</body></methods><methods><class-id>COAST.CoastCSVLogColumn</class-id> <category>initialize-release</category><body package="COClusterManagement">initializeFromToken: token index: i	| s |	self index: i.	s := token trimBlanks.	isQuoted := '"*"' match: s.	name := isQuoted		ifTrue: [ s copyFrom: 2 to: s size - 1 ]		ifFalse: [ s].	self isUnknown: false.</body></methods><methods><class-id>COAST.CoastCSVLogColumn</class-id> <category>private</category><body package="COClusterManagement">logHash	^ self name coastAsLargeInteger bitXor: self index</body></methods><methods><class-id>COAST.CoastCSVLogColumn class</class-id> <category>instance creation</category><body package="COClusterManagement">fromToken: token index: i	^ self new		initializeFromToken: token index: i;		yourself</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>accessing</category><body package="COClusterManagement">accessCountFor: clusterID 	^ 0</body><body package="COClusterManagement">addToApplicationLog: aCatCSApplicationLog	aCatCSApplicationLog isEmpty		ifFalse: [ self storageInterface addToApplicationLog: aCatCSApplicationLog ].</body><body package="COClusterManagement">approxClusterByteSize	^ self clusterController inject: 0 into: [ :bs :cc | bs + cc clusterStub approxByteSize ].</body><body package="COClusterManagement">approxResolvedByteSize	" approx. byte size of all loaded cluster when stored on disk, 	except size of frames that are not yet resolved "	" possibly expensive, so handle with care "	^ self clusterController inject: 0 into: [ :bs :cc | bs + cc clusterStub approxResolvedByteSize ].</body><body package="COClusterManagement">autoSaveInterval"number of transactions after which an autosave is triggered."	^autoSaveInterval</body><body package="COClusterManagement">autoSaveTimeInterval	"max time between saves in seconds"	^ self volumeManager autoSaveTimeInterval</body><body package="COClusterManagement">autosaveTime	autosaveTime isNil		ifTrue: [ autosaveTime := Time secondClock + self autoSaveTimeInterval ].	^autosaveTime</body><body package="COClusterManagement">classNameManager	^ classNameManager</body><body package="COClusterManagement">clusterController	" PLURAL "	^clusterController</body><body package="COClusterManagement">clusterControllerAt: clusterID	^clusterController at: clusterID ifAbsent: [ nil ]</body><body package="COClusterManagement">clusters	| result |	result := Dictionary new: self clusterController size.	self clusterController keysAndValuesDo: [:k :v | result at: k put: (v cluster)].	^result</body><body package="COClusterManagement">createRootCluster	^self createCluster: self rootClusterID</body><body package="COClusterManagement">deregisterClusterWithStream: aCatCSCluster	"just for lint - only called by clients"</body><body package="COClusterManagement">frameClassIndex	^frameClassIndex</body><body package="COClusterManagement">frameForString: frameIDString 	"aus 123-234 wird zunÃ¤chst 123 234. Falls der nicht exisitiert, wiurd nach dem tempShared Frame -234 gesucht"	| readStream clusterID frameID frame |	frameIDString isString ifFalse: [ ^ nil ].	( frameIDString allSatisfy: [: ch | ch isDigit ]) ifTrue: [ ^ self frameFromFullIDNumber: frameIDString asInteger ].	readStream := frameIDString readStream.	clusterID := self nextNumberFrom: readStream.	clusterID isNil ifTrue: [ ^ nil ].	clusterID &lt; 0 ifTrue: [ clusterID := clusterID abs ].	frameID := self nextNumberFrom: readStream.	frameID isNil ifTrue: [ ^ nil ].	frame := self getFrame: frameID abs inCluster: clusterID.	( frame isNil and: [ frameID &lt; 0 ]) ifTrue: [ frame := self getFrame: frameID inCluster: clusterID ].	^ frame</body><body package="COClusterManagement">frameFromFullIDNumber: aNumber	| clusterID frameID |	clusterID := aNumber bitShift: -32.	frameID := aNumber bitAnd: 16rFFFFFFFF.	^ self getFrame: frameID inCluster: clusterID</body><body package="COClusterManagement">frameFromFullIDString: idString 	| locator |	locator := CatCSFrameLocator newFullIDString: idString.	^ locator isNil 		ifTrue: 		[	CoastLog logError: 'Malformed frame ID: ', idString displayString.			nil		]		ifFalse: [ self getFrame: locator frameID inCluster: locator clusterID ]</body><body package="COClusterManagement">getCluster: clusterIDInteger 	"load the cluster if not already loaded. return the cluster"	| cluster |	self exclusiveUseDo: 	[ | cc |	cc := clusterController at: clusterIDInteger ifAbsent: [ nil ].	cluster := cc isNil		ifTrue: [ 			volumeManager currentLoadedClusterID: clusterIDInteger.			self loadCluster: clusterIDInteger 		]		ifFalse: [ cc cluster ]	].	^cluster</body><body package="COClusterManagement">getClusterStub: clusterIDInteger 	"load the cluster if not already loaded. return the stub "	| cc |	cc := clusterController at: clusterIDInteger ifAbsent: [ nil ].	^ cc notNil		ifTrue: [ cc clusterStub ]		ifFalse: [ self loadClusterStub: clusterIDInteger ]</body><body package="COClusterManagement">getFrame: aFrameLocator	^ self getFrame: aFrameLocator frameID inCluster: aFrameLocator clusterID</body><body package="COClusterManagement">getFrame: frameIDInteger inCluster: clusterIDInteger 	| cluster |	 cluster := [ self getCluster: clusterIDInteger ] on: ClusterNotFoundError do: [ :ex | nil ].	^cluster isNil		ifTrue: [ nil ]		ifFalse: [ cluster directTableAccessAt: frameIDInteger ]</body><body package="COClusterManagement">getRootCluster	^self getCluster: self rootClusterID</body><body package="COClusterManagement">hasCluster: aCatCSClusterID 	^clusterController includesKey: aCatCSClusterID</body><body package="COClusterManagement">lastSaveTime	lastSaveTime isNil		ifTrue: [ lastSaveTime := Time secondClock ].	^lastSaveTime</body><body package="COClusterManagement">maxClusterCount	^10</body><body package="COClusterManagement">nextClusterIDToLoad	^ storageInterface notNil 		ifTrue: [ storageInterface nextClusterIDToLoad ]		ifFalse: [ nil ]</body><body package="COClusterManagement">nextNumberFrom: frameIDStream 	| peek |	peek := nil.	[ frameIDStream atEnd or: [( peek := frameIDStream peek ) == $- or: [ peek isDigit ]]] whileFalse: [ frameIDStream next ].	^ frameIDStream atEnd 		ifTrue: [ nil ]		ifFalse: [ Integer readFrom: frameIDStream ]</body><body package="COTransactions">notifyReadCluster: cluster 	| tm transaction |	tm := self transactionManager.	tm notNil ifTrue: 		[	" can't be sure if we're inside an exclusive lock, so don't jump on foreign transactions "			transaction := tm activeTransactionOfCurrentProcess.			transaction notNil ifTrue: [ transaction addReadCluster: cluster ]		].</body><body package="COClusterManagement">recordApplicationLog: aCatCSApplicationLog</body><body package="COClusterManagement">rootClusterNeeded	^[ self getRootCluster ] on: ClusterNotFoundError do: [ :ex | self createRootCluster ].</body><body package="COClusterManagement">segmentSplitSize	^self volumeManager segmentSplitSize</body><body package="COClusterManagement">setAutosaveTime: seconds	"do not allow to set the time forward"	(seconds &lt; self autosaveTime)		ifTrue: [ autosaveTime := seconds ]</body><body package="COClusterManagement">storageInterface	storageInterface isNil		ifTrue: [ self initializeStorageInterface ].	^storageInterface</body><body package="COClusterManagement">tempBytesPool	^ tempBytesPool</body><body package="COTransactions">transactionManager	self subclassResponsibility.</body><body package="COClusterManagement">unloadStrategy	^ nil</body><body package="COClusterManagement">unloadStrategy: aStrategy</body><body package="COClusterManagement">volume	^volume</body><body package="COClusterManagement">volume: aString 	" last check that the volume is really ok "	| nilOrErrorMessage |	nilOrErrorMessage := self responsibleForVolume 			ifTrue: [ self volumeInterface checkVolume: aString clusterManager: self ]			ifFalse: [ nil ].	nilOrErrorMessage isNil 		ifTrue: [ volume := aString ]		ifFalse: [ CoastError raiseSignal: nilOrErrorMessage ].	"self initializeStorageAccessor.	self loadIndex."</body><body package="COClusterManagement">volumeIniAccess	^ self storageInterface volumeIniAccess</body><body package="COClusterManagement">volumeManager	^volumeManager</body><body package="COClusterManagement">volumeManager: aVolumeManager	volumeManager := aVolumeManager</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>cluster creation</category><body package="COClusterManagement">addReusableCluster: cluster	" ignored by default "</body><body package="COClusterManagement">basicCreateCluster: clusterIDInteger	| aClusterController cluster |	"The Locator contains the name of the cluster and the volume, where the cluster is stored"	"The cluster is created and remembered. Subclasses should build a controller for the new cluster"	aClusterController := self localControllerClass new.	aClusterController clusterManager: self.	aClusterController createCluster: clusterIDInteger.	cluster := aClusterController cluster.	cluster notNil		ifTrue: [ self registerClusterController: aClusterController atID: clusterIDInteger ].	^cluster</body><body package="COClusterManagement">basicLoadCluster: clusterIDInteger 	| newClusterController cluster |	newClusterController := self localControllerClass new.	newClusterController clusterManager: self.	newClusterController loadCluster: clusterIDInteger.	cluster := newClusterController cluster.	cluster notNil		ifTrue: [	self registerClusterController: newClusterController atID: clusterIDInteger ].	^cluster</body><body package="COClusterManagement">createCluster	"return a new cluster"	^ self createCluster: self newClusterID</body><body package="COClusterManagement">createCluster: clusterIDInteger	^ self basicCreateCluster: clusterIDInteger</body><body package="COClusterManagement">loadCluster: clusterIDInteger 	^ self basicLoadCluster: clusterIDInteger</body><body package="COClusterManagement">loadClusterStub: clusterIDInteger 	| newClusterController clusterStub |	newClusterController := self localControllerClass new.	newClusterController clusterManager: self.	clusterStub := nil.	[	newClusterController loadCluster: clusterIDInteger.		clusterStub := newClusterController clusterStub	] on: ClusterNotFoundError do: [: ex | ].	clusterStub notNil ifTrue: [ self registerClusterController: newClusterController atID: clusterIDInteger ].	^ clusterStub</body><body package="COClusterManagement">registerClusterController: aClusterController atID: clusterIDInteger 	"a new cluster will be managed by me. Add it to the clusters dictionary"	aClusterController clusterManager: self.	( clusterController includesKey: clusterIDInteger ) 		ifTrue: [ CoastLog logError: 'trying to register a cluster controller at an occupied id: ' , clusterIDInteger printString ].	clusterController at: clusterIDInteger put: aClusterController.	aClusterController clusterID: clusterIDInteger</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>testing</category><body package="COClusterManagement">canUpdateFrameIndex	^ true</body><body package="COClusterManagement">isClusterLoaded: clusterIDInteger	^ clusterController includesKey: clusterIDInteger</body><body package="COClusterManagement">isFrameLoaded: aFrameLocator	^ (self isClusterLoaded: aFrameLocator clusterID)		and: [ ((self getCluster:  aFrameLocator clusterID) directTableAccessAt: aFrameLocator frameID) isNil ]</body><body package="COTransactions">isLocalClient	^false</body><body package="COClusterManagement">isMediatorCM	^ false</body><body package="COClusterManagement">lazyFrameClasses	| b |	b := Bag new.	self clusterController do: [ : cc | 		cc clusterStub lazyFrameClasses valuesAndCountsDo: [ : cl : count |			b add: cl withOccurrences: count		]	].	^ b</body><body package="COClusterManagement">lazyFramesOfClass: aClass	| b |	b := Set new.	self clusterController do: [ : cc | 		b addAll: (cc clusterStub lazyFramesOfClass: aClass)	].	^ b asArray</body><body package="COClusterManagement">numberOfClustersLoaded	^self clusterController size</body><body package="COClusterManagement">numberOfFrames	^self clusterController inject: 0 into: [ : sum : cc | sum + cc clusterStub numberOfFrames ]</body><body package="COClusterManagement">numberOfLazyFrames	^self clusterController inject: 0 into: [ : sum : cc | sum + cc clusterStub numberOfLazyFrames ]</body><body package="COClusterManagement">supportsLazyUnmarshalling	^ false</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>controlling</category><body package="COClusterManagement">controllerClass	^CatCSSingleController</body><body package="COClusterManagement">localControllerClass	^CatCSSingleController</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>cluster unload</category><body package="COClusterManagement">cleanup	"shutdown if there are no interested parties"	(clusterController isEmpty and: [self responsibleForVolume and: [ storageInterface isNil or: [ self storageInterface okToCleanup ]]])		ifTrue: [ self shutDown ]</body><body package="COClusterManagement">deregisterClusterController: clusterIDInteger 	( clusterController at: clusterIDInteger ) clusterManager: nil.	clusterController removeKey: clusterIDInteger</body><body package="COClusterManagement">disresolveAllFramesInCluster: aCluster	"nothing to do"</body><body package="COClusterManagement">unloadAllClusters</body><body package="COClusterManagement">unloadCluster: aCluster 	self unloadCluster: aCluster disresolve: false notifyMediator: true.</body><body package="COClusterManagement">unloadCluster: aCluster disresolve: disresolve	self unloadCluster: aCluster disresolve: disresolve notifyMediator: true</body><body package="COClusterManagement">unloadCluster: aCluster disresolve: disresolve notifyMediator: doNotify 	CoastLog logDebug: [( doNotify 				ifTrue: [ 'Unloading :' ]				ifFalse: [ 'Dropping :' ]) , self volume , '/' , aCluster id printString ]		channel: #load.	aCluster clusterController releaseClusterAndNotifyMediator: doNotify.	disresolve ifTrue: [ self disresolveAllFramesInCluster: aCluster ].	self deregisterClusterController: aCluster id.</body><body package="COClusterManagement">unloadClustersIfNecessaryExcept: keepClusterIDs</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>exclusive use</category><body package="COClusterManagement">exclusiveUseDo: aBlock	"evaluate a block ensuring exclusive use of all clusters"	^volumeManager exclusiveUseDo: aBlock</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>index</category><body package="COClusterManagement">frameSlotIndexForIndex: anInteger	^ frameClassIndex frameSlotIndexForIndex: anInteger</body><body package="COClusterManagement">frameSlotIndexForIndex: newIndex put: newFsi 	^ frameClassIndex frameSlotIndexForIndex: newIndex put: newFsi</body><body package="COClusterManagement">frameSlotIndexForSymbol: aSymbolOrClass	^frameClassIndex frameSlotIndexForSymbol: aSymbolOrClass</body><body package="COClusterManagement">indexIniAccess	^ self storageInterface indexIniAccess</body><body package="COClusterManagement">loadIndex	self loadIndexFromIni: self indexIniAccess.</body><body package="COClusterManagement">loadIndexFromIni: ini	frameClassIndex loadIndex: ini for: self</body><body package="COClusterManagement">newFrameClassIndex	^frameClassIndex newFrameClassIndex</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>resolving</category><body package="COClusterManagement">getFrameForLoading: aCatFSExternalFrameDefinition 	self subclassResponsibility</body><body package="COClusterManagement">getFrameForLoading: frameID clusterID: clusterID frameKey: frameKey 	| frameRef |	frameRef := CatFSFrameReference clusterID: clusterID id: frameID frameKey: frameKey.	^ self getFrameForLoading: frameRef</body><body package="COClusterManagement">resolveFrameLocator: aCatCSFrameLocator	"do not resolve frame locators by default"	^ aCatCSFrameLocator</body><body package="COClusterManagement">resolveFrameReference: aCatFSFrameReference 	"do not resolve frame refs by default"	^ aCatFSFrameReference</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>private</category><body package="COClusterManagement">basicNextClusterID	"internal use only!!!"	"return nextClusterID or try to calucate it"	| tempCid |	nextClusterID notNil ifTrue: [ ^ nextClusterID ].	tempCid := self storageInterface nextClusterID.	tempCid notNil ifTrue: [ ^ tempCid ].	^ self calculateLastClusterAndBlobNumber + 1</body><body package="COClusterManagement">calculateLastClusterAndBlobNumber	"re-calculate the highest cluster number from my cluster- and blobIDs"	| num |	num := self storageInterface highestID.	^ clusterController keys inject: num into: [:maxNum :clusterIDInteger | 		num max: clusterIDInteger ].</body><body package="COClusterManagement">canCaptureFileLock: fileLock 	"only a medator can"	^ false</body><body package="COClusterManagement">classNameManagerClass	self subclassResponsibility</body><body package="COClusterManagement">clientOnlyOperationError: aString	CoastError raiseSignal: 'Only supported by client volume managers: ', aString</body><body package="COClusterManagement">hostDescription	^SocketAccessor hostDescription</body><body package="COClusterManagement">patch: someBytes 	"cluster bytes of a cluster that needs an upgrade "	^ someBytes</body><body package="COClusterManagement">resolveFrameReferenceCursor: aCatFSFrameReference 	"resolve or copy"	| frameOrReference |	frameOrReference := self resolveFrameReference: aCatFSFrameReference.	^ frameOrReference isCoastFrame 		ifTrue: [ frameOrReference ]		ifFalse: [ frameOrReference copy ]</body><body package="COClusterManagement">saveNextClusterID	(self responsibleForVolume and: [ nextClusterID notNil ])		ifTrue: [ self storageInterface nextClusterID: nextClusterID ].</body><body package="COClusterManagement">volumeAccessDenied: fileLock	"close all without saving!"	| error storedInfoString |	self clusterController do: [: e | e modified: false ].		self releaseAllClusters.	error := 'volume ', self volume printString , ' is locked'.	storedInfoString := fileLock storedInfoString.	storedInfoString isEmpty ifFalse: [error := error , ': ' , storedInfoString ].	CoastError raiseSignal: error</body><body package="COClusterManagement">volumeLockInfoString	^''</body><body package="COClusterManagement">withNameSpaceFrom: aString	| classOrNil |	classOrNil := self classNameManager classForCoastClassName: aString.	^classOrNil notNil 		ifTrue: [ classOrNil frameClassSymbol ]		ifFalse: [ frameClassIndex withNameSpaceFrom: aString ]</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>last wish</category><body package="COClusterManagement">addLastWish: loggedAgenda	"this is VERY basic	we store the loggedAgendas as concatenated byteArrays in a dictionary with key 'clientID'	thus after load, a ClusterManager can execute the last wishes"	| slot id stream oldBytes |	slot := self lastWishesSlot.	id :=  loggedAgenda transactionID clientID.	oldBytes := slot valueHolder at: id ifAbsent: [ ByteArray new ].	stream :=  ByteArray new writeStream.	stream nextPutAll: oldBytes.	loggedAgenda marshallBinaryTo: stream marshaller: self loadSaveMarshaller.	slot valueHolder value at: id put: stream contents.	self getRootCluster clusterController modified: true.</body><body package="COTransactions">executeLastWishes	"this is VERY basic	we store the loggedAgendas as concatenated byteArrays in a dictionary with key 'clientID'	thus after load, a ClusterManager can execute the last wishes"	| slot marshall |	self responsibleForVolume ifFalse: [ ^ self ].	( self storageInterface clusterExists: 0 ) ifFalse: [ ^ self ].	" don't create a new empty cluster 0 if it doesn't exist yet "	slot := self lastWishesSlotOrNil.	slot isNil ifTrue: [ ^ self ].	marshall := slot cluster unmarshaller.	marshall clusterManager: self.	slot valueHolder copy keysAndValuesDo: 		[: clientID : byteArray | | agendaCollection |			agendaCollection :=				[ self unmarshallLastWishFrom: byteArray marshall: marshall ] on: CoastError					do: 					[: ex |						CoastLog log: 'unmarshalling of last wish failed with Error: ' , ex description.						OrderedCollection new					].			( agendaCollection allSatisfy: [: loggedTransactionAgenda | loggedTransactionAgenda wouldAcceptLastWishFor: self ]) 				ifTrue: 				[	agendaCollection do: [: loggedTransactionAgenda | loggedTransactionAgenda rollForwardLastWishFor: self ].					CoastLog log: 'last wishes for ' , clientID printString , ' executed post mortem'				]				ifFalse: [ CoastLog log: 'skipped ' , agendaCollection size printString , ' last wishes for client ' , clientID printString ].			self removeLastWishesFor: clientID		].</body><body package="COClusterManagement">lastWishesFrame	| cluster |	cluster := self getRootCluster.	^cluster basicAdministrationFrame ifNil: 	[ | lastWishesFrame |		lastWishesFrame := self newLastWishesFrame.		lastWishesFrame id: 0.		cluster directTableAccessAt: 0 put: lastWishesFrame.		lastWishesFrame cellContainer: cluster.		cluster clusterController modified: true.		lastWishesFrame	].</body><body package="COClusterManagement">lastWishesFrameOrNil	| rootCluster |	rootCluster := [ self getRootCluster ] on: ClusterNotFoundError do: [ :ex | nil ].	^ rootCluster notNil 		ifTrue: [ rootCluster basicAdministrationFrame ]		ifFalse: [ nil ]</body><body package="COClusterManagement">lastWishesSlot	"this is VERY basic	we store the loggedAgendas as concatenated byteArrays in a dictionary with key 'clientID'	thus after load, a ClusterManager can execute the last wishes"	| lastWishesFrame slot |	lastWishesFrame := self lastWishesFrame.	slot := lastWishesFrame basicSlotNamed: #lastWish.	slot isNil ifTrue: 	[	slot := lastWishesFrame slotClass basicNew.		slot cellContainer: lastWishesFrame; valueHolder: CatCSDictionary new;  id: #lastWish.		lastWishesFrame addSlotForUpdate: slot.	].	^slot</body><body package="COClusterManagement">lastWishesSlotOrNil	"this is VERY basic	we store the loggedAgendas as concatenated byteArrays in a dictionary with key 'clientID'	thus after load, a ClusterManager can execute the last wishes"	| lastWishesFrame |	lastWishesFrame := self lastWishesFrameOrNil.	lastWishesFrame isNil ifTrue: [ ^ nil ].	lastWishesFrame notifyFastRead.	"see foot note"	^ lastWishesFrame basicSlotNamed: #lastWish	"a client enters a volume. to load cluster 0 it must download the index.	the mediator will perform #executeLastWishes before the index is sent to the client	if the checkAutoSaveAndRelease message comes between download index and get cluster 	the mediator unloads the cluster 0 (which was never read)	and releases the cluster manager just before reloading it	the probability for this behavior increases with the size of the volume (BFS)...	by using #notifyFastRead the unload can be prevented"</body><body package="COClusterManagement">newLastWishesFrame	^CatCSClusterAdministrationFrame new.</body><body package="COClusterManagement">removeLastWishesFor: clientID	"this is VERY basic	we store the loggedAgendas as concatenated byteArrays in a dictionary with key 'clientID'	thus after load, a ClusterManager can execute the last wishes"	| slot |	slot := self lastWishesSlotOrNil.	slot isNil ifTrue: [ ^self ].	slot valueHolder value removeKey: clientID ifAbsent: [ ^self ].	self getRootCluster clusterController modified: true.</body><body package="COTransactions">unmarshallLastWishFrom: byteArray marshall: marshall 	| agendaCollection stream |	stream := byteArray readStream.	agendaCollection := OrderedCollection new.	[ stream atEnd ] whileFalse: 		[	agendaCollection 				add: ( CatRMLoggedTransactionAgenda new unmarshallAgendaFrom: stream marshaller: marshall withVolumeManager: self volumeManager )		].	^ agendaCollection</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>IDs</category><body package="COClusterManagement">loadedClusterIDs	^clusterController keys</body><body package="COClusterManagement">newClusterID	"return a new clusterID"	| tempCid | 	[	tempCid := self basicNextClusterID.		nextClusterID := tempCid + 1	] on: Error		do: 		[: ex |			self error: 'Volume error: cannot create new cluster ID'.			tempCid := nil		].	self saveNextClusterID.	^ tempCid</body><body package="COClusterManagement">notifyImplicitCreatedClusterID: clusterID 	"#loadCluster: for non existing clusterID!"	"check if the implicit created cluster against nextClusterID"	| tempCid |	clusterID == 0 ifTrue: [ ^ self	"no other way to create the #rootCluster" ].	CoastLog logWarning: 'implicit creation of cluster ' , clusterID printString.	tempCid := self basicNextClusterID.	tempCid isNil ifTrue: [ self error: 'can not create cluster' ].	clusterID &gt;= tempCid ifTrue: 		[	nextClusterID := clusterID + 1.			self saveNextClusterID.			CoastLog 				logWarning: '... and patched nextClusterID (old: ' , tempCid printString , ' new: ' , nextClusterID printString , ')'		]</body><body package="COClusterManagement">rootClusterID	^ 0</body><body package="COClusterManagement">uniqueVolumeID	"answer the unique volume id"	"create id if not existent"	^ self storageInterface uniqueVolumeIDNeeded</body><body package="COClusterManagement">volumeID	^volumeID ifNil: [ volumeID := self uniqueVolumeID. volumeID ]</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>timeing</category><body package="COClusterManagement">localTimestamp	"Returns the current time"	^Timestamp coastRightNow</body><body package="COClusterManagement">milliseconds	^ self timestamp asMilliseconds</body><body package="COClusterManagement">timeDifference	"has no difference"	^ 0</body><body package="COClusterManagement">timestamp	"Returns the current time"	^self localTimestamp</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>releasement</category><body package="COClusterManagement">checkAutoSaveAndRelease	"check if it is time for autosave and release all not-yet-released clusters that are not used anymore	we have the exclusive lock for the volume so we can do what we want"	self saveAllModifiedClusters.</body><body package="COClusterManagement">releaseAllClusters	(( self clusterController 		select: [: cc | cc clusterStub notNil ])		sortedBy: [ : cc | cc clusterStub id negated ]) 			do: [ :cc | self unloadCluster: cc clusterStub disresolve: false notifyMediator: false ].	storageInterface notNil ifTrue: [ storageInterface prepareRelease ].	self cleanup.</body><body package="COClusterManagement">releaseCluster: clusterIDInteger	"aCatCSCluster is not needed any more"	(self clusterController includesKey: clusterIDInteger) ifTrue:	[		self releaseClusterController: (clusterController at: clusterIDInteger).	].</body><body package="COClusterManagement">releaseClusterController: aCatCSClusterController 	self exclusiveUseDo: 		[ | aClusterID releasedCC |			aClusterID := aCatCSClusterController clusterID.			releasedCC := clusterController removeKey: aClusterID ifAbsent: [ nil ].			releasedCC == aCatCSClusterController				ifTrue: [ 					aCatCSClusterController releaseClusterAndNotifyMediator: true.					aCatCSClusterController clusterManager: nil.				].			self cleanup		]</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>status reports</category><body package="COClusterManagement">statusError: aString 	CoastLog logError: 'Error in Cluster Manager: ' , aString</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>printing</category><body package="COClusterManagement">printOn: stream 	super printOn: stream.	stream nextPutAll: ' on volume: '.	volume printOn: stream</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>garbage collection</category><body package="COClusterManagement">removeCluster: clusterIDInteger 	"aCatCSCluster is never needed again"	storageInterface isNil ifTrue: [ self error: ('Cannot remove cluster &lt;1p&gt; without direct storage access' expandMacrosWith: clusterIDInteger) ].	self releaseCluster: clusterIDInteger.	storageInterface deleteCluster: clusterIDInteger</body><body package="COClusterManagement">responsibleForVolume	^true</body><body package="COClusterManagement">useProxyValueHolder	^ false</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>initialize</category><body package="COClusterManagement">basicEmergencyShutDown	" something bad has happended. make sure that we get into a valid state "	self volumeManager removeClusterManager: self volume.</body><body package="COClusterManagement">emergencyShutDown	" something bad has happended. make sure that we get into a valid state "	CoastLog logError: 'Emergency shutdown of volume ', self volume printString.	self basicEmergencyShutDown</body><body package="COClusterManagement">frameClassIndexClass	^ UpdatingFrameClassIndex</body><body package="COClusterManagement">initialize	clusterController := CatCOIntegerKeyDictionary new.	autoSaveInterval := 10000.	classNameManager := self classNameManagerClass default createNewManager.	frameClassIndex := self frameClassIndexClass clusterManager: self.	tempBytesPool := CatCSTempBytesPool new.</body><body package="COClusterManagement">initializeStorageInterface	storageInterface := self volumeInterface newClusterStorageAccessorFor: self.</body><body package="COClusterManagement">shutDown	self saveNextClusterID.	storageInterface notNil ifTrue: [storageInterface shutDown].	self volumeManager removeClusterManager: self volume.</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>dumping</category><body package="COClusterManagement">addDumpInfoTo: aStream 	aStream nextPutAll: self class printString; cr.	aStream tab; nextPutAll: 'cluster '; nextPutAll: self clusterController size printString; cr.	aStream tab; nextPutAll: 'volume '; nextPutAll: volume printString; cr.</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>interrupt</category><body package="COTransactions">interruptHandlers	^ #( )</body><body package="COClusterManagement">lowSpaceAction</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>requests</category><body package="COClusterManagement">backupVolume	" backup a volume or initiate a backup. returns a CoastStatusResponse "	self saveAllModifiedClusters.	^self storageInterface backupVolume.</body><body package="COClusterManagement">backupVolumeAndKeep: backupsToKeep 	self responsibleForVolume 		ifTrue: 		[	self saveAllModifiedClusters.			self storageInterface backupVolumeAndKeep: backupsToKeep.		]		ifFalse: [ CoastError raiseSignal: 'cannot backup remote volume' ].</body><body package="COClusterManagement">blockUntilBackupIsDone	^ self storageInterface blockUntilBackupIsDone</body><body package="COClusterManagement">compress	| message |	message := self exclusiveUseDo: 		[	self saveAllModifiedClusters.			self storageInterface compress		].	^ CoastStatusResponse okCode: #compressed message:  message</body><body package="COClusterManagement">copyVolumeForDownload	" copies the volume and returns a storage accessor of the copy "	| initiateCopyResult |	initiateCopyResult := self exclusiveUseDo: [		self saveAllModifiedClusters.		self storageInterface exclusiveInitiateCopyVolumeForDownload	].	CoastLog log: 'Finished exclusive part of download of volume ', self volume printString.	^ self storageInterface nonExclusiveFinishCopyVolumeForDownloadWith: initiateCopyResult</body><body package="COClusterManagement">copyVolumeTo: newVolume 	self saveAllModifiedClusters.	newVolume isValidVolumeString 		ifFalse: [ CoastError raiseSignal: 'bad target volume!' ].	( self volumeInterface volumeExists: newVolume ) 		ifTrue: [ CoastError raiseSignal: 'can not overwrite existing volume!' ].	self storageInterface copyVolumeTo: newVolume.	^ CoastStatusResponse okCode: CoastStatusResponse codeColumeCopied message: 'Volume ', self volume , ' copied to ', newVolume</body><body package="COClusterManagement">copyVolumeTo: newVolume remotePassword: remotePassword	self saveAllModifiedClusters.	newVolume isValidVolumeString ifFalse: [ CoastError raiseSignal: 'bad target volume!' ].	( self volumeInterface storedVolumes includes: newVolume ) ifTrue: [ CoastError raiseSignal: 'can not overwrite existing volume!' ].	^ self storageInterface copyVolumeTo: newVolume</body><body package="COClusterManagement">deleteVolume	" create a backup and delete the volume. returns a CoastStatusResponse "	| message |	self storageInterface prepareDeleteVolume.	self releaseAllClusters.	self storageInterface deleteVolume.	message := 'Volume "', self volume, '" deleted'.	CoastLog log: message.	^ CoastStatusResponse okCode: #volumeDeleted message: message</body><body package="COClusterManagement">deleteVolumeNoBackup	" delete the volume without creating a backup. returns a CoastStatusResponse "	self releaseAllClusters.	self storageInterface deleteVolumeNoBackup.	^ CoastStatusResponse okCode: #volumeDeletedNoBackup message: 'Volume ', self volume, ' deleted without backup'</body><body package="COClusterManagement">remoteCall: aFrame slotName: slotSymbol selector: selector arguments: argArray allowCache: allowCache 	self clientOnlyOperationError: 'RPC'</body><body package="COClusterManagement">volumeAccessor	self haltOrContinue: 'deprecated! use volumeInterface!'.	^ self volumeManager volumeAccessor</body><body package="COClusterManagement">volumeInterface	^ self volumeManager volumeInterface</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>naming service</category><body package="COClusterManagement">addNamedFrame: aFrame	self rootClusterNeeded administrationFrame atName: aFrame coastName put: aFrame.</body><body package="COClusterManagement">findOrCreate: aClass named: aString 	| theModel |	theModel := self modelNamed: aString.	theModel isNil 		ifTrue:  [ theModel := aClass newInCluster: self rootClusterNeeded named: aString].	^theModel</body><body package="COClusterManagement">modelNamed: aString	^self rootClusterNeeded administrationFrame atName: aString</body><body package="COClusterManagement">namedModels	^self rootClusterNeeded administrationFrame namedFrames values</body><body package="COClusterManagement">removeFrameNamed: aString	self rootClusterNeeded administrationFrame removeName: aString.</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>statistics</category><body package="COClusterManagement">coastStatistics	^ nil</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>blob handling</category><body package="COClusterManagement">loadFromID: anID toLocalFile: targetFile 	"if &lt;targetFile&gt; is an empty string, the contents of blob &lt;anID&gt; are 	returned as ByteArray. Otherwise, the byte sare copied to file &lt;targetFile&gt;"	| targetStream |	^targetFile = '' 		ifTrue: [ self storageInterface bytesFor: anID]		ifFalse: 			[targetStream := targetFile asFilename writeStream binary.			self storageInterface transferBlobData: anID to: targetStream.			targetStream close.			nil]</body><body package="COClusterManagement">storeBytes: aByteArray	| clusterIDInteger |	clusterIDInteger := self newClusterID.	self storageInterface importBlob: clusterIDInteger fromBytes: aByteArray.	^clusterIDInteger</body><body package="COClusterManagement">storeFile: aFilename 	| clusterIDInteger |	clusterIDInteger := self newClusterID.	self storageInterface importBlob: clusterIDInteger fromFile: aFilename.	^ clusterIDInteger</body><body package="COClusterManagement">storeStream: aStream 	| clusterIDInteger |	clusterIDInteger := self newClusterID.	self storageInterface importBlob: clusterIDInteger fromStream: aStream.	^ clusterIDInteger</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>marshalling</category><body package="COClusterManagement">loadMarshaller	"Returns the Marshaller which is used for loading clusters"	|  marshall |	marshall := ClusterUnmarshaller new.	marshall clusterManager: self.	^ marshall</body><body package="COClusterManagement">loadSaveMarshaller	"Returns the Marshaller which is used for loading and saving clusters from/to disk"	|  marshall |	marshall := CatMAMarshallBinary new.	marshall clusterManager: self.	^ marshall</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>saving</category><body package="COClusterManagement">saveAllClusters	"save all clusters, regardless if they have been modified or not. 	returns true if successfull"	^self exclusiveUseDo: [ self storageInterface saveAllClustersFor: clusterController values]</body><body package="COClusterManagement">saveAllModifiedClusters	"save all modified clusters. returns true if successfull "	^ self exclusiveUseDo: [ | modifiedClusters |		modifiedClusters := OrderedCollection new.		clusterController do: [:cc | cc modified ifTrue: [modifiedClusters addLast: cc]].		modifiedClusters isEmpty			ifTrue: [ true ]			ifFalse: [ self storageInterface saveAllClustersFor: modifiedClusters ].	].</body><body package="COClusterManagement">updateIndex: aFrameClassIndex 	| iniAccess |	self responsibleForVolume ifFalse: [ ^ self error: 'Cluster manager ' , self printString , ' is not responsible for the volume' ].	aFrameClassIndex updateWith: frameClassIndex.	iniAccess := self indexIniAccess.	aFrameClassIndex updateIndexIni: iniAccess.	self storageInterface indexIniAccess: iniAccess.	aFrameClassIndex flushUpdates.</body></methods><methods><class-id>COAST.CatCSClusterManager</class-id> <category>test and set</category><body package="COClusterManagement">isValidTestAndSetArg: argumentOrNil 	^ argumentOrNil isNil or: 		[	argumentOrNil isFrameOrFrameReference 				and: [ argumentOrNil isCoastFrame not or: [ argumentOrNil isShared and: [ argumentOrNil clusterManager = self ]]]		]</body><body package="COClusterManagement">testAndSet: key oldValue: oldValue newValue: newValue 	( key notNil and: [ self isValidTestAndSetArg: key ]) ifFalse: [ ^ nil	"unerlaubter key" ].	( self isValidTestAndSetArg: oldValue ) ifFalse: [ ^ nil	"kann nicht drin sein" ].	^ ( self isValidTestAndSetArg: newValue ) 		ifTrue: [ self validTestAndSet: key oldValue: oldValue newValue: newValue ]		ifFalse: [ self validTestAndSet: key oldValue: nil newValue: nil	"kann nicht rein - sag was drin ist" ]</body><body package="COClusterManagement">validTestAndSet: key oldValue: oldValue newValue: newValue	self subclassResponsibility</body></methods><methods><class-id>COAST.CatCSClusterManager class</class-id> <category>instance creation</category><body package="COClusterManagement">new	^super new initialize; yourself</body></methods><methods><class-id>COAST.CatCSClusterManager class</class-id> <category>dumping</category><body package="COClusterManagement">addDumpInfoTo: stream 	self withAllSubclasses do: 		[: each |			each allInstances do: 				[: cm |					cm addDumpInfoTo: stream.					cm classNameManager addDumpInfoTo: stream				]		].</body></methods><methods><class-id>COAST.CatCSFrameSlotIndex</class-id> <category>accessing</category><body package="COClusterManagement">addIndexForSlot: slotName 	slotArray := slotArray copyWith: slotName.	slotName notNil ifTrue: [ slotDict at: slotName put: slotArray size ].	^ slotArray size</body><body package="COClusterManagement">frameClass	^ frameClass</body><body package="COClusterManagement">frameClass: aClass 	frameClass := aClass.	aClass notNil ifTrue: [ self frameClassSymbol: frameClass frameClassSymbol ].</body><body package="COClusterManagement">frameClassFor: aNameSpaceManager 	frameClass isNil ifTrue: [ frameClass := aNameSpaceManager classForCoastClassName: self frameClassName ].	^ frameClass</body><body package="COClusterManagement">frameClassIndex: aFrameClassIndex 	frameClassIndex := aFrameClassIndex.</body><body package="COClusterManagement">frameClassName	^ self frameClassSymbol asString</body><body package="COClusterManagement">frameClassName: aString	self frameClassSymbol: aString asSymbol</body><body package="COClusterManagement">frameClassSymbol	^frameClassSymbol</body><body package="COClusterManagement">frameClassSymbol: symbol	^frameClassSymbol := symbol</body><body package="COClusterManagement">frameKey	| frameKey |	frameKey := self frameClass.	^ frameKey notNil 		ifTrue: [ frameKey ]		ifFalse: [ self frameClassSymbol ]</body><body package="COClusterManagement">hasFrameClassIndex	"for testcases"	^ frameClassIndex notNil</body><body package="COClusterManagement">key	^key</body><body package="COClusterManagement">key: aValue	key := aValue</body><body package="COClusterManagement">knowsSlot: slotName 	"for testcases"	^ slotDict includesKey: slotName</body><body package="COClusterManagement">noRetrySlotAtIndex: index 	index &gt; slotArray size ifTrue: [ CoastFrameClassIndexError raiseSignal: 'unknown slot index: ' , index printString ].	^ slotArray at: index</body><body package="COClusterManagement">slotAtIndex: index 	^ index &gt; slotArray size 		ifTrue: [( frameClassIndex refreshFrameIndexAt: key ) noRetrySlotAtIndex: index ]		ifFalse: [ self noRetrySlotAtIndex: index ]</body><body package="COClusterManagement">slotIndexFor: slotName 	^ slotDict at: slotName ifAbsent: [ frameClassIndex missingSlot: slotName for: self ]</body></methods><methods><class-id>COAST.CatCSFrameSlotIndex</class-id> <category>testing</category><body package="COClusterManagement">hasNameSpace	^ self frameClass notNil or: [ self frameClassSymbol includes: $. ]</body></methods><methods><class-id>COAST.CatCSFrameSlotIndex</class-id> <category>ini read write</category><body package="COClusterManagement">iniCategory	^ self frameClassName</body><body package="COClusterManagement">readFromIni: aCoastIniAccess 	"NOTE: frameClassName could be another string than my frameClassName"	"see Pragma #coastFormerName:"	| slots |	key := aCoastIniAccess 				category: self iniCategory				numberAt: '#frameKey'				ifAbsent: [ CoastError raiseSignal: 'error in index file: frame key missing' ].	slots := (aCoastIniAccess category: self iniCategory) keys reject: [: sn | sn = '#frameKey' ].	slots do: 		[: slotName | | slotKey |			slotKey := aCoastIniAccess 						category: self iniCategory						numberAt: slotName						ifAbsent: [ CoastError raiseSignal: 'error in index file: slot key missing' ].			slotDict at: slotName asSymbol put: slotKey 		].	self buildInverseIndex</body><body package="COClusterManagement">writeToIni: aCoastIniAccess 	aCoastIniAccess 		category: self iniCategory		at: '#frameKey'		put: key.	slotDict keysAndValuesDo: 		[: slotName : skey |			aCoastIniAccess 				category: self iniCategory				at: slotName				put: skey 		]</body></methods><methods><class-id>COAST.CatCSFrameSlotIndex</class-id> <category>marshalling</category><body package="COClusterManagement">marshallArgumentBinaryTo: stream 	stream nextCoastStringPut: self frameClassName.	stream nextOptimized32Put: slotArray size.	slotArray do: 		[: slotNameOrNil |			slotNameOrNil notNil 				ifTrue: [ stream nextCoastStringPut: slotNameOrNil ]				ifFalse: [ stream nextCoastStringPut: ''	"only possible with manual edited index.ini" ]		].</body></methods><methods><class-id>COAST.CatCSFrameSlotIndex</class-id> <category>indexing</category><body package="COClusterManagement">buildInverseIndex	| maxKey |	maxKey := slotDict values inject: 0 into: [: max : next | max max: next ].	slotArray := Array new: maxKey.	slotDict keysAndValuesDo: [: slotname : slotkey | slotArray at: slotkey put: slotname ].</body></methods><methods><class-id>COAST.CatCSFrameSlotIndex</class-id> <category>initialize</category><body package="COClusterManagement">initialize	slotArray := #().	slotDict := Dictionary new.</body></methods><methods><class-id>COAST.CatCSFrameSlotIndex</class-id> <category>copying</category><body package="COClusterManagement">postCopy  	slotDict := slotDict copy.	slotArray := slotArray copy.</body></methods><methods><class-id>COAST.CatCSFrameSlotIndex class</class-id> <category>instance creation</category><body package="COClusterManagement">frameClassSymbol: aSymbol classNameManager: aNameSpaceManager frameClassIndex: frameClassIndex 	^ ( self basicNew )		frameClassSymbol: aSymbol;		frameClass: ( aNameSpaceManager classForCoastClassName: aSymbol asString );		frameClassIndex: frameClassIndex;		initialize;		yourself</body><body package="COClusterManagement">new	^ self shouldNotImplement</body></methods><methods><class-id>COAST.CatCSFrameSlotIndex class</class-id> <category>marshaling</category><body package="COClusterManagement">unmarshallBinaryFrom: stream classNameManager: aNameSpaceManager frameClassIndex: frameClassIndex	| frameClassName size inst statusResponse |	statusResponse := CoastStatusResponse fromStream: stream.	statusResponse  ok ifFalse: [ CoastError raiseSignal: statusResponse message ].	frameClassName := stream nextCoastString.	size := stream nextOptimized32.	inst := self frameClassSymbol: frameClassName asSymbol classNameManager: aNameSpaceManager frameClassIndex: frameClassIndex.	1 to: size		do: 		[: i | | slotName |			slotName := stream nextCoastString.			inst addIndexForSlot: ( slotName isEmpty 						ifTrue: [ nil ]						ifFalse: [ slotName asSymbol ])		].	^ inst</body></methods><methods><class-id>COAST.CatBFSegmentedFile</class-id> <category>initialize-release</category><body package="COBlockFileSystem">blockFileSystem: aCatBFBlockFileSystem	blockFileSystem := aCatBFBlockFileSystem</body><body package="COBlockFileSystem">initialize	segmentsModifiedIndex := nil.	isLocked := false.</body><body package="COBlockFileSystem">openFile: aFilename 	| str |	str := self readOnly 			ifTrue: [ aFilename readStream ]			ifFalse: [ aFilename readWriteStream ].	self stream: str binary.</body><body package="COBlockFileSystem">readOnly	^ self blockFileSystem readOnly</body><body package="COBlockFileSystem">stream: aStream 	self subclassResponsibility</body></methods><methods><class-id>COAST.CatBFSegmentedFile</class-id> <category>marshalling</category><body package="COBlockFileSystem">close	self write.	self unlockStream.	stream close.	stream := nil</body><body package="COBlockFileSystem">corruptSegmentFileError: errorString 	self blockFileSystem markAsReadOnly.	CatBFCorruptSegmentFileError raiseSignal: errorString.</body><body package="COBlockFileSystem">create	self writeHeaderBlock.	self segmentsModifiedIndex: 1.	self write</body><body package="COBlockFileSystem">open	self subclassResponsibility</body><body package="COBlockFileSystem">readHeader	" read file header. returns the number of segments "	[ | numberOfSegments majorVersion minorVersion modNum blockListVersion |		self magicNumber = stream nextUnsigned64 ifFalse: [ self corruptSegmentFileError: 'Magic number expected' ].		numberOfSegments := stream nextUnsigned64.		majorVersion := stream next.		minorVersion := stream next.		blockListVersion := CoastVersion major: majorVersion minor: minorVersion.		blockListVersion = blockFileSystem version ifFalse: 			[	self corruptSegmentFileError: 						blockFileSystem displayString , ': Last save failed, block file has version ' , 						blockFileSystem version printString , ', ' , self shortDescription , ' has version ' , blockListVersion printString			].		modNum := stream nextUnsigned32.		modNum = blockFileSystem modificationNumber ifFalse: 			[	self corruptSegmentFileError: 						blockFileSystem displayString , ': Last save failed, block file has modification number ' , 						blockFileSystem modificationNumber printString , ', ' , 						self shortDescription , ' has modification number ' , modNum printString			].		"lastModified" 		Timestamp fromSeconds: stream nextUnsigned32.		" position to begin of data "		stream position: self headerSize.		^ numberOfSegments	] on: EndOfStreamNotification		do: 		[: ex |			 self corruptSegmentFileError: 'Unexpected end of stream while reading ' , self shortDescription , ': ' , ex description		]</body><body package="COBlockFileSystem">write	self subclassResponsibility</body><body package="COBlockFileSystem">writeHeader	| version |	stream position: 0.	stream nextUnsigned64Put: self magicNumber.	stream nextUnsigned64Put: self numberOfSegments.	version := blockFileSystem version.	stream nextPut: version major.	stream nextPut: version minor.	stream nextUnsigned32Put: blockFileSystem modificationNumber.	stream nextUnsigned32Put: blockFileSystem lastModification asSeconds.	stream flush.</body><body package="COBlockFileSystem">writeHeaderBlock	" create an empty header block "	stream position: 0.	stream next: self headerSize put: 0.</body></methods><methods><class-id>COAST.CatBFSegmentedFile</class-id> <category>private</category><body package="COBlockFileSystem">headerSize	" size of the header block size"	" do not overwrite "	^ self class headerSize</body><body package="COBlockFileSystem">magicNumber	self subclassResponsibility</body><body package="COBlockFileSystem">segmentsDo: aBlock	self subclassResponsibility</body><body package="COBlockFileSystem">shortDescription	self subclassResponsibility</body></methods><methods><class-id>COAST.CatBFSegmentedFile</class-id> <category>accessing</category><body package="COBlockFileSystem">blockFileSystem	^ blockFileSystem</body><body package="COBlockFileSystem">isOpen	^  stream notNil</body><body package="COBlockFileSystem">numberOfDirtySegments	self subclassResponsibility</body><body package="COBlockFileSystem">numberOfSegments	self subclassResponsibility</body><body package="COBlockFileSystem">segmentsModifiedIndex: newIndex 	segmentsModifiedIndex := newIndex isNil 			ifTrue: 			[	"reset"				nil			]			ifFalse: 			[	"save the min index for all following segments must be stored"				segmentsModifiedIndex isNil 					ifTrue: [ newIndex ]					ifFalse: [ newIndex min: segmentsModifiedIndex ]			]</body></methods><methods><class-id>COAST.CatBFSegmentedFile</class-id> <category>upgrade</category><body package="COBlockFileSystem">upgrade	" this is the current version "</body></methods><methods><class-id>COAST.CatBFSegmentedFile</class-id> <category>locking</category><body package="COBlockFileSystem">lockStream	( self isOpen and: [ isLocked not ]) 		ifFalse: [ ^ self ].	[	" Voodoo: ohne next gibt es Fehler beim Unlock (position: 1 ist nicht gleichwertig!) "		stream position: 0.		stream next.		stream ioConnection ifNotNil: [ : io | io input lock: true for: self headerSize ].		stream position: 0.		isLocked := true	] on: Error do: [: ex | CatBFLockError raiseSignal: 'Could not force lock: ' , ex description ].</body><body package="COBlockFileSystem">unlockStream	( self isOpen and: [ isLocked ]) 		ifFalse: [ ^ self ].	[	" Voodoo: ohne next gibt es Fehler beim Unlock (position: 1 ist nicht gleichwertig!) "		stream position: 0.		stream next.		stream ioConnection ifNotNil: [ : io | io input lock: false for: self headerSize ].		stream position: 0.		isLocked := false	] on: Error do: [: ex | CatBFLockError raiseSignal: 'Could not unlock: ' , ex description ].</body></methods><methods><class-id>COAST.CatBFSegmentedFile class</class-id> <category>accessing</category><body package="COBlockFileSystem">headerSize	" size of the header block size"	" fixed size block "	^ 4096</body><body package="COBlockFileSystem">headerUsedSize	" actual bytes used for header info "	^ 26</body></methods><methods><class-id>COAST.CatBFSegmentedFile class</class-id> <category>instance creation</category><body package="COBlockFileSystem">new	^ super new initialize</body><body package="COBlockFileSystem">newOn: aReadWriteStream blockFileSystem: aCatBFBlockFileSystem	^ ( self new )		blockFileSystem: aCatBFBlockFileSystem;		stream: aReadWriteStream;		yourself</body><body package="COBlockFileSystem">newOnFile: aFilename blockFileSystem: aCatBFBlockFileSystem	^ ( self new )		blockFileSystem: aCatBFBlockFileSystem;		openFile: aFilename;		yourself</body></methods><methods><class-id>COAST.CatBFStream</class-id> <category>testing</category><body package="COBlockFileSystem">atEnd	^ currentBlock isNil</body><body package="COBlockFileSystem">isReadable	^ false</body><body package="COBlockFileSystem">isWritable	^ false</body></methods><methods><class-id>COAST.CatBFStream</class-id> <category>character/binary</category><body package="COBlockFileSystem">binary	" always binary, so nevermind "</body><body package="COBlockFileSystem">isBinary	^ true</body><body package="COBlockFileSystem">isText	^ self isBinary not</body></methods><methods><class-id>COAST.CatBFStream</class-id> <category>private</category><body package="COBlockFileSystem">blockFileSystem 	^ blockFileSystem</body><body package="COBlockFileSystem">buffer	^ collection</body><body package="COBlockFileSystem">bufferPosition	" current position within the buffer "	^ blockMinPosition notNil 		ifTrue: [ position - blockMinPosition + 1 ]		ifFalse: [ position + 1 ]</body><body package="COBlockFileSystem">closedStreamError	self error: 'Stream ', self printString, ' is not open'</body><body package="COBlockFileSystem">currentBlock	" currently accessed block "	^ currentBlock</body><body package="COBlockFileSystem">currentBlock: aCatBFBlock 	currentBlock = aCatBFBlock ifTrue: [ ^self ].	self writeBackCurrentBlock.	currentBlock := aCatBFBlock.	writeLimit := 0.	aCatBFBlock notNil 		ifTrue: 		[	" store the position of the first byte of the block, because it is used very frequently "			blockMinPosition := aCatBFBlock minPosition.			self fillBlockBuffer 		]		ifFalse: 		[	blockMinPosition := nil.			readLimit := 0 		]</body><body package="COBlockFileSystem">file 	^ file</body><body package="COBlockFileSystem">fillBlockBuffer	" fill the buffer for the current block "	self subclassResponsibility</body><body package="COBlockFileSystem">writeBackCurrentBlock	" write back the header of there current block (only if needed)"	self subclassResponsibility</body></methods><methods><class-id>COAST.CatBFStream</class-id> <category>initialize-release</category><body package="COBlockFileSystem">blockFileSystem: aCatBfBlockFileSystem file: aCatBFFile buffer: aByteArray	bufferSize := aCatBfBlockFileSystem blockDataSize.	bufferSize = aByteArray size 		ifFalse: [ self error: 'Buffer size (', aByteArray size printString, ') does not match block size (', bufferSize printString, ')' ].	blockFileSystem := aCatBfBlockFileSystem.	file := aCatBFFile.	readLimit := 0.	writeLimit := 0.	collection := aByteArray.	isOpen := true.	self position: 0.</body><body package="COBlockFileSystem">deregister	self subclassResponsibility</body><body package="COBlockFileSystem">finalize	self closeNoWriteBack</body></methods><methods><class-id>COAST.CatBFStream</class-id> <category>status</category><body package="COBlockFileSystem">close	self isOpen ifFalse: [ ^ self ].	self blockFileSystem exclusiveUseDo: 		[	self writeBackCurrentBlock.			self deregister		].	isOpen := false.	currentBlock := nil.	collection := nil.</body><body package="COBlockFileSystem">closeNoWriteBack	self isOpen 		ifFalse: [ ^ self ].	self blockFileSystem exclusiveUseDo: [ self deregister ].	isOpen := false.	currentBlock := nil.	collection := nil.</body><body package="COBlockFileSystem">closed	" for compatibility "	^ self isOpen not</body><body package="COBlockFileSystem">isOpen	^ isOpen</body></methods><methods><class-id>COAST.CatBFStream</class-id> <category>unsupported</category><body package="COBlockFileSystem">contents	self notSupportedError</body><body package="COBlockFileSystem">notSupportedError	self error: thisContext sender printString, ' is not supported by this stream'</body><body package="COBlockFileSystem">on: aCollection 	self notSupportedError</body></methods><methods><class-id>COAST.CatBFStream</class-id> <category>accesssing</category><body package="COBlockFileSystem">flush	self writeBackCurrentBlock.</body></methods><methods><class-id>COAST.CatBFStream</class-id> <category>positioning</category><body package="COBlockFileSystem">position: anInteger	" set the read/write position "	| blk |	position := anInteger max: 0.	(currentBlock isNil or: [ currentBlock minPosition &gt; position or: [ currentBlock maxPosition &lt; position ]])		ifTrue: [ 			blk := self blockFileSystem getBlockForFile: self file position: position.			blk notNil				ifTrue: [					position &gt; blk maxPosition						ifTrue: [ ^ self positionOutOfBoundsError: anInteger ].					self currentBlock: blk.				]				ifFalse: [					position &gt; 0						ifTrue: [ self positionOutOfBoundsError: anInteger ]				].		].</body></methods><methods><class-id>COAST.CatBFStream class</class-id> <category>instance creation</category><body package="COBlockFileSystem">blockFileSystem: aCatBfBlockFileSystem file: aCatBFFile buffer: aByteArray	^ self new		blockFileSystem: aCatBfBlockFileSystem file: aCatBFFile buffer: aByteArray;		yourself</body></methods><methods><class-id>COAST.CatBFDirectorySegment</class-id> <category>private</category><body package="COBlockFileSystem">basicFileAt: fileNumber put: aCatBFFile 	( self fileNumberExists: fileNumber ) 		ifTrue: [ ^ self error: 'File "' , aCatBFFile displayString , '" was already added to the directory' ].	filesDictionary at: fileNumber put: aCatBFFile.	maxKey &gt; fileNumber ifFalse: [ maxKey := fileNumber ]</body></methods><methods><class-id>COAST.CatBFDirectorySegment</class-id> <category>marshalling</category><body package="COBlockFileSystem">directoryDo: aBlock 	" evaluate the block with all filenumbers and files "	^ filesDictionary keysAndValuesDo: aBlock</body><body package="COBlockFileSystem">optimizeUnmodifed	self isResolved 		ifFalse: [ ^ self ].	dirty 		ifTrue: 		[	" Directory segment is modified and cannot be optimized"			^ self		].	filesDictionary do: [: file | file isImmutable: true ].	numFiles := filesDictionary size.	filesDictionary := nil.</body><body package="COBlockFileSystem">readBodyFrom: aStream 	filesDictionary := "CatCOIntegerKey"Dictionary new: (numFiles * 1.4) truncated.	numFiles timesRepeat: 		[ | file |			file := CatBFFile readFrom: aStream.			self basicFileAt: file fileNumber put: file		].	numFiles := nil</body><body package="COBlockFileSystem">readHeaderFrom: aStream 	maxKey := aStream nextUnsigned64.	numFiles := aStream nextUnsigned32.	filesDictionary := nil.	dirty := false</body><body package="COBlockFileSystem">writeOn: aStream for: blockFileSystem	| oldPos isClean |	oldPos := aStream position.	aStream nextUnsigned64Put: maxKey.	aStream nextUnsigned32Put: filesDictionary size.	isClean := true.	filesDictionary keysAndValuesDo: 		[: fileNum : file |			" blob uploads etc. may still have open streams "			(isClean and: [ (blockFileSystem currentWriteStreamOnFile: file) notNil ])				ifTrue: [ isClean := false ].			file writeOn: aStream			" this instance of the file must not be modified anymore "		].	aStream next: self class storageSize + oldPos - aStream position put: 0.	isClean ifTrue: [ dirty := false ].</body></methods><methods><class-id>COAST.CatBFDirectorySegment</class-id> <category>accessing</category><body package="COBlockFileSystem">dirty	^ dirty</body><body package="COBlockFileSystem">dirty: boolean 	dirty := boolean</body><body package="COBlockFileSystem">fileAt: fileNumber put: aCatBFFile 	self basicFileAt: fileNumber put: aCatBFFile.	dirty := true.</body><body package="COBlockFileSystem">fileNumberExists: fileNumber 	^ filesDictionary includesKey: fileNumber</body><body package="COBlockFileSystem">getFile: fileNumber 	^ filesDictionary at: fileNumber ifAbsent: [ nil ]</body><body package="COBlockFileSystem">highestFileNumber	" highest file number of regular files "	| highest |	highest := 0.	self directoryDo: [: i : file | highest := highest max: i ].	^ highest</body><body package="COBlockFileSystem">isFull	^ self numberOfFiles &gt;= self maxNumberOfFiles</body><body package="COBlockFileSystem">isResolved	^ filesDictionary notNil</body><body package="COBlockFileSystem">maxKey	^ maxKey</body><body package="COBlockFileSystem">maxNumberOfFiles	^ ( self class storageSize - self class headerSize ) // CatBFFile maxStructSize</body><body package="COBlockFileSystem">numberOfFiles	^ filesDictionary notNil 		ifTrue: [ filesDictionary size ]		ifFalse: [ numFiles ]</body><body package="COBlockFileSystem">removeFileNumber: fileNumber 	dirty := true.	^ filesDictionary removeKey: fileNumber		ifAbsent: [ self error: 'File "' , fileNumber displayString , '" was not added to the directory' ]</body><body package="COBlockFileSystem">splittedSegmentBefore	" split segment and move files with lower filenumber to the new segment "	" maxKey of this segment remains the same "	| newSegment sortedFileNumbers |	newSegment := self species new.	sortedFileNumbers := filesDictionary keys asSortedCollection.	1 to: self numberOfFiles // 2 do: [ : i |		| fileToMove |		fileToMove := filesDictionary removeKey: (sortedFileNumbers at: i).		newSegment fileAt: fileToMove fileNumber put: fileToMove.	].	dirty := true.	^ newSegment</body></methods><methods><class-id>COAST.CatBFDirectorySegment</class-id> <category>printing</category><body package="COBlockFileSystem">printOn: aStream 	super printOn: aStream.	aStream nextPut: $(.	maxKey printOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>COAST.CatBFDirectorySegment</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	filesDictionary :=" CatCOIntegerKey"Dictionary new.	maxKey := 0.	dirty := true</body></methods><methods><class-id>COAST.CatBFDirectorySegment class</class-id> <category>accessing</category><body package="COBlockFileSystem">errorSignal	^ CatBFError</body><body package="COBlockFileSystem">headerSize	^ 12	"8 maxKey + 4 numerOfElements"</body><body package="COBlockFileSystem">storageSize	^ 4096</body></methods><methods><class-id>COAST.CatBFDirectorySegment class</class-id> <category>instance creation</category><body package="COBlockFileSystem">new	^ super new initialize</body><body package="COBlockFileSystem">readHeaderFrom: aStream 	^ ( self new )		readHeaderFrom: aStream;		yourself</body></methods><methods><class-id>COAST.CatBFLockError class</class-id> <category>testing</category><body package="COBlockFileSystem">mayResume	^ true</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>private</category><body package="COBlockFileSystem">allFilenames	^ Array with: self blockFilename with: self freeListFilename with: self directoryFilename</body><body package="COBlockFileSystem">allFilesSortedByBlockNumber	| filesToScan |	filesToScan := OrderedCollection new: self numberOfFiles.	self filesDo: [: bfsFile | filesToScan add: bfsFile ].	^ filesToScan sortedBy: [: file | file firstBlockNumber ].</body><body package="COBlockFileSystem">allIndexFilenames	^ Array with: self freeListFilename with: self directoryFilename</body><body package="COBlockFileSystem">allocateBufferForFile: aCatBFFile 	| buff buffs |	^ ( self buffers includesKey: aCatBFFile ) 		ifTrue: 		[	" should not happen "			ByteArray new: self blockDataSize		]		ifFalse: 		[	buff := ( buffs := self availableBuffers ) notEmpty 					ifTrue: [ buffs removeFirst atAllPut: 0; yourself]					ifFalse: [ ByteArray new: self blockDataSize ].			self buffers at: aCatBFFile put: buff		]</body><body package="COBlockFileSystem">assertIsNotOpen	self isOpen ifTrue: [ ^ self error: 'Block file system is open' ].</body><body package="COBlockFileSystem">assertIsOpen	self isOpen ifFalse: [ ^ self error: 'Block file system is not open' ].</body><body package="COBlockFileSystem">availableBuffers	availableBuffers isNil ifTrue: [ availableBuffers := OrderedCollection new ].	^ availableBuffers</body><body package="COBlockFileSystem">blockFilenameExtension	^ '.cbf'</body><body package="COBlockFileSystem">buffers	buffers isNil ifTrue: [ buffers := Dictionary new ].	^ buffers</body><body package="COBlockFileSystem">checkIsValidBlockNumber: blockNumber 	( blockNumber &lt; 1 or: [ self numberOfBlocks &lt; blockNumber ]) ifTrue: 		[	self error: 'Illegal block number ' , blockNumber printString , ', must be between 1 and ' , self numberOfBlocks printString		].</body><body package="COBlockFileSystem">consistentStateForCopyDo: aBlock 	^ self exclusiveUseDo: 		[	self isOpen 				ifTrue: 				[	self writeBack.					self unlockAllFiles.					[						aBlock value.					] ensure: [ 						self lockAllFiles					].				]				ifFalse: [ aBlock value ]		]</body><body package="COBlockFileSystem">corruptBlockFileError: aString	self error: 'Block file "', self blockFilename asString, '" is corrupt: ', aString</body><body package="COBlockFileSystem">createOrOverwriteIndexFiles	| dirStream freeStream |	dirStream := self directoryFilename readWriteStream binary.	directory := self directoryClass newOn: dirStream blockFileSystem: self.	directory create.	freeStream := self freeListFilename readWriteStream binary.	freeList := self freeBlockListClass newOn: freeStream blockFileSystem: self.	freeList create.</body><body package="COBlockFileSystem">emergencyRemoveAllFiles	self exclusiveUseDo: [		self privateEmergencyClose.		self privateDeleteCheckAccess: false.	].</body><body package="COBlockFileSystem">enablePatchModeWhile: patchBlock	| oldPatchMode |	oldPatchMode := patchMode.	patchMode := true.	^ patchBlock ensure: [ patchMode := oldPatchMode ].</body><body package="COBlockFileSystem">ensureClosedWhile: aBlock 	self isBackgroundCopyActive 		ifTrue: [ self error: 'BFS ' , self displayString , ' cannot be closed: volume is currently being copied' ].	self hasOpenStreams 		ifTrue: [ self error: 'BFS ' , self displayString , ' cannot be closed: streams are still open' ].	^ self exclusiveUseDo: 		[	self isOpen 				ifTrue: 				[						[	self close.						aBlock value					] ensure: [ self open ]				]				ifFalse: [ aBlock value ]		]</body><body package="COBlockFileSystem">ensureOpenWhile: aBlock 	^ self isOpen 		ifTrue: [ aBlock value ]		ifFalse: 		[				[	self open.				aBlock value			] ensure: [ self close ]		]</body><body package="COBlockFileSystem">ensureWorkingDirectory	| dir |	( dir := self workingDirectory ) exists 		ifTrue: 		[ "trau schau wem ..."			| fn |			fn := dir construct: 'writeTest'.			fn writeStream close.			fn delete		]		ifFalse: [ dir makeFullDirectory ].</body><body package="COBlockFileSystem">exclusiveUseDo: aBlock	^ accessLock critical: aBlock</body><body package="COBlockFileSystem">generateUniqueID	^ UUIDGenerator default next asString.</body><body package="COBlockFileSystem">indexIniFile	^ self getOrCreateFile: CatBFFile indexIniFileNumber fileType: CatBFFile fileTypeIndexIni</body><body package="COBlockFileSystem">ioMode	^ #readWrite</body><body package="COBlockFileSystem">logProgress: i of: max	| stepSize |	stepSize := 5. " log every &gt;= 5% progress"	i &gt; 1 ifTrue: [		((i*100) // (stepSize * max)) - ((i-1)*100 // (stepSize * max))  &gt; 0			ifTrue: [				CoastLog log: ( i * 100 / max ) rounded printString , '% done'			].	].</body><body package="COBlockFileSystem">numberOfBlocksOfFileSized: anInteger	" even empty files allocate a single block  "	^ (anInteger / self blockDataSize) ceiling max: 1</body><body package="COBlockFileSystem">openBlockFileStreamLocked: lock 	bfsFileHandle := IOAccessor openFileNamed: self blockFilename direction: ( IOAccessor perform: self ioMode ) creation: IOAccessor mayCreate.	lock 		ifTrue: [ self lockBFS ].</body><body package="COBlockFileSystem">osProcessID		^ OSHandle currentProcessID</body><body package="COBlockFileSystem">privateBackgroundCopyDone: copyInfo 	self removeCopyInfo: copyInfo.	backgroundCopyInfos isEmpty		ifTrue: [			CoastLog log: 'All background copy operations finished'.			self lockBFS.		].	copyInfo signalCopyDone.</body><body package="COBlockFileSystem">privateEmergencyClose	self markAsReadOnlyWhile: 		[	self privateEmergencyReleaseLock.			self closeBlockFileStream.			self closeIndexFiles		].</body><body package="COBlockFileSystem">privateEmergencyReleaseLock	lockFile notNil 		ifTrue: 		[				[ lockFile releaseLockStream ] 				on: Error				do: 				[: ex |					" schade, aber nicht so wichtig "				].			lockFile := nil		].</body><body package="COBlockFileSystem">privateFiles	^ self exclusiveUseDo: [		self assertIsOpen.		self directory privateFiles	].</body><body package="COBlockFileSystem">releaseLockFile	" additional lock file. the block file is locked, too, but a separate lock makes administration easier "	lockFile notNil		ifTrue: [ 			lockFile releaseLock.			lockFile hasLock ifTrue: [ CoastLog logWarning: 'Could not release lock file of ', self displayString ].			lockFile := nil		].</body><body package="COBlockFileSystem">removeAllFiles	| wipeBlock |	wipeBlock :=	[	self delete.		self create	].	^ self exclusiveUseDo: 		[	self isOpen 				ifTrue: 				[						[	self close.						wipeBlock value					] ensure: [ self open ]				]				ifFalse: [ wipeBlock value ]		]</body><body package="COBlockFileSystem">reset	" forget all information about stored data "	self isOpen 		ifTrue: [ ^ self error: 'Cannot reset, block file system is open' ].	self lastModification: Timestamp now.	self modificationNumber: 0.	self version: self class version.	self blockSize: self class defaultBlockSize.	self numberOfBlocks: 0.	self processID: self notInUseID.	self nextClusterID: 0.	self uniqueVolumeID: String new.	freeList := nil.	directory := nil.</body><body package="COBlockFileSystem">updateNextClusterID	| ncid storedNextClusterID |	self assertIsOpen.	ncid := self directory highestFileNumber + 1.	ncid &gt; (storedNextClusterID := self nextClusterID)		ifTrue: [ 			storedNextClusterID &gt; 0 ifTrue: [ CoastLog logWarning: 'Corrected next cluster ID (', self nextClusterID printString, ' -&gt; ', ncid printString, ')'. ].			self nextClusterID: ncid		].</body><body package="COBlockFileSystem">volumeIniFile	^ self getOrCreateFile: CatBFFile volumeIniFileNumber fileType: CatBFFile fileTypeVolumeIni</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>accessing</category><body package="COBlockFileSystem">allIDsDo: aBlock 	^ self exclusiveUseDo: 		[	self assertIsOpen.			self directory allIDsDo: aBlock		]</body><body package="COBlockFileSystem">blobIDs	" all IDs of blob files"	^ self exclusiveUseDo: [		self assertIsOpen.		self directory blobIDs	].</body><body package="COBlockFileSystem">blockDataSize	" max. number of bytes that can be stored in a block "	^ self blockSize - CatBFBlock headerSize</body><body package="COBlockFileSystem">blockFilename	^ (self coreFilename asString, self blockFilenameExtension) asFilename</body><body package="COBlockFileSystem">blockSize	" Size (in bytes) of each block  "	^ blockSize</body><body package="COBlockFileSystem">blockSize: a32BitInteger 	" Size (in bytes) of each block  "	| minBlockSize |	self isOpen		ifTrue: [ ^ self error: 'Block size cannot be changed, block file system is open' ].	minBlockSize := self class minBlockSize.	a32BitInteger &lt; minBlockSize		ifTrue: [ ^ self error: 'Block file size must be &gt;= ', minBlockSize printString, ' bytes' ].	blockSize := a32BitInteger</body><body package="COBlockFileSystem">blockUntilBackupIsDone	backupCopyInfo ifNotNil: [: copyInfo | copyInfo blockUntilCopyIsDone ].</body><body package="COBlockFileSystem">clusterAndBlobIDs	^ self exclusiveUseDo: [		self assertIsOpen.		self directory clusterAndBlobIDs	].</body><body package="COBlockFileSystem">clusterIDs	" all IDs of cluster files"	^ self exclusiveUseDo: [		self assertIsOpen.		self directory clusterIDs	]</body><body package="COBlockFileSystem">compress	| tempCoreName tempBFS originalFilenames tempFilenames msg oldFileSizeString |	CoastLog log: 'Compressing ' , self displayString.	oldFileSizeString := self blockFilename asFilename fileSize coastShortByteSizePrintString.	self ensureClosedWhile: 		[	tempCoreName := self coreName , '-compress-' , Time millisecondClockValue printString.			tempBFS := self class directory: self workingDirectory name: tempCoreName.			originalFilenames := self allFilenames asOrderedCollection.			tempFilenames := originalFilenames collect: [: source | self workingDirectory construct: tempCoreName , source extension ].			CoastLog log: 'Copying to temporary BFS: ' , tempBFS displayString.			[	tempBFS create.				tempBFS growSizeInBytes: 1024*1024.				self copyToBFS: tempBFS.				tempBFS close			] ifCurtailed: 				[	tempBFS close.					tempBFS delete				].			tempBFS exists 				ifTrue: 				[	CoastLog log: 'Renaming temporary files'.					self delete.					tempFilenames with: originalFilenames do: [: temp : original | temp renameTo: original ]				]				ifFalse: [ CoastLog log: 'Copy failed' ]		].	CoastLog 		log: ( msg := 'Compress finished. Block file size: ' , self blockFilename asFilename fileSize coastShortByteSizePrintString , ' (old size: ' 					, oldFileSizeString , ')' ).	^ msg</body><body package="COBlockFileSystem">coreFilename	" Filename without extension"	^ self workingDirectory construct: coreName</body><body package="COBlockFileSystem">coreName	^ coreName</body><body package="COBlockFileSystem">directoryFilename	^ ( self coreFilename asString , self directoryFilenameExtension ) asFilename</body><body package="COBlockFileSystem">filesDo: aBlock	^ self exclusiveUseDo: [		self assertIsOpen.		self directory filesDo: aBlock	].</body><body package="COBlockFileSystem">freeListFilename	^ ( self coreFilename asString , self freeListFilenameExtension ) asFilename</body><body package="COBlockFileSystem">getNextBlockFromSeekPosition	^ self exclusiveUseDo: [ self privateGetNextBlockFromSeekPosition ]</body><body package="COBlockFileSystem">growSize	" number of blocks that are allocated when growing.	Runtime parameter, is not stored within the file! "	^ ((self growSizeInBytes // self blockSize) max: 10)</body><body package="COBlockFileSystem">growSizeInBytes	" number of bytes that are allocated when growing.	Runtime parameter, is not stored within the file! "	^ growSizeInBytes ifNil: [ growSizeInBytes := self class defaultGrowBytesSize ]</body><body package="COBlockFileSystem">growSizeInBytes: anInteger	" number of bytes that are allocated when growing.	Runtime parameter, is not stored within the file! "	growSizeInBytes := anInteger</body><body package="COBlockFileSystem">highestFileNumber	^ self exclusiveUseDo: [		self assertIsOpen.		self directory highestFileNumber	].</body><body package="COBlockFileSystem">indexIniAccess	^ self iniAccessOnFile: self indexIniFile</body><body package="COBlockFileSystem">indexIniAccess: aCoastIniAccess	self writeIniAccess: aCoastIniAccess toFile: self indexIniFile</body><body package="COBlockFileSystem">isBackgroundCopyActive	^ backgroundCopyInfos notEmpty</body><body package="COBlockFileSystem">isBackupActive	^ backupCopyInfo notNil and: [ backupCopyInfo isCopyActive ]</body><body package="COBlockFileSystem">largestClusterDo: block maxCount: maxCount 	self exclusiveUseDo: [		 directory largestClusterDo: block maxCount: maxCount	].</body><body package="COBlockFileSystem">lastModification	" Timestamp of the last modification "	^ lastModification</body><body package="COBlockFileSystem">maxKey	^ self exclusiveUseDo: [		self assertIsOpen.		self directory maxKey	].</body><body package="COBlockFileSystem">modificationNumber	" Number (increasing) of the last modification "	^ modificationNumber</body><body package="COBlockFileSystem">nextClusterID	^ nextClusterID ifNil: [ 0 ]</body><body package="COBlockFileSystem">nextClusterID: a64BitInteger	nextClusterID := a64BitInteger</body><body package="COBlockFileSystem">numberOfBlocks	" number of allocated blocks "	^ numberOfBlocks</body><body package="COBlockFileSystem">numberOfFiles	" number of stored files "	^ self exclusiveUseDo: [		self assertIsOpen.		self directory numberOfFiles	].</body><body package="COBlockFileSystem">numberOfFragments: bfsFile 	| block count |	bfsFile fileSize &lt;= self blockDataSize ifTrue: [ ^ 1 ].	count := 1.	block := self getBlock: bfsFile firstBlockNumber.	[ block isLastBlock not ] whileTrue: 		[	block nextBlockNumber = ( block blockNumber + 1 ) ifFalse: [ count := count + 1 ].			block := self getBlock: block nextBlockNumber		].	^ count</body><body package="COBlockFileSystem">numberOfFreeBlocks	" number of free blocks"	^ self freeList numberOfFreeBlocks</body><body package="COBlockFileSystem">numberOfUsedBlocks	" number of used blocks "	^ self numberOfBlocks - self numberOfFreeBlocks</body><body package="COBlockFileSystem">optimizeInMemory	self exclusiveUseDo: [ directory optimizeUnmodifed ]</body><body package="COBlockFileSystem">privateGetNextBlockFromSeekPosition	| blockNum |	seekPosition &lt;= self blockFileHeaderSize 		ifTrue: 		[	" not in the data area "			^ nil		].	blockNum := ( seekPosition - self blockFileHeaderSize - 1 ) // self blockSize + 2.	blockNum &gt; numberOfBlocks 		ifTrue: [ ^ nil ].	( self freeList isFree: blockNum ) 		ifTrue: [ ^ nil ].	^ self getBlock: blockNum</body><body package="COBlockFileSystem">totalBlockSize	^ self numberOfBlocks * self blockSize</body><body package="COBlockFileSystem">totalFileSize	| totalFileSize |	totalFileSize := 0.	self exclusiveUseDo: [		self directory directoryDo: [ : i : file |			totalFileSize := totalFileSize + file fileSize		].	].	^ totalFileSize</body><body package="COBlockFileSystem">uniqueVolumeID	" 'unique' string (well, sort of) "	| s |	s := uniqueVolumeID.	^ (s notNil and: [ s notEmpty ])		ifTrue: [ s ]		ifFalse: [ nil ]</body><body package="COBlockFileSystem">uniqueVolumeID: aString	" 'unique' string (well, sort of) "	uniqueVolumeID := aString</body><body package="COBlockFileSystem">version	" COAST version (= file system version)"	^ version</body><body package="COBlockFileSystem">version: aCoastVersion	" COAST version (= file system version)"	version := aCoastVersion</body><body package="COBlockFileSystem">volumeIniAccess	^ self iniAccessOnFile: self volumeIniFile</body><body package="COBlockFileSystem">volumeIniAccess: aCoastIniAccess	self writeIniAccess: aCoastIniAccess toFile: self volumeIniFile</body><body package="COBlockFileSystem">workingDirectory	" directory (Filename) that holds the block file, index file and possibly other files "	^ workingDirectory</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>constants</category><body package="COBlockFileSystem">blockFileHeaderEnd	" 'HeadEnd' coastAs64BitNumber "	^ 16r48656164456E64</body><body package="COBlockFileSystem">blockFileHeaderSize	" size of the header block size"	" fixed size block "	^ 65536</body><body package="COBlockFileSystem">blockFileMagicNumber	" 'CoastBF' coastAs64BitNumber "	^ 16r436F6173744246</body><body package="COBlockFileSystem">endOfFileBlockNumber	^ 0</body><body package="COBlockFileSystem">indexFileEndMagicNumber	" 'CoastEIF' coastAs64BitNumber"	^ 16r436F617374454946</body><body package="COBlockFileSystem">indexFileMagicNumber	" 'CoastIF' coastAs64BitNumber"	^ 16r436F6173744946</body><body package="COBlockFileSystem">notInUseID		^ 0</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>repair / recovery</category><body package="COBlockFileSystem">canBeCreated	self ensureWorkingDirectory.	^ self allFilenames allSatisfy: [: fn | fn exists not ]</body><body package="COBlockFileSystem">checkFileBlocks	| blockArray badFiles i numberOfFiles |	CoastLog log: 'Checking files'.	blockArray := Array new: self numberOfBlocks.	self assertIsOpen.	badFiles := OrderedCollection new.	i := 0.	numberOfFiles := self numberOfFiles.	self allFilesSortedByBlockNumber do: 		[: file |						[	file quickCheck.				self checkBlocksOfFile: file addTo: blockArray			] 				on: CatBFUnrecoverableError , CatBFBadBlockError				do: 				[: ex |					CoastLog logWarning: 'Found bad file ' , file fileNumber printString , ' (' , file displayString , '): ' , ex description.					badFiles add: file				].			i := i + 1.			self logProgress: i of: numberOfFiles		].	badFiles notEmpty 		ifTrue: 		[	" remove the file (this won't add the allocated blocks to the free list! but the files are bad, so finding all bad blocks would be impossible) "			CoastLog logWarning: 'Removing ' , badFiles size printString , ' bad files'.			badFiles do: [: badFile | self directory removeFile: badFile ]		].</body><body package="COBlockFileSystem">checkFiles	| i m |	CoastLog log: 'Checking directory'.	i := 0.	m := self numberOfFiles.	self directory filesDo: [ : file |		file quickCheck.		i := i + 1.		self logProgress: i of: m	].</body><body package="COBlockFileSystem">checkWriteProtection	self allFilenames do: 		[: fn |			fn isWritable 				ifFalse: [ ^ self error: '"' , fn asString , ' is write protected' ]		].</body><body package="COBlockFileSystem">deepCheck	self ensureOpenWhile: [		CoastLog log: 'Checking volume ', self shortDisplayString printString.		self quickCheck.		self checkFiles.		self checkFileBlocks.		CoastLog log: 'Volume check done '.	].</body><body package="COBlockFileSystem">quickBlockFileCheck	| expectedBlockFileSize actualBlockFileSize |	expectedBlockFileSize := self numberOfBlocks * self blockSize + self blockFileHeaderSize.	actualBlockFileSize := bfsFileHandle fileSize.	actualBlockFileSize &gt; expectedBlockFileSize ifTrue: 		[	self markAsReadOnly.			CatBFBlockFileTooLargeError raiseSignal: 'Block file size is larger than expected size'		].	actualBlockFileSize &lt; expectedBlockFileSize ifTrue: 		[	" data probably lost "			self error: 'Block file size is smaller than expected size'		].</body><body package="COBlockFileSystem">quickCheck	CoastLog log: 'Checking datafiles of ', self displayString.	self quickCheckDatafiles.	self ensureOpenWhile: [		CoastLog log: 'Checking block file'.		self quickBlockFileCheck.	].	CoastLog log: 'Quick check done'.</body><body package="COBlockFileSystem">quickCheckDatafiles	self allFilenames do: 		[: fn |			fn exists ifFalse: 				[ | errorClass |					self markAsReadOnly.					errorClass := self blockFilename = fn 							ifTrue: [ CatBFUnrecoverableError ]							ifFalse: [ CatBFCorruptSegmentFileError ].					^ errorClass raiseSignal: '"' , fn asString , ' does not exist'				]		].	self ensureWorkingDirectory.	self checkWriteProtection.</body><body package="COBlockFileSystem">quickRecover	self handleUnrecoverableErrorsWhile:  [ self recoverErrorsDetectedWith: [ self quickCheck ]]</body><body package="COBlockFileSystem">recover	self handleUnrecoverableErrorsWhile:  [ self recoverErrorsDetectedWith: [ self deepCheck ]]</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>repair / recovery - private</category><body package="COBlockFileSystem">badBlockError: string 	self markAsReadOnly.	CatBFBadBlockError raiseSignal: string.</body><body package="COBlockFileSystem">checkBlocksOfFile: aCatBFFile addTo: blockArray	| fileSize blockNum block fileBlockIndex |	fileSize := 0.	blockNum := aCatBFFile firstBlockNumber.	fileBlockIndex := 0.	[ blockNum = 0 ] whileFalse: [		| otherFileNumber |		blockNum &gt; blockArray size			ifTrue: [  self badBlockError: 'Illegal block number ', blockNum printString, ' used by file ', aCatBFFile fileNumber printString ].		(otherFileNumber := blockArray at: blockNum) notNil			ifTrue: [ 				otherFileNumber = aCatBFFile fileNumber					ifTrue: [ self badBlockError: 'Block ', blockNum printString, ' is used twice by file ', aCatBFFile displayString ]					ifFalse: [ self badBlockError: 'Block ', blockNum printString, ' is used by files ', aCatBFFile fileNumber printString, ' and ', otherFileNumber printString ]			].		blockArray at: blockNum put: aCatBFFile fileNumber.		block := self getBlock: blockNum.		block fileNumber = aCatBFFile fileNumber			ifFalse: [ self badBlockError: 'Block ', blockNum printString, ' has file number', block fileNumber printString, ', but is used by file ', aCatBFFile fileNumber printString ].		block modificationNumber = aCatBFFile modificationNumber			ifFalse: [ self badBlockError: 'Block ', blockNum printString, ' has modification number', block modificationNumber printString, ', but should be ', aCatBFFile modificationNumber printString ].		block dataSize &gt; block blockSize			ifTrue: [ self badBlockError: 'Data size ', block dataSize printString, ' of block ', blockNum printString, ' is larger than the block size ', block blockSize printString ].		block dataSize &lt; 0			ifTrue: [ self badBlockError: 'Data size ', block dataSize printString, ' of block ', blockNum printString, ' is &lt; 0' ].		block blockSize = self blockSize			ifFalse: [ self badBlockError: 'Block size ', block blockSize printString, ' of block ', blockNum printString, ' is larger than the block size ', block blockSize printString ].		fileSize := fileSize + block dataSize.			fileBlockIndex := fileBlockIndex + 1.		fileBlockIndex = block fileBlockIndex			ifFalse: [ self badBlockError: 'Block ', blockNum printString, ' has block file index ', block fileBlockIndex printString, ' but should be ', fileBlockIndex printString ].		blockNum := block nextBlockNumber.	].	aCatBFFile fileSize = fileSize		ifFalse: [ self unrecoverableFileError: 'Stored file size ', aCatBFFile fileSize printString, ' of file ', aCatBFFile displayString, ' differs from the actual file size ', fileSize printString ].</body><body package="COBlockFileSystem">checkIsValidFirstBlock: aCatFSBlock ofFile: aCatFSFile	aCatFSFile firstBlockNumber = aCatFSBlock blockNumber		ifFalse: [ self error: 'Block number mismatch' ].	aCatFSFile fileNumber = aCatFSBlock fileNumber		ifFalse: [ self error: 'File number mismatch' ].	aCatFSFile fileType = aCatFSBlock fileType		ifFalse: [ self error: 'File type mismatch' ].	aCatFSFile modificationNumber = aCatFSBlock modificationNumber		ifFalse: [ self error: 'Modification number mismatch' ].</body><body package="COBlockFileSystem">handleUnrecoverableErrorsWhile: aBlock 	| old |	old := readOnly.	readOnly := false.	aBlock on: CatBFError		do: 		[: ex |			CoastLog logError: ex description.			CoastLog logError: 'Could not recover ' , self displayString		].	readOnly := old.</body><body package="COBlockFileSystem">markAsReadOnly	readOnly isNil ifTrue: 		[	readOnly := true.			CoastLog log: 'marked ' , self displayString , ' as read only'		].</body><body package="COBlockFileSystem">markAsReadOnlyWhile: aBlock 	| old |	old := readOnly.	^ [	readOnly := true.		aBlock value	] ensure: [ readOnly := old ]</body><body package="COBlockFileSystem">newRecoveredDataFilename	^ (self coreFilename asString, '.', Time millisecondClockValue printString, '.recover') asFilename</body><body package="COBlockFileSystem">rebuildAllIndexFiles	"close open streams (in index structures)"	| recoveredFiles numBlocks checkPoint exceptionOccurred |	self close.	"create new index structures"	self privateOpenForRecover.	"scan bfs and rebuild"	exceptionOccurred := false.	CoastLog log: 'Recovering volume ' , self shortDisplayString printString , ' (' , self numberOfBlocks printString , ' blocks) '.	recoveredFiles := Dictionary new: self numberOfBlocks.	"CatCOIntegerKey"	numBlocks := self numberOfBlocks.	checkPoint := numBlocks // 20 max: 10000.	1 to: numBlocks		do: 		[: blockNumber | | recoveredFile block fileNumber existingFile isSingleBlockFile |			block :=				[ self getBlock: blockNumber ] 					on: CatBFError					do: 					[: ex |						exceptionOccurred := true.						CoastLog logException: ex message: 'Error while rebuilding index files. Volume may still be damaged after recovery!'.						nil					].			block notNil 				ifTrue: 				[	fileNumber := block fileNumber.					isSingleBlockFile := false.					recoveredFile := recoveredFiles at: fileNumber ifAbsent: [ nil ].					recoveredFile isNil 						ifTrue: 						[	" check if the file was completely recovered (newer or older version) "							existingFile := self directory getFile: fileNumber.							( existingFile notNil and: [ existingFile modificationNumber &gt; block modificationNumber ]) 								ifTrue: 								[	" old block "									self freeList addBlockNumber: blockNumber								]								ifFalse: 								[	" sanity check "									( existingFile notNil and: [ existingFile modificationNumber = block modificationNumber ]) 										ifTrue: [ self haltOrError: 'Block ' , blockNumber printString , ' could not be recovered' ].									existingFile notNil 										ifTrue: 										[	" completely recovered file is old "											self privateDeleteFile: existingFile										].									recoveredFile := CatBFRecoverFile new.									" do not remember 1-block-sized files "									block nextBlockNumber = 0 										ifTrue: [ isSingleBlockFile := true ]										ifFalse: [ recoveredFiles at: fileNumber put: recoveredFile ]								]						].					recoveredFile notNil 						ifTrue: 						[	" recover block "							recoveredFile addBlock: block blockFileSystem: self.							( block nextBlockNumber = 0 and: [ block modificationNumber = recoveredFile modificationNumber ]) 								ifTrue: 								[	" file is complete (could be an old version though) "									recoveredFile addFileNumber: fileNumber blockFileSystem: self.									isSingleBlockFile 										ifFalse: [ recoveredFiles removeKey: fileNumber ]								]						]				].			blockNumber \\ checkPoint = 0 				ifTrue: 				[	self writeBackIndexFiles.					CoastLog log: ( blockNumber * 100 / numBlocks ) rounded printString , '% done'				]		].	" recoveredFiles should contain only invalid files "	recoveredFiles keysAndValuesDo: [: fileNumber : recoveredFile | recoveredFile releaseBlocksTo: self ].	recoveredFiles := nil.	self updateNextClusterID.	self close.	CoastLog log: 'Recovered volume ' , self shortDisplayString printString.	exceptionOccurred 		ifTrue: [ CoastLog logWarning: 'An error occurred during recovery. The volume may still be damaged!' ].	CoastLog log: 'Checking recovered volume'.	self deepCheck.</body><body package="COBlockFileSystem">recoverErrorsDetectedWith: checkBlock 	self isOpen 		ifTrue: [ self error: 'Recovery of ' , self displayString , ' not possible, block file system is open' ]		ifFalse: 		[	self exclusiveUseDo: 				[	patchMode := true.					[							[ self ensureOpenWhile: [ checkBlock value ]] 							on: CatBFRecoverableError							do: 							[: ex |								CoastLog logWarning: ex description.								ex recover: self.								self close.								CoastLog log: 'Recovered ' , self displayString							]					] ensure: [ patchMode := false ]				]		].</body><body package="COBlockFileSystem">truncateToCorrectSize	| expectedBlockFileSize backupFilename recoverStream tooMuch |	self assertIsOpen.	expectedBlockFileSize := self numberOfBlocks * self blockSize + self blockFileHeaderSize.	self positionOn: expectedBlockFileSize.	backupFilename := self newRecoveredDataFilename.	recoverStream := backupFilename writeStream binary.	tooMuch := bfsFileHandle fileSize - expectedBlockFileSize.	[ recoverStream nextPutAll: ( self readBytes: tooMuch )] ensure: [ recoverStream close ].	CoastLog log: 'Moved ' , tooMuch printString , ' bytes that were obsolete to ' , backupFilename asString.	self positionOn: expectedBlockFileSize.	self privateSetBlockFileSizeTo: expectedBlockFileSize.</body><body package="COBlockFileSystem">unrecoverableFileError: string 	self markAsReadOnly.	CatBFUnrecoverableFileError raiseSignal: string.</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>file operations</category><body package="COBlockFileSystem">backgroundBackupToDirectory: aDirectory 	" Create a backup of the block file system.	Most parts of the backup operation is done in a background process.	Only one such background backup may be active at a time	Returns an copy info object "	" copy the index files in a consistent state "	| copyInfo string backupProcess |	copyInfo := self exclusiveUseDo: 			[	self isBackupActive 					ifTrue: [ nil ]					ifFalse: [ self privateInitateBackgroundCopyToDirectory: aDirectory uniqueVolumeID: self uniqueVolumeID ]			].	copyInfo isNil 		ifTrue: 		[	string := 'Backup already initiated'.			CoastLog log: string.			^ string		].	copyInfo description: CoastConstant defaultBackupDirectory.	" non-exclusive copy. the copied part of the block file may not be overwritten in a way that makes the copied BFS inconsistent "	backupProcess :=		[ self privateBackgroundCopyWith: copyInfo ] forkAt: self backgroundOperationProcessPriority.	copyInfo copyProcess: backupProcess.	backupCopyInfo := copyInfo.	^ copyInfo</body><body package="COBlockFileSystem">backgroundCopyToDirectory: aDirectory 	" Create a copy of the block file system. 	Most parts of the copy operation is done in a background process.	Returns a CatBFBackgroundCopyInfo (which can be used to monitor the copy operation) "	" copy the index files in a consistent state "	| copyInfo copyProcess |	copyInfo := self exclusiveUseDo: [ self privateInitateBackgroundCopyToDirectory: aDirectory uniqueVolumeID: self uniqueVolumeID ].	copyInfo description: 'copy'.	" non-exclusive copy. the copied part of the block file may not be overwritten in a way that makes the copied BFS inconsistent "	copyProcess :=		[ self privateBackgroundCopyWith: copyInfo ] forkAt: self backgroundOperationProcessPriority.	copyInfo copyProcess: copyProcess.	^ copyInfo</body><body package="COBlockFileSystem">backgroundOperationProcessPriority	^ backgroundOperationProcessPriority ifNil: [ Processor userBackgroundPriority ]</body><body package="COBlockFileSystem">close	self exclusiveUseDo: [ self privateClose ]</body><body package="COBlockFileSystem">copyToDirectory: aDirectory 	" create a copy of the block file system "	self copyToDirectory: aDirectory coreName: self coreName includeLock: false.</body><body package="COBlockFileSystem">copyToDirectory: aDirectory coreName: newCoreName includeLock: includeLock 	" create a copy of the block file system "	self exclusiveUseDo: [ self privateCopyToDirectory: aDirectory coreName: newCoreName includeLock: includeLock ].</body><body package="COBlockFileSystem">create	" create a new container file "	self exclusiveUseDo: [ self privateCreate ]</body><body package="COBlockFileSystem">createFile: fileNumber fileType: fileType 	" create a new file "	^ self exclusiveUseDo: [ self privateCreateFile: fileNumber fileType: fileType ]</body><body package="COBlockFileSystem">delete	" delete the block/index file  "	self exclusiveUseDo: [ self privateDelete ]</body><body package="COBlockFileSystem">deleteFileNumber: fileNumber	" delete the file. "	^ self exclusiveUseDo: [ 			| file |		self assertIsOpen.		file := self getFile: fileNumber.		file isNil ifTrue: [ self error: 'Unable to delete file number ', fileNumber printString, ', file not found' ].		self privateDeleteFile: file	]</body><body package="COBlockFileSystem">fileExists: fileNumber 	^ self exclusiveUseDo: [		self assertIsOpen.		( self directory getFile: fileNumber ) notNil	]</body><body package="COBlockFileSystem">getFile: fileNumber	" get an existing file "	^ self exclusiveUseDo: [		self assertIsOpen.		self directory getFile: fileNumber	].</body><body package="COBlockFileSystem">getOrCreateBlobFile: fileNumber 	^ self getOrCreateFile: fileNumber fileType: CatBFFile fileTypeBlob</body><body package="COBlockFileSystem">getOrCreateClusterFile: fileNumber 	^ self getOrCreateFile: fileNumber fileType: CatBFFile fileTypeCluster</body><body package="COBlockFileSystem">getOrCreateFile: fileNumber fileType: fileType 	" find or create a file "	^ self exclusiveUseDo: 		[ 	| file |			self assertIsOpen.			file := self getFile: fileNumber.			file isNil 				ifTrue: [ self createFile: fileNumber fileType: fileType ]				ifFalse: [ 					file fileType = fileType						ifFalse: [ self error: 'File "', file displayString, '" has type ', file fileType printString, ', but expected type ', fileType printString ].					file 				]		]</body><body package="COBlockFileSystem">iniAccessOnFile: aCatBFFile	" read an INI file "	^ self exclusiveUseDo: [		| str iniAccess |		self assertIsOpen.		aCatBFFile isSpecialFile ifFalse: [ self error: aCatBFFile displayString, ' is not an ini file' ].		iniAccess := CoastIniAccess new.		aCatBFFile fileSize &gt; 0			ifTrue: [ 				str := self readStreamOnFile: aCatBFFile.				[					iniAccess readFromBinary: str				] ensure: [					str close				].			].		iniAccess	].</body><body package="COBlockFileSystem">isOpen	^ bfsFileHandle notNil</body><body package="COBlockFileSystem">moveToDirectory: aDirectory 	" move the BFS to another directory.	implicitely closes the BFS "	^ self moveToDirectory: aDirectory coreName: self coreName</body><body package="COBlockFileSystem">moveToDirectory: aDirectory coreName: newCoreName	" move the BFS to another directory.	implicitely closes the BFS "	self exclusiveUseDo: [ 		self privateMoveToDirectory: aDirectory coreName: newCoreName	]</body><body package="COBlockFileSystem">open	" open an existing block file system named 'coreName' in the given directory.	Fails if the block/index files do not exist or if they are write protected "	self exclusiveUseDo: [ self privateOpen ]</body><body package="COBlockFileSystem">openOrCreate	self exclusiveUseDo: [ 		self exists			ifTrue: [ self open ]			ifFalse: [ self create ]		].</body><body package="COBlockFileSystem">writeBack	self readOnly ifFalse: [ self exclusiveUseDo: [ self privateWriteBack ]].</body><body package="COBlockFileSystem">writeIniAccess: aCoastIniAccess toFile: aCatBFFile 	" write an INI file "	^ self exclusiveUseDo: 		[ | str |			aCatBFFile isSpecialFile ifFalse: [ self error: aCatBFFile displayString , ' is not an ini file' ].			str := self writeStreamOnFile: aCatBFFile.			[ aCoastIniAccess writeToBinary: str ] ensure: [ str close ]		]</body><body package="COBlockFileSystem">writeStreamOnCluster: clusterIDInteger	^ self writeStreamOnFileNumber: clusterIDInteger fileType: CatBFFile fileTypeCluster</body><body package="COBlockFileSystem">writeStreamOnFileNumber: fileNumber fileType: fileType 	| file |	self readOnly ifTrue: [ ^ ByteArray new writeStream ].	file := self getOrCreateFile: fileNumber fileType: fileType.	^ self writeStreamOnFile: file</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>utilitites - private</category><body package="COBlockFileSystem">compareFile: fileNumber fromStorageAccessor: storageAccessor isCluster: isCluster	| file blockStr readStr |	file := self getFile: fileNumber.	file isNil ifTrue: [ self error: 'File ', fileNumber printString, ' not found' ].	blockStr := self readStreamOnFile: file.	[		readStr := isCluster			ifTrue: [ 	storageAccessor readStreamOnCluster: fileNumber ]			ifFalse: [ storageAccessor readStreamOnBlob: fileNumber ].		[			[ readStr atEnd ] whileFalse: [				| b1 b2 |				blockStr atEnd ifTrue: [ self error: 'Size difference in file ', fileNumber, ' at position ', readStr position printString, ' detected: block file is at end' ].				b1 := readStr next.				b2 := blockStr next.				b1 = b2 ifFalse: [ self error: 'Difference in file ', fileNumber, ' at position ', readStr position printString, ' detected' ].			]		] ensure: [ readStr close ].		blockStr atEnd ifFalse:[ self error: 'Size difference in file ', fileNumber, ' at position ', readStr position printString, ' detected: block file is larger' ].	] ensure: [ blockStr close ].</body><body package="COBlockFileSystem">compareFiles: fileNumbers fromStorageAccessor: storageAccessor isCluster: isCluster	fileNumbers do: [ : fileNum |		self compareFile: fileNum fromStorageAccessor: storageAccessor isCluster: isCluster	].</body><body package="COBlockFileSystem">exportFile: aCatBFFile toStorageAccessor: storageAccessor	| writeStr readStr |	aCatBFFile isUnknownFileType ifTrue: [ ^ self error: 'Cannot export file with unknown type ', aCatBFFile displayString ].	aCatBFFile isSpecialFile ifTrue: [ ^ self error: 'Cannot export special files' ].	writeStr := aCatBFFile isCluster		ifTrue: [ storageAccessor writeStreamOnCluster: aCatBFFile fileNumber ]		ifFalse: [ storageAccessor writeStreamOnBlob: aCatBFFile fileNumber ].	[		readStr := self readStreamOnFile: aCatBFFile.		[			[ readStr atEnd ] whileFalse: [				writeStr nextPut: readStr next			].		] ensure:[			readStr close		].	] ensure: [		writeStr close	]</body><body package="COBlockFileSystem">importFile: fileNumber fromStorageAccessor: storageAccessor isCluster: isCluster	| fileType file writeStr readStr |	fileType := isCluster		ifTrue: [ CatBFFile fileTypeCluster ]		ifFalse: [ CatBFFile fileTypeBlob ].	file := self getOrCreateFile: fileNumber fileType: fileType.	writeStr := self writeStreamOnFile: file.	[		readStr := isCluster			ifTrue: [ 	storageAccessor readStreamOnCluster: fileNumber ]			ifFalse: [ storageAccessor readStreamOnBlob: fileNumber ].		[			[ readStr atEnd ] whileFalse: [				writeStr nextPut: readStr next			]		] ensure: [ readStr close ].	] ensure: [ writeStr close ].</body><body package="COBlockFileSystem">importFiles: fileNumbers fromStorageAccessor: storageAccessor isCluster: isCluster	| prog i n newProg |	isCluster ifTrue: [ CoastLog log: 'Importing Clusters' ] ifFalse: [ CoastLog log: 'Importing Blobs' ] .	prog := 0.	i := 0.	n := fileNumbers size.	fileNumbers do: [ : fileNum |		self importFile: fileNum fromStorageAccessor: storageAccessor isCluster: isCluster.		i := i + 1.		newProg := i * 100 // n.		newProg &gt; prog			ifTrue: [ 				prog := newProg.				CoastLog log: prog printString, '%'.			(self directory numberOfDirtySegments &gt; 200 or: [ self freeList numberOfDirtySegments &gt; 200 ])				ifTrue: [ 					CoastLog log: 'Saving index files...'.					self writeBack.					CoastLog log: 'Done'.				].		].	].</body><body package="COBlockFileSystem">importIni: iniAccess file: aCatBFFile	| str |	str := self writeStreamOnFile: aCatBFFile.	[		iniAccess writeToBinary: str	] ensure: [		str close	].</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>utilitites</category><body package="COBlockFileSystem">compareWithDirectory: volumeDirectory	| storageAccessor |	storageAccessor := CatCSFileStorageAccessor new.	storageAccessor setWorkingDirectory: volumeDirectory.	[		self compareWithStorageAccessor: storageAccessor	] ensure: [		storageAccessor shutDown	].</body><body package="COBlockFileSystem">compareWithStorageAccessor: storageAccessor	self exclusiveUseDo: [		self ensureOpenWhile:		[			self compareFiles: storageAccessor clusterIDs fromStorageAccessor: storageAccessor isCluster: true.			self compareFiles: storageAccessor blobIDs fromStorageAccessor: storageAccessor isCluster: false.		]	].</body><body package="COBlockFileSystem">dumpAllNonAllocatedFileNumbers	" Aus allen BlÃ¶cken Files herausfischen, die nicht mehr im Directory vorhanden sind "	| fileNums |	fileNums := CatCOIntegerKeySet new.	self ensureOpenWhile: [		1 to: self numberOfBlocks do: [ : i | 			| block |			block := self privateGetBlock: i.			(self directory fileNumberExists: block fileNumber)				ifFalse: [ fileNums add: block fileNumber ].		]	].	CoastLog log: 'Old files: ', fileNums size printString.	fileNums asSortedCollection do: [ : n | Transcript show: n printString; space ].	CoastLog log: 'Done'.</body><body package="COBlockFileSystem">dumpWastedSize	| totalSize blockSizes computedSizes totalBlockSizeNoFree |	totalSize := 0.	blockSizes := #( 512 1024 2048 4096 ).	computedSizes := Array new: blockSizes size.	computedSizes atAllPut: 0.	self ensureOpenWhile: 		[	self directory filesDo: 				[: file |					totalSize := totalSize + file fileSize.					blockSizes keysAndValuesDo: 						[: i : bs | | requiredBlocks |							requiredBlocks :=  (file fileSize / (bs - CatBFBlock headerSize)) ceiling.							computedSizes at: i put: ( computedSizes at: i ) + (requiredBlocks * bs)						]				].			totalBlockSizeNoFree := ( self numberOfBlocks - self numberOfFreeBlocks ) * self blockSize.			CoastLog 				log: 'Allocated space (without free space): ' , totalBlockSizeNoFree coastShortByteSizePrintString , ' (' 						, ( totalSize * 100 / totalBlockSizeNoFree ) rounded printString , '% space used)'.			CoastLog log: 'Block size is: ' , self blockSize printString.			blockSizes keysAndValuesDo: 				[: i : bs |					bs = self blockSize 						ifFalse: 						[	CoastLog 								log: 'With block size ' , bs printString , ': ' , ( computedSizes at: i ) coastShortByteSizePrintString , ' (' 										, ( totalSize * 100 / ( computedSizes at: i )) rounded printString , '% space used)'						]				]		]</body><body package="COBlockFileSystem">exportVolumeToDirectory: volumeDirectory	| storageAccessor targetDir |	targetDir := volumeDirectory asFilename.	targetDir ensureFullDirectory.	storageAccessor := CatCSFileStorageAccessor new.	storageAccessor setWorkingDirectory: targetDir.	self exportVolumeToStorageAccessor: storageAccessor.	storageAccessor shutDown.</body><body package="COBlockFileSystem">exportVolumeToStorageAccessor: storageAccessor	self isOpen ifTrue: [ ^ self error: 'Cannot export  ', self displayString, ', is open' ].	self open.	[		self directory filesDo: [ : file |			file isSpecialFile				ifFalse: [ self exportFile: file toStorageAccessor: storageAccessor ].		].		storageAccessor volumeIniAccess: self volumeIniAccess.		storageAccessor indexIniAccess: self indexIniAccess.	] ensure: [		self close	]</body><body package="COBlockFileSystem">importVolumeFromBlockFile: blockFileDirectory	| storageAccessor bfs |	bfs :=  self class directory: blockFileDirectory.	storageAccessor := CatCSBlockFileStorageAccessor blockFileSystem: bfs.	storageAccessor startUp.	[		self importVolumeFromStorageAccessor: storageAccessor	] ensure: [		storageAccessor shutDown	].</body><body package="COBlockFileSystem">importVolumeFromDirectory: volumeDirectory	| storageAccessor |	storageAccessor := CatCSFileStorageAccessor workingDirectory: volumeDirectory.	[		self importVolumeFromStorageAccessor: storageAccessor	] ensure: [		storageAccessor shutDown	].</body><body package="COBlockFileSystem">importVolumeFromStorageAccessor: storageAccessor	self isOpen ifTrue: [ ^ self error: 'Cannot import volume ', storageAccessor volume printString, ', ', self displayString, ' is open' ].	self exclusiveUseDo: [		self create.		[			self numberOfFiles = 0 ifFalse: [ ^ self error: 'Cannot import volume ', storageAccessor volume printString, ', ', self displayString, ' must be empty' ].			self importFiles: storageAccessor clusterIDs fromStorageAccessor: storageAccessor isCluster: true.			self importFiles: storageAccessor blobIDs fromStorageAccessor: storageAccessor isCluster: false.			self importIni: storageAccessor volumeIniAccess file: self volumeIniFile.			self importIni: storageAccessor indexIniAccess file: self indexIniFile.			self nextClusterID: storageAccessor nextClusterID.			self uniqueVolumeID: storageAccessor uniqueVolumeID.		] ensure: [			self close		].	].	CoastLog log: 'Done'.</body><body package="COBlockFileSystem">perfomanceReadRandomBlocks	| buffer random n |	random := Random new.	self ensureOpenWhile: [ | t |		buffer := Array new: self blockDataSize.		t := Time millisecondsToRun: [			n := self numberOfBlocks.			n timesRepeat: [ | i |				i := (random next * n) ceiling.				self getBlock: i.				self nextPutBlockFileData: i into: buffer startingAt: 1.			].		].		CoastLog log: 'Blocks: ', self numberOfBlocks printString, ' , time: ', t printString, ' msecs.'.	].</body><body package="COBlockFileSystem">perfomanceReadRandomFiles	| fileNums random factor |	self ensureOpenWhile: 		[ | t |			fileNums := CatCOIntegerKeySet new: self directory numberOfFiles.			random := Random new.			factor := fileNums capacity * 1000.			self directory filesDo: [: f | fileNums add: (random next * factor) rounded -&gt; f fileNumber ].			fileNums := fileNums asSortedCollection.			t := Time millisecondsToRun: 					[	fileNums do: 							[: firstBlockAndFile | | file str |								file := self getFile: firstBlockAndFile value.								str := self readStreamOnFile: file.								[ str upToEnd ] ensure: [ str close ]							]					].			CoastLog log: 'Files: ' , fileNums size printString , ' , time: ' , t printString , ' msecs.'		]</body><body package="COBlockFileSystem">perfomanceReadSequentialBlocks	| buffer |	self ensureOpenWhile: [ | t |		buffer := Array new: self blockDataSize.		t := Time millisecondsToRun: [			1 to: self numberOfBlocks do: [ : i | 				self getBlock: i.				self nextPutBlockFileData: i into: buffer startingAt: 1.			].		].		CoastLog log: 'Blocks: ', self numberOfBlocks printString, ' , time: ', t printString, ' msecs.'.	].</body><body package="COBlockFileSystem">perfomanceReadSequentialFiles	| fileNums |	self ensureOpenWhile: 		[ | t |			fileNums := CatCOIntegerKeySet new: self directory numberOfFiles.			self directory filesDo: [: f | fileNums add: f firstBlockNumber -&gt; f fileNumber ].			fileNums := fileNums asSortedCollection.			t := Time millisecondsToRun: 					[	fileNums do: 							[: firstBlockAndFile | | file str |								file := self getFile: firstBlockAndFile value.								str := self readStreamOnFile: file.								[ str upToEnd ] ensure: [ str close ]							]					].			CoastLog log: 'Files: ' , fileNums size printString , ' , time: ' , t printString , ' msecs.'		]</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>initialize-release</category><body package="COBlockFileSystem">directory: directoryFilename name: newCoreName	workingDirectory := directoryFilename asFilename.	coreName := newCoreName.</body><body package="COBlockFileSystem">initialize	VisualWorksVersion checkForBlacklistedVMVersion.	accessLock := RecursionLock new.	openWriteStreams := WeakDictionary new.	openReadStreams := CoastWeakSet new.	patchMode := false.	headerBuffer := ByteArray new: self blockFileHeaderSize.	backgroundCopyInfos := OrderedSet new.	isLocked := false.	seekPosition := 0.	self reset</body><body package="COBlockFileSystem">prepareClose	self stopBackgroundCopyProcesses.</body><body package="COBlockFileSystem">removeCopyInfo: copyInfoToRemove	backgroundCopyInfos remove: copyInfoToRemove ifAbsent: [ nil ].	backupCopyInfo == copyInfoToRemove		ifTrue: [ 			backupCopyInfo := nil.		].</body><body package="COBlockFileSystem">stopBackgroundCopyProcesses	backgroundCopyInfos copy do: [: copyInfo | copyInfo abortBackgroundCopy ifTrue: [ self removeCopyInfo: copyInfo ]]</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>testing</category><body package="COBlockFileSystem">exists	^ self blockFilename exists</body><body package="COBlockFileSystem">hasIndexIniFile	^ self fileExists: CatBFFile indexIniFileNumber</body><body package="COBlockFileSystem">hasOpenStreams	^ openWriteStreams notEmpty or: [ openReadStreams notEmpty ]</body><body package="COBlockFileSystem">hasVolumeIniFile	^ self fileExists: CatBFFile volumeIniFileNumber</body><body package="COBlockFileSystem">readOnly	^ readOnly ifNil: [ false ]</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>file operations - private</category><body package="COBlockFileSystem">allocateNewBlocks: numBlocks 	" allocate blocks "	| blockNum newFileSize |	CoastLog logDebug: [ 'Allocating  ', numBlocks printString, ' blocks in ', self displayString ].	blockNum := self numberOfBlocks.	newFileSize := ((blockNum + numBlocks) * self blockSize + self blockFileHeaderSize).	[		self privateSetBlockFileSizeTo: newFileSize.	] on: OsError do: [: ex | | msg |		msg := 'Could not grow ', self displayString, ' to ', newFileSize coastShortByteSizePrintString.		CoastLog logFatalException: ex message: msg.		CoastError raiseSignal: msg, ': ', ex description.	].	self positionOnBlock: blockNum + 1.	" append blocks "	numBlocks timesRepeat: 		[ 	| block |			blockNum := blockNum + 1.			block := CatBFBlock blockNumber: blockNum blockSize: self blockSize.			self writeBytes: block emptyBlockBytes.			self freeList addBlockNumber: blockNum		].	self numberOfBlocks: blockNum.	self writeBlockFileHeader.	CoastLog logDebug: [ 'Allocation done' ].</body><body package="COBlockFileSystem">basicWriteBlockFileHeaderOn: stream processID: aProcessID uniqueVolumeID: aUniqueVolumeIDString	" write the header of the block file "	" sync with #blockHeaderSize ! "	| headSize |	stream nextUnsigned64Put: self blockFileMagicNumber.	stream nextPut: self version major.	stream nextPut: self version minor.	stream nextUnsigned64Put: aProcessID.	stream nextUnsigned64Put: self numberOfBlocks.	stream nextUnsigned32Put: self blockSize.	stream nextUnsigned32Put: self modificationNumber.	stream nextUnsigned32Put: self lastModification asSeconds.	stream nextUnsigned64Put: self nextClusterID.	stream nextCoastStringPut: ( aUniqueVolumeIDString ifNil: [ '' ]).	" end of header marker "	stream nextUnsigned64Put: self blockFileHeaderEnd.	" check size "	( headSize := stream position ) &gt;= self blockFileHeaderSize 		ifTrue: [ self error: 'Block header is larger than the reservered size' ].	^ headSize</body><body package="COBlockFileSystem">closeBlockFileStream	self isOpen ifTrue: 		[	self unlockBFS.			bfsFileHandle close.			bfsFileHandle := nil		].</body><body package="COBlockFileSystem">closeOpenStreams	openWriteStreams values do: [ : str |		str ~~ 0			ifTrue: [ str close ]	].	openReadStreams do: [ : str |		str ~~ 0			ifTrue: [ str close ]	].	buffers := nil.	availableBuffers := nil.</body><body package="COBlockFileSystem">createNextBlockFor: aCatBFFile previousBlock: previousBlock size: anInteger 	" append a new block to the given block (which must be the last block of the file!) "	^ self exclusiveUseDo: 		[	self 				privateCreateNextBlocksFor: aCatBFFile				previousBlock: previousBlock				size: anInteger 		]</body><body package="COBlockFileSystem">createOrOverwriteFile	" create new index and block files. existing ones will be overwritten "	self acquireLockFile.	" don't lock yet, doesn't work at least under Windows, even though MSDN says:	'You can lock bytes that are beyond the end of the current file. This is useful to coordinate adding records to the end of a file' "	self openBlockFileStreamLocked: false.	self processID: self osProcessID.	self uniqueVolumeID: self generateUniqueID.	self createOrOverwriteIndexFiles.	[	" fill header block "		self writeBytes: ( ByteArray new: self blockFileHeaderSize ).		self grow.		self lockBFS.		self writeBack	] on: Error		do: 		[: ex |			self privateEmergencyClose.			ex pass		].</body><body package="COBlockFileSystem">emergencyCloseOpenStreams	openWriteStreams values do: [ : str |		str ~~ 0			ifTrue: [ str closeNoWriteBack ]	].	openReadStreams do: [ : str |		str ~~ 0			ifTrue: [ str closeNoWriteBack ]	].	buffers := nil.	availableBuffers := nil.</body><body package="COBlockFileSystem">getBlock: blockNumber 	^ self exclusiveUseDo: [ self privateGetBlock: blockNumber   ]</body><body package="COBlockFileSystem">getBlockForFile: aCatBFFile position: positionInFile 	" get the block for the specified position within the file "	^ self exclusiveUseDo: [ self privateGetBlockForFile: aCatBFFile position: positionInFile  ]</body><body package="COBlockFileSystem">grow	" allocate a bunch of blocks "	self allocateNewBlocks: self growSize</body><body package="COBlockFileSystem">growByAtLeast: requiredBlocks 	" allocate a bunch of blocks "	self allocateNewBlocks: ( requiredBlocks + ( self growSize // 2 ) max: self growSize ).</body><body package="COBlockFileSystem">positionOfBlock: blockNum	" position of the first byte of the block header within the block file "	^ (blockNum -1) * self blockSize + 1 + self blockFileHeaderSize</body><body package="COBlockFileSystem">positionOn: newPos 	seekPosition = newPos ifFalse: 		[	bfsFileHandle seekTo: newPos.			seekPosition := newPos		].	^ seekPosition</body><body package="COBlockFileSystem">positionOnBlock: blockNum 	" position the stream to the beginning of the block header"	^ self positionOn: (blockNum - 1) * self blockSize + self blockFileHeaderSize	" optimized to reduce LargeInteger arithmetic / same as: "	" -1, because #position: positions the stream before the next byte to be read/written "	"stream position: (self positionOfBlock: blockNum) - 1"</body><body package="COBlockFileSystem">positionOnBlockFileData: blockNum 	" position the stream to the beginning of the block data "	self 		positionOn: (blockNum - 1) * self blockSize + (self blockFileHeaderSize + CatBFBlock headerSize)	" optimized to reduce LargeInteger arithmetic / same as: "	"stream position: (self positionOfBlock: blockNum) + CatBFBlock headerSize - 1"</body><body package="COBlockFileSystem">privateBackgroundCopyWith: copyInfo 	| backupOK time |	backupOK :=		[	time := Time millisecondsToRun: 					[ | targetHandle |						OSSystemSupport concreteClass new coastCopyFile: self blockFilename to: copyInfo targetBlockFile.						" patch header "						targetHandle := IOAccessor openFileNamed: copyInfo targetBlockFile direction: ( IOAccessor perform: #readWrite ) creation: IOAccessor noCreate.						[	targetHandle seekTo: 0;								writeAll: copyInfo header						] ensure: [ targetHandle close ]					].			" check that at least blockFileBytesToCopy bytes have been written "			( copyInfo targetBlockFile exists not or: [ copyInfo targetBlockFile fileSize &lt; copyInfo blockFileBytesToCopy ]) 				ifTrue: [ CatBFBackgroundCopyError raiseSignal: 'Target file "' , copyInfo targetBlockFile asString , '" could not be written' ].			copyInfo lock releaseLock.			CoastLog log: 'Finished ' , copyInfo description , ' of  ' , self coreName printString.			time &gt; 0 				ifTrue: [ CoastLog log: 'Performance: ' , ( self blockFilename fileSize / time ) rounded printString , ' KB/s' ].			true		] 			on: Error			do: 			[: ex |				ex blockFileSystemLogCopyErrorFor: self copyInfo: copyInfo.				[ copyInfo lock ifNotNil: [: lock | lock releaseLockStream ]] 					on: Error					do: [: lockEx | CoastLog logWarning: 'Could not release lock: ' , ex description ].				false			].	self privateFinishBackgroundCopyWith: copyInfo ok: backupOK.</body><body package="COBlockFileSystem">privateClose	" close the block file system "	self isOpen 		ifFalse: [ ^ self ].	self stopBackgroundCopyProcesses.	self closeOpenStreams.	self processID: self notInUseID.	self writeBack.	self closeIndexFiles.	self closeBlockFileStream.	self reset.	self releaseLockFile.</body><body package="COBlockFileSystem">privateCloseRecoveryNeeded: reason 	" close the block file system "	self isOpen 		ifFalse: [ ^ self ].	lockFile notNil 		ifTrue: [ lockFile maintenanceNeeded: reason ].	" don't save, just close "	self markAsReadOnlyWhile: 		[	self emergencyCloseOpenStreams.			self privateEmergencyClose		].	self reset.</body><body package="COBlockFileSystem">privateCopyToDirectory: aDirectory coreName: newCoreName includeLock: includeLock 	| targetDirectory sourceFilenames targetFilenames lockFilename |	targetDirectory := aDirectory asFilename.	targetDirectory = self workingDirectory 		ifTrue: [ ^ self error: 'Target directory must be different from working directory' ].	targetDirectory ensureFullDirectory.	sourceFilenames := self allFilenames asOrderedCollection.	(includeLock and: [ (lockFilename := self lockFilename) exists ])		ifTrue: [ sourceFilenames add: lockFilename ].	targetFilenames := sourceFilenames collect: [: source | targetDirectory construct: newCoreName , source extension ].	self consistentStateForCopyDo: [ sourceFilenames with: targetFilenames do: [: source : target | source copyTo: target ]].	( self class directory: targetDirectory name: newCoreName ) privateFinalizeCopy.</body><body package="COBlockFileSystem">privateCreate	" create a new container file "	self allFilenames do: [ : fn |		fn exists ifTrue: [ ^ self error: '"', fn asString, '" already exists' ].	].	self ensureWorkingDirectory.	self createOrOverwriteFile</body><body package="COBlockFileSystem">privateCreateFile: fileNumber fileType: fileType 	| file |	self assertIsOpen.	file := CatBFFile fileNumber: fileNumber fileType: fileType.	self directory addFile: file.	^ file</body><body package="COBlockFileSystem">privateCreateNextBlocksFor: aCatBFFile previousBlock: previousBlock size: anInteger 	" append a new block to the given block (which must be the last block of the file!) "	| nextFileBlocks |	( previousBlock isNil or: [ previousBlock isLastBlock ]) ifFalse: [ ^ self error: 'Can only append blocks to the last block of a file' ].	nextFileBlocks := self privateGetFreeBlocksOfSize: anInteger.	" modify the block header "	previousBlock notNil 		ifTrue: [ nextFileBlocks keysAndValuesDo: [: i : block | block fileBlockIndex: previousBlock fileBlockIndex + i ]]		ifFalse: 		[	aCatBFFile firstBlockNumber: nextFileBlocks first blockNumber.			nextFileBlocks keysAndValuesDo: [: i : block | block fileBlockIndex: i ]		].	nextFileBlocks do: 		[: blk |			blk fileNumber: aCatBFFile fileNumber;				fileType: aCatBFFile fileType;				modificationNumber: aCatBFFile modificationNumber		].	previousBlock notNil ifTrue: 		[	previousBlock nextBlockNumber: nextFileBlocks first blockNumber.		].	^ nextFileBlocks</body><body package="COBlockFileSystem">privateDelete	self privateDeleteCheckAccess: true.</body><body package="COBlockFileSystem">privateDeleteCheckAccess: checkAccess 	self isOpen 		ifTrue: [ ^ self error: 'Cannot delete "' , self displayString , '": block file system is open' ].	self exists 		ifFalse: [ ^ self ].	checkAccess 		ifTrue: 		[	" access check "			self open.			self close		].	self allFilenames do: 		[: fn |			fn exists 				ifTrue: [ fn delete ]		].	self workingDirectory directoryContents isEmpty 		ifTrue: [ self workingDirectory delete ].</body><body package="COBlockFileSystem">privateDeleteFailedBackgroundCopy: aDirectory copyInfo: copyInfo	[ 		aDirectory asFilename deleteRecursively 	] on: OsError do: [: ex | 		CoastLog log: 'Error while deleting failed ', copyInfo description, ': ' , ex description	].</body><body package="COBlockFileSystem">privateDeleteFile: aCatBFFile	" delete the file. add all blocks to the free list "	(self hasOpenStreamOnFile:  aCatBFFile) 		ifTrue: [ ^ self error: 'Cannot delete file "', aCatBFFile displayString, '", file is in use' ].	self privateFreeBlocksOfFile: aCatBFFile.	self directory removeFile: aCatBFFile.	^ aCatBFFile</body><body package="COBlockFileSystem">privateFinalizeCopy	" I am a BFS that was created by copying bytes from a running BFS. 	now patch the header data so that the copy is not locked anymore "	[	self openBlockFileStreamLocked: true.		patchMode := true.		self readBlockFileHeader.		" update lock marker "		self processID: self notInUseID.		self uniqueVolumeID: nil.		self writeBlockFileHeader	] ensure: 		[	self closeBlockFileStream.			patchMode := false		].</body><body package="COBlockFileSystem">privateFinishBackgroundCopyWith: copyInfo ok: copyOk 	self exclusiveUseDo: [ self privateBackgroundCopyDone: copyInfo ].	copyOk 		ifFalse: [ self privateDeleteFailedBackgroundCopy: copyInfo targetDirectory copyInfo: copyInfo ].</body><body package="COBlockFileSystem">privateFreeBlocksOfFile: aCatBFFile 	| blockNum |	blockNum := aCatBFFile firstBlockNumber.	blockNum isNil ifTrue: [ ^ self error: 'File "' , aCatBFFile displayString , '" is not stored yet and cannot be freed' ].	blockNum == self endOfFileBlockNumber ifFalse: [ self freeList addObsoleteStartBlock: blockNum ].	aCatBFFile firstBlockNumber: 0.</body><body package="COBlockFileSystem">privateGetBlock: blockNumber 	" read the block "	| tempStream |	self checkIsValidBlockNumber: blockNumber.	self positionOnBlock: blockNumber.	tempStream := (self readBytes: CatBFBlock headerSize) readStream.	^ CatBFBlock readHeaderFrom: tempStream</body><body package="COBlockFileSystem">privateGetBlockForFile: aCatBFFile blockIndex: blockIndex	| blockNum |	blockNum := aCatBFFile firstBlockNumber.	[ blockNum = CatBFBlock lastBlockNumber ] whileFalse: [		| block |		block := self privateGetBlock: blockNum.		blockIndex = block fileBlockIndex ifTrue: [ ^ block ].		blockNum := block nextBlockNumber	].	^ nil</body><body package="COBlockFileSystem">privateGetBlockForFile: aCatBFFile position: positionInFile 	| blockNum |	blockNum := aCatBFFile firstBlockNumber.	[ blockNum = CatBFBlock lastBlockNumber ] whileFalse: [		| block |		block := self privateGetBlock: blockNum.		positionInFile &lt;= block maxPosition ifTrue: [ ^ block ].		blockNum := block nextBlockNumber	].	^ nil</body><body package="COBlockFileSystem">privateGetBlocksForFile: aCatBFFile	| blockNum blocks |	blocks := OrderedCollection new.	blockNum := aCatBFFile firstBlockNumber.	[ blockNum = CatBFBlock lastBlockNumber ] whileFalse: [		| block |		block := self privateGetBlock: blockNum.		blocks add: block.		blockNum := block nextBlockNumber	].	^ blocks</body><body package="COBlockFileSystem">privateGetFreeBlocksOfSize: numBytes 	" get a free block (allocate if needed). the block will be removed from free list "	| blocks numBlocks |	numBlocks := numBytes = 0 			ifTrue: [ 1 ]			ifFalse: [( numBytes / self blockDataSize ) ceiling ].	blocks := self freeList getConsecutiveFreeBlocks: numBlocks.	blocks isEmpty ifTrue: 		[	self growByAtLeast: numBlocks.			blocks := self freeList getConsecutiveFreeBlocks: numBlocks.			blocks isEmpty ifTrue: 				[	" just in case. #grow should complain if allocation is not possible "					self error: 'No free block left'				]		].	^ blocks</body><body package="COBlockFileSystem">privateInitateBackgroundCopyToDirectory: aDirectory uniqueVolumeID: aUniqueVolumeID 	" ensure a consistent state of the files "	| targetDirectory sourceFilenames targetFilenames blockFileBytesToCopy targetBlockFile backupLock copyInfo headerStr |	self privateWriteBack.	targetDirectory := aDirectory asFilename.	targetDirectory = self workingDirectory 		ifTrue: [ self error: 'Target directory must be different from working directory' ].	targetDirectory ensureFullDirectory.	self unlockAllFiles.	[	sourceFilenames := self allIndexFilenames.		targetFilenames := sourceFilenames collect: [: source | targetDirectory construct: self coreName , source extension ].		sourceFilenames with: targetFilenames do: [: source : target | source copyTo: target ]	] ensure: [ self lockAllFiles ].	backupLock := self lockFileClass filename: ( targetDirectory construct: self lockFilename tail ) infoString: self lockInfoString.	backupLock getLock.	" remember the relevant size of the block file "	blockFileBytesToCopy := self totalBlockSize.	" must unlock to access the block file "	self unlockBFS.	" save the block header "	targetBlockFile := targetDirectory construct: self coreName , self blockFilename extension.	headerStr := ( ByteArray new: self blockFileHeaderSize ) writeStream.	self basicWriteBlockFileHeaderOn: headerStr processID: self notInUseID uniqueVolumeID: aUniqueVolumeID.	" patch the backup (unlock) "	copyInfo := CatBFBackgroundCopyInfo 			copyBlockFile: self			toDirectory: targetDirectory			targetBlockFile: targetBlockFile			blockFileBytesToCopy: blockFileBytesToCopy			lock: backupLock			header: headerStr contents.	backgroundCopyInfos add: copyInfo.	^ copyInfo</body><body package="COBlockFileSystem">privateMoveToDirectory: aDirectory coreName: newCoreName	| targetDirectory sourceFilenames targetFilenames |	targetDirectory := aDirectory asFilename.	targetDirectory = self workingDirectory		ifTrue: [ ^ self error: 'Target directory must be different from working directory' ].	targetDirectory ensureFullDirectory.	sourceFilenames := self allFilenames.	targetFilenames := sourceFilenames collect: [: source | 		targetDirectory construct: newCoreName , source extension	].	targetFilenames do: [ : fn |		fn exists ifTrue: [ ^ self error: 'Target file ', fn asString, ' already exists' ].	].	self close.	sourceFilenames with: targetFilenames do: [ : source : target |		source renameTo: target	].</body><body package="COBlockFileSystem">privateNumberOfBlocksOfFile: aCatBFFile	^ (aCatBFFile fileSize / self blockDataSize) ceiling</body><body package="COBlockFileSystem">privateOpen	" open an existing block file system named 'coreName' in the given directory.	Fails if the block/index files do not exist or if they are write protected "	self isOpen 		ifTrue: [ ^ self ].	self quickCheckDatafiles.	self acquireLockFile.	[	self openBlockFileStreamLocked: true.		" read the block header first (some information in the index file is redundant, and the block file is the master file) "		self readBlockFileHeader.		self openIndexFiles.		self updateNextClusterID.		" update marker "		self processID: self osProcessID.		self writeBack	] 		on: Error		do: 		[: ex |			self privateEmergencyClose.			ex pass		].</body><body package="COBlockFileSystem">privateOpenForRecover	" open an existing broken block file system named 'coreName' in the given directory"	self isOpen 		ifTrue: [ ^ self ].	self acquireLockFile.	[	self openBlockFileStreamLocked: true.		" read the block header first (some information in the index file is redundant, and the block file is the master file) "		self readBlockFileHeader.		self createOrOverwriteIndexFiles.		" update marker "		self processID: self osProcessID.		self writeBack	] 		on: Error		do: 		[: ex |			self privateEmergencyClose.			ex pass		].</body><body package="COBlockFileSystem">privateSetBlockFileSizeTo: fileSize	self assertIsOpen.	bfsFileHandle truncateTo: fileSize.	self closeBlockFileStream.	self openBlockFileStreamLocked: true.</body><body package="COBlockFileSystem">privateUpdateFile: aCatBFFile	" prepare to update the file data "	self privateFreeBlocksOfFile: aCatBFFile.</body><body package="COBlockFileSystem">privateWriteBack	" write back the updated file system information.	all blocks must be valid at this moment (no open block streams) "	self isOpen 		ifFalse: [ self error: 'Cannot write back ' , self displayString , ' block file system is not open' ].	" bookkeeping "	self lastModification: Timestamp now.	self modificationNumber: ( self modificationNumber + 1 ) \\ 16rFFFFFFFF.	" block file is the master file, so write it first "	self writeBlockFileHeader.	" when the BFS is copied by a background process, no free blocks shall be reused (otherwise, the backup can become inconsistent) "	self isBackgroundCopyActive 		ifFalse: 		[	" it is save now to free obsolete blocks "			self freeList freeObsoleteBlocks		].	" finally save the index "	self writeBackIndexFiles.</body><body package="COBlockFileSystem">readBlockFileHeader	" read the header of the block file "	" sync with #blockHeaderSize ! "	| majorVersion minorVersion procID ver tempStream |	self positionOn: 0.	tempStream := (self readBytes: self blockFileHeaderSize) readStream.	[	tempStream nextUnsigned64 = self blockFileMagicNumber 			ifFalse: [ self corruptBlockFileError: 'Magic number expected' ].		majorVersion := tempStream next.		minorVersion := tempStream next.		procID := tempStream nextUnsigned64.		ver := CoastVersion major: majorVersion minor: minorVersion.		self version: ver.		ver = self class version ifFalse: 			[	self error: self displayString , ' was created with version ' , ver printString , ', current version is ' 							, self class version printString 			].		self numberOfBlocks: tempStream nextUnsigned64.		blockSize := tempStream nextUnsigned32.		self modificationNumber: tempStream nextUnsigned32.		self lastModification: (Timestamp fromSeconds: tempStream nextUnsigned32).		self nextClusterID: tempStream nextUnsigned64.		self uniqueVolumeID: tempStream nextCoastString.		tempStream nextUnsigned64 = self blockFileHeaderEnd 			ifFalse: [ self corruptBlockFileError: 'End of header expected' ] 	] on: EndOfStreamNotification			do: [: ex | self corruptBlockFileError: 'Unexpected end of file reached' ].	(patchMode not and: [ procID ~= self notInUseID and: [ procID ~= self processID ] ]) ifTrue: 		[	CoastLog 				logWarning: 'Block file was locked by process ' , procID printString , ', successfully unlocked' 		]</body><body package="COBlockFileSystem">readBytes: numBytes 	| buffer numRead |	buffer := ByteArray new: numBytes.	numRead := bfsFileHandle readInto: buffer.	seekPosition := seekPosition + numRead.	^ numRead = numBytes 		ifTrue: [ buffer ]		ifFalse: [ buffer copyFrom: 1 to: numRead ]</body><body package="COBlockFileSystem">readBytesInto: buffer startingAt: index for: count 	| numRead |	numRead := bfsFileHandle 				readInto: buffer				startingAt: index				for: count.	seekPosition := seekPosition + numRead.	^ numRead</body><body package="COBlockFileSystem">writeBlock: aCatBFBlock data: byteArray 	" update the block information "	self writeBlockHeader: aCatBFBlock.	self 		writeBytes: byteArray		startingAt: 1		for: aCatBFBlock dataSize.	aCatBFBlock markClean</body><body package="COBlockFileSystem">writeBlockFileHeader	" writethe header of the block file "	" sync with #blockHeaderSize ! "	self exclusiveUseDo: 		[ | str headSize |			str := headerBuffer writeStream.			headSize := self basicWriteBlockFileHeaderOn: str processID: self processID uniqueVolumeID: self uniqueVolumeID.			self positionOn: 0.			self writeBytes: headerBuffer startingAt: 1 for: headSize		].</body><body package="COBlockFileSystem">writeBlockHeader: aCatBFBlock 	" update the block header information "	self positionOnBlock: aCatBFBlock blockNumber.	self writeBytes: aCatBFBlock headerBytes.</body><body package="COBlockFileSystem">writeBytes: bytes 	| numWritten |	numWritten := bfsFileHandle writeAll: bytes.	seekPosition := seekPosition + numWritten.	^ numWritten</body><body package="COBlockFileSystem">writeBytes: buffer startingAt: index for: count 	| numWritten |	count = 0 ifTrue: [ ^ 0 ].	numWritten := bfsFileHandle primWriteFrom: buffer startingAt: index for: count.	seekPosition := seekPosition + numWritten.	^ numWritten</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>accessing - private</category><body package="COBlockFileSystem">lastModification: aTimestamp	" Timestamp of the last modification "	lastModification := aTimestamp</body><body package="COBlockFileSystem">modificationNumber: anInteger 	" Number (increasing) of the last modification "	modificationNumber := anInteger</body><body package="COBlockFileSystem">numberOfBlocks: a64BitInteger	" number of allocated blocks"	numberOfBlocks := a64BitInteger</body><body package="COBlockFileSystem">processID	^ processID</body><body package="COBlockFileSystem">processID: a64BitInteger 	processID := a64BitInteger</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>streaming</category><body package="COBlockFileSystem">currentWriteStreamOnFile: aCatBFFile 	| str |	str := openWriteStreams at: aCatBFFile ifAbsent: [ nil ].	^ str ~~ 0 		ifTrue: [ str ]		ifFalse: [ nil ]</body><body package="COBlockFileSystem">deregisterFileReadStream: aCatBFBlockStream 	| streamFile buffer |	streamFile := aCatBFBlockStream file.	( openReadStreams includes: aCatBFBlockStream)		ifTrue: 		[				openReadStreams remove: aCatBFBlockStream.			buffer := self buffers removeKey: streamFile ifAbsent: [ nil ].			buffer notNil 				ifTrue: [ self availableBuffers add: buffer ]		]</body><body package="COBlockFileSystem">deregisterFileWriteStream: aCatBFBlockStream 	| streamFile buffer |	streamFile := aCatBFBlockStream file.	( self currentWriteStreamOnFile: streamFile ) == aCatBFBlockStream 		ifTrue: 		[				openWriteStreams removeKey: streamFile.			buffer := self buffers removeKey: streamFile ifAbsent: [ nil ].			buffer notNil 				ifTrue: [ self availableBuffers add: buffer ]		]</body><body package="COBlockFileSystem">hasOpenStreamOnFile: aCatBFFile 	| str |	str := openWriteStreams at: aCatBFFile ifAbsent: [ nil ].	^ (str notNil and: [ str ~~ 0  ])		ifTrue: [  true ]		ifFalse: [  openReadStreams anySatisfy: [ : rstr | rstr ~~ nil and: [ rstr ~~ 0 and: [ rstr file  = aCatBFFile  ]]]]</body><body package="COBlockFileSystem">nextPutBlockFileData: blockNumber into: byteArray startingAt: offset	" fill the buffer. "	^ self exclusiveUseDo: [ self privateNextPutBlockFileData: blockNumber into: byteArray startingAt: offset ]</body><body package="COBlockFileSystem">readStreamOnFile: aCatBFFile	" returns a read stream "	^ self exclusiveUseDo: [ self privateReadStreamOnFile: aCatBFFile ]</body><body package="COBlockFileSystem">writeStreamOnFile: aCatBFFile	" returns a write stream "	^ self exclusiveUseDo: [ self privateWriteStreamOnFile: aCatBFFile ]</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>printing</category><body package="COBlockFileSystem">displayString	^ 'BlockFileSystem ', self coreName, ' [', self workingDirectory asString, ']'.</body><body package="COBlockFileSystem">printOn: aStream	| f |	super printOn: aStream.	aStream nextPut: $(.	(f := self coreFilename) notNil		ifTrue: [ f asString printOn: aStream ].	aStream nextPut: $).</body><body package="COBlockFileSystem">shortDisplayString	^ self coreFilename asString</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>upgrade</category><body package="COBlockFileSystem">upgrade	" upgrade to current version "	" this is the current version, no upgrade needed "</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>streaming - private</category><body package="COBlockFileSystem">privateNextPutBlockFileData: blockNumber into: byteArray startingAt: offset 	" fill the buffer "	| transferSize |	self positionOnBlockFileData: blockNumber.	transferSize := self blockDataSize.	transferSize &gt; byteArray size ifTrue: [ ^ self error: 'Buffer not large enough for block data' ].	self 		readBytesInto: byteArray		startingAt: offset		for: transferSize</body><body package="COBlockFileSystem">privateReadStreamOnFile: aCatBFFile 	" returns a read stream "	| fileStream buffer |	( self currentWriteStreamOnFile: aCatBFFile ) notNil 		ifTrue: [ ^ self error: 'Sharing violation: File "' , aCatBFFile printString , '" is opened for writing' ].	buffer := self allocateBufferForFile: aCatBFFile.	fileStream := CatBFReadStream blockFileSystem: self file: aCatBFFile buffer: buffer.	openReadStreams add: fileStream.	^ fileStream</body><body package="COBlockFileSystem">privateWriteStreamOnFile: aCatBFFile 	" returns a write stream "	| fileStream buffer |	(self currentWriteStreamOnFile: aCatBFFile) notNil ifTrue: 		[	^ self error: 'Sharing violation: File "' , aCatBFFile printString , '" is opened for writing' 		].	" track modification. this needs to be done before writing blocks "	aCatBFFile increaseModificationNumber.	directory markModified: aCatBFFile.	" if the file was already stored, free the old blocks "	aCatBFFile isStored ifTrue: [ self privateUpdateFile: aCatBFFile ].	buffer := self allocateBufferForFile: aCatBFFile.	fileStream := CatBFWriteStream 				blockFileSystem: self				file: aCatBFFile				buffer: buffer.	openWriteStreams at: aCatBFFile put: fileStream.	^ fileStream</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>locking</category><body package="COBlockFileSystem">acquireLockFile	" additional lock file. the block file is locked, too, but a separate lock makes administration easier "	lockFile isNil 		ifTrue: 		[	self workingDirectory ensureFullDirectory.			lockFile := self lockFileClass filename: self lockFilename infoString: self lockInfoString.			[ lockFile getLock ] 				on: CatBFLockMaintenanceError				do: 				[: ex |					patchMode 						ifTrue: 						[	CoastLog logWarning: ex description.							ex resume						]						ifFalse: [ ex pass ]				]		].	lockFile hasLock 		ifFalse: [ CatBFLockError raiseSignal: 'Unable to lock ' , self displayString ].</body><body package="COBlockFileSystem">lockAllFiles	self lockBFS.	self directory lockStream.	self freeList lockStream.</body><body package="COBlockFileSystem">lockBFS	" lock the BFS "	self exclusiveUseDo: 		[				[( self isOpen and: [ isLocked not ]) 					ifTrue: 					[	" Voodoo: ohne position: 0; readBytes: 1 gibt es Fehler beim Unlock (positionOn: 1 funktioniert NICHT!) " 						self positionOn: 0.						self readBytes: 1.						bfsFileHandle lock: true for: self blockFileHeaderSize.						isLocked := true					]			] on: Error do: [: ex | CoastLog log: 'Lock of ' , self displayString , ' failed: ' , ex description channel: #bfs ]		].</body><body package="COBlockFileSystem">lockFileClass	^ CatBFFileLock</body><body package="COBlockFileSystem">lockFilename	^ (self coreFilename asString, '.lock') asFilename</body><body package="COBlockFileSystem">lockInfoString	^ lockInfoString ifNil: [ 'Locked by unknown application' ]</body><body package="COBlockFileSystem">lockInfoString: aLockInfoString 	lockInfoString := aLockInfoString.</body><body package="COBlockFileSystem">unlockAllFiles	self unlockBFS.	self directory unlockStream.	self freeList unlockStream.</body><body package="COBlockFileSystem">unlockBFS	" unlock the BFS "	self exclusiveUseDo: 		[				[( self isOpen and: [ isLocked ]) 					ifTrue: 					[	" Voodoo: ohne position: 0; readBytes: 1 gibt es Fehler beim Unlock (positionOn: 1 funktioniert NICHT!) "						self positionOn: 0.						self readBytes: 1.						bfsFileHandle lock: false for: self blockFileHeaderSize					]			] on: Error do: [: ex | CoastLog log: 'Unlock of ' , self displayString , ' failed: ' , ex description channel: #bfs ].			isLocked := false		].</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>command line</category><body package="COBlockFileSystem">checkFragmentation	| str scanned |	self ensureOpenWhile: 		[ | filesToScan total max lastLogTime |			max := total := 0.			filesToScan := OrderedCollection new: self numberOfFiles.			lastLogTime := 0.			self filesDo: 				[: bfsFile |					bfsFile fileSize &gt; self blockDataSize 						ifTrue: [ filesToScan add: bfsFile ]				].			filesToScan := filesToScan sortedBy: [: file | file firstBlockNumber ].			lastLogTime := 0.			scanned := 0.			filesToScan keysAndValuesDo: 				[: done : bfsFile | | fragments now |					fragments := self numberOfFragments: bfsFile.					scanned := scanned + 1.					max := max max: fragments.					total := fragments + total.					now := Time millisecondClockValue.					now - lastLogTime &gt; 60000 						ifTrue: 						[	lastLogTime := now.							str := String new writeStream.							( done * 100 / filesToScan size ) floor printOn: str.							str nextPutAll: '% scanned ('.							str nextPutAll: 'Average: '.							( total / scanned ) asFloat printOn: str.							str nextPutAll: ' fragments per file'.							max &gt; 1 								ifTrue: 								[	str nextPutAll: ', worst case: '.									max printOn: str								].							str nextPutAll: ')'.							CoastLog log: str contents						]				].			CoastLog enableConsoleWhile: 				[	CoastLog log: 'Average: ' , ( total / scanned ) asFloat printString , ' fragments per file'.					CoastLog log: 'Total: ' , ( total - scanned ) printString , ' additional fragments'.					CoastLog log: 'Worst case: ' , (max - 1) printString , ' additional fragments'				]		].</body><body package="COBlockFileSystem">copyToBFS: copyBFS 	self ensureOpenWhile: 		[ | allFiles lastLogTime |			allFiles := OrderedCollection new: self numberOfFiles.			lastLogTime := 0.			self filesDo: [: bfsFile | allFiles add: bfsFile ].			CoastLog log: 'About to copy ' , allFiles size printString , ' files'.			allFiles := allFiles sortedBy: [: file | file firstBlockNumber ].			allFiles keysAndValuesDo: 				[: done : bfsFile | | theBYTEs tmpStream ioStream now |					ioStream := self readStreamOnFile: bfsFile.					[	theBYTEs := ByteArray new.						tmpStream := theBYTEs readWriteStream.						[ ioStream atEnd ] whileFalse: [ tmpStream nextPut: ioStream next ].						ioStream close.						ioStream := copyBFS writeStreamOnFile: ( copyBFS createFile: bfsFile fileNumber fileType: bfsFile fileType ).						"[ tmpStream atEnd ] whileFalse: [ ioStream nextPut: tmpStream next ]"						ioStream next: tmpStream size putAll: theBYTEs startingAt: 1					] ensure: [ ioStream close ].					now := Time millisecondClockValue.					now - lastLogTime &gt; 60000 ifTrue: 						[	lastLogTime := now.							CoastLog log: ( done * 100 / allFiles size ) floor printString , '% copied'						]				].			CoastLog enableConsoleWhile: [ CoastLog log: 'copy done' ]		].</body><body package="COBlockFileSystem">dumpBadBlocksTo: targetFn 	| targetDir numBadBlocks t1 numBlocks |	[ targetDir := targetFn asFilename ] on: Error		do: [: ex | self error: 'Invalid directory: ' , targetFn , '(' , ex description , ')' ].	targetDir exists 		ifTrue: [ targetDir isDirectory ifFalse: [ self error: targetFn , ' is not a directory' ] ]		ifFalse: [ targetDir ensureFullDirectory ].	numBadBlocks := 0.	t1 := 0.	self ensureOpenWhile: 		[ | expectedBlockSize t2 |			numBlocks := self numberOfBlocks.			CoastLog log: 'Checking ' , numBlocks printString , ' blocks'.			1 to: numBlocks				do: 				[: blockNum |					[ self privateGetBlock: blockNum ] on: CatBFError						do: 						[: ex | | outputStr bytes |							(self freeList isFreeOrObsolete: blockNum) 								ifTrue: [ CoastLog logWarning: 'Found bad block ' , blockNum printString , ', block is marked as free' ]								ifFalse: [ CoastLog logWarning: 'Found bad block ' , blockNum printString ].							numBadBlocks := numBadBlocks + 1.							outputStr := [	(targetDir construct: 'bad-block-' , blockNum printString , '.blk') asFilename writeStream binary 									] on: Error											do: 											[: ex2 |												CoastLog logError: 'Could not open target file ' , targetFn , ' (' , ex2 description , ')'.												nil 											].							outputStr notNil ifTrue: 								[	[	self positionOnBlock: blockNum.										expectedBlockSize := self blockSize.										bytes := self readBytes: expectedBlockSize.										outputStr nextPutAll: bytes.										bytes size = expectedBlockSize ifFalse: 											[	CoastLog 													logWarning: 'Transferred ' , bytes size printString , ' bytes, expected ' 															, expectedBlockSize printString , ' bytes' 											] 									] ensure: [ outputStr close ] 								] 						].					t2 := Time millisecondClockValue.					t2 - t1 &gt; 60000 ifTrue: 						[	t1 := t2.							CoastLog log: (blockNum * 100 / numBlocks) floor printString , '% checked' 						] 				] 		].	CoastLog enableConsoleWhile: 		[	numBadBlocks &gt; 0 				ifTrue: 				[	CoastLog 						logWarning: 'Scan finished ' , numBadBlocks printString , ' bad blocks dumped to ' , targetFn 				]				ifFalse: [ CoastLog log: 'Scan finished, no bad blocks found' ] 		]</body><body package="COBlockFileSystem">extractBlock: blockNumber to: targetFn 	| targetFile outputStr expectedBlockSize bytes |	[ targetFile := targetFn asFilename ] on: Error		do: [: ex | self error: 'Invalid filename: ' , targetFn , '(' , ex description , ')' ].	self ensureOpenWhile: 		[	self checkIsValidBlockNumber: blockNumber.			[ outputStr := targetFile writeStream binary ] on: Error				do: [: ex | self error: 'Could not open file ' , targetFn , ' (' , ex description , ')' ].			[	self positionOnBlock: blockNumber.				expectedBlockSize := self blockSize.				bytes := self readBytes: expectedBlockSize.				outputStr nextPutAll: bytes.				bytes size = expectedBlockSize ifFalse: 					[	CoastLog 							logWarning: 'Transferred ' , bytes size printString , ' bytes, expected ' 									, expectedBlockSize printString , ' bytes' 					] 			] ensure: [ outputStr close ] 		].	CoastLog enableConsoleWhile: 		[	CoastLog log: 'Block ' , blockNumber printString , ' of ' , self displayString , ' dumped to file ' 						, targetFn 		]</body><body package="COBlockFileSystem">extractFile: fileNumber to: targetFn 	| targetFile outputStr readStr | 	[ targetFile := targetFn asFilename ] on: Error do: [: ex | self error: 'Invalid filename: ' , targetFn , '(' , ex description , ')' ].	self ensureOpenWhile: 		[				[ outputStr := targetFile writeStream binary ] on: Error do: [: ex | self error: 'Could not open file ' , targetFn , ' (' , ex description , ')' ].			[	readStr := self readStreamOnFile: ( self getFile: fileNumber ).				[						[ readStr atEnd ] whileFalse: [ outputStr nextPut: readStr next ]				] ensure: [ readStr close ]			] ensure: [ outputStr close ]		].	CoastLog enableConsoleWhile: [ CoastLog log: 'File ' , fileNumber printString , ' of ' , self displayString , ' dumped to file ' , targetFn ].</body><body package="COBlockFileSystem">findFileStartingAtBlock: blockNum 	| i numberOfFiles files |	i := 0.	files := OrderedCollection new.	self ensureOpenWhile: 		[	numberOfFiles := self numberOfFiles.			self allFilesSortedByBlockNumber do: 				[: file |					file firstBlockNumber = blockNum 						ifTrue: [ files add: file ].					i := i + 1.					self logProgress: i of: numberOfFiles				]		].	CoastLog log: 'Found ' , files size printString , ' files'.	files do: [: file | CoastLog log: file printString ].</body><body package="COBlockFileSystem">importDamagedFile: fileNumber from: sourceFn fileType: fileType 	| sourceFile inputStr writeStr bfsFile | 	[ sourceFile := sourceFn asFilename ] on: Error do: [: ex | self error: 'Invalid filename: ' , sourceFn , '(' , ex description , ')' ].	self ensureOpenWhile: 		[				[ inputStr := sourceFile readStream binary ] on: Error do: [: ex | self error: 'Could not open file ' , sourceFn , ' (' , ex description , ')' ].			[	( self directory fileNumberExists: fileNumber ) 					ifTrue: 					[	CoastLog log: 'Removing old file: ' , fileNumber printString.						self directory removeFileNumber: fileNumber					].				bfsFile := self createFile: fileNumber fileType: fileType.				writeStr := self writeStreamOnFile: bfsFile.				[						[ inputStr atEnd ] whileFalse: [ writeStr nextPut: inputStr next ]				] ensure: [ writeStr close ]			] ensure: [ inputStr close ].			CoastLog log: 'New file size: ' , bfsFile fileSize printString		].	CoastLog enableConsoleWhile: [ CoastLog log: 'File ' , fileNumber printString , ' of ' , self displayString , ' imported from file ' , sourceFn ].</body><body package="COBlockFileSystem">importFile: fileNumber from: sourceFn 	| sourceFile inputStr writeStr bfsFile header fileType expectedSize |	CoastLog enableConsoleWhile: 		[				[ sourceFile := sourceFn asFilename ] on: Error do: [: ex | ^ self error: 'Invalid filename: ' , sourceFn , '(' , ex description , ')' ].			self ensureOpenWhile: 				[						[	expectedSize := sourceFile fileSize.						inputStr := sourceFile readStream binary					] on: Error do: [: ex | ^ self error: 'Could not open file ' , sourceFn , ' (' , ex description , ')' ].					[	( self directory fileNumberExists: fileNumber ) 							ifTrue: 							[	bfsFile := self getFile: fileNumber.								CoastLog log: 'Deleting old file: ' , bfsFile printString.								self privateDeleteFile: bfsFile							].						header := inputStr nextAvailable: 5.						inputStr reset.						fileType := header = #[ 67 79 65 83 84 ] 								ifTrue: 								[	CoastLog log: 'Detected file type: cluster'.									CatBFFile fileTypeCluster								]								ifFalse: 								[	CoastLog log: 'Detected file type: blob'.									CatBFFile fileTypeBlob								].						bfsFile := self createFile: fileNumber fileType: fileType.						writeStr := self writeStreamOnFile: bfsFile.						[								[ inputStr atEnd ] whileFalse: [ writeStr nextPut: inputStr next ]						] ensure: [ writeStr close ]					] ensure: [ inputStr close ].					CoastLog log: 'New file: ' , bfsFile printString.					bfsFile fileSize = expectedSize						ifFalse: [ CoastLog logWarning: 'File size differs from input file size: ', expectedSize printString ].				].			CoastLog log: 'File ' , fileNumber printString , ' of ' , self displayString , ' imported from file ' , sourceFn		].</body><body package="COBlockFileSystem">logBlocksOfFile: fileNumber 	| file blockNumber |	CoastLog enableConsoleWhile: 		[	self ensureOpenWhile: 				[	file := self getFile: fileNumber.					CoastLog log: [ 'Blocks of file ' , file printString ].					blockNumber := file firstBlockNumber.					[ blockNumber = CatBFBlock lastBlockNumber ] whileFalse: 						[ | block |							block := self getBlock: blockNumber.							CoastLog log: [ block printString ].							blockNumber := block nextBlockNumber						]				].			CoastLog log: [ 'Done' ]		].</body><body package="COBlockFileSystem">wipeBadBlock: blockNumber 	| block |	self ensureOpenWhile: 		[				[	block := self privateGetBlock: blockNumber.				CoastLog log: 'Block is not corrupt, skipped: ' , block printString			] 				on: CatBFError				do: 				[: ex |					CoastLog log: 'Problem: ' , ex description.					block := CatBFBlock blockNumber: blockNumber blockSize: self blockSize.					self writeBlockHeader: block.					CoastLog log: 'Wiped bad block'.				]		].</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>index files - private</category><body package="COBlockFileSystem">closeIndexFiles	directory ifNotNil: [: dir | dir close ].	directory := nil.	freeList ifNotNil: [: list | list close ].	freeList := nil.</body><body package="COBlockFileSystem">directory	^ directory</body><body package="COBlockFileSystem">directoryClass	^ CatBFSegmentedDirectory</body><body package="COBlockFileSystem">directoryFilenameExtension	^ '.cdr'</body><body package="COBlockFileSystem">freeBlockListClass	^ CatBFSegmentedFreeBlockList</body><body package="COBlockFileSystem">freeList	^ freeList</body><body package="COBlockFileSystem">freeListFilenameExtension	^ '.cfl'</body><body package="COBlockFileSystem">openIndexFiles	directory := self directoryClass newOnFile: self directoryFilename blockFileSystem: self.	directory open.	freeList := self freeBlockListClass newOnFile: self freeListFilename  blockFileSystem: self.	freeList open.</body><body package="COBlockFileSystem">writeBackIndexFiles	directory write.	freeList write.</body></methods><methods><class-id>COAST.CatBFBlockFileSystem</class-id> <category>ini</category><body package="COBlockFileSystem">configureWithIni: iniAccess 	| newGrowSize newBlockSize backgroundProcessPriority |	self isOpen 		ifTrue: 		[	CoastLog log: 'Cannot configure ' , self displayString , ', already opened'.			^ self		].	newGrowSize := iniAccess memoryAt: CoastConstant iniAccessBFSGrowSize ifAbsent: [ nil ].	newGrowSize notNil 		ifTrue: 		[	CoastLog log: 'BFS grow size: ' , newGrowSize printString.			self growSizeInBytes: newGrowSize		].	newBlockSize := iniAccess numberAt: CoastConstant iniAccessBFSBlockSize ifAbsent: [ nil ].	newBlockSize notNil 		ifTrue: 		[	CoastLog log: 'BFS block size: ' , newBlockSize printString.			self blockSize: newBlockSize		].	backgroundProcessPriority := iniAccess numberAt: CoastConstant iniAccessBackgroundProcessPriority ifAbsent: [ nil ].	backgroundProcessPriority notNil 		ifTrue: 		[	backgroundProcessPriority := (backgroundProcessPriority max: 1) min: Processor lowIOPriority - 1.			CoastLog log: 'BFS background process priorty: ' , backgroundProcessPriority printString.			backgroundOperationProcessPriority := backgroundProcessPriority		].</body></methods><methods><class-id>COAST.CatBFBlockFileSystem class</class-id> <category>private</category><body package="COBlockFileSystem">closeAll	self allInstances do: [ : inst | inst close ]</body><body package="COBlockFileSystem">errorSignal	^ CatBFError</body></methods><methods><class-id>COAST.CatBFBlockFileSystem class</class-id> <category>instance creation</category><body package="COBlockFileSystem">createNewInDirectory: directoryFilename name: coreName blockSize: blockSize 	" create a new block file system named 'coreName' in the given directory with the specified block size.	Fails if the block/index files already exist or if they cannot be created "	^ (self directory: directoryFilename name: coreName)		blockSize: blockSize;		create;		yourself</body><body package="COBlockFileSystem">directory: directoryFilename 	" default name = directory name "	^ self directory: directoryFilename name: directoryFilename asFilename tail</body><body package="COBlockFileSystem">directory: directoryFilename name: coreName	" returns a block file system accessor.	Can be used to create, open or delete a block file system "	^ self new		directory: directoryFilename name: coreName;		yourself</body><body package="COBlockFileSystem">new	^ super new initialize</body><body package="COBlockFileSystem">openExistingInDirectory: directoryFilename name: coreName	" open an existing block file system named 'coreName' in the given directory with the specified block size.	Fails if the block/index files do not exist or if they are write protected "	^  (self directory: directoryFilename name: coreName)		open;		yourself</body></methods><methods><class-id>COAST.CatBFBlockFileSystem class</class-id> <category>constants</category><body package="COBlockFileSystem">defaultBlockSize	^ 1024</body><body package="COBlockFileSystem">minBlockSize	" at least 256 bytes data should be possible "	^ CatBFBlock headerSize + 256</body></methods><methods><class-id>COAST.CatBFBlockFileSystem class</class-id> <category>accessing</category><body package="COBlockFileSystem">defaultGrowBytesSize	^ 10*1024*1024</body><body package="COBlockFileSystem">version	^ CoastVersion major: 5 minor: 3</body></methods><methods><class-id>COAST.CatBFBlockFileSystem class</class-id> <category>command line</category><body package="COBlockFileSystem">commandLineParameters	"if new parameters are added, also change #parseBFSCommand:	 case-insensitive!  "	| d |	d := Dictionary new.	d at: 'extractBlock' put: #parseExtractBlock:.	d at: 'extractFile' put: #parseExtractFile:.	d at: 'importFile' put: #parseImportFile:.	d at: 'deleteFile' put: #parseDeleteFile:.	d at: 'importDamagedBlob' put: #parseImportDamagedBlob:.	d at: 'importDamagedCluster' put: #parseImportDamagedCluster:.	d at: 'filesStartingAt' put: #parsefilesStartingAt:.	d at: 'wipeBadBlock' put: #parseWipeBadBlock:.	d at: 'dumpBadBlocks' put: #parseDumpBadBlocks:.	d at: 'copyTo' put: #parseCopyTo:.	d at: 'checkFragmentation' put: #parseCheckFragmentation:.	d at: 'quickCheck' put: #parseQuickCheck:.	d at: 'deepCheck' put: #parseDeepCheck:.	d at: 'logBlocksOfFile' put: #parseLogBlocksOfFile:.	^ d</body><body package="COBlockFileSystem">parseBFSCommand: stream 	| bfsName command |	bfsName := stream next ifNil: [ self error: 'Volume name not specified' ].	command := stream next ifNil: [ self error: 'Command not specified' ].	self commandLineParameters keysAndValuesDo: 		[: pattern : parseSelector | | actionBlock wrappedAction |			( pattern match: command ignoreCase: true ) ifTrue: 				[	actionBlock := self perform: parseSelector with: stream.					wrappedAction :=					[ | bfs |						bfs := COAST.CatBSBlockFileVolumeAccessor new blockFileSystemOnVolume: bfsName.						actionBlock value: bfs					].					^ wrappedAction				]		].	self error: 'Unknown command: ' , command.	^ nil</body><body package="COBlockFileSystem">parseCheckFragmentation: stream 	^ [: bfs | [ bfs checkFragmentation ] ensure: [ bfs close ]]</body><body package="COBlockFileSystem">parseCopyTo: stream 	| targetName |	targetName := stream next ifNil: [ self error: 'target volume not specified' ].	^ [: bfs | | copyBFS | 		[	copyBFS := self directory: ( bfs workingDirectory directory construct: targetName ).			copyBFS exists ifTrue: [ self error: 'target Volume must not exists' ].			copyBFS create.			bfs copyToBFS: copyBFS.			copyBFS close		] ensure: [ bfs close ]	]</body><body package="COBlockFileSystem">parseDeepCheck: stream 	^ [: bfs | bfs deepCheck ]</body><body package="COBlockFileSystem">parseDeleteFile: stream 	| fileNumber |	fileNumber := stream next ifNotNil: [: s | s asInteger ] ifNil: [ self error: 'File number not specified' ].	^ [: bfs | bfs ensureOpenWhile: [ bfs deleteFileNumber: fileNumber ]]</body><body package="COBlockFileSystem">parseDumpBadBlocks: stream	| targetFn |	targetFn := stream next.	targetFn isNil		ifTrue: [ self error: 'Target directory not specified' ].	^ [ : bfs | bfs dumpBadBlocksTo: targetFn ]</body><body package="COBlockFileSystem">parseExtractBlock: stream 	| blockNumber targetFn |	blockNumber := stream next ifNotNil: [: s | s asInteger ] ifNil: [ self error: 'Block number not specified' ].	targetFn := stream next ifNil: [ self error: 'Target file not specified' ].	^ [: bfs | bfs extractBlock: blockNumber to: targetFn ]</body><body package="COBlockFileSystem">parseExtractFile: stream 	| fileNumber targetFn |	fileNumber := stream next ifNotNil: [: s | s asInteger ] ifNil: [ self error: 'File number not specified' ].	targetFn := stream next ifNil: [ self error: 'Target file not specified' ].	^ [: bfs | bfs extractFile: fileNumber to: targetFn ]</body><body package="COBlockFileSystem">parseImportDamagedBlob: stream 	| fileNumber sourceFn |	fileNumber := stream next ifNotNil: [: s | s asInteger ] ifNil: [ self error: 'File number not specified' ].	sourceFn := stream next ifNil: [ self error: 'Source file not specified' ].	^ [: bfs | bfs importDamagedFile: fileNumber from: sourceFn fileType: CatBFFile fileTypeBlob  ]</body><body package="COBlockFileSystem">parseImportDamagedCluster: stream 	| fileNumber sourceFn |	fileNumber := stream next ifNotNil: [: s | s asInteger ] ifNil: [ self error: 'File number not specified' ].	sourceFn := stream next ifNil: [ self error: 'Source file not specified' ].	^ [: bfs | bfs importDamagedFile: fileNumber from: sourceFn fileType: CatBFFile fileTypeCluster  ]</body><body package="COBlockFileSystem">parseImportFile: stream 	| fileNumber sourceFn |	fileNumber := stream next ifNotNil: [: s | s asInteger ] ifNil: [ self error: 'File number not specified' ].	sourceFn := stream next ifNil: [ self error: 'Source file not specified' ].	^ [: bfs | bfs importFile: fileNumber from: sourceFn ]</body><body package="COBlockFileSystem">parseLogBlocksOfFile: stream 	| fileNumber |	fileNumber := stream next ifNotNil: [: s | s asInteger ] ifNil: [ self error: 'File number not specified' ].	^ [: bfs | bfs logBlocksOfFile: fileNumber  ]</body><body package="COBlockFileSystem">parseQuickCheck: stream 	^ [: bfs | bfs quickCheck ]</body><body package="COBlockFileSystem">parseWipeBadBlock: stream 	| blockNumber |	blockNumber := stream next ifNotNil: [: s | s asInteger ] ifNil: [ self error: 'Block number not specified' ].	^ [: bfs | bfs wipeBadBlock: blockNumber  ]</body><body package="COBlockFileSystem">parsefilesStartingAt: stream 	| blockNumber |	blockNumber := stream next ifNotNil: [: s | s asInteger ] ifNil: [ self error: 'Block number not specified' ].	^ [: bfs | bfs findFileStartingAtBlock: blockNumber  ]</body></methods><methods><class-id>COAST.CatBFRecoverFile</class-id> <category>repair / recovery</category><body package="COBlockFileSystem">addBlock: block blockFileSystem: blockFileSystem 	block modificationNumber &lt; modificationNumber ifTrue: [ ^ blockFileSystem freeList addBlockNumber: block blockNumber warnIfAlreadyFree: false ].	block modificationNumber &gt; modificationNumber ifTrue: 		[	self releaseBlocksTo: blockFileSystem.			blockIDs := OrderedCollection new: 1.			fileType := block fileType.			modificationNumber := block modificationNumber.			fileSize := 0		].	blockIDs add: block blockNumber.	fileSize := fileSize + block dataSize.	block fileBlockIndex = 1 ifTrue: [ firstBlockNumber := block blockNumber ]</body><body package="COBlockFileSystem">addFileNumber: fileNumber blockFileSystem: blockFileSystem 	( fileType &lt; 0 or: [ modificationNumber &lt; 0 or: [ firstBlockNumber &lt; 0 ]]) 		ifTrue: [ self releaseBlocksTo: blockFileSystem	"dont panic, we are free !" ]		ifFalse: [ blockFileSystem directory addFile: ( self createFileNumber: fileNumber )]</body></methods><methods><class-id>COAST.CatBFRecoverFile</class-id> <category>repair / recovery - private</category><body package="COBlockFileSystem">createFileNumber: fileNumber 	| file |	file := CatBFFile fileNumber: fileNumber fileType: fileType.	file fileSize: fileSize.	file modificationNumber: modificationNumber.	file firstBlockNumber: firstBlockNumber.	^ file</body><body package="COBlockFileSystem">releaseBlocksTo: blockFileSystem 	blockIDs notNil 		ifTrue: [ blockIDs do: [: blockID | blockFileSystem freeList addBlockNumber: blockID warnIfAlreadyFree: false ]].</body></methods><methods><class-id>COAST.CatBFRecoverFile</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	fileSize := 0.	fileType := -1.	modificationNumber := -1.	firstBlockNumber := -1.</body></methods><methods><class-id>COAST.CatBFRecoverFile</class-id> <category>accessing</category><body package="COBlockFileSystem">modificationNumber	^ modificationNumber</body></methods><methods><class-id>COAST.CatBFRecoverFile class</class-id> <category>instance creation</category><body package="COBlockFileSystem">new	^ super new initialize</body></methods><methods><class-id>COAST.FreeMapLeafList</class-id> <category>testing</category><body package="COBlockFileSystem">isEmpty	^ self size = 0</body><body package="COBlockFileSystem">notEmpty	^ self size &gt; 0</body></methods><methods><class-id>COAST.FreeMapLeafList</class-id> <category>accessing</category><body package="COBlockFileSystem">decreaseSize	numberOfLeafs := numberOfLeafs - 1</body><body package="COBlockFileSystem">firstLeaf	^ firstLeaf</body><body package="COBlockFileSystem">firstLeaf: aFirstLeaf 	firstLeaf := aFirstLeaf.</body><body package="COBlockFileSystem">increaseSize	numberOfLeafs := numberOfLeafs + 1</body><body package="COBlockFileSystem">insertLeaf: aLeaf	| nextLeaf |	self increaseSize.	nextLeaf := self firstLeaf.	aLeaf nextLeafOfSameSize: nextLeaf.	nextLeaf notNil ifTrue: [ nextLeaf prevLeafOfSameSize: aLeaf ].	self firstLeaf: aLeaf.</body><body package="COBlockFileSystem">removeLeaf: aLeaf 	| nextLeaf prevLeaf |	nextLeaf := aLeaf nextLeafOfSameSize.	prevLeaf := aLeaf prevLeafOfSameSize.	prevLeaf notNil 		ifTrue: 		[	" link prev &lt;-&gt; next "			prevLeaf nextLeafOfSameSize: nextLeaf.					]		ifFalse: 		[	" first leaf "			self firstLeaf: nextLeaf.		].	self decreaseSize.	nextLeaf notNil ifTrue: [ nextLeaf prevLeafOfSameSize: prevLeaf ].	aLeaf nextLeafOfSameSize: nil.	aLeaf prevLeafOfSameSize: nil.</body><body package="COBlockFileSystem">size	^ numberOfLeafs</body></methods><methods><class-id>COAST.FreeMapLeafList</class-id> <category>enumerating</category><body package="COBlockFileSystem">includes: aLeaf	" slow, for debugging only ! "	self leavesOfSameSizeDo: [ : leaf | leaf == aLeaf ifTrue: [^ true ]].	^ false</body><body package="COBlockFileSystem">leavesOfSameSizeDo: aBlock	self firstLeaf notNil ifTrue: [ self firstLeaf leavesOfSameSizeDo: aBlock expectedListSize: self size ]</body></methods><methods><class-id>COAST.FreeMapLeafList</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	numberOfLeafs := 0</body></methods><methods><class-id>COAST.FreeMapLeafList class</class-id> <category>instance creation</category><body package="COBlockFileSystem">new	^ super new initialize</body></methods><methods><class-id>COAST.CatBFBackgroundCopyInfo</class-id> <category>background process</category><body package="COBlockFileSystem">abortBackgroundCopy	| myPriority |	self copyProcessIsActive		ifTrue: 		[	myPriority := Processor activeProcess priority.			copyProcess interruptWith: 				[	Processor activeProcess priority: myPriority + 1.					CatBFAbortBackgroundCopySignal raiseSignal				].			10 timesRepeat: [				(Delay forMilliseconds: 200) wait.				self copyProcessIsActive					ifFalse: [ ^ false ].			].			CoastLog logError: 'Copy of ', self sourceBlockFile coreName, ' could not be aborted, ', self targetDirectory asString,' is corrupt'.			^ false		]		ifFalse: [ ^ true ].</body><body package="COBlockFileSystem">blockUntilCopyIsDone	copySemaphore ifNotNil: [: sem | sem wait ].</body><body package="COBlockFileSystem">copyProcessIsActive	^ copyProcess notNil and: [ copyProcess isTerminated not ]</body><body package="COBlockFileSystem">signalCopyDone	copyDone := true.	copySemaphore ifNotNil: 		[: sem |			copySemaphore := nil.			[ sem isEmpty ] whileFalse: [ sem signal ]		].</body></methods><methods><class-id>COAST.CatBFBackgroundCopyInfo</class-id> <category>accessing</category><body package="COBlockFileSystem">blockFileBytesToCopy	^ blockFileBytesToCopy</body><body package="COBlockFileSystem">blockFileBytesToCopy: numberOfBytes 	blockFileBytesToCopy := numberOfBytes.</body><body package="COBlockFileSystem">copyProcess	^ copyProcess</body><body package="COBlockFileSystem">copyProcess: aCopyProcess 	copyProcess := aCopyProcess.</body><body package="COBlockFileSystem">copySemaphore	^ copySemaphore</body><body package="COBlockFileSystem">copySemaphore: aCopySemaphore 	copySemaphore := aCopySemaphore.</body><body package="COBlockFileSystem">description	^ description ifNil: [ 'copy' ]</body><body package="COBlockFileSystem">description: aString 	description := aString.</body><body package="COBlockFileSystem">header	^ header</body><body package="COBlockFileSystem">header: aHeader 	header := aHeader.</body><body package="COBlockFileSystem">isCopyDone	^ copyDone</body><body package="COBlockFileSystem">lock	^ lock</body><body package="COBlockFileSystem">lock: aFileLock 	lock := aFileLock.</body><body package="COBlockFileSystem">sourceBlockFile	^ sourceBlockFile</body><body package="COBlockFileSystem">sourceBlockFile: aSourceBlockFile 	sourceBlockFile := aSourceBlockFile.</body><body package="COBlockFileSystem">targetBlockFile	^ targetBlockFile</body><body package="COBlockFileSystem">targetBlockFile: aTargetBlockFile 	targetBlockFile := aTargetBlockFile.</body><body package="COBlockFileSystem">targetDirectory	^ targetDirectory</body><body package="COBlockFileSystem">targetDirectory: aTargetDirectory 	targetDirectory := aTargetDirectory.</body></methods><methods><class-id>COAST.CatBFBackgroundCopyInfo</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	copySemaphore := Semaphore new.	copyDone := false.</body></methods><methods><class-id>COAST.CatBFBackgroundCopyInfo</class-id> <category>testing</category><body package="COBlockFileSystem">isCopyActive	^ self isCopyDone not and: [ self copyProcessIsActive ]</body></methods><methods><class-id>COAST.CatBFBackgroundCopyInfo class</class-id> <category>instance creation</category><body package="COBlockFileSystem">copyBlockFile: aSourceBlockFile toDirectory: aTargetDirectory targetBlockFile: aTargetBlockFile blockFileBytesToCopy: numberOfBytes lock: aFileLock header: headerBytes	^ ( self new )		targetDirectory: aTargetDirectory;		sourceBlockFile: aSourceBlockFile;		targetBlockFile: aTargetBlockFile;		blockFileBytesToCopy: numberOfBytes;		lock: aFileLock;		header: headerBytes;		yourself</body><body package="COBlockFileSystem">new	^ super new initialize; yourself</body></methods><methods><class-id>COAST.CatBFFile</class-id> <category>comparing</category><body package="COBlockFileSystem">= anotherBFFile	^ self class = anotherBFFile class		and: [ self fileNumber = anotherBFFile fileNumber ]</body><body package="COBlockFileSystem">hash	^ self fileNumber hash</body></methods><methods><class-id>COAST.CatBFFile</class-id> <category>accessing</category><body package="COBlockFileSystem">constructFileInDirectory: directory mod: filesPerSubDir	" filename for export to a classic volume directory "	^ self isSpecialFile		ifTrue: [ directory construct: self fileString ]		ifFalse: [ directory constructForCluster: self fileString number: self fileNumber mod: filesPerSubDir ]</body><body package="COBlockFileSystem">fileNumber	" number of this file (0-based).	if the highest bit is set, it is a special name file "	^ fileNumber</body><body package="COBlockFileSystem">fileNumber: a64BitNumber	" number of this file (0-based).	if the highest bit is set, it is a special name file "	fileNumber := a64BitNumber</body><body package="COBlockFileSystem">fileSize	" size of this file (in bytes) "	^ fileSize</body><body package="COBlockFileSystem">fileSize: a64BitInteger 	" size of this file (in bytes) "	self whileMutableDo: [ fileSize := a64BitInteger ]</body><body package="COBlockFileSystem">fileType	" type of this file "	^ fileType</body><body package="COBlockFileSystem">fileType: a32BitInteger	" type of this file "	fileType := a32BitInteger</body><body package="COBlockFileSystem">firstBlockNumber	" number of the first data block of the file "	^ firstBlockNumber</body><body package="COBlockFileSystem">firstBlockNumber: a64BitInteger 	" number of the first data block of the file "	self whileMutableDo: [ firstBlockNumber := a64BitInteger ]</body><body package="COBlockFileSystem">increaseModificationNumber	self whileMutableDo: [ self modificationNumber: self modificationNumber + 1 ]</body><body package="COBlockFileSystem">modificationNumber	" last modification number "	^ modificationNumber</body><body package="COBlockFileSystem">modificationNumber: a32BitInteger	" last modification number "	modificationNumber := a32BitInteger</body></methods><methods><class-id>COAST.CatBFFile</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	fileNumber := 0.	firstBlockNumber := 0.	fileType := 0.	fileSize := 0.	modificationNumber := 0.</body></methods><methods><class-id>COAST.CatBFFile</class-id> <category>testing</category><body package="COBlockFileSystem">isBlob	^ self fileType = self class fileTypeBlob</body><body package="COBlockFileSystem">isCluster	^ self fileType = self class fileTypeCluster</body><body package="COBlockFileSystem">isSpecialFile	^ self fileNumber &gt;= self class specialFileMinNumber</body><body package="COBlockFileSystem">isStored	^ self firstBlockNumber &gt; 0</body><body package="COBlockFileSystem">isUnknownFileType	^ self isSpecialFile not and: [ self isCluster not and: [ self isBlob not ]]</body></methods><methods><class-id>COAST.CatBFFile</class-id> <category>private</category><body package="COBlockFileSystem">fileString	| s |	self isSpecialFile		ifTrue: [ ^ self class specialFileNames at: self fileNumber ifAbsent: [ self error: 'Unknown special file type ', self fileNumber printString ]].	s := self fileNumber printString.	self fileType = self class fileTypeCluster		ifTrue: [ ^ s, CatMAMarshallBinary clusterExtension ].	self fileType = self class fileTypeBlob		ifTrue: [ ^ s, CatMAMarshallBinary blobExtension ].	^ self error: 'Unknown file type of file ', s, ': ', self fileType printString.</body><body package="COBlockFileSystem">magicNumber	" 'CoastFle'  coastAs64BitNumber"	^ 16r436F617374466C65</body></methods><methods><class-id>COAST.CatBFFile</class-id> <category>printing</category><body package="COBlockFileSystem">printOn: aStream	[		aStream nextPutAll: self fileString	] on: Error do: [ : ex |		aStream nextPutAll: 'File '.		aStream nextPutAll: self fileNumber printString.		aStream nextPutAll: ' (Unknown file type)'	].	aStream nextPutAll: ' (modNumber: '.	self modificationNumber printOn: aStream.	aStream nextPutAll: ', first block: '.	self firstBlockNumber printOn: aStream.	aStream nextPutAll: ', size: '.	self fileSize printOn: aStream.	aStream nextPut: $).	^ aStream contents</body></methods><methods><class-id>COAST.CatBFFile</class-id> <category>repair / recovery</category><body package="COBlockFileSystem">quickCheck	fileSize &gt; 0		ifTrue: [ 			firstBlockNumber = 0				ifTrue: [ self error: 'File "', self displayString, '" is not assigned to a block, but is not empty' ].			modificationNumber = 0				ifTrue: [ self error: 'File "', self displayString, '" has an invalid modification number' ].		].</body></methods><methods><class-id>COAST.CatBFFile</class-id> <category>marshalling</category><body package="COBlockFileSystem">readFrom: aStream	[		self fileNumber: aStream nextOptimizedUnsigned64.		self fileType: aStream next.		self firstBlockNumber: aStream nextOptimizedUnsigned64.		self modificationNumber: aStream nextOptimizedUnsigned64.		self fileSize: aStream nextOptimizedUnsigned64.	] on: EndOfStreamNotification do: [ : ex |		self error: 'Unexpected end of stream'.	].	self quickCheck.</body><body package="COBlockFileSystem">writeOn: aStream	self quickCheck.	aStream nextOptimizedUnsigned64Put: self fileNumber.	aStream nextPut: self fileType.	aStream nextOptimizedUnsigned64Put: self firstBlockNumber.	aStream nextOptimizedUnsigned64Put: self modificationNumber.	aStream nextOptimizedUnsigned64Put: self fileSize.</body></methods><methods><class-id>COAST.CatBFFile class</class-id> <category>instance creation</category><body package="COBlockFileSystem">blob: fileNumber	" new blob file, not yet stored "	^ self fileNumber: fileNumber fileType: self fileTypeBlob</body><body package="COBlockFileSystem">cluster: fileNumber	" new cluster file, not yet stored "	^ self fileNumber: fileNumber fileType: self fileTypeCluster</body><body package="COBlockFileSystem">fileNumber: fileNumber fileType: fileType	" new file, not yet stored "	^ self new		fileNumber: fileNumber;		fileType: fileType;		yourself</body><body package="COBlockFileSystem">new	^ super new initialize</body><body package="COBlockFileSystem">readFrom: aStream	^ self new		readFrom: aStream;		yourself</body></methods><methods><class-id>COAST.CatBFFile class</class-id> <category>private</category><body package="COBlockFileSystem">errorSignal	^ CatBFError</body></methods><methods><class-id>COAST.CatBFFile class</class-id> <category>constants</category><body package="COBlockFileSystem">fileTypeBlob	^ 2</body><body package="COBlockFileSystem">fileTypeCluster	^ 1</body><body package="COBlockFileSystem">fileTypeIndexIni	^ 4</body><body package="COBlockFileSystem">fileTypeVolumeIni	^ 3</body><body package="COBlockFileSystem">indexIniFileNumber		^ self specialFileMinNumber + 2</body><body package="COBlockFileSystem">maxStructSize	" size (in bytes) of a serialized file structure "	^ 4*9+1</body><body package="COBlockFileSystem">specialFileMinNumber	" min file number of special files. special files have the highest bit set "	^ 16r8000000000000000</body><body package="COBlockFileSystem">specialFileNames	| d |	d := Dictionary new.	d at: self indexIniFileNumber put: 'index.ini'.	d at: self volumeIniFileNumber put: 'volume.ini'.	^ d</body><body package="COBlockFileSystem">volumeIniFileNumber		^ self specialFileMinNumber + 1</body></methods><methods><class-id>COAST.CatBFFile class</class-id> <category>testing</category><body package="COBlockFileSystem">isSpecialFileNumber: fileNumber 	^ fileNumber &gt;= self specialFileMinNumber</body></methods><methods><class-id>COAST.CatBFBlock</class-id> <category>comparing</category><body package="COBlockFileSystem">= anotherBlock	^ self class = anotherBlock class		and: [ self blockNumber = anotherBlock blockNumber ]</body><body package="COBlockFileSystem">hash	^ self blockNumber hash</body></methods><methods><class-id>COAST.CatBFBlock</class-id> <category>accessing</category><body package="COBlockFileSystem">blockNumber	" number of the block (1-based) "	^ blockNumber</body><body package="COBlockFileSystem">blockNumber: a64BitInteger	" number of the block (1-based) "	blockNumber := a64BitInteger.	self markDirty.</body><body package="COBlockFileSystem">blockSize	" size of the block (with headers) "	" (redundant information) "	^ blockSize</body><body package="COBlockFileSystem">blockSize: a32BitInteger	" size of the block (with headers) "	" (redundant information) "	blockSize := a32BitInteger.	self markDirty.</body><body package="COBlockFileSystem">dataSize	" actual data size (data size + header size &lt;= block size) "	^ dataSize</body><body package="COBlockFileSystem">dataSize: a32BitInteger	" actual data size (data size + header size &lt;= block size) "	dataSize := a32BitInteger.	self markDirty.</body><body package="COBlockFileSystem">endPosition	" byte position (1-based) of the end of the actually used data of the block within the file, or 0 if nor part of a file "	^ self fileBlockIndex &gt; 0 		ifTrue: [ (self fileBlockIndex - 1) * self maxDataSize + self dataSize ]		ifFalse: [ 0 ]</body><body package="COBlockFileSystem">fileBlockIndex	" index of the block within the collection of blocks of a file (1-based) "	^ fileBlockIndex</body><body package="COBlockFileSystem">fileBlockIndex: anInteger	" index of the block within the collection of blocks of a file (1-based) "	fileBlockIndex := anInteger.	self markDirty.</body><body package="COBlockFileSystem">fileNumber	" number of the file this block belongs to "	" (redundant information) "	^ fileNumber</body><body package="COBlockFileSystem">fileNumber: a64BitInteger	" number of the file this block belongs to "	" (redundant information) "	fileNumber := a64BitInteger.	self markDirty.</body><body package="COBlockFileSystem">fileType	" type of this file "	" (redundant information) "	^ fileType</body><body package="COBlockFileSystem">fileType: a32BitInteger	" type of this file "	" (redundant information) "	fileType := a32BitInteger.	self markDirty.</body><body package="COBlockFileSystem">maxDataSize	" max. number of bytes that can be stored "	^ self blockSize - self class headerSize</body><body package="COBlockFileSystem">maxPosition	" byte position (1-based) of the end of the block within the file, or 0 if nor part of a file "	^ self fileBlockIndex &gt; 0 		ifTrue: [ self fileBlockIndex * self maxDataSize ]		ifFalse: [ 0 ]</body><body package="COBlockFileSystem">minPosition	" byte position (1-based) of the beginning of the block data within the file, or 0 if not part of a file "	^ self fileBlockIndex &gt; 0 		ifTrue: [ (self fileBlockIndex - 1) * self maxDataSize + 1 ]		ifFalse: [ 0 ]</body><body package="COBlockFileSystem">modificationNumber	" last modification number "	^ modificationNumber</body><body package="COBlockFileSystem">modificationNumber: a32BitInteger	" last modification number "	modificationNumber := a32BitInteger.	self markDirty.</body><body package="COBlockFileSystem">nextBlockNumber	" number of the the next block of the file (0 if this is the last block) "	^ nextBlockNumber</body><body package="COBlockFileSystem">nextBlockNumber: a64BitInteger	" number of the the next block of the file (0 if this is the last block) "	nextBlockNumber := a64BitInteger.	self markDirty.</body></methods><methods><class-id>COAST.CatBFBlock</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	blockNumber  := 0.	fileNumber  := 0.	nextBlockNumber := 0.	blockSize := 0.	dataSize := 0.	modificationNumber := 0.	fileBlockIndex := 0.	fileType := 0.	self markClean.</body></methods><methods><class-id>COAST.CatBFBlock</class-id> <category>private</category><body package="COBlockFileSystem">magicNumber	" 'CoastBlk' coastAs64BitNumber "	^ 16r436F617374426C6B</body><body package="COBlockFileSystem">markClean	needsWriteBack := false.</body><body package="COBlockFileSystem">markDirty	needsWriteBack := true.</body></methods><methods><class-id>COAST.CatBFBlock</class-id> <category>testing</category><body package="COBlockFileSystem">isLastBlock	^ self nextBlockNumber = self class lastBlockNumber</body><body package="COBlockFileSystem">needsWriteBack	^ needsWriteBack</body></methods><methods><class-id>COAST.CatBFBlock</class-id> <category>marshalling</category><body package="COBlockFileSystem">emptyBlockBytes	"empty block (blank data)"	| bytes |	bytes := self class tmpEmptyBytesNeededOfSize: self blockSize.	self writeHeaderInto: bytes.	^ bytes</body><body package="COBlockFileSystem">headerBytes	| bytes |	bytes := self class tmpHeaderBytesNeeded.	self writeHeaderInto: bytes.	^ bytes</body><body package="COBlockFileSystem">readHeaderFrom: aStream	| num |	[		self magicNumber = (num := aStream nextUnsigned64)			ifFalse: [ ^ CatBFBadBlockError raiseSignal: 'Magic number expected, found ', num printString ].		self blockNumber: aStream nextUnsigned64.		self nextBlockNumber: aStream nextUnsigned64.		self blockSize: aStream nextUnsigned32.		self dataSize: aStream nextUnsigned32.		self modificationNumber: aStream nextUnsigned32.		self fileNumber: aStream nextUnsigned64.		self fileBlockIndex: aStream nextUnsigned32.		self fileType: aStream nextUnsigned32.	] on: EndOfStreamNotification do: [ : ex |		self error: 'Unexpected end of stream'.	].</body><body package="COBlockFileSystem">writeHeaderInto: byteArray 	self magicNumber nextUnsigned64On: byteArray after: 0.	self blockNumber nextUnsigned64On: byteArray after: 8.	self nextBlockNumber nextUnsigned64On: byteArray after: 16.	self blockSize nextFull32On: byteArray after: 24.	self dataSize nextFull32On: byteArray after: 28.	self modificationNumber nextFull32On: byteArray after: 32.	self fileNumber nextUnsigned64On: byteArray after: 36.	self fileBlockIndex nextFull32On: byteArray after: 44.	self fileType nextFull32On: byteArray after: 48.</body></methods><methods><class-id>COAST.CatBFBlock</class-id> <category>printing</category><body package="COBlockFileSystem">printOn: aStream	aStream nextPutAll: 'block: '.	self blockNumber printOn: aStream.	aStream nextPutAll: ', next: '.	self nextBlockNumber printOn: aStream.	aStream nextPutAll: ', size: '.	self dataSize printOn: aStream.	aStream nextPutAll: ', file: '.	self fileNumber printOn: aStream.	aStream nextPutAll: ', modNumber: '.	self modificationNumber printOn: aStream.</body></methods><methods><class-id>COAST.CatBFBlock class</class-id> <category>instance creation</category><body package="COBlockFileSystem">blockNumber: a64BitInteger blockSize: a32BitInteger	" create a new, unassigned block "	^ self new		blockNumber: a64BitInteger;		blockSize: a32BitInteger;		yourself</body><body package="COBlockFileSystem">new	^ super new initialize</body><body package="COBlockFileSystem">readHeaderFrom: aStream 	^ ( self new )		readHeaderFrom: aStream;		yourself</body></methods><methods><class-id>COAST.CatBFBlock class</class-id> <category>private</category><body package="COBlockFileSystem">errorSignal	^ CatBFError</body><body package="COBlockFileSystem">tmpEmptyBytesNeededOfSize: blockSize 	( tmpEmptyBytes isNil or: [ tmpEmptyBytes size ~= blockSize ]) ifTrue: [ tmpEmptyBytes := ByteArray new: blockSize ].	^ tmpEmptyBytes</body><body package="COBlockFileSystem">tmpHeaderBytesNeeded	tmpHeaderBytes isNil ifTrue: [ tmpHeaderBytes := ByteArray new: self headerSize ].	^ tmpHeaderBytes</body></methods><methods><class-id>COAST.CatBFBlock class</class-id> <category>constants</category><body package="COBlockFileSystem">headerSize	" total size of headers "	^ 52	"(4*8) + (5*4)"</body><body package="COBlockFileSystem">lastBlockNumber	^ 0</body></methods><methods><class-id>COAST.CatBFFreeBlockListSegment</class-id> <category>testing</category><body package="COBlockFileSystem">dirty	^ dirty</body><body package="COBlockFileSystem">dirty: isDirty 	^ dirty := isDirty</body></methods><methods><class-id>COAST.CatBFFreeBlockListSegment</class-id> <category>private</category><body package="COBlockFileSystem">freeBlocks	^ freeBlocks</body><body package="COBlockFileSystem">freeBlocks: newFreeBlocks 	newFreeBlocks isEmpty ifTrue: [ self error: 'empty free block list segment' ].	freeBlocks := newFreeBlocks</body><body package="COBlockFileSystem">moveFreeBlocksTo: newSegment 	| index |	newSegment dirty: true.	index := freeBlocks size // 2.	newSegment freeBlocks: ( freeBlocks copyFrom: 1 to: index ).	self freeBlocks: ( freeBlocks copyFrom: 1 + index to: freeBlocks size )</body></methods><methods><class-id>COAST.CatBFFreeBlockListSegment</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	freeBlocks := SortedCollection new.	dirty := true</body></methods><methods><class-id>COAST.CatBFFreeBlockListSegment</class-id> <category>accessing</category><body package="COBlockFileSystem">addBlockNumber: blockNumber for: segmentedList 	^ self addBlockNumber: blockNumber for: segmentedList  warnIfAlreadyFree: true</body><body package="COBlockFileSystem">addBlockNumber: blockNumber for: segmentedList warnIfAlreadyFree: warnIfAlreadyFree 	( self isFree: blockNumber ) 		ifTrue: 		[	warnIfAlreadyFree 				ifTrue: [ CoastLog logWarning: 'Block ' , blockNumber printString , ' was already added to the free list' ]		]		ifFalse: 		[	dirty := true.			freeBlocks add: blockNumber.			freeBlocks size &gt; self class maxNumbersPerSegment 				ifTrue: [ segmentedList splitSegment: self ]		].</body><body package="COBlockFileSystem">isFree: blockNumber 	^ freeBlocks fastIncludes: blockNumber</body><body package="COBlockFileSystem">maxNumber	" get the max number of a free block of this segment. returns nil if the segment is empty"	^ freeBlocks isEmpty 		ifTrue: [ nil ]		ifFalse: [ freeBlocks last ]</body><body package="COBlockFileSystem">numberOfFreeBlocks	^ freeBlocks size</body><body package="COBlockFileSystem">removeBlockNumber: blockNumber for: segmentedList 	freeBlocks remove: blockNumber ifAbsent: [ self error: 'Block ' , blockNumber printString , ' is not on the free list' ].	freeBlocks isEmpty 		ifTrue: [ segmentedList removeSegment: self ]		ifFalse: [ dirty := true ]</body></methods><methods><class-id>COAST.CatBFFreeBlockListSegment</class-id> <category>printing</category><body package="COBlockFileSystem">printOn: stream 	super printOn: stream.	dirty ifTrue: [ stream nextPut: $* ].	stream nextPut: $(.	freeBlocks notEmpty ifTrue: 		[	freeBlocks first printOn: stream.			stream nextPut: $-.			freeBlocks last printOn: stream		].	stream nextPut: $)</body></methods><methods><class-id>COAST.CatBFFreeBlockListSegment</class-id> <category>marshalling</category><body package="COBlockFileSystem">readFrom: aStream 	| numFreeBlocks tempFreeBlocks targetPos |	targetPos := aStream position +  self class storageSize.	numFreeBlocks := aStream nextUnsigned16.	tempFreeBlocks := Array new: numFreeBlocks.	( 1 to: numFreeBlocks ) do: [: idx | tempFreeBlocks at: idx put: aStream nextOptimizedUnsigned64 ].	freeBlocks := SortedCollection new: numFreeBlocks.	freeBlocks addAllWithoutSorting: tempFreeBlocks.	aStream position: targetPos.	dirty := false</body><body package="COBlockFileSystem">writeOn: aStream 	| targetPos |	targetPos := aStream position +  self class storageSize.	aStream nextUnsigned16Put: freeBlocks size.	freeBlocks do: [: blockNum | aStream nextOptimizedUnsigned64Put: blockNum ].	aStream next: targetPos - aStream position  put: 0.	dirty := false</body></methods><methods><class-id>COAST.CatBFFreeBlockListSegment class</class-id> <category>private</category><body package="COBlockFileSystem">errorSignal	^ CatBFError</body><body package="COBlockFileSystem">maxNumbersPerSegment	^ 511	"4096 - 2 // 8"</body><body package="COBlockFileSystem">storageSize	" Passend zur BuffergrÃ¶Ãe eines ExternalStreams "	"bitte mit maxNumbersPerSegment gemeinsam anpassen"	^ 4096</body></methods><methods><class-id>COAST.CatBFFreeBlockListSegment class</class-id> <category>initialize-release</category><body package="COBlockFileSystem">new	^ super new initialize</body><body package="COBlockFileSystem">readFrom: aStream 	^ ( self new )		readFrom: aStream;		yourself</body></methods><methods><class-id>COAST.CatBFFileLock</class-id> <category>public</category><body package="COBlockFileSystem">getLock	self checkLockInfo.	self forceLock</body><body package="COBlockFileSystem">hasLock	^ lockStream notNil</body><body package="COBlockFileSystem">infoString: aString	| s |	s := aString ifNil: [ '' ].	infoString := s.	infoDict at: #infoString put: s.</body><body package="COBlockFileSystem">isLockedByOtherProcess	^ lockStream isNil and: [ super isLockedByOtherProcess ]</body><body package="COBlockFileSystem">maintenanceNeeded: aString	infoDict at: #maintenance put: aString.	self writeLockInfoOn: lockStream.</body><body package="COBlockFileSystem">releaseLock	self hasLock		ifTrue: [ 			self releaseLockStream.			fileName asFilename delete		].</body><body package="COBlockFileSystem">releaseLockStream	lockStream notNil 		ifTrue: 		[	lockStream position: 0.			[ lockStream ioConnection input lock: false for: 1 ] 				on: Error				do: [: ex | ].			lockStream close.			lockStream := nil		].</body><body package="COBlockFileSystem">storedInfoString	| dict |	^ self hasLock 		ifTrue: [ self printInfoDict: infoDict ]		ifFalse: 		[	fileName exists				ifTrue: 				[	dict := self getStoredInfoDict.					dict notNil						ifTrue: [ self printInfoDict: dict ]						ifFalse: [ '(lock file could not be parsed, no info available)' ]				]				ifFalse: [ '(lock file not found, no info available)' ]		]</body></methods><methods><class-id>COAST.CatBFFileLock</class-id> <category>private</category><body package="COBlockFileSystem">checkLockInfo	| dict maintenance info |	dict := self hasLock 			ifTrue: [ infoDict ]			ifFalse: 			[	fileName exists 					ifTrue: 					[							[ self getStoredInfoDict ] 							on: CatBFLockError							do: 							[: ex |								" wird dann spÃ¤ter bei forceLock knallen "								nil							]					]					ifFalse: [ nil ]			].	dict notNil		ifTrue: [			( maintenance := dict at: #maintenance ifAbsent: [ nil ]) notNil				ifTrue: [ CatBFLockMaintenanceError raiseSignal: 'Maintenance required: ' , maintenance ].			(info := dict at: #infoString ifAbsent: [ nil ]) notNil 				ifTrue: [					info ~= infoString 						ifTrue: [ CatBFLockInfoError raiseSignal: 'Locked by: "' , info, '"' ]						ifFalse: [ CoastLog logWarning: 'Lock info matches current info, reincarnation possible ' ].				].		].</body><body package="COBlockFileSystem">checkLockStreams	ExternalStream.OpenStreams do: 		[: str | | io msg |			(( str isKindOf: BufferedExternalStream ) 				and: [(( io := str ioConnection ) isKindOf: FileConnection ) and: [ io fileName asFilename = fileName asFilename ]]) 				ifTrue: 				[	msg := 'Internal lock file already opened: ' , fileName asString.					CatBFLockError raiseSignal: msg				]		].</body><body package="COBlockFileSystem">forceLock	[	self checkLockStreams.		lockStream := fileName asFilename readWriteStream text.		" Locken. wenn ein anderer Prozess den Stream gelocked hat, wird ein Fehler geworfen.		Unter Unix kann man das gelockte File aber evtl. trotzdem lÃ¶schen "		lockStream position: 0.		lockStream ioConnection input lock: true for: 1.		self writeLockInfoOn: lockStream.	] 		on: Error		do: 		[: ex |			lockStream notNil 				ifTrue: 				[	lockStream close.					lockStream := nil				].			CatBFLockError raiseSignal: 'Could not force lock: ' , ex description		].</body><body package="COBlockFileSystem">getStoredInfoDict	^ [		| ini dict default |		ini := CoastIniAccess readFile: fileName.		default := (ini category: nil).		dict := Dictionary new.		default notNil ifTrue: [ default keysDo: [ : k | dict at: k asSymbol put: (ini at: k) ]].		dict	] on: Error do: [ : ex |		CatBFLockError raiseSignal: 'Could not parse lock file info: ', ex description.		nil	].</body><body package="COBlockFileSystem">printInfoDict: dict 	| str |	str := String new writeStream.	str nextPutAll: ( dict at: #infoString ifAbsent: [ '' ]).	str nextPutAll: '; '.	( dict keys asSortedCollection copyWithout: #infoString ) 		do: 		[: key |			str nextPutAll: key asString.			str nextPutAll: '='.			str nextPutAll: ( dict at: key ) asString		]		separatedBy: [ str nextPutAll: '; ' ].	^ str contents</body><body package="COBlockFileSystem">writeLockInfoOn: stream 	| ini |	ini := CoastIniAccess new.	infoDict keysAndValuesDo: [ : k : v |		ini at: k asString put: v displayString.	].	stream reset.	ini writeTo: stream.	stream flush</body></methods><methods><class-id>COAST.CatBFFileLock</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	super initialize.	infoDict := Dictionary new.	infoDict at: #timestamp put: Timestamp now coastShortPrintString.	infoDict at: #process put: OSHandle currentProcessID printString.</body></methods><methods><class-id>COAST.CatRMLoggedTransactionAgenda</class-id> <category>accessing</category><body package="COTransactions">addFailReason: aFailReason	failReasons isNil ifTrue: [ failReasons := OrderedCollection new ].	failReasons add: aFailReason</body><body package="COTransactions">agenda	^agenda</body><body package="COTransactions">agenda: aCatRMSimpleAgenda	agenda := aCatRMSimpleAgenda</body><body package="COTransactions">clusterID	^transactionID clusterLocator id</body><body package="COTransactions">failReasons	^failReasons</body><body package="COTransactions">flags	^ flags ifNil: [ 0 ]</body><body package="COTransactions">flags: smallInteger 	flags := smallInteger.</body><body package="COTransactions">hasFlagPattern: flagPattern 	^ flags notNil and: [ 0 ~~ ( flags bitAnd: flagPattern )]</body><body package="COTransactions">logConcurrencyFail: block 	( self hasFlagPattern: CoastConstant noConcurrencyNag ) ifFalse: [ CoastLog log: block channel: #concurrency ].</body><body package="COTransactions">logFailReasons 	failReasons isNil ifFalse:	[		( self hasFlagPattern: CoastConstant noConcurrencyNag ) ifFalse: [		CoastLog log: [ 	| stream |			stream := String new writeStream.			stream nextPutAll: 'Transaction failed: '.			transactionID printShortOn: stream.			stream nextPutAll: ' '.			failReasons do: [ : fr |  fr printOn: stream ] separatedBy: [ stream nextPutAll: ', ' ].			stream contents 		] channel: #concurrency ].	].</body><body package="COTransactions">rollForwardLastWishFor: clusterManager 	"this is VERY basic - only use for last wish transactions (as the selector might give a hint :P)"	| clusterController |	clusterController := ( clusterManager getCluster: self transactionID clusterLocator id ) clusterController.	agenda rollForwardForClusterController: clusterController.	clusterController modified: true.</body><body package="COTransactions">setFlagPattern: pattern 	self flags: ( self flags bitOr: pattern ).</body><body package="COTransactions">transactionID	^transactionID</body><body package="COTransactions">transactionID: aCatRMTransactionID	transactionID := aCatRMTransactionID</body><body package="COTransactions">wouldAcceptLastWishFor: clusterManager 	"this is VERY basic	last wishes will only be executed without any connected clients	nevertheless, check the agenda"	| clusterController |	clusterController :=		[( clusterManager getCluster: self transactionID clusterLocator id ) clusterController ] on: ClusterNotFoundError			do: 			[: cnf |				CoastLog log: 'invalid cluster detected in last wish ' , self printString.				^ false			].	( agenda hasValidSlotCreationsForClusterController: clusterController loggedAgenda: self ) ifFalse: 		[	CoastLog log: 'Conflict detected in last wish ' , self printString.			^ false		].	( agenda passesSanityCheckForCC: clusterController ) ifFalse: 		[	CoastLog log: 'Transaction sanity check failed for last wish ' , self transactionID printString.			^ false		].	^ true</body></methods><methods><class-id>COAST.CatRMLoggedTransactionAgenda</class-id> <category>testing</category><body package="COTransactions">isEmpty	^ self agenda isEmpty</body><body package="COTransactions">isReadOnly	^ self agenda isReadOnly</body></methods><methods><class-id>COAST.CatRMLoggedTransactionAgenda</class-id> <category>printing</category><body package="COTransactions">printClientDescriptionOn: aStream	transactionID printClientDescriptionOn: aStream</body><body package="COTransactions">printOn: aStream	transactionID printOn: aStream</body></methods><methods><class-id>COAST.CatRMLoggedTransactionAgenda</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	transactionID marshallBinaryTo: aStream marshaller: aCatRMMarshall.	aStream nextOptimized32Put: self flags.	self agenda marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COTransactions">unmarshallAgendaFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	self transactionID: ( CatRMTransactionID new unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ).	( aCatRMMarshall loadCoastVersion isMin: 5 minor: 3 ) ifTrue: [ self flags: aStream nextOptimized32 ].	aCatRMMarshall volumeManager: aCatCSVolumeManager volume: transactionID clusterLocator volume.	self agenda: ( CatRMSimpleAgenda new unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ).</body></methods><methods><class-id>COAST.CatRMLoggedTransactionAgenda class</class-id> <category>instance creation</category><body package="COTransactions">transaction: transaction inClusterController: cc 	| newTID newLoggedAgenda |	newTID := cc nextTransactionID.	newLoggedAgenda := CatRMLoggedTransactionAgenda new.	newLoggedAgenda transactionID: newTID.	newLoggedAgenda agenda: ( transaction combinedAgenda simpleAgendaForCluster: cc cluster ).	( transaction transactionContextAt: #coastAgendaFlags ifAbsent: [ nil ]) 		ifNotNil: [: mvdict | ( mvdict atKey: cc clusterID ) do: [: pattern | newLoggedAgenda setFlagPattern: pattern ]].	^ newLoggedAgenda</body></methods><methods><class-id>COAST.CatCSPreparedAgenda</class-id> <category>private</category><body package="COTransactions">createdCellsPerCluster	createdCellsPerCluster isNil 		ifTrue: 		[	createdCellsPerCluster := Dictionary new.			self unpreparedAgenda createdCellsDo:				[: createdCell | | clusterID |					( createdCell notNil and: [( clusterID := createdCell clusterID ) notNil ]) 						ifTrue: [( createdCellsPerCluster at: clusterID ifAbsentPut: [ OrderedCollection new ]) add: createdCell ]				]		].	^ createdCellsPerCluster</body><body package="COTransactions">prepareSimpleAgendaForCluster: aCatCSCluster 	"Returns a prepared simple agenda which contains only accesses to the given cluster"	| simpleAgenda wa ra cc |	simpleAgenda := self unpreparedAgenda unpreparedSimpleAgendaForCluster: aCatCSCluster.	simpleAgenda prepareAccesses.	ra := self readAccessesPerCluster at: aCatCSCluster id ifAbsent: [ #( )].	ra do: [: a | simpleAgenda addReadAccess: a ].	wa := self writeAccessesPerCluster at: aCatCSCluster id ifAbsent: [ #( )].	wa do: [: a | simpleAgenda addWriteAccess: a ].	cc := self createdCellsPerCluster at: aCatCSCluster id ifAbsent: [ #( )].	cc do: [: c | simpleAgenda addCreatedCell: c ].	self unpreparedAgenda removedSlots do: [: slot | slot frame cluster == aCatCSCluster ifTrue: [ simpleAgenda addRemovedSlot: slot ]].	self unpreparedAgenda removedFrames do: [: aFrame | aFrame cluster == aCatCSCluster ifTrue: [ simpleAgenda addRemovedFrame: aFrame ]].	simpleAgenda isPrepared: true.	^ simpleAgenda</body><body package="COTransactions">preparedSimpleAgendas	^ preparedSimpleAgendas ifNil: [ preparedSimpleAgendas := Dictionary new ]</body><body package="COTransactions">readAccessesPerCluster	readAccessesPerCluster isNil 		ifTrue: 		[	readAccessesPerCluster := Dictionary new.			self unpreparedAgenda readAccessesDo: 				[: access | | cluster |					( access notNil and: [( cluster := access cellCluster ) notNil ]) 						ifTrue: [( readAccessesPerCluster at: cluster clusterID ifAbsentPut: [ OrderedCollection new ]) add: access ]				]		].	^ readAccessesPerCluster</body><body package="COTransactions">unpreparedAgenda: aUnpreparedAgenda 	unpreparedAgenda := aUnpreparedAgenda.</body><body package="COTransactions">writeAccessesPerCluster	writeAccessesPerCluster isNil ifTrue: 		[	writeAccessesPerCluster := Dictionary new.			self unpreparedAgenda writeAccessesDo: 				[: access | | cluster |					( cluster := access cellCluster ) notNil 						ifTrue: [( writeAccessesPerCluster at: cluster clusterID ifAbsentPut: [ OrderedCollection new ]) add: access ]				]		].	^ writeAccessesPerCluster</body></methods><methods><class-id>COAST.CatCSPreparedAgenda</class-id> <category>accessing</category><body package="COTransactions">simpleAgendaForCluster: aCatCSCluster 	"Returns a prepared simple agenda which contains only accesses to the given cluster"	^ self preparedSimpleAgendas at: aCatCSCluster ifAbsentPut: [ self prepareSimpleAgendaForCluster: aCatCSCluster ]</body><body package="COTransactions">unpreparedAgenda	^ unpreparedAgenda</body></methods><methods><class-id>COAST.CatCSPreparedAgenda class</class-id> <category>instance creation</category><body package="COTransactions">unpreparedAgenda: aUnpreparedAgenda 	^ ( self new ) unpreparedAgenda: aUnpreparedAgenda;		yourself</body></methods><methods><class-id>COAST.TransactionPolicy</class-id> <category>accessing</category><body package="COTransactions">isFastRead	^ isFastRead ifNil: [ false ]</body><body package="COTransactions">isFastRead: aBoolean 	isFastRead := aBoolean.</body><body package="COTransactions">transactionManager	^ transactionManager</body><body package="COTransactions">transactionManager: aTransactionManager 	transactionManager := aTransactionManager.</body></methods><methods><class-id>COAST.TransactionPolicy</class-id> <category>api</category><body package="COTransactions">discreteTransactionDo: aBlock	" Der Block soll in einer Transaktion ausgefÃ¼hrt werden. 	Er enhÃ¤lt keine weiteren Transaktionsaufrufe, ausgenommen bestTransactionDo:.	Darf nicht durch #enclosingTransactionDo: gekapselt werden	aBlock kann ein optionales Argument, die aktive Transaktion, haben		instances := policy discreteTransactionDo: [ concept instances ].		policy enclosingTransactionDo: [			instances do: [ : instance |				policy embeddedTransactionDo: [					instance isolateWithDeleteContext.				].			]		].	"	^ self transactionManager transactionDo: aBlock</body><body package="COTransactions">discreteTransactionDo: aBlock onFailure: aFailureBlock 	" wie discreteTransactionDo: , es wird aber noch der failure block ausgefÃ¼hrt.		Achtung:		Wenn die Transaktion eingebettet ist, wird der Failureblock eventuell erst viel spÃ¤ter ausgefÃ¼hrt  "	^ self transactionManager pessimisticTransactionDo: aBlock onFailure: aFailureBlock</body><body package="COTransactions">embeddedTransactionDo: aBlock	" Der Block soll in einer Transaktion ausgefÃ¼hrt werden. 	Er enhÃ¤lt keine weiteren Transaktionsaufrufe, ausgenommen #embeddedTransactionDo:.	Muss in einen Aufruf von #enclosingTransactionDo: gekapselt sein	aBlock kann ein optionales Argument, die aktive Transaktion, haben 		instances := policy discreteTransactionDo: [ concept instances ].		policy enclosingTransactionDo: [			instances do: [ : instance |				policy embeddedTransactionDo: [					instance isolateWithDeleteContext.				].			]		].	"	self subclassResponsibility</body><body package="COTransactions">embeddedTransactionDo: aBlock onFailure: aFailureBlock	" wie #embeddedTransactionDo:, zusÃ¤tzlich mit FailureBlock, der bei Transaktionsabbruch ausgefÃ¼hrt wird "	self subclassResponsibility</body><body package="COTransactions">enclosingTransactionDo: aBlock	" Der Block umfasst potentiell mehrere Aufrufe von #embeddedTransactionDo.	Wie diese auf Transaktionen verteilt werden entscheidet die Policy.	aBlock darf kein Argument haben 		instances := policy discreteTransactionDo: [ concept instances ].		policy enclosingTransactionDo: [			instances do: [ : instance |				policy embeddedTransactionDo: [					instance isolateWithDeleteContext.				].			]		].	"	self subclassResponsibility</body><body package="COTransactions">enclosingTransactionDo: aBlock onFailure: aFailureBlock	" wie #enclosingTransactionDo:, zusÃ¤tzlich mit FailureBlock, der bei Transaktionsabbruch ausgefÃ¼hrt wird "	self subclassResponsibility</body></methods><methods><class-id>COAST.TransactionPolicy</class-id> <category>private</category><body package="COTransactions">nonNestedEmbeddedTransactionDo: aTransactionBlock nestedDo: aBlock 	" Evaluate the block if this is not a nested embeded transaction.	Otherwise evaluate the block with the outer transaction "	embeddedStackDepth isNil 		ifTrue: [ embeddedStackDepth := 0 ].	^ embeddedStackDepth = 0 		ifTrue: 		[	embeddedStackDepth := embeddedStackDepth + 1.			[ aTransactionBlock cull: self transactionManager activeTransaction ] ensure: [ embeddedStackDepth := embeddedStackDepth - 1 ]		]		ifFalse: [ aBlock cull: self transactionManager activeTransaction ]</body></methods><methods><class-id>COAST.TransactionPolicy class</class-id> <category>instance creation</category><body package="COTransactions">transactionManager: aTransactionManager 	^ self new 		transactionManager: aTransactionManager;		yourself</body><body package="COTransactions">transactionManager: aTransactionManager isFastRead: fastRead	^ self new 		transactionManager: aTransactionManager;		isFastRead: fastRead;		yourself</body></methods><methods><class-id>COAST.CatCSAgenda</class-id> <category>accessing</category><body package="COTransactions">accessedUnregisteredCells	^ accessedUnregisteredCells</body><body package="COTransactions">addAccess: aCatCSCellAccess 	aCatCSCellAccess addToAgenda: self.	self clusterManager: aCatCSCellAccess clusterManager.	self recordClustersReferencedByAccess: aCatCSCellAccess.</body><body package="COTransactions">addCellCreation: aCatCSCell 	aCatCSCell isCoastFrame 		ifTrue: 		[	"only unregistered frames will be assigned to a cluster in the prepare phase"			aCatCSCell cellContainer isNil ifTrue: [ accessedUnregisteredCells at: aCatCSCell put: OrderedCollection new ]		]		ifFalse: 		[	writesPerCell notNil ifTrue: [( writesPerCell removeKey: aCatCSCell ifAbsent: [ #( )]) do: [: i | writeAccessesAndNils at: i put: nil ]].			createdCells add: aCatCSCell		].</body><body package="COTransactions">addDisplayAccess: aCatCSCellAccess 	| c |	c := aCatCSCellAccess cellCluster.	c notNil ifTrue: [self addReadCluster: c]</body><body package="COTransactions">addReadAccess: aCatCSCellAccess 	| c |	c := aCatCSCellAccess cell.	( c isCoastFrame and: [ accessedUnregisteredCells includesKey: c ]) ifFalse: [ self basicAddReadAccess: aCatCSCellAccess ].</body><body package="COTransactions">addReadCluster: cluster 	| cid unloadStrategy |	( self readClusterIDs addAndReturnOldOrNil: ( cid := cluster clusterID )) isNil ifTrue: 		[	referencedClusterIDs add: cid.			self clusterManager: cluster clusterManager.			clusterManager isNil ifTrue: [ ^ self ].			self readClusterIDs size &gt; self readClusterIDsFlushSize ifTrue: 				[	unloadStrategy := clusterManager unloadStrategy.					unloadStrategy notNil ifTrue: [ self readClusterIDs do: [: clID | unloadStrategy notifyClusterAccess: clID ]].					readClusterIDs := CatCOIntegerKeySet new: self readClusterIDsFlushSize				]		].</body><body package="COTransactions">addRemovedFrame: frame 	removedFrames add: frame.	involvedClusters add: frame cluster.</body><body package="COTransactions">addRemovedSlot: slot 	removedSlots add: slot.</body><body package="COTransactions">addWriteAccess: aCatCSCellAccess maskOld: maskOld 	" if there has been a value access to the same cell, replace it "	| key |	aCatCSCellAccess isSlotAccess ifFalse: [^self ].	key := aCatCSCellAccess cell.	writesPerCell isNil ifTrue: [ writesPerCell := MultiValueDictionary new ].	maskOld ifTrue: [( writesPerCell removeKey: key ifAbsent: [ #( )]) do: [: previousAccessIndex | writeAccessesAndNils at: previousAccessIndex put: nil ]].	self basicAddWriteAccess: aCatCSCellAccess.	writesPerCell atKey: key add: writeAccessesAndNils size.</body><body package="COTransactions">agendaSize	^simpleAgendas values inject: ( writeAccessesAndNils size + readAccesses size + createdCells size ) into: [ :sum :simpleAgenda | sum + simpleAgenda agendaSize ]</body><body package="COTransactions">clusterManager	^clusterManager</body><body package="COTransactions">clusterManagers	^clusterManager notNil		ifTrue: [ Set with: clusterManager ]		ifFalse: [ Set new ]</body><body package="COTransactions">createdCells	^ createdCells</body><body package="COTransactions">createdLocalFrames	createdLocalFrames isNil		ifTrue: [ createdLocalFrames := IdentitySet new ].	^ createdLocalFrames</body><body package="COTransactions">involvedClusters	^involvedClusters</body><body package="COTransactions">numberOfAccesses	" only valid during a transaction ! "	"note: writeAccesses could contain nils which represent accesses replaced by an later access"	^ simpleAgendas inject: writeAccessesAndNils size into: [: n : agenda | n + agenda numberOfUnpreparedAccesses ]</body><body package="COTransactions">prepareWriteAccess: aCatCSCellAccess 	" remember all arguments that are not yet prepared "	| cluster |	accessedUnregisteredCells isEmpty ifFalse: 		[	aCatCSCellAccess allArgumentsDo: 				[: arg | ( arg isCoastFrame and: [ self isUnpreparedArgument: arg ]) ifTrue: 						[ | cells |							cells := accessedUnregisteredCells at: arg ifAbsentPut: [ CoastError raiseSignal: 'Missing frame creation' ].							cells add: aCatCSCellAccess cell						]				]		].	" remember that the cluster was write-accessed "	cluster := aCatCSCellAccess cellCluster.	cluster isNil ifFalse: [ involvedClusters add: cluster ]</body><body package="COTransactions">readClusterIDs	readClusterIDs isNil ifTrue:[readClusterIDs := CatCOIntegerKeySet new].	^readClusterIDs.</body><body package="COTransactions">readClusterIDsFlushSize	"so viele readClusterIDs max. ansammeln - wenn mehr, dann gleich an die unloadStrategy weitersagen und das Set wieder leeren"	^ 4096</body><body package="COTransactions">recordLocalFrameCreation: localFrame	self createdLocalFrames add: localFrame</body><body package="COTransactions">referenceToCell: aCell 	" returns anything (access, cell ) which mentions the cell, or nil "	| accessCheckBlock |	accessCheckBlock := [: ac | ( ac cell == aCell or: [ ac arguments includes: aCell ]) ifTrue: [ ^ ac ]].	readAccesses do: accessCheckBlock.	self writeAccessesDo: accessCheckBlock.	createdCells do: [: c | c = aCell ifTrue: [ ^ c ]].	( accessedUnregisteredCells includesKey: aCell ) ifTrue: [ ^ accessedUnregisteredCells associationAt: aCell ].	^ nil</body><body package="COTransactions">removedFrames	^ ( removedFrames allSatisfy: [: frame | ( frame fastAt: #coastInternalReferencedBy ) allSatisfy: [: rFrame | removedFrames includes: rFrame ]]) 		ifTrue: [ removedFrames ]		ifFalse: [ CoastLog logDebugNotify: 'Incomplete removed temp shared frames structure'. #( )]</body><body package="COTransactions">removedSlots	^ removedSlots</body><body package="COTransactions">simpleAgendas	^ self involvedClusters collect: [: cluster | self simpleAgendaForCluster: cluster ]</body><body package="COTransactions">undoSlotCreationFor: depletedSlot 	^ createdCells remove: depletedSlot ifAbsent: [ nil ]</body><body package="COTransactions">writeAccesses	^ writeAccessesAndNils select: [: e | e notNil ]</body></methods><methods><class-id>COAST.CatCSAgenda</class-id> <category>private</category><body package="COTransactions">basicAddReadAccess: readAccess	" try to assign the readAccess to a simple agenda immediately "	| simpleAgenda cluster |	cluster := readAccess cellCluster.	cluster notNil		ifTrue: [ 			self addReadCluster: cluster.			simpleAgenda := self unpreparedSimpleAgendaForCluster: cluster.			simpleAgenda addUnpreparedReadAccess: readAccess.		] ifFalse: [ 			readAccesses add: readAccess		]</body><body package="COTransactions">basicAddWriteAccess: writeAccess	writeAccessesAndNils add: writeAccess</body><body package="COTransactions">clusterManager: aCM	| message |	aCM notNil ifTrue: [		(clusterManager notNil and: [ clusterManager ~= aCM ]) ifTrue: [			message := 'Transaction must not touch more than one volume! (', clusterManager printString, ' &lt;-&gt; ', aCM printString, ')'.			Notifier isDevelopment				ifTrue:	[ self haltOrContinue: message ]				ifFalse:	[ CoastError raiseSignal: message ].			].		clusterManager := aCM.		].</body><body package="COTransactions">createdCellsDo: aBlock	createdCells do: aBlock</body><body package="COTransactions">handleDepletes	writesPerCell isNil ifTrue: [ ^ self ].	writeAccessesAndNils keysAndValuesDo: 		[: i : access | ( access notNil and: [ access class = COAST.CatCSDepleteAccess and: [( writesPerCell at: access cell ) allSatisfy: [: j | j &lt;= i ]]]) 				ifTrue: 				[	self undoSlotCreationFor: access cell.					access cell frame coastInternalRemoveSlotNamed: access cell id.					removedSlots add: access cell					"removeSlotAccess := CatCSRemoveKeyAccess cell: access cell frame argument: access cell id.					access cell frame valueAccess: removeSlotAccess.			alternative:					self addWriteAccess: removeSlotAccess maskOld: false"				]		].</body><body package="COTransactions">isPreparedArgument: arg	^ (self isUnpreparedArgument: arg) not</body><body package="COTransactions">isUnpreparedArgument: arg	" is the argument a cell which is not yet assigned to a cluster? "	^ arg isCell and: [ arg isUnresolved not and: [ arg isShared and: [ arg cluster isNil ]]]</body><body package="COTransactions">readAccessesDo: aBlock	readAccesses do: aBlock</body><body package="COTransactions">recordClustersReferencedByAccess: aCatCSAccess 	" record all cluster IDs referenced by the access "	aCatCSAccess cellCluster ifNotNil: [: cluster | referencedClusterIDs add: cluster clusterID ].	aCatCSAccess allArgumentsDo: 		[: arg |			arg isCoastFrame 				ifTrue: [ arg cluster ifNotNil: [: cluster | referencedClusterIDs add: cluster clusterID ]]		].</body><body package="COTransactions">unpreparedSimpleAgendaForCluster: aCatCSCluster 	"Returns a simple agenda which contains only accesses to the given cluster"	^ simpleAgendas at: aCatCSCluster id ifAbsentPut: [ CatRMSimpleAgenda cluster: aCatCSCluster ]</body><body package="COTransactions">writeAccessesDo: block 	writeAccessesAndNils do: [: writeAccessOrNil | writeAccessOrNil notNil ifTrue: [ block value: writeAccessOrNil ]]</body></methods><methods><class-id>COAST.CatCSAgenda</class-id> <category>preparing</category><body package="COTransactions">fastPrepareCreatedCells	"look for created cells that have not yet any container"	"fast, because only one cluster may be involved"	| cluster |	cluster := involvedClusters detect: [ :c | true ].	accessedUnregisteredCells keysDo: [ : frame|		cluster addCell: frame.		createdCells add: frame.	].</body><body package="COTransactions">prepareCreatedCells	"look for created cells that have not yet any container"	"first look if the cell has registered in the meantime"	| cl |	self handleDepletes.	accessedUnregisteredCells keys do: 		[: frame |			frame cellContainer notNil ifTrue: 				[	accessedUnregisteredCells removeKey: frame.					createdCells add: frame.					( cl := frame cluster ) isNil ifFalse: [ involvedClusters add: cl ]				]		].	self involvedClusters size = 1 		ifTrue: [ self fastPrepareCreatedCells ]		ifFalse: [ self slowPrepareCreatedCells ].</body><body package="COTransactions">preparedAgenda	preparedAgenda isNil 		ifTrue: [ preparedAgenda := CatCSPreparedAgenda unpreparedAgenda: self ].	^ preparedAgenda</body><body package="COTransactions">slowPrepareCreatedCells	"look for created cells that have not yet any container"	"slow, because any cluster may be involved"	| before |	before := accessedUnregisteredCells size.	accessedUnregisteredCells isEmpty ifTrue: [^self].		accessedUnregisteredCells keys do: [ : unregisteredFrame| | referringCells cellWithCluster |		" find an access with a registered cell to the unregistered cell "		referringCells := accessedUnregisteredCells at: unregisteredFrame ifAbsent: [ nil ].		referringCells notNil ifTrue:		[				cellWithCluster := referringCells detect: [ :rc | rc cluster notNil ] ifNone: [ nil ].			cellWithCluster notNil ifTrue:			[				accessedUnregisteredCells removeKey: unregisteredFrame.				cellWithCluster cluster addCell: unregisteredFrame.				createdCells add: unregisteredFrame.			]		].	].	(accessedUnregisteredCells size &lt; before)		ifTrue: [ "try to reduce again" 			accessedUnregisteredCells isEmpty not ifTrue: [ self slowPrepareCreatedCells. ] ]		ifFalse: [			accessedUnregisteredCells keysDo: [ :cell | cell makeLocal ].			CoastLog logDebug: [ accessedUnregisteredCells size printString, 							' cell(s) could not be put to a specific cluster, making cells local ' ]].</body></methods><methods><class-id>COAST.CatCSAgenda</class-id> <category>testing</category><body package="COTransactions">isEmpty	"note: writeAccesses could contain nils which represent accesses replaced by an later access - if it contains nils, it also contains replacing accesses"	^ involvedClusters isEmpty and: [ writeAccessesAndNils isEmpty and: [ accessedUnregisteredCells isEmpty ]]</body><body package="COTransactions">isNewInCurrentTransaction: aFrame 	^ accessedUnregisteredCells includesKey: aFrame</body><body package="COTransactions">isSharedAndNewInCurrentTransaction: aFrame 	^ accessedUnregisteredCells includesKey: aFrame</body><body package="COTransactions">notEmpty	^self isEmpty not</body><body package="COTransactions">referencedClusterIDs	^ referencedClusterIDs</body><body package="COTransactions">referencesClusterWithID: clusterID	^ referencedClusterIDs includes: clusterID</body><body package="COTransactions">transactionMustBePessimistic	^ self involvedClusters size &gt; 1 or: [ self removedFrames notEmpty ]</body></methods><methods><class-id>COAST.CatCSAgenda</class-id> <category>cluster management</category><body package="COTransactions">notifyUnloadCluster: cluster 	" readClusterIDs ist bei der Agenda schlecht aufgehoben, da sie zur Unload-Verwaltung verwendet wird.	Es ist notwendig, ausgelagerte Cluster aus readClusterIDs auszutragen, 	da diese andernfalls bei einem Unload-Vorgang der Unload-Strategy mitgeteilt werden, obwohl die Cluster gar nicht geladen sind.	Das verfÃ¤lscht die Lade-Statistik und sorgt bei umfangreichen FastReadTransactions fÃ¼r jede Menge Ballast "	readClusterIDs notNil 		ifTrue: [ readClusterIDs remove: cluster clusterID ifAbsent: [ ]].</body><body package="COTransactions">updateClusterInfoFor: aVolumeManager 	| unloadStrategy |	clusterManager isNil 		ifTrue: [ ^ self ].	unloadStrategy := clusterManager unloadStrategy.	unloadStrategy isNil 		ifTrue: [ ^ self ].	self involvedClusters do: [: cl | unloadStrategy notifyClusterAccess: cl clusterID ].	self readClusterIDs do: [: clID | unloadStrategy notifyClusterAccess: clID ].</body></methods><methods><class-id>COAST.CatCSAgenda</class-id> <category>replication</category><body package="COTransactions">simpleAgendaForCluster: aCatCSCluster 	"Returns a prepared simple agenda which contains only accesses to the given cluster"	^ self preparedAgenda simpleAgendaForCluster: aCatCSCluster</body></methods><methods><class-id>COAST.CatCSAgenda</class-id> <category>initialize</category><body package="COTransactions">initialize	writeAccessesAndNils := OrderedCollection new.	readAccesses := Set new.	createdCells := Set new.	involvedClusters := Set new.	accessedUnregisteredCells := Dictionary new.	simpleAgendas := Dictionary new.	removedFrames := Set new.	removedSlots := Set new.	referencedClusterIDs := CatCOIntegerKeySet new.</body></methods><methods><class-id>COAST.CatCSAgenda class</class-id> <category>instance creation</category><body package="COTransactions">new	^super new initialize</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>transactions</category><body package="COTransactions">abortTransaction	volumeManager exclusiveUseDo: 		[( transactionSequence isNil and: [ activeTransaction isNil or: [ activeTransaction inDisplayPhase ]]) 				ifTrue: [ self privateAbortTransaction ]				ifFalse: 				[						[ self class abortTransactionSignal raise ] 						on: CoastUnhandledAbortTransactionNotification						do: 						[: unhandled |							" no one cared about the notifiaction "							self privateAbortTransaction						]				]		].</body><body package="COTransactions">abortTransactionOfAnyProcess	self volumeManager interruptProtectDo: [		activeTransaction notNil			ifTrue: [  activeTransaction ownerProcess interruptWith: [ self class abortTransactionSignal raise ]]			ifFalse: [ self privateAbortTransaction ]	].</body><body package="COTransactions">abortTransactionWithException: ex	volumeManager exclusiveUseDo:	[		(activeTransaction isNil or: [ activeTransaction inDisplayPhase ])			ifTrue: [ self privateAbortTransaction ]			ifFalse: [  ex resignalAs: self class abortTransactionSignal new ]	].</body><body package="COTransactions">bestDisplayDo: aBlock	^ self bestTransactionClass: CatDMDisplayTransaction do: aBlock</body><body package="COTransactions">bestFastReadTransactionDo: aBlock	^ self bestTransactionClass: CatCSFastReadTransaction do: aBlock</body><body package="COTransactions">bestIndependentDisplayDo: aBlock 	" Perform the block in a (display) transaction. 	No transaction -&gt; perform in a display transaction	Transaction active -&gt; perform the block, but do not become dependent from cells read in the block "	^ self bestTransactionClass: CatDMDisplayTransaction independent: true do: aBlock</body><body package="COTransactions">bestTransactionAbort	self activeTransaction notNil ifTrue: [ ^ self abortTransaction ].	self transactionSequence notNil ifTrue: [ ^ self sequenceDo: [ self abortTransaction ]].</body><body package="COTransactions">bestTransactionClass: transactionClass do: aBlock 	" default since 5.4: with dependencies "	^ self bestTransactionClass: transactionClass independent: false do: aBlock</body><body package="COTransactions">bestTransactionClass: transactionClass do: aBlock onFailure: failBlock 	" be very careful with transactions. do not interrupt active transactions or sequences "	^ ( activeTransaction isNil or: [ activeTransaction checkedOwnerProcess ~~ Processor activeProcess ]) 		ifTrue: 		[	self isSequenceActive 				ifTrue: [ self sequenceDo: aBlock onFailure: failBlock ]				ifFalse: [ self transactionClass: transactionClass do: aBlock onFailure: failBlock ]		]		ifFalse: 		[	self withoutDependenciesDo: 				[	activeTransaction addFailureBlock: failBlock.					aBlock cull: activeTransaction				]		]</body><body package="COTransactions">bestTransactionClass: transactionClass independent: independent do: aBlock 	" a) Perform the block in a new transaction, if no transaction is active. indipendent is ignored.	or	b) perform the block within the active transaction. indipendent = true -&gt; Do not become dependent from cells read in the block"	^self hasNoOwnActiveTransaction		ifTrue: 		[	self isSequenceActive 				ifTrue: [ self sequenceDo: aBlock ]				ifFalse: [ self transactionClass: transactionClass do: aBlock ]		]		ifFalse: 		[	independent 				ifTrue: [ self withoutDependenciesDo: [ aBlock cull: activeTransaction ]]				ifFalse: [ aBlock cull: activeTransaction ]		]</body><body package="COTransactions">bestTransactionDo: aBlock	^ self bestTransactionClass: CatCSTransaction do: aBlock</body><body package="COTransactions">bestTransactionDo: aBlock onFailure: failBlock	^ self bestTransactionClass: CatCSTransaction do: aBlock onFailure: failBlock</body><body package="COTransactions">displayDo: aBlock	| res |	volumeManager exclusiveUseDo:	[		res := (self activeTransaction notNil and: [ self activeTransaction mayDisplay ] )			ifTrue: [ activeTransaction execute: aBlock ]			ifFalse: [ self transactionClass: CatDMDisplayTransaction doWithoutSequenceCheck: aBlock onFailure: nil ].	].	^res</body><body package="COTransactions">fastReadTransactionDo: aBlock 	^ self fastReadTransactionDo: aBlock onFailure: nil</body><body package="COTransactions">fastReadTransactionDo: aBlock onFailure: aFailureBlock 	^ self transactionClass: CatCSFastReadTransaction do: aBlock onFailure: aFailureBlock</body><body package="COTransactions">fastReadWhile: aBlock 	^ self activeTransaction ifNotNil: [: t | t fastReadWhile: aBlock ] ifNil: [ aBlock value ]</body><body package="COTransactions">fastReadWriteTransactionDo: aBlock 	^ self fastReadWriteTransactionDo: aBlock onFailure: nil</body><body package="COTransactions">fastReadWriteTransactionDo: aBlock onFailure: aFailureBlock 	^ self transactionClass: CatCSFastReadWriteTransaction do: aBlock onFailure: aFailureBlock</body><body package="COTransactions">fastWithoutDependenciesDo: aBlock 	| trans |	trans := self activeTransaction.	^ trans isNil 		ifTrue: [ aBlock value	"no transaction -&gt; no dependencies " ]		ifFalse: [ trans fastWithoutDependenciesDo: aBlock ].</body><body package="COTransactions">hasNoOwnActiveTransaction	^ activeTransaction isNil or: [ activeTransaction checkedOwnerProcess ~~ Processor activeProcess ]</body><body package="COTransactions">lastWishTransactionDo: aBlock	^ self transactionClass: CatCSLastWishTransaction do: aBlock onFailure: nil</body><body package="COTransactions">pessimisticTransactionDo: aBlock	^ self transactionClass: CatCSPessimisticTransaction do: aBlock</body><body package="COTransactions">pessimisticTransactionDo: aBlock onFailure: failBlock	^ self transactionClass: CatCSPessimisticTransaction do: aBlock onFailure: failBlock</body><body package="COTransactions">pessimisticTransactionDo: aBlock retries: numRetries delay: delayInMilliseconds onFailure: failBlock 	| i success result |	i := 0.	[	success := true.		result := self 				pessimisticTransactionDo: aBlock				onFailure: 				[	success := false.					nil				].		success 			ifTrue: [ ^ result ].		i := i + 1.		i &lt;= numRetries	] whileTrue: 		[	delayInMilliseconds &gt; 0 				ifTrue: [( Delay forMilliseconds: delayInMilliseconds ) wait ]		].	^ failBlock value</body><body package="COTransactions">pessimisticTransactionDo: aBlock retries: numRetries onFailure: failBlock	^ self pessimisticTransactionDo: aBlock retries: numRetries delay: 0 onFailure: failBlock</body><body package="COTransactions">smallTransactionDo: aBlock	^ self transactionClass: CatCSSmallTransaction do: aBlock onFailure: nil</body><body package="COTransactions">transactionClass: aClass do: aBlock 	^ self transactionClass: aClass do: aBlock onFailure: nil.</body><body package="COTransactions">transactionClass: aClass do: aBlock onFailure: aFailBlock 	"if we are in a transaction sequence, raise an exception. if the exception is resumed,	then the transaction may continue, and will be part of the sequence "	| result exit |	exit := false.	[ | sem |		volumeManager exclusiveUseDo: 			[	transactionSequence isNil 					ifTrue: 					[	result := self transactionClass: aClass doWithoutSequenceCheck: aBlock onFailure: aFailBlock.						exit := true					]					ifFalse: 					[	transactionSequence ownerProcess = Processor activeProcess ifTrue: 							[	CoastFullTransactionWithinSequenceError raiseSignal: 'Full transaction within sequence'.								self privateAbortTransaction.								self endTransactionSequence.								exit := true							].						"must wait for end of sequence!"						sem := transactionSequence waitUntilSequenceEndSemaphore					]			].		sem notNil ifTrue: [ sem wait ].		exit	] whileFalse.	self flushIfNeeded.	^ result</body><body package="COTransactions">transactionClass: aClass doWithoutSequenceCheck: aBlock onFailure: aFailBlock 	"run aBlock as a transaction"	| result |	active 		ifFalse: 		[	^ aFailBlock isNil 				ifTrue: [ nil ]				ifFalse: 				[	aFailBlock numArgs = 1 						ifTrue: [ aFailBlock value: #errorNotActive ]						ifFalse: [ aFailBlock value ]				]		].	[	activeTransaction notNil 			ifTrue: 			[	CoastTransactionNestingError raiseSignal: 'Transaction nesting detected'.				self activeTransaction: nil			].		[ 			| newTrans |			newTrans := aClass new.			Processor activeTransaction: newTrans.			self activeTransaction: newTrans.			activeTransaction transactionManager: self.			transactionSequence notNil 				ifTrue: [ activeTransaction continueTransaction: transactionSequence ].			" Perform the (failure) blocks "			aFailBlock notNil 				ifTrue: 				[	aFailBlock numArgs = 1 						ifTrue: [ activeTransaction addFailureBlock: [: symbol | result := aFailBlock value: symbol ]]						ifFalse: [ activeTransaction addFailureBlock: [ result := aFailBlock value ]]				].			result := activeTransaction execute: aBlock.			activeTransaction notNil 				ifTrue: 				[	activeTransaction performEndTransactionDemons;						evaluateEndBlocks				]		] 			on: self class abortTransactionSignal			do: 			[: ex |				activeTransaction failureReason: #errorAbort.				aFailBlock isNil 					ifTrue: [ result := nil ].				self privateAbortTransaction			].		activeTransaction notNil 			ifTrue: [ self finishActiveTransaction ]	] ifCurtailed: 		[	" catch control intterupts (halt/Ctrl-y). note that this block will be called on exceptions, too, _after_ the exception has been handled "			aFailBlock isNil 				ifTrue: [ result := nil ].			self privateAbortTransaction		].	self flushIfNeeded.	^ result</body><body package="COTransactions">transactionDo: aBlock	^ self transactionClass: CatCSTransaction do: aBlock onFailure: nil</body><body package="COTransactions">transactionDo: aBlock onFailure: aFailBlock 	^self		transactionClass: CatCSTransaction		do: aBlock		onFailure: aFailBlock</body><body package="COTransactions">transactionDo: aBlock onReject: aRejectBlock 	^ self transactionDo: aBlock		onFailure: 		[: symbol |			symbol = #errorReject 				ifTrue: [ aRejectBlock value ]				ifFalse: [ nil ]		]</body><body package="COTransactions">transactionDo: aBlock retries: retries 	| rejected result |	rejected := false.	result := self transactionDo: aBlock			onReject: 			[	rejected := true.				CoastLog log: 'retry! (' , retries printString , ' left)'.				nil			].	^ ( rejected and: [ retries &gt; 0 ]) 		ifTrue: 		[	retries = 0 ifFalse: [( Delay forSeconds: 1 / retries ) wait ].			self transactionDo: aBlock retries: retries - 1		]		ifFalse: [ result ]</body><body package="COTransactions">transactionOrSequenceDo: aBlock 	^ volumeManager exclusiveUseDo: 		[	transactionSequence notNil 				ifTrue: [ self sequenceDo: aBlock ]				ifFalse: [ self transactionDo: aBlock ]		]</body><body package="COTransactions">unmanagedTransactionDo: aBlock 	^ self unmanagedTransactionDo: aBlock onFailure: [ nil ]</body><body package="COTransactions">unmanagedTransactionDo: aBlock onFailure: aFailureBlock 	^ self transactionClass: CatCSUnmanagedTransaction do: aBlock onFailure: aFailureBlock</body><body package="COTransactions">unmanagedWriteTransactionDo: aBlock 	^ self unmanagedWriteTransactionDo: aBlock onFailure: [ nil ]</body><body package="COTransactions">unmanagedWriteTransactionDo: aBlock onFailure: aFailureBlock 	^ self transactionClass: CatCSUnmanagedWriteTransaction do: aBlock onFailure: aFailureBlock</body><body package="COTransactions">withoutDependenciesDo: aBlock	^ self activeTransaction isNil		ifTrue: [ "no transaction -&gt; no dependencies "			aBlock value ]		ifFalse: [ self activeTransaction withoutDependenciesDo: aBlock ]</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>block caches</category><body package="COTransactions">activateBlockCache	self blockCachesNeeded.</body><body package="COTransactions">block: block value: argument	^self block: block valueWithArguments: (Array with: argument)	"^block value: arguments"</body><body package="COTransactions">block: block value: arg1 value: arg2	^self block: block valueWithArguments: (Array with: arg1 with: arg2)	"^block value: arg1 value: arg2"</body><body package="COTransactions">block: block value: arg1 value: arg2 value: arg3	^self block: block valueWithArguments: (Array with: arg1 with: arg2 with: arg3)</body><body package="COTransactions">block: block value: arg1 value: arg2 value: arg3 value: arg4	^self block: block valueWithArguments: (Array with: arg1 with: arg2 with: arg3 with: arg4)</body><body package="COTransactions">block: block valueWithArguments: arguments 	^ self block: block weak: false observe: true valueWithArguments: arguments</body><body package="COTransactions">block: block weak: isWeak 	^ self block: block weak: isWeak observe: true valueWithArguments: Array new</body><body package="COTransactions">block: block weak: isWeak observe: observe	^ self block: block weak: isWeak observe: observe valueWithArguments: Array new</body><body package="COTransactions">block: block weak: isWeak observe: observe value: argument 	^ self block: block weak: isWeak observe: observe valueWithArguments: ( Array with: argument )	"^block value: arguments"</body><body package="COTransactions">block: block weak: isWeak observe: observe value: arg1 value: arg2 	^ self block: block weak: isWeak observe: observe valueWithArguments: ( Array with: arg1 with: arg2 )</body><body package="COTransactions">block: block weak: isWeak observe: observe valueWithArguments: arguments 	^ self blockCacheActive 		ifTrue: [ CoastBlockCache transactionManager: self block: block arguments: arguments weak: isWeak observe: observe ]		ifFalse: [ block valueWithArguments: arguments ]</body><body package="COTransactions">block: block weak: isWeak value: argument 	^ self block: block weak: isWeak observe: true valueWithArguments: ( Array with: argument )	"^block value: arguments"</body><body package="COTransactions">block: block weak: isWeak value: arg1 value: arg2 	^ self block: block weak: isWeak observe: true valueWithArguments: ( Array with: arg1 with: arg2 )</body><body package="COTransactions">block: block weak: isWeak value: arg1 value: arg2 value: arg3 	^ self block: block weak: isWeak observe: true valueWithArguments: ( Array with: arg1 with: arg2 with: arg3 )</body><body package="COTransactions">block: block weak: isWeak value: arg1 value: arg2 value: arg3 value: arg4 	^ self block: block weak: isWeak observe: true valueWithArguments: ( Array with: arg1 with: arg2 with: arg3 with: arg4 )</body><body package="COTransactions">blockCacheAt: aBlock	^ blockCaches notNil		ifTrue: [ blockCaches at: aBlock ifAbsent: [ nil ]]		ifFalse: [ nil ]</body><body package="COTransactions">blockCacheAt: aBlock ifAbsentPut: absentBlock	^ self blockCachesNeeded at: aBlock ifAbsentPut: absentBlock</body><body package="COTransactions">flushBlockCaches	self volumeManager clusterManagers do: [: cm | cm flushBlockCaches ].	blockCaches notNil ifTrue: 		[	blockCaches := nil.			self blockCachesNeeded		].</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>testing</category><body package="COTransactions">active	^active</body><body package="COTransactions">isSequenceActive	^ transactionSequence notNil</body><body package="COTransactions">transactionMustBePessimistic: aTransaction	^ self needsFlush or: [  self isCongested  ]</body><body package="COTransactions">transactionReferencesClusterWithID: clusterID	^ activeTransaction notNil 		ifTrue: [ activeTransaction referencesClusterWithID: clusterID ]		ifFalse: [ transactionSequence notNil and: [ transactionSequence referencesClusterWithID: clusterID ]].</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>rolling</category><body package="COTransactions">addRollbackNotificationBlock: aBlock	"add a block that will be executed after a transaction was rolled back (i.e. was rejected)"	"the block will be provided with two parameters: the transaction manager and the 		transaction that was rolled back"	rollBackNotificationBlocks add: aBlock</body><body package="COTransactions">addRollforwardNotificationBlock: aBlock	"add a block that will be executed after a transaction was rolled forward (i.e. an update occurred)"	"the block will be provided with one parameter: the transaction manager"	rollForwardNotificationBlocks add: aBlock</body><body package="COTransactions">addUpdateNotificationBlock: aBlock	"add a block that will be executed after a transaction replayed"	"the block will be provided with one parameter: the transaction manager"	updateNotificationBlocks add: aBlock</body><body package="COTransactions">roll: aTransaction selector: aSymbol 	"this method is for rolling forward or backward a transaction."	volumeManager exclusiveUseDo: 		[	self class abortTransactionSignal handle: [: ex | self privateAbortTransaction ]				do: 				[	Processor activeTransaction: aTransaction.					self activeTransaction: aTransaction.					activeTransaction setOwnerProcess.					activeTransaction transactionManager: self.					[ activeTransaction perform: aSymbol ] ensure: 						[	activeTransaction notNil ifTrue: 								[										[	activeTransaction inDisplayPhase: true.										[ activeTransaction hasOutstandingCompositions ] whileTrue: 											[	activeTransaction performOutstandingCompositions.												activeTransaction performPostTransactionDemons											].										activeTransaction evaluatePostViewUpdateBlocks									] ensure: 										[	Processor removeActiveTransaction.											self activeTransaction: nil										]								]						]				]		].</body><body package="COTransactions">rollBackTransaction: aTransaction 	"this method is for rolling back a transaction that is not the current transaction. 	i.e. there was a delayed reject of the transaction."	"However, only locally initiated transactions may be rolled back by this method"	Processor 		execute: 		[				[ self roll: aTransaction selector: #rollBack ] ensure: [ rollBackNotificationBlocks do: [: aBlock | aBlock value: self value: aTransaction ]]		]		withPriority: Processor userSchedulingPriority.</body><body package="COTransactions">rollForwardTransaction: aTransaction 	"this method is for rolling forward a transaction."	Processor 		execute: 		[	self roll: aTransaction selector: #rollForward.			updateNotificationBlocks do: [: aBlock | aBlock value: self ]		]		withPriority: Processor userSchedulingPriority.</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>coast internal</category><body package="COTransactions">activeTransaction	"answer the currently active transaction"	^activeTransaction</body><body package="COTransactions">activeTransactionOfCurrentProcess	"answer the currently active transaction - but only if it matches the active transaction of the current process"	| trProcess |	activeTransaction isNil 		ifTrue: [ ^ nil ].	trProcess := activeTransaction ownerProcess.	^ trProcess notNil 		ifTrue: 		[	trProcess = Processor activeProcess 				ifTrue: [ activeTransaction ]				ifFalse: 				[	"kein Gejammer, wenn der Prozess gerade debuggt wird"					( trProcess isUnderDebug or: [ Processor activeProcess isUnderDebug ]) 						ifFalse: [ CoastLog logDebug: 'avoided jumping on another transaction' ].					nil				]		]		ifFalse: [ 			nil 		]</body><body package="COTransactions">activeTransactionOrSequence	"answer the currently active transaction or active transactionSequence"	^ self activeTransaction ifNil: [ self transactionSequence ]</body><body package="COTransactions">beDefault	self class default: self</body><body package="COTransactions">decreaseOutstandingTransactionsCount	"answer from an optimistic transaction has been received from the mediator"	outstandingTransactionsCount := self outstandingTransactionsCount - 1.</body><body package="COTransactions">increaseOutstandingTransactionsCount	"another optimistic transaction has been sent to the mediator"	outstandingTransactionsCount := self outstandingTransactionsCount + 1.</body><body package="COTransactions">isCongested	"try to avoid congestion"	"congestion may result from too many outstanding optimistic transactions"	"congestion may result from (and in!) low local memory"	"the number of 10 may be ok for regular applications, insert more	sophisiticated algorithms/hooks/configurations to take into account	network speed/number of clients the mediator serves/... if you like							CC 2002/10/21"	^self outstandingTransactionsCount &gt; 10		ifTrue: [ CoastLog logDebugDo: [ 'network congestion' ]. true ]		ifFalse: [ false ]</body><body package="COTransactions">outstandingTransactionsCount	^outstandingTransactionsCount ifNil: [ 0 ]</body><body package="COTransactions">rememberAccessIfFirst: aCatCSCellAccess	activeTransaction isNil		ifTrue: [ CoastError raiseSignal: aCatCSCellAccess printString, ' without transaction'  ]		ifFalse: [ activeTransaction rememberAccessIfFirst: aCatCSCellAccess ].</body><body package="COTransactions">removePendingProcess: aProcess	pendingProcesses remove: aProcess ifAbsent: [].</body><body package="COTransactions">removePendingProcesses	pendingProcesses copy do: 		[:aPendingProcess | 			self removePendingProcess: aPendingProcess.			aPendingProcess terminate].</body><body package="COTransactions">startPendingProcess: aBlock withArgs: args 	pendingProcesses add: (			[:localBlock :localArgs | 			localBlock valueWithArguments: localArgs.			self removePendingProcess: Processor activeProcess]				newProcessWithArguments: (Array with: aBlock with: args)) resume</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>eager observers</category><body package="COTransactions">eagerObservers	^eagerObservers</body><body package="COTransactions">installEagerObserver: aCoastEagerObserver	eagerObservers add: aCoastEagerObserver.	aCoastEagerObserver startUp.</body><body package="COTransactions">propagateNonWeakObserver</body><body package="COTransactions">releaseEagerObserver: aCoastEagerObserver	eagerObservers remove: aCoastEagerObserver ifAbsent: [ ^ self ].	aCoastEagerObserver shutDown.</body><body package="COTransactions">releaseEagerObservers	eagerObservers copy do: [ :eo | self releaseEagerObserver: eo ]</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>low space</category><body package="COTransactions">enableLowSpaceHandler	CoastMemoryPolicy lowSpaceHandler: self.	CoastLog log: 'Enabling low space handler'.</body><body package="COTransactions">lowSpaceAction	self volumeManager clusterManagers do: [: cm | cm lowSpaceAction ].	ObjectMemory verboseCompactingGC.</body><body package="COTransactions">lowSpaceNotification	CoastLog logWarning: 'Low space detected, memory-low interrupt fired'.	self lowSpaceAction.</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>transaction partitions</category><body package="COTransactions">endTransactionPartitions	self endTransactionSequence</body><body package="COTransactions">startTransactionPartitions: partitionSize	Processor activePartitionSize: partitionSize.	self startTransactionSequence</body><body package="COTransactions">transactionPartitionDo: aBlock 	^ self  transactionPartitionDo: aBlock onFailure: nil</body><body package="COTransactions">transactionPartitionDo: aBlock onFailure: failBlock 	| result partSize |	result := self sequenceDo: aBlock onFailure: failBlock.	partSize := Processor activePartitionSize.	( transactionSequence notNil and: [ transactionSequence exceedsPartitionSize: partSize ]) 		ifTrue: 		[	self endTransactionSequence.			self startTransactionSequence		].	^ result</body><body package="COTransactions">transactionPartitions: partitionSize do: aBlock	self startTransactionPartitions: partitionSize.	aBlock ensure: [ self endTransactionPartitions ]</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>messages</category><body package="COTransactions">isDemoMode	"Don't show any exceptions, we are in a demo ... :-)"	developmentMode isNil ifTrue: [ ^ false ].	^ developmentMode = #demo</body><body package="COTransactions">isDevelopmentMode	"show as many infos as possible and make developer's life as nice as possible!"	developmentMode isNil ifTrue: [ self setDevelopmentMode ].	^ developmentMode = #debug</body><body package="COTransactions">setDebugMode	developmentMode := #debug</body><body package="COTransactions">setDemoMode	developmentMode := #demo</body><body package="COTransactions">setDeploymentMode	developmentMode := #deploy</body><body package="COTransactions">setDevelopmentMode	developmentMode := #debug</body><body package="COTransactions">statusError: aString	"Note log: aString."	CoastError raiseSignal: aString</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>transaction sequences</category><body package="COTransactions">endTransactionSequence	transactionSequence isNil 		ifTrue: 		[	" transaction was already aborted "			self flushIfNeeded.			^ nil		].	volumeManager exclusiveUseDo: 		[				[ | toBeCommited |				transactionSequence wasRolledBack 					ifFalse: [ self sequenceDo: [: tr | tr enableEndBlocks: true ]].				" evaluating end blocks might abort the transaction "				transactionSequence notNil 					ifTrue: 					[	transactionSequence wakeUpAll.						toBeCommited := nil.						transactionSequence wasRolledBack 							ifFalse: 							[ | transactionCommit |								self sequenceDo: [ ].								Processor activeTransaction: transactionSequence.								self activeTransaction: transactionSequence.								transactionSequence := nil.	"needed! otherwise it will not be propagated"								transactionCommit := self propagateTransaction: activeTransaction.								activeTransaction isNil 									ifFalse: 									[	transactionCommit = #accepted 											ifTrue: [ toBeCommited := activeTransaction ].										activeTransaction markDelayedCompositionsAsOutstanding.										activeTransaction finishForVolumeManager: self volumeManager.										activeTransaction propagateApplicationLog	"some log entries may have appeared during post transaction phase"									]							].						transactionSequence := nil.						Processor removeActiveTransaction.						self activeTransaction: nil.						toBeCommited isNil 							ifFalse: [ toBeCommited commited ]					]			] ifCurtailed: [ transactionSequence := nil ]		].	"end exclusive use do"	self flushIfNeeded.</body><body package="COTransactions">missingTransactionSequence	^ self error: '#sequenceDo: without transaction sequence'</body><body package="COTransactions">sequenceDo: aBlock 	^self sequenceDo: aBlock onFailure: nil</body><body package="COTransactions">sequenceDo: aBlock onFailure: failBlock 	transactionSequence isNil ifTrue: [ self missingTransactionSequence ].	^ transactionSequence wasRolledBack 		ifTrue: 		[	"do not continue broken transaction sequences"			failBlock value		]		ifFalse: 		[	volumeManager 				exclusiveUseDo: [ self transactionClass: CatCSSequence doWithoutSequenceCheck: aBlock onFailure: failBlock ]		]</body><body package="COTransactions">startTransactionSequence	self transactionSequenceExclusiveUseDo: 		[( activeTransaction notNil or: [ transactionSequence notNil ]) 				ifTrue: 				[	self privateAbortTransaction.					CoastSequenceWithinTransactionError raiseSignal: 'A transaction sequence cannot be started in a transaction'				]				ifFalse: 				[	transactionSequence := CatCSSequenceTransaction new.					transactionSequence transactionManager: self				]		].</body><body package="COTransactions">transactionSequence	^ transactionSequence</body><body package="COTransactions">transactionSequenceDo: aBlock 	^ self transactionSequenceDo: aBlock onFailure: [ nil ]</body><body package="COTransactions">transactionSequenceDo: aBlock onFailure: failBlockOrNil 	" returns		result of aBlock if the transaction succeeds		result of failBlockOrNil if the transaction fails and failBlockOrNil is not nil		nil otherwise	"	| result |	result := nil.	self startTransactionSequence.	failBlockOrNil notNil 		ifTrue: [ transactionSequence addFailureBlock: [: symbol | result := failBlockOrNil cull: symbol ]].	[			[				[ result := aBlock value ] ifCurtailed: 				[( transactionSequence notNil and: [ transactionSequence wasRolledBack not ]) 						ifTrue: 						[	CoastLog logDebug: 'implicit abort a transaction sequence on unwind!'.							self privateAbortTransaction						]				]		] 			on: self class abortTransactionSignal			do: 			[: abort |				" handling the notification unwinds the stack.					ifCurtailed: performs the rollback "			]	] ensure: [ self endTransactionSequence ].	^ result</body><body package="COTransactions">transactionSequenceExclusiveUseDo: aBlock 	| sem res | 	[	sem := nil.		self volumeManager exclusiveUseDo: 			[	transactionSequence isNil 					ifTrue: [ res := aBlock value ]					ifFalse: [ sem := transactionSequence waitUntilSequenceEndSemaphore ]			].		sem notNil	] whileTrue: [ sem wait ].	^ res</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>private: transactions</category><body package="COTransactions">activeTransaction: aTransaction	activeTransaction := aTransaction</body><body package="COTransactions">finishActiveTransaction	" Propagate the changes and finish the transaction "	| transactionCommit theTransaction | 	[	theTransaction := activeTransaction.		transactionSequence isNil ifTrue: [ transactionCommit := self propagateTransaction: activeTransaction  ].		transactionCommit ~= #rejected ifTrue: 			[	activeTransaction finishForVolumeManager: volumeManager.				transactionSequence isNil ifTrue: 					[	"some log entries may have appeared during post transaction phase"						activeTransaction notNil ifTrue: [ activeTransaction propagateApplicationLog ]					]			]	] ensure: 		[	Processor removeActiveTransaction.			self activeTransaction: nil		].	rollForwardNotificationBlocks do: [: aBlock | aBlock value: self ].	transactionCommit = #accepted ifTrue: [ theTransaction commited ].</body><body package="COTransactions">handleTransaction: aCatCSTransaction	" optimistic transaction "	"the cluster controller involved has to handle transaction"	| cluster |	aCatCSTransaction involvedClusters isEmpty ifTrue: [ ^nil ]. "may happen, transaction is purely local"	cluster := aCatCSTransaction involvedClusters singleElement.	^cluster clusterController recordOptimisticTransaction: aCatCSTransaction.</body><body package="COTransactions">localCommit: aCatCSTransaction 	" onePhaseCommit, local mode. simply record the transaction "	aCatCSTransaction combinedAgenda involvedClusters 		do: [: aCluster | aCluster clusterController recordLocalTransaction: aCatCSTransaction ].	aCatCSTransaction combinedAgenda clusterManager addToApplicationLog: aCatCSTransaction applicationLog.	aCatCSTransaction flushApplicationLog.	^ #accepted</body><body package="COTransactions">mediatedOnePhaseCommit: aCatCSTransaction 	" onePhaseCommit, mediator mode	send all the stuff to the mediator. let him check the transaction IN ONE STEP! 	this is much easyer than two phase commit, but this does'nt work 	with cross mediator transactions. (but nobody ever tried or needed this)"	| volunteer |	volunteer := aCatCSTransaction combinedAgenda involvedClusters anyElement.	volunteer isNil ifTrue: [^nil].	^(volunteer clusterController tryAndTell: aCatCSTransaction)		ifTrue: [	#accepted]		ifFalse:[	self rollBackTransaction: aCatCSTransaction.				#rejected]</body><body package="COTransactions">onePhaseCommit: aCatCSTransaction 	"all cluster controllers involved have to commit the transaction since the transaction is a multi-cluster 	or pessimistic transaction, use 1 phase commit"	| anyCluster transactionCommit |	anyCluster := aCatCSTransaction combinedAgenda involvedClusters anyElement.	anyCluster isNil ifTrue: [ ^ nil ].	"nothing to do!"	"prerequisite: all clusters have the same clusterManager 		-&gt; no cross volume transactions possible"	aCatCSTransaction flushAfterOnePhaseCommit.	transactionCommit := anyCluster clusterController clusterManager host isNil 			ifTrue: [ self localCommit: aCatCSTransaction ]			ifFalse: [ self mediatedOnePhaseCommit: aCatCSTransaction ].	transactionCommit = #accepted 		ifTrue: [ aCatCSTransaction combinedAgenda removedFrames do: [: frame | frame cluster coastInternalRemoveFrame: frame ]].	^ transactionCommit</body><body package="COTransactions">privateAbortTransaction	"abort the current transaction and the transaction sequence (if one is running)"	[( activeTransaction notNil and: [ activeTransaction isDisplayTransaction or: [ transactionSequence isNil ]]) 			ifTrue: [ activeTransaction abort ]			ifFalse: 			[	transactionSequence notNil 					ifTrue: 					[	activeTransaction notNil 							ifTrue: 							[									[ activeTransaction evaluateFailureBlocks ] ensure: 									[	activeTransaction moveDelayedCompositionsTo: transactionSequence.										transactionSequence copyOutstandingCompositionsFrom: activeTransaction.										self privateAbortTransactionSequence									]							]							ifFalse: 							[									[ transactionSequence evaluateFailureBlocks ] ensure: [ self privateAbortTransactionSequence ]							]					]			]	] ensure: 		[	activeTransaction notNil 				ifTrue: 				[	Processor removeActiveTransaction.					self activeTransaction: nil				]		].</body><body package="COTransactions">privateAbortTransactionSequence	Processor activeTransaction: transactionSequence.	self activeTransaction: transactionSequence.	transactionSequence abort.	transactionSequence := nil.	Processor removeActiveTransaction</body><body package="COTransactions">propagateTransaction: aTransaction	" DB hook "	^ activeTransaction propagateWith: self</body><body package="COTransactions">recordAccess: aCatCSCellAccess in: transaction	" hook "</body><body package="COTransactions">recordTransaction: aCatCSTransaction 	^transactionSequence isNil 		ifTrue: [self handleTransaction: aCatCSTransaction]		ifFalse: [#transactionSequence]</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>initialize - release</category><body package="COTransactions">initialize	eagerObservers := Set new.	active := true.	needsFlush := false.	rollForwardNotificationBlocks := Set new.	rollBackNotificationBlocks := Set new.	updateNotificationBlocks := Set new.	pendingProcesses := Set new.	self activateBlockCache</body><body package="COTransactions">shutDown	self removePendingProcesses.	self releaseEagerObservers.	CoastMemoryPolicy flushLowSpaceHandler.	active := false.</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>accessing</category><body package="COTransactions">clusterID	^ nil</body><body package="COTransactions">flushIfNeeded	( needsFlush and: [ self volumeManager exclusiveLockOwner ~= Processor activeProcess ]) ifTrue: 		[	Processor yield.			needsFlush := false		]</body><body package="COTransactions">needsFlush	^ needsFlush</body><body package="COTransactions">needsFlush: bool 	needsFlush := bool</body><body package="COTransactions">notifyFastRead: aFrame</body><body package="COTransactions">suppressInvalidationWhile: aBlock 	| t |	^ ( t := self activeTransactionOfCurrentProcess ) notNil 		ifTrue: [ t suppressInvalidationWhile: aBlock ]		ifFalse: [ aBlock value ]</body><body package="COTransactions">transactionManager	^self</body><body package="COTransactions">volumeManager	^volumeManager</body><body package="COTransactions">volumeManager: aCoastClientVolumeManager	volumeManager := aCoastClientVolumeManager</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>db</category><body package="COTransactions">recordIsolatedFrame: aCatFSFrame	" hook "</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>block caches - private</category><body package="COTransactions">blockCacheActive	^ blockCaches notNil</body><body package="COTransactions">blockCachesNeeded	blockCaches isNil ifTrue: [ blockCaches := IdentityDictionary new ].	^ blockCaches</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>statistics</category><body package="COTransactions">coastStatistics	" compatibility "	^ nil</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>context accessing - compatibility</category><body package="COTransactions">transactionContextAt: key 	^self transactionManagerContextAt: key</body><body package="COTransactions">transactionContextAt: key ifAbsent: absentBlock 	^self transactionManagerContextAt: key ifAbsent: absentBlock</body><body package="COTransactions">transactionContextAt: key ifAbsentPut: value	^ self transactionManagerContextAt: key ifAbsentPut: value</body><body package="COTransactions">transactionContextAt: key put: value	self transactionManagerContextAt: key put: value</body><body package="COTransactions">transactionContextNeeded	^ self transactionManagerContextNeeded</body><body package="COTransactions">transactionContextRemoveKey: key 	^ self transactionManagerContextRemoveKey: key</body></methods><methods><class-id>COAST.CoastTransactionManager</class-id> <category>context accessing</category><body package="COTransactions">transactionManagerContextAt: key 	"search the context"	^self transactionManagerContextAt: key ifAbsent: [ nil ]</body><body package="COTransactions">transactionManagerContextAt: key ifAbsent: absentBlock 	"search the context"	^ context isNil 		ifTrue: [ absentBlock value ]		ifFalse: [ context at: key ifAbsent: absentBlock ]</body><body package="COTransactions">transactionManagerContextAt: key ifAbsentPut: value	^ self transactionManagerContextNeeded at: key ifAbsentPut: value.</body><body package="COTransactions">transactionManagerContextAt: key put: value	self transactionManagerContextNeeded at: key put: value.</body><body package="COTransactions">transactionManagerContextNeeded	context isNil ifTrue: [ context := IdentityDictionary new. ].	^context</body><body package="COTransactions">transactionManagerContextRemoveKey: key 	^ context notNil 		ifTrue: [ context removeKey: key ifAbsent: [ nil ]]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CoastTransactionManager class</class-id> <category>accessing</category><body package="COTransactions">abortTransactionSignal	^ CoastAbortTransactionNotification</body><body package="COTransactions">default	 ^default</body><body package="COTransactions">default: aCoastTransactionManager	 default := aCoastTransactionManager</body></methods><methods><class-id>COAST.CoastTransactionManager class</class-id> <category>instance creation</category><body package="COTransactions">new	^super new initialize</body><body package="COTransactions">newWithClusterManager: aCatCSClusterManager	^self new clusterManager: aCatCSClusterManager</body></methods><methods><class-id>COAST.CatCSClusterLocator</class-id> <category>comparing</category><body package="COFramesystem">&lt; anotherID	^ (anotherID lessThanClusterLocator: self) not</body><body package="COFramesystem">= anotherID	^anotherID class = self class	ifTrue: [ ((id = anotherID id) and: [ (volume) = (anotherID volume) ]) ]	ifFalse: [ false ]</body><body package="COFramesystem">hash	"Answer a SmallInteger that is equal to the hash value of 	any object that is equal to (=) the receiver. 	When two objects are not =, their hash values may or may not be the same.	The hash value may change based on the receiver's contents."	"If hash is redefined in a subclass, it may also be necessary to	redefine the = method to maintain the semantics described above."	^id hash</body><body package="COFramesystem">lessThanClusterLocator: aClusterLocator	^ (id = aClusterLocator id) 		ifTrue: [ volume &lt; aClusterLocator volume ]		ifFalse: [ id &lt; aClusterLocator id ]</body></methods><methods><class-id>COAST.CatCSClusterLocator</class-id> <category>accessing</category><body package="COFramesystem">id	^id</body><body package="COFramesystem">id: aSmallInteger	id := aSmallInteger</body><body package="COFramesystem">volume	^volume</body><body package="COFramesystem">volume: aString	volume := aString</body></methods><methods><class-id>COAST.CatCSClusterLocator</class-id> <category>printing</category><body package="COFramesystem">printOn: stream 	volume printOn: stream.	stream nextPut: $/.	id printOn: stream</body></methods><methods><class-id>COAST.CatCSClusterLocator</class-id> <category>marshalling</category><body package="COMarshalling">clusterFilename	" answer the filename used for the cluster located by this locator.	the filename may be extended by the caller (eg. 0 --&gt; 0.ini) "	^ self id printString</body><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextShortStringPut: self volume.	aStream nextOptimized32Put: self id.</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	self volume: aStream nextShortString.	self id: aStream nextOptimized32.</body></methods><methods><class-id>COAST.CatCSClusterLocator class</class-id> <category>instance creation</category><body package="COFramesystem">cluster: aCatCSCLuster	^ self id: aCatCSCLuster id volume: aCatCSCLuster volume.</body><body package="COFramesystem">id: anInteger	^self new id: anInteger</body><body package="COFramesystem">id: aSmallInteger volume: aString	"create a clusterID with the given id and volume"	| newInst |	newInst := self new.	newInst id: aSmallInteger.	newInst volume: aString.	^newInst</body></methods><methods><class-id>COAST.CatCSClusterLocator class</class-id> <category>marshalling</category><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	" note: the (very) old cluster locator class name unmarshalling stuff	is not supported any more "		^ self new unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall</body></methods><methods><class-id>COAST.SegmentedCollectionHeader</class-id> <category>accessing</category><body package="COFramesystem">clusterIDs	^ clusterIDs</body><body package="COFramesystem">clusterIDs: aClusterIDs 	clusterIDs := aClusterIDs.</body><body package="COFramesystem">compareIndex: index key: key 	^ ( lastKeys at: index ) coastCompareTo: key</body><body package="COFramesystem">lastKeys: aLastKeys 	lastKeys := aLastKeys</body><body package="COFramesystem">numberOfSegments	^lastKeys size</body><body package="COFramesystem">segmentClusterIDForKey: key 	^ clusterIDs at: ( self segmentIndexForKey: key min: 1 max: lastKeys size )</body><body package="COFramesystem">segmentIndexForKey: key min: min max: max 	"search index of the segment responsible for key-&gt;value"	| minIndex maxIndex |	minIndex := min.	maxIndex := max.	"1 &lt;= minIndex &lt;= maxIndex &lt;= keys size"	[ minIndex &lt; maxIndex ] whileTrue: 		[ "search in interval [ minIndex .. maxIndex ]"			| index compare |			index := minIndex + maxIndex bitShift: -1.	"minIndex &lt;= index &lt; maxIndex"			compare := self compareIndex: index key: key.			compare = 0 				ifTrue: [ ^ index	"value=midVal ==&gt; return index" ].			compare = 1 				ifTrue: [ maxIndex := index	"search at or before index" ]				ifFalse: [ minIndex := index + 1	"search behind index" ]		].	"minIndex = maxIndex"	^ minIndex</body></methods><methods><class-id>COAST.CatRMAbstractAgendaChecker</class-id> <category>checking</category><body package="COTransactions">isValidAgenda: agenda cluster: cluster 	"scan the agenda for accesses without slot or frame"	self subclassResponsibility</body></methods><methods><class-id>COAST.CatRMAbstractAgendaChecker class</class-id> <category>private</category><body package="COTransactions">errorSignal	^ CoastInvalidAccessError</body></methods><methods><class-id>COAST.CatRMAbstractAgendaChecker class</class-id> <category>instance creation</category><body package="COTransactions">setCurrent	"CatRMSkippingAgendaChecker setCurrent."	"CatRMAgendaChecker setCurrent."	"CatRMAgendaChecker_OLD setCurrent."	COAST.AgendaChecker := self new</body></methods><methods><class-id>COAST.FrameSet</class-id> <category>accessing</category><body package="COFramesystem">coastAsSetOrYourself	^ self</body><body package="COFramesystem">coastValueFor: valueHolder 	| myValueHolderClass adaptedValueHolder |	valueHolder valueClass = Set 		ifTrue: [ ^ self copy ].	myValueHolderClass := COAST.CatCSSet.	adaptedValueHolder := myValueHolderClass new			value: self;			adaptedCoastValueHolderToClass: valueHolder.	^ adaptedValueHolder value = self 		ifTrue: 		[	COAST.CoastError raiseBadValueClass.			self		]		ifFalse: [ adaptedValueHolder value coastValueFor: valueHolder ]</body></methods><methods><class-id>COAST.FrameSet</class-id> <category>private</category><body package="COFramesystem">findElementOrNil: anObject 	| index length probe pass |	length := self basicSize.	pass := 1.	index := self initialIndexFor: anObject coastFrameSetHash boundedBy: length.	[( probe := self basicAt: index ) == nil or: [ probe = anObject ]] whileFalse: 		[( index := index + 1 ) &gt; length ifTrue: 				[	index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [ ^ self grow findElementOrNil: anObject ]				]		].	^ index</body></methods><methods><class-id>Core.ThreadSafeWeakFrameSet</class-id> <category>private</category><body package="COFramesystem">findElementOrNil: anObject 	"Answer the index of the argument anObject, if present, or the index of a nil	entry where anObject would be placed."	| index length probe pass indexOfTombstone |	length := self basicSize.	pass := 1.	index := self initialIndexFor: anObject coastFrameSetHash boundedBy: length.	[	probe := self basicAt: index.		( indexOfTombstone == nil and: [ probe == self tombstone ]) ifTrue: [ indexOfTombstone := index ].		probe == nil or: [ probe = anObject ]	] whileFalse: 		[( index := index + 1 ) &gt; length ifTrue: 				[	index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [ ^ self grow findElementOrNil: anObject ]				]		].	probe ~~ nil ifTrue: [ ^ index ].	^ indexOfTombstone ifNil: [ index ]</body><body package="COFramesystem">frameWithClusterID: clusterID frameID: frameID withIndexDo: block 	^ self evaluateWithFullProtection: [ super frameWithClusterID: clusterID frameID: frameID withIndexDo: block ]</body></methods><methods><class-id>Core.ThreadSafeWeakFrameSet</class-id> <category>adding</category><body package="COFramesystem">addAll: aCollection 	self evaluateWithFullProtection: 		[	aCollection do: 				[: newObject | | index probe |					newObject == nil ifFalse: 						[	index := self findElementOrNil: newObject.							probe := self basicAt: index.							( probe == nil or: [ probe == self tombstone ]) ifTrue: [ self atNewIndex: index put: newObject ]						]				]		].	^ aCollection</body></methods><methods><class-id>Core.ThreadSafeWeakFrameSet</class-id> <category>accessing</category><body package="COFramesystem">addAndReturnOldOrNil: newObject 	"Include newObject as one of the receiver's elements.  Answer nil if newObject was added or old if not added"	^ self evaluateWithFullProtection: [ super addAndReturnOldOrNil: newObject ]</body></methods><methods><class-id>COAST.CoastFinalEndBlock</class-id> <category>evaluating</category><body package="COTransactions">finalEndBlockValue	 ^block value</body></methods><methods><class-id>COAST.CoastFinalEndBlock</class-id> <category>accessing</category><body package="COTransactions">block: aBlock	block := aBlock</body></methods><methods><class-id>COAST.CoastFinalEndBlock class</class-id> <category>instance creation</category><body package="COTransactions">block: aBlock	^self new block: aBlock; yourself</body></methods><methods><class-id>COAST.ResolveClusterNotification class</class-id> <category>accessing</category><body package="COFramesystem">mayResume	^ true</body></methods><methods><class-id>COAST.CoastBlockCache</class-id> <category>accessing</category><body package="COTransactions">block	^block</body><body package="COTransactions">block: aBlock	block := aBlock</body><body package="COTransactions">cacheNeededFor: arguments weak: isWeak observe: observe 	| cache |	cache := self cachedValues at: arguments ifAbsent: [ nil ].	cache isNil 		ifTrue: 		[	misses := misses + 1.			cache := self newCacheFor: arguments weak: isWeak observe: observe		]		ifFalse: 		[	cache isValid 				ifTrue: [ hits := hits + 1 ]				ifFalse: [ misses := misses + 1 ]		].	^ cache</body><body package="COTransactions">cachedValues	^cachedValues</body><body package="COTransactions">transactionManager	^transactionManager</body><body package="COTransactions">transactionManager: t	transactionManager := t</body><body package="COTransactions">validAt: arguments	| cache |	cache := self cachedValues at: arguments ifAbsent: [^false].	^cache isValid</body><body package="COTransactions">valueFor: arguments weak: isWeak observe: observe 	| slot value |	slot := self cacheNeededFor: arguments weak: isWeak observe: observe.	value := [ slot readAccess ] ifCurtailed: [ slot isValid: false. nil ].	^ value</body></methods><methods><class-id>COAST.CoastBlockCache</class-id> <category>accessing cache</category><body package="COTransactions">newCacheFor: arguments ofClass: slotClass	| newSlot |	newSlot := slotClass newPrototypeOfType: #virtualValue.	newSlot initializeForBlockCache: self arguments: arguments.	self registerCache: newSlot forArguments: arguments.	^ newSlot</body><body package="COTransactions">newCacheFor: arguments weak: isWeak observe: observe 	| slotClass |	^ observe 		ifTrue: 		[	slotClass := isWeak 					ifTrue: [ CatFSWeakCachingSlot ]					ifFalse: [ CatFSCachingVirtualSlot ].			self newCacheFor: arguments ofClass: slotClass		]		ifFalse: 		[	" don't observe. weak does not matter here, the cached value will always be remembered "			self transactionManager withoutDependenciesDo: 				[	| cachedValue cache |					cachedValue := self block valueWithArguments: arguments.					cache := CatFSCachedValue value: cachedValue.					self registerCache: cache forArguments: arguments.					cache				]		]</body><body package="COTransactions">registerCache: cache forArguments: arguments 	| transaction |	transaction := self transactionManager transactionSequence.	transaction isNil ifTrue: [ transaction := self transactionManager activeTransaction ].	transaction notNil ifTrue: [ transaction addFailureBlock: [ self removeCacheFor: arguments ]].	^ cachedValues at: arguments put: cache</body><body package="COTransactions">removeCacheFor: arguments 	cachedValues removeKey: arguments ifAbsent: [].</body></methods><methods><class-id>COAST.CoastBlockCache</class-id> <category>printing</category><body package="COTransactions">printBlockCacheInfoOn: aStream clusterManager: clusterManager	| clusterIDs clustersSize weak nonWeak |	aStream nextPutAll: block coastMethodPrintString.	aStream nextPut: $;.	cachedValues size printOn: aStream.	aStream nextPut: $;.	hits printOn: aStream.	aStream nextPut: $;.	misses printOn: aStream.	aStream nextPut: $;.	weak := false.	nonWeak := false.	cachedValues do: [ : slot | 		slot isWeakObserver ifTrue: [ weak := true ] ifFalse: [ nonWeak := true ]	].	weak 		ifTrue: [ nonWeak 			ifTrue: [ aStream nextPutAll: 'mixed' ] 			ifFalse: [ aStream nextPutAll: 'yes' ] ]		ifFalse: [ aStream nextPutAll: 'no' ].	aStream nextPut: $;.	clusterIDs := Set new.	cachedValues do: [ : slot | 		clusterIDs addAll: slot allObservedClusterIDs 	].	clusterIDs size printOn: aStream.	aStream nextPut: $;.	clustersSize := 0.	clusterIDs do: [ : cid | clustersSize := clustersSize + (clusterManager getCluster: cid) approxByteSize ].	(clustersSize // 1000) printOn: aStream.	aStream cr.</body><body package="COTransactions">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: block coastMethodPrintString.	aStream nextPut: $).</body></methods><methods><class-id>COAST.CoastBlockCache</class-id> <category>initialize-release</category><body package="COTransactions">initialize	cachedValues := ArgumentsDictionary new.	hits := 0.	misses := 0.</body></methods><methods><class-id>COAST.CoastBlockCache class</class-id> <category>accessing</category><body package="COTransactions">blockCacheFor: block clusterManager: clusterManager 	^ clusterManager blockCacheAt: block		ifAbsentPut: 		[	CoastLog logDebug: [ 'Creating new block cache (' , block coastMethodPrintString , ')' ] channel: #blockCache.			self newWithBlock: block transactionManager: clusterManager transactionManager		]</body><body package="COTransactions">blockCacheFor: block transactionManager: transactionManager 	^ transactionManager blockCacheAt: block		ifAbsentPut: 		[	CoastLog logDebug: [ 'Creating new block cache (' , block coastMethodPrintString , ')' ] channel: #blockCache.			self newWithBlock: block transactionManager: transactionManager		]</body><body package="COTransactions">newWithBlock: block transactionManager: transactionManager 	^ ( self new )		initialize;		transactionManager: transactionManager;		block: block;		yourself</body><body package="COTransactions">transactionManager: transactionManager block: block arguments: arguments weak: isWeak observe: observe 	| activeTransaction cache localArg cm |	Notifier isDevelopment ifTrue: [ block coastIsClean ifFalse: [ self haltOrContinue: 'BlockCache is not clean!' ]].	activeTransaction := transactionManager activeTransactionOfCurrentProcess.	activeTransaction isNil ifTrue: 		[	CoastLog debugDo: 				[	transactionManager transactionContextAt: block method						ifAbsentPut: 						[	CoastLog log: [ block coastMethodPrintString , ' BlockCache evaluated without transaction!' ] channel: #blockCache.							'BlockCache evaluated without transaction!'						]				]		].	"fetch any local arg, prefer any unmanagedLocal (these must NOT use a blockcache)"	localArg := nil.	cm := nil.	arguments do: 		[: arg |			( arg isCoastFrame and: [ arg isLocal and: [ localArg isNil or: [ localArg isUnmanagedLocal not ]]]) ifTrue: [ localArg := arg ].			cm isNil ifTrue: [ cm := arg clusterManagerForBlockCache ]		].	cache := localArg notNil 			ifTrue: [ localArg blockCacheFor: block transactionManager: transactionManager activeTransaction: activeTransaction ]			ifFalse: 			[	cm notNil 					ifTrue: [ self blockCacheFor: block clusterManager: cm ]					ifFalse: [ self blockCacheFor: block transactionManager: transactionManager ]			].	^ cache notNil 		ifTrue: [ cache valueFor: arguments weak: isWeak observe: observe ]		ifFalse: [ block valueWithArguments: arguments ]</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>testing</category><body package="COFramesystem">= anotherCluster 	| result |	result := super = anotherCluster.	result ifFalse: 		[( self looksLike: anotherCluster ) 				ifTrue: [ CoastError raiseSignal: 'FATAL ERROR: Two clusters look alike but are not identical ' , self printString ]		].	^ result</body><body package="COClusterManagement">hasNonWeakObservers	^ self mayHaveNonWeakObserver and: [ mayHaveNonWeakObserver := self valueHolder hasNonWeakObservers ]</body><body package="COClusterManagement">hasObservers	^ self valueHolder hasObservers</body><body package="COFramesystem">isCluster	"ja, doch eher schon"	^ true</body><body package="COClusterManagement">isIndexCluster	self framesDo: [: f | f class isPartOfIndexStructure ifFalse: [ ^ false ]].	^ true</body><body package="COFramesystem">isPrototype	^false</body><body package="COFramesystem">looksLike: anotherCluster 	"modified, since id is an integer by now"	^anotherCluster class == self class 		and: [ self id = anotherCluster id 		and: [self volume = anotherCluster volume ]]</body><body package="COClusterManagement">mayHaveNonWeakObserver	^ mayHaveNonWeakObserver ifNil: [ false ]</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>adding cells</category><body package="COFramesystem">addCell: aCatCSCell	"add a cell to the container"	aCatCSCell id isNil ifTrue: [ self generateIDForCell: aCatCSCell ].	self addCellWithID: aCatCSCell.	^aCatCSCell</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>private: accessing</category><body package="COFramesystem">administrationFrame	^self basicAdministrationFrame ifNil: [ self initializeAdministrationFrame. self basicAdministrationFrame ].</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>accessing</category><body package="COFramesystem">approxByteSize	" approx. byte size of the cluster when stored on disk "	^ approxByteSize ifNil: [ 0 ]</body><body package="COFramesystem">approxByteSize: anInteger	" approx. byte size of the cluster when stored on disk "	approxByteSize := anInteger</body><body package="COFramesystem">approxResolvedByteSize	" approx. byte size of the cluster when stored on disk, 	except size of frames that are not yet resolved "	" possibly expensive, so handle with care "	| approxResolvedByteSize |	approxResolvedByteSize := self frames inject: self approxByteSize into: [ :sz :fr | sz - fr byteArraySize ].	approxResolvedByteSize := approxResolvedByteSize max: 0.	^ approxResolvedByteSize</body><body package="COFramesystem">closeClusterStream	| cm |	clusterStream notNil		ifTrue: [ 			clusterStream close.			clusterStream := nil.			(cm := self clusterManager) notNil				ifTrue: [ cm deregisterClusterWithStream: self ]		].	^ clusterStream</body><body package="COFramesystem">cluster	^self</body><body package="COFramesystem">clusterController	^clusterController</body><body package="COFramesystem">clusterController: aCatCSClusterController	clusterController := aCatCSClusterController</body><body package="COFramesystem">clusterID	^ coastID</body><body package="COFramesystem">clusterLocator	^ CatCSClusterLocator id: self id volume: self volume</body><body package="COFramesystem">clusterManager	^ self clusterController clusterManager</body><body package="COFramesystem">coastCopyWith: copyContext 	self error: 'Clusters cannot be copied'.</body><body package="COTransactions">coastInternalRemoveFrame: frameOrFrameRemove 	"this is post commit"	| frame frameID |	frameID := frameOrFrameRemove frameID.	frame := self directTableAccessAt: frameID.	frame notNil ifTrue: 		[	frame coastInternalRemoveFromCluster.			self valueHolder coastInternalRemoveKey: frameID		].</body><body package="COMarshalling">frameFor: anID	^self directTableAccessAt: anID</body><body package="COFramesystem">frameIDs	^ self valueHolder keys</body><body package="COFramesystem">getCluster	"thats me"	^self</body><body package="COFramesystem">incrementModificationNumber	" for MS freaks: incModNum "	modificationNumber := modificationNumber + 1.</body><body package="COFramesystem">lazyFrameClasses	| b |	b := Bag new.	self frames do: [ :f | f basicValueHolder isNil ifTrue: [ b add: f  class ]].	^ b</body><body package="COFramesystem">lazyFramesOfClass: aClass	| b |	b := Set new.	self frames do: [ :f | (f class = aClass and: [ f basicValueHolder isNil ]) ifTrue: [ b add: f  ]].	^ b</body><body package="COFramesystem">modificationNumber	^ modificationNumber</body><body package="COFramesystem">modificationNumber: anInteger	(modificationNumber isNil or: [ anInteger &gt;= modificationNumber ])		ifFalse: [ 			self error: 'Cluster ', self clusterID printString, ': New modification number ', anInteger printString, 				' is lower than current (', modificationNumber printString, ')'		].	modificationNumber := anInteger</body><body package="COFramesystem">notifyRead	| clusterManager |	clusterManager := self clusterManager.	clusterManager notNil ifTrue: [ clusterManager notifyReadCluster: self ].</body><body package="COFramesystem">numberOfFrames	^ self valueHolder size</body><body package="COFramesystem">numberOfLazyFrames	^self frames inject: 0 into: [:sum :f | f basicValueHolder notNil			ifTrue: [sum]			ifFalse: [sum + 1]]</body><body package="COFramesystem">propagateNonWeakObserver	mayHaveNonWeakObserver := true</body><body package="COFramesystem">removeForRollback: cell 	" for rollback: restore the old cell value "	( cell isCoastFrame and: [ cell cellContainer == self ]) ifTrue: 		[	cell cellContainer: nil.			self valueHolder coastInternalRemoveKey: cell frameID.			cell setInvalidFrameID.		].</body><body package="COFramesystem">restoreOldValue: undefined transaction: transaction 	" for rollback: restore the old cell value "	| agenda |	agenda := transaction combinedAgenda.	agenda createdCells do: [: cell | self removeForRollback: cell ].	agenda accessedUnregisteredCells keysDo: [: cell | self removeForRollback: cell ].	self numberOfFrames = 0 ifTrue: [ self clusterManager addReusableCluster: self ].</body><body package="COFramesystem">transactionManager	| cm |	cm := self clusterManager.	^ cm isNil		ifTrue: [ nil ]		ifFalse: [ cm transactionManager ]</body><body package="COFramesystem">unmarshaller	^unmarshaller</body><body package="COFramesystem">volume	^self clusterManager volume</body><body package="COFramesystem">volumeManager	^ self clusterController volumeManager</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>basic accessing</category><body package="COFramesystem">basicAdministrationFrame	^self directTableAccessAt: 0</body><body package="COFramesystem">directTableAccessAt: key	^self cellValue at: key ifAbsent: [ nil ]</body><body package="COFramesystem">directTableAccessAt: key put: cell 	(self cellValue includesKey: key) ifTrue: [ self error: 'Frame ', key printString, ' already registered in cluster ', self id printString ].	^ self cellValue at: key put: cell</body><body package="COFramesystem">replaceFrameAt: frameID with: anotherFrame	(self cellValue includesKey: frameID) ifFalse: [ self error: 'Frame ', frameID printString, ' not registered in cluster ', self id printString ].	^ self cellValue at: frameID put: anotherFrame</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>garbage collect</category><body package="COFramesystem">dumpCells: someCellIDs	| keepIDs keepFrames |	keepIDs := (self valueHolder keys - someCellIDs) asArray.	keepFrames := keepIDs collect: [ :fID | self directTableAccessAt: fID ].	self initializeValueHolder.	keepIDs with: keepFrames do: [ :fID :frame | self directTableAccessAt: fID put: frame ].</body><body package="COFramesystem">frames	" all frames stored in the cluster "	^  self resolvedCellValue values</body><body package="COFramesystem">framesDo: aBlock	" evaluate the block with all frames stored in the cluster "	self resolvedCellValue do: aBlock</body><body package="COFramesystem">invalidateAllFrames	self resolvedCellValue values		do: 			[:frame | 			frame invalidateSlotObservers.			frame invalidateObservers]</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>namespace</category><body package="COFramesystem">generateIDForCell: aCatCSCell	"generate and assign a new random id in the given range"	| r |	r := aCatCSCell coastHashOrNil ifNil: [ self class generateNextID ].	[		self cellValue includesKey: r.	] whileTrue: [ r := self class generateNextID ].	aCatCSCell id: r.</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>initialize-release</category><body package="COFramesystem">initializeAdministrationFrame	| clusterAdministrationFrame |	clusterAdministrationFrame := CatCSClusterAdministrationFrame new.	clusterAdministrationFrame id: 0.	self addCellWithID: clusterAdministrationFrame.</body><body package="COFramesystem">initializeCluster	modificationNumber := 1.	" magic number, must be &gt; 0 (0 is: cluster doesn't exist) "	self initializeValueHolder.</body><body package="COFramesystem">initializeValueHolder	self valueHolder: self valueHolderClass new.</body><body package="COFramesystem">releaseCluster	self closeClusterStream.</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>naming service</category><body package="COFramesystem">rootFrames	"rootFrames are those to start the reachability-check from"	| adm |	adm := self basicAdministrationFrame.	^adm isNil		ifTrue: [ Set new ]		ifFalse: [ adm basicRootFrames ]</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>private</category><body package="COFramesystem">notifyFastRead: aFrame	clusterController notNil ifTrue: [ clusterController notifyFastRead: aFrame in: self ]</body><body package="COFramesystem">valueHolderClass	^ CatCSFrameDictionary</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>inspecting</category><body package="COFramesystem">idPrintStringOn: stream 	stream nextPut: $[.	self id printOn: stream.	stream nextPut: $].</body></methods><methods><class-id>COAST.CatCSCluster</class-id> <category>marshalling - binary</category><body package="COMarshalling">marshallBinaryClusterInfoTo: aStream marshaller: aCatRMMarshall 	aStream nextPutAll: aCatRMMarshall saveMagicWord asByteArray.	CoastVersion defaultCoastVersion marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">marshallBinaryHeaderTo: aStream marshaller: aCatRMMarshall 	"cluster identification (do not store the volume name!) "	aStream nextOptimized32Put: self id.	" modification number "	aStream nextUnsigned32Put: self modificationNumber.</body><body package="COMarshalling">marshallBinaryTo: externalStream marshaller: aCatRMMarshallBinary 	aCatRMMarshallBinary currentClusterID: self clusterID.	aCatRMMarshallBinary marshallClusterBody: self to: externalStream.	"aCatRMMarshallBinary currentCluster: nil." "unnÃ¶tig weil man den marshaller sowieso nicht recyclen darf"	self closeClusterStream.</body><body package="COMarshalling">unmarshallBinaryBodyFrom: aStream marshaller: aCatRMMarshall 	aCatRMMarshall unmarshallClusterBody: self from: aStream</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	"load the header"	unmarshaller := aCatRMMarshall.	self unmarshallBinaryHeaderFrom: aStream.	aCatRMMarshall lazyLoad ifFalse: 		[	"load the body "			self unmarshallBinaryBodyFrom: aStream marshaller: aCatRMMarshall		].</body><body package="COMarshalling">unmarshallBinaryHeaderFrom: aStream 	" read version numbers and names "	" do not load the cluster info, because this is already done by the class methods "	"load cluster id"	self id: aStream nextOptimized32.	" modification number "	self modificationNumber: aStream nextUnsigned32.</body></methods><methods><class-id>COAST.CatCSCluster class</class-id> <category>instance creation</category><body package="COMarshalling">loadFromStream: externalStream marshaller: aCatRMMarshall 	| clusterToLoad clusterClass stream |	stream := CoastHashStream originalStream: externalStream.	clusterClass := self loadClusterInfoFromStream: stream marshaller: aCatRMMarshall.	"in case of lazyLoad, the clusterController already has a cluster - otherwise create a new one"	clusterToLoad := aCatRMMarshall clusterController clusterStub ifNil: [ clusterClass basicNew ].	clusterToLoad unmarshallBinaryFrom: stream marshaller: aCatRMMarshall.	aCatRMMarshall verifyCoastHashOn: stream.	^ clusterToLoad</body><body package="COMarshalling">loadHeaderFromStream: aStream marshaller: aCatRMMarshall 	"load the cluster header from the stream"	| newCluster clusterClass |	clusterClass := self loadClusterInfoFromStream: aStream marshaller: aCatRMMarshall.	^ clusterClass isNil 		ifTrue: [ nil ]		ifFalse: 		[	newCluster := clusterClass basicNew.			newCluster unmarshallBinaryHeaderFrom: aStream.			newCluster		]</body><body package="COFramesystem">named: clusterIDInteger	^self newCluster id: clusterIDInteger; yourself</body><body package="COFramesystem">newCluster	^self basicNew initializeCluster</body></methods><methods><class-id>COAST.CatCSCluster class</class-id> <category>private</category><body package="COMarshalling">loadClusterInfoFromStream: aStream marshaller: aCatRMMarshall 	| loadMagicWord | 	loadMagicWord := aStream peek = 16r43 			ifTrue: [( aStream nextAvailable: 5 ) asByteString ]			ifFalse: [ aStream nextShortString ].	aCatRMMarshall loadMagicWord: loadMagicWord.	aCatRMMarshall loadCoastVersion: ( CoastVersion unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ).	( aCatRMMarshall loadCoastVersion isMax: 5 minor: 1 ) ifTrue: 		[	"we never realy used this. how should the mediator know, anyway?"			aStream nextShortString.	"loadApplicationName"			CoastVersion unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	"loadApplicationVersion:"		].	" coast 2.1 or higher: also load the cluster class name "	(( aCatRMMarshall loadCoastVersion isMin: 2 minor: 1 ) and: [ aCatRMMarshall loadCoastVersion isMax: 4 minor: 3 ]) 		ifTrue: [ aStream nextShortString ].	" however, coast 4.3 ignores this ;-) "	^ CatCSCluster</body></methods><methods><class-id>COAST.CoastApplicationLogEntry</class-id> <category>accessing</category><body package="COTransactions">addKey: aKey value: aValue	aValue isCoastPrimitiveValue		ifFalse: [ self error: 'Log value is not a primitive "', aValue printString, '"' ].	keys add: aKey.	values add: aValue.</body><body package="COTransactions">associations	| associations |	associations := OrderedCollection new: keys size.	1 to: keys size do: [ : i |		associations add: (keys at: i) -&gt; (values at: i)	].	^ associations</body><body package="COTransactions">keysAndValuesDo: aBlock	keys with: values do: aBlock</body><body package="COTransactions">numEntries	^ keys size</body><body package="COTransactions">valueAtKey: aKey 	| idx |	idx := keys indexOf: aKey ifAbsent: [ ^ nil ].	^ values at: idx</body></methods><methods><class-id>COAST.CoastApplicationLogEntry</class-id> <category>initialize-release</category><body package="COTransactions">initialize 	keys := OrderedCollection new.	values := OrderedCollection new.</body></methods><methods><class-id>COAST.CoastApplicationLogEntry</class-id> <category>printing</category><body package="COTransactions">printOn: aStream	| index |	index := keys indexOf: 'ActionID' ifAbsent: [ nil ].	index notNil ifTrue: [ 	aStream nextPutAll: ( values at: index ). ]		ifFalse: [ super printOn: aStream ].</body></methods><methods><class-id>COAST.CoastApplicationLogEntry</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: keys size.	keys with: values		do: 		[: key : value |			key marshallBinaryTo: aStream marshaller: aCatRMMarshall.			value marshallBinaryTo: aStream marshaller: aCatRMMarshall		].</body><body package="COTransactions">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	| numKeys |	numKeys := aStream nextOptimized32.	keys := Array new: numKeys.	values := Array new: numKeys.	1 to: numKeys do: [ : i |		| key value |		key := aCatRMMarshall unmarshallPrimitiveValueFrom: aStream.		value := aCatRMMarshall unmarshallPrimitiveValueFrom: aStream.		keys at: i put: key.		values at: i put: value.	].</body></methods><methods><class-id>COAST.CoastApplicationLogEntry class</class-id> <category>instance creation</category><body package="COTransactions">new	^ super new initialize</body></methods><methods><class-id>COAST.CoastAbortTransactionNotification</class-id> <category>private - actions</category><body package="COTransactions">defaultAction	" no one cared about the notifiaction "	CoastUnhandledAbortTransactionNotification raiseSignal</body></methods><methods><class-id>COAST.CatFSDemon</class-id> <category>accessing</category><body package="COFramesystem">argument	^argument</body><body package="COFramesystem">argument: anArgument	argument:=anArgument</body><body package="COFramesystem">demonType	^''</body><body package="COFramesystem">endTransactionJob	^ endTransactionJob</body><body package="COFramesystem">endTransactionJob: aJob	endTransactionJob := aJob</body><body package="COFramesystem">endTransactionPerform: anAccess 	(endTransactionJob notNil and: [ self isResponsibleFor: anAccess ])		ifTrue: [ endTransactionJob value: self value: anAccess value: anAccess cell ].</body><body package="COFramesystem">hasEndTransactionJob	^ endTransactionJob notNil</body><body package="COFramesystem">hasEndTransactionJobWithAccess: aCatCSCellAccess	^self hasEndTransactionJob and: [ self isResponsibleFor: aCatCSCellAccess ]</body><body package="COFramesystem">hasPostJob	^ self postJob notNil</body><body package="COFramesystem">hasPostTransactionJob	^ postTransactionJob notNil</body><body package="COFramesystem">hasPostTransactionJobWithAccess: aCatCSCellAccess	^self hasPostTransactionJob and: [ self isResponsibleFor: aCatCSCellAccess ]</body><body package="COFramesystem">hasPreJob	^ self preJob notNil</body><body package="COFramesystem">name	^name</body><body package="COFramesystem">name: aSymbol	name := aSymbol</body><body package="COFramesystem">postJob	^ postJob</body><body package="COFramesystem">postJob: aBlock	postJob := aBlock</body><body package="COFramesystem">postTransactionJob	^ postTransactionJob</body><body package="COFramesystem">postTransactionJob: aJob	postTransactionJob := aJob</body><body package="COFramesystem">postTransactionPerform: anAccess 	(postTransactionJob notNil and: [ self isResponsibleFor: anAccess ])		ifTrue: [ postTransactionJob value: self value: anAccess value: anAccess cell ].</body><body package="COFramesystem">preJob	^ preJob</body><body package="COFramesystem">preJob: aBlock	preJob := aBlock</body><body package="COFramesystem">read	^ read</body><body package="COFramesystem">write	^ write</body></methods><methods><class-id>COAST.CatFSDemon</class-id> <category>priority</category><body package="COFramesystem">defaultPriority	" Priorities are signed integers. Larger numbers mean higher priorities. Default is 0 "	priority := 0</body><body package="COFramesystem">hasHigherPriorityThan: aDemon	^ self priority &gt; aDemon priority</body><body package="COFramesystem">highestSystemPriority	priority :=  200</body><body package="COFramesystem">highestUserPriority	priority :=  100</body><body package="COFramesystem">lowestSystemPriority	priority :=  -200</body><body package="COFramesystem">lowestUserPriority	priority :=  -100</body><body package="COFramesystem">priority	^ priority</body><body package="COFramesystem">priority: anInteger	" Give the demon an explicit priority. "	priority := anInteger</body><body package="COFramesystem">systemPriority: anInteger	" Give the demon an explicit priority. Halt if it is not	a system priority "	(self isSystemPriority: anInteger)		ifFalse: [ self halt: 'The demon requires a system priority'. ].	self priority: anInteger</body><body package="COFramesystem">userPriority: anInteger	" Give the demon an explicit priority. Halt if it is not	a user priority "	(self isUserPriority: anInteger)		ifFalse: [ self halt: 'The demon requires a user priority'. ].	self priority: anInteger</body></methods><methods><class-id>COAST.CatFSDemon</class-id> <category>private</category><body package="COFramesystem">isSystemPriority: anInteger	"Answer true, if anInteger represents a system priority "	^ self class systemPriorities contains: anInteger</body><body package="COFramesystem">isUserPriority: anInteger	"Answer true, if anInteger represents a user priority "	^ self class userPriorities contains: anInteger</body></methods><methods><class-id>COAST.CatFSDemon</class-id> <category>private accessing</category><body package="COFramesystem">isResponsibleFor: aCatCSCellAccess	" for compatibility only. responsibility must be decided by looking at the class "	^ self isResponsibleForAccessClass: aCatCSCellAccess class</body><body package="COFramesystem">isResponsibleForAccessClass: aCatCSCellAccessClass	^ ((write and: [ aCatCSCellAccessClass isWriteAccess ])		or: [ read and: [ aCatCSCellAccessClass isReadAccess ]])		or: [ write not and: [ read not and: [ aCatCSCellAccessClass isUpdateAccess ]]]</body><body package="COFramesystem">read: bool	read := bool</body><body package="COFramesystem">write: bool	write := bool</body></methods><methods><class-id>COAST.CatFSDemon</class-id> <category>action</category><body package="COFramesystem">actionPostAccess: aCatCSCellAccess	"if the demon feels responsible, it can activate the postJob now"	"additionally attach me to the cell access if any endTransaction or postTransaction jobs due"	postJob isNil ifFalse: [ postJob value: self value: aCatCSCellAccess value: aCatCSCellAccess cell].</body><body package="COFramesystem">actionPreAccess: aCatCSCellAccess	"if the demon feels responsible, it can activate the preJob now"	"additionally attach me to the cell access if any endTransaction or postTransaction jobs due"	preJob isNil ifFalse: [ preJob value: self value: aCatCSCellAccess value: aCatCSCellAccess cell].</body><body package="COFramesystem">updateActionPostAccess: aCatCSCellAccess	"the demon can activate the postJob now"	"additionally attach me to the cell access if any endTransaction or postTransaction jobs due"	postJob isNil ifFalse: [ postJob value: self value: aCatCSCellAccess value: aCatCSCellAccess cell].</body></methods><methods><class-id>COAST.CatFSDemon</class-id> <category>printing</category><body package="COFramesystem">printOn: stream 	stream nextPut: $[.	self priority printOn: stream.	stream nextPutAll: '] '.	self name printOn: stream.	stream nextPutAll: ' ('.	stream nextPutAll: self demonType.	stream nextPutAll: ')'</body></methods><methods><class-id>COAST.CatFSDemon</class-id> <category>initialize-release</category><body package="COFramesystem">initialize	write := read := false.</body></methods><methods><class-id>COAST.CatFSDemon</class-id> <category>testing</category><body package="COFramesystem">interestedInPreIsolate	^ false</body></methods><methods><class-id>COAST.CatFSDemon class</class-id> <category>priorities</category><body package="COFramesystem">defaultPriority	" Priorities are signed integers. Larger numbers mean higher priorities. Default is 0 "	^ 0</body><body package="COFramesystem">highestSystemPriority	^ 200</body><body package="COFramesystem">highestUserPriority	^ 100</body><body package="COFramesystem">lowestSystemPriority	^ -200</body><body package="COFramesystem">lowestUserPriority	^ -100</body><body package="COFramesystem">systemPriorities	^self lowestSystemPriority to: self highestSystemPriority.</body><body package="COFramesystem">userPriorities	^self lowestUserPriority to: self highestUserPriority.</body></methods><methods><class-id>COAST.CatFSDemon class</class-id> <category>instance creation</category><body package="COFramesystem">endTransactionJob: endBlock	^(self new) 		endTransactionJob: endBlock;		yourself</body><body package="COFramesystem">new	^ (super new initialize)		defaultPriority;		yourself.</body><body package="COFramesystem">postJob: aBlock	^(self new) 		postJob: aBlock; 		yourself</body><body package="COFramesystem">postTransactionJob: endBlock	^(self new) 		postTransactionJob: endBlock;		yourself</body><body package="COFramesystem">preJob: aBlock	^(self new) 		preJob: aBlock; 		yourself</body><body package="COFramesystem">preJob: aBlock postJob: anotherBlock	" Give the demon also a priority "	^(self new) 		preJob: aBlock; 		postJob: anotherBlock; 		yourself</body><body package="COFramesystem">readOnly	"create a new demon that will be triggered when reading a cell"	| d |	d := self new.	d read: true.	^d</body><body package="COFramesystem">readWrite	"create a new demon that will be triggered when reading or writing a cell"	| d |	d := self new.	d read: true.	d write: true.	^d</body><body package="COFramesystem">update	"create a new demon that will be triggered when updating a virtual cell"	| d |	d := self new.	^d</body><body package="COFramesystem">writeOnly	"create a new demon that will be triggered when writing a cell"	| d |	d := self new.	d write: true.	^d</body></methods><methods><class-id>COAST.CatRMTransactionID</class-id> <category>comparing</category><body package="COTransactions">&lt; anotherTID 	^ clientID = anotherTID clientID 		ifTrue: [ clusterLocator &lt; anotherTID clusterLocator ]		ifFalse: [ clientID &lt; anotherTID clientID ]</body><body package="COTransactions">= anotherTID 	^anotherTID class = self class and: 		[ clientID = anotherTID clientID and: 		[ localSeqNum = anotherTID localSeqNum			and: [ clusterLocator = anotherTID clusterLocator ]]]</body><body package="COTransactions">hash	^clusterLocator hash</body></methods><methods><class-id>COAST.CatRMTransactionID</class-id> <category>accessing</category><body package="COTransactions">basedOnGlobal	^basedOnGlobal</body><body package="COTransactions">basedOnGlobal: aGlobalSeqNum	basedOnGlobal := aGlobalSeqNum</body><body package="COTransactions">basedOnLocal	^basedOnLocal</body><body package="COTransactions">basedOnLocal: aLocalSeqNum	basedOnLocal := aLocalSeqNum</body><body package="COTransactions">clientID	^clientID</body><body package="COTransactions">clientID: aValue	clientID := aValue</body><body package="COTransactions">clusterLocator	^clusterLocator</body><body package="COTransactions">clusterLocator: aCatCSClusterLocator	clusterLocator := aCatCSClusterLocator</body><body package="COTransactions">globalSeqNum	"the global sequence number may be nil - this is valid	until another number is assigned by the mediator."	^ globalSeqNum</body><body package="COTransactions">globalSeqNum: aValue	globalSeqNum := aValue</body><body package="COTransactions">localSeqNum	^localSeqNum</body><body package="COTransactions">localSeqNum: aValue	localSeqNum := aValue</body></methods><methods><class-id>COAST.CatRMTransactionID</class-id> <category>printing</category><body package="COTransactions">printClientDescriptionOn: aStream"	aStream nextPutAll: '(client '. clientID printOn: aStream.	aStream nextPutAll: ')'."	self printShortOn: aStream</body><body package="COTransactions">printOn: str	str nextPutAll: 'client: '. clientID printOn: str.	str nextPutAll: ' volume: '; nextPutAll: clusterLocator printString.	str nextPutAll: ' local: '. localSeqNum printOn: str.	str nextPutAll: ' ('. basedOnLocal printOn: str.	str nextPutAll: ') global: '. globalSeqNum printOn: str.	str nextPutAll: ' ('. basedOnGlobal printOn: str.	str nextPutAll: ')'.</body><body package="COTransactions">printShortOn: str	str nextPutAll: '(client '. clientID printOn: str.	str nextPutAll: ' '. clusterLocator volume printOn: str.	str nextPutAll: '/'. clusterLocator id printOn: str."	str nextPutAll: ','. localSeqNum printOn: str.	str nextPutAll: '-&gt;'. basedOnLocal printOn: str.	str nextPutAll: ','. globalSeqNum printOn: str.	str nextPutAll: '-&gt;'. basedOnGlobal printOn: str."	str nextPutAll: ')'.</body></methods><methods><class-id>COAST.CatRMTransactionID</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: self clientID.	aStream nextUnsigned32Put: localSeqNum.	aStream nextUnsigned32Put: ( globalSeqNum ifNil: [ 0 ]).	aStream nextUnsigned32Put: basedOnLocal.	aStream nextUnsigned32Put: basedOnGlobal.	self clusterLocator marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COTransactions">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	clientID := aStream nextOptimized32.	localSeqNum := aStream nextUnsigned32.	globalSeqNum := aStream nextUnsigned32.	globalSeqNum = 0 ifTrue: [ globalSeqNum := nil ].	basedOnLocal := aStream nextUnsigned32.	basedOnGlobal := aStream nextUnsigned32.	clusterLocator := CatCSClusterLocator unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>accessing</category><body package="COFramesystem">access: aCatCSCellAccess 	" Access the value of the cell. If the value is not valid, it is recomputed and the update	demons are triggered "	^aCatCSCellAccess isWriteAccess		ifTrue: [ "Only perform internal write accesses"			self writeAccessOnVirtualCellError ]		ifFalse: 	[ self basicAccessInTransaction: aCatCSCellAccess transaction ]</body><body package="COFramesystem">basicAccessInTransaction: transaction 	| i |	^ self isPrototype 		ifTrue: 		[	CoastLog logDebugNotify: [ 'Skipped computation of ' , self printString ].			nil		]		ifFalse: 		[( transaction notNil and: [ transaction isTransient not ]) 				ifTrue: 				[	i := 1.					[	self computeValueInTransaction: transaction.						self isValid					] whileFalse: 						[	i := i + 1.							CoastLog logDebugNotify: [ 'Invalidation during computation of ' , self printString , ', computing again' ].							"see CatFSVirtualSlot&gt;&gt;coastInvalidate"							i &gt; self class maxInvalidationCycles 								ifTrue: [ self haltOrError: 'Invalidation/Computation cycle detected' ]						].					self buildUpDependenciesForTransaction: transaction access: nil.					self resolvedCellValue				]				ifFalse: 				[	self resolvedCellValue ifNil: 						[( valid ~~ true and: [ self mayComputeOutsideTranscation ]) 								ifTrue: [ self reallyComputeValue ]								ifFalse: [ nil ]						]				]		]</body><body package="COFramesystem">basicReadValue	| tm |	tm := self transactionManager.	tm notNil ifTrue: [ self buildUpDependenciesForTransaction: tm activeTransaction access: nil ].	^ self resolvedCellValue</body><body package="COFramesystem">composingMethod	^ self definition composingMethod</body><body package="COFramesystem">computeInSequence	^ self definition computeInSequence</body><body package="COFramesystem">computeInSequence: aBoolean	self definition computeInSequence: aBoolean</body><body package="COFramesystem">computedLazy</body><body package="COFramesystem">readAccess	^ self isValid 		ifTrue: [ self basicReadValue ]		ifFalse: [ self basicAccessInTransaction: self transactionManager activeTransactionOfCurrentProcess ]</body><body package="COTransactions">referencedClusterIDsSkip: skipFrames 	| result |	self isValid ifFalse: [ ^ #( )].	result := Set new.	self subjectsDo: [: subj | result addAll: ( subj referencedClusterIDsSkip: skipFrames ). ].	^ result</body><body package="COFramesystem">restoreOldValue: oldValue transaction: transaction	" for rollback: restore the old cell value "	" virtual slots are computed and therefore don't restore the old value "</body><body package="COFramesystem">value: anObject	self writeAccessOnVirtualCellError. "virtual Slots shouldn't be set by clients"</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>observer - subject</category><body package="COFramesystem">addObserverOnFrame: frame slotName: slotName 	| obsPair |	(subjectObserverPairs size &gt; 0 and: [ subjectObserverPairs size &lt; 5 ])		ifTrue: 		[	subjectObserverPairs do: 				[: subjectOrPair | ( SlotObserverPair isObserverPair: subjectOrPair equalToObserver: self subject: frame slotName: slotName ) 						ifTrue: [ ^ self ]				]		].	obsPair := SlotObserverPair observer: self frame: frame slotName: slotName.	frame addObserver: obsPair.	self addObserverPair: obsPair</body><body package="COFramesystem">addObserverPair: anObserverPair	subjectObserverPairs add: anObserverPair.</body><body package="COFramesystem">addSubject: aCatCSCell	subjects add: aCatCSCell.</body><body package="COFramesystem">allObservedClusterIDs	| allObservedClusterIDs |	allObservedClusterIDs := Set new.	self subjectsDo: [: subj | allObservedClusterIDs addAll: subj allObservedClusterIDs ].	^ allObservedClusterIDs</body><body package="COFramesystem">breakDependents	self valueHolder value breakDependents.	super breakDependents.</body><body package="COFramesystem">coastInvalidateDisresolved	" one of my subjects was disresolved "	self invalidate</body><body package="COFramesystem">coastInvalidateWithAccess: cellAccessOrNil 	" a subject of me has changed, so flush dependencies.	make sure that eager cells are immediatly computed at the end of the transaction  	 to detect cycles uncomment the following line "	" valid isNil ifTrue: [ self haltOrContinue ]. "	valid ~~ false 		ifTrue: 		[	self isValid: false.			self transactionManager activeTransaction startInvalidationPhase.			self invalidateObservers.			self definition revalidationBlock 				ifNil: [ self flushSubjects ]				ifNotNil: [: revalidationBlock | self revalidateWithAccess: cellAccessOrNil block: revalidationBlock ].			self transactionManager activeTransaction endInvalidationPhase.			self finishInvalidate		]		ifFalse: 		[	self definition revalidationBlock 				ifNotNil: [: revalidationBlock | self revalidateWithAccess: cellAccessOrNil block: revalidationBlock ]		].	^ false</body><body package="COFramesystem">coastRemoveObserverPair: anObserverPair 	subjectObserverPairs remove: anObserverPair ifAbsent: [ ].</body><body package="COFramesystem">coastRemoveSubject: aCatCSCell 	subjects remove: aCatCSCell ifAbsent: [ ].</body><body package="COFramesystem">finishInvalidate</body><body package="COFramesystem">finishObservation	self flushSubjects.	valid := true. "do not recompute anymore, hope this reduces unnecessary eager computations. CS 3/99"	super finishObservation.</body><body package="COFramesystem">flushSubjects	(subjects notNil or: [ subjectObserverPairs notNil ])		ifTrue: [			self subjectsDo: [ :s | s removeObserver: self].			self initializeSubjects.		].</body><body package="COFramesystem">initializeSubjects	subjects := IdentitySet new.	subjectObserverPairs := Set new.</body><body package="COFramesystem">invalidate	self coastInvalidate</body><body package="COFramesystem">releaseSubjects	subjects notNil 		ifTrue: [ subjects do: [: s | s removeObserver: self ]].	 subjectObserverPairs notNil		ifTrue: [ subjectObserverPairs do: [: s | s removeObserver: self ]].	subjects := nil.	subjectObserverPairs := nil.</body><body package="COFramesystem">revalidateWithAccess: cellAccessOrNil block: revalidationBlock 	( cellAccessOrNil class = CatCSAtKeyPutAccess and: [ cellAccessOrNil cell isCoastFrame ]) 		ifTrue: 		[	"just switch the observer from frame to slot"			cellAccessOrNil arg2 addObserver: self access: cellAccessOrNil		]		ifFalse: 		[( cellAccessOrNil notNil and: [ revalidationBlock value: self value: cellAccessOrNil cell value: cellAccessOrNil differences ]) 				ifTrue: 				[	cellAccessOrNil cell addObserver: self access: cellAccessOrNil.					self isValid: true				]				ifFalse: [ self flushSubjects ]		].</body><body package="COFramesystem">revalidationBlock	^definition revalidationBlock</body><body package="COFramesystem">subjects	| allSubjects |	allSubjects := OrderedCollection new.	subjects notNil ifTrue: [ allSubjects addAll: subjects ].	subjectObserverPairs notNil ifTrue: [ allSubjects addAll: subjectObserverPairs ].	allSubjects beImmutable.	^ allSubjects</body><body package="COFramesystem">subjectsDo: aBlock	subjects notNil ifTrue: [ subjects do: aBlock ].	subjectObserverPairs notNil ifTrue: [ subjectObserverPairs do: aBlock ].</body><body package="COFramesystem">subjectsIncludes: anObject	^ (subjects notNil and: [subjects  includes: anObject ])		or: [ subjectObserverPairs notNil and: [ subjectObserverPairs  includes: anObject ]]</body><body package="COFramesystem">usesSubjectMechanism	" answer 'true' if the cell uses the automatic subject mechanism. to save space, 	subjects == nil indicates that the cell does not use this mechanism "	 ^ subjects notNil or: [ subjectObserverPairs notNil ]</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>testing</category><body package="COFramesystem">canFastRead	^self isValid</body><body package="COFramesystem">canFastReadFullValue	^ self canFastRead</body><body package="COFramesystem">isEager	^ self isLazy not</body><body package="COFramesystem">isLazy	" answer true, if the cell value is computed lazy (on demand). this is true by default "	^ true</body><body package="COFramesystem">isLocal	^true</body><body package="COFramesystem">isUnresolved	^ false</body><body package="COFramesystem">isValid	^ valid ifNil: [ false ]</body><body package="COFramesystem">isValidOrComputed	^ valid ~~ false</body><body package="COFramesystem">isVirtual	^true</body><body package="COFramesystem">mayComputeOutsideTranscation	^ self prototype notNil</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>inspecting</category><body package="COFramesystem">classLabel	^'virtual Slot'</body><body package="COFramesystem">printOn: aStream 	self isPrototype ifTrue: [ aStream nextPutAll: 'prototype of ' ].	self idPrintStringOn: aStream.	aStream nextPutAll: ' ('.	aStream nextPutAll: self classLabel.	valid == nil ifTrue: [ aStream nextPut: $? ].	valid == false ifTrue: [ aStream nextPut: $* ].	aStream nextPutAll: ')'.</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>compute</category><body package="COFramesystem">computeEager	"perform computation for an eager slot - ask my frame before 	starting the computation"	self frame allowsSlotComputation		ifTrue: [ self readAccess ]</body><body package="COFramesystem">updateEagerSlot	"perform computation for an eager slot - ask my frame before 	starting the computation"	self frame allowsSlotComputation		ifTrue: [ self readAccess ]</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>error handling</category><body package="COFramesystem">cycleInComputationError: transaction	| ccs |	InputState default ctrlDown ifTrue: [ ^ self ].	CoastLog logDebug: [ 'Cycle in computation of ',self printString , ' detected' ].	(transaction notNil and: [ (ccs := transaction composedCells) notNil ])		ifTrue: [			ccs reverseDo: [ :cc |				CoastLog logDebug: '	', cc printString.			].		].</body><body package="COFramesystem">writeAccessOnVirtualCellError	self error: 'Write accesses on virtual cells are not allowed'.</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>initialize-new</category><body package="COFramesystem">initializeSpawned	" make sure that eager cells are immediatly computed at the end of the transaction "	super initializeSpawned.	self initializeSubjects.	self isValid: false.</body><body package="COFramesystem">register	" not with me - virtual cells are local objects "</body><body package="COFramesystem">release	self finishObservation.	self releaseOldValue.	super release.</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>value access</category><body package="COFramesystem">postAccess: aCatCSCellAccess 	aCatCSCellAccess isWriteAccess 		ifFalse: [ self buildUpDependenciesForTransaction: aCatCSCellAccess transaction access: aCatCSCellAccess ]	" do not bother if the cell is written. this only happens during the		composition of the value "</body><body package="COFramesystem">releaseOldValue	| releaseBlock oldVal vh |	(releaseBlock := self definition releaseOldValueBlock) notNil		ifTrue: [ 			vh := self resolvedValueHolder.			oldVal := vh value.			oldVal notNil ifTrue: [ releaseBlock value: oldVal ].		].</body><body package="COFramesystem">rememberAccess: aCatCSCellAccess 	(aCatCSCellAccess isUpdateAccess and: [ self hasDemons ])  		ifTrue: [ aCatCSCellAccess transaction rememberAccessIfFirst: aCatCSCellAccess ]</body><body package="COFramesystem">valueAccess: aCatCSCellAccess 	self releaseOldValue.	^ super valueAccess: aCatCSCellAccess</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>demon - private</category><body package="COFramesystem">range	"virtual slots do not have a real range"	^Object</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>accessing - proto</category><body package="COFramesystem">composingMethod: aBlock	^ self definition composingMethod: aBlock</body><body package="COFramesystem">makeImmutable: aBoolean	^ self definition makeImmutable: aBoolean</body><body package="COFramesystem">releaseOldValueBlock: aBoolean 	^ self definition releaseOldValueBlock: aBoolean</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>initialize-release</category><body package="COFramesystem">slotDefinitionClass	^ CatCSVirtualSlotDefinition</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>computing</category><body package="COFramesystem">computeValueInTransaction: transaction 	" Recompute my value if necessary, but avoid cycles.	Return a boolean that indicates whether I was updated or not "	| actualDemons updateAccess |	^ self isValid 		ifTrue: [ false ]		ifFalse: 		[	transaction inInvalidationPhase ifTrue: [ self error: 'do not recompute in invalidation phase !' ].			( valid isNil and: [ transaction composedCells includes: self ]) 				ifTrue: 				[	" Either there is a cycle in the composing methods, or the value was not					composed properly the last time "					self setIsValid: true.	" avoid debuggers "					self cycleInComputationError: transaction.					false				]				ifFalse: 				[	valid isNil ifTrue: [ CoastLog logDebug: [ 'concurrent computation of: ' , self printString ] channel: #views ].					" Compose the value. To build up dependencies between cells, notify the					current transaction of the composition "					self setIsValid: nil.					transaction beginComposing: self.					[	updateAccess := CatCSValueUpdateAccess cell: self argument: self reallyComputeValue transaction: transaction.						self valueAccess: updateAccess.						" if the update block performs a write access that invalidates this slot again, this slot must stay invalid "						valid isNil ifTrue: [ self isValid: true ]					] ensure: [ transaction endComposing: self ].					actualDemons := self demons.					actualDemons notNil ifTrue: [ actualDemons do: [: d | d updateActionPostAccess: updateAccess ]].					true				]		]</body><body package="COFramesystem">reallyComputeValue	"compute the value now and return it"	| computedValue |	computedValue := self composingMethod value: self frame.	self definition makeImmutable		ifTrue: [ 	computedValue coastComputedValueBeImmutableIfNeeded ].	^ computedValue</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>accessing-private</category><body package="COFramesystem">isValid: aBoolean	self setIsValid: aBoolean.	aBoolean ifFalse: [ container coastInvalidatedSlot: self id ].</body><body package="COFramesystem">setIsValid: aBoolean 	valid := aBoolean.</body></methods><methods><class-id>COAST.CatFSVirtualSlot</class-id> <category>copying - private</category><body package="COFramesystem">copyValueHolderTo: anotherSlot with: copyContext</body></methods><methods><class-id>COAST.CatFSVirtualSlot class</class-id> <category>prototype creation</category><body package="COFramesystem">computedBy: aBlockOrSelector 	| newSlot composingMethod |	newSlot := self newPrototypeOfType: #virtualValue.	composingMethod := aBlockOrSelector isSymbol 			ifTrue: [ [: frame | frame perform: aBlockOrSelector ]]			ifFalse: [ aBlockOrSelector ].	newSlot composingMethod: composingMethod.	^ newSlot</body><body package="COFramesystem">newPrototypeOfType: aSlotType	^self newPrototype valueHolder: (self typeDictionary at: aSlotType) new</body><body package="COFramesystem">typeDictionary	typeDictionary isNil ifTrue:	[		typeDictionary := Dictionary new.		typeDictionary 				at: #bag put: CatCSBag; 				at: #dictionary put: CatCSDictionary; 				at: #orderedCollection put: CatCSOrderedCollection; 				at: #set put: CatCSSet; 				at: #singleValue put: CatCSSingleValue;			at: #virtualValue put: CatCSVirtualValue.	].	^typeDictionary</body></methods><methods><class-id>COAST.CatFSVirtualSlot class</class-id> <category>accessing</category><body package="COFramesystem">maxInvalidationCycles	^ MaxInvalidationCycles ifNil: [ 50 ]</body><body package="COFramesystem">maxInvalidationCycles: anInteger	MaxInvalidationCycles := anInteger</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>accessing - comfy</category><body package="COTransactions">addCreatedCell: cell	" create an object describing the creation. it is either a frame or a slot	creation "	cell isCoastFrame		ifTrue: [ self addFrameCreationOf: cell ]		ifFalse: [ self addSlotCreationOf: cell ]</body><body package="COTransactions">addReadAccess: aCatCSCellAccess	" add the read access only if it is an slot access (frame accesses can be constructed	by looking at the slot accesses). the slot access has to prepared for replication "	aCatCSCellAccess isSlotAccess ifTrue: [ self addSlotReadAccess: aCatCSCellAccess asRemoteSlotAccess ].</body><body package="COTransactions">addRemovedFrame: aFrame 	"remember the id of the removed frame"	frameRemoves add: ( CatRMFrameRemove frameID: aFrame frameID ).</body><body package="COTransactions">addRemovedSlot: aSlot 	"remember the id of the removed frame"	slotRemoves add: ( CatRMSlotRemove slot: aSlot frame: aSlot frame ).</body><body package="COTransactions">addUnpreparedReadAccess: aCatCSCellAccess	" remeber the access (which is not yet prepare for replication) "	aCatCSCellAccess isSlotAccess		ifTrue: [ unpreparedReadAccesses add: aCatCSCellAccess ]</body><body package="COTransactions">addWriteAccess: aCatCSCellAccess 	" add the write access only if it is an slot access (frame accesses can be constructed	by looking at the slot accesses). the slot access has to prepared for replication "	"Neue Version sammelt nur noch Slotaccesses auf"	aCatCSCellAccess isSlotAccess 		ifTrue: [ self addSlotWriteAccess: aCatCSCellAccess asRemoteSlotAccess ]		ifFalse: [ self halt: 'unexpected access: ' , aCatCSCellAccess ].</body><body package="COTransactions">prepareAccesses		unpreparedReadAccesses do: [ : aCatCSCellAccess |		self addSlotReadAccess: aCatCSCellAccess asRemoteSlotAccess ].	unpreparedReadAccesses := Set new.</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>accessing</category><body package="COTransactions">addFrameCreationOf: createdFrame 	frameCreations add: ( CatRMFrameCreation frameID: createdFrame id frameClassSymbol: createdFrame frameClassSymbol ).</body><body package="COTransactions">addSlotCreationOf: createdSlot 	slotCreations add: ( CatRMSlotCreation slot: createdSlot frame: createdSlot frame).</body><body package="COTransactions">addSlotReadAccess: aCatRMSlotAccess	slotReadAccesses add: aCatRMSlotAccess</body><body package="COTransactions">addSlotWriteAccess: aCatRMSlotAccess	slotWriteAccesses add: aCatRMSlotAccess</body><body package="COTransactions">agendaSize	^ self numberOfAccesses + self numberOfCreations</body><body package="COTransactions">cluster	^ cluster</body><body package="COTransactions">cluster: aCatCSCluster	cluster := aCatCSCluster.	self clusterLocator: aCatCSCluster clusterLocator.</body><body package="COTransactions">clusterID	^clusterLocator id</body><body package="COTransactions">clusterLocator	^ clusterLocator</body><body package="COTransactions">clusterLocator: aCatCSClusterLocator	clusterLocator := aCatCSClusterLocator</body><body package="COTransactions">frameCreations	^ frameCreations</body><body package="COTransactions">frameRemoves	^ frameRemoves</body><body package="COTransactions">isPrepared	^ isPrepared</body><body package="COTransactions">isPrepared: aBoolean	isPrepared := aBoolean</body><body package="COTransactions">numberOfAccesses	^slotWriteAccesses size + slotReadAccesses size</body><body package="COTransactions">numberOfCreations	^frameCreations size + slotCreations size</body><body package="COTransactions">numberOfUnpreparedAccesses	^ unpreparedReadAccesses size</body><body package="COTransactions">slotCreations	^ slotCreations</body><body package="COTransactions">slotReadAccesses	^slotReadAccesses</body><body package="COTransactions">slotRemoves	^ slotRemoves</body><body package="COTransactions">slotWriteAccesses	^slotWriteAccesses</body><body package="COTransactions">volumeManager	^ cluster volumeManager</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>rolling</category><body package="COTransactions">doCreationsForClusterController: aCatCSClusterController	" create all cells "self logRollFor: aCatCSClusterController.	self doFrameCreationsForClusterController: aCatCSClusterController.	self doSlotCreationsForClusterController: aCatCSClusterController.</body><body package="COTransactions">doFrameCreationsForClusterController: aCatCSClusterController	"create new instances and put them into the cluster of &lt;aCatCSClusterController&gt;"	self frameCreations do: [ :fc | aCatCSClusterController createFrame: fc ]</body><body package="COTransactions">doFrameRemovesForClusterController: aCatCSClusterController 	"remove instances from the cluster of &lt;aCatCSClusterController&gt;"	self frameRemoves do: [: fr | aCatCSClusterController cluster coastInternalRemoveFrame: fr ].</body><body package="COTransactions">doRemovesForClusterController: aCatCSClusterController 	self doSlotRemovesForClusterController: aCatCSClusterController.	self doFrameRemovesForClusterController: aCatCSClusterController.</body><body package="COTransactions">doSlotCreationsForClusterController: aCatCSClusterController 	" create new instances and put them in the frame "	| useProxyValueHolder msg |	useProxyValueHolder := aCatCSClusterController clusterManager useProxyValueHolder.	self slotCreations do: 		[: sc | | newSlot frame newSlotID |			frame := aCatCSClusterController cluster directTableAccessAt: sc frameID.			frame isNil 				ifTrue: 				[	msg := 'Frame not found - slot creation failed (frameID: ' , sc frameID printString , ' clusterID: ' 							, aCatCSClusterController cluster idPrintString , ' slotName: ' 							, sc slotName , ')'.					( CatFSFrameID isTempShared: sc frameID ) 						ifTrue: [ CoastLog logWarning: 'TempShared', msg ]						ifFalse: [( CoastError new messageText: msg ) raiseSignal ]				]				ifFalse: 				[					(frame slotExists: sc slotName asSymbol) ifFalse: "do not re-create the slot!"					[						newSlot := frame slotClass basicNew.						newSlotID := sc slotName asSymbol.						newSlot cellContainer: frame;							id: newSlotID;							valueHolder: sc valueHolderClass new.						useProxyValueHolder 							ifTrue: [ newSlot valueHolder changeToDelegatingProxyForSlot: newSlot ].						newSlot valueHolder clusterManagerIfNeeded: aCatCSClusterController clusterManager.						frame addSlotForUpdate: newSlot					]				]		].</body><body package="COTransactions">doSlotRemovesForClusterController: aCatCSClusterController 	"remove instances from the cluster of &lt;aCatCSClusterController&gt;"	self slotRemoves do: 		[: sr | | frame |			frame := aCatCSClusterController cluster directTableAccessAt: sr frameID.			frame notNil ifTrue: [ frame coastInternalRemoveSlotNamed: sr slotName ]		].</body><body package="COTransactions">hasValidSlotCreationsForClusterController: aCatCSClusterController loggedAgenda: loggedAgenda 	" false if any of the slots has already been created, or the frame does not exist "	| createdFrameIDs |	createdFrameIDs := nil.	self slotCreations do: 		[: sc | | frame slot |			frame := aCatCSClusterController cluster directTableAccessAt: sc frameID.			frame notNil 				ifTrue: 				[	slot := frame basicSlotNamed: sc slotName.					( slot notNil and: [ sc valueHolderClass ~~ slot valueHolder class ]) ifTrue: 						[							loggedAgenda addFailReason: (DuplicateSlotCreation conflictingAgenda: nil slotCreation: sc conflictingType: slot valueHolder class).							^ false						]				]				ifFalse: 				[	createdFrameIDs isNil ifTrue: 						[	createdFrameIDs := Set new: self frameCreations size.							self frameCreations do: [: fc | createdFrameIDs add: fc frameID ]						].					( createdFrameIDs includes: sc frameID ) ifFalse: 						[	loggedAgenda addFailReason: (CreateSlotOfUnknownFrame conflictingAgenda: nil slotCreation: sc).							^ false						]				]		].	^ true</body><body package="COTransactions">logRollFor: aCatCSClusterController 	COAST.CoastLog debugDo: 		[	COAST.CoastLog logDebug: aCatCSClusterController rollForwardDebugString.			self frameCreations do: [: fc | COAST.CoastLog logDebug: [ '+' , fc frameClassName displayString , ' ' , fc frameID printString ]].			self frameRemoves do: [: fr | COAST.CoastLog logDebug: [ '-' , fr frameID printString ]]		].</body><body package="COTransactions">rollForwardAccessesForClusterController: aCatCSClusterController 	" roll forward the accesses of the remote transaction "	self rollForwardAccessesForClusterController: aCatCSClusterController transaction: nil</body><body package="COTransactions">rollForwardAccessesForClusterController: aCatCSClusterController transaction: aTransaction 	" roll forward the accesses of the remote transaction "	| msg |	aCatCSClusterController clusterManager isNil 		ifTrue: [ ^ self	"urgs" ].	cluster := aCatCSClusterController cluster.	self slotWriteAccesses do: 		[: slotAccess | | frame |			frame := self frameAtCluster: cluster id: slotAccess frameID.			frame isNil 				ifTrue: 				[	msg := 'Frame  not found - slot access failed (' , slotAccess printString , ')'.					( CatFSFrameID isTempShared: slotAccess frameID ) 						ifTrue: [ CoastLog logWarning: 'TempShared', msg ]						ifFalse: [( CoastFatalError new messageText: msg ) raiseSignal ]				]				ifFalse: 				[	frame slotAccessForUpdate: slotAccess argumentTranslationBlock: [: arg | arg translatedArgumentForCluster: cluster ] transaction: aTransaction				]		].</body><body package="COTransactions">rollForwardForClusterController: aCatCSClusterController 	^ self rollForwardForClusterController: aCatCSClusterController transaction: nil</body><body package="COTransactions">rollForwardForClusterController: aCatCSClusterController transaction: aTransaction 	" roll forward the remote transaction. create all cells first, then perform the accesses "	self doCreationsForClusterController: aCatCSClusterController.	[	aTransaction notNil ifTrue: [ Processor activeTransaction: aTransaction ].		self rollForwardAccessesForClusterController: aCatCSClusterController transaction: aTransaction.		self doRemovesForClusterController: aCatCSClusterController	] ensure: [ aTransaction notNil ifTrue: [ Processor removeActiveTransaction.	"this will revoke the previous transaction" ]].	( aTransaction notNil and: [ aTransaction combinedAgenda isEmpty not ]) ifTrue: [ aTransaction reduceRollingAgenda ].</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>private</category><body package="COTransactions">frameAtCluster: aCluster id: frameID	" Returns the frame with the given ID in the given cluster "		^ aCluster directTableAccessAt: frameID</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>testing</category><body package="COTransactions">isEmpty	^ false</body><body package="COTransactions">isReadOnly	^ frameCreations isEmpty and: [ frameRemoves isEmpty and: [ slotCreations isEmpty and: [ slotRemoves isEmpty and: [ slotWriteAccesses isEmpty ]]]]</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>concurrency control</category><body package="COTransactions">checkFrameCreationsAgainst: aCatCSSimpleAgenda loggedAgenda: loggedAgenda 	" we have to check that no two frames were created with the same ID. this might	happen since every client creates IDs by simply creating a pseudo-random number"	aCatCSSimpleAgenda frameCreations do: 		[: fc | ( self frameCreations 				detect: [: anotherFc | ( anotherFc isCommutativeTo: fc ) not ]				ifNone: [ nil ]) notNil ifTrue: 				[					loggedAgenda addFailReason: (FrameIDCollision conflictingAgenda: aCatCSSimpleAgenda conflictingFrameCreation: fc).					" generate a new seed "					CatCSCluster initializeRandomStream.					^ false				]		].	^ true</body><body package="COTransactions">checkFrameRemovesAgainst: aCatCSSimpleAgenda loggedAgenda: loggedAgenda 	^ ( self checkOwnFrameRemovesAgainst: aCatCSSimpleAgenda loggedAgenda: loggedAgenda ) and: [ aCatCSSimpleAgenda checkOwnFrameRemovesAgainst: self loggedAgenda: loggedAgenda ]</body><body package="COTransactions">checkOwnFrameRemovesAgainst: aCatCSSimpleAgenda loggedAgenda: loggedAgenda 	" we have to check that no removed frame was used in a slotWriteAccess (neither the frame nor any argument)"	aCatCSSimpleAgenda frameRemoves do: 		[: fr | | removedID |			removedID := CatFSFrameID id: fr frameID.			self slotWriteAccesses do: 				[: writeAccess | ( writeAccess referencesRemovedFrame: removedID ) ifTrue: 						[							loggedAgenda addFailReason: (AccessConflict conflictingAgenda: aCatCSSimpleAgenda conflictingAccess: fr ownAccess: writeAccess).							^ false						]				]		].	^ true</body><body package="COTransactions">checkSlotCreationsAgainst: aCatCSSimpleAgenda loggedAgenda: loggedAgenda 	" check that no newly created slots were read by the other transaction, so check	slot creations against frame accesses. frame accesses are only implicit described	by slot accesses (every slot access implies a frame access)	"	^ ( self simpleCheckSlotCreationsAgainst: aCatCSSimpleAgenda loggedAgenda: loggedAgenda ) 		and: [ aCatCSSimpleAgenda simpleCheckSlotCreationsAgainst: self loggedAgenda: loggedAgenda ]</body><body package="COTransactions">isCommutativeTo: aCatCSSimpleAgenda loggedAgenda: loggedAgenda 	"tests whether two transactions are serially independent or not; 	that means, whether the execution-order of the transactions is unimportant or not"	| swapped accesses1 accesses2 |	( self checkFrameRemovesAgainst: aCatCSSimpleAgenda loggedAgenda: loggedAgenda ) ifFalse: [ ^ false ].	( self checkFrameCreationsAgainst: aCatCSSimpleAgenda loggedAgenda: loggedAgenda ) ifFalse: [ ^ false ].	( self checkSlotCreationsAgainst: aCatCSSimpleAgenda loggedAgenda: loggedAgenda ) ifFalse: [ ^ false ].	accesses1 := self prepareSlotAccessList.	accesses2 := aCatCSSimpleAgenda prepareSlotAccessList.	swapped := false.	accesses1 size &gt; accesses2 size ifTrue: 		[ "let accesses1 be the smaller dictionary for faster conflict-test"			| temp |			temp := accesses1.			accesses1 := accesses2.			accesses2 := temp.			swapped := true.		].	accesses1 keysAndValuesDo: 		[: cell1 : accessesToCell1 |			"conflict-test"			"for every accessed cell in transaction1"			( accesses2 includesKey: cell1 ) ifTrue: 				[	"are there accesses to the same cell in transaction2? if yes:"					accessesToCell1 do: 						[: access1 |							"for every access to this cell of transaction1"							( accesses2 at: cell1 ) do: 								[: access2 |									"for every access to this cell of transaction2"									( access1 isCommutativeTo: access2 ) ifFalse: 										[	"perform conflict-test between this accesses"											swapped												ifTrue: [ loggedAgenda addFailReason: (AccessConflict conflictingAgenda: aCatCSSimpleAgenda conflictingAccess: access1 ownAccess: access2) ]												ifFalse: [ loggedAgenda addFailReason: (AccessConflict conflictingAgenda: aCatCSSimpleAgenda conflictingAccess: access2 ownAccess: access1) ].											^ false										]								]						]				]		].	"if only one fails, the transactions are not compatible"	"hurra!"	^ true</body><body package="COTransactions">prepareSlotAccessList	"create one dictionary for every transaction with accessed slots as key	and the list of accesses to this slot as value. do not bother about accesses to newly created cells"	slotAccessList isNil ifTrue: 		[	slotAccessList := Dictionary new: (( slotReadAccesses size + slotWriteAccesses size ) * 6 / 5 ) asInteger.			self slotReadAccesses 				do: [: slotAccess | ( slotAccessList at: slotAccess ifAbsentPut: [ OrderedCollection new: 1 ]) add: slotAccess ].			self slotWriteAccesses 				do: [: slotAccess | ( slotAccessList at: slotAccess ifAbsentPut: [ OrderedCollection new: 1 ]) add: slotAccess ]		].	^ slotAccessList</body><body package="COTransactions">simpleCheckSlotCreationsAgainst: aCatCSSimpleAgenda loggedAgenda: loggedAgenda 	" unidirectional check. see  #checkSlotCreationsAgainst for comments"	self slotCreations do: 		[: slotCreation |			" do not allow different creation of slots. may be allowed, if duplicate creations are discarded "			aCatCSSimpleAgenda slotCreations do: 				[: anotherCreation | ( slotCreation frameID = anotherCreation frameID and: 						[	slotCreation slotName = anotherCreation slotName and: [ slotCreation valueHolderClass ~~ anotherCreation valueHolderClass ]						]) 						ifTrue: 						[							loggedAgenda addFailReason: (DuplicateSlotCreation conflictingAgenda: nil slotCreation: slotCreation conflictingType: anotherCreation valueHolderClass).							^ false						]				]		].	^ true</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>sanity check</category><body package="COTransactions">checkAgendaSize	self checkNumberOfFrameCreations: frameCreations size.	self checkNumberOfFrameRemoves: frameRemoves size.	self checkNumberOfSlotCreations: slotCreations size.	self checkNumberOfSlotRemoves: slotRemoves size.	self checkNumberOfSlotWriteAccesses: slotWriteAccesses size.	self checkNumberOfSlotReadAccesses: slotReadAccesses size.</body><body package="COTransactions">checkNumberOfFrameCreations: numberOfFrameCreations	numberOfFrameCreations &gt; self class maxAllowedWriteSize		ifTrue: [ CoastError raiseSignal: 'Number of frame creations exceeds limit: ', numberOfFrameCreations printString ].</body><body package="COTransactions">checkNumberOfFrameRemoves: numberOfFrameRemoves	numberOfFrameRemoves &gt; self class maxAllowedWriteSize		ifTrue: [ CoastError raiseSignal: 'Number of frame removals exceeds limit: ', numberOfFrameRemoves printString ].</body><body package="COTransactions">checkNumberOfSlotCreations: numberOfSlotCreations	numberOfSlotCreations &gt; self class maxAllowedWriteSize		ifTrue: [ CoastError raiseSignal: 'Number of slot creations exceeds limit: ', numberOfSlotCreations printString ].</body><body package="COTransactions">checkNumberOfSlotReadAccesses: numberOfSlotReadAccesses	numberOfSlotReadAccesses &gt; self class maxAllowedReadSize		ifTrue: [ CoastError raiseSignal: 'Number of slot read accesses exceeds limit: ', numberOfSlotReadAccesses printString ].</body><body package="COTransactions">checkNumberOfSlotRemoves: numberOfSlotRemoveAccesses	numberOfSlotRemoveAccesses &gt; self class maxAllowedWriteSize		ifTrue: [ CoastError raiseSignal: 'Number of slot remove accesses exceeds limit: ', numberOfSlotRemoveAccesses  printString ].</body><body package="COTransactions">checkNumberOfSlotWriteAccesses: numberOfSlotWriteAccesses	numberOfSlotWriteAccesses &gt; self class maxAllowedWriteSize		ifTrue: [ CoastError raiseSignal: 'Number of slot write accesses exceeds limit: ', numberOfSlotWriteAccesses  printString ].</body><body package="COTransactions">passesSanityCheckForCC: aCatRMMediatorCC 	| cl |	cl := aCatRMMediatorCC cluster.	( cluster ~~ nil and: [ cl ~~ nil and: [ cl ~~ cluster ]]) ifTrue: 		[	CoastLog logError: 'Sanity check: Agenda does not match with CC ' , self printString , '/' , cl printString.			^ false		].	( cl isNil or: [ cl valueHolder isNil ]) ifTrue: 		[	CoastLog logError: 'Sanity check: missing cluster ' , cl printString.			^ false		].	^ AgendaChecker isValidAgenda: self cluster: cl</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>printing</category><body package="COTransactions">printClientDescriptionOn: aStream	"i do not have a client description"</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>initialize</category><body package="COTransactions">initialize	frameCreations := OrderedCollection new.	frameRemoves := Set new.	slotCreations := OrderedCollection new.	slotRemoves := OrderedCollection new.	slotWriteAccesses := OrderedCollection new.	slotReadAccesses := OrderedCollection new.	unpreparedReadAccesses := Set new.	isPrepared := false.</body></methods><methods><class-id>COAST.CatRMSimpleAgenda</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: stream marshaller: aCatRMMarshall 	aCatRMMarshall clusterManager isNil ifTrue: [ aCatRMMarshall clusterManager: cluster clusterManager ].	self checkAgendaSize.	clusterLocator marshallBinaryTo: stream marshaller: aCatRMMarshall.	stream nextOptimized32Put: frameCreations size.	frameCreations do: [: fc | fc marshallBinaryTo: stream marshaller: aCatRMMarshall ].	stream nextOptimized32Put: frameRemoves size.	frameRemoves do: [: fr | fr marshallBinaryTo: stream marshaller: aCatRMMarshall ].	stream nextOptimized32Put: slotCreations size.	slotCreations do: [: sc | sc marshallBinaryTo: stream marshaller: aCatRMMarshall ].	stream nextOptimized32Put: slotRemoves size.	slotRemoves do: [: sr | sr marshallBinaryTo: stream marshaller: aCatRMMarshall ].	stream nextOptimized32Put: slotWriteAccesses size.	slotWriteAccesses do: [: swa | swa marshallBinaryTo: stream marshaller: aCatRMMarshall ].	stream nextOptimized32Put: slotReadAccesses size.	slotReadAccesses do: [: sra | sra marshallBinaryTo: stream marshaller: aCatRMMarshall ].</body><body package="COTransactions">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	| numberOfFrameRemoves numberOfFrameCreations numbeOfSlotCreations numberOfSlotWriteAccesses numberOfSlotReadAccesses numbeOfSlotRemoves |	clusterLocator := CatCSClusterLocator unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall.	CoastLog logDebug: [ 'Unmarshalling agenda for cluster: ' , clusterLocator id printString ].	numberOfFrameCreations := aStream nextOptimized32 .	self checkNumberOfFrameCreations: numberOfFrameCreations.	frameCreations := ( 1 to: numberOfFrameCreations ) collect: [: i | CatRMFrameCreation unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ].	numberOfFrameRemoves := ( aCatRMMarshall loadCoastVersion isMin: 5 minor: 2 ) 			ifTrue: [ aStream nextOptimized32 ]			ifFalse: [ 0	"old style - agenda had no frame removes" ].	self checkNumberOfFrameRemoves: numberOfFrameRemoves.	frameRemoves := ( 1 to: numberOfFrameRemoves ) collect: [: i | CatRMFrameRemove unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ].	numbeOfSlotCreations := aStream nextOptimized32 .	self checkNumberOfSlotCreations: numbeOfSlotCreations.	slotCreations := ( 1 to: numbeOfSlotCreations) collect: [: i | CatRMSlotCreation unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ].	numbeOfSlotRemoves := aStream nextOptimized32 .	self checkNumberOfSlotRemoves: numbeOfSlotRemoves.	slotRemoves := ( 1 to: numbeOfSlotRemoves) collect: [: i | CatRMSlotRemove unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ].	numberOfSlotWriteAccesses := aStream nextOptimized32 .	self checkNumberOfSlotWriteAccesses: numberOfSlotWriteAccesses.	slotWriteAccesses := ( 1 to: numberOfSlotWriteAccesses) collect: [: i | CatRMSlotAccess unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ].	numberOfSlotReadAccesses := aStream nextOptimized32 .	self checkNumberOfSlotReadAccesses: numberOfSlotReadAccesses.	slotReadAccesses := ( 1 to: numberOfSlotReadAccesses ) collect: [: i | CatRMSlotAccess unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ].</body></methods><methods><class-id>COAST.CatRMSimpleAgenda class</class-id> <category>instance creation</category><body package="COTransactions">cluster: aCluster 	^ ( self new )		cluster: aCluster;		yourself</body><body package="COTransactions">new	^super new initialize</body></methods><methods><class-id>COAST.CatRMSimpleAgenda class</class-id> <category>limits</category><body package="COTransactions">maxAllowedReadSize	" limit the number of read accesses"	^ 1048576</body><body package="COTransactions">maxAllowedWriteSize	" limit the number of creations/removals/write accesses "	^ 1048576</body></methods><methods><class-id>COAST.SegmentedFrameSet</class-id> <category>enumerating</category><body package="COFramesystem">collect: aBlock 	| newSet |	self isEmpty ifTrue: [ ^ self species new: 2 ].	newSet := self species new: self size * 3 // 2.	self do: [: element | newSet add: ( aBlock value: element )].	^ newSet</body><body package="COFramesystem">do: aBlock 	contents do: aBlock.	self overflowDo: [: more | more do: aBlock ].</body><body package="COFramesystem">includesFrameWithReference: frameOrReference 	| set |	set := self setForSegmentHash: frameOrReference coastFrameSetSegmentHash.	^ set notNil and: [ set includesFrameWithReference: frameOrReference ]</body></methods><methods><class-id>COAST.SegmentedFrameSet</class-id> <category>binary storage</category><body package="COFramesystem">readGeneralStructureOn: aBinaryStorageReader	self shouldNotImplement.</body><body package="COFramesystem">setTally	"does not apply"</body></methods><methods><class-id>COAST.SegmentedFrameSet</class-id> <category>testing</category><body package="COFramesystem">coastIncludesCompactKey: compactKey 	^ compactKey isFrameOrFrameReference and: [ self includesFrameWithReference: compactKey ]</body><body package="COFramesystem">includes: anObject 	| set |	set := self setForSegmentHash: anObject coastFrameSetSegmentHash.	^ set notNil and: [ set includes: anObject ]</body></methods><methods><class-id>COAST.SegmentedFrameSet</class-id> <category>accessing</category><body package="COFramesystem">coastAsSetOrYourself	^ self</body><body package="COFramesystem">coastValueFor: valueHolder 	| myValueHolderClass adaptedValueHolder |	valueHolder valueClass = Set 		ifTrue: [ ^ self copy ].	myValueHolderClass := COAST.CatCSSet.	adaptedValueHolder := myValueHolderClass new			value: self;			adaptedCoastValueHolderToClass: valueHolder.	^ adaptedValueHolder value = self 		ifTrue: 		[	COAST.CoastError raiseBadValueClass.			self		]		ifFalse: [ adaptedValueHolder value coastValueFor: valueHolder ]</body><body package="COFramesystem">findElementLike: frame ifAbsent: aBlock 	"frames are equal &lt;==&gt; they are identiccaly"	^ ( self includes: frame ) 		ifTrue: [ frame ]		ifFalse: [ aBlock value ]</body><body package="COFramesystem">frameOrNilWithClusterID: clusterID frameID: frameID 	| set |	set := self setForSegmentHash: clusterID.	^ set notNil 		ifTrue: [ set frameOrNilWithClusterID: clusterID frameID: frameID ]		ifFalse: [ nil ]</body><body package="COFramesystem">removeFrameWithClusterID: clusterID frameID: frameID 	| set |	set := self setForSegmentHash: clusterID.	^ set notNil 		ifTrue: [ set removeFrameWithClusterID: clusterID frameID: frameID ]		ifFalse: [ nil ]</body><body package="COFramesystem">size	| size |	size := contents size.	self overflowDo: [: more | size := size + more size ].	^ size</body><body package="COFramesystem">swap: oneIndex with: anotherIndex 	self shouldNotImplement.</body></methods><methods><class-id>COAST.SegmentedFrameSet</class-id> <category>private</category><body package="COFramesystem">atNewIndex: index put: anObject 	self shouldNotImplement.</body><body package="COFramesystem">bitsPerLevel	^ 12</body><body package="COFramesystem">compressWhile: whileBlock 	"Ziel: leere Teile wegwerfen, kleine Teile wieder zusammenfassen (ohne overflow)"	"RÃ¼ckgabewert: meine GrÃ¶Ãe (zum optimierten Zusammenrechnen) oder nil, falls whileBlock nicht mehr true liefert (d.h. Abbruch)"	| size |	overflow isNil ifTrue: [ ^ contents size ].	( size := contents compressWhile: whileBlock ) isNil ifTrue: [ ^ nil	"pass cancle marker" ].	overflow keysAndValuesDo: 		[: i : more | | moreSize |			more notNil ifTrue: 				[	( moreSize := more compressWhile: whileBlock ) isNil ifTrue: [ ^ nil	"pass cancle marker" ].					moreSize = 0 						ifTrue: 						[	overflow at: i put: nil.							"paranoia: falls irgendwer parallel was eingefÃ¼llt hat - zurÃ¼ckeintragen"							more do: [: shouldNotExisit | self add: shouldNotExisit ]						]						ifFalse: [ size := size + moreSize ]				]		].	whileBlock value ifFalse: [ ^ nil	"cancle" ].	size * 2 &lt; self splitSize ifTrue: [ self purgeOverflow ].	^ size</body><body package="COFramesystem">find: anObject ifAbsent: aBlock 	self shouldNotImplement</body><body package="COFramesystem">findElementOrNil: anObject 	self shouldNotImplement.</body><body package="COFramesystem">fixCollisionsFrom: index 	self shouldNotImplement.</body><body package="COFramesystem">forDepth: depth 	keyIndex := depth.	contents := self setClass new: self splitSize.</body><body package="COFramesystem">forceSplit	| filling |	filling := contents.	overflow := Array new: self splitSize.	contents := self class forDepth: keyIndex + 1.	filling fastDo: [: frame | self setForSegmentHash: frame coastFrameSetSegmentHash withSegmentDo: [: set : segment | set add: frame ]].</body><body package="COFramesystem">keyBitShift	keyBitShift == nil 		ifTrue: [ keyBitShift := ( keyIndex - 1 ) * self bitsPerLevel negated ].	^ keyBitShift</body><body package="COFramesystem">keyFrom: clusterID 	" passend zu splitSize "	| key |	key := 1 == keyIndex 			ifTrue: [ clusterID ]			ifFalse: [ clusterID bitShift: self keyBitShift ].	^ key bitAnd: self splitSize</body><body package="COFramesystem">maxKeyIndex	" durch 32 Bit Cluster-ID beschrÃ¤nkt "	^ 32 // self bitsPerLevel</body><body package="COFramesystem">noCheckAdd: frame 	^ self setForSegmentHash: frame coastFrameSetSegmentHash		withSegmentDo: 		[: set : segment | | result |			result := set noCheckAdd: frame.			segment splitIfNeeded.			result		]</body><body package="COFramesystem">overflowDo: block 	overflow notNil ifTrue: [ overflow do: [: more | more notNil ifTrue: [ block value: more ]]].</body><body package="COFramesystem">purgeOverflow	| oldOverflow oldContents |	CoastLog logDebug: [ 'compressing a  ' , self class name, ' of size ', self size printString  ] channel: #coast.	oldContents := contents.	oldOverflow := overflow.	[ contents := self setClass new: self splitSize ] ensure: 		[	overflow := nil.			oldContents do: [: frame | self add: frame ].			oldOverflow do: [: more | more notNil ifTrue: [ more do: [: frame | self add: frame ]]]		].</body><body package="COFramesystem">rehash	"does not apply"</body><body package="COFramesystem">setClass	^ FrameSet</body><body package="COFramesystem">setForSegmentHash: clusterID 	^ self setForSegmentHash: clusterID withSegmentDo: nil</body><body package="COFramesystem">setForSegmentHash: clusterID withSegmentDo: block 	| key more |	nil == overflow ifTrue: 		[	^ nil == block 				ifTrue: [ contents ]				ifFalse: [ block value: contents value: self ]		].	key := self keyFrom: clusterID.	0 == key ifTrue: [ ^ contents setForSegmentHash: clusterID withSegmentDo: block ].	more := overflow at: key.	more isNil ifTrue: 		[	block isNil 				ifTrue: [ ^ nil ]				ifFalse: 				[	more := overflow at: key put: ( self class forDepth: keyIndex + 1 ).				]		].	^ more setForSegmentHash: clusterID withSegmentDo: block</body><body package="COFramesystem">species	^ Set</body><body package="COFramesystem">splitIfNeeded	( nil ~~ overflow or: [ contents size &lt; self splitSize ]) 		ifTrue: [ ^ self ].	keyIndex &gt;= self maxKeyIndex 		ifTrue: [ ^ self ].	self forceSplit.</body><body package="COFramesystem">splitSize	splitSize == nil 		ifTrue: [ splitSize := 2 raisedTo: self bitsPerLevel ].	^ splitSize</body><body package="COFramesystem">trim	contents trim.	self overflowDo: [: more | more trim ]</body></methods><methods><class-id>COAST.SegmentedFrameSet</class-id> <category>adding</category><body package="COFramesystem">add: frame 	self addAndReturnOldOrNil: frame.	^ frame</body><body package="COFramesystem">addAndReturnOldOrNil: frame 	^ self setForSegmentHash: frame coastFrameSetSegmentHash		withSegmentDo: 		[: set : segment | | result |			result := set addAndReturnOldOrNil: frame.			segment splitIfNeeded.			result		]</body></methods><methods><class-id>COAST.SegmentedFrameSet</class-id> <category>copying</category><body package="COFramesystem">postCopy	super postCopy.	contents := contents copy.	overflow notNil ifTrue: [ overflow := overflow collect: [: more | more copy ]].</body></methods><methods><class-id>COAST.SegmentedFrameSet</class-id> <category>removing</category><body package="COFramesystem">remove: frame ifAbsent: anExceptionBlock 	| set |	set := self setForSegmentHash: frame coastFrameSetSegmentHash.	^ set notNil 		ifTrue: [ set remove: frame ifAbsent: anExceptionBlock ]		ifFalse: [ anExceptionBlock value ]</body></methods><methods><class-id>COAST.SegmentedFrameSet class</class-id> <category>instance creation</category><body package="COFramesystem">forDepth: depth 	^ self basicNew		forDepth: depth;		yourself</body><body package="COFramesystem">new	^ self forDepth: 1</body><body package="COFramesystem">new: targetSize 	| inst |	inst := self new.	inst splitSize &lt;= targetSize ifTrue: [ inst forceSplit ].	^ inst</body></methods><methods><class-id>COAST.CatRMLoggedTransaction</class-id> <category>accessing</category><body package="COTransactions">transaction	^transaction</body><body package="COTransactions">transaction: aCatCSTransaction	transaction := aCatCSTransaction</body><body package="COTransactions">transactionID	^transactionID</body><body package="COTransactions">transactionID: aCatRMTransactionID	transactionID := aCatRMTransactionID</body></methods><methods><class-id>COAST.AbstractObserver</class-id> <category>accessing</category><body package="COFramesystem">addObserver: observerOrWrapper 	self observer == observerOrWrapper 		ifTrue: [ self coastSubject addObserver: self ]		ifFalse: 		[	CoastLog 				logWarning: 'Observer mismatch: Expected observer ' , self observer printString , ', got ' , observerOrWrapper printString		]</body><body package="COFramesystem">coastInvalidateDisresolved	self coastObserver coastInvalidateDisresolved</body><body package="COFramesystem">coastInvalidateWithAccess: cellAccessOrNil	self coastObserver coastInvalidateWithAccess: cellAccessOrNil.	^ false</body><body package="COFramesystem">coastObserver	^ self observer</body><body package="COFramesystem">coastRemoveSubject: observedObject	self observer coastRemoveObserverPair: self</body><body package="COFramesystem">coastSubject	^ subject</body><body package="COFramesystem">observer	^ self value</body><body package="COFramesystem">observer: anObject	value := anObject.</body><body package="COTransactions">referencedClusterIDsSkip: skipFrames	^ #()</body><body package="COFramesystem">subject	^ subject</body><body package="COFramesystem">subject: anObject	subject := anObject</body><body package="COFramesystem">value: anObject 	value := anObject.</body></methods><methods><class-id>COAST.AbstractObserver</class-id> <category>testing</category><body package="COFramesystem">isWeakObserver	| obs |	^ (obs := self observer) notNil and: [ obs isWeakObserver ]</body></methods><methods><class-id>COAST.AbstractObserver</class-id> <category>observer - subject</category><body package="COFramesystem">allObservedClusterIDs	^ subject allObservedClusterIDs</body><body package="COFramesystem">removeObserver: anObserver	subject removeObserver: self</body></methods><methods><class-id>COAST.AbstractObserver</class-id> <category>comparing</category><body package="COFramesystem">= anotherPair	^ self class = anotherPair class 		and: [ self subject == anotherPair subject 		and: [ self observer == anotherPair observer	]]</body><body package="COFramesystem">hash	^ self observer hash</body></methods><methods><class-id>COAST.CatCSApplicationLog</class-id> <category>accessing</category><body package="COTransactions">addLogEntry: logEntry	logEntries add: logEntry.	"debug purposes"	"LogEntries := OrderedCollection new."	LogEntries notNil ifTrue: [ LogEntries add: logEntry ].</body><body package="COTransactions">currentEntryAddKey: aKey value: aValue	currentEntry notNil 		ifTrue: [ currentEntry addKey: aKey value: aValue ]		ifFalse: [ CoastLog logWarning: 'No current application log entry set' ].</body><body package="COTransactions">finishEntry	currentEntry notNil 		ifTrue: [			self addLogEntry: currentEntry.			currentEntry := nil.		]		ifFalse: [ 			CoastLog logWarning: 'No current application log entry set'		].</body><body package="COTransactions">isEmpty	^ self logEntries isEmpty</body><body package="COTransactions">logEntries	^ logEntries</body><body package="COTransactions">startEntry	currentEntry isNil 		ifTrue: [ currentEntry := CoastApplicationLogEntry new ]		ifFalse: [ CoastLog logWarning: 'Current application log entry already set' ].</body></methods><methods><class-id>COAST.CatCSApplicationLog</class-id> <category>initialize-release</category><body package="COTransactions">initialize 	logEntries := OrderedCollection new.</body></methods><methods><class-id>COAST.CatCSApplicationLog</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextUnsigned32Put: self logEntries size.	self logEntries do: [: entry | entry marshallBinaryTo: aStream marshaller: aCatRMMarshall ].</body><body package="COTransactions">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	| numEntries |	numEntries := aStream nextUnsigned32.	logEntries := Array new: numEntries.	1 to: numEntries		do: 		[: i | | entry |			entry := CoastApplicationLogEntry new.			entry unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall.			logEntries at: i put: entry		].</body></methods><methods><class-id>COAST.CatCSApplicationLog class</class-id> <category>instance creation</category><body package="COTransactions">new	^ super new initialize</body></methods><methods><class-id>COAST.CatCSApplicationLog class</class-id> <category>marshalling</category><body package="COTransactions">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	^ self new		unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall;		yourself</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>demon description 4</category><body package="COFramesystem">afterModificationDemon: methodSelector 	"The indicated method will be called after the slot was modified.	The method has to accept one parameter which is the access object."	| demon |	demon := (CatFSDemon writeOnly)				postJob: (self performMethodBlockFor: methodSelector);				name: methodSelector;				yourself.	self addDemon: demon</body><body package="COFramesystem">afterTransactionDemon: methodSelector 	| demon |	demon := (CatFSDemon writeOnly)				endTransactionJob: (self performMethodBlockFor: methodSelector);				name: methodSelector;				yourself.	self addDemon: demon</body><body package="COFramesystem">beforeModificationDemon: methodSelector 	"The indicated method will be called before the slot is modified.	The method has to accept one parameter which is the access object."	| demon |	demon := (CatFSDemon writeOnly)				preJob: (self performMethodBlockFor: methodSelector);				name: methodSelector;				yourself.	self addDemon: demon</body><body package="COFramesystem">differencesDemon: methodSelector	"The indicated method will be called after the slot has been modified.	The demon computes the differences between the old and new value	of the slot and passes these to the indicated  method which has to	accept two parameters:  first is the set of added values, second is the	set of removed values."	| newDemon |	newDemon := CatFSDemon writeOnly.	newDemon preJob: [:demon :cellAccess :cell | cellAccess keepDifferences].	newDemon postJob: 	[:demon :slotAccess :slot | | diff |		diff := slotAccess differences.		slot frame demonPerformer perform: methodSelector with: diff added with: diff removed.	].	newDemon name: methodSelector.	self addDemon: newDemon</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>demon description depricated</category><body package="COFramesystem">afterRead: aBlock named: aSymbol 	| demon |	demon := (CatFSDemon readOnly) 					postJob: aBlock; 					name: aSymbol; 					yourself.	self addDemon: demon</body><body package="COFramesystem">afterWrite: aBlock named: aSymbol "depricated! Use afterModificatuionDemon:#methodSelector instead"	| demon |	demon := (CatFSDemon writeOnly) 					postJob: aBlock; 					name: aSymbol; 					yourself.	self addDemon: demon</body><body package="COFramesystem">assert: assertBlock 	"Create an assert demon that checks all added frames "	| newDemon |	newDemon := ( CatFSDemon writeOnly )			preJob: [: demon : cellAccess : cell | cellAccess keepDifferences ];			postJob: 				[: demon : cellAccess : cell |					cellAccess differences added do: [: frame | ( assertBlock value: frame ) ifFalse: [ CoastError raiseSignal: 'Assertion failed' ]]				];			yourself.	newDemon name: #assert.	newDemon argument: assertBlock.	self addDemon: newDemon.</body><body package="COFramesystem">beforeRead: aBlock named: aSymbol 	| demon |	demon := (CatFSDemon readOnly) 					preJob: aBlock; 					name: aSymbol; 					yourself.	self addDemon: demon</body><body package="COFramesystem">beforeWrite: aBlock named: aSymbol 	| demon |	demon := (CatFSDemon writeOnly) 					preJob: aBlock; 					name: aSymbol; 					yourself.	self addDemon: demon</body><body package="COFramesystem">constituentCheckFor: cellAccess 	cellAccess differences removed isEmpty ifTrue: [ ^ nil ].	self isSingleValueSlot 		ifTrue: [ self valueHolder value isNil ifTrue: [ self frame isolate ]]		ifFalse: [ self valueHolder isEmpty ifTrue: [ self frame isolate ]].</body><body package="COFramesystem">crossVolume	"Allows the slot to contain frames from another volume.	Warning: A current implementation restriction forbids to contain a frame more than once	- so be careful with bags, dicts and ordered collections"	| demon |	demon := (CatFSDemon writeOnly) 					endTransactionJob: [ :theDemon :access :slot | slot frame checkOutgoingCrossVolumeRefsFor: access slot: slot ]; 					name: #crossVolumeDemon; 					yourself.	self addDemon: demon</body><body package="COFramesystem">invertsKeysTo: anotherSlotName valueComputationBlock: aValueComputationBlock 	"Create a inverting demon that ensures, that my frame is added as key to each of the frames, that 	serve as keys for me. The Parameter aValueComputationBlock will be fed with the Frame, which 	was added as a key to me and my frame. This demon only works on Dictionaries."	| newDemon |	(self valueHolder isKindOf: (self class typeDictionary at: #dictionary))		ifFalse: 			[self halt: 'This demon may only be attached to slots of type Dictionary!'.			^self].	newDemon := (CatFSDemon writeOnly) preJob: [:demon :cellAccess :cell | cellAccess keepDifferences]; postJob: [:demon :cellAccess :cell | cell invertingKeyJobForDemon: demon access: cellAccess]; yourself.	newDemon name: #invertingKeySlot.	newDemon argument: (Array with: anotherSlotName with: aValueComputationBlock).	self addDemon: newDemon</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>demon - private</category><body package="COFramesystem">changeDemon: aDemonName to: aCatFSDemon	self removeDemon: aDemonName.	self addDemon: aCatFSDemon.</body><body package="COFramesystem">demonViolation: aDemon	self demonViolation: aDemon description: ''</body><body package="COFramesystem">demonViolation: aDemon description: anErrorString	 | errStr |	errStr := 'Demon violation: ',			aDemon name,			' of slot ',			self name printString,			' in frame ',			self frame printString,			' (',			 anErrorString,			 ') Transaction aborted!'.	CoastLog logError: errStr.	self transactionManager statusError: errStr.	self transactionManager abortTransaction.</body><body package="COFramesystem">invertingJobForDemon: demon access: aCatCSCellAccess 	| frame slotname |	aCatCSCellAccess isInvertingAccess ifTrue: [ ^ self ].	slotname := demon argument.	frame := aCatCSCellAccess cellFrame.	aCatCSCellAccess transaction invertedFrameDo: [ frame invertTo: slotname access: aCatCSCellAccess demon: demon ]</body><body package="COFramesystem">invertingKeyJobForDemon: demon access: aCatCSCellAccess 	| slot frame slotname added removed targetValueBlock |	aCatCSCellAccess differences isNil ifTrue: [ self error: 'internal error: cannot invert dictionary' ].	slot := aCatCSCellAccess cell.	added := aCatCSCellAccess differences added collect: [ :a | a key ].	removed := aCatCSCellAccess differences removed collect: [ :a | a key ].	slotname := demon argument at: 1.	targetValueBlock := demon argument at: 2.	frame := slot frame.	added do: [:targetFrame | (targetFrame at: slotname includesKey: frame)			ifFalse: [targetFrame					at: slotname					atKey: frame					put: (targetValueBlock							value: targetFrame							value: frame)]].	removed do: [:targetFrame | (targetFrame at: slotname includesKey: frame)			ifTrue: [targetFrame at: slotname removeKey: frame]]</body><body package="COFramesystem">transactionContextAdded	| added |	added := self transactionManager activeTransaction transactionContextAt: #elementsAdded.	added isNil		ifTrue: [ added := Set new.			self transactionManager activeTransaction transactionContextAt: #elementsAdded put: added ].	^ added.</body><body package="COFramesystem">transactionContextMoved	| moved |	moved := self transactionManager activeTransaction transactionContextAt: #elementsMoved.	moved isNil		ifTrue: [ moved := Set new.			self transactionManager activeTransaction transactionContextAt: #elementsMoved put: moved ].	^ moved.</body><body package="COFramesystem">transactionContextRemoved	| removed |	removed := self transactionManager activeTransaction transactionContextAt: #elementsRemoved.	removed isNil		ifTrue: [ removed := Set new.			self transactionManager activeTransaction transactionContextAt: #elementsRemoved put: removed ].	^ removed.</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>inspecting</category><body package="COFramesystem">classLabel	^'Slot'</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>demon description</category><body package="COFramesystem">canOverwriteOnCopy	^ self clientData at: #canOverwriteOnCopy ifAbsent: [ true]</body><body package="COFramesystem">constituent	"Create a constituence demon "	self addDemon: CatFSConstituentDemon new.</body><body package="COFramesystem">copyOrder	" slots with lower numbers are copied first. "	^ self clientData at: #copyOrder ifAbsent: [ SmallInteger maxVal ]</body><body package="COFramesystem">copyOrder: anInteger	" slots with lower numbers are copied first. "	self clientData at: #copyOrder put: anInteger</body><body package="COFramesystem">defaultValue: aValue 	self isPrototype ifTrue: [self valueHolder value: aValue]</body><body package="COFramesystem">defaultValueAdd: aValue 	self isPrototype ifTrue: [ self valueHolder coastInternalAdd: aValue withAccess: nil ]</body><body package="COFramesystem">defaultValueAt: aKey put: aValue 	self isPrototype ifTrue: [ self valueHolder coastInternalAt: aKey put: aValue ]</body><body package="COFramesystem">doNotCopy	self doNotShallowCopy;		doNotDeepCopy</body><body package="COFramesystem">doNotDeepCopy	self clientData at: #testSlotDeepCopyBlock put: [ false ]</body><body package="COFramesystem">doNotOverwriteOnCopy	self clientData at: #canOverwriteOnCopy put: false.</body><body package="COFramesystem">doNotShallowCopy	self clientData at: #testSlotCopyShallowBlock put: [ false ].</body><body package="COFramesystem">invertsKeysTo: anotherSlotName targetValue: aValue 	"Create a inverting demon that ensures, that my frame is added as key to each of the frames, that 	serve as keys for me. The value for the new assoc is aValue. This demon only works on 	Dictionaries."	^self invertsKeysTo: anotherSlotName valueComputationBlock: [:newFrame :myFrame | aValue]</body><body package="COFramesystem">invertsTo: anotherSlotName 	"Create a inverting demon "	^ self invertsTo: anotherSlotName keyBlock: nil</body><body package="COFramesystem">invertsTo: anotherSlotName keyBlock: keyBlock 	"Create a inverting demon "	| newDemon |	newDemon := ( CatFSInvertingDemon writeOnly )			preJob: [: demon : cellAccess : cell | cellAccess keepDifferences ];			postJob: [: demon : cellAccess : cell | cell invertingJobForDemon: demon access: cellAccess ];			yourself.	newDemon argument: anotherSlotName.	keyBlock notNil ifTrue: [ newDemon keyBlock: keyBlock ].	self addDemon: newDemon</body><body package="COFramesystem">keyRange: aClassOrArray 	"Create a range check demon which checks if all slot values are instances of &lt;aClass&gt;. This demon only works on Dictionary slots."	| newDemon |	(self valueHolder canCheckKeyRange) ifFalse: 		[	self halt: 'A key range demon cannot be added to a slot with value type #', self valueHolder class slotSymbol.			^ self 		].	newDemon := CatFSDemon writeOnly.	newDemon preJob: [: demon : cellAccess : cell | cellAccess keepDifferences ].	newDemon postJob: 		[: demon : slotAccess : slot |			slotAccess differences added isEmpty ifFalse: 				[	"this check is necessary!"					slotAccess differences added keysDo: 						[: newValue |							(aClassOrArray isCoastRangeFor: newValue) ifFalse: 								[	slot demonViolation: demon										description: newValue printString , ' was expected to be of kind ' , aClassOrArray printString 								] 						] 				] 		].	newDemon name: #keyRange.	self addDemon: newDemon</body><body package="COFramesystem">maxCardinality: aNumber 	"The slot has to have at most aNumber elements"	| newDemon |	newDemon := (CatFSDemon writeOnly				endTransactionJob: 					[:demon :slotAccess :slot | 					| v |					v := slot accessCellValue.					(slot isSingleValueSlot)						ifFalse: [v size &gt; aNumber ifTrue: [slot demonViolation: demon description: v size printString, ' (', aNumber printString, ')']]])				name: #maxCardinality;				argument: aNumber; yourself.	self addDemon: newDemon</body><body package="COFramesystem">minCardinality: aNumber	"The slot has to have at least aNumber elements "	| newDemon |	newDemon := ((CatFSDemon writeOnly)			endTransactionJob: [:demon :slotAccess :slot | 					| v |					v := slot accessCellValue.					(slot isSingleValueSlot)						ifFalse: [v size &lt; aNumber ifTrue: [slot demonViolation: demon description: v size printString, ' (', aNumber printString, ')']]])		name: #minCardinality;		argument: aNumber;		yourself.	self addDemon: newDemon.</body><body package="COFramesystem">oneWayInvertsTo: anotherSlotName 	"Create a one-way inverting demon "	self clientData at: #oneWayInverted put: true.	self invertsTo: anotherSlotName.</body><body package="COFramesystem">primitiveCopyBlock	^self clientData at: #primitiveCopyBlock ifAbsent: nil</body><body package="COFramesystem">range: aClassOrArray 	"Create a range check demon which checks if all slot values are instances of &lt;aClass&gt;"	| newDemon |	self class enableRangeDemon ifFalse: [ ^ self ].	newDemon := CatFSDemon writeOnly.	newDemon preJob: [: demon : cellAccess : cell | cellAccess keepDifferences ].	newDemon postJob: 		[: demon : slotAccess : slot |			| added |			added := slotAccess differences addedOrNil.			added notNil				ifTrue: [					added do: 						[: newValue |							(aClassOrArray isCoastRangeFor: newValue) ifFalse: 								[	slot demonViolation: demon										description: newValue printString , ' was expected to be of kind ' , aClassOrArray printString 								] 						] 				].		].	newDemon name: #range.	newDemon argument: aClassOrArray.	self addDemon: newDemon</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>testing</category><body package="COFramesystem">allowsSlotModification	^ valueHolder allowsSlotModification</body><body package="COFramesystem">depleteSlotBeforeIsolate	^ self definition depleteSlotBeforeIsolate</body><body package="COFramesystem">isLocal	"this depends on my frame"	| f |	^(f := self frame) notNil 		ifTrue: [f isLocal]		ifFalse: 			[self isPrototype 				ifFalse: [self error: 'Cannot decide if slot is local or shared'].			true]</body><body package="COFramesystem">isSingleValueSlot	^self valueHolder isSingleValue</body><body package="COFramesystem">referencesSharedFrame: rFrame 	^ self valueHolder referencesSharedFrame: rFrame</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>accessing</category><body package="COFramesystem">access: aCatCSCellAccess 	"if one of my observer has a revalidation block the differences are needed"	observers hasObserversWithRevalidationBlock ifTrue: [ aCatCSCellAccess keepDifferences ].	^ super access: aCatCSCellAccess</body><body package="COFramesystem">clusterManager	"the cluster manager can be reached via the frame"	^ container notNil 		ifTrue: [ container clusterManager ]		ifFalse: [ nil ]</body><body package="COFramesystem">hash	^ self frame hash bitXor: self definition hash</body><body package="COFramesystem">id: newID 	| slotProto |	self definition notNil 		ifTrue: 		[	" prototype "			self definition slotName: newID		]		ifFalse: 		[	" unmarshalled slot "			slotProto := self frame class prototypeNeeded protoSlotNamed: newID complain: false.			slotProto isNil ifTrue: 				[	slotProto := self class unknownSlotPrototype: newID valueHolderClass: CatCSSingleValue.					self frame isUniversalFrame ifFalse: [ self frame class prototype slot: newID with: slotProto ]				].			self definition: slotProto definition		].	self slotName isNil ifTrue: [ self haltOrError ].</body><body package="COFramesystem">initializeForArgumentsBlock: argumentsBlock inVolume: volume 	^ self valueHolder initializeForArgumentsBlock: argumentsBlock inVolume: volume</body><body package="COFramesystem">minimizedInvalidation	self definition notNil 		ifTrue: 		[				self definition minimizeInvalidation: true		]</body><body package="COFramesystem">readAccess	^ self access: (CatCSValueReadAccess cell: self)</body><body package="COTransactions">referencedClusterIDsSkip: skipFrames 	^ container referencedClusterIDsSkip: skipFrames</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>prototype description</category><body package="COFramesystem">allowRPCs 	^definition allowRPCs</body><body package="COFramesystem">allowRPCs: boolean 	definition allowRPCs: boolean</body><body package="COFramesystem">definition	" definition of the slot "	^ definition</body><body package="COFramesystem">forceRPC	^ definition forceRPC</body><body package="COFramesystem">forceRPC: boolean 	definition forceRPC: boolean.</body><body package="COFramesystem">testSlotCopyShallowBlock	^self clientData at: #testSlotCopyShallowBlock ifAbsent: nil</body><body package="COFramesystem">testSlotDeepCopyBlock	^self clientData at: #testSlotDeepCopyBlock ifAbsent: nil</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>observer - subject</category><body package="COFramesystem">addObserver: newObserver 	newObserver isWeakObserver ifFalse: [ self propagateNonWeakObserver ].	^super addObserver: newObserver</body><body package="COFramesystem">addObserver: newObserver access: cellAccess 	| obsPair |	self definition minimizeInvalidation ifFalse: [ ^ super addObserver: newObserver access: cellAccess ].	observers notNil ifTrue: 		[	obsPair := observers 					detect: [: anObsPair | anObsPair coastObserver = newObserver ]					ifNone: [ nil ]		].	obsPair isNil ifTrue: 		[	obsPair := AccessObserverPair observer: newObserver subject: self.			self addObserver: obsPair.			newObserver addObserverPair: obsPair		].	obsPair addAccess: cellAccess</body><body package="COFramesystem">minimalInvalidateObserversWithAccess: aCatCSCellAccess	| oldObservers |	self definition minimizeInvalidation		ifFalse: [ ^ super minimalInvalidateObserversWithAccess: aCatCSCellAccess ].	observers notNil ifTrue: 		[	oldObservers := self observers.			observers := nil.			oldObservers do: [: o | 				(o coastInvalidateWithAccess: aCatCSCellAccess)					ifTrue: [ self addObserver: o ].			]		]</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>private</category><body package="COFramesystem">clientData	" dictionary to store additional information about the slot "	^ self definition clientData</body><body package="COFramesystem">valueHolder: aCatCSValueHolder	aCatCSValueHolder notNil		ifTrue: [ aCatCSValueHolder slot: self ].	super valueHolder: aCatCSValueHolder.</body><body package="COFramesystem"> withoutRPCsDo: block	self allowRPCs ifFalse: [ ^ block value ].	self allowRPCs: false.	^ block ensure: [ self allowRPCs: true ]</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>initialize-new</category><body package="COFramesystem">initializeSpawned	super initializeSpawned.	self valueHolder initializeSpawned.</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>private utility</category><body package="COFramesystem">performMethodBlockFor: methodSelector 	^ [: theDemon : access : slot |				[ slot frame demonPerformer perform: methodSelector with: access ] on: Error			do: 			[: ex |				access transaction addEndBlock: [ access transaction transactionManager class abortTransactionSignal raise ].				ex pass			]	]</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>accessing - private</category><body package="COFramesystem">allowsNilValueAtKey	"only dictionary may have nil values, but none of the subclasses!"	^ self basicValueHolder class == CatCSDictionary</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>comparing</category><body package="COFramesystem">= cell 	^ self == cell or: [ cell class == self class and: [ self frame == cell frame and: [ self definition == cell definition ]]]</body></methods><methods><class-id>COAST.CatFSSlot</class-id> <category>marshalling</category><body package="COMarshalling">ensureUpdatedFrameSlotIndexWith: aCatRMMarshall frame: frame	aCatRMMarshall slotIndexFor: self id frame: frame.	self valueHolder ensureUpdatedFrameSlotIndexWith: aCatRMMarshall.</body><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self valueHolder index.	self valueHolder marshallValueHolderBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">unmarshallSlotBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector 	| newValueHolder |	newValueHolder := ( CatCSCellValueHolder valueHolderClassWithID: aStream next ) newWithoutValue.	( self definition forceRPC and: [ self clusterManager isLocalClient not ]) ifTrue: [ newValueHolder changeToDelegatingProxy ].	newValueHolder unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall morph: morphSelector.	self prototype definition isUnknown 		ifTrue: 		[	self prototype valueHolder: newValueHolder class new.			self prototype definition definedBy: self		]		ifFalse: 		[	self cluster clusterManager responsibleForVolume 				ifFalse: [ newValueHolder := newValueHolder selfOrAdaptedCoastValueHolderToClass: self prototype valueHolder class ]		].	self valueHolder: newValueHolder.</body></methods><methods><class-id>COAST.CatFSSlot class</class-id> <category>demon creation</category><body package="COFramesystem">endWriteTransaction: aJob 	^((CatFSDemon writeOnly) 			endTransactionJob: [:demon :slotAccess| aJob value: slotAccess frame])		name: #afterWriteTransactionDemon; yourself</body></methods><methods><class-id>COAST.CatFSSlot class</class-id> <category>prototype creation</category><body package="COFramesystem">buildTypeDictionary	"self buildTypeDictionary"	typeDictionary := Dictionary new.	CatCSCellValueHolder withAllSubclasses do:  		[: class | class slotSymbol ifNotNil: [ : symbol | typeDictionary at: symbol put: class ].		]."	typeDictionary := Dictionary new.	typeDictionary		at: #singleValue put: CatCSSingleValue;		at: #orderedCollection put: CatCSOrderedCollection;		at: #set put: CatCSSet;		at: #compactSet put: CatCSCompactSet;		at: #setProxy put: CatCSProxySet;		at: #bag put: CatCSBag;		at: #compactBag put: CatCSCompactBag;		at: #bagProxy put: CatCSProxyBag;		at: #dictionary put: CatCSDictionary;		at: #proxyDictionary put: CatCSProxyDictionary;		at: #compactKeyDictionary put: CatCSCompactKeyDictionary;		at: #compactDictionary put: CatCSCompactDictionary;		at: #indexProxy put: CatCSProxyIndex;		at: #compactIndex put: CatCSCompactIndex;		at: #compactValueIndex put: CatCSCompactValueIndex;		at: #compactKeyIndex put: CatCSCompactKeyIndex;		at: #multiValueDictionary put: CatCSMultiValueDictionary;		yourself."	"CatCSCompactRPCResultCollection is not yet ready to be used as a vh type"</body><body package="COFramesystem">newPrototypeOfType: aSlotType	^self newPrototype valueHolder: (self typeDictionary at: aSlotType) newPrototype</body><body package="COFramesystem">typeDictionary	typeDictionary isNil ifTrue: [ self buildTypeDictionary ].	^ typeDictionary</body></methods><methods><class-id>COAST.CatFSSlot class</class-id> <category>prototype access</category><body package="COFramesystem">unknownSlotPrototype: slotName valueHolderClass: valueHolderClass 	| unknownPrototype |	unknownPrototype := self newPrototype.	unknownPrototype valueHolder: valueHolderClass new.	unknownPrototype id: slotName.	unknownPrototype definition definedBy: #unknown.	^ unknownPrototype</body></methods><methods><class-id>COAST.CatFSSlot class</class-id> <category>accessing</category><body package="COFramesystem">enableRangeDemon	^ EnableRangeDemon ifNil: [ EnableRangeDemon := Notifier isDevelopment ]</body><body package="COFramesystem">enableRangeDemon: aBoolean	EnableRangeDemon := aBoolean</body></methods><methods><class-id>COAST.CopyContext</class-id> <category>testing</category><body package="COFramesystem">deepCopyAllowedOnSlot: slot 	"was ist an der Slotdefinition angebracht?"	^ slot testSlotDeepCopyBlock ifNil: [ true ] ifNotNil: [: testSlotDeepCopyBlock | testSlotDeepCopyBlock cull: slot ]</body><body package="COFramesystem">shallowCopyAllowedOnSlot: slot 	^slot testSlotCopyShallowBlock ifNil: [ true ] ifNotNil: [ : testSlotCopyBlock | testSlotCopyBlock cull: slot ]</body><body package="COFramesystem">shouldCopySlot: slot 	^ ( self shallowCopyAllowedOnSlot: slot ) or: [ self deepCopyAllowedOnSlot: slot ]</body><body package="COFramesystem">shouldDeepCopyFrame: frame 	"wurde fÃ¼r diesen Frame eine Deep copy gewÃ¼nscht?"	^ deepCopyQueryBlock ifNotNil: [: block | block cull: frame ] ifNil: [ false ]</body></methods><methods><class-id>COAST.CopyContext</class-id> <category>accessing</category><body package="COFramesystem">deepCopiedCellsAt: aCell ifAbsent: absentBlock 	^ deepCopiedCells at: aCell ifAbsent: absentBlock</body><body package="COFramesystem">volume	^ volume</body><body package="COFramesystem">volume: aVolume 	volume := aVolume.</body></methods><methods><class-id>COAST.CopyContext</class-id> <category>copying</category><body package="COFramesystem">copyOf: aFrame deepCopyFinishBlock: finishBlock 	| copy currentlyCopiedSlot |	( deepCopiedCells at: aFrame ifAbsent: nil ) ifNotNil: [: cpy | ^ cpy ].	volume isNil ifTrue: [ self volume: aFrame volume ].	currentlyCopiedSlot := copyStack isNil 			ifTrue: [ nil ]			ifFalse: [ copyStack last ].	^ ( self shouldDeepCopyFrame: aFrame inSlot: currentlyCopiedSlot ) 		ifTrue: 		[	copy := self spawnBlock value: aFrame.			( deepCopiedCells includesKey: aFrame ) ifTrue: [ CoastError raiseSignal: 'copy error' ].			deepCopiedCells at: aFrame put: copy.			copy isLocal ifTrue: [ copy initializeVirtualSlots ].			finishBlock value: copy.			copy		]		ifFalse: [ aFrame ]</body><body package="COFramesystem">copyOfPrimitive: aPrimitive 	| currentlyCopiedSlot |	currentlyCopiedSlot := copyStack isNil 			ifTrue: [ nil ]			ifFalse: [ copyStack last ].	currentlyCopiedSlot isNil ifTrue: [ ^ aPrimitive copy ].	currentlyCopiedSlot primitiveCopyBlock isNil ifTrue: [ ^ aPrimitive copy ].	^ currentlyCopiedSlot primitiveCopyBlock cull: aPrimitive cull: currentlyCopiedSlot cull: self</body><body package="COFramesystem">copySlot: slot frame: frame with: copyBlock 	copyStack isNil ifTrue: [ copyStack := OrderedCollection new ].	copyStack addLast: slot.	copyBlock ensure: 		[			copyStack removeLast = slot ifFalse: [ CoastError raiseSignal: 'copy stack mismatch' ]		].</body><body package="COFramesystem">shouldDeepCopyFrame: aFrame inSlot: currentlyCopiedSlot 	currentlyCopiedSlot isNil ifTrue: [ ^ true	"dieser Frame muss offensichtlich der erste sein" ].	^ ( self shouldDeepCopyFrame: aFrame ) 		ifTrue: 		[( self deepCopyAllowedOnSlot: currentlyCopiedSlot ) 				ifTrue: [ true ]				ifFalse: 				[	self copyRestrictionViolated: 'deep copy requested but not allowed' mayResume: ( self shallowCopyAllowedOnSlot: currentlyCopiedSlot ).					false				]		]		ifFalse: 		[( self shallowCopyAllowedOnSlot: currentlyCopiedSlot ) 				ifTrue: [ false ]				ifFalse: 				[	self copyRestrictionViolated: 'shallow copy requested but not allowed' mayResume: ( self deepCopyAllowedOnSlot: currentlyCopiedSlot ).					true				]		]</body></methods><methods><class-id>COAST.CopyContext</class-id> <category>private</category><body package="COFramesystem">copyRestrictionViolated: string mayResume: resume 	resume 		ifTrue: 		[	Notifier isDevelopment ifTrue: [ self haltOrContinue: string ].			CoastLog logWarning: string		]		ifFalse: [ self error: string ].</body><body package="COFramesystem">firstSpawnedFrame: firstSpawnedFrame	spawnBlock := nil.	self colocationFrame: firstSpawnedFrame</body></methods><methods><class-id>COAST.CopyContext</class-id> <category>initialize-release</category><body package="COFramesystem">initialize	deepCopiedCells := IdentityDictionary new.</body></methods><methods><class-id>COAST.CopyContext</class-id> <category>configure</category><body package="COFramesystem">colocationFrame: aColocationFrame 	aColocationFrame notNil ifTrue: 		[	self spawnBlock: [: originalFrame | originalFrame coastCreateBasicCopyColocatedTo: aColocationFrame context: self ].			aColocationFrame volume ifNotNil: [: vol | self volume: vol ]		].</body><body package="COFramesystem">deepCopyQueryBlock: aBlock 	"This Block answers true if the passed object should be copied deep (a real 	copy will be generated using the coastCopy method. If it answers false, the 	same reference to the object is used. 	aBlock is a block that excepts one argument"	deepCopyQueryBlock := aBlock</body><body package="COFramesystem">register: copyCell asCopyOf: originalCell	deepCopiedCells at: originalCell ifAbsentPut: copyCell.</body><body package="COFramesystem">spawnBlock	spawnBlock notNil ifTrue: [ ^ spawnBlock ].	^ [: originalFrame | originalFrame class new ]</body><body package="COFramesystem">spawnBlock: aBlock 	spawnBlock notNil ifTrue: [ self error: 'spawn block should not change!' ].	spawnBlock := aBlock.</body><body package="COFramesystem">spawnInNewCluster	self spawnBlock: [: originalFrame | self spawnInNewClusterFrom: originalFrame ].</body><body package="COFramesystem">spawnInNewClusterFrom: originalFrame 	| copy |	copy := originalFrame coastCreateBasicCopyInNewClusterInContext: self.	self firstSpawnedFrame: copy.	^ copy</body><body package="COFramesystem">spawnLocalFrames	self spawnBlock: [: originalFrame | self spawnLocalFrom: originalFrame ].</body><body package="COFramesystem">spawnLocalFrom: originalFrame 	| copy |	copy := originalFrame coastCreateBasicLocalCopyInContext: self.	self firstSpawnedFrame: copy.	^ copy</body><body package="COFramesystem">spawnTempSharedFrames	self spawnBlock: [: originalFrame | self spawnTempSharedFrom: originalFrame cluster: originalFrame cluster "cluster may be nil" ].</body><body package="COFramesystem">spawnTempSharedFrom: originalFrame cluster: cluster 	| copy |	copy := originalFrame coastCreateBasicCopyInNewClusterInContext: self.	copy coastID: #newUnreferencedFrame.	"mark it as a valid frame for temp sharing"	copy makeTempShared.	cluster notNil ifTrue: [ copy addToCluster: cluster ].	self firstSpawnedFrame: copy.	^ copy</body><body package="COFramesystem">spawnTempSharedInCluster: cluster	self spawnBlock: [: originalFrame | self spawnTempSharedFrom: originalFrame cluster: cluster ].</body></methods><methods><class-id>COAST.CopyContext</class-id> <category>accessing post copy</category><body package="COFramesystem">framesAndCopiesDo: block	deepCopiedCells keysAndValuesDo: block</body></methods><methods><class-id>COAST.CopyContext class</class-id> <category>instance creation</category><body package="COFramesystem">deepCopyQueryBlock: aBlock 	^ self new		deepCopyQueryBlock: aBlock;		yourself</body><body package="COFramesystem">forDeepCopy	^ self deepCopyQueryBlock: [: frame | true ]</body><body package="COFramesystem">forShallowCopy	"default"	^ self deepCopyQueryBlock: [: frame | false ]</body><body package="COFramesystem">new	^ super new initialize</body></methods><methods><class-id>COAST.CatFSCachedValue</class-id> <category>testing</category><body package="COFramesystem">isValid	^ true</body><body package="COFramesystem">isValid: ignore</body><body package="COFramesystem">isWeakObserver	^true</body><body package="COFramesystem">readAccess	^ self value</body><body package="COFramesystem">value	^ value</body><body package="COFramesystem">value: aValue	value := aValue</body></methods><methods><class-id>COAST.CatFSCachedValue</class-id> <category>accessing</category><body package="COFramesystem">allObservedClusterIDs	^Set new</body></methods><methods><class-id>COAST.CatFSCachedValue class</class-id> <category>instance creation</category><body package="COFramesystem">value: aValue	^ self new value: aValue; yourself</body></methods><methods><class-id>COAST.CoastLargeSetSegment</class-id> <category>accessing</category><body package="COFramesystem">clusterNumber	^ self fastAt: #clusterNumber</body><body package="COFramesystem">decreaseNumberOfValues	self at: #numberOfValues set: (self at: #numberOfValues) -1</body><body package="COFramesystem">hasSpace	^ self class maxNumberOfValues &gt; 1		ifTrue: [ self numberOfValues &lt; self class maxNumberOfValues ]		ifFalse: [ false ]</body><body package="COFramesystem">increaseNumberOfValues	self at: #numberOfValues set: (self at: #numberOfValues) + 1</body><body package="COFramesystem">isEmpty	^ self numberOfValues = 0</body><body package="COFramesystem">notEmpty	^ self isEmpty not</body><body package="COFramesystem">numberOfValues	^ self at: #numberOfValues</body><body package="COFramesystem">setHolder	^ self fastAt: #setHolder</body><body package="COFramesystem">valueCluster	self clusterNumber isNil ifTrue: [self initializeForClusterID: ( self clusterManager createCluster id)].	^ self clusterManager getCluster: self clusterNumber</body></methods><methods><class-id>COAST.CoastLargeSetSegment</class-id> <category>values</category><body package="COFramesystem">addValue: aFrame	" Note: sender must check that the segment does not yet include anObject "	| setHolder |	setHolder := self setHolder.	setHolder addValue: aFrame.	aFrame needsCluster		ifTrue: [ aFrame addToCluster: self valueCluster ].	self increaseNumberOfValues.</body><body package="COFramesystem">includesValue: anObject	^ self setHolder includesValue: anObject</body><body package="COFramesystem">removeValue: anObject	" Note: sender must check that the segment includes anObject "	self setHolder removeValue: anObject.	self decreaseNumberOfValues.</body><body package="COFramesystem">values	^ self setHolder at: #values</body></methods><methods><class-id>COAST.CoastLargeSetSegment</class-id> <category>initialize-release</category><body package="COFramesystem">initializeForClusterID: valueClusterID	| setHolder |	self at: #clusterNumber set: valueClusterID.	setHolder := CoastSegmentSetHolder new.	self at: #setHolder set: setHolder.</body></methods><methods><class-id>COAST.CoastLargeSetSegment</class-id> <category>copying</category><body package="COFramesystem">clone	| clone |	clone := self class new.	clone at: #clusterNumber set: (self at: #clusterNumber).	clone at: #numberOfValues set: (self at: #numberOfValues).	clone at: #setHolder set: (self at: #setHolder).	^ clone</body></methods><methods><class-id>COAST.CoastLargeSetSegment class</class-id> <category>slots</category><body package="COFramesystem">clusterNumberSlot	^ self slotSingleValue		range: Integer</body><body package="COFramesystem">numberOfValuesSlot	^ self slotSingleValue		range: Integer;		defaultValue: 0; 		yourself</body><body package="COFramesystem">setHolderSlot	^ self slotSingleValue		range: CoastSegmentSetHolder</body></methods><methods><class-id>COAST.CoastLargeSetSegment class</class-id> <category>accessing</category><body package="COFramesystem">maxNumberOfValues	maxNumberOfValues isNil		ifTrue: [ maxNumberOfValues := 500 ].	^ maxNumberOfValues</body><body package="COFramesystem">maxNumberOfValues: anInteger	maxNumberOfValues := anInteger</body></methods><methods><class-id>COAST.CoastLargeSetSegment class</class-id> <category>instance creation</category><body package="COFramesystem">forClusterID: valueClusterID	^ (self new)		initializeForClusterID: valueClusterID;		yourself</body><body package="COFramesystem">forClusterID: valueClusterID volume: aVolume	^ (self newInVolume: aVolume)		initializeForClusterID: valueClusterID;		yourself</body></methods><methods><class-id>COAST.CatMASingleRepeatedObject</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self class marshallID.</body></methods><methods><class-id>COAST.CatMASingleRepeatedObject</class-id> <category>accessing</category><body package="COMarshalling">asInteger	^ 1</body></methods><methods><class-id>COAST.CatMASingleRepeatedObject class</class-id> <category>accessing</category><body package="COMarshalling">marshallID	^ 23</body></methods><methods><class-id>COAST.CatMASingleRepeatedObject class</class-id> <category>instance creation</category><body package="COMarshalling">flushSingletons	singleton := nil</body><body package="COMarshalling">fromCount: count 	singleton isNil ifTrue: [ singleton := self new ].	^ singleton</body></methods><methods><class-id>COAST.CatMASingleRepeatedObject class</class-id> <category>unmarshalling</category><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	^ self fromCount: 1</body></methods><methods><class-id>COAST.CatFSPreIsolateDemon</class-id> <category>testing</category><body package="COFramesystem">interestedInPreIsolate	^ true</body></methods><methods><class-id>COAST.HuffmanISOString class</class-id> <category>accessing</category><body package="COMarshalling">baseClass	^ ISO8859L1String</body><body package="COMarshalling">marshallID	^ 27</body></methods><methods><class-id>COAST.CoastCollection</class-id> <category>copying</category><body package="COFramesystem">allSatisfy: block 	self do: [: any | ( block value: any ) ifFalse: [ ^ false ]].	^ true</body><body package="COFramesystem">asArray	| anArray index |	anArray := Array new: self size.	index := 0.	self do: [: each | anArray at: ( index := index + 1 ) put: each ].	^ anArray</body><body package="COFramesystem">asCollection	^ self collect: [: elem | elem ] as: self collectionTypeForCollect</body><body package="COFramesystem">asList	^ List withAll: self</body><body package="COFramesystem">asOrderedCollection	^ self collectAsOrderedCollection: [: elem | elem ]</body><body package="COFramesystem">asRPCArguments	| anArray index |	anArray := Array new: self size.	index := 0.	self referencesElementsCursorDo: [: assocOrElem | anArray at: ( index := index + 1 ) put: assocOrElem value copyForRefCursor ].	^ anArray asRPCArguments</body><body package="COFramesystem">asSet	^ self collect: [: elem | elem ] as: Set</body><body package="COFramesystem">asSortedCollection	^ self collect: [: elem | elem ] as: SortedCollection</body><body package="COFramesystem">collect: block 	^ self collect: block as: self collectionTypeForCollect</body><body package="COFramesystem">collect: block as: collectionClass 	| result |	result := collectionClass new: self size.	self do: [: value | result add: ( block value: value )].	^ result</body><body package="COFramesystem">collectAsArray: aBlock	| array i |	array := Array new: self size.	i := 1.	self do: [ :element |		array at: i put: (aBlock value: element).		i := i + 1.	].	^ array</body><body package="COFramesystem">collectAsOrderedCollection: block 	^ self collect: block as: OrderedCollection</body><body package="COFramesystem">collectionTypeForCollect	self subclassResponsibility</body><body package="COFramesystem">reject: block 	^ self reject: block as: self collectionTypeForCollect</body><body package="COFramesystem">reject: block as: collectionClass 	| result |	result := collectionClass new: self size.	self do: [: value | ( block value: value ) ifFalse: [ result add: value ]].	^ result</body><body package="COFramesystem">select: block 	^ self select: block as: self collectionTypeForCollect</body><body package="COFramesystem">select: block as: collectionClass 	| result |	result := collectionClass new: self size.	self do: [: value | ( block value: value ) ifTrue: [ result add: value ]].	^ result</body></methods><methods><class-id>COAST.CoastCollection</class-id> <category>accessing</category><body package="COFramesystem">anyElement	self do: [: e | ^ e ].	^ nil</body><body package="COFramesystem">anyKey	self keysDo: [: e | ^ e ].	^ nil</body><body package="COFramesystem">do: block 	self subclassResponsibility.</body><body package="COFramesystem">size	self subclassResponsibility.</body><body package="COFramesystem">sortedBy: aBlock	^ self asCollection sortedBy: aBlock</body><body package="COFramesystem">values	| values |	values := OrderedCollection new: self size.	self do: [: elem | values add: elem ].	^ values</body></methods><methods><class-id>COAST.CoastCollection</class-id> <category>testing</category><body package="COFramesystem">includes: key 	self includesKey: key</body><body package="COFramesystem">includesKey: key 	self subclassResponsibility.</body><body package="COFramesystem">isCoastCollectionFrame	^ true</body><body package="COFramesystem">isEmpty	^ self size = 0</body><body package="COFramesystem">notEmpty	^ self isEmpty not</body></methods><methods><class-id>COAST.CoastCollection</class-id> <category>enumerating</category><body package="COFramesystem">keysDo: block 	self subclassResponsibility.</body><body package="COFramesystem">referencesElementsCursorDo: block 	self subclassResponsibility.</body></methods><methods><class-id>COAST.CoastCollection</class-id> <category>private</category><body package="COFramesystem">depleteProxy	self depleteSlot: #lastKeys.	self depleteSlot: #segments.	self depleteSlot: #sizes</body></methods><methods><class-id>COAST.CoastCollection</class-id> <category>iterating</category><body package="COFramesystem">coastAllArgumentsDo: block 	self do: block.</body></methods><methods><class-id>COAST.CatMAShortRepeatedObject</class-id> <category>accessing</category><body package="COMarshalling">asInteger	^ count</body><body package="COMarshalling">count: aCount 	count := aCount.	self beImmutable.</body></methods><methods><class-id>COAST.CatMAShortRepeatedObject</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self class marshallID.	aStream nextPut: count.</body></methods><methods><class-id>COAST.CatMAShortRepeatedObject class</class-id> <category>accessing</category><body package="COMarshalling">marshallID	^ 24</body></methods><methods><class-id>COAST.CatMAShortRepeatedObject class</class-id> <category>unmarshalling</category><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	^ self fromCount: aStream next</body></methods><methods><class-id>COAST.CatMAShortRepeatedObject class</class-id> <category>instance creation</category><body package="COMarshalling">flushSingletons	singletons := nil</body><body package="COMarshalling">fromCount: count 	singletons isNil ifTrue: 		[	singletons := ( 1 to: 255 ) collect: 					[: i | ( self new )							count: i;							yourself					]		].	^ singletons at: count</body></methods><methods><class-id>COAST.CatFSCachingVirtualSlot</class-id> <category>initialize-new</category><body package="COFramesystem">initializeForBlockCache: blockCache arguments: arguments	self cellContainer: blockCache.	self initializeSubjects.	self isValid: false.	self id: arguments.	self composingMethod: [ : voidArg | blockCache block valueWithArguments: arguments ].</body></methods><methods><class-id>COAST.CatFSCachingVirtualSlot</class-id> <category>accessing - private</category><body package="COFramesystem">isPrototype	^false</body></methods><methods><class-id>COAST.CatFSCachingVirtualSlot</class-id> <category>value access</category><body package="COFramesystem">releaseOldValue</body></methods><methods><class-id>COAST.CatFSCachingVirtualSlot</class-id> <category>testing</category><body package="COFramesystem">mayComputeOutsideTranscation	CoastLog logDebug: [ self printString , ' computed cache without transaction' ].	^ true</body></methods><methods><class-id>COAST.CatFSCachingVirtualSlot</class-id> <category>printing</category><body package="COFramesystem">idPrintStringOn: stream 	"print the arguments - in a save way, frames only by id string"	stream nextPut: $[.	self id 		do: 		[: argument |			argument isCoastFrame 				ifTrue: [ argument fullIDStringOn: stream ]				ifFalse: [ argument printOn: stream ]		]		separatedBy: [ stream nextPutAll: ', ' ].	stream nextPut: $].</body></methods><methods><class-id>COAST.CatMALongRepeatedObject</class-id> <category>accessing</category><body package="COMarshalling">asInteger	^ count</body><body package="COMarshalling">count: aCount 	count := aCount.</body></methods><methods><class-id>COAST.CatMALongRepeatedObject</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self class marshallID.	aStream nextOptimized32Put: count.</body></methods><methods><class-id>COAST.CatMALongRepeatedObject class</class-id> <category>accessing</category><body package="COMarshalling">marshallID	^ 25</body></methods><methods><class-id>COAST.CatMALongRepeatedObject class</class-id> <category>unmarshalling</category><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	^ self fromCount: aStream nextOptimized32</body></methods><methods><class-id>COAST.CatMALongRepeatedObject class</class-id> <category>instance creation</category><body package="COMarshalling">fromCount: count 	^ ( self new )		count: count;		yourself</body></methods><methods><class-id>COAST.CatFSEagerVirtualSlot</class-id> <category>printing</category><body package="COFramesystem">classLabel	^'eager Slot'</body></methods><methods><class-id>COAST.CatFSEagerVirtualSlot</class-id> <category>accessing</category><body package="COFramesystem">computedLazy	self changeClassTo: CatFSVirtualSlot</body><body package="COFramesystem">revalidationBlock: aBlockClosure 	definition revalidationBlock: aBlockClosure</body></methods><methods><class-id>COAST.CatFSEagerVirtualSlot</class-id> <category>observer - subject</category><body package="COFramesystem">finishInvalidate	super finishInvalidate.	self transactionManager activeTransaction rememberOutstandingComposition: self.</body></methods><methods><class-id>COAST.CatFSEagerVirtualSlot</class-id> <category>testing</category><body package="COFramesystem">isLazy	^ false</body></methods><methods><class-id>COAST.CatFSEagerVirtualSlot</class-id> <category>initialize-release</category><body package="COFramesystem">initializeSpawned	" make sure that eager cells are immediatly computed at the end of the transaction "	super initializeSpawned.	self transactionManager activeTransaction rememberInitialOutstandingComposition: self.</body></methods><methods><class-id>COAST.CoastThreeByteInteger class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ SmallInteger threeByteMarshallID</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	^ aStream next24</body></methods><methods><class-id>COAST.CoastCollectionSegment</class-id> <category>accessing</category><body package="COFramesystem">add: object 	self subclassResponsibility.</body><body package="COFramesystem">coastCompactElementCount	^ ( self at: #compactCollection ) coastCompactElementCount</body><body package="COFramesystem">do: block 	^ ( self at: #compactCollection ) do: block</body><body package="COFramesystem">lastElement	^ ( self at: #compactCollection ) lastElement</body><body package="COFramesystem">moveSomeElementsTo: newLeaf 	^ self moveSomeElementsTo: newLeaf max: self coastCompactElementCount // 2</body><body package="COFramesystem">moveSomeElementsTo: newLeaf max: max 	self subclassResponsibility.</body><body package="COFramesystem">size	^ self sizeAt: #compactCollection</body></methods><methods><class-id>COAST.CoastCollectionSegment</class-id> <category>enumerating</category><body package="COFramesystem">referencesElementsCursorDo: block 	( self at: #compactCollection ) referencesElementsCursorDo: block.</body></methods><methods><class-id>COAST.CoastCollectionSegment class</class-id> <category>testing</category><body package="COFramesystem">isFastRead	^ true</body><body package="COFramesystem">isPartOfIndexStructure	^true</body></methods><methods><class-id>COAST.CoastCollectionSegment class</class-id> <category>slots</category><body package="COFramesystem">compactCollectionSlot	^ self slotOfType: self collectionSlotType</body></methods><methods><class-id>COAST.CoastCollectionSegment class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ self subclassResponsibility</body></methods><methods><class-id>COAST.CoastOneByteInteger class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ SmallInteger oneByteMarshallID</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	^ aStream next</body></methods><methods><class-id>COAST.CatFSConstituentDemon</class-id> <category>actions</category><body package="COFramesystem">constituentCheckFor: cellAccess cell: cell	cell constituentCheckFor: cellAccess</body><body package="COFramesystem">preAction: cellAccess	cellAccess keepDifferences</body></methods><methods><class-id>COAST.CatFSConstituentDemon</class-id> <category>testing</category><body package="COFramesystem">hasEndTransactionJobWithAccess: aCatCSCellAccess	"i can only be triggered if something has been removed"	^aCatCSCellAccess isWriteAccess and:		[ aCatCSCellAccess differences removed isEmpty not ]</body></methods><methods><class-id>COAST.CatFSConstituentDemon</class-id> <category>initialize-release</category><body package="COFramesystem">initialize	super initialize.	self preJob: [ :demon :cellAccess :cell | self preAction: cellAccess ].	self endTransactionJob: [ :demon :cellAccess :cell | self constituentCheckFor: cellAccess cell: cell ].	write := true.	self name: #constituent.</body></methods><methods><class-id>COAST.CoastTwoByteInteger class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ SmallInteger twoByteMarshallID</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	^ aStream next16</body></methods><methods><class-id>COAST.AbstractBinaryContainer</class-id> <category>accessing</category><body package="COFramesystem">fileID	self subclassResponsibility</body><body package="COFramesystem">filename	^ self at: #filename.</body><body package="COFramesystem">filename: aFilenameOrString 	self 		at: #filename		set: ( aFilenameOrString notNil 				ifTrue: [ self normalizeFilename: aFilenameOrString ]				ifFalse: [ nil ]).</body><body package="COFramesystem">mimeType	^ self at: #mimeType.</body><body package="COFramesystem">mimeType: aString	self at: #mimeType set: aString.</body><body package="COFramesystem">size	^self at: #size</body><body package="COFramesystem">size: aInteger	self at: #size set: aInteger</body></methods><methods><class-id>COAST.AbstractBinaryContainer</class-id> <category>private</category><body package="COFramesystem">normalizeFilename: aFilenameOrString 	" ohne Pfade, ohne problematische Characters "	| normalized |	normalized := aFilenameOrString asFilename tail. "Problem: eventuell passt meine aktuelle Plattform nicht zum Filename. To be done"	"normalized := NTFSFilename mapUglies: normalized.	normalized := UnixFilename mapUglies: normalized."	^ normalized</body></methods><methods><class-id>COAST.AbstractBinaryContainer</class-id> <category>testing</category><body package="COFramesystem">coastIsBinaryContainer	^ true</body></methods><methods><class-id>COAST.AbstractBinaryContainer</class-id> <category>transfer</category><body package="COFramesystem">downloadToFile: aFilename 	self subclassResponsibility</body><body package="COFramesystem">uploadFromFile: aFilename clusterManager: aClusterManager filename: filenameString 	self subclassResponsibility</body></methods><methods><class-id>COAST.AbstractBinaryContainer</class-id> <category>api</category><body package="COFramesystem">bytes	self subclassResponsibility</body><body package="COFramesystem">bytes: newByteArray 	self subclassResponsibility</body><body package="COFramesystem">removeFromStoreIfPossible	"the binary container is not used any more (by one client) - remove it from store if it is not used anymore"</body></methods><methods><class-id>COAST.AbstractBinaryContainer</class-id> <category>relationships</category><body package="COFramesystem">sortKey	^ self filename ifNil: [ '' ]</body></methods><methods><class-id>COAST.AbstractBinaryContainer class</class-id> <category>slots</category><body package="COFramesystem">filenameSlot	^ self slotSingleValue		range: String;		yourself</body><body package="COFramesystem">mimeTypeSlot	^ self slotSingleValue		range: String;		yourself</body><body package="COFramesystem">sizeSlot	^(self slotSingleValue)		range: Integer;		yourself</body></methods><methods><class-id>COAST.CoastSegmentSetHolder</class-id> <category>accessing</category><body package="COFramesystem">addValue: anObject	self at: #values add: anObject.</body><body package="COFramesystem">includesValue: aFrame	^self at: #values includes: aFrame</body><body package="COFramesystem">removeValue: anObject	self at: #values remove: anObject.</body><body package="COFramesystem">values	^ self at: #values</body></methods><methods><class-id>COAST.CoastSegmentSetHolder class</class-id> <category>slot</category><body package="COFramesystem">valuesSlot	^ self slotOfType: #set</body></methods><methods><class-id>COAST.CatRMInterruptMessage</class-id> <category>accessing</category><body package="COMessages">data	^data ifNil: [ String new ]</body><body package="COMessages">data: anObject	data := anObject</body><body package="COMessages">receiver	^CatCSClusterLocator id: 0 volume: self volume</body><body package="COMessages">target	^target</body><body package="COMessages">target: anObject	target := anObject</body><body package="COMessages">volume	^volume</body><body package="COMessages">volume: anObject	volume := anObject</body></methods><methods><class-id>COAST.CatRMInterruptMessage</class-id> <category>testing</category><body package="COMessages">isInterruptMessage	^true</body></methods><methods><class-id>COAST.CatRMInterruptMessage</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextCoastStringPut: self volume.	aStream nextCoastStringPut: self data.	aStream nextCoastStringPut: self target.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self volume: aStream nextCoastString.	self data: aStream nextCoastString.	self target: aStream nextCoastString.</body></methods><methods><class-id>COAST.CatRMInterruptMessage class</class-id> <category>instance creation</category><body package="COMessages">volume: volume target: targetString data: dataString	^self new		volume: volume;		target: targetString;		data: dataString;		yourself</body></methods><methods><class-id>COAST.WeakSegmentedFrameSet</class-id> <category>private</category><body package="COFramesystem">setClass	^ ThreadSafeWeakFrameSet</body><body package="COFramesystem">updateTally	contents updateTally.	self overflowDo: [: more | more updateTally ].</body></methods><methods><class-id>COAST.CatFSUniversalFrame</class-id> <category>accessing</category><body package="COMarshalling">coastFrameDictKey	^ self frameClassSymbol</body><body package="COFramesystem">coastSpawn	self error: 'Universal frames must not be created!'.	^ super coastSpawn</body><body package="COFramesystem">frameClassName	^frameClassName</body><body package="COFramesystem">frameClassName: aString	frameClassName := aString</body><body package="COFramesystem">frameClassSymbol	^frameClassName asSymbol</body><body package="COFramesystem">frameKey	^ self frameClassSymbol</body></methods><methods><class-id>COAST.CatFSUniversalFrame</class-id> <category>testing</category><body package="COFramesystem">isUniversalFrame	^ true</body></methods><methods><class-id>COAST.CatFSUniversalFrame</class-id> <category>class membership</category><body package="COFramesystem">isCoastKindOf: aClass 	^ aClass includesBehavior: CatFSFrame</body></methods><methods><class-id>COAST.CatFSUniversalFrame</class-id> <category>printing</category><body package="COFramesystem">classLabel	^ self isPrototype 		ifTrue: [ super classLabel ]		ifFalse: [ 'universal~' , self frameClassName ]</body></methods><methods><class-id>COAST.CatFSUniversalFrame class</class-id> <category>accessing</category><body package="COFramesystem">frameClassSymbol	^ self shouldNotImplement</body><body package="COFramesystem">frameKey	^ self shouldNotImplement</body></methods><methods><class-id>COAST.CatFSUniversalFrame class</class-id> <category>instanceCreation</category><body package="COFramesystem">newWithFrameClassName: aString	^self basicNew frameClassName: aString</body></methods><methods><class-id>COAST.CatFSUniversalFrame class</class-id> <category>debug</category><body package="COFramesystem">addDumpInfoTo: stream 	| unknownClasses |	stream		nextPutAll: self name asString;		nextPutAll: ' - unknownClasses:'.	unknownClasses := Set new.	self allInstances do: [: inst | unknownClasses add: inst frameClassName ].	unknownClasses isEmpty ifTrue: [ stream cr; tab; nextPutAll: ' none!' ].	( unknownClasses coastSortedBy: [: frameClassName | frameClassName ]) do: 		[: frameClassName |			stream				cr;				tab;				nextPutAll: frameClassName asString		].	stream cr</body></methods><methods><class-id>COAST.CatCSClusterAdministrationFrame</class-id> <category>accessing</category><body package="COFramesystem">atName: aSymbol	^self at: #namedFrames atKey: aSymbol</body><body package="COFramesystem">atName: aSymbol put: aFrame 	( self includesName: aSymbol ) 		ifTrue: 		[	"naming conflict: name is already in use. Better throw an exception here!"			self transactionManager abortTransaction		]		ifFalse: [ self at: #namedFrames atKey: aSymbol put: aFrame ].</body><body package="COFramesystem">includesName: aSymbol	^self at: #namedFrames includesKey: aSymbol</body><body package="COFramesystem">namedFrames	^self at: #namedFrames</body><body package="COFramesystem">removeName: aSymbol	^self at: #namedFrames removeKey: aSymbol</body><body package="COFramesystem">removeVolumeInfoAt: timestamp	self 		at: #volumeInfo		removeKey: timestamp</body><body package="COFramesystem">volumeInfo	^self at: #volumeInfo</body><body package="COFramesystem">volumeInfo: aString 	self 		at: #volumeInfo		atKey: Timestamp now		put: aString</body><body package="COFramesystem">volumeInfoAt: timestamp string: aString 	self 		at: #volumeInfo		atKey: timestamp		put: aString</body></methods><methods><class-id>COAST.CatCSClusterAdministrationFrame</class-id> <category>basic accessing</category><body package="COFramesystem">basicRootFrames	"do not use official frame/slot accesses"	| s |	s := self basicSlotNamed: #namedFrames.	^s isNil		ifTrue: [ Set new ]		ifFalse: [ s resolvedCellValue ]</body></methods><methods><class-id>COAST.CatCSClusterAdministrationFrame</class-id> <category>coast counter</category><body package="COFramesystem">coastCounterAt: frame 	self clusterManager responsibleForVolume 		ifFalse: [ ^ self at: nil rpcPerform: #coastCounterAt: withArguments: ( Array with: frame ) allowCache: false ].	^ self at: #counterPerFrame atKey: frame ifAbsent: [ nil ]</body><body package="COFramesystem">coastCounterAt: frame incBy: delta 	"the only valid way to modify the counter"	"this modification will not be undone on transaction failure!"	| current segmentedCollection segment |	self clusterManager responsibleForVolume 		ifFalse: [ ^ self at: nil rpcPerform: #coastCounterAt:incBy: withArguments: ( Array with: frame with: delta ) allowCache: false ].	current := ( self coastCounterAt: frame ) ifNil: 			[	Processor activeTransaction allowRPCWriteAccessesWhile: [ self coastCounterAt: frame set: 0 ].				0			].	current isInteger ifFalse: [ current := 0 ].	current := current + delta.	segmentedCollection := ( self at: #counterPerFrame ) valueFrame.	segment := segmentedCollection segmentAtIndex: ( segmentedCollection segmentIndexForKey: frame ).	( segment at: #compactCollection ) coastInternalAt: frame put: current.	segment cluster clusterController modified: true.	^ current</body><body package="COFramesystem">coastCounterAt: frame set: value 	"only set new or remove old value	return the effective value"	self clusterManager responsibleForVolume 		ifFalse: [ ^ self at: nil rpcPerform: #coastCounterAt:set: withArguments: ( Array with: frame with: value ) allowCache: false ].	Processor activeTransaction allowRPCWriteAccessesWhile: 		[ | segmentedCollection |			value notNil 				ifTrue: 				[( self at: #counterPerFrame includesKey: frame ) 						ifTrue: [ ^ CoastError raiseSignal: 'Counter modification not allowed!' ]						ifFalse: [ self at: #counterPerFrame atKey: frame put: value ]				]				ifFalse: [ self at: #counterPerFrame removeKey: frame ].			" Mediator transactions do not set the modification flag "			segmentedCollection := ( self at: #counterPerFrame ) valueFrame.			segmentedCollection cluster clusterController modified: true.			segmentedCollection segmentsDo: [ : segment |				segment cluster clusterController modified: true			].		].	^ value</body><body package="COFramesystem">coastFastCounterAt: frame 	^ self fastAt: #counterPerFrame atKey: frame</body></methods><methods><class-id>COAST.CatCSClusterAdministrationFrame class</class-id> <category>slots</category><body package="COFramesystem">counterPerFrameSlot	^ self slotOfType: #proxyDictionary</body><body package="COFramesystem">namedFramesSlot	^(self slotOfType: #dictionary)		range: CatFSFrame;		yourself</body><body package="COFramesystem">rootFramesSlot	^(self slotOfType: #set)		range: CatFSFrame;		yourself</body><body package="COFramesystem">volumeInfoSlot	^(self slotOfType: #dictionary)		yourself</body></methods><methods><class-id>COAST.CatRMAliveMessage</class-id> <category>accessing</category><body package="COMessages">clientID	^clientID</body><body package="COMessages">clientID: anInteger	clientID := anInteger</body><body package="COMessages">globalSeqNum	^globalSeqNum</body><body package="COMessages">globalSeqNum: anInteger	globalSeqNum := anInteger</body><body package="COMessages">receiver	^receiver</body><body package="COMessages">receiver: aCatCSClusterLocator	receiver := aCatCSClusterLocator</body></methods><methods><class-id>COAST.CatRMAliveMessage</class-id> <category>printing</category><body package="COMessages">printOn: stream 	super printOn: stream.	stream nextPutAll: ' clientID '.	clientID printOn: stream</body></methods><methods><class-id>COAST.CatRMAliveMessage</class-id> <category>marshalling</category><body package="COMessages">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextUnsigned32Put: self globalSeqNum.	aStream nextOptimized32Put: self clientID.	self receiver marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMessages">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager	self globalSeqNum: aStream nextUnsigned32.	self clientID: aStream nextOptimized32.	self receiver: ( CatCSClusterLocator unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall ).</body></methods><methods><class-id>COAST.CatRMAliveMessage class</class-id> <category>instance creation</category><body package="COMessages">globalSeqNum: anInteger clientID: clientid receiver: aCatCSClusterLocator	^(self new) 		globalSeqNum: anInteger; 		clientID: clientid; 		receiver: aCatCSClusterLocator;		yourself</body></methods><methods><class-id>COAST.SlotObserverPair</class-id> <category>printing</category><body package="COFramesystem">printOn: aStream	self subject printOn: aStream.	aStream nextPutAll: ' '.	slotName printOn: aStream.	aStream nextPutAll: ' --&gt; '.	self observer printOn: aStream.</body></methods><methods><class-id>COAST.SlotObserverPair</class-id> <category>comparing</category><body package="COFramesystem">= anotherPair	^ super = anotherPair and: [ slotName == anotherPair slotName ]</body><body package="COFramesystem">hash	^ self observer hash bitXor: slotName hash</body></methods><methods><class-id>COAST.SlotObserverPair</class-id> <category>accessing</category><body package="COFramesystem">frame	^ subject</body><body package="COFramesystem">frame: aCoastFrame	subject := aCoastFrame</body><body package="COTransactions">referencedClusterIDsSkip: skipFrames	^ self frame referencedClusterIDsSkip: skipFrames</body><body package="COFramesystem">slotName	^slotName</body><body package="COFramesystem">slotName: anObject	slotName := anObject</body></methods><methods><class-id>COAST.SlotObserverPair class</class-id> <category>testing</category><body package="COFramesystem">isObserverPair: observerPair equalToObserver: observer subject: subject slotName: slotName	" compare subject/observer with ==, because = might result in a slot access, 	which will mess up the observation mechanism and might cause infinite recursions "	^ observerPair class = self 		and: [ observerPair coastSubject == subject		and: [ observerPair coastObserver == observer		and:  [ observerPair slotName == slotName ]]]</body></methods><methods><class-id>COAST.SlotObserverPair class</class-id> <category>instance creation</category><body package="COFramesystem">observer: aCell frame: aCoastFrame slotName: aSymbol	^self new observer: aCell; frame: aCoastFrame; slotName: aSymbol; yourself</body></methods><methods><class-id>COAST.SegmentedIndexHeader</class-id> <category>accessing</category><body package="COFramesystem">compareIndex: index key: key value: value 	| compare |	compare := self compareIndex: index key: key.	^ compare = 0 		ifTrue: 		[	"key=midKey"			( lastValues at: index ) coastCompareTo: value		]		ifFalse: [ compare ]</body><body package="COFramesystem">lastValues: aLastValues 	lastValues := aLastValues</body><body package="COFramesystem">segmentClusterIDForKey: key value: value 	^ clusterIDs at: ( self segmentIndexForKey: key value: value min: 1 max: lastKeys size )</body><body package="COFramesystem">segmentIndexForKey: key value: value min: min max: max 	"search index of the segment responsible for key-&gt;value"	| minIndex maxIndex |	minIndex := min.	maxIndex := max.	"1 &lt;= minIndex &lt;= maxIndex &lt;= keys size"	[ minIndex &lt; maxIndex ] whileTrue: 		[ "search in interval [ minIndex .. maxIndex ]"			| index compare |			index := minIndex + maxIndex bitShift: -1.	"minIndex &lt;= index &lt; maxIndex"			compare := self compareIndex: index key: key value: value.			compare = 0 ifTrue: [ ^ index	"value=midVal ==&gt; return index" ].			compare = 1 				ifTrue: [ maxIndex := index	"search at or before index" ]				ifFalse: [ minIndex := index + 1	"search behind index" ]		].	"minIndex = maxIndex"	^ minIndex</body></methods><methods><class-id>COAST.AccessObserverPair</class-id> <category>printing</category><body package="COFramesystem">printOn: aStream	self observer printOn: aStream.	aStream nextPutAll: ' --&gt; '.	self subject printOn: aStream.</body></methods><methods><class-id>COAST.AccessObserverPair</class-id> <category>accessing</category><body package="COFramesystem">accesses	^ accesses ifNil: [ #() ]</body><body package="COFramesystem">addAccess: aCatCSCellAccess	| copiedAccess |	accesses isNil ifTrue: [ accesses := Set new ].	copiedAccess := aCatCSCellAccess asSlotAccessForInvalidation.	accesses add: copiedAccess</body><body package="COFramesystem">coastInvalidateWithAccess: cellAccessOrNil	cellAccessOrNil isNil		ifTrue: [ ^ super coastInvalidateWithAccess: cellAccessOrNil ].	(self accesses allSatisfy: [ : registeredAccess | registeredAccess isCommutativeTo: cellAccessOrNil asSlotAccessForInvalidation])		ifTrue: [ ^ true ].	^ super coastInvalidateWithAccess: cellAccessOrNil</body></methods><methods><class-id>COAST.AccessObserverPair class</class-id> <category>instance creation</category><body package="COFramesystem">observer: aCell subject: subjectCell	^self new observer: aCell; subject: subjectCell; yourself</body></methods><methods><class-id>COAST.CatCSExternalFileInfo</class-id> <category>display</category><body package="COClusterManagement">printOn: stream 	stream nextPutAll: 'ExternalFileInfo ( last check: '.	accessTime printOn: stream.	stream nextPutAll: ' )'</body></methods><methods><class-id>COAST.CatFSInvertingDemon</class-id> <category>accessing</category><body package="COFramesystem">keyBlock: aKeyBlock 	keyBlock := aKeyBlock</body><body package="COFramesystem">keyFor: frame 	^ keyBlock notNil 		ifTrue: [ keyBlock value: frame ]		ifFalse: [ nil ]</body></methods><methods><class-id>COAST.CatFSInvertingDemon</class-id> <category>initialize-release</category><body package="COFramesystem">initialize	super initialize.	self name: #invertingSlot</body></methods><methods><class-id>COAST.CatFSInvertingDemon</class-id> <category>dispatching</category><body package="COFramesystem">invertedSlotNamed: slotName at: frame addFrame: addedFrame 	( frame prototype basicSlotNamed: slotName ) valueHolder invertFrame: frame slotName: slotName added: addedFrame with: self.</body><body package="COFramesystem">invertedSlotNamed: slotName at: frame removeFrame: removedFrame 	| slot |	slot := frame prototype basicSlotNamed: slotName.	slot isNil ifTrue: 		[	"universal frame without a matching prototype"			slot := frame slotNamed: slotName		].	slot isNil 		ifTrue: [ SlotNotFoundError new isResumable: true; raiseSignal: slotName asString , ' not found' ]		ifFalse: [ slot valueHolder invertFrame: frame slotName: slotName removed: removedFrame with: self ].</body></methods><methods><class-id>COAST.CoastJournalCollection</class-id> <category>accessing</category><body package="COFramesystem">coastInternalMaxJournalSize: journalSize in: slot 	| segmentedCollection |	journalSize = 0 ifTrue: 		[	self fullFlushJournal.			segmentedCollection := self segmentedCollection.			slot frame at: slot id set: segmentedCollection.			^ segmentedCollection		].	self at: #maxJournalSize set: journalSize.	self checkJournal.	^ self</body><body package="COFramesystem">depleteProxy	self segmentedCollection depleteProxy.	self depleteSlot: #removed.	self depleteSlot: #added.</body><body package="COFramesystem">fullSanityCheck	^ self segmentedCollection fullSanityCheck</body><body package="COFramesystem">maxJournalSize	^ self at: #maxJournalSize.</body><body package="COFramesystem">segmentClusterIDs	^ self segmentedCollection segmentClusterIDs</body><body package="COFramesystem">segmentedCollection	| segmentedCollection |	segmentedCollection := self at: #segmentedCollection.	(segmentedCollection isCoastFrame not and: [ segmentedCollection isFrameOrFrameReference ]) 		ifTrue: [ segmentedCollection := segmentedCollection realFrameFrom: self clusterManager ].	(segmentedCollection isCoastFrame and: [ segmentedCollection clusterManager isNil ]) ifTrue: 		[	"mediator should reload the cluster"			segmentedCollection := segmentedCollection frameReference realFrameFrom: self clusterManager 		].	^ segmentedCollection</body><body package="COFramesystem">size	| array |	array := self cleanJournalDiffs.	^ self segmentedCollection size + ( array at: 1 ) size - ( array at: 2 ) size</body></methods><methods><class-id>COAST.CoastJournalCollection</class-id> <category>private</category><body package="COFramesystem">checkJournal	| maxJournalSize toFree |	maxJournalSize := self maxJournalSize.	toFree := self journalSize - maxJournalSize.	toFree &gt; 0 ifTrue: [ self fastFlushJournal: toFree + ( maxJournalSize // 16 )].</body><body package="COFramesystem">cleanJournalDiffs	"remove added already included	remove removed not included yet"	self subclassResponsibility.	Array with: ( self at: #added ) with: ( self at: #removed ).</body><body package="COFramesystem">compactAddsAndRemoves	( self at: #added ) compact.	( self at: #removed ) compact.</body><body package="COFramesystem">diffsBySegmentClusterID: segmentedCollection 	self subclassResponsibility.</body><body package="COFramesystem">fastFlushJournal: toFree 	"group k&amp;v by target Segment - fill up biggest first"	"should reduce clusters to save to a minimum while shrinking journal"	"return number of removed entries"	| segmentedCollection diffsByCID flushed |	segmentedCollection := self segmentedCollection.	diffsByCID := self diffsBySegmentClusterID: segmentedCollection.	diffsByCID isNil ifTrue: [ ^ self fullFlushJournal ].	flushed := 0.	diffsByCID copy keysAndValuesDo: 		[: cid : collection | ( self clusterManager isClusterLoaded: cid ) ifTrue: 				[	flushed := flushed + ( self flush: collection segmentedCollection: segmentedCollection ).					flushed &gt;= toFree ifTrue: 						[	CoastLog logDebug: [ 'fastFlushJournal: shrink ' , self printString , ' by ' , flushed printString ] channel: #journal.							^ flushed						].					diffsByCID removeKey: cid				]		].	diffsByCID := diffsByCID sortedBy: [: oc | oc size negated ].	diffsByCID do: 		[: collection |			flushed := flushed + ( self flush: collection segmentedCollection: segmentedCollection ).			flushed &gt;= toFree ifTrue: 				[	CoastLog logDebug: [ 'fastFlushJournal: shrink ' , self printString , ' by ' , flushed printString ] channel: #journal.					^ flushed				]		].	CoastLog logDebug: [ 'fastFlushJournal did full flush!!! ' , self printString , ' by ' , flushed printString ] channel: #journal.	^ flushed</body><body package="COFramesystem">flush: collection segmentedCollection: segmentedCollection	"flush some parts matching a single Segment"	self subclassResponsibility.</body><body package="COFramesystem">fullFlushJournal	"flush "	self subclassResponsibility.</body><body package="COFramesystem">journalSize	^ ( self sizeAt: #added ) + ( self sizeAt: #removed )</body></methods><methods><class-id>COAST.CoastJournalCollection</class-id> <category>testing</category><body package="COFramesystem">isEmpty	self do: [: e | ^ false ].	^ true</body></methods><methods><class-id>COAST.CoastJournalCollection</class-id> <category>copying</category><body package="COFramesystem">collectAsArray: block 	^ self collect: block as: Array</body></methods><methods><class-id>COAST.CoastJournalCollection</class-id> <category>enumerating</category><body package="COFramesystem">referencesElementsCursorDo: block 	| added removed |	added := self at: #added.	added referencesElementsCursorDo: block.	removed := self at: #removed.	self segmentedCollection referencesElementsCursorDo: 		[: ref | (( added journalIncludesReferencedElement: ref ) or: [ removed journalIncludesReferencedElement: ref ]) 				ifFalse: [ block value: ref ]		].</body></methods><methods><class-id>COAST.CoastJournalCollection class</class-id> <category>accessing</category><body package="COFramesystem">addedSlot	^ self slotOfType: self collectionSlotType</body><body package="COFramesystem">collectionSlotType	^ self subclassResponsibility</body><body package="COFramesystem">maxJournalSizeSlot	^ ( self slotSingleValue )		defaultValue: 1024;		yourself</body><body package="COFramesystem">removedSlot	^ self slotOfType: self collectionSlotType</body><body package="COFramesystem">segmentedCollectionSlot	^ self slotSingleValue</body></methods><methods><class-id>COAST.CoastSegmentedCollection</class-id> <category>accessing slots</category><body package="COFramesystem">lastKeyAtIndex: index 	^ self at: #lastKeys atIndex: index</body><body package="COFramesystem">lastKeyAtIndex: index put: key 	^ self at: #lastKeys atIndex: index put: key selfOrFrameLocator</body><body package="COFramesystem">lastKeyBeforeIndex: index add: key 	^ self at: #lastKeys add: key selfOrFrameLocator beforeIndex: index</body><body package="COFramesystem">lastReferenceBeforeIndex: index add: reference 	self lastKeyBeforeIndex: index add: reference</body><body package="COFramesystem">numberOfSegments	^ self sizeAt: #segments</body><body package="COFramesystem">removeAtIndex: index 	self at: #segments removeAtIndex: index.	self at: #lastKeys removeAtIndex: index.	self at: #sizes removeAtIndex: index</body><body package="COFramesystem">segmentAtIndex: index 	| segmentOrLocator |	segmentOrLocator := self at: #segments atIndex: index.	^ self clusterManager getFrame: segmentOrLocator frameID inCluster: segmentOrLocator clusterID</body><body package="COFramesystem">segmentBeforeIndex: index add: segment 	| clusterManager segmentorLocator |	clusterManager := self clusterManager.	segmentorLocator := clusterManager notNil 			ifTrue: [ segment frameLocator ]			ifFalse: [ segment ].	^ self at: #segments add: segmentorLocator beforeIndex: index</body><body package="COFramesystem">segmentsDo: block 	| clusterManager |	clusterManager := self clusterManager.	( self at: #segments ) do: 		[: segmentOrLocator | | segment |			segment := clusterManager getFrame: segmentOrLocator frameID inCluster: segmentOrLocator clusterID.			block value: segment		]</body><body package="COFramesystem">sizeAtIndex: index 	^ self at: #sizes atIndex: index</body><body package="COFramesystem">sizeAtIndex: index put: size 	^ self at: #sizes atIndex: index put: size</body><body package="COFramesystem">sizeBeforeIndex: index add: size 	^ self at: #sizes add: size beforeIndex: index</body></methods><methods><class-id>COAST.CoastSegmentedCollection</class-id> <category>private</category><body package="COFramesystem">buildSegmentWith: reference 	| segment index |	segment := self segmentClass newInVolume: self volume.	segment add: reference.	index := ( self sizeAt: #sizes ) + 1.	self segmentBeforeIndex: index add: segment.	self sizeBeforeIndex: index add: 1.	self lastReferenceBeforeIndex: index add: reference.</body><body package="COFramesystem">compareAtIndex: index key: key 	^ ( self lastKeyAtIndex: index ) coastCompareTo: key</body><body package="COFramesystem">comparetIndex: index key: key 	^ ( self lastKeyAtIndex: index ) coastCompareTo: key</body><body package="COFramesystem">lastReferencedElementAtIndex: index put: element 	self lastKeyAtIndex: index put: element</body><body package="COFramesystem">segmentClass	^ CoastCollectionSegment</body><body package="COFramesystem">segmentIndexForKey: key 	^ ( self at: #lastKeys ) coastMinIndexForInserting: key</body><body package="COFramesystem">segmentIndexForKey: key inclusive: inclusive 	| index |	index := self segmentIndexForKey: key.	inclusive ifFalse: [ ^ index ].	"if the key spans multiple segments, the last values might be found in the next segment, too"	( self sizeAt: #lastKeys ) &gt; index ifFalse: [ ^ index ].	"the last segment"	^ ( key coastLessThan: ( self at: #lastKeys atIndex: index )) 		ifTrue: [ index	"all values to the key are definitely included in this segment" ]		ifFalse: [ index + 1	"some values might be in the next segment" ]</body></methods><methods><class-id>COAST.CoastSegmentedCollection</class-id> <category>testing</category><body package="COFramesystem">includesKey: key 	| index |	key coastIsValidRPCArgument ifFalse: [ ^ false ].	index := self segmentIndexForKey: key.	^ index &lt;= self numberOfSegments and: [( self segmentAtIndex: index ) includesKey: key ]</body><body package="COFramesystem">isEmpty	^ self numberOfSegments = 0</body><body package="COFramesystem">isSegmentedCollection	^ true</body></methods><methods><class-id>COAST.CoastSegmentedCollection</class-id> <category>accessing</category><body package="COFramesystem">do: block 	self segmentsDo: [: segment | segment do: block ]</body><body package="COFramesystem">isSplitSize: size 	"	size &lt; 1024 ifTrue: [ ^ false ].	size &gt; 4096 ifTrue: [ ^ true ].	^ size &gt; (( self sizeAt: #sizes ) * 3 )."	^ size &gt; self clusterManager segmentSplitSize</body><body package="COFramesystem">keysDo: block 	self segmentsDo: [: segment | segment keysDo: block ]</body><body package="COFramesystem">segmentClusterIDs	^ (self at: #segments) collect: [ : ref | ref clusterID ]</body><body package="COFramesystem">segmentedCollectionHeader	| newInst |	newInst := SegmentedCollectionHeader new.	newInst lastKeys: ( self at: #lastKeys ) copy.	newInst clusterIDs: (( self at: #segments ) collect: [: frameLocator | frameLocator clusterID ]).	^ newInst</body><body package="COFramesystem">size	^ ( self at: #sizes ) inject: 0 into: [: sum : each | sum + each ]</body><body package="COFramesystem">split: oldLeaf atIndex: index 	| newLeaf lastReference |	newLeaf := self segmentClass newInVolume: self volume.	lastReference := oldLeaf moveSomeElementsTo: newLeaf.	self sizeAtIndex: index put: oldLeaf coastCompactElementCount.	self lastReferenceBeforeIndex: index add: lastReference.	self sizeBeforeIndex: index add: newLeaf coastCompactElementCount.	self segmentBeforeIndex: index add: newLeaf.</body></methods><methods><class-id>COAST.CoastSegmentedCollection</class-id> <category>journal</category><body package="COFramesystem">coastInternalMaxJournalSize: journalSize in: slot 	| journal journalCass |	journalSize = 0 ifTrue: [ ^ self ].	journal := self journal.	journal isNil ifTrue: 		[	journalCass := self journalClass.			journalCass isNil ifTrue: [ ^ self ].			journal := journalCass newInVolume: self volume.			"Es ist fÃ¼r den Mediator fatal, einen Cluster zu speichern, in dem eine Referenz auf einen Implementierungsframe (--&gt; ImplementationFrameClasses) steht (HS/HK)"			journal at: #segmentedCollection set: self frameLocator.			self at: #journal set: journal frameLocator		].	journal coastInternalMaxJournalSize: journalSize in: slot.	slot frame at: slot id set: journal.	^ journal</body><body package="COFramesystem">journal	| journal |	journal := self at: #journal.	^ ( journal isCoastFrame not and: [ journal isFrameOrFrameReference ]) 		ifTrue: [ journal realFrameFrom: self clusterManager ]		ifFalse: [ journal ]</body><body package="COFramesystem">journalClass	self subclassResponsibility.</body><body package="COFramesystem">journalSize	^ 0</body><body package="COFramesystem">maxJournalSize	^ 0</body></methods><methods><class-id>COAST.CoastSegmentedCollection</class-id> <category>enumerating</category><body package="COFramesystem">referencesElementsCursorDo: block 	self segmentsDo: [: segment | segment referencesElementsCursorDo: block ].</body></methods><methods><class-id>COAST.CoastSegmentedCollection class</class-id> <category>slots</category><body package="COFramesystem">journalSlot	^ self slotSingleValue</body><body package="COFramesystem">lastKeysSlot	^ self slotOfType: #orderedCollection</body><body package="COFramesystem">segmentsSlot	^ self slotOfType: #orderedCollection</body><body package="COFramesystem">sizesSlot	^ self slotOfType: #orderedCollection</body></methods><methods><class-id>COAST.CoastSegmentedCollection class</class-id> <category>testing</category><body package="COFramesystem">isFastRead	^ true</body><body package="COFramesystem">isPartOfIndexStructure	^true</body></methods><methods><class-id>COAST.MemoryBasedUnloadStrategy</class-id> <category>private</category><body package="COClusterManagement">bestNumberOfUnloadableClusters	| memUsage upperBound |	memUsage := self currentObjectMemory dynamicallyAllocatedFootprint.	upperBound := ( ObjectMemory currentMemoryPolicy growthRegimeUpperBound * self currentGRUBFactor ) floor.	^ memUsage &gt; upperBound 		ifTrue: [((( 1 - ( upperBound / memUsage )) * 2 min: 1 / 2 ) * self clusterManager clusterController size ) ceiling ]		ifFalse: [ self numberOfClustersToUnloadInBackground ]</body><body package="COClusterManagement">clusterControllerDo: block 	| cc basicSize startValue |	basicSize := manager clusterController basicSize.	ccIterateIndex := startValue := ( ccIterateIndex notNil and: [ ccIterateIndex &lt;= basicSize ]) 				ifTrue: [ ccIterateIndex ]				ifFalse: [ 1 ].	[	cc := manager clusterController coastBasicValueAt: ccIterateIndex.		cc notNil ifTrue: [ block value: cc ].		ccIterateIndex &lt; basicSize 			ifTrue: [ ccIterateIndex := ccIterateIndex + 1 ]			ifFalse: [ ccIterateIndex := 1 ].		ccIterateIndex == startValue	] whileFalse.</body><body package="COClusterManagement">currentGCState	currentObjectMemory := nil.	"reset"	^ Array with: self currentObjectMemory numIncGCs with: self currentObjectMemory numGlobalGCs with: self currentObjectMemory numGCs</body><body package="COClusterManagement">currentGRUBFactor	"wie viel des GrowthRegimeUpperBounds soll max. belegt werden, bevor Cluster ausgelagert werden"	^ 0.8</body><body package="COClusterManagement">currentObjectMemory	currentObjectMemory isNil ifTrue: [ currentObjectMemory := ObjectMemory current ].	^ currentObjectMemory</body><body package="COClusterManagement">filterClusterController: clusterController with: cutOff 	"die cc mit rank &gt; cutOff rauswerfen"	"den hÃ¶chsten rank zurÃ¼ckliefern"	| newMax |	newMax := 0.	clusterController copy do: 		[: cc | | rank |			rank := cc unloadStrategyInformation ifNil: [ 0 ].			rank &gt;= cutOff 				ifTrue: [ clusterController remove: cc ]				ifFalse: [ newMax := newMax max: rank ]		].	^ newMax</body><body package="COClusterManagement">forceUnloadAllPossible	^ forceUnloadAllPossible ifNil: [ false ]</body><body package="COClusterManagement">gcStateChanged	" any GC activity since the last time #updateGCState was sent?  "	| currentState |	currentState := self currentGCState."CoastLog log: 'Compare GC state: Last = ', lastGCState printString, ', current = ', currentState printString."	^ lastGCState ~= currentState</body><body package="COClusterManagement">numberOfClustersToUnloadInBackground	" try at least 5% "	^ 10 max: (self clusterManager numberOfClustersLoaded // 20)</body><body package="COClusterManagement">suggestedCCsForUnloadMax: maxOrNil maxRank: maxRank excludeClusterIDs: excludeClusterIDs allowRetry: allowRetry abortTime: abortTimeOrNil keepObserved: keepObserved 	| suggestedCCs worstCase hasCCsOutOfRank maxRankFound |	hasCCsOutOfRank := false.	maxRankFound := 0.	suggestedCCs := maxOrNil isNil 			ifTrue: [ OrderedCollection new ]			ifFalse: [ OrderedCollection new: maxOrNil ].	worstCase := 0.	"der zurzeit ungÃ¼nstigste Rank"	self clusterControllerDo: 		[: cc | | rank suggestClusterID |			( abortTimeOrNil notNil and: [ Time microsecondClock &gt; abortTimeOrNil ]) 				ifTrue: 				[	self logDebug: [ 'Timeout :(' ].					worstCase &gt; maxRank 						ifTrue: 						[	suggestedCCs := suggestedCCs select: [: ccFilter | ( ccFilter unloadStrategyInformation ifNil: [ maxRank ]) &lt; maxRank ]						].					^ suggestedCCs				].			(( self keepClusterIDs includes: cc clusterID ) not and: [( excludeClusterIDs includes: cc cluster id ) not ]) 				ifTrue: 				[	rank := cc unloadStrategyInformation ifNil: [ maxRank ].					suggestClusterID := maxOrNil isNil or: [ rank &lt; maxRank ].					maxRankFound := maxRankFound max: rank.					suggestClusterID 						ifFalse: [ hasCCsOutOfRank := true	"ggf spÃ¤ter runterranken" ].					( suggestClusterID not and: [ maxOrNil notNil ]) 						ifTrue: 						[	"suboptimale aufsammeln, um besser zu werden"							suggestClusterID := suggestedCCs size &lt; maxOrNil or: [ rank &lt; worstCase ]						].					suggestClusterID := suggestClusterID and: [ cc hasLog not and: [ keepObserved ifTrue: [ cc cluster hasObservers not] ifFalse: [ cc cluster hasNonWeakObservers not ]]].					suggestClusterID 						ifTrue: 						[	suggestedCCs add: cc.							maxOrNil notNil 								ifTrue: 								[	worstCase := suggestedCCs size &gt; maxOrNil 											ifTrue: [ self filterClusterController: suggestedCCs with: worstCase ]											ifFalse: [ worstCase max: rank ].									( suggestedCCs size &gt;= maxOrNil and: [ worstCase &lt;= rank ]) 										ifTrue: [ ^ suggestedCCs ]								]						]				]		].	^ ( allowRetry not or: [ hasCCsOutOfRank not or: [ suggestedCCs size &gt;= ( maxOrNil ifNil: [ 1 ])]]) 		ifTrue: 		[	" no need to restrict the number of suggested clusters  "			suggestedCCs		]		ifFalse: 		[	self logDebug: [ 'rank range [0..' , maxRankFound displayString , '] must rerank' ].			ccIterateIndex := 1.			self clusterControllerDo: 				[: cc | | rank |					rank := cc unloadStrategyInformation.					rank notNil 						ifTrue: 						[	cc cluster isIndexCluster 								ifTrue: [ cc unloadStrategyInformation: 4 * rank // 5 ]								ifFalse: [ cc unloadStrategyInformation: 3 * rank // 4 ]						]						ifFalse: [ cc unloadStrategyInformation: maxRank // 2 ]				].			( abortTimeOrNil notNil and: [ Time microsecondClock &gt; abortTimeOrNil ]) 				ifTrue: 				[	"retry once "					self suggestedCCsForUnloadMax: maxOrNil maxRank: 1 excludeClusterIDs: excludeClusterIDs allowRetry: false abortTime: abortTimeOrNil keepObserved: keepObserved				]				ifFalse: 				[	"timeout -&gt; no retry"					#( )				]		]</body><body package="COClusterManagement">suggestedClustersForUnloadMax: maxOrNil excludeClusterIDs: excludeClusterIDs abortTime: abortTime keepObserved: keepObserved 	| suggestedClustersForUnload delta |	delta := Time millisecondsToRun: 			[	suggestedClustersForUnload := self 						suggestedCCsForUnloadMax: maxOrNil						maxRank: 5						excludeClusterIDs: excludeClusterIDs						allowRetry: true						abortTime: abortTime						keepObserved: keepObserved			].	self logDebug: [ 'Unload CC scan needed ' , delta displayString , 'ms' ].	^ suggestedClustersForUnload collect: [: cc | cc clusterID ]</body><body package="COClusterManagement">updateGCState	" remember the current GC state, to detect GC activity "	lastGCState := self currentGCState.	unloadRecommended := false.</body></methods><methods><class-id>COAST.MemoryBasedUnloadStrategy</class-id> <category>logging</category><body package="COClusterManagement">logDebug: textBlock 	CoastLog logDebug: textBlock channel: #unloadStrategy.</body></methods><methods><class-id>COAST.MemoryBasedUnloadStrategy</class-id> <category>load / unload</category><body package="COClusterManagement">manyClustersToLoadDo: aBlock 	| oldForce |	oldForce := forceUnloadAllPossible.	^ [	forceUnloadAllPossible := true.		aBlock value	] ensure: [ forceUnloadAllPossible := oldForce ]</body><body package="COClusterManagement">notifyClusterAccess: clusterIDInteger 	"increase rank by one"	| clusterController accessValue |	clusterController := manager clusterController at: clusterIDInteger.	clusterController notNil ifTrue: 		[	accessValue := clusterController cluster isIndexCluster 					ifTrue: [ 100 ]					ifFalse: [ 1 ].			clusterController unloadStrategyInformation: ( clusterController unloadStrategyInformation ifNil: [ 0 ]) + accessValue		].</body><body package="COClusterManagement">notifyClusterLoad: clusterID 	"compatibility"	"rough bookkeeping of cluster sizes"	| cluster |	cluster := ( manager clusterController at: clusterID ifAbsent: nil ) ifNotNil: [: cc | cc cluster ].	cluster notNil ifTrue: 		[	self notifyLoadCluster: cluster		].</body><body package="COClusterManagement">notifyLoadCluster: cluster 	cluster isIndexCluster 		ifTrue: [ approxTotalIndexClusterSize := approxTotalIndexClusterSize + cluster approxByteSize ]		ifFalse: [ approxTotalClusterSize := approxTotalClusterSize + cluster approxByteSize ].</body><body package="COClusterManagement">notifyUnloadCluster: cluster 	"rough bookkeeping of cluster sizes"	cluster isIndexCluster 		ifTrue: [ approxTotalIndexClusterSize := approxTotalIndexClusterSize - cluster approxByteSize ]		ifFalse: [ approxTotalClusterSize := approxTotalClusterSize - cluster approxByteSize ].</body></methods><methods><class-id>COAST.MemoryBasedUnloadStrategy</class-id> <category>testing</category><body package="COClusterManagement">clusterUnloadNeeded	| unloadNeeded |	unloadNeeded := self unloadRecommended.	unloadNeeded ifTrue: [ self logDebug: [ 'clusterUnloadNeeded' ]].	^ unloadNeeded</body><body package="COClusterManagement">needsLowSpaceHandler	^ true</body><body package="COClusterManagement">unloadRecommended	" if unload is recommend, continue recommending it until clusters are unloaded "	unloadRecommended 		ifFalse: 		[	unloadRecommended := self gcStateChanged 					ifTrue: 					[	self currentObjectMemory dynamicallyAllocatedFootprint &gt; ( ObjectMemory currentMemoryPolicy growthRegimeUpperBound * self currentGRUBFactor )					]					ifFalse: [ "abwarten, dass Speicher freigegeben wird"  false ]		].	^ unloadRecommended</body></methods><methods><class-id>COAST.MemoryBasedUnloadStrategy</class-id> <category>initialize-release</category><body package="COClusterManagement">initialize	approxTotalClusterSize := 0.	approxTotalIndexClusterSize := 0.	self updateGCState.</body></methods><methods><class-id>COAST.MemoryBasedUnloadStrategy</class-id> <category>accessing</category><body package="COClusterManagement">clusterUnloadFinished: didUnload 	super clusterUnloadFinished: didUnload.	didUnload  ifTrue:[ self updateGCState ].</body><body package="COClusterManagement">gcState	| com |	com := ObjectMemory current.	^ Array with: com numIncGCs with: com numGlobalGCs with: com numGCs</body><body package="COClusterManagement">unloadableClustersWithout: clusterIDsToKeep background: background ignoreRestrictions: ignoreRestrictions 	| max abortTime unloadable |	background 		ifTrue: 		[	self clusterUnloadNeeded 				ifFalse: [ ^ #( )].			abortTime := Time microsecondClock + ( 1000 * 50 ).			max := self numberOfClustersToUnloadInBackground		]		ifFalse: 		[( ignoreRestrictions or: [ self forceUnloadAllPossible ]) 				ifTrue: 				[	abortTime := nil.					max := nil				]				ifFalse: 				[	abortTime := Time microsecondClock + ( 1000 * 15000 ).					max := self bestNumberOfUnloadableClusters				]		].	unloadable := self suggestedClustersForUnloadMax: max excludeClusterIDs: clusterIDsToKeep abortTime: abortTime keepObserved: background.	self logDebug: 		[	'Unloadable clusters: ' , unloadable size printString , ', loaded: ' , self clusterManager numberOfClustersLoaded printString , ', keep: ' 				, clusterIDsToKeep size printString , ', background: ' 				, background printString , ', ignore restrictions: ' 				, ignoreRestrictions printString , ', force: ' 				, self forceUnloadAllPossible printString		].	^ unloadable</body></methods><methods><class-id>COAST.MemoryBasedUnloadStrategy class</class-id> <category>constants</category><body package="COClusterManagement">strategyShortName	^ 'MEM'</body></methods><methods><class-id>COAST.CoastIndexSegment</class-id> <category>accessing</category><body package="COFramesystem">add: assoc 	^ self atKey: assoc key add: assoc value</body><body package="COFramesystem">associationsDo: block 	( self at: #compactCollection ) associationsDo: block</body><body package="COFramesystem">atIndex: elementIndex 	^ self at: #compactCollection atIndex: elementIndex</body><body package="COFramesystem">atKey: key 	^ self at: #compactCollection atKey: key</body><body package="COFramesystem">atKey: key add: value 	^ self at: #compactCollection atKey: key add: value</body><body package="COFramesystem">atKey: key includes: value 	^ self at: #compactCollection atKey: key includes: value</body><body package="COFramesystem">atKey: key remove: value 	^ self atKey: key remove: value ifAbsent: nil</body><body package="COFramesystem">atKey: key remove: value ifAbsent: absentBlock 	^ ( self at: #compactCollection atKey: key remove: value ) notNil 		ifTrue: [ value ]		ifFalse: [ absentBlock value ]</body><body package="COFramesystem">fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive	^ inclusive		ifTrue: [ self at: #compactCollection fromKey: startKeyOrNil toKey: stopKeyOrNil ]		ifFalse: [ self at: #compactCollection exclusiveFromKey: startKeyOrNil toKey: stopKeyOrNil ]</body><body package="COFramesystem">includesKey: key 	^ self at: #compactCollection includesKey: key</body><body package="COFramesystem">indexOf: assoc 	^ self at: #compactCollection indexOf: assoc</body><body package="COFramesystem">insertionIndexOf: assoc 	^ ( self at: #compactCollection ) insertionIndexOf: assoc</body><body package="COFramesystem">keysAndValuesDo: block 	( self at: #compactCollection ) keysAndValuesDo: block</body><body package="COFramesystem">keysDo: block 	^ ( self at: #compactCollection ) keysDo: block</body></methods><methods><class-id>COAST.CoastIndexSegment</class-id> <category>private</category><body package="COFramesystem">fillKeysToMove: keysToMove valuesToMove: valuesToMove max: max 	| done |	done := 0.	self keysAndValuesDo: 		[: key : value |			keysToMove add: key.			valuesToMove add: value.			done := done + 1.			done &gt;= max ifTrue: [ ^ self ]		].</body><body package="COFramesystem">moveSomeElementsTo: newLeaf max: max 	| keysToMove valuesToMove |	keysToMove := OrderedCollection new: max.	valuesToMove := OrderedCollection new: max.	self fillKeysToMove: keysToMove valuesToMove: valuesToMove max: max.	keysToMove with: valuesToMove		do: 		[: key : value |			newLeaf atKey: key add: value.			self atKey: key remove: value		].	^ keysToMove last -&gt; valuesToMove last</body></methods><methods><class-id>COAST.CoastIndexSegment class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #compactIndex</body></methods><methods><class-id>COAST.RemoteFrameClassIndex</class-id> <category>accessing</category><body package="COClusterManagement">clusterManager: aClusterManager 	clusterManager := aClusterManager.	super clusterManager: aClusterManager.</body><body package="COClusterManagement">frameSlotIndexForIndex: anInteger 	^ ( anInteger &gt; frameClassTable size or: [( frameClassTable at: anInteger ) isNil ]) 		ifTrue: [ self refreshFrameIndexAt: anInteger ]		ifFalse: [ super frameSlotIndexForIndex: anInteger ]</body></methods><methods><class-id>COAST.RemoteFrameClassIndex</class-id> <category>private</category><body package="COClusterManagement">refreshFrameIndexAt: frameClassIndex 	| fsi  |	fsi := CoastMediatorStub sendTo: clusterManager host		requestID: CoastConstant getFrameClassIndex		andStrings: ( Array with: clusterManager volume )		sendStreamDo: [: sendStream | sendStream nextOptimized32Put: frameClassIndex ]		receiveStreamDo: 		[: receiveStream |			| newFsi |			newFsi := CatCSFrameSlotIndex unmarshallBinaryFrom: receiveStream					classNameManager: clusterManager classNameManager					frameClassIndex: self.			self frameSlotIndexForIndex: frameClassIndex put: newFsi		].	CoastLog logDebugNotify: 'frame class index for ' , fsi frameClassName , ' reloaded'.	^ fsi</body></methods><methods><class-id>COAST.CatFSCoastNameDemon</class-id> <category>initialize-release</category><body package="COFramesystem">initialize	super initialize.	self write: true.	self preJob: [: demon : cellAccess : cell | cellAccess keepDifferences ].	self postJob: 		[: demon : slotAccess : cell | | diff |			diff := slotAccess differences.			cell frame nameChangedFrom: diff removed anyElement to: diff added anyElement		].	self name: #coastNameDemon.</body></methods><methods><class-id>COAST.UpdatingFrameClassIndex</class-id> <category>accessing</category><body package="COClusterManagement">doNotUpdateWhile: aBlock	doNotUpdateNow := true.	aBlock ensure: [ doNotUpdateNow := false ].</body><body package="COClusterManagement">frameSlotIndexForSymbol: aSymbolOrClass 	| fsi |	fsi := self basicFrameSlotIndexForSymbol: aSymbolOrClass.	^ fsi notNil 		ifTrue: [ fsi ]		ifFalse: 		[	lock critical: 				[	fsi := self basicFrameSlotIndexForSymbol: aSymbolOrClass.					fsi notNil 						ifTrue: 						[	" concurrent access , the other process was fastrer "							fsi						]						ifFalse: [ self absentFrameSlotIndexForSymbol: aSymbolOrClass ]				]		]</body><body package="COClusterManagement">missingSlot: slotName for: frameSlotIndex 	self notifyUpdate.	^ frameSlotIndex addIndexForSlot: slotName</body><body package="COClusterManagement">notifyUpdate	"extra checking - can be removed later"	doNotUpdateNow == true ifTrue: [self error: 'frame class index updates not allowed here'].	hasUpdates ifFalse: [ CoastLog log: 'frame class index extended' ].	hasUpdates := true.</body></methods><methods><class-id>COAST.UpdatingFrameClassIndex</class-id> <category>private</category><body package="COClusterManagement">absentFrameSlotIndexForSymbol: aSymbolOrClass 	| frameClassSymbol fsi |	frameClassSymbol := aSymbolOrClass frameClassSymbol.	frameClassSymbol == aSymbolOrClass ifFalse: 		[	fsi := self basicFrameSlotIndexForSymbol: frameClassSymbol.			fsi notNil ifTrue: 				[	self frameClassAt: aSymbolOrClass put: fsi.					^ fsi				]		].	fsi := self newFrameSlotIndexFor: frameClassSymbol classNameManager: classNameManager.	^ fsi hasNameSpace 		ifTrue: 		[	namespaceDict at: ( fsi frameClassSymbol tokensBasedOn: $. ) last put: frameClassSymbol.			self notifyUpdate.			frameClassTable := frameClassTable copyWith: fsi.			fsi key: frameClassTable size.			aSymbolOrClass == frameClassSymbol ifFalse: [ self frameClassAt: aSymbolOrClass put: fsi ].			self frameClassAt: frameClassSymbol put: fsi.			fsi		]		ifFalse: 		[	CoastLog logWarning: 'No namespace for: ' , fsi frameClassSymbol , ', could not expand class index'.			nil		]</body><body package="COClusterManagement">basicFrameSlotIndexForSymbol: aSymbolOrClass	^ frameClassDict at: aSymbolOrClass ifAbsent: [ nil ]</body></methods><methods><class-id>COAST.UpdatingFrameClassIndex</class-id> <category>initialize</category><body package="COClusterManagement">initialize	super initialize.	lock := Semaphore forMutualExclusion.</body></methods><methods><class-id>COAST.CoastAbstractSetSegment</class-id> <category>private</category><body package="COFramesystem">keysToMoveMax: max 	| done keysToMove |	keysToMove := OrderedCollection new: max.	done := 0.	self do: 		[: key |			keysToMove add: key.			done := done + 1.			done &gt;= max ifTrue: [ ^ keysToMove ]		].</body><body package="COFramesystem">moveSomeElementsTo: newLeaf max: max 	| keysToMove |	keysToMove := self keysToMoveMax: max.	keysToMove do: 		[: key |			newLeaf add: key.			self remove: key		].	^ keysToMove last</body></methods><methods><class-id>COAST.CoastAbstractSetSegment</class-id> <category>accessing</category><body package="COFramesystem">add: value 	^ self at: #compactCollection add: value</body><body package="COFramesystem">includes: value 	^ self at: #compactCollection includes: value</body><body package="COFramesystem">remove: value 	^ self at: #compactCollection remove: value</body></methods><methods><class-id>COAST.UnpreparedStreamableCluster</class-id> <category>streaming</category><body package="COClusterManagement">saveClusterOn: writeStream	clusterController saveClusterOn: writeStream marshaller: marshaller</body></methods><methods><class-id>COAST.UnpreparedStreamableCluster</class-id> <category>accessing</category><body package="COClusterManagement">approxByteSize	^clusterController approxByteSize</body><body package="COClusterManagement">clusterController: aClusterController marshaller: aMarshaller	clusterController := aClusterController.	marshaller := aMarshaller.	"prepare/update index-ini now"	aClusterController ensureUpdatedFrameSlotIndexWith: aMarshaller.</body><body package="COClusterManagement">clusterID	^clusterController clusterID</body></methods><methods><class-id>COAST.CatFSWeakCachingSlot</class-id> <category>accessing cache</category><body package="COFramesystem">initializeForBlockCache: aBlockCache arguments: blockArguments	super initializeForBlockCache: aBlockCache arguments: blockArguments.	blockCache := aBlockCache.	arguments := blockArguments.</body></methods><methods><class-id>COAST.CatFSWeakCachingSlot</class-id> <category>testing</category><body package="COFramesystem">isWeakObserver	^ true</body></methods><methods><class-id>COAST.CatFSWeakCachingSlot</class-id> <category>observer - subject</category><body package="COFramesystem">coastInvalidateDisresolved	" remove the cache "	self invalidateObserversDisresolved.	self flushSubjects.	blockCache isNil ifFalse: [ blockCache removeCacheFor: arguments ].	blockCache := nil.	arguments := nil</body></methods><methods><class-id>COAST.CoastDictionarySegment</class-id> <category>accessing</category><body package="COFramesystem">add: assoc 	^ self atKey: assoc key put: assoc value</body><body package="COFramesystem">atKey: key 	^ self at: #compactCollection atKey: key</body><body package="COFramesystem">atKey: key ifAbsent: absentBlock 	| result |	result := self atKey: key.	result isNil ifTrue: [ absentBlock value ].	^ result</body><body package="COFramesystem">atKey: key put: value 	^ self at: #compactCollection atKey: key put: value</body><body package="COFramesystem">includesKey: key 	^ self at: #compactCollection includesKey: key</body><body package="COFramesystem">keysDo: block 	^ ( self at: #compactCollection ) keysDo: block</body><body package="COFramesystem">removeKey: key 	^ self removeKey: key ifAbsent: nil</body><body package="COFramesystem">removeKey: key ifAbsent: absentBlock 	| value |	value := self atKey: key.	value isNil ifTrue: [ ^ absentBlock value ].	self at: #compactCollection removeKey: key.	^ value</body></methods><methods><class-id>COAST.CoastDictionarySegment</class-id> <category>enumerating</category><body package="COFramesystem">associationsDo: block 	(self at: #compactCollection) associationsDo: block</body><body package="COFramesystem">keysAndValuesDo: block 	( self at: #compactCollection ) keysAndValuesDo: block</body></methods><methods><class-id>COAST.CoastDictionarySegment</class-id> <category>compatibility</category><body package="COFramesystem">compactElementAtIndex: index	^ (self at: #compactCollection) compactElementAtIndex: index</body></methods><methods><class-id>COAST.CoastDictionarySegment</class-id> <category>private</category><body package="COFramesystem">fillKeysToMove: keysToMove valuesToMove: valuesToMove max: max 	| done |	done := 0.	self keysAndValuesDo: 		[: key : value |			keysToMove add: key.			valuesToMove add: value.			done := done + 1.			done &gt;= max ifTrue: [ ^ self ]		].</body><body package="COFramesystem">moveSomeElementsTo: newLeaf max: max 	| keysToMove valuesToMove |	keysToMove := OrderedCollection new: max.	valuesToMove := OrderedCollection new: max.	self fillKeysToMove: keysToMove valuesToMove: valuesToMove max: max.	keysToMove with: valuesToMove		do: 		[: key : value |			newLeaf atKey: key put: value.			self removeKey: key		].	^ keysToMove last -&gt; valuesToMove last</body></methods><methods><class-id>COAST.CoastDictionarySegment class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #compactDictionary</body></methods><methods><class-id>COAST.LocalVolumeStorageInterface</class-id> <category>accessing</category><body package="COClusterManagement">checkVolume: volume clusterManager: clusterManagerOrNil 	^volumeAccessor checkVolume: volume clusterManager: clusterManagerOrNil</body><body package="COClusterManagement">newClusterStorageAccessorFor: aClusterManager 	| csa lsi |	csa := volumeAccessor newClusterStorageAccessorFor: aClusterManager.	lsi := LocalStorageInterface onAccessor: csa.	lsi clusterManager: aClusterManager.	^ lsi</body><body package="COClusterManagement">replaceVolume: volume with: replacementVolume 	^volumeAccessor replaceVolume: volume with: replacementVolume</body><body package="COClusterManagement">sizeOfBlobOrCluster: clusterID in: volume 	^volumeAccessor sizeOfBlobOrCluster: clusterID in: volume</body><body package="COClusterManagement">storedVolumes	^volumeAccessor storedVolumes</body></methods><methods><class-id>COAST.LocalVolumeStorageInterface</class-id> <category>admin</category><body package="COClusterManagement">deleteBackup: oldVolume version: version	^volumeAccessor deleteBackup: oldVolume version: version</body><body package="COClusterManagement">deleteVolume: volume	^volumeAccessor deleteVolume: volume</body><body package="COClusterManagement">quickRecoverVolume: volumeName	volumeAccessor quickRecoverVolume: volumeName</body><body package="COClusterManagement">recoverVolume: oldVolume version: version to: recoverVolume	^volumeAccessor recoverVolume: oldVolume version: version to: recoverVolume</body><body package="COClusterManagement">recoverableVolumes	^volumeAccessor recoverableVolumes</body><body package="COClusterManagement">shutDown	^volumeAccessor shutDown</body></methods><methods><class-id>COAST.LocalVolumeStorageInterface</class-id> <category>auto repair</category><body package="COClusterManagement">checkVolumes	volumeAccessor checkVolumes</body><body package="COClusterManagement">recoverVolume: targetVolume	volumeAccessor recoverVolume: targetVolume</body></methods><methods><class-id>COAST.LocalVolumeStorageInterface</class-id> <category>testing</category><body package="COClusterManagement">volumeExists: targetVolume	^volumeAccessor volumeExists: targetVolume</body></methods><methods><class-id>COAST.LocalVolumeStorageInterface</class-id> <category>accessing private</category><body package="COClusterManagement">volumeAccessor: aVolumeAccessor 	volumeAccessor := aVolumeAccessor.</body></methods><methods><class-id>COAST.LocalVolumeStorageInterface</class-id> <category>initialize-release</category><body package="COClusterManagement">configuration: aCOASTCoastInteractiveClientConfiguation 	volumeAccessor configuration: aCOASTCoastInteractiveClientConfiguation</body></methods><methods><class-id>COAST.LocalVolumeStorageInterface class</class-id> <category>instance creation</category><body package="COClusterManagement">onAccessorClass: accessorClass 	^ ( self new ) volumeAccessor: accessorClass new;		yourself</body></methods><methods><class-id>COAST.CoastBinaryContainer</class-id> <category>accessing</category><body package="COFramesystem">bytes	^self isStoredInternal 		ifTrue: [self rawBytes]		ifFalse: [self bytesFromExtFile]</body><body package="COFramesystem">bytes: newByteArray 	self isStoredInternal 		ifTrue: [self rawBytes: newByteArray]		ifFalse: [self bytesToExtFile: newByteArray clusterManager: self clusterManager ].	self at: #size set: newByteArray size</body><body package="COFramesystem">fileID	^self at: #fileID</body><body package="COFramesystem">fileID: aClusterID	^self at: #fileID set: aClusterID</body></methods><methods><class-id>COAST.CoastBinaryContainer</class-id> <category>private-transfer</category><body package="COFramesystem">bytesFromExtFile	| fileID |	^(fileID := self at: #fileID) notNil		ifTrue: [self desperateLookForClusterManager loadFromID: fileID toLocalFile: ''.]		ifFalse: [ByteArray new]</body><body package="COFramesystem">bytesToExtFile: aByteArray	^ self bytesToExtFile: aByteArray clusterManager: nil</body><body package="COFramesystem">bytesToExtFile: aByteArray clusterManager: aClusterManagerOrNil	| newID |	newID := (aClusterManagerOrNil ifNil:[ self desperateLookForClusterManager ]) storeBytes: aByteArray.	self at: #fileID set: newID.	^self.</body><body package="COFramesystem">downloadBytesToFile: aFilename 	| aStream |	aStream := aFilename writeStream.	[		aStream binary.		aStream nextPutAll: self bytes.	] ensure: [ 		aStream close	]</body><body package="COFramesystem">downloadExtFileToFile: aFilename	self desperateLookForClusterManager loadFromID: (self at: #fileID) toLocalFile: aFilename.</body><body package="COFramesystem">uploadBytesFromFile: aFilename 	| newBytes aStream size |	aStream := aFilename readStream.	size := aFilename fileSize.	newBytes := ByteArray new: size.	aStream binary.	(1 to: size) do: [:i | newBytes at: i put: aStream next].	aStream close.	self rawBytes: newBytes</body><body package="COFramesystem">uploadExtFileFromFile: aFilename clusterManager: aClusterManager	| newID |	newID := (aClusterManager ifNil:[ self desperateLookForClusterManager ]) storeFile: aFilename.	self at: #fileID set: newID.	^self</body></methods><methods><class-id>COAST.CoastBinaryContainer</class-id> <category>private-accessing</category><body package="COFramesystem">desperateLookForClusterManager	^self clusterManager ifNil: 			[self transactionManager activeTransaction combinedAgenda involvedClusters 				anyElement clusterManager]</body><body package="COFramesystem">rawBytes	^self at: #bytes</body><body package="COFramesystem">rawBytes: newBytes	self at: #bytes set: newBytes</body></methods><methods><class-id>COAST.CoastBinaryContainer</class-id> <category>transfer</category><body package="COFramesystem">downloadToFile: aFilename 	(self at: #bytes) notNil		ifTrue: [^self downloadBytesToFile: aFilename].	(self at: #fileID) notNil		ifTrue: [^self downloadExtFileToFile: aFilename].	"damage case: create empty file"	aFilename writeStream close</body><body package="COFramesystem">uploadFromFile: aFilename clusterManager: aClusterManager filename: filenameString 	self filename: filenameString.	self at: #size set: aFilename fileSize.	self isStoredInternal 		ifTrue: [ self uploadBytesFromFile: aFilename ]		ifFalse: [ self uploadExtFileFromFile: aFilename clusterManager: aClusterManager ].</body></methods><methods><class-id>COAST.CoastBinaryContainer</class-id> <category>storage mode</category><body package="COFramesystem">externalStorage	self bytesToExtFile: self bytes.	self at: #bytes set: nil</body><body package="COFramesystem">internalStorage	self at: #bytes set: self bytes.	self at: #fileID set: nil</body><body package="COFramesystem">isStoredInternal	^(self at: #bytes) notNil</body></methods><methods><class-id>COAST.CoastBinaryContainer</class-id> <category>garbage collect</category><body package="COFramesystem">referencedFile	" fees gaefoommel for the garbage collector"	| fileIDHolder fileID |	fileIDHolder := self resolvedCellValue detect: [:e | e id = #fileID]				ifNone: [nil].	fileID := fileIDHolder isNil 				ifTrue: [nil]				ifFalse: [fileIDHolder resolvedCellValue].	^ fileID</body></methods><methods><class-id>COAST.CoastBinaryContainer class</class-id> <category>slot description</category><body package="COFramesystem">bytesSlot	^(self slotSingleValue) range: ByteArray; yourself</body><body package="COFramesystem">fileIDSlot	^(self slotSingleValue)		range: Integer;		yourself</body></methods><methods><class-id>COAST.CoastBinaryContainer class</class-id> <category>initialize-release</category><body package="COFramesystem">newExternalStorage	^self new</body><body package="COFramesystem">newInternalStorage	^(self new)		internalStorage;		yourself</body></methods><methods><class-id>COAST.CoastBinaryContainer class</class-id> <category>instance creation</category><body package="COFramesystem">newLocal	^(super newLocal)		at: #bytes set: #[];		yourself</body></methods><methods><class-id>COAST.CatCSSingleController</class-id> <category>local transactions</category><body package="COTransactions">recordLastWishTransaction: aTransaction	"a last wish transaction has to be directly forwarded to the mediator"	"in comparison to regular transactions avoid all the bookkeeping and make that thingy as invisible as possible"	"ATTENTION: this is for transactions that touch only one cluster"	| newEntry newTID newLoggedAgenda |	newTID  := CatRMTransactionID new.	newTID localSeqNum: 0.	newTID clientID: 0.	newTID clusterLocator: (CatCSClusterLocator id: self clusterStub id volume: self clusterManager volume).	newTID basedOnGlobal: 0.	newTID basedOnLocal: 0.	newEntry := CatRMLoggedTransaction new.	newEntry transaction: aTransaction.	newEntry transactionID: newTID.	newLoggedAgenda := CatRMLoggedTransactionAgenda new.	newLoggedAgenda transactionID: newTID.	newLoggedAgenda agenda: (aTransaction combinedAgenda simpleAgendaForCluster: self cluster).	self clusterManager addLastWish: newLoggedAgenda</body><body package="COClusterManagement">recordLocalTransaction: aCatCSTransaction 	cluster incrementModificationNumber.	self modified: true.	^ #accepted</body><body package="COClusterManagement">recordOptimisticTransaction: aCatCSTransaction 	" optimistic transaction, local mode "	| result |	result := self recordLocalTransaction: aCatCSTransaction.	self clusterManager addToApplicationLog: aCatCSTransaction applicationLog.	aCatCSTransaction flushApplicationLog.	^ result</body></methods><methods><class-id>COAST.CatCSSingleController</class-id> <category>release</category><body package="COClusterManagement">releaseClusterAndNotifyMediator: doNotify	modified ifTrue: [ self clusterManager saveAllModifiedClusters ].	super releaseClusterAndNotifyMediator: doNotify.</body></methods><methods><class-id>COAST.CatCSSingleController</class-id> <category>accessing</category><body package="COClusterManagement">globalSeqNum	"diese Methode wird zurzeit nur fÃ¼r Inspectoren benÃ¶tigt"	^ self cluster modificationNumber</body><body package="COTransactions">rollForwardDebugString	| stream |	stream := String new writeStream.	stream nextPutAll: 'Client '.	self clientID printOn: stream.	stream nextPutAll: ' Roll forward cluster '.	self clusterID printOn: stream.	^ stream contents</body><body package="COClusterManagement">unloadStrategyInformation	^ unloadStrategyInformation</body><body package="COClusterManagement">unloadStrategyInformation: aUnloadStrategyInformation 	unloadStrategyInformation := aUnloadStrategyInformation.</body></methods><methods><class-id>COAST.CoastJournalIndex</class-id> <category>accessing</category><body package="COFramesystem">atIndex: elementIndex 	"very complicated"	| segmentedCollection indices offset array |	segmentedCollection := self segmentedCollection.	array := self cleanJournalDiffs.	indices := self removedIndicesUpTo: elementIndex in: ( array at: 2 ).	offset := 0.	( array at: 1 ) associationsDo: 		[: assoc | | hit |			hit := segmentedCollection insertionIndexOf: assoc.			[ indices notEmpty and: [ indices first &lt; hit ]] whileTrue: 				[	indices removeFirst.					offset := offset - 1				].			hit + offset = elementIndex ifTrue: [ ^ assoc ].			hit + offset &lt; elementIndex 				ifTrue: [ offset := offset + 1 ]				ifFalse: 				[						[ indices notEmpty and: [ indices first &lt;= ( elementIndex - offset )]] whileTrue: 						[	indices removeFirst.							offset := offset - 1						].					^ segmentedCollection atIndex: elementIndex - offset				]		].	[ indices notEmpty and: [ indices first &lt;= ( elementIndex - offset )]] whileTrue: 		[	indices removeFirst.			offset := offset - 1		].	^ segmentedCollection atIndex: elementIndex - offset</body><body package="COFramesystem">atKey: key 	| result1 result2 toRemove |	result1 := self at: #added atKey: key.	result2 := self segmentedCollection atKey: key.	result2 isEmpty ifTrue: 		[	^ result1 isNil 				ifTrue: [ result1 := #( )]				ifFalse: [ result1 ]		].	toRemove := self at: #removed atKey: key.	toRemove notNil ifTrue: [ toRemove do: [: removed | result2 remove: removed ifAbsent: ["schade, dirty remove"] ]].	result1 isNil ifTrue: [ ^ result2 ].	^ result1 size &lt; result2 size 		ifTrue: 		[	result2 addAll: result1.			result2		]		ifFalse: 		[	result1 addAll: result2.			result1		]</body><body package="COFramesystem">atKey: key add: value 	| segmentedCollection |	segmentedCollection := self segmentedCollection.	self at: #removed atKey: key remove: value.	( segmentedCollection suppressJournalForKey: key value: value ) 		ifTrue: 		[	self at: #added atKey: key remove: value.			segmentedCollection atKey: key add: value		]		ifFalse: 		[	self at: #added atKey: key add: value.			self checkJournal		].	^ value</body><body package="COFramesystem">atKey: key includes: value 	( key coastIsValidRPCArgument and: [ value coastIsValidRPCArgument ]) ifFalse: [ ^ false ].	( self at: #removed atKey: key includes: value ) ifTrue: [ ^ false ].	( self at: #added atKey: key includes: value ) ifTrue: [ ^ true ].	^ self segmentedCollection atKey: key includes: value</body><body package="COFramesystem">atKey: key remove: value 	^ self atKey: key remove: value ifAbsent: nil</body><body package="COFramesystem">atKey: key remove: value ifAbsent: absentBlock 	| segmentedCollection |	segmentedCollection := self segmentedCollection.	( segmentedCollection suppressJournalForKey: key value: value ) ifTrue: 		[ | probe |			probe := self at: #added atKey: key remove: value.			probe notNil ifTrue: 				[	segmentedCollection atKey: key remove: value ifAbsent: nil.					^ value				].			probe := self at: #removed atKey: key remove: value.			probe notNil ifTrue: 				[	segmentedCollection atKey: key remove: value ifAbsent: nil.					^ absentBlock value				].			^ segmentedCollection atKey: key remove: value ifAbsent: absentBlock		].	absentBlock isNil ifTrue: 		[	self at: #added atKey: key remove: value.			self at: #removed atKey: key add: value.			self checkJournal.			^ value		].	( self at: #removed atKey: key includes: value ) ifTrue: [ ^ absentBlock value ].	( self at: #added atKey: key remove: value ) notNil ifTrue: [ ^ self at: #removed atKey: key add: value ].	( self segmentedCollection atKey: key includes: value ) ifFalse: [ ^ absentBlock value ].	self at: #removed atKey: key add: value.	self checkJournal.	^ value</body><body package="COFramesystem">atKeys: someKeys 	| result |	result := self segmentedCollection atKeys: someKeys.	( self at: #added atKeys: someKeys ) keysAndValuesDo: [: k : v | result atKey: k add: v ].	( self at: #removed atKeys: someKeys ) keysAndValuesDo: [: k : v | result atKey: k remove: v ifAbsent: nil ].	^ result</body><body package="COFramesystem">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COFramesystem">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues 	^ self atKeys: someKeys restrictToValues: rvalues</body><body package="COFramesystem">atKeys: someKeys restrictToValues: rvalues 	| result |	result := self segmentedCollection atKeys: someKeys restrictToValues: rvalues.	(( self at: #added ) atKeys: someKeys ) keysAndValuesDo: [: k : v | ( rvalues includes: v ) ifTrue: [ result atKey: k add: v ]].	( self at: #removed atKeys: someKeys ) keysAndValuesDo: [: k : v | result atKey: k remove: v ifAbsent: nil ].	^ result</body><body package="COFramesystem">eachKeyIn: someKeys do: eachKeyBlock 	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index. "	" default fallback implementation "	(self atKeys: someKeys) keysDo: eachKeyBlock</body><body package="COFramesystem">fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	| result |	result := self segmentedCollection fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive.	(( self at: #removed ) fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive ) do: [: v | result remove: v ifAbsent: nil ].	result addAll: (( self at: #added ) fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive ).	^ result</body><body package="COFramesystem">indexOf: assoc 	^ self indexOf: assoc ifAbsent: nil</body><body package="COFramesystem">indexOf: assoc ifAbsent: block 	^ ( self atKey: assoc key includes: assoc value ) 		ifTrue: [ self insertionIndexOf: assoc ]		ifFalse: [ block value ]</body><body package="COFramesystem">insertionIndexOf: assoc 	| index array |	array := self cleanJournalDiffs.	index := self segmentedCollection insertionIndexOf: assoc.	index := index + (( array at: 1 ) insertionIndexOf: assoc ).	index := index - (( array at: 2 ) insertionIndexOf: assoc ).	^ index</body><body package="COFramesystem">keys	| keys |	keys := OrderedCollection new: self size.	self keysDo: [: elem | keys add: elem ].	^ keys</body><body package="COFramesystem">lastValuesClusterIDs	^ self segmentedCollection lastValuesClusterIDs</body><body package="COFramesystem">removedIndicesUpTo: elementIndex in: removed 	| segmentedCollection indices |	segmentedCollection := self segmentedCollection.	indices := OrderedCollection new.	removed associationsDo: 		[: assoc | | index |			index := segmentedCollection insertionIndexOf: assoc.			index &lt;= elementIndex 				ifTrue: [ indices add: index ]				ifFalse: [ ^ indices ]		].	^ indices</body><body package="COFramesystem">rpcAtIndex: index 	| assoc |	assoc := self atIndex: index.	^ Array with: assoc key with: assoc value</body><body package="COFramesystem">rpcIndexOfKey: key value: value 	| dummy |	dummy := ( self segmentedCollection rpcIndexOfKey: key value: value ) ifNil: [ 1 ].	dummy := dummy + (( self at: #added ) indexForKey: key value: value ).	^ dummy - (( self at: #removed ) indexForKey: key value: value )</body><body package="COFramesystem">rpcSelectKeys: someKeys whichInclude: aValue 	^ someKeys collect: [: key | self atKey: key includes: aValue ]</body><body package="COFramesystem">selectKeys: someKeys whichInclude: aValue 	^ someKeys select: [: key | self atKey: key includes: aValue ]</body></methods><methods><class-id>COAST.CoastJournalIndex</class-id> <category>private</category><body package="COFramesystem">cleanJournalDiffs	"remove added already included	remove removed not included yet"	| added removed result |	added := self at: #added.	removed := self at: #removed.	result := Array with: added copy with: removed copy.	added keysAndValuesDo: [: k : v | ( self segmentedCollection atKey: k includes: v ) ifTrue: [( result at: 1 ) atKey: k remove: v ]].	removed keysAndValuesDo: [: k : v | ( self segmentedCollection atKey: k includes: v ) ifFalse: [( result at: 2 ) atKey: k remove: v ]].	^ result</body><body package="COFramesystem">diffsBySegmentClusterID: segmentedCollection 	| segh temp |	segh := segmentedCollection segmentedCollectionHeader.	segh numberOfSegments = 0 ifTrue: [ ^ nil ].	self compactAddsAndRemoves.	temp := Dictionary new.	( self at: #added ) keysAndValuesDo: 		[: k : v | | index oc |			index := segh segmentClusterIDForKey: k value: v.			oc := temp at: index ifAbsentPut: [ OrderedCollection new ].			oc add: k.			oc add: v		].	( self at: #removed ) keysAndValuesDo: 		[: k : v | | index oc |			index := segh segmentClusterIDForKey: k value: v.			oc := temp at: index ifAbsentPut: [ OrderedCollection new ].			oc add: k.			oc add: v		].	( temp allSatisfy: [: oc | oc size &lt;= 2 ]) ifTrue: [ ^ nil ].	^ temp</body><body package="COFramesystem">flush: keysAndValues segmentedCollection: segmentedCollection 	1 to: keysAndValues size		by: 2		do: 		[: i | | k v |			k := keysAndValues at: i.			v := keysAndValues at: i + 1.			( self at: #added atKey: k remove: v ) notNil 				ifTrue: [ segmentedCollection atKey: k add: v ]				ifFalse: 				[	self at: #removed atKey: k remove: v.					segmentedCollection atKey: k remove: v				]		].	^ keysAndValues size // 2</body><body package="COFramesystem">fullFlushJournal	"return number of removed entries"	| addedSize removedSize |	addedSize := self sizeAt: #added.	addedSize &gt; 0 ifTrue: 		[	"add all (key/value)s"			( self at: #added ) keysAndValuesDo: [: k : v | self segmentedCollection atKey: k add: v ].			self depleteSlot: #added		].	removedSize := self sizeAt: #removed.	removedSize &gt; 0 ifTrue: 		[	"remove all (key/value)s"			( self at: #removed ) keysAndValuesDo: [: k : v | self segmentedCollection atKey: k remove: v ].			self depleteSlot: #removed		].	CoastLog logDebug: [ 'fullFlushJournal: shrink ' , self printString , ' by ' , ( addedSize + removedSize ) printString ] channel: #journal.	^ addedSize + removedSize</body></methods><methods><class-id>COAST.CoastJournalIndex</class-id> <category>copying</category><body package="COFramesystem">asIndex	| index |	index := Index new.	self keysAndValuesDo: [ : k : v | 		index atKey: k add: v	].	^ index</body><body package="COFramesystem">collectionTypeForCollect	^ Index</body></methods><methods><class-id>COAST.CoastJournalIndex</class-id> <category>enumerating</category><body package="COFramesystem">associationsDo: block 	^ self keysAndValuesDo: [: k : v | block value: k -&gt; v ]</body><body package="COFramesystem">do: block 	| added removed |	added := self at: #added.	removed := self at: #removed.	( added isEmpty and: [ removed isEmpty ]) 		ifTrue: [ self segmentedCollection do: block ]		ifFalse: [ self keysAndValuesDo: [: k : v | block value: v ] added: added removed: removed ].</body><body package="COFramesystem">keysAndValuesDo: block 	| added removed |	added := self at: #added.	removed := self at: #removed.	( added isEmpty and: [ removed isEmpty ]) 		ifTrue: [ self segmentedCollection keysAndValuesDo: block ]		ifFalse: [ self keysAndValuesDo: block added: added removed: removed ].</body><body package="COFramesystem">keysAndValuesDo: block added: added removed: removed 	added keysAndValuesDo: block.	self segmentedCollection 		keysAndValuesDo: [: k : v | (( added atKey: k includes: v ) or: [ removed atKey: k includes: v ]) ifFalse: [ block value: k value: v ]].</body><body package="COFramesystem">keysDo: block 	| added removed |	added := self at: #added.	removed := self at: #removed.	( added isEmpty and: [ removed isEmpty ]) 		ifTrue: [ self segmentedCollection keysDo: block ]		ifFalse: [ self keysAndValuesDo: [: k : v | block value: k ] added: added removed: removed ].</body></methods><methods><class-id>COAST.CoastJournalIndex</class-id> <category>testing</category><body package="COFramesystem">includesKey: key 	key coastIsValidRPCArgument ifFalse: [ ^ false ].	( self at: #added includesKey: key ) ifTrue: [ ^ true ].	( self at: #removed includesKey: key ) ifTrue: [ ^ false ].	^ self segmentedCollection includesKey: key</body></methods><methods><class-id>COAST.CoastJournalIndex</class-id> <category>iterating</category><body package="COFramesystem">coastAllArgumentsDo: aBlock 	self keysAndValuesDo: 		[: k : v |			aBlock value: k.			aBlock value: v		].</body></methods><methods><class-id>COAST.CoastJournalIndex class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #compactIndex</body></methods><methods><class-id>COAST.LocalStorageInterface</class-id> <category>read</category><body package="COClusterManagement">allClustersDo: aBlock	storageAccessor clusterIDs do:		[ :cid | | c |			c := clusterManager getCluster: cid.			aBlock value: c.		].</body><body package="COClusterManagement">bytesFor: clusterIDInteger	^storageAccessor bytesFor: clusterIDInteger</body><body package="COClusterManagement">importBlob: aSmallInteger fromFile: aNTFSFilename 		^storageAccessor importBlob: aSmallInteger fromFile: aNTFSFilename</body><body package="COClusterManagement">readStreamOnCluster: clusterID 	^storageAccessor readStreamOnCluster: clusterID</body></methods><methods><class-id>COAST.LocalStorageInterface</class-id> <category>gc</category><body package="COClusterManagement">allIDsDo: aBlock	storageAccessor allIDsDo: aBlock</body><body package="COClusterManagement">badFramesFileAccess	^storageAccessor badFramesFileAccess</body><body package="COClusterManagement">conflictingBlobIDs	^storageAccessor conflictingBlobIDs</body><body package="COClusterManagement">deleteCluster: clusterIDInteger	^storageAccessor deleteCluster: clusterIDInteger</body><body package="COClusterManagement">deleteConflictingBlob: badBlobID	storageAccessor deleteConflictingBlob: badBlobID</body><body package="COClusterManagement">estimatedNumberOfClusters	^storageAccessor estimatedNumberOfClusters</body><body package="COClusterManagement">gcEnabled	^storageAccessor gcEnabled</body><body package="COClusterManagement">highestID	^storageAccessor highestID</body><body package="COClusterManagement">largestClusterDo: block maxCount: maxCount 	storageAccessor largestClusterDo: block maxCount: maxCount</body><body package="COClusterManagement">nextClusterIDToLoad	^storageAccessor nextClusterIDToLoad</body></methods><methods><class-id>COAST.LocalStorageInterface</class-id> <category>accessing</category><body package="COClusterManagement">addToApplicationLog: aCatCSApplicationLog	^ storageAccessor addToApplicationLog: aCatCSApplicationLog</body><body package="COClusterManagement">blobExists: clusterID	^storageAccessor blobExists: clusterID</body><body package="COClusterManagement">cacheAccessor: aCacheAccessor	storageAccessor cacheAccessor: aCacheAccessor</body><body package="COClusterManagement">importBlob: clusterIDInteger fromStream: aStream	^ storageAccessor importBlob: clusterIDInteger fromStream: aStream</body><body package="COClusterManagement">indexIniAccess	^storageAccessor indexIniAccess</body><body package="COClusterManagement">indexIniAccess: iniAccess	^storageAccessor indexIniAccess: iniAccess</body><body package="COClusterManagement">nextClusterID	^storageAccessor nextClusterID</body><body package="COClusterManagement">nextClusterID: aSmallInteger 	storageAccessor nextClusterID: aSmallInteger</body><body package="COClusterManagement">releaseVolumeAccess	self releaseBinaryStoreInterfaces.	^ storageAccessor releaseVolumeAccess</body><body package="COClusterManagement">storageAccessor	^ storageAccessor</body><body package="COClusterManagement">storageAccessor: aStorageAccessor 	storageAccessor := aStorageAccessor.</body><body package="COClusterManagement">storageSizeForCluster: clusterID	^storageAccessor storageSizeForCluster: clusterID</body><body package="COClusterManagement">uniqueVolumeID	^storageAccessor uniqueVolumeID</body><body package="COClusterManagement">uniqueVolumeIDNeeded	^storageAccessor uniqueVolumeIDNeeded</body><body package="COClusterManagement">volumeIniAccess	^ storageAccessor volumeIniAccess</body></methods><methods><class-id>COAST.LocalStorageInterface</class-id> <category>admin</category><body package="COClusterManagement">backupVolume	^storageAccessor backupVolume</body><body package="COClusterManagement">backupVolumeAndKeep: backupsToKeep	self backupVolume.	self blockUntilBackupIsDone.	storageAccessor removeBackupsExcept: backupsToKeep</body><body package="COClusterManagement">blockUntilBackupIsDone	^storageAccessor blockUntilBackupIsDone</body><body package="COClusterManagement">compress	^storageAccessor compress</body><body package="COClusterManagement">copyConflictingBlob: oldID to: newID	^storageAccessor copyConflictingBlob: oldID to: newID</body><body package="COClusterManagement">copyVolumeTo: newVolume	^storageAccessor copyVolumeTo: newVolume</body><body package="COClusterManagement">deleteVolume	| backupDir |	backupDir := storageAccessor directoryForBackup.	self moveBinaryStoreTo: backupDir.	^storageAccessor moveVolumeToDirectory: backupDir.</body><body package="COClusterManagement">deleteVolumeNoBackup	self deleteBinaryStore.	^storageAccessor deleteVolumeNoBackup</body><body package="COClusterManagement">exclusiveInitiateCopyVolumeForDownload	^storageAccessor exclusiveInitiateCopyVolumeForDownload</body><body package="COClusterManagement">nonExclusiveFinishCopyVolumeForDownloadWith: copyInfo	^storageAccessor nonExclusiveFinishCopyVolumeForDownloadWith: copyInfo</body><body package="COClusterManagement">prepareDeleteVolume	storageAccessor prepareDeleteVolume</body><body package="COClusterManagement">receiveVolumeFrom: receiveStream	^storageAccessor receiveVolumeFrom: receiveStream clusterManager: clusterManager</body><body package="COClusterManagement">sendVolumeTo: sendStream	storageAccessor sendVolumeTo: sendStream</body></methods><methods><class-id>COAST.LocalStorageInterface</class-id> <category>write (mediator)</category><body package="COClusterManagement">handleFileDownloadRequest: req	storageAccessor handleFileDownloadRequest: req</body><body package="COClusterManagement">transferBlob: blobNr to: writeStream 	self transferBlob: blobNr to: writeStream bytesOnly: false</body><body package="COClusterManagement">transferBlob: blobNr to: writeStream bytesOnly: bytesOnly 	storageAccessor transferBlob: blobNr to: writeStream bytesOnly: bytesOnly</body><body package="COClusterManagement">transferBlobData: blobNr to: writeStream	storageAccessor transferBlobData: blobNr to: writeStream</body><body package="COClusterManagement">transferCluster: clusterIDInteger to: writeStream	storageAccessor transferCluster: clusterIDInteger to: writeStream</body></methods><methods><class-id>COAST.LocalStorageInterface</class-id> <category>testing</category><body package="COClusterManagement">clusterExists: clusterID	^storageAccessor clusterExists: clusterID</body><body package="COClusterManagement">importBlob: blobIDInteger fromBytes: byteArray 	storageAccessor importBlob: blobIDInteger fromBytes: byteArray</body><body package="COClusterManagement">importCluster: clusterID fromBytes: byteArray 	storageAccessor importCluster: clusterID fromBytes: byteArray</body><body package="COClusterManagement">okToCleanup	^storageAccessor okToCleanup</body><body package="COClusterManagement">supportsLazyUnmarshalling	^storageAccessor supportsLazyUnmarshalling</body></methods><methods><class-id>COAST.LocalStorageInterface</class-id> <category>shutdown</category><body package="COClusterManagement">prepareRelease	storageAccessor prepareRelease</body><body package="COClusterManagement">shutDown	self releaseBinaryStoreInterfaces.	storageAccessor shutDown</body></methods><methods><class-id>COAST.LocalStorageInterface</class-id> <category>write</category><body package="COClusterManagement">optimizeInMemory	storageAccessor optimizeInMemory</body><body package="COClusterManagement">saveAllClustersFor: aClusterControllerCollection 	| success frameClassIndex newIndexIni streamableClusters |	frameClassIndex := clusterManager frameClassIndex.	streamableClusters := aClusterControllerCollection 			collect: [: cc | UnpreparedStreamableCluster clusterController: cc marshaller: clusterManager loadSaveMarshaller ].	"a mandatory side effect of collecting streamable clusters is the update of the frame class index"	newIndexIni := nil.	frameClassIndex hasUpdates ifTrue: 		[	newIndexIni := CoastIniAccess new.			frameClassIndex updateIndexIni: newIndexIni.			frameClassIndex flushUpdates		].	frameClassIndex doNotUpdateWhile: [ success := storageAccessor saveAllClustersFor: streamableClusters updatedIndexAccess: newIndexIni ].	success ifFalse: 		[	newIndexIni notNil ifTrue: [ frameClassIndex unflushUpdates ].			^ false		].	frameClassIndex hasUpdates ifTrue: [ self error: 'frameClassIndex modified while storing clusters' ].	success ifTrue: [ aClusterControllerCollection do: [: cc | cc modified: false ]].	^ success</body><body package="COClusterManagement">writeStreamOnBlob: fileID size: size	^storageAccessor writeStreamOnBlob: fileID size: size</body></methods><methods><class-id>COAST.LocalStorageInterface class</class-id> <category>instance creation</category><body package="COClusterManagement">onAccessor: clusterStorageAccessor 	^ ( self new ) storageAccessor: clusterStorageAccessor;		yourself</body></methods><methods><class-id>COAST.CoastAbstractSegmentedSet</class-id> <category>accessing</category><body package="COFramesystem">* collection 	self subclassResponsibility.</body><body package="COFramesystem">- aSet 	"Answer those elements present in the receiver and absent from aSet."	^ self reject: [: i | aSet includes: i ]</body><body package="COFramesystem">add: key 	| size segment index |	size := self numberOfSegments.	size = 0 ifTrue: [ ^ self buildSegmentWith: key ].	index := ( self segmentIndexForKey: key ) min: size.	( index = size 		and: [( self isSplitSize: ( self fastAt: #sizes atIndex: index ) + 1 ) and: [( self fastAt: #lastKeys atIndex: index ) coastLessThan: key ]]) 		ifTrue: [ ^ self buildSegmentWith: key ].	segment := self segmentAtIndex: index.	segment add: key.	self postAdd: segment index: index key: key.	^ key</body><body package="COFramesystem">includes: key 	| size segment index |	size := self numberOfSegments.	size = 0 ifTrue: [ ^ false ].	index := self segmentIndexForKey: key.	index &gt; size ifTrue: [ ^ false ].	segment := self segmentAtIndex: index.	^ segment includes: key</body><body package="COFramesystem">occurrencesOf: key 	^ ( self includes: key ) 		ifTrue: [ 1 ]		ifFalse: [ 0 ]</body><body package="COFramesystem">remove: key 	self remove: key ifAbsent: nil</body><body package="COFramesystem">remove: key ifAbsent: absentBlock 	| size segment index |	size := self numberOfSegments.	size = 0 ifTrue: [ ^ absentBlock value ].	index := ( self segmentIndexForKey: key ) min: size.	segment := self segmentAtIndex: index.	( segment remove: key ) isNil ifTrue: [ ^ absentBlock value ].	self postRemove: segment index: index key: key.	^ key</body><body package="COFramesystem">suppressJournalForKey: key 	| size index cc |	size := self numberOfSegments.	size &lt; 2 ifTrue: [ ^ true ].	index := ( self segmentIndexForKey: key ) min: size.	( index = size 		and: [( self isSplitSize: ( self fastAt: #sizes atIndex: index ) + 1 ) and: [( self fastAt: #lastKeys atIndex: index ) coastLessThan: key ]]) 		ifTrue: [ ^ true	"build new segment" ].	cc := self clusterManager clusterControllerAt: ( self at: #segments atIndex: index ) clusterID.	^ cc notNil and: [ cc modified ]</body></methods><methods><class-id>COAST.CoastAbstractSegmentedSet</class-id> <category>private</category><body package="COFramesystem">postAdd: segment index: index key: key 	| size |	size := segment coastCompactElementCount.	self sizeAtIndex: index put: size.	( self compareAtIndex: index key: key ) = -1 ifTrue: [ self lastReferencedElementAtIndex: index put: key ].	( self isSplitSize: size ) ifTrue: [ self split: segment atIndex: index ].</body><body package="COFramesystem">postRemove: segment index: index key: key 	| size lastKey |	size := segment coastCompactElementCount.	size = 0 ifTrue: [ ^ self removeAtIndex: index ].	self sizeAtIndex: index put: size.	lastKey := self lastKeyAtIndex: index.	( key coastLessThan: lastKey ) ifTrue: [ ^ self ].	"update last key"	self lastReferencedElementAtIndex: index put: segment lastElement.</body><body package="COFramesystem">segmentClass	^ self subclassResponsibility</body></methods><methods><class-id>COAST.CoastAbstractSegmentedSet</class-id> <category>copying</category><body package="COFramesystem">collectionTypeForCollect	^ Set</body></methods><methods><class-id>COAST.CoastKeyIndexSegment class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #compactKeyIndex</body></methods><methods><class-id>COAST.PreparedStreamableCluster</class-id> <category>accessing</category><body package="COClusterManagement">approxByteSize	^clusterBytes size</body><body package="COClusterManagement">clusterController: aClusterController marshaller: aMarshaller	| writeStream |	writeStream := ByteArray new writeStream.	aClusterController saveClusterOn: writeStream marshaller: aMarshaller.	clusterBytes := writeStream contents.	clusterID := aClusterController clusterID.</body><body package="COClusterManagement">clusterID	^clusterID</body></methods><methods><class-id>COAST.PreparedStreamableCluster</class-id> <category>streaming</category><body package="COClusterManagement">saveClusterOn: writeStream	writeStream nextPutAll: clusterBytes</body></methods><methods><class-id>COAST.CoastSegmentedIndex</class-id> <category>accessing</category><body package="COFramesystem">associationsDo: block 	self segmentsDo: [: segment | segment associationsDo: block ]</body><body package="COFramesystem">atIndex: elementIndex 	| segmentElementIndex segment |	segmentElementIndex := elementIndex.	( self at: #sizes ) keysAndValuesDo: 		[: segIndex : sz |			sz &gt;= segmentElementIndex 				ifTrue: 				[	segment := self segmentAtIndex: segIndex.					^ segment atIndex: segmentElementIndex				]				ifFalse: [ segmentElementIndex := segmentElementIndex - sz ]		].	^ nil</body><body package="COFramesystem">atKey: key 	| index result maxIndex |	( key isCoastFrame and: [ key isLocal ]) ifTrue: [ ^ OrderedCollection new ].	index := self segmentIndexForKey: key.	result := nil.	maxIndex := self numberOfSegments.	index &gt; maxIndex ifTrue: [ ^ OrderedCollection new ].	[ | segment toAdd |		segment := self segmentAtIndex: index.		toAdd := segment atKey: key.		toAdd isNil 			ifTrue: 			[	^ result isNil 					ifTrue: [ OrderedCollection new ]					ifFalse: [ result ]			]			ifFalse: 			[	result isNil 					ifTrue: [ result := toAdd ]					ifFalse: [ result addAll: toAdd ]			].		( key coastLessThan: ( self lastKeyAtIndex: index )) or: 			[	index := index + 1.				index &gt; maxIndex			]	] whileFalse.	^ result</body><body package="COFramesystem">atKey: key add: value 	| size segment index |	size := self numberOfSegments.	size = 0 ifTrue: 		[	self buildSegmentWith: key -&gt; value.			^ value		].	index := self segmentIndexForKey: key value: value min: 1 max: size.	( index = size 		and: [( self isSplitSize: ( self fastAt: #sizes atIndex: index ) + 1 ) and: [( self fastAt: #lastKeys atIndex: index ) coastLessThan: key ]]) ifTrue: 		[	self buildSegmentWith: key -&gt; value.			^ value		].	segment := self segmentAtIndex: index.	segment atKey: key add: value.	self postAdd: segment index: index key: key value: value.	^ value</body><body package="COFramesystem">atKey: key includes: value 	| size segment index |	( key coastIsValidRPCArgument and: [ value coastIsValidRPCArgument ]) ifFalse: [ ^ false ].	size := self numberOfSegments.	size = 0 ifTrue: [ ^ false ].	index := self segmentIndexForKey: key value: value min: 1 max: size.	segment := self segmentAtIndex: index.	^ segment atKey: key includes: value</body><body package="COFramesystem">atKey: key remove: value 	^ self atKey: key remove: value ifAbsent: nil</body><body package="COFramesystem">atKey: key remove: value ifAbsent: absentBlock 	| size segment index |	size := self numberOfSegments.	size = 0 ifTrue: [ ^ absentBlock value ].	index := self segmentIndexForKey: key value: value min: 1 max: size.	segment := self segmentAtIndex: index.	( segment atKey: key remove: value ) isNil ifTrue: [ ^ absentBlock value ].	self postRemove: segment index: index key: key value: value.	^ value</body><body package="COFramesystem">atKeys: someKeys 	"someKeys must be compareable - otherwise a filtering would be needed"	^ ( self atKeysEmptyResult )		fillFrom: self atKeys: someKeys coastAsSortedValidKeys;		yourself</body><body package="COFramesystem">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COFramesystem">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues 	^ ( self atKeys: someKeys ) restrictToValues: rvalues</body><body package="COFramesystem">atKeys: someKeys restrictToValues: rvalues 	"return only those key-value pairs with keys in &lt;someKeys&gt; and values in &lt;rvalues&gt;"	^ ( self atKeys: someKeys ) restrictToValues: rvalues</body><body package="COFramesystem">atKeysEmptyCompactResult	^ CompactIndex new</body><body package="COFramesystem">atKeysEmptyResult	^ self clusterManager isMediatorCM 		ifTrue: [ self atKeysEmptyCompactResult ]		ifFalse: [ Index new ]</body><body package="COFramesystem">atSortedKeys: sortedKeys do: block 	"while accessing each key, reuse som informations:"	"a key can not be found in a segment with a index less than the segment index for the previous key ==&gt; startSegment keeps growing"	| lastKeys startSegment endSegment |	lastKeys := self at: #lastKeys.	startSegment := 1.	endSegment := lastKeys size.	sortedKeys do: 		[: key | | index |			index := lastKeys coastMinIndexForInserting: key min: startSegment max: endSegment.			index &gt; endSegment ifTrue: [ ^ self ].			[ | segment toAdd |				segment := self segmentAtIndex: index.				toAdd := segment atKey: key.				toAdd notNil ifTrue: [ toAdd do: [: value | block value: key value: value ]].				( key coastLessThan: ( lastKeys at: index )) or: 					[	index := index + 1.						index &gt; endSegment					]			] whileFalse.			startSegment := index		].</body><body package="COFramesystem">eachKeyIn: someKeys do: eachKeyBlock 	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index. "	" default fallback implementation "	(self atKeys: someKeys) keysDo: eachKeyBlock</body><body package="COFramesystem">fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive 	| startIndex result maxIndex stopIndex |	maxIndex := self numberOfSegments.	startIndex := startKeyOrNil notNil				ifTrue: [ (self segmentIndexForKey: startKeyOrNil) max: 1 ]				ifFalse: [ 1 ].	startIndex &gt; maxIndex ifTrue: [ ^ OrderedCollection new ].	stopIndex := stopKeyOrNil notNil				ifTrue: [ (self segmentIndexForKey: stopKeyOrNil inclusive: inclusive ) min: maxIndex ]				ifFalse: [ maxIndex ].	stopIndex &lt; startIndex ifTrue: [ ^ OrderedCollection new ].	result := nil.	[ | segment toAdd |		segment := self segmentAtIndex: startIndex.		toAdd := segment fromKey: startKeyOrNil toKey: stopKeyOrNil inclusive: inclusive.		toAdd isNil 			ifTrue: 			[	^ result isNil 					ifTrue: [ OrderedCollection new ]					ifFalse: [ result ]			]			ifFalse: 			[	result isNil 					ifTrue: [ result := toAdd asOrderedCollection ]					ifFalse: [ result addAll: toAdd ]			].		startIndex := startIndex + 1.		startIndex &lt;= stopIndex	] whileTrue.	^ result</body><body package="COFramesystem">indexOf: assoc 	| size segment indexOfSegment indexOfElement |	size := self numberOfSegments.	size = 0 ifTrue: [ ^ nil ].	indexOfSegment := self segmentIndexForKey: assoc key value: assoc value min: 1 max: size.	segment := self segmentAtIndex: indexOfSegment.	indexOfElement := segment indexOf: assoc.	1 to: indexOfSegment - 1 do: [: segInx | indexOfElement := indexOfElement + ( self at: #sizes atIndex: segInx )].	^ indexOfElement</body><body package="COFramesystem">insertionIndexOf: assoc 	| size segment indexOfSegment indexOfElement |	size := self numberOfSegments.	size = 0 ifTrue: [ ^ 1 ].	indexOfSegment := self segmentIndexForKey: assoc key value: assoc value min: 1 max: size.	segment := self segmentAtIndex: indexOfSegment.	indexOfElement := segment insertionIndexOf: assoc.	1 to: indexOfSegment - 1 do: [: segInx | indexOfElement := indexOfElement + ( self at: #sizes atIndex: segInx )].	^ indexOfElement</body><body package="COFramesystem">keys	| keys |	keys := OrderedCollection new: self size.	self keysDo: [: elem | keys add: elem ].	^ keys</body><body package="COFramesystem">keysAndValuesDo: block 	self segmentsDo: [: segment | segment keysAndValuesDo: block ]</body><body package="COFramesystem">lastValuesClusterIDs	^ (self at: #lastValues) collect: [ : ref | ref clusterID ]</body><body package="COFramesystem">rpcSelectKeys: someKeys whichInclude: aValue 	^ someKeys collect: [: key | self atKey: key includes: aValue ]</body><body package="COFramesystem">segmentedCollectionHeader	| newInst |	newInst := SegmentedIndexHeader new.	newInst lastKeys: (self at: #lastKeys) copy.	newInst clusterIDs: (( self at: #segments ) collect: [: frameLocator | frameLocator clusterID ]).	newInst lastValues: (self at: #lastValues) copy.	^newInst</body><body package="COFramesystem">selectKeys: someKeys whichInclude: aValue 	^ someKeys select: [: key | self atKey: key includes: aValue ]</body><body package="COFramesystem">suppressJournalForKey: key value: value 	| size index cc |	size := self numberOfSegments.	size &lt; 2 ifTrue: [ ^ true ].	index := self segmentIndexForKey: key value: value min: 1 max: size.	( index = size 		and: [( self isSplitSize: ( self fastAt: #sizes atIndex: index ) + 1 ) and: [( self fastAt: #lastKeys atIndex: index ) coastLessThan: key ]]) 		ifTrue: [ ^ true	"build new segment" ].	cc := self clusterManager clusterControllerAt: ( self at: #segments atIndex: index ) clusterID.	^ cc notNil and: [ cc modified ]</body></methods><methods><class-id>COAST.CoastSegmentedIndex</class-id> <category>accessing slots</category><body package="COFramesystem">lastReferenceBeforeIndex: index add: reference 	self lastKeyBeforeIndex: index add: reference key.	self lastValueBeforeIndex: index add: reference value</body><body package="COFramesystem">lastValueAtIndex: index 	^ self at: #lastValues atIndex: index</body><body package="COFramesystem">lastValueAtIndex: index put: value 	^ self at: #lastValues atIndex: index put: value selfOrFrameLocator</body><body package="COFramesystem">lastValueBeforeIndex: index add: value 	^ self at: #lastValues add: value selfOrFrameLocator beforeIndex: index</body><body package="COFramesystem">removeAtIndex: index 	super removeAtIndex: index.	self at: #lastValues removeAtIndex: index</body></methods><methods><class-id>COAST.CoastSegmentedIndex</class-id> <category>copying</category><body package="COFramesystem">asIndex	| index |	index := Index new.	self keysAndValuesDo: [ : k : v | 		index atKey: k add: v	].	^ index</body><body package="COFramesystem">collectionTypeForCollect	^ Index</body></methods><methods><class-id>COAST.CoastSegmentedIndex</class-id> <category>private</category><body package="COFramesystem">compareAtIndex: index key: key value: value 	| compare |	compare := self compareAtIndex: index key: key.	^ compare = 0 		ifTrue: 		[	"key=midKey"			( self lastValueAtIndex: index ) coastCompareTo: value		]		ifFalse: [ compare ]</body><body package="COFramesystem">depleteProxy	super depleteProxy.	self depleteSlot: #lastValues</body><body package="COFramesystem">lastReferencedElementAtIndex: index put: element 	self lastKeyAtIndex: index put: element key.	self lastValueAtIndex: index put: element value</body><body package="COFramesystem">postAdd: segment index: index key: key value: value 	| size |	size := segment size.	self sizeAtIndex: index put: size.	( self compareAtIndex: index key: key value: value ) = -1 ifTrue: 		[	self lastKeyAtIndex: index put: key.			self lastValueAtIndex: index put: value		].	( self isSplitSize: size ) ifTrue: [ self split: segment atIndex: index ].</body><body package="COFramesystem">postRemove: segment index: index key: key value: value 	| size |	size := segment size.	size = 0 ifTrue: [ ^ self removeAtIndex: index ].	self sizeAtIndex: index put: size.	( self compareAtIndex: index key: key value: value ) = 0 ifFalse: [ ^ self ].	"update last key"	self lastReferencedElementAtIndex: index put: segment lastElement.</body><body package="COFramesystem">segmentClass	^ CoastIndexSegment</body><body package="COFramesystem">segmentIndexForKey: key value: value min: min max: max 	"search index of the segment responsible for key-&gt;value"	| minIndex maxIndex |	minIndex := min.	maxIndex := max.	"1 &lt;= minIndex &lt;= maxIndex &lt;= keys size"	[ minIndex &lt; maxIndex ] whileTrue: 		[ "search in interval [ minIndex .. maxIndex ]"			| index compare |			index := minIndex + maxIndex bitShift: -1.	"minIndex &lt;= index &lt; maxIndex"			compare := self compareAtIndex: index key: key value: value.			compare = 0 ifTrue: [ ^ index	"value=midVal ==&gt; return index" ].			compare = 1 				ifTrue: [ maxIndex := index	"search at or before index" ]				ifFalse: [ minIndex := index + 1	"search behind index" ]		].	"minIndex = maxIndex"	^ minIndex</body></methods><methods><class-id>COAST.CoastSegmentedIndex</class-id> <category>journal</category><body package="COFramesystem">journalClass	^ CoastJournalIndex</body></methods><methods><class-id>COAST.CoastSegmentedIndex</class-id> <category>iterating</category><body package="COFramesystem">coastAllArgumentsDo: aBlock 	self keysAndValuesDo: 		[: k : v |			aBlock value: k.			aBlock value: v		].</body></methods><methods><class-id>COAST.CoastSegmentedIndex class</class-id> <category>slots</category><body package="COFramesystem">lastValuesSlot	^ self slotOfType: #orderedCollection</body></methods><methods><class-id>COAST.CatCSNullApplicationLogger</class-id> <category>API</category><body package="COClusterManagement">addToApplicationLog: aCatCSApplicationLog</body><body package="COClusterManagement">copyLogFilesToDirectory: destinationDirectory</body><body package="COClusterManagement">deleteLogFiles</body><body package="COClusterManagement">moveLogFilesToDirectory: destinationDirectory</body><body package="COClusterManagement">shutDown</body><body package="COClusterManagement">startUp</body></methods><methods><class-id>COAST.CatCSNullApplicationLogger class</class-id> <category>testing</category><body package="COClusterManagement">isAbstract	^ false</body></methods><methods><class-id>COAST.CoastSetSegment class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #compactSet</body></methods><methods><class-id>COAST.CatBFSegmentedFreeBlockList</class-id> <category>private</category><body package="COBlockFileSystem">freeBlocks	| freeBlocks |	freeBlocks := Set new.	freeBlockSegments do: [: seg | freeBlocks addAll: seg freeBlocks ].	^ freeBlocks</body><body package="COBlockFileSystem">magicNumber	" 'CoastSFL'  coastAs64BitNumber"	^ 16r436F61737453464C</body><body package="COBlockFileSystem">positionToSegmentIndex: index 	| pos |	pos := ( index - 1 ) * CatBFFreeBlockListSegment storageSize + self headerSize.	stream position: pos</body><body package="COBlockFileSystem">removeSegment: segment 	| index |	index := freeBlockSegments indexOf: segment.	self segmentsModifiedIndex: index.	freeBlockSegments removeAtIndex: index</body><body package="COBlockFileSystem">segmentFor: blockNumber 	| index |	freeBlockSegments isEmpty ifTrue: [ ^ nil ].	index := freeBlockSegments coastMinIndexForInserting: blockNumber criteria: [: segment | segment maxNumber ].	^ freeBlockSegments at: (( index min: freeBlockSegments size ) max: 1 )</body><body package="COBlockFileSystem">segmentsDo: aBlock	freeBlockSegments do: aBlock</body><body package="COBlockFileSystem">shortDescription	^ 'Free list'</body><body package="COBlockFileSystem">splitSegment: segment 	| newSegment index |	newSegment := CatBFFreeBlockListSegment new.	index := freeBlockSegments indexOf: segment.	freeBlockSegments add: newSegment beforeIndex: index.	segment moveFreeBlocksTo: newSegment.	self segmentsModifiedIndex: index</body></methods><methods><class-id>COAST.CatBFSegmentedFreeBlockList</class-id> <category>accessing</category><body package="COBlockFileSystem">addBlockNumber: blockNumber 	self addBlockNumber: blockNumber warnIfAlreadyFree: true</body><body package="COBlockFileSystem">addBlockNumber: blockNumber warnIfAlreadyFree: warnIfAlreadyFree 	| segment |	segment := self segmentFor: blockNumber.	segment isNil ifTrue: 		[	freeBlockSegments isEmpty ifFalse: [ self error: 'internal error' ].			freeBlockSegments add: ( segment := CatBFFreeBlockListSegment new ).			self segmentsModifiedIndex: 1		].	segment addBlockNumber: blockNumber for: self warnIfAlreadyFree: warnIfAlreadyFree.	freeMap add: blockNumber.</body><body package="COBlockFileSystem">addObsoleteStartBlock: blockNum	obsoleteStartBlocks add: blockNum</body><body package="COBlockFileSystem">allObsoleteBlocks	| copy oc |	obsoleteStartBlocks isEmpty ifTrue: [ ^ #( )].	oc := OrderedCollection new: obsoleteStartBlocks size.	copy := obsoleteStartBlocks asSortedCollection.	[ copy isEmpty ] whileFalse: 		[ | block nextBlockNumber |			block := blockFileSystem privateGetBlock: copy removeFirst.			nextBlockNumber := block nextBlockNumber.			nextBlockNumber &gt; 0 ifTrue: [ copy add: nextBlockNumber ].			oc add: block blockNumber		].	^ oc asSortedCollection</body><body package="COBlockFileSystem">freeObsoleteBlocks	" free obsolete blocks (=blocks of deleted files). 	!!! only free obsolete blocks right before writing back the BFS. Otherwise the BFS might get corrupt !!! "	| oc |	oc := self allObsoleteBlocks.	oc do: 		[: blockNumber | | segment |			segment := self segmentFor: blockNumber.			segment isNil ifTrue: 				[	freeBlockSegments isEmpty ifFalse: [ self error: 'internal error' ].					freeBlockSegments add: ( segment := CatBFFreeBlockListSegment new ).					self segmentsModifiedIndex: 1				].			segment addBlockNumber: blockNumber for: self warnIfAlreadyFree: true		].	obsoleteStartBlocks := OrderedCollection new.	freeMap addAll: oc.</body><body package="COBlockFileSystem">getConsecutiveFreeBlocks: numBlocks 	| blocks blockNums |	( freeMap hasRoomForAtLeast: numBlocks ) ifFalse: [ ^ OrderedCollection new: 0 ].	blockNums := freeMap bestRangeForSize: numBlocks minLength: ( numBlocks // 2 min: 20 ).	blockNums size = numBlocks ifFalse: [ ^ OrderedCollection new: 0 ].	self removeAllBlockNumbers: blockNums.	blocks := blockNums collect: [: bNum | CatBFBlock blockNumber: bNum blockSize: blockFileSystem blockSize ].	blocks reverse inject: 0		into: 		[: next : block |			block nextBlockNumber: next.			block blockNumber		].	^ blocks asOrderedCollection</body><body package="COBlockFileSystem">isFree: blockNumber 	| segment |	segment := self segmentFor: blockNumber.	^ segment notNil and: [ segment isFree: blockNumber ]</body><body package="COBlockFileSystem">isFreeOrObsolete: blockNumber 	^ ( self allObsoleteBlocks includes: blockNumber ) or: [ self isFree: blockNumber ]</body><body package="COBlockFileSystem">numberOfDirtySegments	| n |	n := 0.	freeBlockSegments keysAndValuesDo: 		[: index : directorySegment |			directorySegment dirty 				ifTrue: [ n := n + 1 ]		].	^ n</body><body package="COBlockFileSystem">numberOfFreeBlocks	^ freeMap numberOfFreeBlocks</body><body package="COBlockFileSystem">numberOfObsoleteBlocks	^ self allObsoleteBlocks size</body><body package="COBlockFileSystem">numberOfSegments	^ freeBlockSegments size</body><body package="COBlockFileSystem">removeAllBlockNumbers: blockNumbers 	blockNumbers do: 		[: blockNumber | | segment |			segment := self segmentFor: blockNumber.			segment notNil 				ifTrue: [ segment removeBlockNumber: blockNumber for: self ]				ifFalse: [ self error: 'Block ' , blockNumber printString , ' is not on the free list' ]		].	freeMap removeAll: blockNumbers .</body><body package="COBlockFileSystem">removeBlockNumber: blockNumber 	| segment |	segment := self segmentFor: blockNumber.	segment notNil 		ifTrue: 		[	segment removeBlockNumber: blockNumber for: self.			freeMap remove: blockNumber		]		ifFalse: [ self error: 'Block ' , blockNumber printString , ' is not on the free list' ].</body></methods><methods><class-id>COAST.CatBFSegmentedFreeBlockList</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	super initialize.	freeBlockSegments := OrderedCollection new.	obsoleteStartBlocks := OrderedCollection new.	freeMap := FreeMapRoot new.</body><body package="COBlockFileSystem">stream: aReadWriteStream 	aReadWriteStream reset.	stream := aReadWriteStream</body></methods><methods><class-id>COAST.CatBFSegmentedFreeBlockList</class-id> <category>marshalling</category><body package="COBlockFileSystem">open	| numberOfSegments tempFreeBlocks |	self lockStream.	freeMap isEmpty ifFalse: 		[	self haltOrContinue: 'unexpected reopen of free list'.			freeMap := FreeMapRoot new		].	numberOfSegments := self readHeader.	tempFreeBlocks := OrderedCollection new: numberOfSegments.	1 to: numberOfSegments		do: 		[: index | | segment |			self positionToSegmentIndex: index.			segment := CatBFFreeBlockListSegment readFrom: stream.			tempFreeBlocks add: segment.			freeMap addAll: segment freeBlocks		].	freeBlockSegments := tempFreeBlocks.</body><body package="COBlockFileSystem">write	self readOnly 		ifTrue: [ ^ self ].	freeBlockSegments keysAndValuesDo: 		[: index : freeBlockSegment | ( freeBlockSegment dirty or: [ segmentsModifiedIndex notNil and: [ segmentsModifiedIndex &lt;= index ]]) 				ifTrue: 				[	self positionToSegmentIndex: index.					freeBlockSegment writeOn: stream				]		].	self writeHeader.	self segmentsModifiedIndex: nil.</body></methods><methods><class-id>COAST.CatBFSegmentedFreeBlockList class</class-id> <category>private</category><body package="COBlockFileSystem">errorSignal	^ CatBFError</body></methods><methods><class-id>COAST.CoastJournalSet</class-id> <category>accessing</category><body package="COFramesystem">* aSet 	^ aSet select: [: e | self includes: e ]</body><body package="COFramesystem">- aSet 	"Answer those elements present in the receiver and absent from aSet."	^ self reject: [: i | aSet includes: i ]</body><body package="COFramesystem">add: value 	| segmentedCollection |	segmentedCollection := self segmentedCollection.	self at: #removed remove: value.	( segmentedCollection suppressJournalForKey: value ) 		ifTrue: 		[	self at: #added remove: value.			segmentedCollection add: value		]		ifFalse: 		[	self at: #added add: value.			self checkJournal		].	^ value</body><body package="COFramesystem">includes: value 	( self at: #removed includes: value ) ifTrue: [ ^ false ].	( self at: #added includes: value ) ifTrue: [ ^ true ].	^ self segmentedCollection includes: value</body><body package="COFramesystem">occurrencesOf: key 	^ ( self includes: key ) 		ifTrue: [ 1 ]		ifFalse: [ 0 ]</body><body package="COFramesystem">remove: key 	self remove: key ifAbsent: nil</body><body package="COFramesystem">remove: value ifAbsent: absentBlock 	| segmentedCollection |	segmentedCollection := self segmentedCollection.	( segmentedCollection suppressJournalForKey: value ) ifTrue: 		[ | probe |			probe := self at: #removed remove: value.			probe notNil ifTrue: 				[	segmentedCollection remove: value ifAbsent: nil.					^ absentBlock value				].			probe := self at: #added remove: value.			probe notNil ifTrue: 				[	segmentedCollection remove: value ifAbsent: nil.					^ value				].			^ segmentedCollection remove: value ifAbsent: absentBlock		].	absentBlock isNil ifTrue: 		[	self at: #added remove: value.			self at: #removed add: value.			self checkJournal.			^ value		].	( self at: #removed includes: value ) ifTrue: [ ^ absentBlock value ].	( self at: #added remove: value ) notNil ifTrue: [ ^ self at: #removed add: value ].	( self segmentedCollection includes: value ) ifFalse: [ ^ absentBlock value ].	self at: #removed add: value.	self checkJournal.	^ value</body></methods><methods><class-id>COAST.CoastJournalSet</class-id> <category>copying</category><body package="COFramesystem">collectionTypeForCollect	^ Set</body></methods><methods><class-id>COAST.CoastJournalSet</class-id> <category>private</category><body package="COFramesystem">diffsBySegmentClusterID: segmentedCollection 	"group k&amp;v by target Segment - fill up biggest first"	"should reduce clusters to save to a minimum while shrinking journal"	"return number of removed entries"	| segh temp |	segh := segmentedCollection segmentedCollectionHeader.	segh numberOfSegments = 0 ifTrue: [ ^ nil ].	temp := Dictionary new.	( self at: #added ) do: 		[: v | | index oc |			index := segh segmentClusterIDForKey: v.			oc := temp at: index ifAbsentPut: [ OrderedCollection new ].			oc add: v		].	( self at: #removed ) do: 		[: v | | index oc |			index := segh segmentClusterIDForKey: v.			oc := temp at: index ifAbsentPut: [ OrderedCollection new ].			oc add: v		].	( temp allSatisfy: [: oc | oc size &lt;= 1 ]) ifTrue: [ ^ nil ].	^ temp</body><body package="COFramesystem">flush: values segmentedCollection: segmentedCollection 	values do: 		[: v | ( self at: #added remove: v ) notNil 				ifTrue: [ segmentedCollection add: v ]				ifFalse: 				[	self at: #removed remove: v.					segmentedCollection remove: v				]		].	^ values size</body><body package="COFramesystem">fullFlushJournal	"return number of removed entries"	| addedSize removedSize |	addedSize := self sizeAt: #added.	addedSize &gt; 0 ifTrue: 		[	"add all"			( self at: #added ) do: [: v | self segmentedCollection add: v ].			self depleteSlot: #added		].	removedSize := self sizeAt: #removed.	removedSize &gt; 0 ifTrue: 		[	"remove all"			( self at: #removed ) do: [: v | self segmentedCollection remove: v ].			self depleteSlot: #removed		].	CoastLog logDebug: [ 'fullFlushJournal: shrink ' , self printString , ' by ' , ( addedSize + removedSize ) printString ] channel: #journal.	^ addedSize + removedSize</body></methods><methods><class-id>COAST.CoastJournalSet</class-id> <category>enumerating</category><body package="COFramesystem">do: block 	| added removed |	added := self at: #added.	removed := self at: #removed.	( added isEmpty and: [ removed isEmpty ]) 		ifTrue: [ self segmentedCollection do: block ]		ifFalse: 		[	added do: block.			self segmentedCollection do: 				[: v | (( added includes: v ) or: [ removed includes: v ]) 						ifFalse: [ block value: v ]				]		].</body><body package="COFramesystem">keysDo: block 	^ self do: block</body></methods><methods><class-id>COAST.CoastJournalSet class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #compactSet</body></methods><methods><class-id>COAST.CatBFSegmentedDirectory</class-id> <category>accessing</category><body package="COBlockFileSystem">addFile: aCatBFFile 	self fileAt: aCatBFFile fileNumber put: aCatBFFile</body><body package="COBlockFileSystem">allIDsDo: aBlock 	self filesDo: [: file | ( file isBlob or: [ file isCluster ]) ifTrue: [ aBlock value: file fileNumber ]].</body><body package="COBlockFileSystem">blobIDs	" all IDs of blob files"	| blobIDs |	blobIDs	:= OrderedCollection new.	self filesDo: [ : file | 		file isBlob ifTrue: [ blobIDs add: file fileNumber ].	].	^ blobIDs</body><body package="COBlockFileSystem">clusterAndBlobIDs	" all IDs of blob / cluster files"	| fileIDs |	fileIDs	:= OrderedCollection new: self numberOfFiles.	self filesDo: [ : file | 		(file isBlob or:[ file isCluster ]) ifTrue: [ fileIDs add: file fileNumber ].	].	^ fileIDs</body><body package="COBlockFileSystem">clusterIDs	" all IDs of cluster files"	| clusterIDs |	clusterIDs := OrderedCollection new: self numberOfFiles.	self filesDo: [ : file | 		file isCluster ifTrue: [ clusterIDs add: file fileNumber ].	].	^ clusterIDs</body><body package="COBlockFileSystem">fileExists: aCatBFFile 	^ self fileNumberExists: aCatBFFile fileNumber</body><body package="COBlockFileSystem">fileNumberExists: fileNumber 	| segment |	segment := self segmentFor: fileNumber.	^ segment notNil and: [ segment fileNumberExists: fileNumber ]</body><body package="COBlockFileSystem">getFile: fileNumber 	| segment |	segment := self segmentFor: fileNumber.	^ segment notNil 		ifTrue: [ segment getFile: fileNumber ]		ifFalse: [ nil ]</body><body package="COBlockFileSystem">highestFileNumber	" highest file number of regular files "	"do not look to the specialFilesSegment"	| highestFileNumber |	self resolvedSegmentsReverseDo: 		[: seg |			highestFileNumber := seg highestFileNumber.			highestFileNumber = 0 ifFalse: [ ^ highestFileNumber ]		].	^ -1</body><body package="COBlockFileSystem">largestClusterDo: block maxCount: maxCount 	| clusterSizeMargin biggestClusters |	clusterSizeMargin := nil.	biggestClusters := Dictionary new.	self filesDo: 		[: file |			file isCluster ifTrue: 				[ | smallestKept |					( clusterSizeMargin isNil or: [ clusterSizeMargin &lt; file fileSize ]) ifTrue: 						[	biggestClusters at: file fileNumber put: file fileSize.							biggestClusters size &gt; ( 1000 max: 2 * maxCount ) ifTrue: 								[	"ab der doppelten GrÃ¶Ãe (oder 1000) trimmen"									smallestKept := self trimmLargestClusters: biggestClusters maxCount: maxCount.									clusterSizeMargin := clusterSizeMargin notNil 											ifTrue: [ smallestKept max: clusterSizeMargin ]											ifFalse: [ smallestKept ]								]						]				]		].	self trimmLargestClusters: biggestClusters maxCount: maxCount.	^ ( biggestClusters keys sortedBy: [: cid | biggestClusters at: cid ]) 		reverseDo: [: fileNumber | block value: fileNumber value: ( biggestClusters at: fileNumber )]</body><body package="COBlockFileSystem">markModified: aCatBFFile 	| segment |	segment := self segmentFor: aCatBFFile fileNumber.	segment notNil 		ifTrue: [ segment dirty: true ]		ifFalse: [ self error: 'unknown file to modify: ' , aCatBFFile displayString ]</body><body package="COBlockFileSystem">maxKey	" highest file number ever used of regular files "	"do not look to the specialFilesSegment"	| maxKey |	self resolvedSegmentsReverseDo: 		[: seg |			maxKey := seg maxKey.			maxKey = 0 ifFalse: [ ^ maxKey ]		].	^ 0</body><body package="COBlockFileSystem">numberOfDirtySegments	| n |	n := 0.	specialFilesSegment dirty 		ifTrue: [ n := n + 1 ].	filesDictionarySegments keysAndValuesDo: 		[: index : directorySegment |			directorySegment dirty 				ifTrue: [ n := n + 1 ]		].	^ n</body><body package="COBlockFileSystem">numberOfFiles	^ filesDictionarySegments inject: specialFilesSegment numberOfFiles into: [: sum : seg | sum + seg numberOfFiles ]</body><body package="COBlockFileSystem">numberOfSegments	^ filesDictionarySegments size</body><body package="COBlockFileSystem">removeFile: aCatBFFile 	self removeFileNumber: aCatBFFile fileNumber</body><body package="COBlockFileSystem">removeFileNumber: fileNumber 	| segment |	segment := self segmentFor: fileNumber.	segment isNil 		ifTrue: [ self error: 'File "' , fileNumber displayString , '" was not added to the directory' ]		ifFalse: [ segment removeFileNumber: fileNumber ]</body><body package="COBlockFileSystem">trimmLargestClusters: biggestClusters maxCount: maxCount 	| sorted |	biggestClusters isEmpty ifTrue: [ ^ nil ].	sorted := biggestClusters keys sortedBy: [: key | biggestClusters at: key ].	biggestClusters size &gt; maxCount ifFalse: [ ^ biggestClusters at: sorted first ].	1 to: sorted size - maxCount do: [: i | biggestClusters removeKey: ( sorted at: i )].	^ biggestClusters at: ( sorted at: sorted size - maxCount + 1 )</body></methods><methods><class-id>COAST.CatBFSegmentedDirectory</class-id> <category>private</category><body package="COBlockFileSystem">checkMaxKeys         | maxKey |       maxKey := -1.       (filesDictionarySegments) keysAndValuesDo:             [: index : segment |                 maxKey &lt; segment maxKey                      ifTrue: [ maxKey := segment maxKey ]                      ifFalse: [ self error: 'Internal error: invalid directory segment maxKey at index ', index printString  ].            ]</body><body package="COBlockFileSystem">fileAt: fileNumber put: aCatBFFile 	| segment splittedSegment |	segment := self segmentFor: fileNumber.	segment isNil 		ifTrue: 		[ 			filesDictionarySegments isEmpty ifFalse: [ self error: 'internal error' ].			filesDictionarySegments add: ( segment := CatBFDirectorySegment new ).			self segmentsModifiedIndex: 1		]		ifFalse: 		[			segment isFull ifTrue: 				[ 					splittedSegment := self splitSegment: segment.					fileNumber &lt;= splittedSegment maxKey						ifTrue: [ segment := splittedSegment ].				]		].	segment fileAt: fileNumber put: aCatBFFile</body><body package="COBlockFileSystem">indexOfSegment: segment 	| index |	index := filesDictionarySegments coastMinIndexForInserting: segment maxKey criteria: [: seg | seg maxKey ].	(index &gt;= 1 and: [ index &lt;= filesDictionarySegments size ])		ifTrue: [			(filesDictionarySegments at: index) == segment				ifFalse: [ self error: 'Internal error: wrong directory segment at index ', index printString ].			^ index		]		ifFalse: [			self error: 'Internal error: wrong index of directory segment not' 		]</body><body package="COBlockFileSystem">magicNumber	" 'CoastSD'  coastAs64BitNumber"	^ 16r436F6173745344</body><body package="COBlockFileSystem">positionToSegmentIndex: index offset: offset  	| pos |	pos := index * CatBFDirectorySegment storageSize + self headerSize.	stream position: offset + pos</body><body package="COBlockFileSystem">privateFiles	" all files "	| privateFiles |	privateFiles := OrderedCollection new: self numberOfFiles.	self filesDo: [: file | privateFiles add: file ].	^ privateFiles</body><body package="COBlockFileSystem">resolvedSegmentAt: index	| segment |	segment := filesDictionarySegments at: index.	segment isResolved ifFalse: 		[	self positionToSegmentIndex: index offset: CatBFDirectorySegment headerSize.			segment readBodyFrom: stream		].	^ segment</body><body package="COBlockFileSystem">segmentFor: fileNumber 	| index segmentIndex |	( CatBFFile isSpecialFileNumber: fileNumber ) ifTrue: [ ^ specialFilesSegment ].	filesDictionarySegments isEmpty ifTrue: [ ^ nil ].	index := filesDictionarySegments coastMinIndexForInserting: fileNumber criteria: [: seg | seg maxKey ].	segmentIndex := ( index min: filesDictionarySegments size ) max: 1.	^ self resolvedSegmentAt: segmentIndex</body><body package="COBlockFileSystem">segmentsDo: aBlock	filesDictionarySegments do: aBlock.	aBlock value: specialFilesSegment .</body><body package="COBlockFileSystem">segmentsModifiedIndex: newIndex 	super segmentsModifiedIndex: newIndex.	newIndex notNil		ifTrue: [			" make sure that the segments after the modifed position are loaded "			newIndex + 1 to: filesDictionarySegments size do: [ : index |				self resolvedSegmentAt: index			].		].</body><body package="COBlockFileSystem">shortDescription	^ 'Directory'</body><body package="COBlockFileSystem">splitSegment: segment	| splittedSegment splitIndex |	segment == specialFilesSegment ifTrue: [ self error: 'too many special files!' ].	" need to resolve all segments after the insertion index before doing the split	(otherwise segment index calculation would be incorrect) "	splitIndex := self indexOfSegment: segment.	self segmentsModifiedIndex: splitIndex.	splittedSegment := segment splittedSegmentBefore.	filesDictionarySegments add: splittedSegment beforeIndex:splitIndex.	^ splittedSegment</body></methods><methods><class-id>COAST.CatBFSegmentedDirectory</class-id> <category>enumeration</category><body package="COBlockFileSystem">directoryDo: aBlock 	" evaluate the block with all filenumbers and files "	self resolvedSegmentsReverseDo: [: seg | seg directoryDo: aBlock ].	specialFilesSegment directoryDo: aBlock</body><body package="COBlockFileSystem">filesDo: aBlock 	" evaluate the block with all files "	^ self directoryDo: [: i : file | aBlock value: file ]</body><body package="COBlockFileSystem">resolvedSegmentsReverseDo: aBlock 	" evaluate the block with all filenumbers and files "	filesDictionarySegments size to: 1 by: -1 do: [ : segIndex |		aBlock value: ( self resolvedSegmentAt: segIndex )	]</body></methods><methods><class-id>COAST.CatBFSegmentedDirectory</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	super initialize.	filesDictionarySegments := OrderedCollection new.	specialFilesSegment := CatBFSpecialFilesSegment new</body><body package="COBlockFileSystem">stream: aStream 	stream := aStream</body></methods><methods><class-id>COAST.CatBFSegmentedDirectory</class-id> <category>marshalling</category><body package="COBlockFileSystem">open	| numberOfSegments tempSegments |	self lockStream.	stream reset.	numberOfSegments := self readHeader.	tempSegments := OrderedCollection new: numberOfSegments.	self positionToSpecialFilesSegment.	specialFilesSegment := CatBFSpecialFilesSegment readHeaderFrom: stream.	specialFilesSegment readBodyFrom: stream.	( 1 to: numberOfSegments ) do: 		[: index |			self positionToSegmentIndex: index offset: 0.			tempSegments add: ( CatBFDirectorySegment readHeaderFrom: stream )		].	filesDictionarySegments := tempSegments.	self checkMaxKeys.</body><body package="COBlockFileSystem">optimizeUnmodifed	filesDictionarySegments do:		[ : directorySegment |			directorySegment optimizeUnmodifed		].</body><body package="COBlockFileSystem">positionToSpecialFilesSegment	stream position: self headerSize</body><body package="COBlockFileSystem">write	self readOnly		ifTrue: [ ^ self ].	specialFilesSegment dirty ifTrue: 		[	self positionToSpecialFilesSegment.			specialFilesSegment writeOn: stream for: blockFileSystem		].	filesDictionarySegments keysAndValuesDo: 		[: index : directorySegment |			(directorySegment dirty or: [ segmentsModifiedIndex notNil and: [ segmentsModifiedIndex &lt;= index ]])				ifTrue: [					self positionToSegmentIndex: index offset: 0.					directorySegment writeOn: stream for: blockFileSystem				].			directorySegment optimizeUnmodifed		].	self writeHeader.	self segmentsModifiedIndex: nil.</body></methods><methods><class-id>COAST.CatBFSegmentedDirectory class</class-id> <category>private</category><body package="COBlockFileSystem">errorSignal	^ CatBFError</body></methods><methods><class-id>COAST.CoastKeyDictionarySegment class</class-id> <category>private</category><body package="COFramesystem">collectionSlotType	^ #compactKeyDictionary</body></methods><methods><class-id>COAST.CatBFReadStream</class-id> <category>testing</category><body package="COBlockFileSystem">atEnd	^  currentBlock isNil or: [ self bufferPosition &gt;= readLimit and: [ currentBlock isLastBlock ]]</body><body package="COBlockFileSystem">isReadable	^ true</body></methods><methods><class-id>COAST.CatBFReadStream</class-id> <category>initialize-release</category><body package="COBlockFileSystem">blockFileSystem: aCatBfBlockFileSystem file: aCatBFFile buffer: aByteArray	super blockFileSystem: aCatBfBlockFileSystem file: aCatBFFile buffer: aByteArray.	self getFirstBlockForReading.</body><body package="COBlockFileSystem">deregister	self blockFileSystem deregisterFileReadStream: self.</body></methods><methods><class-id>COAST.CatBFReadStream</class-id> <category>private</category><body package="COBlockFileSystem">currentBlock: aCatBFBlock 	super currentBlock: aCatBFBlock.	( aCatBFBlock notNil and: [ aCatBFBlock isLastBlock not ]) ifTrue: [ ^ self	"nothing to check now" ].	self position + readLimit - self bufferPosition = file fileSize 		ifFalse: [ CatBFError raiseSignal: 'file ' , file displayString , ' is to short (' , ( self position + readLimit ) displayString , ')!' ].</body><body package="COBlockFileSystem">fillBlockBuffer	" fill the buffer for the current block "	self blockFileSystem 		nextPutBlockFileData: self currentBlock blockNumber 		into: self buffer		startingAt: 1.	readLimit := self currentBlock dataSize</body><body package="COBlockFileSystem">getFirstBlockForReading	| blk blockNum |	blockNum := self file firstBlockNumber.	blk := blockNum &gt; 0		ifTrue: [ self blockFileSystem getBlock: blockNum ]		ifFalse: [ nil ].	self currentBlock: blk.	^ blk</body><body package="COBlockFileSystem">getNextBlockForReading	" Get the next block "	| blk |	currentBlock isNil ifTrue: [ ^ nil ].	currentBlock isLastBlock 		ifTrue: [ 			self currentBlock: nil.			self class endOfStreamSignal raiseRequestFrom: self.			^ nil		].	blk := self blockFileSystem getBlock: currentBlock nextBlockNumber.	self currentBlock: blk.	^ blk</body><body package="COBlockFileSystem">writeBackCurrentBlock	" not needed "</body></methods><methods><class-id>COAST.CatBFReadStream</class-id> <category>accesssing</category><body package="COBlockFileSystem">flush	" read only, nothing to do "</body><body package="COBlockFileSystem">next	| i blk |	currentBlock isNil ifTrue: [ ^ nil ].	i := self bufferPosition + 1.	^ i &lt;= readLimit		ifTrue: [ 			position := position + 1.			collection at: i.		]		ifFalse: [			blk := self getNextBlockForReading.			blk notNil				ifTrue: [ 	self next ]				ifFalse: [ nil ]		].</body><body package="COBlockFileSystem">next: anInteger into: aSequenceableCollection startingAt: startIndex 	" copy of Stream&gt;&gt;next:into:startingAt: "	| index stopIndex |	index := startIndex.	stopIndex := index + anInteger.	[[index &lt; stopIndex]				whileTrue: [aSequenceableCollection at: index put: self next.							index := index + 1]]		on: Stream endOfStreamSignal		do: 			[:ex | ex retryUsing:					[(Stream incompleteNextCountSignal newExceptionFrom: self)						parameter: index - startIndex;						raiseRequest]].	^aSequenceableCollection</body><body package="COBlockFileSystem">nextPut: anObject 	self shouldNotImplement</body></methods><methods><class-id>COAST.CoastValueIndexSegment</class-id> <category>accessing</category><body package="COFramesystem">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	^ ( self at: #compactCollection ) atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize</body><body package="COFramesystem">matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	^ ( self at: #compactCollection ) matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize</body></methods><methods><class-id>COAST.CoastValueIndexSegment class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #compactValueIndex</body></methods><methods><class-id>COAST.CoastMixedSetSegment class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #sortedSet</body></methods><methods><class-id>COAST.FreeMapRoot</class-id> <category>testing</category><body package="COBlockFileSystem">covers: aRange 	^ node notNil and: [ node covers: aRange ]</body><body package="COBlockFileSystem">isBalanced	^ node isNil or: [ node isBalanced ]</body><body package="COBlockFileSystem">isEmpty	^ node isNil or: [ node isEmpty ]</body><body package="COBlockFileSystem">isSorted	^ node isNil or: [ node isSorted ]</body></methods><methods><class-id>COAST.FreeMapRoot</class-id> <category>accessing</category><body package="COBlockFileSystem">addFrom: start to: stop 	node := node notNil 			ifTrue: [ node addFrom: start to: stop ]			ifFalse: [ self newLeafFrom: start to: stop ].</body><body package="COBlockFileSystem">bestRangeForSize: size minLength: minLength 	| rangeCollection result |	rangeCollection := IdentitySet new.	self bestRangeForSize: size minLength: minLength to: rangeCollection.	rangeCollection size = 1 ifTrue: [ ^ rangeCollection singleElement asOrderedCollection ].	rangeCollection := rangeCollection sortedBy: [: leafOrIntervall | leafOrIntervall min ].	result := OrderedCollection new: ( rangeCollection inject: 0 into: [: sum : leafOrIntervall | sum + leafOrIntervall size ]).	rangeCollection do: [: leafOrIntervall | result addAll: leafOrIntervall ].	^ result</body><body package="COBlockFileSystem">bestRangeForSize: size minLength: minLength to: result 	| leafList bestLeaf |	leafList := leavesBySize atKey: size ifAbsent: #( ).	bestLeaf := leafList notEmpty 			ifTrue: [ self anyLeafFrom: leafList except: result ]			ifFalse: [ nil ].	bestLeaf notNil 		ifTrue: 		[	result add: bestLeaf leftMostRange.			^ self		].	bestLeaf := 1 to: 0.	leavesBySize keysAndValuesDo: 		[: rangeSize : leaves | | leaf |			leaf := minLength &lt;= rangeSize 					ifTrue: [ self anyLeafFrom: leaves except: result ]					ifFalse: [ nil ].			bestLeaf := leaf notNil 					ifTrue: 					[	rangeSize &gt; size 							ifTrue: 							[	"smallest greater "								( bestLeaf size &gt; size and: [ bestLeaf size &lt; rangeSize ]) 									ifTrue: [ bestLeaf ]									ifFalse: [ leaf ]							]							ifFalse: 							[	"biggest smaller with todo at least minLength"								( size - rangeSize &lt; minLength or: [ bestLeaf size &gt; rangeSize ]) 									ifTrue: [ bestLeaf ]									ifFalse: [ leaf ]							]					]					ifFalse: [ bestLeaf ]		].	bestLeaf isEmpty 		ifTrue: [ ^ self ].	bestLeaf size &gt; size 		ifTrue: 		[	result add: ( bestLeaf min to: bestLeaf min + size - 1 ).			^ self		].	result add: bestLeaf.	self bestRangeForSize: size - bestLeaf size minLength: minLength to: result.</body><body package="COBlockFileSystem">deregisterLeaf: leaf	| key list |	key := leaf size.	list := leavesBySize at: key ifAbsent: [ self error: 'Leaf list expected for size ', key printString. ].	list removeLeaf: leaf.	list isEmpty ifTrue: [ leavesBySize removeKey: key ].</body><body package="COBlockFileSystem">do: block 	node notNil ifTrue: [ node do: block ].</body><body package="COBlockFileSystem">hasRoomForAtLeast: requiredNumberOfBlocks 	| totalNumberOfBlocks |	totalNumberOfBlocks := 0.	leavesBySize keys asSortedCollection reverseDo: 		[: numBlocks |			totalNumberOfBlocks := totalNumberOfBlocks + ( numBlocks * ( leavesBySize at: numBlocks ) size ).			totalNumberOfBlocks &gt;= requiredNumberOfBlocks ifTrue: [ ^ true ]		].	^ false</body><body package="COBlockFileSystem">height	^ node notNil 		ifTrue: [ node height ]		ifFalse: [ 0 ]</body><body package="COBlockFileSystem">max	^ node notNil 		ifTrue: [ node max ]		ifFalse: [ 0 ]</body><body package="COBlockFileSystem">min	^ node notNil 		ifTrue: [ node min ]		ifFalse: [ 1 ]</body><body package="COBlockFileSystem">numberOfFreeBlocks	| totalNumberOfBlocks |	totalNumberOfBlocks := 0.	leavesBySize keysAndValuesDo: [: numBlocks : leafList | totalNumberOfBlocks := totalNumberOfBlocks + ( numBlocks * leafList size )].	^ totalNumberOfBlocks</body><body package="COBlockFileSystem">rangeForSize: size 	^ leavesBySize at: size ifPresent: [ : leaves | leaves firstLeaf leftMostRange ]</body><body package="COBlockFileSystem">registerLeaf: leaf	| key list |	key := leaf size.	list := leavesBySize at: key ifAbsentPut: [ FreeMapLeafList new ].	list insertLeaf: leaf.</body><body package="COBlockFileSystem">removeFrom: start to: stop 	node := node removeFrom: start to: stop.</body><body package="COBlockFileSystem">root	^ self</body></methods><methods><class-id>COAST.FreeMapRoot</class-id> <category>private</category><body package="COBlockFileSystem">anyLeafFrom: leafList except: excludedLeaves 	leafList leavesOfSameSizeDo: 		[: leaf | ( excludedLeaves includes: leaf ) not 				ifTrue: [ ^ leaf ]		].	^ nil</body><body package="COBlockFileSystem">validate	super validate.	node notNil ifTrue: [ node validate ].</body></methods><methods><class-id>COAST.FreeMapRoot</class-id> <category>initialize-release</category><body package="COBlockFileSystem">initialize	leavesBySize := CatCOIntegerKeyDictionary new.</body></methods><methods><class-id>COAST.FreeMapRoot class</class-id> <category>instance creation</category><body package="COBlockFileSystem">new	^ ( super new )		initialize;		yourself</body></methods><methods><class-id>COAST.CoastJournalValueIndex</class-id> <category>accessing</category><body package="COFramesystem">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| result1 result2 temp |	result1 := self at: #added atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize.	result1 size = maxSize ifTrue: [ ^ result1 ].	result2 := self segmentedCollection atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize.	result2 isEmpty ifTrue: [ ^ result1 ].	( self at: #removed atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: nil ) do: [: removed | result2 remove: removed ifAbsent: nil ].	result1 isEmpty ifTrue: [ ^ result2 ].	result1 size &lt; result2 size ifTrue: 		[	temp := result2.			result2 := result1.			result1 := temp		].	( maxSize notNil and: [ result1 size + result2 size &gt; maxSize ]) 		ifTrue: [ 1 to: maxSize - result1 size do: [: i | result1 add: ( result2 at: i )]]		ifFalse: [ result1 addAll: result2 ].	^ result1</body><body package="COFramesystem">matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| result1 result2 temp limit |	limit := maxSize.	limit notNil ifTrue: [ limit := limit + ( self sizeAt: #removed )].	result1 := self at: #added matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: limit.	result2 := self segmentedCollection matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: limit.	result2 isEmpty ifTrue: [ ^ result1 limitToSize: maxSize ].	( self at: #removed matchingPattern: keyPattern ignoreCase: ignoreCase ) 		keysAndValuesDo: [: rKey : rValue | result2 atKey: rKey remove: rValue ifAbsent: nil ].	result1 isEmpty ifTrue: [ ^ result2 limitToSize: maxSize ].	result1 size &lt; result2 size ifTrue: 		[	temp := result2.			result2 := result1.			result1 := temp		].	result2 referencesElementsCursorDo: [: cursor | result1 addElement: cursor copyForRefCursor ].	^ result1 limitToSize: maxSize</body></methods><methods><class-id>COAST.CoastJournalValueIndex class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #compactValueIndex</body></methods><methods><class-id>COAST.CatBFSpecialFilesSegment</class-id> <category>marshalling</category><body package="COBlockFileSystem">optimizeUnmodifed	" do nothing, keep files in memory "</body></methods><methods><class-id>COAST.CoastSegmentedSet</class-id> <category>private</category><body package="COFramesystem">segmentClass	^ CoastSetSegment</body></methods><methods><class-id>COAST.CoastSegmentedSet</class-id> <category>accessing</category><body package="COFramesystem">* collection 	| stream result oc nextFrame frameLocator |	oc := collection asSortedCollection: 			[: f1 : f2 | | cid1 cid2 fid1 fid2 |				( f1 isCoastFrame and: [( fid1 := f1 id ) isInteger ]) and: 					[( f2 isCoastFrame and: [( fid2 := f2 id ) isInteger ]) not or: 							[( cid1 := f1 clusterID ) = ( cid2 := f2 clusterID ) 									ifTrue: [ fid1 &lt; fid2 ]									ifFalse: [ cid1 &lt; cid2 ]							]					]			].	oc isEmpty ifTrue: [ ^ Set new: 0 ].	stream := oc readStream.	nextFrame := stream next.	frameLocator := nextFrame frameLocator.	result := Set new: oc size.	self referencesElementsCursorDo: 		[: cursor |						[ frameLocator &lt; cursor ] whileTrue: 				[	stream atEnd ifTrue: [ ^ result ].					nextFrame := stream next.					( nextFrame isCoastFrame and: [ nextFrame isLocal not ]) ifFalse: [ ^ result ].					frameLocator frameID: nextFrame frameID.					frameLocator clusterID: nextFrame clusterID				].			( frameLocator frameID = cursor frameID and: [ frameLocator clusterID = cursor clusterID ]) ifTrue: [ result add: nextFrame ]		].	^ result</body><body package="COFramesystem">includes: key 	key isFrameOrFrameReference ifFalse: [ ^ false ].	key clusterID isNil ifTrue: [ ^ false ].	^ super includes: key</body></methods><methods><class-id>COAST.CoastSegmentedSet</class-id> <category>journal</category><body package="COFramesystem">journalClass	^ CoastJournalSet</body></methods><methods><class-id>COAST.CoastSegmentedKeyIndex</class-id> <category>private</category><body package="COFramesystem">segmentClass	^ CoastKeyIndexSegment</body></methods><methods><class-id>COAST.CoastSegmentedKeyIndex</class-id> <category>accessing</category><body package="COFramesystem">atKeysEmptyCompactResult	^ CompactKeyIndex new</body></methods><methods><class-id>COAST.CoastSegmentedKeyIndex</class-id> <category>journal</category><body package="COFramesystem">journalClass	^ CoastJournalKeyIndex</body></methods><methods><class-id>COAST.CoastBagSegment</class-id> <category>accessing</category><body package="COFramesystem">numberOfKeys	^ ( self at: #compactCollection ) numberOfKeys</body><body package="COFramesystem">occurrencesOf: value 	^ self at: #compactCollection occurrencesOf: value</body><body package="COFramesystem">valuesAndCountsDo: key 	( self at: #compactCollection ) valuesAndCountsDo: key</body></methods><methods><class-id>COAST.CoastBagSegment</class-id> <category>private</category><body package="COFramesystem">add: key withOccurrences: occcurrences 	^ self at: #compactCollection add: key withOccurrences: occcurrences</body><body package="COFramesystem">keysToMoveMax: max 	| done assocsToMove |	assocsToMove := OrderedCollection new: max.	done := 0.	self valuesAndCountsDo: 		[: key : count |			assocsToMove add: key -&gt; count.			done := done + 1.			done &gt;= max ifTrue: [ ^ assocsToMove ]		].</body><body package="COFramesystem">moveSomeElementsTo: newLeaf max: max 	| keysToMove |	keysToMove := self keysToMoveMax: max.	keysToMove do: 		[: assoc |			newLeaf add: assoc key withOccurrences: assoc value.			self removeAllOccurrences: assoc key		].	^ keysToMove last key</body><body package="COFramesystem">removeAllOccurrences: key 	^ self at: #compactCollection removeAllOccurrences: key</body></methods><methods><class-id>COAST.CoastBagSegment class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #compactBag</body></methods><methods><class-id>COAST.CoastSegmentedValueIndex</class-id> <category>private</category><body package="COFramesystem">segmentClass	^ CoastValueIndexSegment</body></methods><methods><class-id>COAST.CoastSegmentedValueIndex</class-id> <category>accessing</category><body package="COFramesystem">atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| lastKeys min max result sizeLeft |	lastKeys := self at: #lastKeys.	min := lastKeys coastMinIndexForInserting: ( keyPattern coastAsPatternPrefixIgnoreCase: ignoreCase ).	max := lastKeys size min: ( lastKeys coastMinIndexForInserting: ( keyPattern coastAsPostPatternPrefixIgnoreCase: ignoreCase )).	sizeLeft := ( min to: max ) inject: 0 into: [: sum : index | sum + ( self sizeAtIndex: index )].	maxSize notNil ifTrue: [ sizeLeft := sizeLeft min: maxSize ].	result := CompactRPCResultCollection clusterManager: self clusterManager.	min to: max		do: 		[: index | | added |			added := ( self segmentAtIndex: index ) atKeyPattern: keyPattern ignoreCase: ignoreCase maxSize: sizeLeft.			result compactAddAll: added.			sizeLeft := sizeLeft - added size.			sizeLeft = 0 ifTrue: [ ^ result ]		].	^ result</body><body package="COFramesystem">atKeysEmptyCompactResult	^ CompactValueIndex new</body><body package="COFramesystem">matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: maxSize 	| lastKeys min max sizeLeft result |	lastKeys := self at: #lastKeys.	min := lastKeys coastMinIndexForInserting: ( keyPattern coastAsPatternPrefixIgnoreCase: ignoreCase ).	max := lastKeys size min: ( lastKeys coastMinIndexForInserting: ( keyPattern coastAsPostPatternPrefixIgnoreCase: ignoreCase )).	result := CompactValueIndex clusterManager: self clusterManager.	sizeLeft := maxSize.	min to: max		do: 		[: index | | added |			added := ( self segmentAtIndex: index ) matchingPattern: keyPattern ignoreCase: ignoreCase maxSize: sizeLeft.			added referencesElementsCursorDo: [: cursor | result addElement: cursor copyForRefCursor ].			maxSize notNil ifTrue: 				[	result size &lt; maxSize ifFalse: [ ^ result limitToSize: maxSize ].					sizeLeft := maxSize - result size				]		].	^ result</body></methods><methods><class-id>COAST.CoastSegmentedValueIndex</class-id> <category>journal</category><body package="COFramesystem">journalClass	^ CoastJournalValueIndex</body></methods><methods><class-id>COAST.CoastJournalDictionary</class-id> <category>accessing</category><body package="COFramesystem">atKey: key 	^ self atKey: key ifAbsent: nil</body><body package="COFramesystem">atKey: key ifAbsent: absentBlock 	key coastIsValidRPCArgument ifFalse: [ ^ absentBlock value ].	^ self at: #added		atKey: key		ifAbsent: 		[( self at: #removed includes: key ) 				ifTrue: [ absentBlock value ]				ifFalse: [( self segmentedCollection atKey: key ) ifNil: absentBlock ]		]</body><body package="COFramesystem">atKey: key put: value 	| segmentedCollection |	self at: #removed remove: key.	segmentedCollection := self segmentedCollection.	( segmentedCollection suppressJournalForKey: key ) 		ifTrue: 		[	self at: #added removeKey: key.			segmentedCollection atKey: key put: value		]		ifFalse: 		[	self at: #added atKey: key put: value.			self checkJournal		].	^ value</body><body package="COFramesystem">atKeys: someKeys 	| result |	result := self segmentedCollection atKeys: someKeys.	( self at: #removed ) do: [: k | result removeKey: k ifAbsent: nil ].	( self at: #added atKeys: someKeys ) keysAndValuesDo: [: k : v | result at: k put: v ].	^ result</body><body package="COFramesystem">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COFramesystem">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues	^self atKeys: someKeys restrictToValues: rvalues</body><body package="COFramesystem">atKeys: someKeys restrictToValues: rvalues 	| result |	result := self segmentedCollection atKeys: someKeys restrictToValues: rvalues.	( self at: #removed ) do: [: k | result removeKey: k ifAbsent: nil ].	(( self at: #added ) atKeys: someKeys ) keysAndValuesDo: 		[: k : v | ( rvalues includes: v ) 				ifTrue: [ result atKey: k put: v ]				ifFalse: [ result removeKey: k ifAbsent: nil ]		].	^ result</body><body package="COFramesystem">eachKeyIn: someKeys do: eachKeyBlock 	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index. "	" default fallback implementation "	(self atKeys: someKeys) keysDo: eachKeyBlock</body><body package="COFramesystem">includesKey: key 	^ ( self at: #added includesKey: key ) or: [( self at: #removed includes: key ) not and: [ self segmentedCollection includesKey: key ]]</body><body package="COFramesystem">keys	| keys |	keys := OrderedCollection new: self size.	self keysDo: [: elem | keys add: elem ].	^ keys</body><body package="COFramesystem">removeKey: key 	^ self removeKey: key ifAbsent: nil</body><body package="COFramesystem">removeKey: key ifAbsent: absentBlock 	| value segmentedCollection |	value := self at: #added atKey: key.	value notNil ifTrue: 		[	self at: #added removeKey: key.			self at: #removed add: key.			^ value	"move from added to removed"		].	( absentBlock notNil and: [ self at: #removed includes: key ]) ifTrue: [ ^ absentBlock value ].	"already removed"	segmentedCollection := self segmentedCollection.	( segmentedCollection suppressJournalForKey: key ) ifTrue: 		[	absentBlock isNil ifTrue: [ self at: #removed remove: key ].	"absentBlock notNil and: [ self at: #removed includes: key] already checked "			^ segmentedCollection removeKey: key ifAbsent: absentBlock		].	value := absentBlock notNil 			ifTrue: [ segmentedCollection atKey: key ]			ifFalse: [ nil ].	^ ( absentBlock isNil or: [ value notNil ]) 		ifTrue: 		[	self at: #removed add: key.			self checkJournal.			value		]		ifFalse: [ absentBlock value ]</body></methods><methods><class-id>COAST.CoastJournalDictionary</class-id> <category>enumerating</category><body package="COFramesystem">associationsDo: block 	^ self keysAndValuesDo: [: k : v | block value: k -&gt; v ]</body><body package="COFramesystem">do: block 	| added removed |	added := self at: #added.	removed := self at: #removed.	( added isEmpty and: [ removed isEmpty ]) 		ifTrue: [ self segmentedCollection do: block ]		ifFalse: [ self keysAndValuesDo: [: k : v | block value: v ] added: added removed: removed ].</body><body package="COFramesystem">keysAndValuesDo: block 	| added removed |	added := self at: #added.	removed := self at: #removed.	( added isEmpty and: [ removed isEmpty ]) 		ifTrue: [ self segmentedCollection keysAndValuesDo: block ]		ifFalse: [ self keysAndValuesDo: block added: added removed: removed ].</body><body package="COFramesystem">keysAndValuesDo: block added: added removed: removed 	added keysAndValuesDo: block.	self segmentedCollection keysAndValuesDo: [: k : v | (( added includesKey: k ) or: [ removed includes: k ]) ifFalse: [ block value: k value: v ]].</body><body package="COFramesystem">keysDo: block 	| added removed |	added := self at: #added.	removed := self at: #removed.	( added isEmpty and: [ removed isEmpty ]) 		ifTrue: [ self segmentedCollection keysDo: block ]		ifFalse: [ self keysAndValuesDo: [: k : v | block value: k ] added: added removed: removed ].</body><body package="COFramesystem">referencesElementsCursorDo: block 	| added removed |	added := self at: #added.	added referencesElementsCursorDo: block.	removed := self at: #removed.	self segmentedCollection referencesElementsCursorDo: 		[: ref | (( added journalIncludesReferencedElement: ref ) or: [ removed journalIncludesReferencedElement: ref key ]) 				ifFalse: [ block value: ref ]		].</body></methods><methods><class-id>COAST.CoastJournalDictionary</class-id> <category>private</category><body package="COFramesystem">diffsBySegmentClusterID: segmentedCollection 	| segh temp |	segh := segmentedCollection segmentedCollectionHeader.	segh numberOfSegments = 0 ifTrue: [ ^ nil ].	temp := Dictionary new.	( self at: #added ) keysDo: 		[: k | | index oc |			index := segh segmentClusterIDForKey: k.			oc := temp at: index ifAbsentPut: [ OrderedCollection new ].			oc add: k		].	( self at: #removed ) do: 		[: v | | index oc |			index := segh segmentClusterIDForKey: v.			oc := temp at: index ifAbsentPut: [ OrderedCollection new ].			oc add: v		].	( temp allSatisfy: [: oc | oc size &lt;= 1 ]) ifTrue: [ ^ nil ].	^ temp</body><body package="COFramesystem">flush: keys segmentedCollection: segmentedCollection 	keys do: 		[: k | | v |			v := self at: #added atKey: k.			self at: #removed remove: k.			v notNil 				ifTrue: 				[	self at: #added removeKey: k.					segmentedCollection atKey: k put: v				]				ifFalse: [ segmentedCollection removeKey: k ]		].	^ keys size</body><body package="COFramesystem">fullFlushJournal	"return number of removed entries"	| addedSize removedSize |	removedSize := self sizeAt: #removed.	removedSize &gt; 0 ifTrue: 		[	"remove all keys"			( self at: #removed ) do: [: k | self segmentedCollection removeKey: k ].			self depleteSlot: #removed		].	addedSize := self sizeAt: #added.	addedSize &gt; 0 ifTrue: 		[	"add all (key/value)s"			( self at: #added ) keysAndValuesDo: [: k : v | self segmentedCollection atKey: k put: v ].			self depleteSlot: #added		].	CoastLog logDebug: [ 'fullFlushJournal: shrink ' , self printString , ' by ' , ( addedSize + removedSize ) printString ] channel: #journal.	^ addedSize + removedSize</body></methods><methods><class-id>COAST.CoastJournalDictionary</class-id> <category>iterating</category><body package="COFramesystem">coastAllArgumentsDo: aBlock 	self keysAndValuesDo: 		[: k : v |			aBlock value: k.			aBlock value: v		].</body></methods><methods><class-id>COAST.CoastJournalDictionary class</class-id> <category>slots</category><body package="COFramesystem">collectionSlotType	^ #compactDictionary</body><body package="COFramesystem">removedSlot	^ self slotOfType: #compactSet</body></methods><methods><class-id>COAST.CatBFWriteStream</class-id> <category>private</category><body package="COBlockFileSystem">allocateNextBlockForWriting: numberOfBytes 	^ self allocateNextBlockForWriting: numberOfBytes previousBlock: currentBlock</body><body package="COBlockFileSystem">allocateNextBlockForWriting: numberOfBytes previousBlock: previousBlock	| blk |	( preAllocatedBlocks isNil or: [ preAllocatedBlocks isEmpty ]) 		ifTrue: [ preAllocatedBlocks := self blockFileSystem createNextBlockFor: self file previousBlock: previousBlock size: numberOfBytes ].	blk := preAllocatedBlocks removeFirst.	^ blk</body><body package="COBlockFileSystem">fillBlockBuffer	" not needed, write only "</body><body package="COBlockFileSystem">getNextBlockForWriting: numberOfBytes 	" Get the next block (allocate one if necessary) "	"self blockFileSystem writeBlockHeader: blk."	| blk |	self isOpen 		ifFalse: [ ^ self closedStreamError ].	blk := self allocateNextBlockForWriting: numberOfBytes.	self currentBlock: blk.	self markDirtyBuffer.	^ blk</body><body package="COBlockFileSystem">markDirtyBuffer	currentBlock markDirty</body><body package="COBlockFileSystem">writeBackCurrentBlock	" write back the header of there current block (only if needed)"	(currentBlock notNil and: [ currentBlock needsWriteBack ])		ifTrue: [ 				currentBlock dataSize: writeLimit.			self file fileSize: position.			self blockFileSystem writeBlock: currentBlock data: self buffer.		]</body></methods><methods><class-id>COAST.CatBFWriteStream</class-id> <category>testing</category><body package="COBlockFileSystem">isWritable	^ true</body></methods><methods><class-id>COAST.CatBFWriteStream</class-id> <category>accesssing</category><body package="COBlockFileSystem">close	( self isOpen and: [ currentBlock isNil and: [ writeLimit = 0 ]]) ifTrue: [ self getNextBlockForWriting: 0 ].	^ super close</body><body package="COBlockFileSystem">next	self shouldNotImplement</body><body package="COBlockFileSystem">next: anInteger putAll: aSequenceableCollection startingAt: startIndex 	| currentToDo currentStartIndex |	currentToDo := anInteger.	currentStartIndex := startIndex.	[ currentToDo &gt; 0 ] whileTrue: 		[ | i j numWritten |			( currentBlock notNil and: [( i := self bufferPosition + 1 ) &lt;= bufferSize ]) ifFalse: 				[	self getNextBlockForWriting: currentToDo.					i := self bufferPosition + 1				].			j := bufferSize min: i + currentToDo - 1.			collection replaceFrom: i to: j with: aSequenceableCollection startingAt: currentStartIndex.			numWritten := j - i + 1.			currentStartIndex := currentStartIndex + numWritten.			currentToDo := currentToDo - numWritten.			writeLimit := j.			position := position + numWritten		].	^ aSequenceableCollection</body><body package="COBlockFileSystem">nextPut: aByte 	| i |	( currentBlock notNil and: [( i := self bufferPosition + 1 ) &lt;= bufferSize ]) 		ifTrue: 		[	writeLimit := i.			position := position + 1.			collection at: i put: aByte		]		ifFalse: 		[	" write past end of the current block "			self getNextBlockForWriting: 1.			self nextPut: aByte		].	^ aByte</body></methods><methods><class-id>COAST.CatBFWriteStream</class-id> <category>initialize-release</category><body package="COBlockFileSystem">deregister	self blockFileSystem deregisterFileWriteStream: self.</body></methods><methods><class-id>COAST.CoastJournalKeyIndex class</class-id> <category>accessing</category><body package="COFramesystem">collectionSlotType	^ #compactKeyIndex</body></methods><methods><class-id>COAST.CatBFAbortBackgroundCopySignal</class-id> <category>accessing</category><body package="COBlockFileSystem">blockFileSystemLogCopyErrorFor: aCatBFBlockfilesystem copyInfo: copyInfo 	COAST.CoastLog logWarning: copyInfo description,' of ' , aCatBFBlockfilesystem coreName printString , ' aborted'.</body></methods><methods><class-id>COAST.CoastSegmentedMixedSet</class-id> <category>accessing</category><body package="COFramesystem">* collection 	^ collection coastAsSetOrYourself select: [: e | self includes: e ]</body></methods><methods><class-id>COAST.CoastSegmentedMixedSet</class-id> <category>journal</category><body package="COFramesystem">journalClass	^ nil</body></methods><methods><class-id>COAST.CoastSegmentedMixedSet</class-id> <category>private</category><body package="COFramesystem">segmentClass	^ CoastMixedSetSegment</body></methods><methods><class-id>COAST.CoastSegmentedDictionary</class-id> <category>private</category><body package="COFramesystem">segmentClass	^ CoastDictionarySegment</body></methods><methods><class-id>COAST.CoastSegmentedDictionary</class-id> <category>accessing</category><body package="COFramesystem">atKey: key 	| index maxIndex segment |	key coastIsValidRPCArgument ifFalse: [ ^ nil ].	index := self segmentIndexForKey: key.	maxIndex := self numberOfSegments.	index &gt; maxIndex ifTrue: [ ^ nil ].	segment := self segmentAtIndex: index.	^ segment atKey: key</body><body package="COFramesystem">atKey: key ifAbsent: absentBlock 	^ ( self atKey: key ) ifNil: absentBlock</body><body package="COFramesystem">atKey: key put: value 	| size segment index |	size := self numberOfSegments.	size = 0 ifTrue: 		[	self buildSegmentWith: key -&gt; value.			^ value		].	index := ( self segmentIndexForKey: key ) min: size.	( index = size 		and: [( self isSplitSize: ( self fastAt: #sizes atIndex: index ) + 1 ) and: [( self fastAt: #lastKeys atIndex: index ) coastLessThan: key ]]) ifTrue: 		[	self buildSegmentWith: key -&gt; value.			^ value		].	segment := self segmentAtIndex: index.	segment atKey: key put: value.	self postAdd: segment index: index key: key.	^ value</body><body package="COFramesystem">atKeys: someKeys 	^ self atKeys: someKeys restrictToValues: nil</body><body package="COFramesystem">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COFramesystem">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: rvalues	^self atKeys: someKeys restrictToValues: rvalues</body><body package="COFramesystem">atKeys: someKeys restrictToValues: rvalues 	"someKeys must be compareable - otherwise a filtering would be needed"	^ ( self atKeysEmptyResult )		fillFrom: self atKeys: someKeys coastAsSortedValidKeys restrictToValues: rvalues;		yourself</body><body package="COFramesystem">atKeysEmptyCompactResult	^ CompactDictionary new</body><body package="COFramesystem">atKeysEmptyResult	^ self clusterManager isMediatorCM 		ifTrue: [ self atKeysEmptyCompactResult ]		ifFalse: [ Dictionary new ]</body><body package="COFramesystem">eachKeyIn: someKeys do: eachKeyBlock 	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index. "	" default fallback implementation "	(self atKeys: someKeys) keysDo: eachKeyBlock</body><body package="COFramesystem">includesKey: key 	| size segment index |	key coastIsValidRPCArgument ifFalse: [ ^ false ].	size := self numberOfSegments.	size = 0 ifTrue: [ ^ false ].	index := ( self segmentIndexForKey: key ) min: size.	segment := self segmentAtIndex: index.	^ segment includesKey: key</body><body package="COFramesystem">keys	| keys |	keys := OrderedCollection new: self size.	self keysDo: [: elem | keys add: elem ].	^ keys</body><body package="COFramesystem">lastReferenceBeforeIndex: index add: reference 	self lastKeyBeforeIndex: index add: reference key</body><body package="COFramesystem">removeKey: key 	^ self removeKey: key ifAbsent: nil</body><body package="COFramesystem">removeKey: key ifAbsent: absentBlock 	| size segment index |	size := self numberOfSegments.	size = 0 ifTrue: [ ^ absentBlock value ].	index := ( self segmentIndexForKey: key ) min: size.	segment := self segmentAtIndex: index.	( segment removeKey: key ) isNil ifTrue: [ ^ absentBlock value ].	self postRemove: segment index: index key: key.	^ key</body></methods><methods><class-id>COAST.CoastSegmentedDictionary</class-id> <category>enumerating</category><body package="COFramesystem">associationsDo: block 	self segmentsDo: [: segment | segment associationsDo: block ]</body><body package="COFramesystem">keysAndValuesDo: block 	self segmentsDo: [: segment | segment keysAndValuesDo: block ]</body></methods><methods><class-id>COAST.CoastSegmentedDictionary</class-id> <category>compatibility</category><body package="COFramesystem">compactElementAtIndex: index	| pos |	pos := self positionForIndex: index.	^ (self segmentAtIndex: pos x) compactElementAtIndex: pos y</body><body package="COFramesystem">positionForIndex: index	| sum segmentIndex |	sum := 0.	segmentIndex := 0.	(self at: #sizes) do: [ : size |		segmentIndex := segmentIndex + 1.		sum + size &gt;= index ifTrue: [			^ segmentIndex @ (index - sum)			].		sum := sum + size.		].	^ segmentIndex @ 0</body></methods><methods><class-id>COAST.CoastSegmentedDictionary</class-id> <category>compact</category><body package="COFramesystem">compact	"nothing to do"</body></methods><methods><class-id>COAST.CoastSegmentedDictionary</class-id> <category>journal</category><body package="COFramesystem">journalClass	^ CoastJournalDictionary</body></methods><methods><class-id>COAST.CoastSegmentedDictionary</class-id> <category>iterating</category><body package="COFramesystem">coastAllArgumentsDo: aBlock 	self keysAndValuesDo: 		[: k : v |			aBlock value: k.			aBlock value: v		].</body></methods><methods><class-id>COAST.ReadOnlyBlockFileSystem</class-id> <category>private</category><body package="COBlockFileSystem">checkWriteProtection</body><body package="COBlockFileSystem">ensureWorkingDirectory	| dir |	( dir := self workingDirectory ) exists 		ifFalse: [ self error: 'Directory ', dir asString, ' does not exist' ].</body><body package="COBlockFileSystem">ioMode	^ #readOnly</body><body package="COBlockFileSystem">truncateToCorrectSize</body><body package="COBlockFileSystem">writeBytes: bytes</body><body package="COBlockFileSystem">writeBytes: buffer startingAt: index for: count</body></methods><methods><class-id>COAST.ReadOnlyBlockFileSystem</class-id> <category>locking</category><body package="COBlockFileSystem">acquireLockFile</body><body package="COBlockFileSystem">lockBFS</body><body package="COBlockFileSystem">unlockBFS</body></methods><methods><class-id>COAST.ReadOnlyBlockFileSystem</class-id> <category>file operations</category><body package="COBlockFileSystem">create	self error: 'Read-only mode, cannot create  ', self displayString</body></methods><methods><class-id>COAST.ReadOnlyBlockFileSystem</class-id> <category>testing</category><body package="COBlockFileSystem">readOnly	^ true</body></methods><methods><class-id>COAST.ReadOnlyBlockFileSystem</class-id> <category>repair / recovery - private</category><body package="COBlockFileSystem">markAsReadOnly</body></methods><methods><class-id>COAST.CoastSegmentedBag</class-id> <category>accessing</category><body package="COFramesystem">occurrencesOf: key 	| size segment index |	size := self numberOfSegments.	size = 0 ifTrue: [ ^ 0 ].	index := self segmentIndexForKey: key.	index &gt; size ifTrue: [ ^ 0 ].	segment := self segmentAtIndex: index.	^ segment occurrencesOf: key</body><body package="COFramesystem">size	| size |	size := 0.	self segmentsDo: [: segment | size := size + segment size ].	^ size</body><body package="COFramesystem">valuesAndCountsDo: aBlock 	self segmentsDo: [: segment | segment valuesAndCountsDo: aBlock ]</body></methods><methods><class-id>COAST.CoastSegmentedBag</class-id> <category>private</category><body package="COFramesystem">segmentClass	^ CoastBagSegment</body></methods><methods><class-id>COAST.CoastSegmentedBag</class-id> <category>copying</category><body package="COFramesystem">collectionTypeForCollect	^ Bag</body></methods><methods><class-id>COAST.CoastSegmentedBag</class-id> <category>journal</category><body package="COFramesystem">journalClass	"not supported by now"	^ nil</body></methods><methods><class-id>COAST.CoastJournalKeyDictionary class</class-id> <category>slots</category><body package="COFramesystem">collectionSlotType	^ #compactKeyDictionary</body></methods><methods><class-id>COAST.CatRMApplicationLogMessage</class-id> <category>accessing</category><body package="COTransactions">applicationLog	^ applicationLog</body><body package="COTransactions">applicationLog: aCatCSApplicationLog	applicationLog := aCatCSApplicationLog</body><body package="COTransactions">receiverVolume	^ self volume</body><body package="COTransactions">volume	^ volume</body><body package="COTransactions">volume: aString	volume := aString</body></methods><methods><class-id>COAST.CatRMApplicationLogMessage</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextCoastStringPut: self volume.	self applicationLog marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COTransactions">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	volume := aStream nextCoastString.	applicationLog := CatCSApplicationLog unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CatRMApplicationLogMessage</class-id> <category>printing</category><body package="COTransactions">printOn: stream 	super printOn: stream.	stream nextPutAll: ' volume '.	volume printOn: stream</body></methods><methods><class-id>COAST.CoastSegmentedKeyDictionary</class-id> <category>private</category><body package="COFramesystem">segmentClass	^ CoastKeyDictionarySegment</body></methods><methods><class-id>COAST.CoastSegmentedKeyDictionary</class-id> <category>accessing</category><body package="COFramesystem">atKeysEmptyCompactResult	^ CompactKeyDictionary new</body></methods><methods><class-id>COAST.CoastSegmentedKeyDictionary</class-id> <category>journal</category><body package="COFramesystem">journalClass	^ CoastJournalKeyDictionary</body></methods><methods><class-id>COAST.CatCSSequence</class-id> <category>most private</category><body package="COTransactions">enableEndBlocks: bool 	enableEndBlocks := bool</body></methods><methods><class-id>COAST.CatCSSequence</class-id> <category>transaction sequences</category><body package="COTransactions">evaluateEndBlocks	enableEndBlocks ifTrue: [ super evaluateEndBlocks ]	"ifFalse: not now, later"</body></methods><methods><class-id>COAST.CatCSSequence</class-id> <category>initialize - release</category><body package="COTransactions">initialize	super initialize.	enableEndBlocks := false</body></methods><methods><class-id>COAST.CatCSSequence</class-id> <category>composing virtual cells</category><body package="COTransactions">delayOutstandingComposition: aSlot	^ aSlot computeInSequence not</body><body package="COTransactions">sequenceOrSelf	^ transactionManager transactionSequence</body></methods><methods><class-id>COAST.CatCSSequence</class-id> <category>private</category><body package="COTransactions">unloadClustersForVolumeManager: volumeManager 	"at end of sequence"</body></methods><methods><class-id>COAST.CatCSSequence</class-id> <category>execution</category><body package="COTransactions">handleOutstandingCompositions	| ts |	super handleOutstandingCompositions.	( ts := self transactionManager transactionSequence ) notNil 		ifTrue: [ self moveDelayedCompositionsTo: ts ]</body></methods><methods><class-id>COAST.CatCSSequenceTransaction</class-id> <category>accessing</category><body package="COTransactions">abort	[ super abort ] ensure: [ self wakeUpAll ].</body><body package="COTransactions">copyOutstandingCompositionsFrom: anotherTransaction	outstandingCompositions := anotherTransaction outstandingCompositions</body><body package="COTransactions">waitUntilSequenceEndSemaphore	| sem |	ownerProcess = Processor activeProcess ifTrue: [ self error: 'can not wait for transaction sequence in same process' ].	sem := Semaphore new.	waitingProcesses add: sem.	ownerProcess suspendedContext isNil ifTrue: 		[	transactionManager privateAbortTransaction.			transactionManager endTransactionSequence		].	^ sem</body><body package="COTransactions">wakeUpAll	waitingProcesses do: [: sem | sem signal ]</body></methods><methods><class-id>COAST.CatCSSequenceTransaction</class-id> <category>initialize - release</category><body package="COTransactions">initialize	super initialize.	waitingProcesses := OrderedCollection new</body></methods><methods><class-id>COAST.TransactionPartitionsPolicy</class-id> <category>api</category><body package="COTransactions">embeddedTransactionDo: aBlock 	^ self 		nonNestedEmbeddedTransactionDo: 		[	self transactionManager transactionPartitionDo: 				[: transaction |					transaction isFastRead: self isFastRead.					aBlock cull: transaction				]		]		nestedDo: aBlock</body><body package="COTransactions">embeddedTransactionDo: aBlock onFailure: aFailureBlock 	^ self 		nonNestedEmbeddedTransactionDo: 		[	self transactionManager 				transactionPartitionDo: 				[: transaction |					transaction isFastRead: self isFastRead.					aBlock cull: transaction				]				onFailure: aFailureBlock		]		nestedDo: aBlock</body><body package="COTransactions">enclosingTransactionDo: aBlock	^ self transactionManager transactionPartitions: self partitionSize do: [ aBlock value ]</body><body package="COTransactions">enclosingTransactionDo: aBlock onFailure: aFailureBlock	^ self enclosingTransactionDo: aBlock</body></methods><methods><class-id>COAST.TransactionPartitionsPolicy</class-id> <category>accessing</category><body package="COTransactions">partitionSize	^ partitionSize ifNil: [ 1000 ]</body><body package="COTransactions">partitionSize: aPartitionSize 	partitionSize := aPartitionSize.</body></methods><methods><class-id>COAST.TransactionPartitionsPolicy class</class-id> <category>instance creation</category><body package="COTransactions">transactionManager: aTransactionManager partitionSize: aPartitionSize 	^ ( self transactionManager: aTransactionManager )		partitionSize: aPartitionSize;		yourself</body><body package="COTransactions">transactionManager: aTransactionManager partitionSize: aPartitionSize isFastRead: fastRead 	^ ( self transactionManager: aTransactionManager partitionSize: aPartitionSize )		isFastRead: fastRead;		yourself</body></methods><methods><class-id>COAST.CatCSLastWishTransaction</class-id> <category>testing</category><body package="COTransactions">invalidationSuppressed	^ true</body><body package="COTransactions">isTransient	^true</body><body package="COTransactions">pessimistic	"spanning multiple clusters makes me pessimistic"	^ combinedAgenda transactionMustBePessimistic</body></methods><methods><class-id>COAST.CatCSLastWishTransaction</class-id> <category>execution</category><body package="COTransactions">propagateWith: aCatCSTransactionManager 	"only record non-empty transactions"	^self agendaNotEmpty 		ifTrue: 			[			combinedAgenda prepareCreatedCells.			self pessimistic 				ifTrue: 					["pessimistic: not allowed"					self error: 'last wishes must not be pessimistic'.]				ifFalse: 					["optimistic: here goes my last wish"						| cluster |						cluster := self involvedClusters detect: [ :blah | true ].						cluster clusterController recordLastWishTransaction: self.					].			]		ifFalse: [#accepted]</body><body package="COTransactions">suppressInvalidationWhile: aBlock	" invalidation is always suppressed "	^ aBlock value</body></methods><methods><class-id>COAST.CatCSLastWishTransaction</class-id> <category>accessing</category><body package="COTransactions">invertedFrameDo: aBlock	" no inverting at all "</body></methods><methods><class-id>COAST.SingleTransactionPolicy</class-id> <category>api</category><body package="COTransactions">embeddedTransactionDo: aBlock	" eine Transaktion fÃ¼r alles, deshalb hier keine Transaktion starten "	^ aBlock cull: self transactionManager activeTransaction</body><body package="COTransactions">embeddedTransactionDo: aBlock onFailure: aFailureBlock 	" eine Transaktion fÃ¼r alles, deshalb hier keine Transaktion starten "	^ self embeddedTransactionDo: aBlock</body><body package="COTransactions">enclosingTransactionDo: aBlock	" eine Transaktion fÃ¼r alles "	^ self transactionManager transactionDo: 		[: transaction |			transaction isFastRead: self isFastRead.			aBlock value		]</body><body package="COTransactions">enclosingTransactionDo: aBlock onFailure: aFailureBlock 	" eine Transaktion fÃ¼r alles "	^ self transactionManager 		transactionDo: 		[: transaction |			transaction isFastRead: self isFastRead.			aBlock value		]		onFailure: aFailureBlock</body></methods><methods><class-id>COAST.OutOfSequence</class-id> <category>accessing</category><body package="COTransactions">expectedBaseNumber	^ expectedBaseNumber</body><body package="COTransactions">expectedBaseNumber: aExpectedBaseNumber 	expectedBaseNumber := aExpectedBaseNumber.</body><body package="COTransactions">wrongBaseNumber	^ wrongBaseNumber</body><body package="COTransactions">wrongBaseNumber: aWrongBaseNumber 	wrongBaseNumber := aWrongBaseNumber.</body></methods><methods><class-id>COAST.OutOfSequence</class-id> <category>printing</category><body package="COTransactions">printOn: aStream	aStream nextPutAll: self class name; space.		aStream nextPutAll: 'Based on local seqNum '.	wrongBaseNumber printOn: aStream.	aStream nextPutAll: ' accepted seqNum is '.	expectedBaseNumber printOn: aStream.</body></methods><methods><class-id>COAST.OutOfSequence class</class-id> <category>instance creation</category><body package="COTransactions">expectedBaseNumber: expected wrongBaseNumber: wrong	^self new		expectedBaseNumber: expected;		wrongBaseNumber: wrong;		yourself</body></methods><methods><class-id>COAST.CatCSVolatileTransaction</class-id> <category>accessing</category><body package="COTransactions">continueTransaction: aCatCSTransaction</body></methods><methods><class-id>COAST.CatCSVolatileTransaction</class-id> <category>rolling</category><body package="COTransactions">evaluateFailureBlocks</body></methods><methods><class-id>COAST.CatCSVolatileTransaction</class-id> <category>execution</category><body package="COTransactions">finishForVolumeManager: volumeManager	" The main part of the transaction is finished. Now do everything necessary to properly	complete the transaction - i.e. rollback everything ;-)"	self abort.</body><body package="COTransactions">propagateWith: aCatCSTransactionManager	^ #accepted</body></methods><methods><class-id>COAST.OuterTransactionPolicy</class-id> <category>api</category><body package="COTransactions">discreteTransactionDo: aBlock	^ aBlock cull: self transactionManager activeTransaction</body><body package="COTransactions">discreteTransactionDo: aBlock onFailure: aFailureBlock 	| transaction |	transaction := self transactionManager activeTransaction.	aFailureBlock notNil ifTrue: [ transaction addFailureBlock: aFailureBlock ].	^ aBlock cull: transaction</body><body package="COTransactions">embeddedTransactionDo: aBlock	^ aBlock cull: self transactionManager activeTransaction</body><body package="COTransactions">embeddedTransactionDo: aBlock onFailure: aFailureBlock 	^ self embeddedTransactionDo: aBlock</body><body package="COTransactions">enclosingTransactionDo: aBlock	^ aBlock value</body><body package="COTransactions">enclosingTransactionDo: aBlock onFailure: aFailureBlock	^ aBlock value</body></methods><methods><class-id>COAST.MultipleTransactionsPolicy</class-id> <category>api</category><body package="COTransactions">embeddedTransactionDo: aBlock 	" fÃ¼r jeden Teil eine neue Transakton starten "	^ self 		nonNestedEmbeddedTransactionDo: 		[	self transactionManager transactionDo: 				[: transaction |					transaction isFastRead: self isFastRead.					aBlock cull: transaction				]		]		nestedDo: aBlock</body><body package="COTransactions">embeddedTransactionDo: aBlock onFailure: aFailureBlock 	" fÃ¼r jeden Teil eine neue Transakton starten "	^ self 		nonNestedEmbeddedTransactionDo: 		[	self transactionManager 				transactionDo: 				[: transaction |					transaction isFastRead: self isFastRead.					aBlock cull: transaction				]				onFailure: aFailureBlock		]		nestedDo: aBlock</body><body package="COTransactions">enclosingTransactionDo: aBlock	" mehrere Transaktionen, deshalb hier keine Transaktionen starten "	^ aBlock value</body><body package="COTransactions">enclosingTransactionDo: aBlock onFailure: aFailureBlock	" mehrere Transaktionen, deshalb hier keine Transaktionen starten "	^ aBlock value</body></methods><methods><class-id>COAST.CatCSPessimisticTransaction</class-id> <category>accessing</category><body package="COTransactions">pessimistic	"spanning multiple clusters makes me pessimistic"	^true.</body></methods><methods><class-id>COAST.CatDMDisplayTransaction</class-id> <category>testing</category><body package="COTransactions">canWrite	^ false</body><body package="COTransactions">isDisplayTransaction	^true</body></methods><methods><class-id>COAST.CatDMDisplayTransaction</class-id> <category>accessing</category><body package="COTransactions">continueTransaction: aCatCSTransaction</body><body package="COTransactions">inDisplayPhase	^true "allways ;-)"</body><body package="COTransactions">propagateWith: aCatCSTransactionManager	^ #accepted</body><body package="COTransactions">unloadClustersForVolumeManager: volumeManager 	"better not"</body></methods><methods><class-id>COAST.CatDMDisplayTransaction</class-id> <category>agenda handling</category><body package="COTransactions">recordCellCreation: aCatCSCell 	" this should not happen. local cells do no need to be recorded,	shared cells cannot be created in display transactions "	aCatCSCell makeLocal.</body></methods><methods><class-id>COAST.CatRMTryAndTell</class-id> <category>accessing</category><body package="COTransactions">addLoggedTransactionAgenda: aValue	loggedTransactionAgendas add: aValue</body><body package="COTransactions">applicationLog	applicationLog isNil		ifTrue: [ applicationLog := CatCSApplicationLog new ].	^ applicationLog</body><body package="COTransactions">applicationLog: aCatCSApplicationLog	applicationLog := aCatCSApplicationLog</body><body package="COTransactions">loggedTransactionAgendas	^loggedTransactionAgendas</body><body package="COTransactions">receiver	"answer the first cluster locator"	^loggedTransactionAgendas first transactionID clusterLocator</body><body package="COTransactions">receiverVolume	^self receiver volume</body></methods><methods><class-id>COAST.CatRMTryAndTell</class-id> <category>initialize</category><body package="COTransactions">initialize	loggedTransactionAgendas := OrderedCollection new</body></methods><methods><class-id>COAST.CatRMTryAndTell</class-id> <category>marshalling</category><body package="COTransactions">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextOptimized32Put: loggedTransactionAgendas size.	loggedTransactionAgendas do: 		[: eachAgenda | | subMarshall |			subMarshall := aCatRMMarshall copy.			subMarshall currentClusterID: eachAgenda agenda cluster clusterID.			subMarshall clusterManager: eachAgenda agenda cluster clusterManager.			eachAgenda marshallBinaryTo: aStream marshaller: subMarshall		].	self applicationLog marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COTransactions">unmarshallMessageFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager 	aStream nextOptimized32 timesRepeat: 		[ | newAgenda |			newAgenda := CatRMLoggedTransactionAgenda new.			newAgenda unmarshallAgendaFrom: aStream marshaller: aCatRMMarshall withVolumeManager: aCatCSVolumeManager.			self addLoggedTransactionAgenda: newAgenda		].	applicationLog := CatCSApplicationLog unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall.</body></methods><methods><class-id>COAST.CatRMTryAndTell class</class-id> <category>instance creation</category><body package="COTransactions">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>COAST.CatRMSkippingAgendaChecker</class-id> <category>checking</category><body package="COTransactions">isValidAgenda: agenda cluster: cluster 	"scan the agenda for accesses without slot or frame"	^ true	"skip the check"</body></methods><methods><class-id>COAST.CatCSSmallTransaction</class-id> <category>initialize - release</category><body package="COTransactions">initialSizeForAccesses	^ 10</body></methods><methods><class-id>COAST.CatRMAgendaChecker</class-id> <category>private</category><body package="COTransactions">addSlotForFrameOf: access in: frameSlotDict cluster: cluster 	( self slotNamesForFrameOf: access in: frameSlotDict cluster: cluster ) add: access slotName asSymbol</body><body package="COTransactions">assertNewFrameCreation: frameCreation in: cluster	(cluster directTableAccessAt: frameCreation frameID) notNil		ifTrue: [ self error: 'Frame already exists: ' , frameCreation printString ]</body><body package="COTransactions">assertSlotForFrameOf: access in: frameSlotDict cluster: cluster 	| slots |	slots := self slotNamesForFrameOf: access in: frameSlotDict cluster: cluster.	access accessClass = COAST.CatCSDepleteAccess 		ifFalse: [( slots includes: access slotName asSymbol ) ifFalse: [ self error: 'Missing slot for ' , access printString ]].</body><body package="COTransactions">slotNamesForFrameOf: access in: frameSlotDict cluster: cluster 	^ frameSlotDict at: access frameID		ifAbsentPut: 		[ | frame |			frame := cluster directTableAccessAt: access frameID.			frame isNil ifTrue: [ self error: 'Missing frame for ' , access printString , ' in cluster ' , cluster printString ].			frame basicSlots inject: ( IdentitySet new: frame basicSlots size )				into: 				[: slotNames : slot |					slot isNil ifTrue: [ self error: 'Missing slot for ' , access printString , ' in cluster ' , cluster printString ].					slotNames add: slot id.					slotNames				]		]</body></methods><methods><class-id>COAST.CatRMAgendaChecker</class-id> <category>checking</category><body package="COTransactions">check: agenda against: cluster 	| frameSlotDict |	frameSlotDict := IdentityDictionary new: cluster numberOfFrames + agenda frameCreations size.	agenda frameCreations do: 		[: fc |			self assertNewFrameCreation: fc in: cluster.			frameSlotDict at: fc frameID put: IdentitySet new		].	agenda slotCreations do: [: sc | self addSlotForFrameOf: sc in: frameSlotDict cluster: cluster ].	agenda slotWriteAccesses do: [: wa | self assertSlotForFrameOf: wa in: frameSlotDict cluster: cluster ].	^ true</body><body package="COTransactions">isValidAgenda: agenda cluster: cluster 	"scan the agenda for accesses without slot or frame"	^ [ self check: agenda against: cluster ] 		on: CoastInvalidAccessError		do: 		[: ex |			self haltOrContinue.			CoastLog logError: 'Sanity check failed: ' , ex description.			false		]</body></methods><methods><class-id>COAST.CatRMAgendaChecker class</class-id> <category>accessing</category><body package="COTransactions">errorSignal	^ CoastInvalidAccessError</body></methods><methods><class-id>COAST.BestSingleTransactionPolicy</class-id> <category>api</category><body package="COTransactions">discreteTransactionDo: aBlock	^ self transactionManager bestTransactionDo: aBlock</body><body package="COTransactions">discreteTransactionDo: aBlock onFailure: aFailureBlock 	^ self transactionManager bestTransactionDo: aBlock onFailure: aFailureBlock</body><body package="COTransactions">embeddedTransactionDo: aBlock	^ aBlock cull: self transactionManager activeTransaction</body><body package="COTransactions">embeddedTransactionDo: aBlock onFailure: aFailureBlock	^ self embeddedTransactionDo: aBlock</body><body package="COTransactions">enclosingTransactionDo: aBlock	^ self transactionManager bestTransactionDo: aBlock</body><body package="COTransactions">enclosingTransactionDo: aBlock onFailure: aFailureBlock	^ self transactionManager bestTransactionDo: aBlock onFailure: aFailureBlock</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>COAST</category><body package="COUtilities">coastCopyFile: sourceFilename to: targetFilename 	| status |	status := self CopyFile: sourceFilename asString copyToHeapUnicode newFileName: targetFilename asString copyToHeapUnicode failIfExists: 0.	status = 0 		ifTrue: [ OsError raiseSignal: 'CopyFile ' , sourceFilename tail , ' to ' , targetFilename tail , ' failed' ].</body><body package="COUtilities">coastFreePhysicalMemory	"OSSystemSupport concreteClass new coastFreePhysicalMemory"	^ [ 		self coastMemory: #ullAvailPhys	] on: Error do: [ : ex |		COAST.CoastLog logException: ex message: 'Unable to detect free physical memory'.		super coastFreePhysicalMemory	].</body><body package="COUtilities">coastMemory: memberSymbol	| mem |	mem := MEMORYSTATUSEX gcMalloc.	mem zeroFill.	mem memberAt: #dwLength put: MEMORYSTATUSEX sizeof.	self GlobalMemoryStatus: mem.	^ mem memberAt: memberSymbol</body><body package="COUtilities">coastSystemUserName	^ super coastSystemUserName ifNil: [ self getVariable: 'USERNAME' ifAbsent: nil ]</body><body package="COUtilities">coastTotalPhysicalMemory	"OSSystemSupport concreteClass new coastTotalPhysicalMemory"	^ [		self coastMemory: #ullTotalPhys	] on: Error do: [ : ex |		COAST.CoastLog logException: ex message: 'Unable to detect available physical memory'.		super coastTotalPhysicalMemory	].</body><body package="COUtilities">currentUserName	| buffPtr nSize buffer |	buffer := ByteString new: 257.	buffPtr := buffer gcCopyToHeap.	nSize := 256 gcCopyToHeap.	self GetUserNameW: buffPtr with: nSize.	^buffPtr copyUnicodeStringFromHeap</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>types</category><body package="COUtilities">DWORDLONG	&lt;C: typedef long long DWORDLONG&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>structs</category><body package="COUtilities">MEMORYSTATUS	&lt;C: struct MEMORYSTATUS {		  DWORD dwLength; 		  DWORD dwMemoryLoad; 		  DWORD dwTotalPhys; 		  DWORD dwAvailPhys; 		  DWORD dwTotalPageFile; 		  DWORD dwAvailPageFile; 		  DWORD dwTotalVirtual; 		  DWORD dwAvailVirtual; 	} &gt;</body><body package="COUtilities">MEMORYSTATUSEX	&lt;C: struct MEMORYSTATUSEX {		  DWORD dwLength; 		  DWORD dwMemoryLoad; 		  DWORDLONG ullTotalPhys; 		  DWORDLONG ullAvailPhys; 		  DWORDLONG ullTotalPageFile; 		  DWORDLONG ullAvailPageFile; 		  DWORDLONG ullTotalVirtual; 		  DWORDLONG ullAvailVirtual; 		  DWORDLONG ullAvailExtendedVirtual;	} &gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>constants</category><body package="COUtilities">MOVEFILE_COPY_ALLOWED	^2</body><body package="COUtilities">MOVEFILE_DELAY_UNTIL_REBOOT	^4</body><body package="COUtilities">MOVEFILE_REPLACE_EXISTING	^1</body><body package="COUtilities">MOVEFILE_WRITE_THROUGH	^8</body></methods><methods><class-id>OS.OSSystemSupport</class-id> <category>COAST</category><body package="COUtilities">coastCopyFile: sourceFilename to: targetFilename 	sourceFilename copyTo: targetFilename</body></methods><methods><class-id>OS.OSSystemSupport</class-id> <category>accessing</category><body package="COUtilities">coastFreePhysicalMemory	^ nil</body><body package="COUtilities">coastMaxMemory	| coastPhysicalMemory |	coastPhysicalMemory := self coastTotalPhysicalMemory.	^ coastPhysicalMemory notNil 		ifTrue: 		[	ObjectMemory is64Bit 				ifTrue: [ coastPhysicalMemory ]				ifFalse: [ coastPhysicalMemory min: 2147483648 ]		]		ifFalse: [ 2147483648 ]</body><body package="COUtilities">coastSystemUserName	^ self getVariable: 'COASTUSER' ifAbsent: nil</body><body package="COUtilities">coastTotalPhysicalMemory	^ nil</body><body package="COUtilities">currentUserName	"dunno"	^''</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>debug</category><body package="COUtilities">coastParcelVersionStringsDo: block 	| tmp |	tmp := self parcels select: [: p | p name notNil and: [ p version notNil ]].	tmp := tmp asSortedCollection: [: p1 : p2 | p1 name &lt; p2 name ].	tmp do: [: parcel | block value: parcel name , ' / ' , parcel version ].</body></methods><methods><class-id>Core.Object class</class-id> <category>accessing</category><body package="COUtilities">coastSkipHaltOrContinue	^ CoastSkipHaltOrContinue == true</body><body package="COUtilities">coastSkipHaltOrContinue: aBoolean	"self coastSkipHaltOrContinue: true"	"self coastSkipHaltOrContinue: false"	CoastSkipHaltOrContinue := aBoolean</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="COUtilities">asIniString	" default represenation of this object in an INI file "	^ self displayString asIniString</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COUtilities">callStackArgumentString	^self printString</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="COUtilities">callStackStringOfSize: anInteger	^ thisContext printStackFrom: 2 to: 2 + anInteger.</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COUtilities">coastIsNumber	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COUtilities">coastSkipHaltOrContinue	^ self class coastSkipHaltOrContinue</body></methods><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="COUtilities">haltOrContinue: aString	Notifier isDevelopment		ifTrue: [ 			self coastSkipHaltOrContinue				ifTrue: [ COAST.CoastLog logWarning: 'haltOrContinue in ', thisContext sender printString,': ', aString ]				ifFalse: [ self halt: aString.  ]		]</body><body package="COUtilities">haltOrError	self haltOrError: 'unspecified error'.</body><body package="COUtilities">haltOrError: aString	Notifier isDevelopment		ifTrue: [ self halt: aString. ]		ifFalse: [ self error: 'internal error: ', aString. ].</body><body package="COUtilities">logOrNotify: aString 	| headLess |	aString isString ifFalse: [ ^ self ].	headLess := false.	#{HeadlessImage} ifDefinedDo: [: hli | headLess := hli default isHeadless ].	headLess 		ifTrue: [ COAST.CoastLog log: aString; cr ]		ifFalse: [ Dialog warn: aString ]</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="COUtilities">coastBufferSize: bufferSize	" ignored by unbuffered streams "</body><body package="COUtilities">coastOsOutputExceptionOriginator	^ self</body><body package="COUtilities">coastTransfer: numberOfBytes to: writeStream	" returns the number of bytes actually transferred "	| numTransferred |	numTransferred := 0.	1 to: numberOfBytes do: [ : i |		self atEnd ifTrue: [ ^ numTransferred ].		writeStream nextPut: self next.		numTransferred := numTransferred + 1.	].	^ numTransferred</body><body package="COUtilities">coastTransferAllTo: writeStream	[ self atEnd ] whileFalse: [		writeStream nextPut: self next	].</body></methods><methods><class-id>Core.Timestamp</class-id> <category>printing</category><body package="COUtilities">coastIniPrintString	| aStream |	aStream := WriteStream on: ( String new: 32 ).	self year printOn: aStream paddedWith: $0 to: 4 base: 10.	aStream nextPut: Character space.	self month printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: Character space.	self dayOfMonth printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: Character space.	self hour printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $:.	self minute printOn: aStream paddedWith: $0 to: 2 base: 10.	^ aStream contents</body><body package="COUtilities">coastLogFilePrintOn: aStream 	self year printOn: aStream.	aStream nextPut: $-.	self month printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $-.	self dayOfMonth printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $-.	self hour printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $-.	self minute printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $-.	self second printOn: aStream paddedWith: $0 to: 2 base: 10.</body><body package="COUtilities">remainingPrintString	| aStream |	aStream := WriteStream on: ( String new: 32 ).	self remainingPrintStringOn: aStream.	^ aStream contents</body><body package="COUtilities">remainingPrintStringOn: aStream 	self dayOfMonth &gt; 1 		ifTrue: 		[	aStream				print: self dayOfMonth - 1;				space; nextPutAll: ( #dayOrDaysMLS &lt;&lt; #mls &gt;&gt; 'Day(s)' ) asString; space		].	self hour &gt; 0 		ifTrue: 		[	aStream				print: self hour;				space; nextPutAll: ( self hour &gt; 1 							ifTrue: [ ( #hoursMLS &lt;&lt; #mls &gt;&gt; 'hours' ) asString ]							ifFalse: [ ( #hourMLS &lt;&lt; #mls &gt;&gt; 'Hour' ) asString ]); space		].	self dayOfMonth &gt; 1 		ifTrue: [ ^ self ].	self minute &gt; 0 		ifTrue: 		[	aStream				print: self minute;				space; nextPutAll: ( self minute &gt; 1 							ifTrue: [ ( #minutesMLS &lt;&lt; #mls &gt;&gt; 'Minutes' ) asString ]							ifFalse: [ ( #minuteMLS &lt;&lt; #mls &gt;&gt; 'Minute' ) asString ]); space		].	( self hour = 0 and: [ self minute &lt; 10 and: [ self second &gt; 0 or: [ self minute = 0 ]]]) 		ifTrue: 		[( self second = 0 and: [ self millisecond &gt; 0 ]) 				ifTrue: 				[	aStream print: self millisecond;						space; nextPutAll: ( #millisecondsMLS &lt;&lt; #mls &gt;&gt; 'Milliseconds' ) asString				]				ifFalse: 				[	aStream print: self second;						space; nextPutAll: (( self second = 0 or: [ self second &gt; 1 ]) 									ifTrue: [ ( #secondsMLS &lt;&lt; #mls &gt;&gt; 'Seconds' ) asString ]									ifFalse: [ ( #secondMLS &lt;&lt; #mls &gt;&gt; 'Second' ) asString ])				]		].</body></methods><methods><class-id>OS.BufferedExternalStream</class-id> <category>accessing</category><body package="COUtilities">coastBufferSize: bufferSize 	" see #setupBufferAndLimits "	( readLimit = 0 and: [ writeLimit = -1 ]) 		ifTrue: [ self coastUncheckedBufferSize: bufferSize ]		ifFalse: [ COAST.CoastLog logWarning: 'Stream ' , self printString , ' already in use, cannot change buffer size' ].</body><body package="COUtilities">coastOsOutputExceptionOriginator	^ self ioConnection coastOsOutputExceptionOriginator</body><body package="COUtilities">coastTransfer: numberOfBytes to: writeStream 	| toDo transferSize startIndex |	binary 		ifFalse: [ ^ super coastTransfer: numberOfBytes to: writeStream ].	toDo := numberOfBytes.	[ toDo &lt;= 0 or: [ self atEnd ]] whileFalse: 		[	startIndex := position &lt; readLimit 					ifTrue: [ position + 1 ]					ifFalse: 					[	self nextBuffer.						1					].			transferSize := toDo min: readLimit - startIndex + 1.			writeStream next: transferSize putAll: collection startingAt: startIndex.			toDo := toDo - transferSize.			self skip: transferSize		].	^ numberOfBytes - toDo</body><body package="COUtilities">coastTransferAllTo: writeStream	[ self atEnd ] whileFalse: [		| transferSize |		transferSize := readLimit - position .		writeStream next: transferSize putAll: collection startingAt: position + 1.		self skip: transferSize	].</body><body package="COUtilities">coastUncheckedBufferSize: bufferSize 	ioBuffer coastBufferSize: bufferSize.	collection := ioBuffer buffer.</body></methods><methods><class-id>Kernel.Context</class-id> <category>printing</category><body package="COUtilities">coastHomeClass	^ method ifNotNil: [: m | m homeMethod ifNotNil: [ : hm | hm mclass ]]</body><body package="COUtilities">coastPrintStack	"thisContext coastPrintStack"	"self halt"	^ self printStackFrom: 2 to: 30.</body><body package="COUtilities">coastPrintStackOfSize: anInteger	"thisContext coastPrintStackOfSize: 50"	"self halt"	^ self printStackFrom: 2 to: 2 + anInteger.</body><body package="COUtilities">printStackFrom: start to: stop	| stackStream |	stackStream := WriteStream on: (String new: 400).	self printStackFrom: start to: stop startingAt: 1 on: stackStream.	^stackStream contents</body><body package="COUtilities">printStackFrom: start to: stop on: stackStream 	self printStackFrom: start to: stop startingAt: 1 on: stackStream</body><body package="COUtilities">printStackFrom: start to: stop startingAt: i on: stackStream 	| n |	i &gt; stop ifTrue: [^self].	i &gt;= start 		ifTrue: 			[stackStream print: self.			n := method notNil ifTrue: [method numArgs] ifFalse: [stackp].			n &gt; 0 				ifTrue: 					[stackStream nextPutAll: ' ('.										[(1 to: n) do: 							[:j | 							| s |							s := (stack at: j) callStackArgumentString.							s isCharacters ifTrue: [stackStream nextPutAll: s]]						separatedBy: [stackStream nextPutAll: ', ']] 							on: Error							do: [:ex | stackStream nextPutAll: 'Error while printing arguments'].					stackStream nextPut: $)].			stackStream cr].	self sender notNil 		ifTrue: 			[self sender 				printStackFrom: start				to: stop				startingAt: i + 1				on: stackStream]</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>accessing</category><body package="COUtilities">coastTransfer: numberOfBytes to: writeStream 	^ self optimizeBinaryBulkOperations 		ifTrue: [ self coreStream coastTransfer: numberOfBytes to: writeStream ]		ifFalse: [ super coastTransfer: numberOfBytes to: writeStream ]</body><body package="COUtilities">coastTransferAllTo: writeStream	^ self optimizeBinaryBulkOperations 		ifTrue: [ self coreStream coastTransferAllTo: writeStream ]		ifFalse: [ super coastTransferAllTo: writeStream ]</body><body package="COUtilities">coreStream	^ stream</body><body package="COUtilities">next: anInteger putAll: aSequenceableCollection startingAt: startIndex 	"Store the anInteger elements of aSequenceableCollection starting	at startIndex into the next anInteger elements of the receiver.	Answer aSequenceableCollection"	^ self optimizeBinaryBulkOperations		ifTrue: [ self coreStream next: anInteger putAll: aSequenceableCollection startingAt: startIndex ]		ifFalse: [ super next: anInteger putAll: aSequenceableCollection startingAt: startIndex ]</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>testing</category><body package="COUtilities">optimizeBinaryBulkOperations	^binary and: [ self class == EncodedStream ]</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="COUtilities">asDurationDefaultUnit: aUnitSelector	" in Duration umwandeln "	^ self perform: aUnitSelector</body></methods><methods><class-id>Core.Number</class-id> <category>testing</category><body package="COUtilities">coastIsNumber	^ true</body></methods><methods><class-id>Core.Number</class-id> <category>printing</category><body package="COUtilities">coastShortByteSizePrintOn: stream 	| suffixes index percent |	suffixes := #( 'KB' 'MB' 'GB' ).	index := self &gt; 0 			ifTrue: [( self log: 2 ) // 10 ]			ifFalse: [ 0 ].	index &gt;= 1 		ifTrue: 		[	index := index min: suffixes size.			percent := (( self * 100 / ( 2 raisedTo: index * 10 )) rounded / 100 ) asFloat.			percent printOn: stream.			stream space.			stream nextPutAll: ( suffixes at: index )		]		ifFalse: 		[	self printOn: stream.			stream nextPutAll: ' Bytes'		].</body><body package="COUtilities">coastShortByteSizePrintString	| stream |	stream := String new writeStream.	self coastShortByteSizePrintOn: stream.	^ stream contents</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>initializing</category><body package="COUtilities">setupSeparableFileTranscript: maxLogSize 	"The Transcript is handled differently when the image is headless versus 	headful. In headless mode, the Transcript can go to either standard out, a file, or both"	"First, clean out any old file transcripts"	Transcript dependents do: 		[: each | ( each isKindOf: FileTranscript ) ifTrue: 				[	Transcript removeDependent: each.					each release				]		].	self shouldSendTranscriptToStandardOut 		ifTrue: 		[( Transcript dependents includes: StandardOutTranscript current ) ifFalse: [ Transcript addDependent: StandardOutTranscript current ]		]		ifFalse: [ Transcript removeDependent: StandardOutTranscript current ].	self shouldSendTranscriptToFile 		ifTrue: [ Transcript addDependent: ( COAST.SeparableFileTranscript named: self transcriptFilename maxLogSize: maxLogSize )].</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="COUtilities">trimWhitespaces	"Return a copy of the receiver that has leading and trailing whitespaces removed."	| size index whitespaces |	whitespaces := #(9 10 13 32).	(size := self size) == 0 ifTrue: [^self].	index := 1.	[ whitespaces includes: (self at: index) asInteger ] whileTrue: [		index = size ifTrue: [^''].		index := index + 1].	[ whitespaces includes: (self at: size) asInteger ] whileTrue: [		index = size ifTrue: [^''].		size := size - 1].	^self copyFrom: index to: size</body></methods><methods><class-id>OS.SolarisSocketAccessor</class-id> <category>options</category><body package="COUtilities">tcpSetKeepAlive 	"at least Solaris 10 x86 does not like keepalive on tcp sockets as non-root"	^ [ super tcpSetKeepAlive ] on: OsIllegalOperation do: [ : ex | ex return ]</body></methods><methods><class-id>OS.ExternalReadAppendStream</class-id> <category>accessing</category><body package="COUtilities">coastBufferSize: bufferSize	super coastBufferSize: bufferSize.	writeStream coastBufferSize: bufferSize.</body></methods><methods><class-id>OS.LinuxSocketAccessor</class-id> <category>options</category><body package="COUtilities">coastConfigureSocket	self coastTryReuseaddr.</body></methods><methods><class-id>Kernel.MediumGrainMemoryPolicy</class-id> <category>accessing</category><body package="COUtilities">addDumpInfoTo: aStream 	aStream nextPutAll: 'Memory policy: '; nextPutAll: self class fullName asString; cr.	aStream tab; nextPutAll: 'growth regime: ' , self growthRegimeUpperBound coastShortByteSizePrintString; cr.	aStream tab; nextPutAll: 'preferred growth: ' , self preferredGrowthIncrement coastShortByteSizePrintString; cr.	aStream tab; nextPutAll: 'max memory bound: ' , self memoryUpperBound coastShortByteSizePrintString; cr.	aStream tab; nextPutAll: 'free memory bound: ' , self freeMemoryUpperBound coastShortByteSizePrintString; cr.	aStream tab; nextPutAll: 'allocated memory: ' , ObjectMemory dynamicallyAllocatedFootprint coastShortByteSizePrintString; cr.	aStream tab; nextPutAll: 'hard low space limit: ' , ObjectMemory hardLowSpaceLimit coastShortByteSizePrintString; cr.	aStream cr.</body></methods><methods><class-id>Kernel.MediumGrainMemoryPolicy</class-id> <category>growing memory</category><body package="COUtilities">allocatedMemory	"ObjectMemory currentMemoryPolicy allocatedMemory"	| om |	om := ObjectMemory current.	^ om edenUsedBytes + om survUsedBytes + om largeUsedBytes + om oldDataBytes + ( om otEntriesToBytes: om oldOTEs ) + om permDataBytes 		+ ( om otEntriesToBytes: om permOTEs )</body></methods><methods><class-id>Kernel.MediumGrainMemoryPolicy</class-id> <category>accessing</category><body package="COUtilities">emergencyLowSpaceBlock: aEmergencyLowSpaceBlock 	" Hook for registering a block that is evaluated in low space conditions "</body></methods><methods><class-id>UI.TextCollector</class-id> <category>accessing</category><body package="COUtilities">&lt;&lt; anObject	anObject isCharacters		ifTrue: [ self show: anObject ]		ifFalse: [ self show: anObject printString ]</body></methods><methods><class-id>UI.TextCollector</class-id> <category>entry control</category><body package="COUtilities">closeCollector	" close resources associated with the collector "	self flush.</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="COUtilities">fromCoastDurationString: string 	"this reader eats a lot:		120 ==&gt; 120 secs ==&gt; 2:00		100: ==&gt; 100 minutes ==&gt; 1:40:00		1:: ==&gt; 1 hour ==&gt; 1:00:00"	| seconds stream |	seconds := 0.	stream := string readStream.	[ stream atEnd ] whileFalse: [ seconds := seconds * 60 + ( stream upTo: $: ) asInteger ].	string last = $: ifTrue: [ seconds := seconds * 60 ].	^ Time fromSeconds: seconds</body></methods><methods><class-id>Core.Time</class-id> <category>printing</category><body package="COUtilities">coastDurationPrintString	| stream |	stream := String new writeStream.	hours &gt; 0 ifTrue: 		[	hours printOn: stream.			stream nextPut: $:		].	minutes printOn: stream paddedWith: $0 to: 2 base: 10.	stream nextPut: $:.	seconds printOn: stream paddedWith: $0 to: 2 base: 10.	^ stream contents</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>accessing</category><body package="COUtilities">coastConfigureStream: externalStream	self coastStreamBufferSize ifNotNil: [ : bufferSize | externalStream coastBufferSize: bufferSize ]</body><body package="COUtilities">coastDefaultNoDelay	^ true</body><body package="COUtilities">coastDefaultWindowSize	^ 65536</body><body package="COUtilities">coastNoDelay	^ CoastNoDelay</body><body package="COUtilities">coastNoDelay: aBoolean	CoastNoDelay  := aBoolean</body><body package="COUtilities">coastStreamBufferSize	^ CoastStreamBufferSize</body><body package="COUtilities">coastStreamBufferSize: anInteger 	" 0 = default "	CoastStreamBufferSize := anInteger &gt; 0 			ifTrue: [ anInteger ]			ifFalse: [ nil ].</body><body package="COUtilities">coastWindowSize	^ CoastWindowSize</body><body package="COUtilities">coastWindowSize: anInteger	" 0 = dont set window size "	CoastWindowSize := anInteger &gt; 0 ifTrue: [ anInteger ] ifFalse: [ nil ]</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>instance creation</category><body package="COUtilities">hostnameAndPortNumFrom: hostAndPort	| port nameParts hostname |	nameParts := hostAndPort tokensBasedOn: $:.	hostname := nameParts at: 1.	port := nameParts size &gt; 1		ifTrue: [	(nameParts at: 2) asNumber ]		ifFalse: [ nil ].	^hostname -&gt; port</body><body package="COUtilities">newCoastClientToHost: hname port: pnum	^ self newTCPclientToHost: hname port: pnum windowSize: self coastWindowSize</body><body package="COUtilities">newCoastServerAtPort: pnumOrNil 	" pnumOrNil = nil -&gt; use any port "	| skt sa ws |	skt := self family: self AF_INET type: self SOCK_STREAM.	[	(( ws := self coastWindowSize ) notNil and: [ ws &gt; 0 ]) 			ifTrue: [ skt coastTryTCPWindowSize: ws ].		skt coastConfigureSocket.		self coastNoDelay ifNotNil: [: noDelay | skt coastTryTCPNoDelay: noDelay ].		skt coastTryTCPSetKeepAlive	] on: Error do: [: ex | COAST.CoastLog logWarning: 'Unable to set (optional) socket options (' , ex description , ')' ].	[			[	sa := pnumOrNil notNil 					ifTrue: [ IPSocketAddress hostAddress: IPSocketAddress thisHost port: pnumOrNil ]					ifFalse: [ IPSocketAddress thisHostAnyPort ].			skt bindTo: sa		] ifCurtailed: [ skt close ]	] 		on: OSErrorHolder existingReferentSignal		do: 		[: ex |			pnumOrNil notNil 				ifTrue: [ COAST.CoastLog logError: 'Port ' , pnumOrNil printString , ' is already in use! (' , ex description , ')' ]				ifFalse: [ COAST.CoastLog logError: 'Could not open port: ' , ex description ].			^ nil		].	^ skt</body><body package="COUtilities">newReusableTCPserverAtPort: pnum 	"Create an instance prepared to be a TCP server at the specified port."	| skt sa |	skt := self family: (SocketAddress domainCodeFromName: #afInet)				type: self sockStream.	[ skt setOptionsLevel: self solSocket name: self soReuseaddr value: 1 ] on: Error do: [].	[sa := IPSocketAddress hostAddress: IPSocketAddress thisHost port: pnum.	skt bindTo: sa]		valueOnUnwindDo: [skt close].	^skt</body><body package="COUtilities">newTCPclientToHost: hname port: pnum windowSize: windowSize 	"Create a client socket connected to host hname/port pnum"	| skt fa |	skt := self family: self AF_INET type: self SOCK_STREAM.	( windowSize notNil and: [ windowSize &gt; 0 ]) 		ifTrue: [ skt coastTryTCPWindowSize: windowSize ].	[	fa := IPSocketAddress hostName: hname port: pnum.		skt connectTo: fa	] ifCurtailed: [ skt close ].	^ skt</body><body package="COUtilities">newTCPclientToHostAndPort: hostAndPort defaultPort: defaultPort	| assoc |	assoc := self hostnameAndPortNumFrom: hostAndPort.	^self newCoastClientToHost: assoc key port: (assoc value ifNil: [defaultPort])</body><body package="COUtilities">newTCPserverAtPort: pnum retryUntil: mnum	"Create an instance prepared to be a TCP server at the specified port."	"Retry with next higher number until a free port is found or a maximum number is reached"	| skt sa |	pnum &gt; mnum ifTrue: [ ^nil ].	skt := self family: (SocketAddress domainCodeFromName: #afInet)				type: self sockStream.	OSErrorHolder existingReferentSignal	handle: [ :ex |		skt close.		Transcript show: ('retry with port: ', (pnum + 1) printString) ; cr.		skt := self newTCPserverAtPort: (pnum + 1) retryUntil: mnum	]	do: [sa := IPSocketAddress hostAddress: IPSocketAddress thisHost port: pnum. skt bindTo: sa].	^skt</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>stream creation</category><body package="COUtilities">coastBinaryReadAppendStream	| stream |	stream := self readAppendStream binary.	self class coastConfigureStream: stream.	^ stream</body><body package="COUtilities">coastBinaryReadStream	| stream |	stream := self readStream binary.	self class coastConfigureStream: stream.	^ stream</body><body package="COUtilities">coastBinaryWriteStream	| stream |	stream := self writeStream binary.	self class coastConfigureStream: stream.	^ stream</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>options</category><body package="COUtilities">coastConfigureSocket</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>accessing</category><body package="COUtilities">coastTryReuseaddr	self coastTrySetSocketOption: [ self soReuseaddr: true ] description: 'Reuse address' complain: true.</body><body package="COUtilities">coastTrySetSocketOption: setBlock description: description complain: complain	[	setBlock value.		COAST.CoastLog logDebugNotify: 'Socket option set: ' , description	] 		on: Error		do: 		[: ex | | msg |			msg := 'Unable to set optional socket option: ' , description.			complain 				ifTrue: [ COAST.CoastLog log: msg ]				ifFalse: [ COAST.CoastLog logDebugNotify: msg ].		].</body><body package="COUtilities">coastTryTCPNoDelay: noDelay 	self coastTrySetSocketOption: [ self tcpNoDelay: noDelay ] description: 'No delay = ' , noDelay printString complain: false.</body><body package="COUtilities">coastTryTCPSetKeepAlive	self coastTrySetSocketOption: [ self tcpSetKeepAlive ] description: 'Keep alive' complain: false.</body><body package="COUtilities">coastTryTCPWindowSize: aSize 	self coastTrySetSocketOption: [ self tcpWindowSize: aSize ] description: 'Window size = ' , aSize printString complain: true.</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>options</category><body package="COUtilities">tcpSetKeepAlive 	^self		setOptionsLevel: SocketAccessor  SOL_SOCKET		name: SocketAccessor SO_KEEPALIVE		value: 1</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>accessing</category><body package="COUtilities">tcpWindowSize: bufferSize	| uba |	uba := UninterpretedBytes new: 4.	uba longAt: 1 put: bufferSize.	self setOptionsLevel: self class SOL_SOCKET name: self class  SO_SNDBUF value: uba asByteArray.	self setOptionsLevel: self class  SOL_SOCKET name: self class  SO_RCVBUF value: uba asByteArray.</body></methods><methods><class-id>Core.Interval</class-id> <category>accessing</category><body package="COUtilities">max	^ self first max: self last</body><body package="COUtilities">min	^ self first min: self last</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>accessing</category><body package="COUtilities">coastTotalPhysicalMemory		"self new coastTotalPhysicalMemory"	^ [	| memory |		memory := (self sysconf:  self _SC_PHYS_PAGES) * (self sysconf:  self _SC_PAGE_SIZE) .		" sanity check "		memory &gt;= (1024*1024*512)			ifTrue: [ memory ]			ifFalse: [ nil ]	] on: Error do: [ : ex |		COAST.CoastLog logError:  'Unable to detect available physical memory: ', ex description.		nil	]</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>constants</category><body package="COUtilities">_SC_PAGE_SIZE	^  30</body><body package="COUtilities">_SC_PHYS_PAGES	^  85</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="COUtilities">fromIniString: aString 	| replacementDictionary replacement str token lastTokenWasReplaced |	lastTokenWasReplaced := false.	aString isEmpty ifTrue: [ ^ aString ].	replacementDictionary := self iniToStringDictionary.	str := (String new: aString size) writeStream.	token := String new: 2.	aString keysAndValuesDo: 		[: i : ch |			token at: 2 put: ch.			replacement := replacementDictionary at: token ifAbsent: [ nil ].			replacement isNil 				ifTrue: 				[	token first asInteger = 0 ifFalse: [ str nextPut: token first ].					lastTokenWasReplaced := false 				]				ifFalse: 				[	str nextPutAll: replacement.					token := String new: 2.					lastTokenWasReplaced := true 				].			token at: 1 put: (token at: 2) 		].	lastTokenWasReplaced ifFalse: [ str nextPut: (token at: 2) ].	^ str contents</body></methods><methods><class-id>Core.String class</class-id> <category>accessing</category><body package="COUtilities">iniToStringDictionary	" keys must be of size 2 "	^ Dictionary new		at: '\\' put: '\';		at: '\*' put: (String with: Character cr);		at: '\~' put: '=';		yourself.</body><body package="COUtilities">stringToIniDictionary	" values must be of size 2 "	^ Dictionary new		at: $\ put: '\\';		at: Character cr put: '\*';		at: $= put: '\~';		yourself.</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="COUtilities">asIniString	" Answer the represenation of this object in an INI file "	| replacementDictionary replacement |	replacementDictionary := self class stringToIniDictionary.	^self inject: String new		into: 			[:answer :c | 			replacement := replacementDictionary at: c ifAbsent: [nil].			replacement notNil 				ifTrue: [answer , replacement]				ifFalse: [answer , (String with: c)]]</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="COUtilities">asStringsSeperatedBy: arrayOfCharacters	^  self asStringsSeperatedBy: arrayOfCharacters addBlock: [ :wordsCollection :anInterval :aString |			wordsCollection add: aString ]</body><body package="COUtilities">asStringsSeperatedBy: arrayOfCharacters addBlock: aBlock	| start skip o |	o := OrderedCollection new.	self isEmpty ifTrue: [ ^ o].	start := 1.	skip := (arrayOfCharacters includes: (self at: 1)).	1 to: self size do: [ :i |		(arrayOfCharacters includes: (self at: i))			ifTrue: [ " found a seperator "				skip					ifFalse: [						aBlock value: o value: (start to: i -1) value: (self copyFrom: start to: i - 1).						skip := true.].				start := i + 1			]			ifFalse: [ skip := false ].	].	start &lt;= self size		ifTrue: [ aBlock value: o value: (start to: self size) value: (self copyFrom: start to: self size) ].	^ o</body><body package="COUtilities">coastAsLargeInteger	| int |	int := LargePositiveInteger basicNew: self size.	self keysAndValuesDo: [ : i  :each | int basicAt: (self size + 1- i) put: each asInteger ].	^int</body></methods><methods><class-id>OS.IOBuffer</class-id> <category>buffer accessing</category><body package="COUtilities">coastBufferSize: bufferSize	buffer := self class getBufferOfSize: bufferSize.</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>collecting garbage</category><body package="COUtilities">compactingGCReportOn: aStream	"Perform a compacting, mark-sweep garbage collection of the entire 	Smalltalk system (with the exception of those objects housed in PermSpace),	printing the results in the transcript. Compacts both the OT and object data.	May take some time even on fast machines."	"ObjectMemory compactingGCReportOn: String new writeStream"	^self doGCAction: [self garbageCollect]		labeled: (#compactingGC &lt;&lt; #dialogs &gt;&gt; 'Compacting garbage collection (please wait)...')		reportOn: aStream</body><body package="COUtilities">compactMemoryReportOn: aStream	"Compacts the data in OldSpace, printing the 	results on the stream. Does not compact the OT.	May take some time even on fast machines."	"ObjectMemory compactMemoryReportOn: String new writeStream"	^self doGCAction: [self compactMemory]		labeled: (#compactingMemory &lt;&lt; #dialogs &gt;&gt; 'Compacting memory (please wait)...')		reportOn: aStream</body><body package="COUtilities">doGCAction: aBlock labeled: aStringOrMessage reportOn: aStream	"Perform some garbage collection action, printing some reclamation statistics	 on the stream.  If aBlock is nil then simply report current memory usage."	"ObjectMemory doGCAction: [self quickGC] labeled: 'quickie' reportOn: String new writeStream"	"ObjectMemory doGCAction: [] labeled: 'do nothing' reportOn: String new writeStream"	"ObjectMemory doGCAction: nil labeled: 'report' reportOn: String new writeStream"	| tUnits tPrecision spUnits spPrecision memStatus	  freeBytesBefore freeEntriesBefore footprintBefore	  time freeBytesAfter freeEntriesAfter footprintAfter shrinkage	  bytesReclaimed entriesReclaimed |	tUnits := 1000.0. "milliseconds"	tPrecision := 10.0. "tenths"	spUnits := 1000000.0. "megabytes"	spPrecision := 100.0. "hundredths"	aStream cr; nextPutAll: aStringOrMessage asString.	memStatus := self current.	freeBytesBefore := memStatus availableFreeBytes.	freeEntriesBefore := memStatus threadedOTEntries.	footprintBefore := memStatus dynamicallyAllocatedFootprint.	aBlock notNil ifTrue:		[time := Time millisecondsToRun: aBlock].	memStatus := self current.	freeBytesAfter := memStatus availableFreeBytes.	freeEntriesAfter := memStatus threadedOTEntries.	footprintAfter := memStatus dynamicallyAllocatedFootprint.	shrinkage := footprintBefore - footprintAfter max: 0.	bytesReclaimed := freeBytesAfter - freeBytesBefore + shrinkage.	entriesReclaimed := freeEntriesAfter - freeEntriesBefore.	aBlock notNil ifTrue:		[aStream cr;			nextPutAll: ((#reclaimedMemoryAfterGC &lt;&lt; #dialogs &gt;&gt; 			'reclaimed &lt;1p&gt; Mbytes of data and &lt;2p&gt; OTEntries in &lt;3p&gt; sec.')				expandMacrosWith: (bytesReclaimed//(spUnits/spPrecision)/spPrecision max: 0) 				with: (entriesReclaimed max: 0) 				with: time//(tUnits/tPrecision)/tPrecision)		].	shrinkage &gt; 0 ifTrue:		[ aStream cr;			nextPutAll: ((#heapshrunk &lt;&lt; #dialogs &gt;&gt; 'heap shrunk by &lt;1p&gt; Mbytes') 				expandMacrosWith: (shrinkage//(spUnits/spPrecision)/spPrecision max: 0))		].	aStream cr;		nextPutAll: ((#memoryStatsAfterGC &lt;&lt; #dialogs &gt;&gt; 			'&lt;1p&gt; Mbytes total;&lt;t&gt;&lt;2p&gt; Mbytes used,&lt;t&gt;&lt;3p&gt; Mbytes free.&lt;n&gt;')			expandMacrosWith: footprintAfter//(spUnits/spPrecision)/spPrecision				with: footprintAfter - freeBytesAfter//(spUnits/spPrecision)/spPrecision				with:freeBytesAfter//(spUnits/spPrecision)/spPrecision).	^aStream</body><body package="COUtilities">globalCompactingGCReportOn: aStream	"Perform a compacting, mark-sweep garbage collection of the entire 	Smalltalk system (including those objects housed in PermSpace),	printing the results on the stream. Compacts both the OT and object data.	May take some time even on fast machines."	"ObjectMemory globalCompactingGCReportOn: String new writeStream"	^self doGCAction: [self globalGarbageCollect]		labeled: (#GlobalGC &lt;&lt; #dialogs &gt;&gt; 'Global garbage collection (please wait)...')		reportOn: aStream</body><body package="COUtilities">quickGCReportOn: aStream	"Do a quick, non-compacting mark-sweep garbage collection of the entire	Smalltalk system (except for those object housed in PermSpace), printing the	results on the steram. May take some time even on fast machines."	"ObjectMemory verboseQuickGC"	^self doGCAction: [self quickGC]		labeled: (#nonCompactingGC &lt;&lt; #dialogs &gt;&gt; 'Non-compacting garbage collection (please wait)...')		reportOn: aStream</body></methods><methods><class-id>Kernel.ObjectMemory</class-id> <category>space queries</category><body package="COUtilities">coastDynamicallyAllocatedFootprint	"Answers the total size (in bytes) of the dynamically allocated footprint 	 represented by the receiver....	.... only measure space in dynamic memory spaces "	^self edenBytes + (self survBytes * 2) + self stackBytes + self oldBytes</body><body package="COUtilities">coastSumAllocatedOldSpace	"ObjectMemory current coastSumAllocatedOldSpace"	| sumAllocated |	sumAllocated := 0.	1 to: self oldSegments		do: 		[: segNumber | | usedSize |			" count OT size + data size "			usedSize := ( self basicAt: segNumber * 3 ) + ( self otEntriesToBytes: ( self basicAt: segNumber * 3 - 1 )).			sumAllocated := sumAllocated + usedSize		].	^ sumAllocated</body><body package="COUtilities">coastSumFreeOldSpace	| sumFree |	sumFree := 0.	1 to: self oldSegments		do: 		[: segNumber | | segmentSize usedSize |			segmentSize := self basicAt: segNumber * 3 - 2.			" count OT size + data size "			usedSize := ( self basicAt: segNumber * 3 ) + ( self otEntriesToBytes: ( self basicAt: segNumber * 3 - 1 )).			sumFree := sumFree + ( segmentSize - usedSize )		].	^ sumFree</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="COUtilities">coastKeyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value is equal (not neccesarily identical!) to 	the argument, value. If there is none, answer the result of evaluating 	exceptionBlock." 	self keysAndValuesDo: 		[:aKey :aValue | value = aValue ifTrue: [^aKey]].	^exceptionBlock value</body><body package="COUtilities">coastRemoveKeyAtValue: value ifAbsent: exceptionBlock	"remove the key whose value is equal (not neccesarily identical!) to 	the argument, value. If there is none, answer the result of evaluating 	exceptionBlock." 	self keysAndValuesDo: 		[:aKey :aValue | value = aValue ifTrue: [ self removeKey: aKey. ^aKey]].	^exceptionBlock value</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>positioning</category><body package="COUtilities">truncate	"Reset the size of the receiver"	"Same code as in #truncateStream because of packageProblem"	readLimit := position</body></methods><methods><class-id>Core.Duration</class-id> <category>converting</category><body package="COUtilities">asDurationDefaultUnit: aUnitSelector	" Schon eine Duration "	^ self</body></methods><methods><class-id>Core.Duration</class-id> <category>timed evaluation</category><body package="COUtilities">toFinish: aBlock orElse: aTimeoutBlock interruptProtectWith: volumeManager 	" patch: nested timeout blocks "	| timedProcess timer delay timedOut result |	timedProcess := Processor activeProcess.	delay := self asDelay.	timer := Process 			forBlock: 			[	delay wait.				volumeManager interruptProtectDo: [ timedProcess interruptWith: [ TimeoutExceeded raiseWith: delay ]]			]			priority: Processor timingPriority.	timedOut := false.	result :=		[	timer resume.			aBlock ensure: 				[	delay disable.					timer terminate				]		] 			on: TimeoutExceeded			do: 			[: ex |				ex parameter = delay 					ifTrue: 					[	timedOut := true.						nil					]					ifFalse: [ ex pass ]			].	^ timedOut 		ifTrue: [ aTimeoutBlock value ]		ifFalse: [ result ]</body></methods><methods><class-id>Core.ByteStreamEncoder</class-id> <category>accessing</category><body package="COUtilities">coastCanEncode: aCharacter	^ (encoder encode: aCharacter) ~~ Character illegalCode</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="COUtilities">allFilenamesDo: aBlock	aBlock value: self.	self isDirectory		ifTrue: [			self directoryContents do: [ : fn |				(self construct: fn) allFilenamesDo: aBlock			].		].</body><body package="COUtilities">copyToRecursively: target 	"Use with care. There is no checking for endless loops"	self isDirectory 		ifTrue: 		[	target exists 				ifTrue: 				[	target isDirectory 						ifFalse: [ self error: target asString , ' already exists, but is not a directory' ]				]				ifFalse: [ target makeDirectory ].			self directoryContents do: 				[: c | | source targetName |					source := self construct: c.					targetName := target construct: c.					source copyToRecursively: targetName				]		]		ifFalse: [ self copyTo: target ].</body><body package="COUtilities">deleteRecursively	self isDirectory		ifTrue: [			self directoryContents do: [ : c |				(self construct: c) deleteRecursively			]		].	self delete.</body><body package="COUtilities">ensureFullDirectory	self exists ifTrue: [ ^ self ].	self makeFullDirectory.	self makeWritable.</body><body package="COUtilities">fastConstruct: extraFn	"no filename checking is done! handle with care"	^ self class new named:  (self constructString: extraFn)</body><body package="COUtilities">makeFullDirectory	| parent |	parent := Filename named: self head.	parent = self		ifTrue: [ ^ self ].	parent exists		ifFalse: [			parent makeFullDirectory.			parent exists				ifFalse: [ ^ self ].		].	self exists		ifFalse: [ self makeDirectory ].</body></methods><methods><class-id>OS.Filename</class-id> <category>caching tools</category><body package="COUtilities">modifiedTimestamp	| aDateTimeArray aTimestamp |	aDateTimeArray := self dates at: #modified.	aTimestamp := Timestamp fromDate: (aDateTimeArray at: 1) andTime: (aDateTimeArray at: 2).	^aTimestamp</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="COUtilities">moveToRecursively: target 	self isDirectory 		ifTrue: 		[	target definitelyExists ifFalse: [ target makeDirectory ].			self directoryContents do: [: c | ( self construct: c ) moveToRecursively: ( target construct: c )].			self delete 		]		ifFalse: [ self moveTo: target ]</body></methods><methods><class-id>OS.Filename</class-id> <category>caching tools</category><body package="COUtilities">touch	| stream c |	stream := self readWriteStream.	[ stream position: 0.	  c := stream next.	  stream position: 0.	  c isNil 		  ifTrue: [ stream nextPut:  (Character value: 0).					stream position: 0.					stream ioConnection output truncateTo: 0 ]		  ifFalse: [ stream nextPut: c]	] valueNowOrOnUnwindDo: [ stream close]</body></methods><methods><class-id>OS.ExternalConnection</class-id> <category>accessing</category><body package="COUtilities">coastOsOutputExceptionOriginator	^ outputDescriptor</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="COUtilities">coastSortedBy: aBlock	| associations sortedAssociations |	associations := self collect: [ :x | (aBlock value: x) -&gt; x ].	sortedAssociations := associations asSortedCollection: [ :x :y | x key &lt;= y key ].	^ sortedAssociations asOrderedCollection collect: [ :assoc | assoc value ]</body></methods><methods><class-id>Core.TimeZone class</class-id> <category>accessing</category><body package="COUtilities">coastSetTimeZone: delta	"self coastSetTimeZone: 1"	self unfixedHolger. " falsche DST "	[	TimeZone setReferenceTimeZone: 			(TimeZone timeDifference: delta				DST: 0 start: 2 end: 3				from: 90 "on March 31"				to: 304 "until October 31"				startDay: #Sunday).		COAST.CoastLog logDebug: 'Updated TimeZone'.	] on: Error do: [ : ex |		COAST.CoastLog logDebug: 'Could not update TimeZone'.	].</body></methods><methods><class-id>Core.SharedQueue</class-id> <category>accessing</category><body package="COUtilities">coastEmptyQueue	[	accessProtect critical: 			[					[ contents isEmpty ] whileFalse: [ contents removeFirst ]			]	] valueUninterruptably.</body></methods><methods><class-id>Core.Character</class-id> <category>COAST</category><body package="COUtilities">asUppercaseBasePart	| code char parts |	code := self asInteger.	code &lt; 192 ifTrue: 		[	"(1  to: 96 ) allSatisfy: [: i | ( Character value: i ) = ( Character value: i ) asUppercaseBasePart ]. true"			"(123 to: 255) detect: [: i | ( Character value: i ) ~~ ( Character value: i ) asUppercaseBasePart ].  192"			^ ( code &gt;= 97 and: [ code &lt;= 122 ]) 				ifTrue: [ Character value: code - 32	"a-z" ]				ifFalse: [ self ]		].	CoBasePartsTableSize isNil ifTrue: [ ^ self asUppercase basePart ].	^ code &lt;= CoBasePartsTableSize 		ifTrue: [ self coBaseParts at: code ]		ifFalse: 		[	char := SmallSpecialLetters at: self ifAbsent: [ nil ].			( char isString or: [ char == nil ]) ifTrue: [ char := self ].			code := char asInteger.			code &lt; ComposedPartCodes size 				ifTrue: 				[	parts := ComposedPartCodes at: code + 1.					parts notNil 						ifTrue: [ parts first ]						ifFalse: [ char ]				]				ifFalse: [ char ]		]</body><body package="COUtilities">coBaseParts	CoBasePartsTable isNil ifTrue: [ self initializeCoBaseParts ].	^ CoBasePartsTable</body><body package="COUtilities">initializeCoBaseParts	CoBasePartsTable := ( 1 to: CoBasePartsTableSize ) collect: [: i | ( Character value: i ) asUppercase basePart ].</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>testing</category><body package="COUtilities">coastIsClean	^outerContext isNil and: [method numCopiedValues = 0]</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>accessing</category><body package="COUtilities">coastMethodPrintString	| str |	^ [		str := String new writeStream.		method homeMethod printNameOn: str inClass: nil.		str contents.	] on: Error do: [ : ex |		self printString	]</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>watchdog</category><body package="COUtilities">coastValueWithin: aDuration orDo: alternateBlock 	| timedProcess timer delay timedOut result |	timedProcess := Processor activeProcess.	delay := Delay for: aDuration.	timer := Process 			forBlock: 			[	delay wait.				timedProcess interruptWith: [ COAST.TimeoutInterrupt raiseWith: delay ]			]			priority: Processor timingPriority.	timedOut := false.	result :=		[	timer resume.			[ self value ] ensure: [ delay disable ]		] 			on: COAST.TimeoutInterrupt			do: 			[: ex |				ex parameter = delay 					ifTrue: 					[	timedOut := true.						nil					]					ifFalse: [ ex pass ]			].	^ timedOut 		ifTrue: [ alternateBlock value ]		ifFalse: [ result ]</body><body package="COUtilities">coastValueWithinMilliseconds: aNumber orDo: alternateBlock 	" compatibility " 	^ self coastValueWithin: aNumber milliseconds orDo: alternateBlock</body><body package="COUtilities">coastValueWithinSeconds: seconds 	" 	true: block performed	false: block timed out "	^ [	self value.		true	] coastValueWithinSeconds: seconds orDo: [ false ]</body><body package="COUtilities">coastValueWithinSeconds: timeoutSeconds orDo: timeoutBlock 	^ self coastValueWithin: timeoutSeconds seconds orDo: timeoutBlock</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>timed evaluation</category><body package="COUtilities">valueWithinSeconds: aNumber orDo: alternateBlock interruptProtectWith: volumeManager	"Evaluate the receiver and answer the result, giving at most aNumber seconds to complete.	After that, terminate execution and answer the result of alternateBlock instead.	Care should be taken using this method for scenarios where interrupting the reciever could leave objects in undesirable states."	^aNumber seconds toFinish: self orElse: alternateBlock interruptProtectWith: volumeManager</body></methods><methods><class-id>OS.IPSocketAddress class</class-id> <category>addressing</category><body package="COUtilities">randomHostAddress	"return some random address"	"usually called, when normal resolving of full hostname to 	 its address fails due to host dns configuration problems"	 | rand result | 	rand := Random new.	result := ByteArray new: 4.	(2 to: 4) do: [ : i | result at: i put: (rand next * 256) floor ].	^ result</body></methods><methods><class-id>OS.IPSocketAddress class</class-id> <category>As yet unclassified</category><body package="COUtilities">thisHostFullAddress	"returns the full address instead of 0.0.0.0 which was not very useful"	"self thisHostFullAddress"	^ self hostAddressByName: SocketAccessor getHostname</body></methods><methods><class-id>OS.IPSocketAddress</class-id> <category>printing</category><body package="COUtilities">addressPrintString	| stream |	stream := String new writeStream.	self printAddressOn: stream.	^ stream contents</body></methods><methods><class-id>OS.IPSocketAddress</class-id> <category>As yet unclassified</category><body package="COUtilities">convertToFullAddress	self isLocalHost ifTrue: [ self hostName: SocketAccessor getHostname ]</body><body package="COUtilities">isLocalHost	^self class allZeros: self hostAddress</body></methods><methods><class-id>Core.StreamEncoder</class-id> <category>accessing</category><body package="COUtilities">coastCanEncode: aCharacter	^ true</body></methods><methods><class-id>OS.MacOSXSystemSupport</class-id> <category>accessing</category><body package="COUtilities">coastTotalPhysicalMemory		^  nil</body></methods><methods><class-id>Security.RSAPublicKey</class-id> <category>accessing</category><body package="COBase">coastChallenge	| random |	random := Security.DSSRandom new.	random q: n.	^ random next asBigEndianByteArray</body><body package="COBase">coastMD5FingerPrint	^ ( Security.MD5 new )		updateWith: n asBigEndianByteArray;		updateWith: e asBigEndianByteArray;		digest</body></methods><methods><class-id>Core.Double</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body></methods><methods><class-id>Core.LookupKey</class-id> <category>testing</category><body package="COBase">coastIsAssociation	"Answer whether the receiver is an Association."	^true</body></methods><methods><class-id>Core.Array class</class-id> <category>instance creation</category><body package="COBase">newForValueHolder	^ #()</body></methods><methods><class-id>Core.Set</class-id> <category>accessing</category><body package="COBase">* aSet	"set function: intersection" 	| newSet s1 s2 |	"running over the smaller set, avoiding to much tests"	aSet size &lt; self size 		ifTrue: [s1 := aSet. s2 := self]		ifFalse: [s1 := self. s2 := aSet].	newSet := self species new. 	s1 do: 		[:each | 		(s2 includes: each) 			ifTrue: [newSet add: each]].	^newSet</body></methods><methods><class-id>Core.Set</class-id> <category>adding</category><body package="COBase">+ aCollection	| newCollection |	newCollection := self copy.	newCollection addAll: aCollection.	^newCollection</body></methods><methods><class-id>Core.Set</class-id> <category>converting</category><body package="COBase">coastAsSet	^ self class == Set 		ifTrue: [ self copy ]		ifFalse: [ super coastAsSet ]</body></methods><methods><class-id>Core.Set</class-id> <category>accessing</category><body package="COBase">coastAsSetOrYourself	^ self class == Set 		ifTrue: [ self ]		ifFalse: [ super coastAsSetOrYourself ]</body><body package="COBase">coastAsSortedValidKeys	^ ( self allSatisfy: [: elem | elem isCoastFrame and: [ elem coastIsValidRPCArgument]]) 		ifTrue: [ COAST.CompactSet withAll: self ]		ifFalse: [ super coastAsSortedValidKeys ]</body></methods><methods><class-id>Core.TwoByteString</class-id> <category>marshalling</category><body package="COBase">asCoastString	^ self</body></methods><methods><class-id>Core.TwoByteString</class-id> <category>converting</category><body package="COBase">coastAsPostPatternPrefixIgnoreCase: ignoreCase 	| end |	end := self lastUsableMatchCharacterIndex.	^ end = self size 		ifTrue: [ self copyWith: ( Character value: 0 )]		ifFalse: 		[( self copyFrom: 1 to: end + 1 )				at: end + 1 put: ( Character value: self coastMaxCharValue );				yourself		]</body><body package="COBase">coastMaxCharValue	^ 65535</body></methods><methods><class-id>Core.TwoByteString</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body></methods><methods><class-id>Core.Object class</class-id> <category>instance creation</category><body package="COBase">newForValueHolder	^ self new</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COBase">allowsSlotComputation	^true</body><body package="COBase">asValidFrameReferenceOrNil	^ nil</body></methods><methods><class-id>Core.Object</class-id> <category>inspecting</category><body package="COBase">classLabel	^self class printString</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COBase">coastArgumentsHash	^ self hash</body><body package="COBase">coastAsID	^self</body><body package="COBase">coastAsNewIDFrom: newID for: cell	^newID</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="COBase">coastAsSet	^Set with: self.</body><body package="COBase">coastAsSetOrYourself	" returns a set, which is not necessarily a collection "	^ self coastAsSet</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="COBase">coastCompareBooleanTo: characters 	^ self coastComparePrimitiveTypeTo: characters</body><body package="COBase">coastCompareColorValueTo: timestamp	^ self coastComparePrimitiveTypeTo: timestamp</body><body package="COBase">coastCompareFrameOrReferenceTo: frame 	^ self coastComparePrimitiveTypeTo: frame</body><body package="COBase">coastComparePrimitiveTypeTo: primitive 	^ self isCoastPrimitiveValue 		ifTrue: [ self coastCompareTypeOrder coastCompareMagnitudeTo: primitive coastCompareTypeOrder ]		ifFalse: [ self error: 'not a coast primitive' ]</body><body package="COBase">coastCompareTo: object 	self coastPrimitiveSubclassResponsibility</body><body package="COBase">coastCompareTypeOrder	self coastPrimitiveSubclassResponsibility</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COBase">coastHashFor: coastCell	^coastCell identityHash</body><body package="COBase">coastHashOrNil	^nil</body><body package="COBase">coastInvalidate	^ self coastInvalidateWithAccess: nil</body><body package="COBase">coastInvalidateDisresolved</body><body package="COBase">coastInvalidatedSlot: slotname	" Hook for subclasses. I don't care "</body><body package="COBase">coastInvalidateWithAccess: cellAccessOrNil	" true: keep observer "	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COBase">coastIsAssociation	"Answer whether the receiver is an Association."	^false</body><body package="COBase">coastIsTempSharedFrameID	^ false</body><body package="COBase">coastIsValueHolder	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="COBase">coastLessThan: object 	| compare |	compare := self coastCompareTo: object.	^ compare = -1</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COBase">coastObjectSize	| oopSize headerSize varSize instVarsSize myClass |	oopSize := 4.	" bytes per object pointer "	headerSize := 12.	" bytes per object header "	myClass := self class.	varSize := myClass isVariable 			ifTrue: 			[	myClass isBits 					ifTrue: [ self basicSize ]					ifFalse: [ self basicSize * oopSize ]			]			ifFalse: [ 0 ].	headerSize := myClass hasImmediateInstances 			ifTrue: [ oopSize ]			ifFalse: [ headerSize ].	instVarsSize :=  myClass instSize * oopSize.	^ headerSize + varSize + instVarsSize</body><body package="COBase">coastObserver	^ nil</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="COBase">coastPrimitiveSubclassResponsibility	self isCoastPrimitiveValue 		ifTrue: 		[	Object subclassResponsibilitySignal 				raiseErrorString: #errSubclassResponsibility &lt;&lt; #dialogs &gt;&gt; 'My subclass should have overridden one of my messages.'		]		ifFalse: [ self error: 'not a coast primitive' ].</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COBase">coastReferencedObjectSize	" I'm a referenced object (instVar etc.). Returns my size "	^ self class hasImmediateInstances 		ifTrue: 		[	" pointer stores the value itself "			0		]		ifFalse: [ self coastObjectSize ]</body><body package="COBase">coastRemoveObserverPair: anObserverPair	self coastRemoveSubject: anObserverPair</body><body package="COBase">coastRemoveSubject: observedObject</body><body package="COBase">coastSubject	^ nil</body><body package="COBase">coastTotalByteSize	" total size of the object and its substructure, including values, but not referenced first class COAST objects "	^ self coastObjectSize</body><body package="COBase">equalFromFrameID: anotherFrameID 	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>As yet unclassified</category><body package="COBase">finishObservation	" do nothing by default "</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COBase">isAntiSet	^false</body><body package="COBase">isBoolean	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>As yet unclassified</category><body package="COBase">isCell	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COBase">isCoastFrame	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COBase">isFrameOrFrameReference	^false</body><body package="COBase">selfOrFrameLocator	^ self</body></methods><methods><class-id>Core.Object</class-id> <category>marshalling</category><body package="COBase">translatedArgumentForCluster: aCatCSCluster	^ self</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COBase">unfixed: todo for: developers 	Notifier isDevelopment ifFalse: [ ^ self ].	Transcript show: 'Remaining work for '.	developers 		do: [: dev | Transcript show: dev ]		separatedBy: [ Transcript show: ', ' ].	Transcript		show: ': ';		show: todo;		cr</body></methods><methods><class-id>Core.Object</class-id> <category>As yet unclassified</category><body package="COBase">unfixedChristian	"Transcript show: 'Remaining work for Christian';cr."	^self</body><body package="COBase">unfixedFrank	"Transcript show: 'Remaining work for Frank';cr."	^self</body><body package="COBase">unfixedHans	"Transcript show: 'Remaining work for Hans';cr."	^self</body><body package="COBase">unfixedHolger	"Transcript show: 'Remaining work for Holger';cr."	^self</body></methods><methods><class-id>Core.Object</class-id> <category>some adds</category><body package="COBase">value	"Allows all Objects to be used as read-only ValueModels"	^self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="COBase">coastAsSortedValidKeys	"remove invalid elements, sort remaining keys"	| sortedKeys lastElem sorted |	lastElem := sortedKeys := nil.	sorted := true.	self do: 		[: e |			"try to save a unnessesary copy in most cases (no local frames present)"			( e isCoastFrame and: [ e isLocal ]) 				ifTrue: 				[	"ohne local Frames"					sortedKeys isNil ifTrue: [ sortedKeys := self copy ].					sortedKeys remove: e				]				ifFalse: 				[	sorted ifTrue: 						[	"try to save a unnessesary copy in some cases (keys are sorted)"							sorted := lastElem isNil or: [ lastElem coastLessThan: e ].							lastElem := e						]				]		].	sortedKeys isNil ifTrue: [ sortedKeys := self ].	sorted ifFalse: [ sortedKeys := sortedKeys asSortedCollection: [: a : b | a coastLessThan: b ]].	^ sortedKeys</body><body package="COBase">coastKeyRangeFor: object 	| max min |	max := self size.	min := self coastMinIndexForInserting: object min: 1 max: max.	min &gt; max ifTrue: [	^ min to: max].	((self at: min) coastCompareTo: object) = 0 ifFalse: [	^ min to: min - 1].	max := self coastMaxIndexForInserting: object min: min max: max.	^ min to: max</body><body package="COBase">coastMaxIndexForInserting: anObject 	^ self coastMaxIndexForInserting: anObject min: 1 max: self size</body><body package="COBase">coastMaxIndexForInserting: search min: min max: max 	| minIndex maxIndex |	minIndex := min.	maxIndex := max.	maxIndex == 0 ifTrue: [ ^ 1	"empty collection" ].	"1 &lt;= min &lt;= minIndex &lt;= maxIndex &lt;= max &lt;= self size"	[ minIndex &lt; maxIndex ] whileTrue: 		[ "search in interval [ minIndex .. maxIndex ]"			| midIndex found |			midIndex := 1 + minIndex + maxIndex bitShift: -1.	"minIndex &lt;= index &lt; maxIndex"			found := self at: midIndex.			( search coastLessThan: found ) 				ifTrue: [ maxIndex := midIndex - 1	"search before index" ]				ifFalse: [ minIndex := midIndex	"search at or behind index" ]		].	^ ( minIndex = min and: [ search coastLessThan: ( self at: min )]) 		ifTrue: [ 0 ]		ifFalse: [ minIndex ]</body><body package="COBase">coastMinIndexForInserting: anObject 	^ self coastMinIndexForInserting: anObject min: 1 max: self size</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>private</category><body package="COBase">coastMinIndexForInserting: anObject criteria: block 	| index low high |	low := 1.	high := self size.	[	index := ( low + high ) // 2.		low &gt; high	] whileFalse: 		[(( block value: ( self at: index )) coastLessThan: anObject ) 				ifTrue: [ low := index + 1 ]				ifFalse: [ high := index - 1 ]		].	^ ( low = self size and: [( block value: self last ) coastLessThan: anObject ]) 		ifTrue: [ self size + 1 ]		ifFalse: [ low ]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="COBase">coastMinIndexForInserting: search min: min max: max 	| minIndex maxIndex |	minIndex := min.	maxIndex := max.	maxIndex == 0 ifTrue: [ ^ 1	"empty collection" ].	"1 &lt;= min &lt;= minIndex &lt;= maxIndex &lt;= max &lt;= self size"	[ minIndex &lt; maxIndex ] whileTrue: 		[ "search in interval [ minIndex .. maxIndex ]"			| midIndex found |			midIndex := minIndex + maxIndex bitShift: -1.	"minIndex &lt;= index &lt; maxIndex"			found := self at: midIndex.			( found coastLessThan: search ) 				ifTrue: [ minIndex := midIndex + 1	"search behind index" ]				ifFalse: [ maxIndex := midIndex	"search at or before index" ]		].	^ ( minIndex = max and: [( self at: max ) coastLessThan: search ]) 		ifTrue: [ minIndex + 1 ]		ifFalse: [ minIndex ]</body><body package="COBase">mergeOrdered: col1 with: col2 	"we are ordered same way as col1 and col2, which are disjunct nonEmpty subcollections of myself"	" 'abcdefg' mergeOrdered: 'adf' with: 'cg' ==&gt; 'acdfg' "	| stream1 stream2 resultStream |	stream1 := col1 readStream.	stream2 := col2 readStream.	resultStream := self species new writeStream.	self do: 		[: each |			stream1 peek = each ifTrue: 				[	resultStream nextPut: each.					stream1 next				].			stream2 peek = each ifTrue: 				[	resultStream nextPut: each.					stream2 next				]		].	^ resultStream contents</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>testing</category><body package="COBase">startsWith: otherCollection 	self size &gt;= otherCollection size 		ifFalse: [ ^ false ].	1 to: otherCollection size		do: 		[: index | ( self at: index ) = ( otherCollection at: index ) 				ifFalse: [ ^ false ]		].	^ true</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="COBase">coastRightNow	"until now, rightNow comes from wron time zone - this is a workaround"	"note: all time zones have the same seconds beat"	^Timestamp now		millisecond: (Time microsecondClock // 1000) \\ 1000</body></methods><methods><class-id>Core.Timestamp</class-id> <category>comparing</category><body package="COBase">coastCompareTypeOrder	^ 5</body></methods><methods><class-id>Core.Timestamp</class-id> <category>printing</category><body package="COBase">coastShortPrintString	| aStream |	aStream := WriteStream on: (String new: 32).	self coastShortPrintStringOn: aStream.	^ aStream contents</body><body package="COBase">coastShortPrintStringOn: aStream 	self dayOfMonth printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $..	self month printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $..	self year printOn: aStream.	aStream nextPut: Character space.	self hour printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $:.	self minute printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $:.	self second printOn: aStream paddedWith: $0 to: 2 base: 10.</body></methods><methods><class-id>Core.Timestamp</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>comparing</category><body package="COBase">coastCompareColorValueTo: anotherColorValue 	| result |	result := ( self red * 255 ) rounded coastCompareTo: ( anotherColorValue red * 255 ) rounded.	^ 0 == result 		ifTrue: 		[	result := ( self green * 255 ) rounded coastCompareTo: ( anotherColorValue green * 255 ) rounded.			0 == result 				ifTrue: [ ( self blue * 255 ) rounded coastCompareTo: ( anotherColorValue blue * 255 ) rounded ]				ifFalse: [ result ]		]		ifFalse: [ result ]</body><body package="COBase">coastCompareTo: object 	^ ( object coastCompareColorValueTo: self ) negated</body><body package="COBase">coastCompareTypeOrder	^ 8</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body></methods><methods><class-id>Xtreams.TLSContext</class-id> <category>services</category><body package="COBase">coastConnectionForSocket: aSocketAccessor	^(COAST.CoastSocketAccessor context: self)		reading: aSocketAccessor writing: aSocketAccessor;		yourself</body></methods><methods><class-id>Core.ByteString class</class-id> <category>marshalling</category><body package="COBase">supervisorUnmarshalPrimitiveFrom: aStream	| length new |	length := aStream nextCoastStringLength.	new := self new: length.	1 to: length do:		[:i |		new byteAt: i put: aStream next].	^new</body></methods><methods><class-id>Core.ByteString</class-id> <category>marshalling</category><body package="COBase">asCoastString	^ self</body><body package="COBase">isCoastPrimitiveValue	^ true</body><body package="COBase">supervisorMarshalTo: stream	stream nextPut: self class marshallID.	stream nextCoastStringPut: self.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="COBase">coastAsPatternPrefixIgnoreCase: ignoreCase 	| end copy |	^ ignoreCase 		ifTrue: [ self coastAsUppercaseBaseParts coastAsPatternPrefixIgnoreCase: false ]		ifFalse: 		[	end := self lastUsableMatchCharacterIndex.			( ignoreCase not and: [ end == self size ]) 				ifTrue: [ ^ self ].			copy := self copyFrom: 1 to: end.			copy		]</body><body package="COBase">coastAsPostPatternPrefixIgnoreCase: ignoreCase 	^ self asString coastAsPostPatternPrefixIgnoreCase: ignoreCase</body><body package="COBase">coastAsSet	^Set with: self.</body><body package="COBase">coastAsUppercaseBaseParts	| copy |	copy := self species new: self size.	1 to: self size do: [: index | copy at: index put: ( self at: index ) asUppercaseBasePart ].	^ copy</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>comparing</category><body package="COBase">coastMatch: aCharacterArray ignoreCase: caseFlag 	"Answer whether aCharacterArray matches the pattern in the receiver.  Matching	includes upper/lower case differences if caseFlag is false.  Where the	receiver contains ?, aCharacterArray may contain any single character.  Where	the receiver contains *, aCharacterArray may contain any sequence of characters."	^ aCharacterArray coastMatchesPattern: self ignoreCase: caseFlag do: nil	" Examples: 	'xyz' coastMatch: 'Xyz'  ignoreCase: true ==&gt; true	'x?z' coastMatch: 'x@z' ignoreCase: true ==&gt; true 	'x#z' coastMatch: 'x@z' ignoreCase: true ==&gt; false 	'x*z' coastMatch: 'x whyNot? z' ignoreCase: true ==&gt; true	'*x' coastMatch: 'xx' ignoreCase: true ==&gt; true	"</body><body package="COBase">coastMatchesPattern: pattern ignoreCase: ignoreCase do: aBlock 	"Answer whether the receiver matches the pattern.  Matching	includes upper/lower case differences if ignoreCase is false.  Where the	pattern contains ?, the receiver may contain any single character.  Where	the pattern contains *, the receiver may contain any sequence of characters.	If aBlock is not nil then before the receiver answers true for the matching case,	 the block will be evaluated with the start and stop index for the runs matching	a ? or a *.  Note that the block may be evaluated even if the ultimate answer	is false."	| stringSize stringIndex patternSize patternIndex p t patternStartScan stringStartScan singleMatches |	stringSize := self size.	stringIndex := 1.	patternSize := pattern size.	patternIndex := 1.	" patternStartScan = patternIndex of the most recent * + 1.	stringStartScan = stringIndex when we saw the *,		or nil if we haven't seen any * yet.	singleMatches = stringIndex values corresponding to ?s in the pattern		since the last *, or nil if no block. "	stringStartScan := nil.	singleMatches := aBlock == nil 			ifTrue: [ nil ]			ifFalse: [ OrderedCollection new ].	[ patternIndex &lt;= patternSize ] whileTrue: 		[	p := pattern at: patternIndex.			patternIndex := patternIndex + 1.			p == $* 				ifTrue: 				[	" We found a successful match after the last *,					if any.  Give it, and any subsequent ? matches, to the block. "					aBlock == nil ifFalse: 						[	stringStartScan == nil 								ifFalse: [ aBlock value: stringStartScan value: stringIndex + patternStartScan - patternIndex ].							singleMatches do: [: index | aBlock value: index value: index ]						].					patternIndex &gt; patternSize ifTrue: 						[	" We have a * as the last element of the pattern.							Give the block the entire rest of the string. "							aBlock == nil ifFalse: [ aBlock value: stringIndex value: stringSize ].							^ true						].					stringStartScan := stringIndex.					patternStartScan := patternIndex.					singleMatches == nil ifFalse: [ singleMatches setIndices ]				]				ifFalse: 				[	stringIndex &gt; stringSize ifTrue: [ ^ false ].					t := self at: stringIndex.					stringIndex := stringIndex + 1.					( p == $? or: [ t coastEqual: p ignoreCase: ignoreCase ]) 						ifTrue: 						[( patternIndex &gt; patternSize and: [ stringIndex &lt;= stringSize ]) 								ifTrue: 								[	" We ran off the end of the pattern.									Treat like a non-match (see below). "									stringStartScan == nil ifTrue: [ ^ false ].									stringIndex := stringIndex + patternStartScan - patternIndex + 1.									patternIndex := patternStartScan.									singleMatches == nil ifFalse: [ singleMatches setIndices ]								]								ifFalse: [( p == $? and: [ singleMatches notNil ]) ifTrue: [ singleMatches addLast: stringIndex - 1 ]]						]						ifFalse: 						[	" We hit a non-match while scanning.							Back up the string to one character after							the beginning of the current partial match,							and the pattern to just after the last *. "							stringStartScan == nil ifTrue: [ ^ false ].	"no * yet, match fails"							stringIndex := stringIndex + patternStartScan - patternIndex + 1.							patternIndex := patternStartScan.							singleMatches == nil ifFalse: [ singleMatches setIndices ]						]				]		].	stringIndex &lt;= stringSize ifTrue: 		[	" We didn't match the whole string: report failure. "			^ false		].	" Give the last match(es) to the block. "	aBlock == nil ifFalse: 		[	stringStartScan == nil 				ifFalse: [ aBlock value: stringStartScan value: stringIndex + patternStartScan - patternIndex - 1 ].			singleMatches do: [: index | aBlock value: index value: index ]		].	^ true</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="COBase">coastTotalByteSize	^ self coastObjectSize</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="COBase">lastUsableMatchCharacterIndex	1 to: self size		do: 		[: index | | char |			char := self at: index.			( $* == char or: [ $? == char ]) ifTrue: [ ^ index - 1]		].	^ self size</body></methods><methods><class-id>Core.Number</class-id> <category>comparing</category><body package="COBase">coastCompareTypeOrder	^ 3</body></methods><methods><class-id>Core.RecursionLock</class-id> <category>mutual exclusion</category><body package="COBase">basicWouldBlock	"Check if the resource represented by the receiver is  	already in use by another Process."	"processes in the debugger count:  fast version"	^(owner notNil and: [ Processor activeProcess ~~ owner ])</body></methods><methods><class-id>Core.RecursionLock</class-id> <category>debugging</category><body package="COBase">blockerPrintString	"answer a description of the blocking process"	| sndr i nextSender callStack |	owner isNil ifTrue: [ ^'not blocked' ].	callStack := String new.	sndr := owner suspendedContext.	sndr isNil ifTrue: [ ^'blocked ???' ].	i := 1.	[ i &lt;= 50 and: [ (nextSender := sndr sender) ~~ sndr			and: [ nextSender notNil ]]] whileTrue: [		i := i + 1.		callStack := callStack, nextSender printString, '\' withCRs.		sndr := nextSender.	].	^ callStack</body></methods><methods><class-id>Core.RecursionLock</class-id> <category>mutual exclusion</category><body package="COBase">interruptOrTerminateOwnerWith: anExceptionClass 	| currentOwner |	currentOwner := owner.	( currentOwner notNil and: [ Processor activeProcess ~~ currentOwner ]) 		ifTrue: 		[	currentOwner interruptWith: 				[						[ anExceptionClass raiseSignal ] 						on: UnhandledException						do: 						[: ex |							COAST.CoastLog 								logException: ex 								message: 'Exception ' , anExceptionClass fullName , ' not handled by exclusiveLock owner, terminating process'.							" terminate process to release blocked resources "							currentOwner isTerminated ifFalse: [ currentOwner terminate ].						]				]		].</body></methods><methods><class-id>Security.TLSInputOutputStream</class-id> <category>testing</category><body package="COBase">closed	^ false</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>adding</category><body package="COBase">coastAdd: newObject afterIndex: spot 	"Add the argument, newObject, as an element of the receiver.  Put it	in the position just after the indexed position spot.  Answer newObject."	self insert: newObject before: spot + firstIndex.	^newObject</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>removing</category><body package="COBase">coastRemove: count index: index 	| startIndex endIndex |	startIndex := index + firstIndex - 1.	endIndex := lastIndex - count.	startIndex to: endIndex do: [: moveIndex | self basicAt: moveIndex put: ( self basicAt: moveIndex + count )].	endIndex + 1 to: lastIndex do: [: obsoleteIndex | self basicAt: obsoleteIndex put: nil ].	lastIndex := endIndex</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>accessing</category><body package="COBase">components	^self</body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>marshalling</category><body package="COBase">asCoastString	^ self</body><body package="COBase">supervisorMarshalTo: stream	stream nextPut: self class marshallID.	stream nextCoastStringPut: self.</body></methods><methods><class-id>Core.False</class-id> <category>comparing</category><body package="COBase">coastCompareBooleanTo: aBoolean 	"(true coastCompareTo: true) -&gt; 0	(true coastCompareTo: false) -&gt; 1	(false coastCompareTo: true) -&gt; -1	(false coastCompareTo: false) -&gt; 0"	^ aBoolean 		ifTrue: [ -1 ]		ifFalse: [ 0 ]</body></methods><methods><class-id>Core.False</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body><body package="COBase">supervisorMarshalTo: aStream	aStream nextPut: self class marshallID.</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>converting</category><body package="COBase">coastAsSet	^Set new</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>comparing</category><body package="COBase">coastCompareTo: object 	^ object notNil 		ifTrue: [ -1	" nil &lt; object " ]		ifFalse: [ 0	"nil=nil" ]</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>marshalling</category><body package="COBase">coastCompareTypeOrder	^ 1</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>accessing</category><body package="COBase">coastHashFor: coastCell	^ coastCell buildHashWrapper coastHashFor: coastCell</body><body package="COBase">coastReferencedObjectSize	" I'm a referenced object (instVar etc.). Returns my size "	" no object referenced "	^ 0</body><body package="COBase">coastTotalByteSize	^ 0</body><body package="COBase">hasObserversWithRevalidationBlock	^ false</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body><body package="COBase">supervisorMarshalTo: aStream	aStream nextPut: self class marshallID.</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>accessing</category><body package="COBase">coastDefaultListenBacklog	" see 7.8 release notes "	^ 128</body><body package="COBase">coastIPAddress	" may fail if the host is not bound to a single address "	^ IPSocketAddress hostAddressByName: SocketAccessor defaultClass getHostname</body><body package="COBase">coastIPAddressString	" may fail if the host is not bound to a single address "	| bytes str |	bytes := self coastIPAddress.	str := String new writeStream.	bytes do: [ : byte | byte printOn: str. ] separatedBy: [  str nextPut: $. ].	^ str contents</body><body package="COBase">hostDescription	| hostDescription |		[hostDescription := SocketAccessor getHostname.	hostDescription := hostDescription , ' ' , (IPSocketAddress hostAddressByName: hostDescription) asIPAdressString]		on: Error		do: [:ex | hostDescription := 'unknown host'. ex return].	^hostDescription</body></methods><methods><class-id>Core.IdentitySet</class-id> <category>accessing</category><body package="COBase">coastAsSetOrYourself	^ self class == IdentitySet 		ifTrue: [ self ]		ifFalse: [ super coastAsSetOrYourself ]</body></methods><methods><class-id>Core.Integer</class-id> <category>accessing</category><body package="COBase">coastAsNewIDFrom: newID for: cell	^self == newID		ifTrue: [ self ]		ifFalse: [ COAST.CoastIDAndHashWrapper coastID: newID hash: self ]</body><body package="COBase">coastHashFor: coastCell	^self</body><body package="COBase">coastHashOrNil	^self</body></methods><methods><class-id>Core.Integer</class-id> <category>testing</category><body package="COBase">coastIsTempSharedFrameID	^ self &lt; 0</body></methods><methods><class-id>Core.Integer</class-id> <category>printing</category><body package="COBase">coastPrintLargeOn: aStream 	"12031345 ==&gt; 12'031'345"	self coastPrintLargeOn: aStream paddedWith: $0 base: 10 separator: $. digits: 3</body><body package="COBase">coastPrintLargeOn: aStream paddedWith: padding base: base separator: separator digits: digits 	"	example	| stream |	stream := String new writeStream.	16rA04C11B coastPrintLargeOn: stream paddedWith: $0 base: 16 separator: Character space digits: 2.	stream contents 	==&gt; 'A 04 C1 1B'	"	| mod |	mod := 1.	digits timesRepeat: [ mod := mod * base ].	self 		coastPrintLargeOn: aStream		paddedWith: padding		base: base		separator: separator		digits: digits		mod: mod</body><body package="COBase">coastPrintLargeOn: aStream paddedWith: padding base: base separator: separator digits: digits mod: mod 	| big |	big := self // mod.	big &gt; 0 		ifTrue: 		[	big 				coastPrintLargeOn: aStream				paddedWith: padding				base: base				separator: separator				digits: digits				mod: mod.			aStream nextPut: separator.			self \\ mod printOn: aStream paddedWith: padding to: digits base: base		]		ifFalse: [ self printOn: aStream base: base ]</body></methods><methods><class-id>Core.Integer</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>accessing</category><body package="COBase">activePartitionSize	^self activeProcess environmentAt: #activePartitionSize</body><body package="COBase">activePartitionSize: anInteger	^self activeProcess environmentAt: #activePartitionSize put: anInteger</body><body package="COBase">activeTransaction	^self activeProcess environmentAt: #activeTransaction</body><body package="COBase">activeTransaction: aTransaction 	^ self activeProcess environment activeTransaction: aTransaction.</body><body package="COBase">execute: aBlock withPriority: aProcessPriorirty 	| oldPriority process |	process := self activeProcess.	oldPriority := process priority.	^ [	process priority: aProcessPriorirty.		aBlock value	] valueNowOrOnUnwindDo: [ process priority: oldPriority ]</body><body package="COBase">removeActiveTransaction	self activeProcess environment removeActiveTransaction.</body></methods><methods><class-id>Core.Symbol</class-id> <category>comparing</category><body package="COBase">coastCompareTypeOrder	^ 5</body></methods><methods><class-id>Core.Symbol</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body></methods><methods><class-id>Core.Boolean</class-id> <category>comparing</category><body package="COBase">coastCompareBooleanTo: aBoolean 	"false &lt; true	(true coastLessThan: true) -&gt; false	(true coastLessThan: false) -&gt; false	(false coastLessThan: true) -&gt; true	(false coastLessThan: false) -&gt; false"	^ aBoolean and: [ self not ]</body></methods><methods><class-id>Core.Boolean</class-id> <category>logical operations</category><body package="COBase">coastCompareTo: object 	"(true coastCompareTo: true) -&gt; 0	(true coastCompareTo: false) -&gt; 1	(false coastCompareTo: true) -&gt; -1	(false coastCompareTo: false) -&gt; 0"	^ ( object coastCompareBooleanTo: self ) negated</body></methods><methods><class-id>Core.Boolean</class-id> <category>comparing</category><body package="COBase">coastCompareTypeOrder	^ 2</body></methods><methods><class-id>Core.Boolean</class-id> <category>testing</category><body package="COBase">isBoolean	^ true</body></methods><methods><class-id>Core.GenericException</class-id> <category>testing</category><body package="COBase">isCoastError	^false</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="COBase">coastFromTwoByteArray: byteArray	" convert each two-byte-pair into a character "	| s hiByte loByte |	s := self new: byteArray size // 2.	1 to: s size do: [ :i |		hiByte := byteArray at: i * 2 - 1.		loByte := byteArray at: i * 2.		s at: i put: (Character value: hiByte * 256 + loByte).	].	^ s</body></methods><methods><class-id>Core.String</class-id> <category>marshalling</category><body package="COBase">asCoastString	^ self asByteString</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="COBase">asDouble	^ Double readFrom: self readStream</body><body package="COBase">asFloat	^ Float readFrom: self readStream</body><body package="COBase">asInteger	^ Integer readFrom: self readStream</body><body package="COBase">coastAsPostPatternPrefixIgnoreCase: ignoreCase 	" we need to insert a special character (which is greater than every other character).	cannot do this with bytestrings "	^ self asTwoByteString coastAsPostPatternPrefixIgnoreCase: ignoreCase</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="COBase">coastCompareTo: string 	"kein double dispatch, da 'abc' mit #abc nicht Ã¼ber die buchstaben verglichen werden soll" 	| compareType firstNonMatch bufchar1 bufchar2 j1 j2 length1 length2 atEnd1 atEnd2 |	self == string ifTrue: [ ^ 0 ].	compareType := self coastCompareTypeOrder coastCompareMagnitudeTo: string coastCompareTypeOrder.	0 == compareType ifFalse: [ ^ compareType ].	firstNonMatch := 0.	bufchar1 := nil.	bufchar2 := nil.	j1 := 1.	j2 := 1.	length1 := self size.	length2 := string size.	[	atEnd1 := j1 &gt; length1 and: [ bufchar1 == nil ].		atEnd2 := j2 &gt; length2 and: [ bufchar2 == nil ].		atEnd1 or: [ atEnd2 ]	] whileFalse: 		[ | char1 char2 |			bufchar1 notNil 				ifTrue: 				[	char1 := bufchar1.					bufchar1 := nil				]				ifFalse: 				[	char1 := self at: j1.					char1 == $Ã ifTrue: 						[	bufchar1 := $S.							char1 := $S						].					j1 := j1 + 1				].			bufchar2 notNil 				ifTrue: 				[	char2 := bufchar2.					bufchar2 := nil				]				ifFalse: 				[	char2 := string at: j2.					char2 == $Ã ifTrue: 						[	bufchar2 := $S.							char2 := $S						].					j2 := j2 + 1				].			( char1 == char2 and: [ bufchar1 == bufchar2 ]) ifFalse: 				[ | u1 u2 |					u1 := char1 asUppercaseBasePart.					u2 := char2 asUppercaseBasePart.					u1 == u2 ifFalse: 						[	^ u1 &lt; u2 								ifTrue: [ -1 ]								ifFalse: [ 1 ]						].					firstNonMatch == 0 ifTrue: 						[	firstNonMatch := char1 = char2 									ifTrue: 									[	bufchar1 notNil 											ifTrue: [ -1	"Ã &lt; SS" ]											ifFalse: [ 1	"SS &gt; Ã" ]									]									ifFalse: 									[	char1 &lt; char2 											ifTrue: [ -1 ]											ifFalse: [ 1 ]									]						]				]		].	" check for shorter string (considering each Ã) "	^ atEnd1 		ifTrue: 		[	"self at end"			atEnd2 				ifTrue: 				[	"string at End"					firstNonMatch				]				ifFalse: [ -1 ]		]		ifFalse: [ 1 ]</body></methods><methods><class-id>Core.String</class-id> <category>comparing</category><body package="COBase">coastCompareTypeOrder	^ 4</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="COBase">coastTrimBlanks	"Return a copy of the receiver that has leading and trailing blanks removed."	| size index space |	(size := self size) == 0 ifTrue: [^self].	index := 1.	space := Character space.	[(self at: index) = space] whileTrue: [		index = size ifTrue: [^''].		index := index + 1].	[(self at: size) = space] whileTrue: [		index = size ifTrue: [^''].		size := size - 1].	^self copyFrom: index to: size</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="COBase">isValidFrameIDString	^ COAST.CatCSFrameLocator isValidFrameIDString: self</body></methods><methods><class-id>Core.String</class-id> <category>testing</category><body package="COBase">isValidVolumeString	(self isEmpty or: [ self = '..' or: [self = '.']])		ifTrue: ["oh no!!" ^false].	self do:	[ :char | | cv |		('\:"/|&lt;&gt;=;,*?' includes: char) ifTrue: [ ^false ].		cv := char asInteger.		cv &lt; 32 "space" ifTrue: [^false].		cv = 8r177 "del" ifTrue: [^false]	].	^true</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="COBase">replaceSubstrings: subString by: replacementString		| resultStream index |	resultStream := String new writeStream.	index := 1.	[ index &gt; self size ] whileFalse:	[ | targetIdx |		targetIdx := self indexOfSubCollection: subString startingAt: index.		targetIdx = 0			ifTrue:			[				index to: self size do: [ : idx | resultStream nextPut: (self at: idx) ].				index :=self size + 1.			]			ifFalse:			[				index to: targetIdx - 1 do: [ : idx | resultStream nextPut: (self at: idx) ].				resultStream nextPutAll: replacementString.				index := targetIdx + subString size.			].	].	^resultStream contents</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="COBase">withSeparator	^ self last = Filename separator		ifTrue: [ self ]		ifFalse: [ self, (String with: Filename separator)].</body></methods><methods><class-id>Core.Magnitude</class-id> <category>comparing</category><body package="COBase">coastCompareMagnitudeTo: aMagnitude 	^ self &lt; aMagnitude 		ifTrue: [ -1 ]		ifFalse: 		[	self = aMagnitude 				ifTrue: [ 0 ]				ifFalse: [ 1 ]		]</body><body package="COBase">coastCompareTo: aMagnitude 	| compareType |	compareType := self coastCompareTypeOrder coastCompareMagnitudeTo: aMagnitude coastCompareTypeOrder.	"nicht #coastCompareTo: benutzen -&gt; Endlosschleife ;)"	^ 0 == compareType 		ifTrue: [( aMagnitude coastCompareMagnitudeTo: self ) negated ]		ifFalse: [ compareType ]</body></methods><methods><class-id>Core.ArrayedCollection class</class-id> <category>instance creation</category><body package="COBase">newForValueHolder	^ self new: 0</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="COBase">anyKey	"use #keysAndValuesDo: instead of #associationsDo: -&gt; speedup for IdentityDictionary"	self keysAndValuesDo: [: key : igoneThis | ^ key ].	^ nil</body><body package="COBase">atKey: key 	^ self at: key ifAbsent: nil</body><body package="COBase">atKey: key ifAbsent: aBlock 	^ self at: key ifAbsent: aBlock</body><body package="COBase">atKeys: someKeys	| result |	result := self species new.	someKeys do: [ : k | 		| v |		(v := self atKey: k) notNil			ifTrue: [ result at: k put: v ]	].	^ result</body><body package="COBase">atKeys: someKeys maxRPCSize: maxKeysSize	^ self atKeys: someKeys</body><body package="COBase">atKeys: someKeys maxRPCSize: maxKeysSize restrictToValues: values	| keys |	keys := self atKeys: someKeys.	^keys select: [ :key | values includes: (self at: key) ]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>iterating</category><body package="COBase">coastAllArgumentsDo: aBlock 	self keysAndValuesDo: 		[: k : v |			aBlock value: k.			aBlock value: v		].</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="COBase">coastTotalByteSize	| sz |	sz := self coastObjectSize.	self associationsDo: 		[: assoc |			sz := sz + assoc coastObjectSize + assoc key coastReferencedObjectSize 					+ assoc value coastReferencedObjectSize		].	^ sz</body><body package="COBase">compactAtKey: key 	^ self at: key ifAbsent: nil</body><body package="COBase">eachKeyIn: someKeys do: eachKeyBlock	" perform the eachKeyBlock for each occurrence of the key in this dictionary/index.	Equivalent to 		(self atKeys: someKeys) keysDo: eachKeyBlock	but faster for some classes "	someKeys do: [ : k | 		(self atKey: k) notNil			ifTrue: [ eachKeyBlock value: k ]	].</body><body package="COBase">translatedArgumentForCluster: aCatCSCluster	"bogous: addedFrames contains frame references "	self error: 'Set all for dictionaries not supported'</body></methods><methods><class-id>Core.Dictionary</class-id> <category>converting</category><body package="COBase">valuesDo: block	self do: block</body></methods><methods><class-id>Core.True</class-id> <category>logical operations</category><body package="COBase">coastCompareBooleanTo: aBoolean 	"(true coastCompareTo: true) -&gt; 0	(true coastCompareTo: false) -&gt; 1	(false coastCompareTo: true) -&gt; -1	(false coastCompareTo: false) -&gt; 0"	^ aBoolean 		ifTrue: [ 0 ]		ifFalse: [ 1 ]</body></methods><methods><class-id>Core.True</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body><body package="COBase">supervisorMarshalTo: aStream	aStream nextPut: self class marshallID.</body></methods><methods><class-id>Core.ProcessEnvironment</class-id> <category>environment accessing</category><body package="COBase">activeTransaction: aTransaction 	accessLock critical: 		[ | old |			old := environmentDictionary at: #activeTransaction ifAbsent: nil.			old notNil 				ifTrue: [( environmentDictionary at: #activeTransactionStack ifAbsentPut: [ OrderedCollection new ]) addLast: old ].			environmentDictionary at: #activeTransaction put: aTransaction		].</body><body package="COBase">removeActiveTransaction	accessLock critical: 		[ | stack |			stack := environmentDictionary at: #activeTransactionStack ifAbsent: nil.			( stack notNil and: [ stack isEmpty not ]) 				ifTrue: 				[	"COAST.CoastLog logWarning: 'reinstall overridden transaction'."					environmentDictionary at: #activeTransaction put: stack removeLast				]				ifFalse: [ environmentDictionary removeKey: #activeTransaction ifAbsent: [ ]]		].</body></methods><methods><class-id>Core.TwoByteSymbol</class-id> <category>marshalling</category><body package="COBase">asCoastString	^ self</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>accessing</category><body package="COBase">fastIncludes: object 	| index |	index := self indexForInserting: object.	^ firstIndex &lt; index and: [( self basicAt: index - 1 ) = object ]</body></methods><methods><class-id>Core.Collection class</class-id> <category>instance creation</category><body package="COBase">newForValueHolder	^ self new: 1</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="COBase">* anotherCollection	^ (self size &lt;= anotherCollection size or: [ self class ~~ anotherCollection class ])		ifTrue: [ self select: [: x | anotherCollection includes: x ]]		ifFalse: [ anotherCollection select: [: x | self includes: x ]]</body><body package="COBase">anyElement	"Answer an element at an unspecified position." 	self do: [:x | ^x].	^nil</body></methods><methods><class-id>Core.Collection</class-id> <category>iterating</category><body package="COBase">coastAllArgumentsDo: aBlock 	self do: aBlock.</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="COBase">coastArgumentsHash	^ self isEmpty 		ifTrue: [ 12345 ]		ifFalse: 		[	self inject: nil				into: 				[: hash : object |					hash notNil 						ifTrue: [ hash bitXor: object hash ]						ifFalse: [ object hash ]				]		]</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="COBase">coastAsSet	^self asSet</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="COBase">coastAsSortedValidKeys	"remove invalid elements, sort remaining keys"	| sortedKeys |	sortedKeys := nil.	self do: 		[: e |			e coastIsValidRPCArgument ifFalse: 				[	"try to save a unnessesary copy in most cases (no local frames present)"					sortedKeys isNil ifTrue: [ sortedKeys := self copy ].					sortedKeys remove: e				]		].	"ohne local Frames"	sortedKeys isNil ifTrue: [ sortedKeys := self ].	^ sortedKeys := sortedKeys asSortedCollection: [: a : b | a coastLessThan: b ]</body><body package="COBase">coastCompactElementCount	^ self size</body><body package="COBase">coastTotalByteSize	^ self inject: self coastObjectSize into: [ : sz : val | sz + val coastReferencedObjectSize ]</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="COBase">collect: block as: collectionClass 	| result |	result := collectionClass new: self size.	self do: [: elem | result add: ( block value: elem )].	^ result</body><body package="COBase">collectAsArray: aBlock	| array i |	array := Array new: self size.	i := 1.	self do: [ :element |		array at: i put: (aBlock value: element).		i := i + 1.	].	^ array</body><body package="COBase">collectAsOrderedCollection: aBlock	| oc |	oc := OrderedCollection new: self size.	self do: [ :element | oc add: (aBlock value: element) ].	^ oc</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="COBase">defaultMoreBlock	^[self error: 'this collection should contain a single object']</body><body package="COBase">defaultNoneBlock	^[self emptyCollectionError]</body><body package="COBase">hasObserversWithRevalidationBlock	^ self contains: [: obs | obs revalidationBlock notNil ]</body><body package="COBase">singleElement	^self singleElementIfNone: self defaultNoneBlock ifMore: self defaultMoreBlock</body><body package="COBase">singleElementDo: aBlock	| element |	element := self singleElementOrNil.	element notNil ifTrue: [ aBlock value: element ].</body><body package="COBase">singleElementIfMore: moreBlock 	^self singleElementIfNone: self defaultNoneBlock ifMore: moreBlock</body><body package="COBase">singleElementIfNone: noneBlock	^self singleElementIfNone: noneBlock ifMore: self defaultMoreBlock</body><body package="COBase">singleElementIfNone: noneBlock ifMore: moreBlock 	self isEmpty ifTrue: [ ^ noneBlock value ].	self size &gt; 1 ifTrue: 		[	^ moreBlock notNil 				ifTrue: 				[	moreBlock numArgs = 0 						ifTrue: [ moreBlock value ]						ifFalse: [ moreBlock value: self ]				]				ifFalse: [ nil ]		].	^ self detect: [: x | true ] ifNone: noneBlock	"noneBlock may occur on concurrent accessings"</body><body package="COBase">singleElementOnError: aBlock	^self singleElementIfNone: aBlock ifMore: aBlock</body><body package="COBase">singleElementOrNil	^self singleElementOnError: [nil]</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="COBase">sortedBy: aBlock 	| associations sortedAssociations |	self size &lt; 2 ifTrue: [ ^ self collectAsOrderedCollection: [: e | e ]].	associations := self collectAsArray: [: x | ( aBlock value: x ) -&gt; x ].	sortedAssociations := associations asSortedCollection: [: x : y | x key &lt;= y key ].	^ sortedAssociations collectAsOrderedCollection: [: assoc | assoc value ]</body></methods><methods><class-id>Core.ISO8859L1String</class-id> <category>marshalling</category><body package="COBase">asCoastString	^ self</body><body package="COBase">isCoastPrimitiveValue	^ true</body></methods><methods><class-id>Security.RSA class</class-id> <category>accessing</category><body package="COBase">coastVerify: aSignatureArray of: aMessageByteArray publicKey: aPublicKey 	| int |	int := aSignatureArray asLargePositiveInteger.	^ ( aPublicKey exponentPowerOf: int ) = aMessageByteArray asLargePositiveInteger</body></methods><methods><class-id>Security.RSA</class-id> <category>services</category><body package="COBase">coastSign: aMessageByteArray 	| int |	int := aMessageByteArray asLargePositiveInteger.	int &gt;= privateKey n ifTrue: [ COAST.CoastError raiseSignal: 'message to encrypt is to long' ].	privateKey n digitLength - int digitLength &gt; 1 ifTrue: [ COAST.CoastError raiseSignal: 'message to encrypt is to short' ].	^ ( privateKey exponentPowerOf: int ) asBigEndianByteArray</body></methods><methods><class-id>Core.Point</class-id> <category>comparing</category><body package="COBase">coastCompareMagnitudeTo: point  	^ x = point x 		ifTrue: [ y coastCompareTo: point y ]		ifFalse: [ x coastCompareTo: point x ]</body><body package="COBase">coastCompareTypeOrder	^ 9</body></methods><methods><class-id>Core.Point</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ x isInteger and: [ y isInteger ]</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>marshalling</category><body package="COBase">supervisorUnmarshalPrimitiveFrom: aStream	| baSize ba |	baSize := aStream nextOptimized32.	ba := self new: baSize.	aStream next: baSize into: ba startingAt: 1.	^ ba</body></methods><methods><class-id>Core.ByteArray</class-id> <category>As yet unclassified</category><body package="COBase">asIPAdressString	| stream |	stream := String new writeStream.	self 		do: [: element | element printOn: stream ]		separatedBy: [ stream nextPut: $. ].	^ stream contents</body></methods><methods><class-id>Core.ByteArray</class-id> <category>comparing</category><body package="COBase">coastCompareTypeOrder	^ 7</body></methods><methods><class-id>Core.ByteArray</class-id> <category>accessing</category><body package="COBase">coastTotalByteSize	^ self coastObjectSize</body></methods><methods><class-id>Core.ByteArray</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body><body package="COBase">supervisorMarshalTo: aStream	aStream nextPut: self class marshallID.	aStream nextOptimized32Put: self size.	aStream nextPutAll: self.</body></methods><methods><class-id>Tools.Notifier class</class-id> <category>accessing</category><body package="COBase">headlessDo: headlessBlock	^ self headlessDo: headlessBlock elseDo: [ nil ]</body><body package="COBase">headlessDo: headlessBlock elseDo: elseBlock 	^ self isHeadless 		ifTrue: 		[	#{HeadlessImage} 				ifDefinedDo: 				[: headlessImageClass |					headlessBlock numArgs = 1 						ifTrue: [ headlessBlock value: headlessImageClass default ]						ifFalse: [ headlessBlock value ]				]				elseDo: [ elseBlock value ]		]		ifFalse: [ elseBlock value ]</body><body package="COBase">isHeadless	^ #{HeadlessImage} ifDefinedDo: [ : cl | cl default isHeadless ] elseDo: [ false ]</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body></methods><methods><class-id>Core.Float</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ true</body></methods><methods><class-id>Core.FourByteSymbol</class-id> <category>marshalling</category><body package="COBase">isCoastPrimitiveValue	^ false</body></methods><methods><class-id>Core.Character class</class-id> <category>private</category><body package="COBase">bigSwapArray	| bigSwapDict |	bigSwapDict := Array new: 16rFFFF.	SmallSpecialLetters 		keysAndValuesDo: [: k : v | ( v notNil and: [ v isString not ]) ifTrue: [ bigSwapDict at: k asInteger put: v asInteger ]].	CapitalSpecialLetters 		keysAndValuesDo: [: k : v | ( v notNil and: [ v isString not ]) ifTrue: [ bigSwapDict at: k asInteger put: v asInteger ]].	^ bigSwapDict</body></methods><methods><class-id>Core.Character</class-id> <category>COAST</category><body package="COBase">coastEqual: otherChar ignoreCase: ignoreCase 	"| swapArray |	swapArray := Array new: 255.	1 to: 255		do: 		[: i | | c1 c2 |			c1 := Character value: i .			c2 := c1 asUppercase.			c1 == c2 ifTrue: [ c2 := c1 asLowercase ].			swapArray at: i  				put: ( c1 == c2 						ifTrue: [ nil ]						ifFalse: [ c2 asInteger])		].	swapArray"	| i j |	self == otherChar ifTrue: [ ^ true ].	ignoreCase ifFalse: [ ^ false ].	i := self asInteger.	i == 0 ifTrue: [ ^ false ].	j := otherChar asInteger.	^ ( i &lt; 256 and: [ j &lt; 256 ]) 		ifTrue: 		[	"look up in the inlined swapArray"			( #( nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 nil nil nil nil nil nil 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 nil 248 249 250 251 252 253 254 nil 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 nil 216 217 218 219 220 221 222 376 ) 				at: i ) == j		]		ifFalse: [ self asUppercase == otherChar or: [ self == otherChar asUppercase ]]</body></methods><methods><class-id>Core.Bag</class-id> <category>accessing</category><body package="COBase">* collection 	^ contents keys * collection</body></methods><methods><class-id>Core.Bag</class-id> <category>enumerating</category><body package="COBase">coastAsSet	"do not copy keys"	^ contents keys</body></methods><methods><class-id>Core.Bag</class-id> <category>accessing</category><body package="COBase">coastCompactElementCount	^ self numberOfKeys</body><body package="COBase">numberOfKeys	^contents size</body></methods><methods><class-id>Core.Error</class-id> <category>testing</category><body package="COBase">isFatalCoastError	^ false</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>As yet unclassified</category><body package="COCellAccesses">coastCopyWith: awareness	| newSortedCollection |	newSortedCollection := self species new: self size.	newSortedCollection sortBlock: (self sortBlock).	self do: [:each | newSortedCollection add: (each coastCopyWith: awareness)].	^newSortedCollection</body></methods><methods><class-id>Core.Behavior</class-id> <category>As yet unclassified</category><body package="COCellAccesses">coastCopyWith: awareness	^self</body></methods><methods><class-id>Core.Association</class-id> <category>accessing</category><body package="COCellAccesses">coastCompareTo: assoc 	| compare |	compare := key coastCompareTo: assoc key.	^ compare = 0 		ifTrue: [ value coastCompareTo: assoc value ]		ifFalse: [ compare ]</body></methods><methods><class-id>Core.Association</class-id> <category>copying</category><body package="COCellAccesses">coastCopyWith: awareness	^self class		key: (key coastCopyWith: awareness)		 value: (value coastCopyWith: awareness)</body></methods><methods><class-id>Core.Association</class-id> <category>accessing</category><body package="COCellAccesses">coastLessThan: assoc 	| compare |	compare := self coastCompareTo: assoc.	^ compare = -1</body></methods><methods><class-id>Core.Dictionary</class-id> <category>converting</category><body package="COCellAccesses">asMultiValueDictionary	| mvd |	mvd := COAST.MultiValueDictionary new: self size.	self keysAndValuesDo: [: k : values | values do: [: v | mvd atKey: k add: v ]].	^ mvd</body></methods><methods><class-id>Core.Dictionary</class-id> <category>As yet unclassified</category><body package="COCellAccesses">coastCopyWith: awareness	| theCopy |	theCopy := self species new.	self keysAndValuesDo: [:k :v | theCopy at: (k coastCopyWith: awareness) put: (v coastCopyWith: awareness)].	^theCopy</body></methods><methods><class-id>Core.Interval</class-id> <category>copy</category><body package="COCellAccesses">coastCopyWith: awareness 	"Do not acces instVars directly here (portability issue!)"	^self class		from: (self first coastCopyWith: awareness)		to: (self last coastCopyWith: awareness)		by: (self increment coastCopyWith: awareness)</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="COCellAccesses">coastCopyWith: awareness	^self collect: [:x | x coastCopyWith: awareness]</body></methods><methods><class-id>Core.Object</class-id> <category>copy</category><body package="COCellAccesses">coastCopyWith: awareness	^self copy</body></methods><methods><class-id>Core.Object</class-id> <category>marshalling</category><body package="COCellAccesses">isValidAccessParameter	^ self isCoastPrimitiveValue</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>copying</category><body package="COCellAccesses">coastCopyWith: copyContext	^copyContext copyOfPrimitive: self</body></methods><methods><class-id>Core.Dictionary</class-id> <category>private</category><body package="COCellValueHolder">postRPCInitializeWith: delegatingProxy 	"due pending updates rpc results might contain frames of local loaded clusters"	"which are not yet known to this client - these must be hidden"	| resultDict |	resultDict := Dictionary new: self size.	self keysAndValuesDo: 		[: k : v | "hide yet unknown frames "			| resultKey resultValue |			resultKey := k isCoastPrimitiveValue 					ifTrue: [ k ]					ifFalse: [ delegatingProxy resolveFrameReference: k ].			resultValue := v isCoastPrimitiveValue 					ifTrue: [ v ]					ifFalse: [ delegatingProxy resolveFrameReference: v ].			( resultKey notNil and: [ resultValue notNil or: [ v isNil ]]) 				ifTrue: [ resultDict at: resultKey put: resultValue ]				ifFalse: [ COAST.CoastLog logWarning: 'RPC result contains unknown frame'	"this can happen, when updates are pending" ]		].	^ resultDict</body></methods><methods><class-id>Core.Dictionary</class-id> <category>enumerating</category><body package="COCellValueHolder">referencesElementsCursorDo: block 	self associations do: block.</body></methods><methods><class-id>Core.Dictionary</class-id> <category>removing</category><body package="COCellValueHolder">restrictToValues: rvalues 	"return a copy restricted to the given values"	| restrictedDict |	restrictedDict := Dictionary new: rvalues size.	self keysAndValuesDo: [ : k : v | (rvalues includes: v) ifTrue: [ restrictedDict at: k put: v ] ].	^restrictedDict</body></methods><methods><class-id>Core.Association</class-id> <category>accessing</category><body package="COCellValueHolder">copyForRefCursor	^ key copyForRefCursor -&gt; value copyForRefCursor</body></methods><methods><class-id>Core.Association</class-id> <category>testing</category><body package="COCellValueHolder">isValidRPCResultWith: clusterManager 	^ ( key isValidRPCResultWith: clusterManager ) and: [ value isValidRPCResultWith: clusterManager ]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="COCellValueHolder">asCoastValueHolder	^ (COAST.CatCSOrderedCollection new)		value: self;		yourself</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="COCellValueHolder">coastOptimizedAppendAll: otherCollections 	| newSequenceableCollection oldSize othersSize |	oldSize := self size.	othersSize := otherCollections inject: 0 into: [: sum : otherCollection | sum + otherCollection size ].	newSequenceableCollection := self coastOptimizedGrownBy: othersSize.	otherCollections inject: oldSize		into: 		[: start : otherCollection | | endReplacement |			endReplacement := start + otherCollection size.			newSequenceableCollection coastOptimizedReplaceFrom: start + 1 to: endReplacement with: otherCollection startingAt: 1.			endReplacement		].	^ newSequenceableCollection</body><body package="COCellValueHolder">coastOptimizedGrownBy: size 	| newSequenceableCollection newSize oldSize |	size &lt;= 0 ifTrue: [ ^ self ].	oldSize := self size.	newSize := oldSize + size.	newSequenceableCollection := self species withSize: newSize.	newSequenceableCollection coastOptimizedReplaceFrom: 1 to: oldSize with: self startingAt: 1.	^ newSequenceableCollection</body><body package="COCellValueHolder">coastOptimizedReplaceFrom: start to: stop with: replacement startingAt: repStart 	"hook for DwordArray"	self replaceFrom: start to: stop with: replacement startingAt: repStart.</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="COCellValueHolder">partitionedBy: limit 	"divide myself into smaller collections with a maximum of &lt;limit&gt; elements"	| partitions resArray |	partitions := (self size / limit) ceiling.	resArray := Array new: partitions.	1 to: partitions - 1		do: [: index | resArray at: index put: (self copyFrom: (index - 1) * limit + 1 to: index * limit) ].	resArray at: partitions put: (self copyFrom: (partitions - 1) * limit + 1 to: self size).	^ resArray</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>private</category><body package="COCellValueHolder">postRPCInitializeWith: delegatingProxy 	^ self asOrderedCollection postRPCInitializeWith: delegatingProxy</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="COCellValueHolder">selectValidRPCArguments	" keys nicht schon auf verdacht hin selecten, weil das bei vielen keys teuer sein kann und es normalerweise nicht passieren sollte "	1 to: self size do: [ : i | | validKeys |		(self at: i) coastIsValidRPCArgument			ifFalse: [				" bereits geprÃ¼fte keys "				validKeys := OrderedCollection new: self size.				validKeys changeSizeTo: i - 1.				validKeys replaceFrom: 1 to: i - 1 with: self startingAt: 1.				"  rest Ã¼berprÃ¼fen "				i + 1 to: self size do: [ : j | | key |					( key := self at: j) coastIsValidRPCArgument						ifTrue: [ validKeys add: key ].				].				^ validKeys			].	].	" alle keys sind valid "	^ self</body><body package="COCellValueHolder">transformWith: transformation from: original 	transformation performMovesFrom: original to: self.</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="COCellValueHolder">asRPCArguments	^ ( self allSatisfy: [: elem | elem isCoastFrame and: [ elem coastIsValidRPCArgument ]]) 		ifTrue: [ COAST.CompactSet withAll: self ]		ifFalse: [ self asSortedCollection: [: a : b | a coastLessThan: b ]]</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="COCellValueHolder">coastDepletedValue	^ self class new</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="COCellValueHolder">coastIncludesCompactKey: compactKey 	compactKey isFrameOrFrameReference ifFalse: [ ^ self includes: compactKey ].	^ self contains: 		[: e |			e == compactKey or: [ e isCoastFrame and: [ e frameID = compactKey frameID and: [ e clusterID = compactKey clusterID ]]]		]</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="COCellValueHolder">cutWithCompactCollection: aCompactCollection	^ aCompactCollection cutWithCollection: self</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="COCellValueHolder">referencesElementsCursorDo: aBlock 	self do: aBlock.</body><body package="COCellValueHolder">selectValidRPCArguments	" keys nicht schon auf verdacht hin selecten, weil das bei vielen keys teuer sein kann und es normalerweise nicht passieren sollte "	^ ( self allSatisfy: [: key | key coastIsValidRPCArgument ]) 		ifTrue: [ self ]		ifFalse: [ self select: [: key | key coastIsValidRPCArgument ]]</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>accessing</category><body package="COCellValueHolder">coastOptimizedGrownBy: size 	^ self capacity &gt;= ( self size + size ) 		ifTrue: [ self ]		ifFalse: [ super coastOptimizedGrownBy: size ]</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>private</category><body package="COCellValueHolder">postRPCInitializeWith: delegatingProxy 	self isEmpty ifTrue: [ ^ self copy ].	self anyElement isCoastPrimitiveValue ifTrue: [ ^ self copy ].	^ self inject: ( self copyEmpty: self size )		into: 		[: results : frameRef | | frameOrNil |			frameOrNil := delegatingProxy resolveFrameReference: frameRef.			frameOrNil notNil 				ifTrue: [ results add: frameOrNil ]				ifFalse: [ COAST.CoastLog logWarning: 'RPC result contains unknown frame'	"this can happen, when updates are pending" ].			results		]</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COCellValueHolder">coastIsValidRPCArgument	^ self isCoastPrimitiveValue</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COCellValueHolder">coastValueFor: valueHolder 	| myValueHolderClass adaptedValueHolder |	valueHolder valueClass = self class 		ifTrue: [ ^ self copy ].	myValueHolderClass := COAST.CatCSCollection allSubclasses 			detect: [: e | e isAbstractCoastValueHolder not and: [ e valueClass = self class ]]			ifNone: 			[	COAST.CoastError raiseBadValueClass.				^ self			].	adaptedValueHolder := myValueHolderClass new value: self;			adaptedCoastValueHolderToClass: valueHolder.	^ adaptedValueHolder value = self 		ifTrue: 		[	COAST.CoastError raiseBadValueClass.			self		]		ifFalse: [ adaptedValueHolder value coastValueFor: valueHolder ]</body><body package="COCellValueHolder">copyForRefCursor	^ self</body><body package="COCellValueHolder">copyForRollback	^ self</body><body package="COCellValueHolder">frameReferenceOrSelf	^ self</body></methods><methods><class-id>Core.Object</class-id> <category>experimental</category><body package="COCellValueHolder">innerCoastValue	^self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COCellValueHolder">isCoastCollectionFrame	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="COCellValueHolder">isValidRPCResultWith: clusterManager 	^true</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COCellValueHolder">setCompactCollectionClusterManagerFor: compactCollection</body></methods><methods><class-id>Core.Set</class-id> <category>testing</category><body package="COCellValueHolder">coastIncludesCompactKey: compactKey 	| index length probe pass frameID clusterID |	compactKey isFrameOrFrameReference ifFalse: [ ^ self includes: compactKey ].	frameID := compactKey frameID.	length := self basicSize.	pass := 1.	index := self initialIndexFor: frameID boundedBy: length.	clusterID := compactKey clusterID.	[( probe := self basicAt: index ) == nil or: [ probe isCoastFrame and: [ probe frameID = frameID and: [ probe clusterID = clusterID ]]]] whileFalse: 		[( index := index + 1 ) &gt; length ifTrue: 				[	index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [ ^ false ]				]		].	^ probe notNil</body></methods><methods><class-id>Core.Set</class-id> <category>removing</category><body package="COCellValueHolder">coastSubstract: anotherSet 	^ self - anotherSet</body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>accessing</category><body package="COCellValueHolder">frameClassSymbol	^ self</body><body package="COCellValueHolder">frameKey	^ self</body></methods><methods><class-id>Core.Set</class-id> <category>accessing</category><body package="COFramesystem">frameOrNilWithClusterID: clusterID frameID: frameID 	^ self frameWithClusterID: clusterID frameID: frameID withIndexDo: [: probe : index | probe ]</body></methods><methods><class-id>Core.Set</class-id> <category>private</category><body package="COFramesystem">frameWithClusterID: clusterID frameID: frameID withIndexDo: block 	| index length probe pass |	length := self basicSize.	pass := 1.	index := self initialIndexFor: frameID boundedBy: length.	[	probe := self basicAt: index.		probe == nil or: [ probe isCoastFrame and: [ probe clusterID = clusterID and: [ probe frameID = frameID ]]]	] whileFalse: 		[( index := index + 1 ) &gt; length ifTrue: 				[	index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [ ^ nil ]				]		].	^ block value: probe value: index</body></methods><methods><class-id>Core.Set</class-id> <category>accessing</category><body package="COFramesystem">removeFrameWithClusterID: clusterID frameID: frameID 	^ self frameWithClusterID: clusterID		frameID: frameID		withIndexDo: 		[: probe : index |			probe notNil ifTrue: 				[	self basicAt: index put: nil.					tally := tally - 1.					self fixCollisionsFrom: index				].			probe		]</body></methods><methods><class-id>Core.Object class</class-id> <category>accessing</category><body package="COFramesystem">coastIsFrameClass	^ false</body></methods><methods><class-id>Core.Object class</class-id> <category>private</category><body package="COFramesystem">isCoastRangeFor: anObject 	^ anObject isCoastKindOf: self</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COFramesystem">coastComputedValueBeImmutableIfNeeded</body><body package="COFramesystem">coastFrameSetHash	^ self hash</body><body package="COFramesystem">coastFrameSetSegmentHash	^ self hash</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COFramesystem">coastIsBinaryContainer	^ false</body><body package="COFramesystem">coastIsByteArray	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="COFramesystem">equalFromFrameLocator: frameLocator	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>class membership</category><body package="COFramesystem">isCoastKindOf: aClass 	^self isKindOf: aClass</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COFramesystem">isResolvedValueHolder	"do I indicate some kind of value holder or something that can be converted into one?	 - usually something but nil - e.g. Integer, ByteArray, CatCSCellValueHolder"	^ true</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="COFramesystem">markAsEndcellPrototypeValue	self beImmutable.</body></methods><methods><class-id>Core.Object</class-id> <category>observer - subject</category><body package="COFramesystem">revalidationBlock	^nil</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing</category><body package="COFramesystem">isResolvedValueHolder	"do I indicate some kind of value holder? - no"	^ false</body></methods><methods><class-id>Core.Dictionary</class-id> <category>private</category><body package="COFramesystem">fillFrom: segmentedDict atKeys: sortedKeys restrictToValues: rvalues 	self changeCapacityTo: ( self class goodSizeFrom: sortedKeys size ).	sortedKeys do: 		[: key | | value |			value := segmentedDict atKey: key.			( value notNil and: [ rvalues isNil or: [ rvalues includes: value ]]) ifTrue: [ self at: key put: value ]		].</body></methods><methods><class-id>Core.Collection</class-id> <category>private</category><body package="COFramesystem">isCoastRangeFor: anObject 	^ self contains: [: each | anObject isCoastKindOf: each ]</body></methods><methods><class-id>Core.ByteArray</class-id> <category>testing</category><body package="COFramesystem">coastIsByteArray	^ true</body></methods><methods><class-id>Core.SharedQueue</class-id> <category>accessing</category><body package="COEagerObservers">patchQueueForStop	self coastEmptyQueue.	self nextPut: #stopProcessing.</body></methods><methods><class-id>Core.TwoByteString class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 18</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	" convert each two-byte-pair into a character "	^ aStream nextCoastTwoByteString</body></methods><methods><class-id>Core.TwoByteString</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	" convert each character into two bytes "	aStream nextPut: self class marshallID.	aStream nextCoastTwoByteStringPut: self</body></methods><methods><class-id>Core.Object</class-id> <category>marshalling</category><body package="COMarshalling">coastAsArgumentForMinimalInvalidation	^ self</body><body package="COMarshalling">coastAsRemoteArgumentFor: aCluster	^ self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COMarshalling">isCoastOptimizedInteger	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryArgumentTo: aStream marshaller: aCatRMMarshall	self marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	COAST.CoastError raiseSignal: 'COAST error: no primitive marshalling is defined for the class ' , self class printString.</body><body package="COMarshalling">marshallBinaryValueTo: aStream marshaller: aCatRMMarshall 	self marshallBinaryTo: aStream marshaller: aCatRMMarshall.</body><body package="COMarshalling">valueEnsureUpdatedFrameSlotIndexWith: aCatRMMarshall</body></methods><methods><class-id>Core.Symbol class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 15</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	^(ByteString unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall) asSymbol</body></methods><methods><class-id>Core.Symbol</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextPut: self class marshallID.	aStream nextCoastStringPut: self.</body></methods><methods><class-id>Core.Float class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 9</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	"we use platform independent order"	| bytes |	bytes := ByteArray new: 4.	aStream next: 4 into: bytes startingAt: 1.	bytes := UninterpretedBytes from: bytes.	UninterpretedBytes isBigEndian ifFalse: [ bytes swapFloatAt: 1 ].	"DomainError may indicate NaN or Infinity - not supported by floatAt: - use brute force conversion"	^[ bytes floatAt: 1 ] on: DomainError do: [ : err | bytes changeClassTo: Float ].</body></methods><methods><class-id>Core.Float</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	| bytes length |	aStream nextPut: self class marshallID.	"make it platform independent"	length := 4.	bytes := UninterpretedBytes new: length.	bytes floatAt: 1 put: self.	UninterpretedBytes isBigEndian 		ifTrue: [ 1 to: length do: [: idx | aStream nextPut: ( bytes byteAt: idx )]]		ifFalse: [ length to: 1 by: -1 do: [: idx | aStream nextPut: ( bytes byteAt: idx )]].</body></methods><methods><class-id>Core.Number</class-id> <category>testing</category><body package="COMarshalling">coastIsSmallInteger	^ false</body></methods><methods><class-id>Core.Stream class</class-id> <category>accessing</category><body package="COMarshalling">coast1Byte64ID	^ 1</body><body package="COMarshalling">coast2Byte64ID	^ 2</body><body package="COMarshalling">coast4Byte64ID	^ 4</body><body package="COMarshalling">coast8Byte64ID	^ 8</body></methods><methods><class-id>Core.Stream</class-id> <category>private</category><body package="COMarshalling">coastError: string 	COAST.CoastError raiseSignal: string</body></methods><methods><class-id>Core.Stream</class-id> <category>marshalling</category><body package="COMarshalling">coastNextByte	| value |	nil == ( value := self next ) ifTrue: [ self nextByteFailed ].	^ value asInteger</body><body package="COMarshalling">coastNextFor32	| value |	value := self next.	value isNil ifTrue: [ self next32Failed ].	^ value asInteger</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="COMarshalling">coreStream	^ self</body></methods><methods><class-id>Core.Stream</class-id> <category>marshalling optimized read</category><body package="COMarshalling">next14Of32FirstByte: firstByte 	"read a 32-bit integer (64..16383) as 16 bits.( 2 Bits coding length, 14 bits coding value)"	"Bits: 01 + valueBits"	| v1 v2 |	v1 := firstByte bitShift: 8.	v2 := self coastNextFor32.	^ v1 + v2</body></methods><methods><class-id>Core.Stream</class-id> <category>marshalling optimized write</category><body package="COMarshalling">next14Of32Put: aSmall32BitW 	"Write out a 32-bit integer (64..16383) as 16 bits.( 2 Bits coding length, 14 bits coding value)"	"Bits: 01 + valueBits"	self nextPut: (( aSmall32BitW bitShift: -8 ) bitOr: 2r01000000 ).	self nextPut: ( aSmall32BitW bitAnd: 16rFF ).	^ aSmall32BitW</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="COMarshalling">next16	"Answer the next two bytes from the receiver as an Integer."	| high low |	high := self coastNextFor32.	low := self coastNextFor32.	^ ( high asInteger bitShift: 8 ) + low asInteger</body><body package="COMarshalling">next16Put: aWord 	"Append to the receiver an Integer as the next two bytes."	self nextPut: ((aWord bitShift: -8) bitAnd: 255).	self nextPut: (aWord bitAnd: 255).	^aWord</body></methods><methods><class-id>Core.Stream</class-id> <category>marshalling optimized read</category><body package="COMarshalling">next21Of32FirstByte: firstByte 	"Read a 32-bit integer (-2097150..2097151) as 24 bits.( 3 Bits coding length and sign, 21 bits coding value)"	"Bits: 110 + valueBits "	| v1 v2 v3 |	v1 := firstByte bitShift: 16.	v2 := self coastNextFor32 bitShift: 8.	v3 := self coastNextFor32.	^ v1 + v2 + v3</body></methods><methods><class-id>Core.Stream</class-id> <category>marshalling optimized write</category><body package="COMarshalling">next21Of32NegatedPut: aMediumSized32BitW 	"Write out a 32-bit integer (-2097150..0) as 24 bits.( 3 Bits coding length and sign, 21 bits coding value)"	"Bits: 001 + valueBits "	self nextPut: ((( aMediumSized32BitW bitAnd: 16rFF0000 ) bitShift: -16 ) bitAnd: 2r00111111 ).	self nextPut: (( aMediumSized32BitW bitAnd: 16rFF00 ) bitShift: -8 ).	self nextPut: ( aMediumSized32BitW bitAnd: 16rFF ).	^ aMediumSized32BitW</body><body package="COMarshalling">next21Of32Put: aMediumSized32BitW 	"Write out a 32-bit integer (16384..2097151) as 24 bits.( 3 Bits coding length and sign, 21 bits coding value)"	"Bits: 110 + valueBits "	self nextPut: ((( aMediumSized32BitW bitAnd: 16rFF0000 ) bitShift: -16 ) bitXor: 2r11000000 ).	self nextPut: (( aMediumSized32BitW bitAnd: 16rFF00 ) bitShift: -8 ).	self nextPut: ( aMediumSized32BitW bitAnd: 16rFF ).	^ aMediumSized32BitW</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="COMarshalling">next24	"Read a 32-bit quantity from the input stream."	| high med low |	high := self coastNextFor32.	med := self coastNextFor32.	low := self coastNextFor32.	^ ( high bitShift: 16 ) + ( med bitShift: 8 ) + low</body><body package="COMarshalling">next24Put: a24BitW 	"Write out a 32-bit integer as 24 bits."	self nextPut: (( a24BitW bitAnd: 16rFF0000 ) bitShift: -16 ).	self nextPut: (( a24BitW bitAnd: 16rFF00 ) bitShift: -8 ).	self nextPut: ( a24BitW bitAnd: 16rFF ).	^ a24BitW</body><body package="COMarshalling">next32	"Read a 32-bit quantity from the input stream."	" Actually, it's an unsigned 29-bit-number, only SmallIntegers are allowed "	| highH highL lowH lowL a32BitW |	highH := self coastNextFor32.	highL := self coastNextFor32.	lowH := self coastNextFor32.	lowL := self coastNextFor32.	a32BitW := ( highH bitShift: 24 ) + ( highL bitShift: 16 ) + ( lowH bitShift: 8 ) + lowL.	a32BitW coastIsSmallInteger ifFalse: [ self next32MustBeSmallInteger: a32BitW ].	^ a32BitW</body></methods><methods><class-id>Core.Stream</class-id> <category>private</category><body package="COMarshalling">next32Failed	self coastError: 'next32 failed on ' , self printString</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="COMarshalling">next32MustBeSmallInteger: num 	self coastError: '32 bit number ' , num printString , ' is not a SmallInteger'</body><body package="COMarshalling">next32Put: a32BitW 	"Write out a 32-bit integer as 32 bits."	" Actually, it's a 29-bit-number, only SmallIntegers are allowed. It is possible to write signed or unsigned SmallInts,	the reader must take care to use the correct method to read the SmallInt (next32 or nextSigned32) "	a32BitW coastIsSmallInteger ifFalse: [ self next32MustBeSmallInteger: a32BitW ].	self nextPut: (( a32BitW bitShift: -24 ) bitAnd: 16rFF ).	self nextPut: (( a32BitW bitAnd: 16rFF0000 ) bitShift: -16 ).	self nextPut: (( a32BitW bitAnd: 16rFF00 ) bitShift: -8 ).	self nextPut: ( a32BitW bitAnd: 16rFF ).	^ a32BitW</body></methods><methods><class-id>Core.Stream</class-id> <category>marshalling</category><body package="COMarshalling">next64PutInteger: a64BitNumber	self nextPut: (( a64BitNumber bitShift: -56 ) bitAnd: 16rFF ).	self nextPut: (( a64BitNumber bitShift: -48 ) bitAnd: 16rFF ).	self nextPut: (( a64BitNumber bitShift: -40 ) bitAnd: 16rFF ).	self nextPut: (( a64BitNumber bitShift: -32 ) bitAnd: 16rFF ).	self nextPut: (( a64BitNumber bitShift: -24 ) bitAnd: 16rFF ).	self nextPut: (( a64BitNumber bitShift: -16 ) bitAnd: 16rFF ).	self nextPut: (( a64BitNumber bitShift: -8 ) bitAnd: 16rFF ).	self nextPut: ( a64BitNumber bitAnd: 16rFF ).</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="COMarshalling">next64PutLargeInteger: a64BitW 	"Write out an unsigned 64-bit integer "	| basicSize |	basicSize := a64BitW basicSize.	basicSize &gt; 8 ifTrue: [ self error: 'Number ' , a64BitW printString , ' is not a 64-Bit-Number' ].	basicSize + 1 to: 8 do: [: i | self nextPut: 0 ].	basicSize to: 1 by: -1 do: [: i | self nextPut: ( a64BitW basicAt: i )].</body></methods><methods><class-id>Core.Stream</class-id> <category>marshalling optimized write</category><body package="COMarshalling">next6Of32Put: aVerySmall32BitW 	"Write out a 32-bit integer (0..63) as 8 bits.( 2 Bits coding length, 6 bits coding value)"	"Bits: 10 + valueBits"	self nextPut: ( aVerySmall32BitW bitOr: 2r10000000 ).	^ aVerySmall32BitW</body></methods><methods><class-id>Core.Stream</class-id> <category>private</category><body package="COMarshalling">nextByteFailed	self coastError: 'next byte failed on ' , self printString</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="COMarshalling">nextCoastByteStringPut: aByteString 	"Append the length of 'aString' and the string 'aString' itself to	the receiver. (for details of storing length see method nextString)"	" modified: fixed the &gt; 32k String length bug "	| size |	size := aByteString size.	size &lt; 255 		ifTrue: [ self nextPut: size ]		ifFalse: 		[	self nextPut: 255.			self nextOptimized32Put: size		].	1 to: size do: [: i | self nextPut: ( aByteString basicAt: i )].</body><body package="COMarshalling">nextCoastString	"Answer a new String read from the receiver"	| aString length |	length := self next.	"first byte."	length = 255 ifTrue: [ length := self nextOptimized32 ].	^ length &lt; 0 		ifTrue: 		[	"new featrue: #utf8-encoded"			( EncodedStream on: self encodedBy: UTF8StreamEncoder new ) nextAvailable: length abs		]		ifFalse: 		[	"old style - byteString"			aString := ByteString new: length.			1 to: length do: [: i | aString at: i put: self next asCharacter ].			aString		]</body><body package="COMarshalling">nextCoastStringLength	"Answer the String length read from the receiver"	| length |	length := self next.	"first byte."	length = 255		ifTrue: [	length := self nextOptimized32 ].	^length</body><body package="COMarshalling">nextCoastStringPut: aString 	"try as ByteString, dispatch for Non-ByteStrings"	| aByteString |	( aByteString := aString asByteString ) class = ByteString 		ifTrue: [ self nextCoastByteStringPut: aByteString ]		ifFalse: [ self nextCoastUTF8StringPut: aByteString ].</body></methods><methods><class-id>Core.Stream</class-id> <category>marshalling</category><body package="COMarshalling">nextCoastTwoByteString	" convert each two-byte-pair into a character "	| string word size |	size := self nextOptimized32.	string := TwoByteString new: size.	1 to: size		do: 		[: i |			word := self next16.			string at: i put: ( Character value: word )		].	^ string</body><body package="COMarshalling">nextCoastTwoByteStringPut: twoByteString 	| int |	self nextOptimized32Put: twoByteString size.	1 to: twoByteString size		do: 		[: i |			int := ( twoByteString at: i ) asInteger.			self nextPut: (( int bitAnd: 65280 ) bitShift: -8 ).			self nextPut: ( int bitAnd: 255 )		].</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="COMarshalling">nextCoastUTF8StringPut: aString 	"save the string length and ste sting itself as UTF8-encoded"	"Note: the bytes needed and the size needn't match"	| size |	size := aString size.	self nextPut: 255.	self nextOptimized32Put: size negated.	( EncodedStream on: self encodedBy: UTF8StreamEncoder new ) nextPutAll: aString.</body></methods><methods><class-id>Core.Stream</class-id> <category>marshalling optimized read</category><body package="COMarshalling">nextFull32FirstByte: firstByte 	"Read a 32-bit quantity from the input stream."	| v1 v2 v3 v4 |	v1 := firstByte bitShift: 24.	v2 := self coastNextFor32 bitShift: 16.	v3 := self coastNextFor32 bitShift: 8.	v4 := self coastNextFor32.	^ v1 + v2 + v3 + v4</body></methods><methods><class-id>Core.Stream</class-id> <category>marshalling</category><body package="COMarshalling">nextFull32Put: a32BitW 	"Write out a 32-bit integer as 32 bits."	a32BitW coastIsSmallInteger ifFalse: [ self next32MustBeSmallInteger: a32BitW ].	self nextPut: (( a32BitW bitShift: -24 ) bitAnd: 16rFF ).	self nextPut: (( a32BitW bitAnd: 16rFF0000 ) bitShift: -16 ).	self nextPut: (( a32BitW bitAnd: 16rFF00 ) bitShift: -8 ).	self nextPut: ( a32BitW bitAnd: 16rFF ).	^ a32BitW</body><body package="COMarshalling">nextOptimized32	| firstByte bitPattern value |	firstByte := self coastNextFor32.	bitPattern := firstByte bitAnd: 2r11100000.	"first two bits = 10 ==&gt; 0 .. 63"	( bitPattern == 2r10000000 or: [ bitPattern == 2r10100000 ]) ifTrue: [ ^ firstByte bitXor: 2r10000000 ].	"first two bits = 01 ==&gt; 64 .. 16383"	( bitPattern == 2r01000000 or: [ bitPattern == 2r01100000 ]) ifTrue: 		[	firstByte := firstByte bitXor: 2r01000000.			^ self next14Of32FirstByte: firstByte		].	"first tree bits = 110 ==&gt; 16384 .. 2097151"	bitPattern == 2r11000000 ifTrue: 		[	firstByte := firstByte bitXor: 2r11000000.			^ self next21Of32FirstByte: firstByte		].	"first tree bits = 000 ==&gt; 2097152 .. maxVal"	bitPattern == 2r00000000 ifTrue: [ ^ self nextFull32FirstByte: firstByte ].	"first tree bits = 001 ==&gt; -2097152 .. -1"	bitPattern == 2r00100000 ifTrue: 		[	firstByte := firstByte bitXor: 2r11000000.			value := self next21Of32FirstByte: firstByte.			^ -1 - ( value bitXor: 16rFFFFFF )		].	"first tree bits = 111 ==&gt; minVal .. -2097153"	bitPattern == 2r11100000 ifTrue: 		[	value := self nextFull32FirstByte: firstByte.			^ -1 - ( value bitXor: 16rFFFFFFFF )		].	self next32Failed</body><body package="COMarshalling">nextOptimized32Put: a32BitVal 	^ a32BitVal &lt; 64 		ifTrue: 		[	a32BitVal &lt; 0 				ifTrue: 				[	a32BitVal &lt; -2097152 						ifTrue: [ self nextFull32Put: a32BitVal	"minVal .. -2097153" ]						ifFalse: [ self next21Of32NegatedPut: a32BitVal	"-2097152 .. -1" ]				]				ifFalse: [ self next6Of32Put: a32BitVal	"0..63" ]		]		ifFalse: 		[	a32BitVal &lt; 16384 				ifTrue: [ self next14Of32Put: a32BitVal	"64 .. 16383" ]				ifFalse: 				[	a32BitVal &lt; 2097152 						ifTrue: [ self next21Of32Put: a32BitVal	"16384 .. 2097151" ]						ifFalse: [ self nextFull32Put: a32BitVal	"2097152 .. maxVal" ]				]		]</body></methods><methods><class-id>Core.Stream</class-id> <category>private</category><body package="COMarshalling">nextOptimized32SizeBefore: block 	| calStream |	calStream := COAST.SizeCalculatingStream new initialize.	block value: calStream.	self nextOptimized32Put: calStream byteSize.	block value: self.</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="COMarshalling">nextOptimizedUnsigned64	"Write out an unsigned 64-bit integer "	| id |	id := self next.	id = self class coast1Byte64ID ifTrue: [ ^ self coastNextByte ].	id = self class coast2Byte64ID ifTrue: [ ^ self nextUnsigned16 ].	id = self class coast4Byte64ID ifTrue: [ ^ self nextUnsigned32 ].	id = self class coast8Byte64ID ifTrue: [ ^ self nextUnsigned64 ].	^ self error: 'Corrupt optimized 64 Bit Number, wrong id ', id printString</body><body package="COMarshalling">nextOptimizedUnsigned64Put: a64BitW 	"Write out an unsigned 64-bit integer "	a64BitW nextOptimizedUnsignedOn: self.</body><body package="COMarshalling">nextShortString	"Answer a new String read from the receiver. The first byte is the 	length of the string."	| aString length |	length := self next.				"&lt;- first byte."	aString := String new: length.	1 to: length do: [:i | aString at: i put: self next asCharacter].	^aString</body><body package="COMarshalling">nextShortStringPut: aString 	"Append the length of 'aString' and the string 'aString' itself to	the receiver. A string longer than 255 characters will report	an error message."	| size |	size := aString size.	size &gt; 255 ifTrue: [ self error: 'String to long for this method. Use nextStringPut:' ].	self nextPut: size.	1 to: size do: [: i | self nextPut: ( aString basicAt: i )].</body><body package="COMarshalling">nextSigned32	"Read a signed 32-bit quantity from the input stream."	"signed 32-bit quantities can be written with next32Put:"	" Actually, it's a signed 29-bit-number, only SmallIntegers are allowed "	| firstByte aSigned32BitW |	firstByte := self coastNextFor32.	aSigned32BitW := firstByte highBit = 8 			ifTrue: 			[ | value |				value := self nextFull32FirstByte: firstByte.				-1 - ( value bitXor: 16rFFFFFFFF )			]			ifFalse: [ self nextFull32FirstByte: firstByte ].	aSigned32BitW coastIsSmallInteger ifFalse: [ self next32MustBeSmallInteger: aSigned32BitW ].	^ aSigned32BitW</body><body package="COMarshalling">nextUnsigned16	"Read an unsigned 16-bit Integer from the input stream."	| b8 b0 |	b8 := self coastNextByte.	b0 := self coastNextByte.	^ ( b8 bitShift: 8 ) + b0</body><body package="COMarshalling">nextUnsigned16Put: a16BitW 	"Write out an unsigned 16-bit integer "	a16BitW &gt; 16rFFFF ifTrue: [ self error: 'Number ' , a16BitW printString , ' is not a 16-Bit-Number' ].	self nextPut: (( a16BitW bitShift: -8 ) bitAnd: 16rFF ).	self nextPut: ( a16BitW bitAnd: 16rFF ).	^ a16BitW</body><body package="COMarshalling">nextUnsigned32	"Read an unsigned 32-bit Integer from the input stream."	| b24 b16 b8 uint32 |	b24 := self coastNextByte.	b16 := self coastNextByte.	b8 := self coastNextByte.	uint32 := self coastNextByte.	b8 == 0 ifFalse: [ uint32 := uint32 + ( b8 bitShift: 8 ) ].	b16 == 0 ifFalse: [ uint32 := uint32 + ( b16 bitShift: 16 ) ].	b24 == 0 ifFalse: [ uint32 := uint32 + ( b24 bitShift: 24 ) ].	^ uint32</body><body package="COMarshalling">nextUnsigned32Put: a32BitW 	"Write out an unsigned 32-bit integer "	a32BitW &gt; 16rFFFFFFFF ifTrue: [ self error: 'Number ' , a32BitW printString , ' is not a 32-Bit-Number' ].	self nextPut: (( a32BitW bitShift: -24 ) bitAnd: 16rFF ).	self nextPut: (( a32BitW bitShift: -16 ) bitAnd: 16rFF ).	self nextPut: (( a32BitW bitShift: -8 ) bitAnd: 16rFF ).	self nextPut: ( a32BitW bitAnd: 16rFF ).</body><body package="COMarshalling">nextUnsigned64	"Read an unsigned 64-bit Integer from the input stream."	| byte largeInteger |	largeInteger := nil.	8 to: 5		by: -1		do: 		[: pos |			byte := self coastNextByte.			0 == byte ifFalse: 				[	nil == largeInteger ifTrue: [ largeInteger := LargePositiveInteger basicNew: pos ].					largeInteger basicAt: pos put: byte				]		].	^ nil == largeInteger 		ifTrue: [ self nextUnsigned32 ]		ifFalse: 		[	largeInteger basicAt: 4 put: self coastNextByte.			largeInteger basicAt: 3 put: self coastNextByte.			largeInteger basicAt: 2 put: self coastNextByte.			largeInteger basicAt: 1 put: self coastNextByte.			largeInteger		]</body><body package="COMarshalling">nextUnsigned64Put: a64BitW 	"Write out an unsigned 64-bit integer "	 a64BitW nextUnsigned64On: self</body><body package="COMarshalling">oldNextCoastStringLength	"Answer a new String length read from the receiver. The first byte is the 	length of the string, unless it is more than 127 (indicateing, that the length	is at least 128). 	Warning: we asume that no text will be longer than 32000 characters	used for compatiblity "	| length |	length := self next.	"first byte."	length &gt;=128 		ifTrue: [	length := ((255 - length) * 256) + self next].	^length</body></methods><methods><class-id>Core.LargePositiveInteger class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 16</body></methods><methods><class-id>Core.LargePositiveInteger</class-id> <category>private</category><body package="COMarshalling">checkUnsigned64Bit	" slightly optimized "	self basicSize &gt;8		ifTrue: [ self raiseNotAnUnsigned64BitNumber ].</body></methods><methods><class-id>Core.LargePositiveInteger</class-id> <category>marshalling</category><body package="COMarshalling">nextUnsigned64On: stream 	stream next64PutLargeInteger: self.</body><body package="COMarshalling">nextUnsigned64On: byteArray after: position 	byteArray next64PutLargeInteger: self after: position</body></methods><methods><class-id>Core.Double class</class-id> <category>marshalling</category><body package="COMarshalling">marshallDouble: aDouble binaryTo: aStream marshaller: aCatRMMarshall 	| doubleBytes length |	aStream nextPut: self marshallID.	length := 8.	doubleBytes := UninterpretedBytes new: 8.	doubleBytes doubleAt: 1 put: aDouble.	" Make it platform independent.  "	UninterpretedBytes isBigEndian 		ifTrue: [ 1 to: length do: [: idx | aStream nextPut: ( doubleBytes byteAt: idx )]]		ifFalse: [ length to: 1 by: -1 do: [: idx | aStream nextPut: ( doubleBytes byteAt: idx )]].</body><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 10</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	| bytes |	bytes := ByteArray new: 8.	aStream next: 8 into: bytes startingAt: 1.	bytes := UninterpretedBytes from: bytes.	"we use platform independent order"	UninterpretedBytes isBigEndian 		ifFalse: [ bytes swapDoubleAt: 1 ].	"DomainError may indicate NaN or Infinity - not supported by doubleAt: - use brute force conversion"	^ [ bytes doubleAt: 1 ] on: DomainError do: [: err | bytes changeClassTo: Double ]</body></methods><methods><class-id>Core.Double</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	self class marshallDouble: self binaryTo: aStream marshaller: aCatRMMarshall</body></methods><methods><class-id>Core.LargeNegativeInteger class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 17</body></methods><methods><class-id>Core.LargeNegativeInteger</class-id> <category>private</category><body package="COMarshalling">checkUnsigned64Bit	self raiseNotAnUnsigned64BitNumber</body></methods><methods><class-id>Core.False class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 4</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	^ false</body></methods><methods><class-id>Core.False</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextPut: self class marshallID.</body></methods><methods><class-id>Core.SmallInteger class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 6</body><body package="COMarshalling">oneByteMarshallID	" answer the ID for this class used for (un)marshalling "	^ 20</body><body package="COMarshalling">threeByteMarshallID	" answer the ID for this class used for (un)marshalling "	^ 22</body><body package="COMarshalling">twoByteMarshallID	" answer the ID for this class used for (un)marshalling "	^ 21</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	^ aStream nextOptimized32</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>private</category><body package="COMarshalling">checkUnsigned64Bit	" slightly optimized "	self &gt;= 0 		ifFalse: [ self raiseNotAnUnsigned64BitNumber ].</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>testing</category><body package="COMarshalling">coastIsSmallInteger	" 32 bit SmallInteger "	^  self &gt;= -536870912 and: [ self &lt;= 536870911 ]</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	( self bitAnd: 16rFF ) == self ifTrue: 		[	aStream nextPut: self class oneByteMarshallID.			^ aStream nextPut: self		].	( self bitAnd: 16rFFFF ) == self ifTrue: 		[	aStream nextPut: self class twoByteMarshallID.			^ aStream next16Put: self		].	( self bitAnd: 16rFFFFFF ) == self ifTrue: 		[	aStream nextPut: self class threeByteMarshallID.			^ aStream next24Put: self		].	self coastIsSmallInteger		ifFalse: [ ^ self marshallBinaryAsLargeIntegerTo: aStream marshaller: aCatRMMarshall ].	aStream nextPut: self class marshallID.	^ aStream nextOptimized32Put: self</body><body package="COMarshalling">nextOptimizedUnsignedOn: stream 	"Write out an unsigned 64-bit integer "	self &lt; 0 		ifTrue: [ self raiseNotAnUnsigned64BitNumber ].	self coastIsSmallInteger 		ifTrue: 		[	self &lt;= 16rFF 				ifTrue: 				[	stream nextPut: stream class coast1Byte64ID.					stream nextPut: self				]				ifFalse: 				[	self &lt;= 16rFFFF 						ifTrue: 						[	stream nextPut: stream class coast2Byte64ID.							stream nextUnsigned16Put: self						]						ifFalse: 						[	stream nextPut: stream class coast4Byte64ID.							stream nextUnsigned32Put: self						]				]		]		ifFalse: [ super nextOptimizedUnsignedOn: stream ].</body></methods><methods><class-id>Core.String</class-id> <category>marshalling</category><body package="COMarshalling">defaultMarshallBinaryTo: stream marshaller: aCatRMMarshall 	stream nextPut: self class marshallID.	stream nextCoastStringPut: self.</body><body package="COMarshalling">huffmanClass	self error: 'Only for ByteString and ISO8859L1String'.</body><body package="COMarshalling">isCoastPrimitiveValue	| cms |	cms := self asCoastString.	^ cms ~~ self and: [ cms class ~~ self class and: [ cms isCoastPrimitiveValue ]]</body><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	"self subclassResponsibility - but some classes (GapString, MSCP1252, ...) can be used when converted into Bytestrings"	| string |	string := self asCoastString.	(self == string or: [ self class = string class ])		ifTrue: [ super marshallBinaryTo: aStream marshaller: aCatRMMarshall ]		ifFalse: [ string marshallBinaryTo: aStream marshaller: aCatRMMarshall ].</body><body package="COMarshalling">marshallHuffmanBinaryTo: stream marshaller: aCatRMMarshall 	stream nextPut: self huffmanClass marshallID.	stream nextOptimized32Put: self size.	COAST.HuffmanStringCodec encode: self on: stream.</body></methods><methods><class-id>Core.Point class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 11</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	^ self x: aStream nextOptimized32 y: aStream nextOptimized32</body></methods><methods><class-id>Core.Point</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self class marshallID.	aStream nextOptimized32Put: x asInteger asSmallInteger.	aStream nextOptimized32Put: y asInteger asSmallInteger.</body></methods><methods><class-id>Core.ByteString class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 14</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	| length new |	length := aCatRMMarshall stringLengthFrom: aStream.	new := self new: length.	1 to: length do:		[:i |		new byteAt: i put: aStream next].	^new</body></methods><methods><class-id>Core.ByteString</class-id> <category>marshalling</category><body package="COMarshalling">huffmanClass	^ COAST.HuffmanByteString</body><body package="COMarshalling">marshallBinaryTo: stream marshaller: aCatRMMarshall 	aCatRMMarshall nextOptimizedCoastString: self to: stream.</body></methods><methods><class-id>Core.WriteStream</class-id> <category>marshalling optimized write</category><body package="COMarshalling">next14Of32Put: aSmall32BitW 	"Write out a 32-bit integer (64..16383) as 16 bits.( 2 Bits coding length, 14 bits coding value)"	"Bits: 01 + valueBits"	self prepareDirectWriteOfSize: 2.	position := collection next14Of32Put: aSmall32BitW after: position.	^ aSmall32BitW</body><body package="COMarshalling">next21Of32NegatedPut: aMediumSized32BitW 	"Write out a 32-bit integer (-2097150..0) as 24 bits.( 3 Bits coding length and sign, 21 bits coding value)"	"Bits: 001 + valueBits "	self prepareDirectWriteOfSize: 3.	position := collection next21Of32NegatedPut: aMediumSized32BitW after: position.	^ aMediumSized32BitW</body><body package="COMarshalling">next21Of32Put: aMediumSized32BitW 	"Write out a 32-bit integer (16384..2097151) as 24 bits.( 3 Bits coding length and sign, 21 bits coding value)"	"Bits: 110 + valueBits "	self prepareDirectWriteOfSize: 3.	position := collection next21Of32Put: aMediumSized32BitW after: position.	^ aMediumSized32BitW</body></methods><methods><class-id>Core.WriteStream</class-id> <category>marshalling</category><body package="COMarshalling">next64PutInteger: a64BitNumber	"Write an unsigned 64-bit integer "	self prepareDirectWriteOfSize: 8.	collection next64PutInteger: a64BitNumber after: position.	position := position + 8.</body><body package="COMarshalling">next64PutLargeInteger: a64BitW 	"Write an unsigned 64-bit large integer "	self prepareDirectWriteOfSize: 8.	collection next64PutLargeInteger: a64BitW after: position.	position := position + 8.</body></methods><methods><class-id>Core.WriteStream</class-id> <category>marshalling optimized write</category><body package="COMarshalling">next6Of32Put: aVerySmall32BitW 	"Write out a 32-bit integer (0..63) as 8 bits.( 2 Bits coding length, 6 bits coding value)"	"Bits: 10 + valueBits"	self prepareDirectWriteOfSize: 1.	position := collection next6Of32Put: aVerySmall32BitW after: position.	^ aVerySmall32BitW</body></methods><methods><class-id>Core.WriteStream</class-id> <category>accessing</category><body package="COMarshalling">nextCoastByteStringPut: aByteString	"Append the length of 'aString' and the string 'aString' itself to	the receiver. (for details of storing length see method nextString)"	" modified: fixed the &gt; 32k String length bug "	|  size newPosition |	size := aByteString size.	newPosition := position + size + 1.	size &lt; 255 ifFalse: [ newPosition := newPosition + ( COAST.SizeCalculatingStream nextOptimized32SizeOf: size )].	newPosition &lt; writeLimit ifFalse: 		[	collection growToAtLeast: newPosition.			writeLimit := collection size		].	size &lt; 255 		ifTrue: [ collection at: ( position := position + 1 ) put: size ]		ifFalse: 		[	collection at: ( position := position + 1 ) put: 255.			self nextOptimized32Put: size		].	1 to: size do: [: i | collection at: position + i put: ( aByteString basicAt: i )].	position := newPosition.</body></methods><methods><class-id>Core.WriteStream</class-id> <category>marshalling</category><body package="COMarshalling">nextFull32Put: a32BitW 	"Write out a 32-bit integer as 32 bits."	a32BitW coastIsSmallInteger ifFalse: [ self next32MustBeSmallInteger: a32BitW ].	self prepareDirectWriteOfSize: 4.	position := collection nextFull32Put: a32BitW after: position.	^ a32BitW</body></methods><methods><class-id>Core.WriteStream</class-id> <category>marshalling optimized write</category><body package="COMarshalling">nextOptimized32SizeBefore: block 	| oldPos delta moveBy |	oldPos := self position.	"most common: 2 bytes length"	self nextPut: 0.	self nextPut: 0.	block value: self.	delta := self position - oldPos - 2.	moveBy := ( COAST.SizeCalculatingStream nextOptimized32SizeOf: delta ) - 2.	moveBy &gt; 0 ifTrue: 		[	1 to: moveBy do: [: i | self nextPut: 0 ].			collection replaceFrom: oldPos + 1 + moveBy to: position with: collection startingAt: oldPos + 1		].	self position: oldPos.	moveBy &lt; 0 		ifTrue: [ self next14Of32Put: delta	"sorry, lost a byte, saved a move ;)" ]		ifFalse: [ self nextOptimized32Put: delta ].	position := position + delta.</body></methods><methods><class-id>Core.WriteStream</class-id> <category>private</category><body package="COMarshalling">prepareDirectWriteOfSize: numBytes 	"about to write numBytes bytes directly into collection"	position + numBytes &lt; writeLimit ifFalse: 		[	collection growToAtLeast: position + numBytes.			writeLimit := collection size		].</body></methods><methods><class-id>Core.TwoByteSymbol class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 19</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	^(TwoByteString unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall) asSymbol</body></methods><methods><class-id>Core.TwoByteSymbol</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextPut: self class marshallID.	aStream nextCoastTwoByteStringPut: self.</body></methods><methods><class-id>Core.SmallDouble class</class-id> <category>instance creation</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ Double marshallID</body></methods><methods><class-id>Core.SmallDouble class</class-id> <category>marshalling</category><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	^ Double unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	Double marshallDouble: self binaryTo: aStream marshaller: aCatRMMarshall</body></methods><methods><class-id>Core.UndefinedObject class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 0</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	^ nil</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextPut: self class marshallID.</body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>marshalling</category><body package="COMarshalling">huffmanClass	^ COAST.HuffmanSymbol</body><body package="COMarshalling">marshallBinaryTo: stream marshaller: aCatRMMarshall 	aCatRMMarshall nextOptimizedCoastString: self to: stream.</body></methods><methods><class-id>Core.True class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 5</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	^ true</body></methods><methods><class-id>Core.True</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextPut: self class marshallID.</body></methods><methods><class-id>Core.LargeInteger class</class-id> <category>marshalling</category><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	| size int |	size := aStream next.	int := self basicNew: size.	1 to: size do: [: i | int digitAt: i put: aStream next ].	" class comment says that integers MUST be represented as SmallInteger if possible "	^ int compressed</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>private</category><body package="COMarshalling">checkUnsigned64Bit	" slightly optimized "	( self &gt;= 0 and: [ self basicSize &lt;= 8 ]) 		ifFalse: [ self raiseNotAnUnsigned64BitNumber ].</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	self marshallBinaryAsLargeIntegerTo: aStream marshaller: aCatRMMarshall .</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 12</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	^ self fromDate: ( Date fromDays: aStream nextOptimized32 ) andTime: ( Time fromSeconds: aStream nextOptimized32 // 1000 )</body></methods><methods><class-id>Core.Timestamp</class-id> <category>private</category><body package="COMarshalling">coastCanBeMarshalled	" true wenn marshalbar "	^ self coastMarshaledDateValue coastIsSmallInteger		and: [ self coastMarshaledTimeValue coastIsSmallInteger ]</body><body package="COMarshalling">coastMarshaledDateValue	^ self asDate asDays</body><body package="COMarshalling">coastMarshaledTimeValue	^ self asTime asSeconds * 1000</body></methods><methods><class-id>Core.Timestamp</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self class marshallID.	aStream nextOptimized32Put: self coastMarshaledDateValue.	aStream nextOptimized32Put: self coastMarshaledTimeValue.</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 8</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall 	| baSize ba |	baSize := aStream nextOptimized32.	ba := self new: baSize.	aStream next: baSize into: ba startingAt: 1.	^ ba</body></methods><methods><class-id>Core.ByteArray</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: self class marshallID.	aStream nextOptimized32Put: self size.	aStream nextPutAll: self.</body><body package="COMarshalling">next14Of32Put: aSmall32BitW after: position 	"Write out a 32-bit integer (64..16383) as 16 bits.( 2 Bits coding length, 14 bits coding value)"	"Bits: 01 + valueBits"	| newPos |	newPos := position + 2.	self at: position + 1 put: (( aSmall32BitW bitShift: -8 ) bitOr: 2r01000000 ).	self at: newPos put: ( aSmall32BitW bitAnd: 16rFF ).	^ newPos</body><body package="COMarshalling">next21Of32NegatedPut: aMediumSized32BitW after: position 	"Write out a 32-bit integer (-2097150..0) as 24 bits.( 3 Bits coding length and sign, 21 bits coding value)"	"Bits: 001 + valueBits "	| newPos |	newPos := position + 3.	self at: position + 1 put: ((( aMediumSized32BitW bitAnd: 16rFF0000 ) bitShift: -16 ) bitAnd: 2r00111111 ).	self at: position + 2 put: (( aMediumSized32BitW bitAnd: 16rFF00 ) bitShift: -8 ).	self at: newPos put: ( aMediumSized32BitW bitAnd: 16rFF ).	^ newPos</body><body package="COMarshalling">next21Of32Put: aMediumSized32BitW  after: position 	"Write out a 32-bit integer (16384..2097151) as 24 bits.( 3 Bits coding length and sign, 21 bits coding value)"	"Bits: 110 + valueBits "	| newPosition |	newPosition := position + 3.	self at: position + 1 put: ((( aMediumSized32BitW bitAnd: 16rFF0000 ) bitShift: -16 ) bitXor: 2r11000000 ).	self at: position + 2 put: (( aMediumSized32BitW bitAnd: 16rFF00 ) bitShift: -8 ).	self at: newPosition put: ( aMediumSized32BitW bitAnd: 16rFF ).	^newPosition.</body><body package="COMarshalling">next64PutInteger: a64BitW after: position 	"Write out an unsigned 64-bit integer "	a64BitW checkUnsigned64Bit.	self at: position + 1 put: (( a64BitW bitShift: -56 ) bitAnd: 16rFF ).	self at: position + 2 put: (( a64BitW bitShift: -48 ) bitAnd: 16rFF ).	self at: position + 3 put: (( a64BitW bitShift: -40 ) bitAnd: 16rFF ).	self at: position + 4 put: (( a64BitW bitShift: -32 ) bitAnd: 16rFF ).	self at: position + 5 put: (( a64BitW bitShift: -24 ) bitAnd: 16rFF ).	self at: position + 6 put: (( a64BitW bitShift: -16 ) bitAnd: 16rFF ).	self at: position + 7 put: (( a64BitW bitShift: -8 ) bitAnd: 16rFF ).	self at: position + 8 put: (( a64BitW ) bitAnd: 16rFF ).</body><body package="COMarshalling">next64PutLargeInteger: a64BitW after: position 	"Write out an unsigned 64-bit integer "	| basicSize bytePos |	basicSize := a64BitW basicSize.	( basicSize &gt; 8 or: [ a64BitW &lt; 0 ]) 		ifTrue: [ a64BitW raiseNotAnUnsigned64BitNumber ].	position + 1 to: position + 8 - basicSize do: [: pos | self at: pos put: 0 ].	bytePos := basicSize.	position + 9 - basicSize to: position + 8		do: 		[: pos |			self at: pos put: ( a64BitW basicAt: bytePos ).			bytePos := bytePos - 1		].</body><body package="COMarshalling">next6Of32Put: aVerySmall32BitW after: position 	"Write out a 32-bit integer (0..63) as 8 bits.( 2 Bits coding length, 6 bits coding value)"	"Bits: 10 + valueBits"	| newPos |	newPos := position + 1.	self at: newPos put: ( aVerySmall32BitW bitOr: 2r10000000 ).	^ newPos</body><body package="COMarshalling">nextFull32Put: a32BitW after: position 	"Write out a 32-bit integer as 32 bits."	| newPos |	newPos := position + 4.	self at: position + 1 put: (( a32BitW bitShift: -24 ) bitAnd: 16rFF ).	self at: position + 2 put: (( a32BitW bitAnd: 16rFF0000 ) bitShift: -16 ).	self at: position + 3 put: (( a32BitW bitAnd: 16rFF00 ) bitShift: -8 ).	self at: newPos put: ( a32BitW bitAnd: 16rFF ).	^ newPos</body></methods><methods><class-id>Core.Integer</class-id> <category>private</category><body package="COMarshalling">checkUnsigned64Bit	( self &gt;= 0 and: [ self &lt;= 16rFFFFFFFFFFFFFFFF ]) 		ifFalse: [ self raiseNotAnUnsigned64BitNumber ].</body></methods><methods><class-id>Core.Integer</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryAsLargeIntegerTo: aStream marshaller: aCatRMMarshall 	aStream nextPut: ( self &gt;= 0 				ifTrue: [ LargePositiveInteger marshallID ]				ifFalse: [ LargeNegativeInteger marshallID ]).	aStream nextPut: self digitLength.	1 to: self digitLength do: [: i | aStream nextPut: ( self digitAt: i )].</body><body package="COMarshalling">nextFull32On: byteArray after: position 	byteArray nextFull32Put: self after: position.</body><body package="COMarshalling">nextOptimizedUnsignedOn: stream 	"Write out an unsigned 64-bit integer "	stream nextPut: stream class coast8Byte64ID.	stream nextUnsigned64Put: self.</body><body package="COMarshalling">nextUnsigned64On: stream 	"Write out an unsigned 64-bit integer "	self checkUnsigned64Bit.	stream next64PutInteger: self.</body><body package="COMarshalling">nextUnsigned64On: byteArray after: position 	byteArray next64PutInteger: self after: position</body></methods><methods><class-id>Core.Integer</class-id> <category>private</category><body package="COMarshalling">raiseNotAnUnsigned64BitNumber	COAST.CoastError raiseSignal: 'Number ' , self printString , ' is not a 64-Bit-Number'.</body></methods><methods><class-id>Core.ISO8859L1String class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 7</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	| length new |	length := aCatRMMarshall stringLengthFrom: aStream.	new := self new: length.	1 to: length do:		[:i |		new byteAt: i put: aStream next].	^new</body></methods><methods><class-id>Core.ISO8859L1String</class-id> <category>marshalling</category><body package="COMarshalling">huffmanClass	^ COAST.HuffmanISOString</body><body package="COMarshalling">marshallBinaryTo: stream marshaller: aCatRMMarshall 	aCatRMMarshall nextOptimizedCoastString: self to: stream.</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>marshalling</category><body package="COMarshalling">marshallID	" answer the ID for this class used for (un)marshalling "	^ 13</body><body package="COMarshalling">unmarshallBinaryFrom: aStream marshaller: aCatRMMarshall	^ self		red: aStream next / 255		green: aStream next / 255		blue: aStream next / 255</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>marshalling</category><body package="COMarshalling">marshallBinaryTo: aStream marshaller: aCatRMMarshall	aStream nextPut: self class marshallID.	aStream nextPut: (self red * 255) rounded.	aStream nextPut: (self green * 255) rounded.	aStream nextPut: (self blue * 255) rounded.</body></methods><methods><class-id>Core.Object</class-id> <category>marshalling</category><body package="COMessages">asCoastPrimitive</body></methods><methods><class-id>Core.ByteArray</class-id> <category>marshalling</category><body package="COMessages">asCoastPrimitive</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSOrderedCollection new )		value: self;		yourself</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSDictionary new )		value: self;		yourself</body></methods><methods><class-id>Core.Set</class-id> <category>accessing</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSSet new )		value: self;		yourself</body></methods><methods><class-id>Core.Bag</class-id> <category>accessing</category><body package="COMessages">asCoastPrimitive	^ ( COAST.CatCSBag new )		value: self;		yourself</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="COMessages">asCoastPrimitive</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>accessing</category><body package="COClusterManagement">ensureLastElement: object 	( self includes: object ) 		ifTrue: [ self reSort ]		ifFalse: [ self add: object ]</body></methods><methods><class-id>OS.Filename</class-id> <category>instance creation</category><body package="COClusterManagement">constructForCluster: clusterFileString number: number mod: mod	| subDir |	subDir := mod = 0		ifTrue: [self]		ifFalse: [self fastConstruct: (number // mod) printString].	subDir definitelyExists ifFalse: [ subDir makeDirectory ].	^subDir fastConstruct: clusterFileString</body></methods><methods><class-id>OS.Filename</class-id> <category>utilities</category><body package="COClusterManagement">sizeOfBlobOrCluster: clusterID 	| filename subDir |	filename := self construct: clusterID printString , COAST.CatMAMarshallBinary clusterExtension.	filename definitelyExists ifTrue: [ ^ filename fileSize ].	filename := self construct: clusterID printString , COAST.CatMAMarshallBinary blobExtension.	filename definitelyExists ifTrue: [ ^ filename fileSize ].	subDir := self construct: ( clusterID // 1000 ) printString.	subDir definitelyExists ifFalse: [ ^ 0 ].	subDir isDirectory ifFalse: [ ^ 0 ].	^ subDir sizeOfBlobOrCluster: clusterID</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="COClusterManagement">subDirsAndFilesDo: aBlock	self directoryContents do: 	[: subDirString | | subDir |		subDir := self construct: subDirString.		subDir isDirectory			ifTrue: [ subDir directoryContents do: [: fileString | aBlock value: subDirString value: fileString ]]			ifFalse: [ aBlock value: '' value: subDirString ]	].</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="COClusterManagement">coastBasicValueAt: index 	| probe |	probe := self basicAt: index.	^ probe notNil 		ifTrue: [ probe value ]		ifFalse: [ nil ]</body></methods><methods><class-id>Security.Hash class</class-id> <category>accessing</category><body package="COClusterManagement">coastHashOnFile: filename 	"beware when using encoding this uses a binary stream"	"	( 'c:\test.txt' asFilename withEncoding:  #'iso8859-1' ) appendStream "	| hash readStream bytes |	hash := self new.	filename definitelyExists ifTrue: 		[	readStream := filename readStream binary.			[					[ readStream atEnd ] whileFalse: 					[	bytes := readStream nextAvailable: hash blockSize.						hash updateWith: bytes asByteArray					]			] ensure: [ readStream close ]		].	^ hash</body></methods><methods><class-id>Core.RecursionLock</class-id> <category>debugging</category><body package="COClusterManagement">owner	^ owner</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>accessing</category><body package="COClusterManagement">coastBasicValueAt: index 	| probe |	probe := valueArray at: index.	^ probe notNil 		ifTrue: [ probe value ]		ifFalse: [ nil ]</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>removing</category><body package="COClusterManagement">ensureLastElement: object 	| found |	self isEmpty ifTrue: [ ^ self addLast: object ].	object = self last ifTrue: [ ^ object ].	found := false.	firstIndex to: lastIndex - 1		do: 		[: index | ( found or: [ found := object = ( self basicAt: index )]) 				ifTrue: [ self basicAt: index put: ( self basicAt: index + 1 )]		].	found 		ifTrue: [ self basicAt: lastIndex put: object ]		ifFalse: [ self addLast: object ].	^ object</body></methods><methods><class-id>Core.Error</class-id> <category>accessing</category><body package="COBlockFileSystem">blockFileSystemLogCopyErrorFor: aCatBFBlockfilesystem copyInfo: copyInfo 	COAST.CoastLog logFatalException: self message: 'Error during ', copyInfo description, ' of ' , aCatBFBlockfilesystem coreName printString , '.: ' , self description</body></methods><methods><class-id>Core.Set</class-id> <category>adding</category><body package="COTransactions">addAndReturnOldOrNil: newObject 	"Include newObject as one of the receiver's elements.  Answer nil if newObject was added or old if not added"	| index old |	newObject == nil ifTrue: [^nil].	index := self findElementOrNil: newObject.	^(old :=self basicAt: index) == nil		ifTrue: [self atNewIndex: index put: newObject. nil]		ifFalse: [ old ]</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COTransactions">accessClassForValueRestoring	^COAST.CatCSValueWriteAccess</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="COTransactions">ccPrintStringOn: stream withClusterID: clusterID	self printOn: stream</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="COTransactions">clusterManagerForBlockCache	^ nil</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="COTransactions">isTempSharedFrame	^ false</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="COTransactions">accessClassForValueRestoring	^COAST.CatCSValueWriteAccess</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>printing</category><body package="COTransactions">ccPrintStringOn: aStream withClusterID: clusterID 	| tooMany |	tooMany := aStream position + self maxPrint.	aStream nextPut: $'.	self do: [ : char | | value |			aStream position &gt; tooMany ifTrue: 				[	aStream nextPutAll: '...'''.					^ self				].			"\ als Escape; leider nicht direkt in Smalltalk lesbar, aber sicher fÃ¼r alle Logfiles"			value := char asInteger.			value = 10 				ifTrue: [ aStream nextPutAll: '\n'. ]				ifFalse: [					value = 13 						ifTrue: [ aStream nextPutAll: '\r'. ]						ifFalse: [							((value = 9) or: [ value &gt; 31 and: [ value &lt; 256 ]]) 								ifTrue: [	(#(39 92) includes: value) ifTrue: [ aStream nextPut: $\. ].										 aStream nextPut: char. 										]								ifFalse: [ aStream nextPutAll: '\u'. value printOn: aStream paddedWith: $0 to: 4 base: 16. ].							]					].		].	aStream nextPut: $'.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="COTransactions">clusterManagerForBlockCache	^ nil</body></methods><methods><class-id>Core.Dictionary</class-id> <category>copying</category><body package="COTransactions">copyForRollback	| copy |	copy := Dictionary new: self size.	self keysAndValuesDo: [: k : v | copy at: k put: v ].	^ copy</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="COTransactions">accessClassForValueRestoring	^COAST.CatCSCollectionWriteAccess</body></methods><methods><class-id>Core.Collection</class-id> <category>printing</category><body package="COTransactions">ccPrintStringOn: aStream withClusterID: clusterID 	| tooMany |	tooMany := aStream position + self maxPrint.	aStream nextPutAll: '('.	self 		do: 		[: element |			aStream position &gt; tooMany ifTrue: 				[	aStream nextPutAll: '...)'.					^ self				].			element ccPrintStringOn: aStream withClusterID: clusterID		]		separatedBy: [ aStream space ].	aStream nextPut: $).</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="COTransactions">clusterManagerForBlockCache	^ ( self 		detect: [: e | e clusterManagerForBlockCache notNil ]		ifNone: [ nil ]) clusterManagerForBlockCache</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="COTransactions">copyForRollback	^ self copy</body></methods><methods><class-id>Core.IntegerArray</class-id> <category>accessing</category><body package="COTransactions">accessClassForValueRestoring	^COAST.CatCSValueWriteAccess</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="COTransactions">finalEndBlockValue</body></methods><initialize><class-id>COAST.SmallIntegerArray</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Weakling</name><environment>Weaklings</environment><super>Core.Object</super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Weaklings</category><attributes><package>Weaklings</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>networkFamily </inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>SharedQueue</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents accessProtect readSynch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>IPSocketAddress</name><environment>OS</environment><super>OS.SocketAddress</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ObjectMemory</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytesPerOTE bytesPerOOP bytesPerRTE rtEntries rtUsedEntries edenBytes edenUsedBytes edenUsedBytesScavengeThreshold survBytes survUsedBytes survUsedBytesTenuringThreshold largeBytes largeUsedBytes largeFreeBytesTenuringThreshold largeUsedObjects bytesPerLTE threadedOTEntries threadedDataEntries threadedDataBytes allocFailures allocSplits allocMatches allocProbes incGCState incMarkedObjects incMarkedBytes incMarkedWeakObjects incMarkedWeakBytes incUnmarkedObjects incNilledObjects incNilledBytes incSweepAllocatedObjects incSweepAllocatedBytes incSweptObjects incReclaimedObjects incReclaimedBytes contiguousFreeOldBytes reservedContiguousFreeBytes availableFreeOldSpaceBytes availableFreeOldSpaceBytesLimit oldBytes oldOTEs oldDataBytes oldSegments numScavenges numIncGCs numGCs numDataCompactions stackBytes compCodeCacheBytes permBytes permOTEs permDataBytes oldRtEntries oldRtUsedEntries numGlobalGCs fixedSegments fixedBytes fixedUsedBytes fixedUsedObjects bytesPerFTE enumerationCallsPerMillisecond maximalFreeOldSpaceBytes nativeStackSpills numMarkStackOverflows numWeakObjectListOverflows numCompactNMethods incAbortedCount incMarkStackOverflows </inst-vars><class-inst-vars>dependents </class-inst-vars><imports></imports><category>System-Support</category><attributes><package>System-Support</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteString</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>LargeInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargePositiveInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargeNegativeInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>IntegerArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>TwoByteString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>TwoByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LinuxSocketAccessor</name><environment>OS</environment><super>OS.SocketAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SolarisSocketAccessor</name><environment>OS</environment><super>OS.SocketAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>WeakArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>weak</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>WinService</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceInterface serviceName shutdownActionBlock postStartProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WinService</category><attributes><package>WinService</package></attributes></class><class><name>MediumGrainMemoryPolicy</name><environment>Kernel</environment><super>Kernel.AbstractMemoryPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memoryStatus idleLoopAllocationThreshold incrementalAllocationThreshold maxPercentOfThreadedData maxPercentOfThreadedOTEs maxProbesPerAttempt incMaxPauseMicroseconds incMaxMarkQuota incMaxUnmarkQuota incMaxSweepQuota preferredGrowthIncrement preferredFixedGrowthIncrement growthRetryDecrement availableSpaceSafetyMargin contiguousSpaceSafetyMargin growthRegimeUpperBound threadedDataIncrement memoryUpperBound freeMemoryUpperBound freeFixedMemoryUpperBound idleMaxPercentOfThreadedData idleMaxPercentOfThreadedOTEs numScavengesAsOfLastGC allowIncGC </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Support</category><attributes><package>System-Support</package></attributes></class><class><name>LargeGrainMemoryPolicy</name><environment>Kernel</environment><super>Kernel.MediumGrainMemoryPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Support</category><attributes><package>System-Support</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ControlInterrupt</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isInterrupt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>OsError</name><environment>OS</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>TLSConnection</name><environment>Xtreams</environment><super>Core.Announcer</super><private>true</private><indexed-type>none</indexed-type><inst-vars>context session handshake writeLock output input socket client_random server_random write_mac_key read_mac_key write_key read_key write_iv read_iv </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.OsTransferFaultError			Security.*			</imports><category>Xtreams-TLS</category><attributes><package>TLS</package></attributes></class><class><name>RecursionLock</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner semaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>FourByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>TLSContext</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>random sessions certificates suites compressions extensions maxVersion minVersion dheParameters mayRenegotiate </inst-vars><class-inst-vars>defaultRandom defaultSecureSuites defaultCompressions defaultExtensions defaultDHEParameters defaultMayRenegotiate defaultServerSessionCache defaultCertificateStore </class-inst-vars><imports>			private OS.OSHandle			</imports><category>Xtreams-TLS</category><attributes><package>TLS</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>HeadlessImage</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isTerminating startupFilename transcriptFilename currentlyHeadless shouldSaveHeadless transcriptToStandardOut transcriptToStandardOutHeadless transcriptToFile transcriptToFileHeadless suspendedProcesses stackDumpStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>SortedCollection</name><environment>Core</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>LookupKey</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>TLSInputOutputStream</name><environment>Security</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>in out inBuffered </inst-vars><class-inst-vars></class-inst-vars><imports>			private Xtreams.*			</imports><category>Net-SSL</category><attributes><package>TLS-Classic</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>OSSystemSupport</name><environment>OS</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.OSSystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-Support</package></attributes></class><class><name>Win32SystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win32SystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>gdi32.dll</item> <item>advapi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-PC</package></attributes></class><class><name>TextCollector</name><environment>UI</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entryStream characterLimit writeSequencer nextEntry autoFlush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>EncodedStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binary stream encoder policy lineEndConvention lineEndCharacter skipSize </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>RSA</name><environment>Security</environment><super>Security.AsymmetricCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>privateKey publicKey hash </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><class><name>ISO8859L1String</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ByteStreamEncoder</name><environment>Core</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>RSAPublicKey</name><environment>Security</environment><super>Security.RSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>e </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>False</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>True</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>FileTranscript</name><environment>OS</environment><super>OS.AbstractStreamTranscript</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><class><name>ExternalStream</name><environment>OS</environment><super>Core.PositionableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>BufferedExternalStream</name><environment>OS</environment><super>OS.ExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lineEndCharacter binary lineEndConvention bufferType ioBuffer ioConnection </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>ExternalReadAppendStream</name><environment>OS</environment><super>OS.ExternalReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>writeStream </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>ProcessorScheduler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>quiescentProcessLists activeProcess pausedProcesses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>ProcessEnvironment</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentDictionary accessLock parentEnvironment bindingHandler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>ExternalConnection</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputDescriptor outputDescriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>IOBuffer</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>input output buffer bufferAmount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Duration</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>period scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Core</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>IdentitySet</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Bag</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>ThreadSafeWeakSet</name><environment>Core</environment><super>Core.WeakSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>accessLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WeakCollections</category><attributes><package>WeakCollections</package></attributes></class><class><name>UnixSystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.UnixSystemSupportDictionary.*			</imports><category>OS-Unix</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item type="sym">linkedIn</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-Unix</package></attributes></class><class><name>MacOSXSystemSupport</name><environment>OS</environment><super>OS.UnixSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.MacOSXSystemSupportDictionary.*			</imports><category>OS-Unix</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libc.dylib</item></libraryFiles><libraryDirectories><item>/usr/lib</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-MacOSX</package></attributes></class></st-source>