<?xml version="1.0"?><st-source><!-- Name: SudokuViewsDevelopmentPrerequisites: #(#(#any 'SudokuSolving' '') #(#any 'SudokuCoastModel' '') #(#any 'SudokuInternational' '') #(#any 'COASTViews' '') #(#any 'COASTClient' '') #(#any 'COASTCore' '') #(#any 'SudokuModels' ''))KSignature: #('definedClasses' 17 'definedClassesHash' 39147816685 'extendedClasses' 7 'extendedClassesHash' 963133677)KSignatureV2: #('definedClasses' 17 'definedClassesHash' 1129719281158400141515287432147784493870615837866 'extendedClasses' 7 'extendedClassesHash' 1172303872262688560726075045578522072584363693953)PackageName: SudokuViewsParcel: #('SudokuViews')ParcelDirectory: SudokuViewsPrerequisiteDescriptions: #(#(#name 'SudokuSolving' #componentType #package) #(#name 'SudokuCoastModel' #componentType #package) #(#name 'SudokuInternational' #componentType #package) #(#name 'COASTViews' #componentType #package) #(#name 'COASTClient' #componentType #package) #(#name 'COASTCore' #componentType #bundle) #(#name 'SudokuModels' #componentType #package))PrerequisiteParcels: #(#('SudokuSolving' '') #('SudokuCoastModel' '') #('SudokuInternational' '') #('COASTViews' '') #('COASTClient' '') #('COASTCore' '') #('SudokuModels' ''))Version: 2.2Date: 1:48:32 PM July 26, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jul14.3) of 25. Juli 2014 on 26. Juli 2014 at 13:48:32</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AutoscaledView</name><environment>Sudoku</environment><super>COAST.CoastCompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SudokuViews</package></attributes></class><class><name>GridController</name><environment>Sudoku</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastHighlightedValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AragonApp</category><attributes><package>SudokuViews</package></attributes></class><class><name>CellController</name><environment>Sudoku</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyBuffer startPoint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AragonApp</category><attributes><package>SudokuViews</package></attributes></class><class><name>GameApp</name><environment>Sudoku</environment><super>COAST.CoastApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SudokuViews</package></attributes></class><class><name>AbstractCellView</name><environment>Sudoku</environment><super>COAST.CoastView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SudokuViews</package></attributes></class><class><name>KeyBuffer</name><environment>Sudoku</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>time number modifier undo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Suzdoku</category><attributes><package>SudokuViews</package></attributes></class><class><name>LocalGameApp</name><environment>Sudoku</environment><super>COAST.CoastLocalApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>gridView radarView hintAspect gridFactory toolBarAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SudokuViews</package></attributes></class><class><name>SudokuIconLibrary</name><environment>Sudoku</environment><super>Tools.ToolbarIconLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>SudokuViews</package></attributes></class><class><name>SudokuServerDialog</name><environment>Sudoku</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumeAspect serverAspect teamAspect statusAspect client iniAccess userNameAspect passwordAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sudoku</category><attributes><package>SudokuViews</package></attributes></class><class><name>SudokuLoginApp</name><environment>Sudoku</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>volumeAspect serverAspect teamAspect statusAspect client appsToClose iniAccess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sudoku</category><attributes><package>SudokuViews</package></attributes></class><class><name>FactoryDialog</name><environment>Sudoku</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aspects gridFactory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuViews</category><attributes><package>SudokuViews</package></attributes></class><class><name>AbstractGridView</name><environment>Sudoku</environment><super>Sudoku.AutoscaledView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fontDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SudokuViews</package></attributes></class><class><name>CellView</name><environment>Sudoku</environment><super>Sudoku.AbstractCellView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuViews</category><attributes><package>SudokuViews</package></attributes></class><class><name>RadarCellView</name><environment>Sudoku</environment><super>Sudoku.AbstractCellView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SudokuViews</category><attributes><package>SudokuViews</package></attributes></class><class><name>RadarView</name><environment>Sudoku</environment><super>Sudoku.AutoscaledView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SudokuViews</package></attributes></class><class><name>GridView</name><environment>Sudoku</environment><super>Sudoku.AbstractGridView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SudokuViews</package></attributes></class><class><name>RadarGridView</name><environment>Sudoku</environment><super>Sudoku.AbstractGridView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SudokuViews</package></attributes></class><shared-variable><name>DefaultColors</name><environment>COAST.CoastUser</environment><private>false</private><constant>false</constant><category>resources</category><initializer>nil</initializer><attributes><package>SudokuViews</package></attributes></shared-variable><methods><class-id>Sudoku.LocalGameApp class</class-id> <category>resources</category><body package="SudokuViews">menu	"Tools.MenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #sudokuGame 					#defaultString: 'Game' ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuNew 								#defaultString: 'New' ) 							#nameKey: #voteNewGame 							#value: #voteNewGame 							#indication: true 							#indicationSelector: #isNewGameVoter 							#shortcutKeyCharacter: $n 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #newGrid ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuNewEmpty 								#defaultString: 'New (empty)' ) 							#nameKey: #newEmpty 							#value: #newEmpty 							#enablementSelector: #isSinglePlayerGame 							#shortcutKeyCharacter: $b 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #emptyGrid ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuFix 								#defaultString: 'Fix' ) 							#nameKey: #fixGrid 							#value: #fixGrid 							#enablementSelector: #isSinglePlayerGame 							#hidden: true 							#shortcutKeyCharacter: $f 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #filledGrid ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuPasteString 								#defaultString: 'paste' ) 							#nameKey: #pasteFromClipboard 							#value: #pasteFromClipboard 							#shortcutKeyCharacter: $v 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #paste ) 							#helpText: 							#(#{Kernel.UserMessage} 								#key: #sudokuPasteString 								#defaultString: '' ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuCopyString 								#defaultString: 'copy' ) 							#nameKey: #copyToClipboard 							#value: #copyToClipboard 							#shortcutKeyCharacter: $c 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #copy ) 							#helpText: 							#(#{Kernel.UserMessage} 								#key: #sudokuCopyString 								#defaultString: '' ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuReset 								#defaultString: 'Restart' ) 							#value: #restart 							#shortcutKeyCharacter: $r 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #resetGrid ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuVerify 								#defaultString: 'Verify' ) 							#nameKey: #verify 							#value: #verify 							#enablementSelector: #isSinglePlayerGame 							#shortcutKeyCharacter: $p 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #check ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuSolve 								#defaultString: 'Solve' ) 							#nameKey: #solve 							#value: #solve 							#enablementSelector: #isSinglePlayerGame 							#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #filledGrid ) ) ) #(6 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #sudokuView 					#defaultString: 'Settings' ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuSettings 								#defaultString: '&lt;new item&gt;' ) 							#nameKey: #openGridOptions 							#value: #openGridOptions 							#shortcutKeyCharacter: $o 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #settings ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuShowMarks 								#defaultString: '' ) 							#value: #toggleShowMarks 							#indication: true 							#indicationSelector: #showMarks ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuHideSakes 								#defaultString: '' ) 							#value: #toggleHideSakes 							#indication: true 							#indicationSelector: #autoHideSakes ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #sudokuHighlightFreeCells 								#defaultString: '' ) 							#value: #toggleHighlightFreeCells 							#indication: true 							#enablementSelector: #autoHideSakes 							#indicationSelector: #highlightFreeCells 							#hidden: true ) ) #(1 3 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="SudokuViews">sudokuIcon	"UIMaskEditor new openOnClass: self andSelector: #sudokuIcon"	&lt;resource: #image&gt;	^((Image extent: 16@16 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5460 5460)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4111 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[63 207 243 252 234 181 94 171 234 181 94 171 234 181 94 171 234 181 94 171 63 207 243 252 213 122 173 87 213 122 173 87 213 122 173 87 213 122 173 87 63 207 243 252 234 181 94 171 234 181 94 171 234 181 94 171 234 181 94 171 63 207 243 252])) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">sudokuIconMask	"UIMaskEditor new openOnClass: self andSelector: #sudokuIconMask"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0])</body><body package="SudokuViews">toolbar	"Tools.MenuEditor new openOnClass: self andSelector: #toolbar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #sudokuNew 					#defaultString: 'new' ) 				#nameKey: #voteNewGame 				#value: #voteNewGame 				#shortcutKeyCharacter: $n 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #newGrid ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #sudokuNew 					#defaultString: '' ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #sudokuReset 					#defaultString: '&lt;new item&gt;' ) 				#value: #restart 				#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #resetGrid ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #sudokuReset 					#defaultString: '' ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #sudokuSettings 					#defaultString: 'GridOptions' ) 				#nameKey: #openGridOptions 				#value: #openGridOptions 				#shortcutKeyCharacter: $o 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #settings ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #sudokuSettings 					#defaultString: '' ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #sudokuHint 					#defaultString: 'Help' ) 				#nameKey: #nextHint 				#value: #nextHint 				#enablementSelector: #canModifyGame 				#labelImage: #(#{UI.ResourceRetriever} #{SudokuIconLibrary} #lightBlub ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #sudokuHint 					#defaultString: '' ) ) ) #(2 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Sudoku.LocalGameApp class</class-id> <category>interface specs</category><body package="SudokuViews">multiPlayerSpec	"Tools.UIPainter new openOnClass: self andSelector: #multiPlayerSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'SUDOKU' 			#min: #(#{Core.Point} 400 300 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 640 496 1240 946 ) 			#flags: 4 			#menu: #menu 			#toolBar: #toolBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{COAST.CoastArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.75 -25 1 ) 					#name: #gridView 					#flags: 0 					#component: #gridView ) 				#(#{COAST.CoastArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.75 0 0 0 1 -25 1 ) 					#name: #radarView 					#flags: 1 					#component: #radarView ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 -54 1 0 1 ) 					#name: #hintAspect 					#model: #hintAspect 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -53 1 -25 1 -28 1 0 1 ) 					#name: #prevHint 					#flags: 0 					#model: #prevHint 					#label: '&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -27 1 -25 1 -2 1 0 1 ) 					#name: #nextHint 					#flags: 0 					#model: #nextHint 					#label: '&gt;' 					#defaultable: true ) ) ) )</body><body package="SudokuViews">originalSpec	"Tools.UIPainter new openOnClass: self andSelector: #originalSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'SUDOKU' 			#min: #(#{Core.Point} 400 300 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 640 496 1240 946 ) 			#flags: 4 			#menu: #menu 			#toolBar: #toolBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{COAST.CoastArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.75 -25 1 ) 					#name: #gridView 					#flags: 0 					#component: #gridView ) 				#(#{COAST.CoastArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.75 0 0 0 1 -25 1 ) 					#name: #radarView 					#flags: 1 					#component: #radarView ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 -54 1 0 1 ) 					#name: #hintAspect 					#model: #hintAspect 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -53 1 -25 1 -28 1 0 1 ) 					#name: #prevHint 					#flags: 0 					#model: #prevHint 					#label: '&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -27 1 -25 1 -2 1 0 1 ) 					#name: #nextHint 					#flags: 0 					#model: #nextHint 					#label: '&gt;' 					#defaultable: true ) ) ) )</body><body package="SudokuViews">singlePlayerSpec	"Tools.UIPainter new openOnClass: self andSelector: #singlePlayerSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'SUDOKU' 			#min: #(#{Core.Point} 400 300 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 640 496 1240 946 ) 			#flags: 4 			#menu: #menu 			#toolBar: #toolBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{COAST.CoastArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -25 1 ) 					#name: #gridView 					#flags: 0 					#component: #gridView ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 -54 1 0 1 ) 					#name: #hintAspect 					#model: #hintAspect 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -53 1 -25 1 -28 1 0 1 ) 					#name: #prevHint 					#flags: 0 					#model: #prevHint 					#label: '&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -27 1 -25 1 -2 1 0 1 ) 					#name: #nextHint 					#flags: 0 					#model: #nextHint 					#label: '&gt;' 					#defaultable: true ) ) ) )</body><body package="SudokuViews">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'SUDOKU' 			#min: #(#{Core.Point} 400 300 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 640 496 1240 946 ) 			#flags: 4 			#menu: #menu 			#toolBar: #toolBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #changeableSpec 					#flags: 0 					#minorKey: #changeableSpec ) ) ) )</body></methods><methods><class-id>Sudoku.SudokuIconLibrary class</class-id> <category>resources grid</category><body package="SudokuViews">check20x20	"UIMaskEditor new openOnClass: self andSelector: #check20x20"	&lt;resource: #image&gt;	^((Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3404 6424 3212)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6681 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 6167 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3918 7002 3918)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 7195 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H0@@H3L3HQDQH3L3H0@@H3L3HQDQH3L3H0@@H3L3HQDQH3L3H0@@H3L3HQDQH3L3H0@@H3L3HQDQH3L3H0@@H"H"H"H"H"H"H0@@HQDQH3L3HQDQH0@@HQDQH3L3HQDQH0@@HQDQH3L3HQDQH0@@HQDQH3L3HQDQH0@@HQDQH3L3HQET@0@@H"H"H"H"H"ADP0@@H3L3HQET@6QD@0@@H3L3HQEDQ$QFH0@@H3L3HQETQDQ#H0@@H3L3HQDUQDX3H0@@H3L3HQDQAFL3H0@@H"H"H"H"H"H"H0@@L3L3L3L3L3L3L0@@'))) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">check20x20bw	"UIMaskEditor new openOnClass: self andSelector: #check20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 224 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 255 255 224 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 224 0 255 255 224 0 130 59 224 0 130 63 224 0 130 63 160 0 130 31 32 0 130 14 32 0 255 255 224 0 0 0 0 0])</body><body package="SudokuViews">emptyGrid20x20	"UIMaskEditor new openOnClass: self andSelector: #emptyGrid20x20"	&lt;resource: #image&gt;	^((Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6681 6424)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[170 170 170 170 169 0 0 0 149 88 0 149 89 0 0 0 149 88 0 149 89 0 0 0 149 88 0 149 89 0 0 0 149 88 0 149 89 0 0 0 149 88 0 149 89 0 0 0 170 170 170 170 169 0 0 0 128 9 85 128 9 0 0 0 128 9 85 128 9 0 0 0 128 9 85 128 9 0 0 0 128 9 85 128 9 0 0 0 128 9 85 128 9 0 0 0 170 170 170 170 169 0 0 0 149 88 0 149 89 0 0 0 149 88 0 149 89 0 0 0 149 88 0 149 89 0 0 0 149 88 0 149 89 0 0 0 149 88 0 149 89 0 0 0 170 170 170 170 169 0 0 0 85 85 85 85 85 0 0 0])) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">emptyGrid20x20bw	"UIMaskEditor new openOnClass: self andSelector: #emptyGrid20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 224 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 255 255 224 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 255 255 224 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 255 255 224 0 0 0 0 0])</body><body package="SudokuViews">emptyGrid20x20mask	"UIMaskEditor new openOnClass: self andSelector: #emptyGrid20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 0 0 0 0])</body><body package="SudokuViews">filledGrid20x20	"UIMaskEditor new openOnClass: self andSelector: #filledGrid20x20"	&lt;resource: #image&gt;	^((Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4111 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6681 6424)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDP @@P"H"P@@@P"H"P @@P!DRPCL0P"L"P @@P"D"P@@0P"L"P @@P!DRPCL0P"L"P @@P"H"P@@@P"H"P @@QDQDQDQDQDQDP @@P@@@P"H"P@@@P @@P@L@P#L2PADPP @@P@L@P"L"P@@PP @@P@L@P#L2PADPP @@P@@@P"H"P@@@P @@QDQDQDQDQDQDP @@P"H"P@@@P"H"P @@P#L2P@D@P#L2P @@P"H2P@D@P"L"P @@P#L2P@D@P#L2P @@P"H"P@@@P"H"P @@QDQDQDQDQDQDP @@H"H"H"H"H"H"H @@'))) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">filledGrid20x20bw	"UIMaskEditor new openOnClass: self andSelector: #filledGrid20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 224 0 130 8 32 0 186 233 32 0 146 41 32 0 186 233 32 0 130 8 32 0 255 255 224 0 130 8 32 0 146 235 160 0 146 72 160 0 146 235 160 0 130 8 32 0 255 255 224 0 130 8 32 0 186 75 160 0 138 73 32 0 186 75 160 0 130 8 32 0 255 255 224 0 0 0 0 0])</body><body package="SudokuViews">newGrid20x20	"UIMaskEditor new openOnClass: self andSelector: #newGrid20x20"	&lt;resource: #image&gt;	^((Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6681 6424)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[255 255 255 255 254 0 0 0 234 172 0 234 174 0 0 0 229 108 0 234 174 0 0 0 233 172 0 234 174 0 0 0 229 108 0 234 174 0 0 0 234 172 0 234 174 0 0 0 255 255 255 255 254 0 0 0 192 14 170 192 14 0 0 0 192 14 170 197 78 0 0 0 192 14 170 192 78 0 0 0 192 14 170 197 78 0 0 0 192 14 170 192 14 0 0 0 255 255 255 255 254 0 0 0 234 172 0 234 174 0 0 0 234 172 16 234 174 0 0 0 234 172 16 234 174 0 0 0 234 172 16 234 174 0 0 0 234 172 0 234 174 0 0 0 255 255 255 255 254 0 0 0 170 170 170 170 170 0 0 0])) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">newGrid20x20bw	"UIMaskEditor new openOnClass: self andSelector: #newGrid20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 224 0 130 8 32 0 186 8 32 0 146 8 32 0 186 8 32 0 130 8 32 0 255 255 224 0 130 8 32 0 130 11 160 0 130 8 160 0 130 11 160 0 130 8 32 0 255 255 224 0 130 8 32 0 130 72 32 0 130 72 32 0 130 72 32 0 130 8 32 0 255 255 224 0 0 0 0 0])</body><body package="SudokuViews">resetGrid20x20	"UIMaskEditor new openOnClass: self andSelector: #resetGrid20x20"	&lt;resource: #image&gt;	^((Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6681 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 4111 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 3918 3918)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7484 3340 3212)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 0 0)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'DQDQDQDQDQDQD @@D"H"D@@@D"H"D @@D"H"D@@@D"H"D @@D"H"D@@@D"H"D @@D"H"D@@@D"H"D @@D"H"D@@@D"H"D @@DQDQDQDQDQDQD @@D@@@D"H"D@@@D @@D@@@D"H"D@@@D @@D@@@D"H"D@@@D @@D@@@D"H"D@@@D @@D@@@D"H6T@Q$D @@DQDQDQU&amp;XUY&amp;D @@D"H"DDY&amp;T6Y#D @@D"H"DFY$E&amp;X2D @@D"H"DDY&amp;T6Y#D @@D"H"D@Q&amp;X#Y&amp;D @@D"H"D@AFT"M#D @@DQDQDQDQDQDQD @@H"H"H"H"H"H"H @@'))) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">resetGrid20x20bw	"UIMaskEditor new openOnClass: self andSelector: #resetGrid20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 224 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 255 255 224 0 130 8 32 0 130 8 32 0 130 8 32 0 130 8 32 0 130 57 224 0 255 255 224 0 130 255 224 0 130 255 160 0 130 255 224 0 130 123 224 0 130 57 224 0 255 255 224 0 0 0 0 0])</body><body package="SudokuViews">settings20x20	"UIMaskEditor new openOnClass: self andSelector: #settings20x20"	&lt;resource: #image&gt;	^((Image extent: 20@20 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4882 4882 7934)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1959 1959 8094)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6681 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3693 3693 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1316 1316 8126)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6263 6135 6584)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2569 2505 7516)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6841 6841 7837)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3918 3918 7998)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3404 3340 7291)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2409 2409 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1027 1027 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 6520 7869)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5492 5492 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6167 7869)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3083 3083 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2280 2280 8062)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5139 5139 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5878 5878 7901)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7195 7195 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4786 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6841 6841 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1156 1124 7901)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2601 2601 8062)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5139 5043 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7516 7516 8191)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@0LC@0LC@0LC@0LC@0LC@0LC@0DC@PDA@PDCBP$IBP$C@PDA@PDC@PLA@PDPCPLIBP$IBPLMD@DA@PLA@0DAA@4MCP4MCP4MCP4MD@DA@0DC@Q@MA@4CBP$IBP$CCQ@A@PDC@PLACP4M@PLIBP$IBPLA@PDA@PLA@0LCCPLC@0LC@0LC@0LC@0LC@0DCBP$MBP$C@PDXC@4MAQDIBP$C@PLIBP4IBPLA@P8MEA,ECP IBPLA@0$ICP$I@0DVD!\A@1TMB $I@0DCBP$MBP$C@PDA@PDFD04QBP$C@PLIBP4IBPLA@PDAGA$MF $IBPLA@0LCCPLC@0LC@0LGCP,C@0LC@0DC@P4MCPDCBP$IBPHM@PDA@PDC@PLAD@4P@PLIBP$I@@,A@PDA@PLA@0DAD@DA@0$IBP$BCPDA@PDA@0DC@PDA@PDCBP$IBP&lt;[@PDA@PDC@PLA@PDA@PLIBP$IBPLA@PDA@PLA@0LC@0LC@0LC@0LC@0LC@0LC@0DA@PDA@PDA@PDA@PDA@PDA@PDA@P@a'))) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">settings20x20bw	"UIMaskEditor new openOnClass: self andSelector: #settings20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 224 0 130 8 32 0 142 14 32 0 159 255 32 0 190 14 32 0 186 8 32 0 255 255 224 0 146 126 32 0 146 127 32 0 146 239 32 0 146 15 32 0 146 30 32 0 255 255 224 0 186 24 32 0 186 24 32 0 146 24 32 0 130 24 32 0 130 8 32 0 255 255 224 0 0 0 0 0])</body></methods><methods><class-id>Sudoku.SudokuIconLibrary class</class-id> <category>resources</category><body package="SudokuViews">copy20x20	"UIMaskEditor new openOnClass: self andSelector: #copy20x20"	&lt;resource: #image&gt;	^((Image extent: 20@21 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3083 3083 3083)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6681 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 0 0)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@DL"H"MDQDMDQ@@@QDL"H"MDQDMDQ@@@L3L3L3L3L3MDQ@@@H"MDQDL"H"MDQ@@@H"MDQDL @BMDQ@@@H"MDQDL"HBMDQ@@@H"MDQDL @BMDQ@@@H"MDQDL"H"MDQ@@@L3L3L3L3L3MDQ@@@QDL"H"MDQDMDQ@@@QDL"@"MDQDMDQ@@@QDL"@"MDQDMUQ@@@QDL"@"MDQDMEU@@@QDL"H"MDQDMEU@@@L3L3L3L3L3MUUP@@QDQDQDQDQDQEU@@@QDQDQDQDQDQDQ@@@P@ADQDP@ADPDQ@@@Q@QDQDQDADPDQ@@@P@AADQP@A@PDQ@@@QDQDQDQDQDQDQ@@@'))) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">copy20x20bw	"UIMaskEditor new openOnClass: self andSelector: #copy20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@21 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[208 65 0 0 16 65 0 0 255 255 0 0 16 65 0 0 16 93 0 0 16 69 0 0 16 93 0 0 16 65 0 0 255 255 0 0 16 65 0 0 18 65 0 0 18 65 192 0 18 65 96 0 16 65 96 0 255 255 240 0 0 0 96 0 0 0 0 0 112 56 128 0 32 8 128 0 119 186 128 0 0 0 0 0])</body><body package="SudokuViews">copy20x20mask	"UIMaskEditor new openOnClass: self andSelector: #copy20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@21 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 192 0 255 255 96 0 255 255 96 0 255 255 240 0 0 0 96 0 255 255 192 0 255 255 192 0 255 255 192 0 255 255 192 0 255 255 192 0])</body><body package="SudokuViews">emptyButton20x20mask	"UIMaskEditor new openOnClass: self andSelector: #emptyButton20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[127 255 192 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 127 255 192 0 0 0 0 0])</body><body package="SudokuViews">lightBlub20x20	"UIMaskEditor new openOnClass: self andSelector: #lightBlub20x20"	&lt;resource: #image&gt;	^((Image extent: 20@20 depth: 8 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6681 6552 6295)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 6617 1606)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7580 6199 1124)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6745 6520 5942)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 6874 1895)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7195 5717 674)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4529 4529 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 6456 1316)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3758 3758 3758)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6681 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 4432 4368)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7098 2344)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6649 5267 1349)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 4753 4753)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7323 3051)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7484 6231 1541)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6199 6199 6167)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7580 3790)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 6777 1349)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7420 3629)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7869 6584 1477)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 6649 1252)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7741 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 6874 1959)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7869 5171)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7195 2569)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 6938 1798)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7741 6103 770)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7163 5749 706)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7420 3308)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7773 6424 1413)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6681 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7644 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4529 4529 4561)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7773 4946)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7901 4818)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6777 5396 1124)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7355 3083)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 5300 1284)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6841 6617 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 6584 2023)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 5139 1316)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8094 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7291 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6841 6584 5846)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3886 3886 3886)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7580 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7741 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7805 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7998 5075)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 6938 1830)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5203 4047 1092)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 6103 867)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5653 5653 5653)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6681 5749 3212)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7002 5557 770)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7355 3115)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4818 4786 4721)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7002 2184)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7869 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7355 6103 1541)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7066 5878 2055)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7516 3597)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7869 6263 867)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7484 6520 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6938 5557 1188)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 7163 2794)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7163 5717 803)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7709 6424 1541)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7966 6552 1156)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 3726 1830)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7323 5942 1092)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4753 4047 2248)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7548 6263 1541)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7901 6360 1092)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7612 3854)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7452 4015)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 6809 1413)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7805 4657)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 6938 2344)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6327 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6392 6199 5749)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7612 6456 1959)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7452 6520 3051)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 6970 1895)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6841 5460 1413)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7195 2633)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7291 5974 1445)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7452 3404)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6038 6006 5974)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 6552 1220)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 6841 1798)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7066 6135 3501)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 5428 1156)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7130 2376)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7098 2409)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7612 3886)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7066 2152)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7066 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7869 5621)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7130 3083)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7259 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7548 3661)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6938 6649 5781)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7066 6070 2923)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7709 6488 1863)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7484 3693)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7773 4400)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 6874 2152)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7934 5235)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6295 4946)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7227 6617 4207)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7227 2666)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7452 3404)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7644 6424 1670)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 6456 1606)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7741 4432)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 6874 1734)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7837 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7934 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7098 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7580 4272)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7259 5846 963)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7644 6263 1156)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 6424 1188)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7516 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7034 6070 3308)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7612 3918)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7098 5492 513)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7741 4786)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7066 2184)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7837 6906 2666)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 7259 3051)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7291 2923)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6552 6038)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7452 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5364 4240 1188)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7966 6681 1445)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6456 6456 6456)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 6970 1959)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6745 6617 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4593 4593 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2826 2826 2826)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7227 2666)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7002 5814 1959)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7612 4272)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7002 5524 931)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7130 2441)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 6167 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7869 4689)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7195 3083)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5524 4304 995)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7741 6295 1092)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 4304 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6681 5878)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5043 5043 5043)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7612 4625)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4625 4593 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7259 6649 4207)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7227 2698)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7484 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 5267 5235)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7709 4207)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7227 5653 610)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7387 3212)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 6424 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7869 4721)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7709 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7548 3758)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6649 6520 6295)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6488 5107 1252)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7002 1959)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7066 2955)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7227 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7195 2826)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 7066 3019)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 6617 1220)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7709 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7773 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 7130 2633)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7163 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7098 2569)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7966 4978)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6488 5460)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7387 3244)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7066 2601)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6360 5332 2826)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6777 6649 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7323 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6424 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7741 6327 1124)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7580 3726)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6906 5974 3308)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6649 6552 6295)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2858 2858 2858)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7805 5492)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4625 4625 4625)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 3533 3501)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7002 6649 5524)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 6552 1284)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6392 6392 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5364 5300 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6552 6424 6199)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 6874 1991)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7966 5010)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7098 2569)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 7163 2537)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 5557 2280)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 6745 1798)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7548 5910 770)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 7130 3340)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6456 5557 3212)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'G1&lt;_G1&lt;IY5M2JEH&lt;ZK\IG1&lt;_G1&lt;_G1&lt;_BV&gt;C_RJA$V*3C78''G1&lt;_G1&lt;_G0&amp;^P#A#FD8 O*24QL@IG1&lt;_G1&lt;_1,.2N641H1XQ.L:BQ68_G1&lt;_G1=@!&lt;M63B*6Z4,],5=[31&lt;_G1&lt;_G7N\)7RU]:Z1/:SN$;T$G1&lt;_G1&lt;_ZR99_:H/,VB +IOMYDD_G1&lt;_G1=ISAM1Y*!&amp;VBV3XYZ,WQ&lt;_G1&lt;_G5_NP*08+:1B^C)TJ62*G1&lt;_G1&lt;_WAQ"W,9O3 ,W][''R@-L_G1&lt;_G1&gt;ZOX$Z*0FKL,\D+18L!!&lt;_G1&lt;_G1&lt;,$AUM)QHRR-@GI%@_G1&lt;_G1&lt;_G1&gt;=^+@?QU([_IJTG1&lt;_G1&lt;_G1&lt;_G0%U_CRX/-E;JP$_G1&lt;_G1&lt;_G1&lt;_G3YC(0T\ C^:G1&lt;_G1&lt;_G1&lt;_G1&lt;_@4"H%9$3Q%D_G1&lt;_G1&lt;_G1&lt;_G1?AHQAY(Y4-*Q&lt;_G1&lt;_G1&lt;_G1&lt;_G0@F2L 5CR7AG1&lt;_G1&lt;_G1&lt;_G1&lt;_.&lt;&amp;M&amp;84HNX0_G1&lt;_G1&lt;_G1&lt;_G1&lt;_.0*N0,WJG1&lt;_G1&lt;_G0@a'))) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">lightBlub20x20bw	"UIMaskEditor new openOnClass: self andSelector: #lightBlub20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 252 0 0 4 2 0 0 8 1 0 0 16 0 128 0 16 0 128 0 16 0 128 0 16 0 128 0 16 0 128 0 16 0 128 0 17 248 128 0 8 145 0 0 4 146 0 0 2 148 0 0 2 148 0 0 2 148 0 0 1 248 0 0 1 8 0 0 1 8 0 0 1 152 0 0 0 240 0 0])</body><body package="SudokuViews">lightBlub20x20mask	"UIMaskEditor new openOnClass: self andSelector: #lightBlub20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 252 0 0 7 254 0 0 15 255 0 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 15 255 0 0 7 254 0 0 3 252 0 0 3 252 0 0 3 252 0 0 1 248 0 0 1 248 0 0 1 248 0 0 1 248 0 0 0 240 0 0])</body><body package="SudokuViews">paste20x20	"UIMaskEditor new openOnClass: self andSelector: #paste20x20"	&lt;resource: #image&gt;	^((Image extent: 20@21 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3083 3083 3083)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6809 6681 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4111 0)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDQ@@@P@ADQDP@ADPDQ@@@Q@QDQDQDADPDQ@@@P@AADQP@A@PDQ@@@QDQDQDQDQDQDQ@@@QDQDQDQDQDQDUP@@L3L3L3L3L3MDUP@@QDL"H"MDQDMTUP@@@DL"H"MDQDUUUP@@ADL"H"MDQDUUU@@@@DL"H"MDQDMTQ@@@QDL"H"MDQDMDQ@@@L3L3L3L3L3MDQ@@@H"MDQDL"H"MDQ@@@H"MDQDL @BMDQ@@@H"MDQDL"HBMDQ@@@H"MDQDL @BMDQ@@@H"MDQDL"H"MDQ@@@L3L3L3L3L3MDQ@@@QDL"H"MDQDMDQ@@@QDL"@"MDQDMDQ@@@'))) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">paste20x20bw	"UIMaskEditor new openOnClass: self andSelector: #paste20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@21 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 112 56 128 0 32 8 128 0 119 186 128 0 0 0 0 0 0 0 48 0 255 255 48 0 16 65 176 0 208 65 240 0 144 65 224 0 208 65 128 0 16 65 0 0 255 255 0 0 16 65 0 0 16 93 0 0 16 69 0 0 16 93 0 0 16 65 0 0 255 255 0 0 16 65 0 0 18 65 0 0])</body><body package="SudokuViews">paste20x20mask	"UIMaskEditor new openOnClass: self andSelector: #paste20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@21 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 192 0 255 255 192 0 255 255 192 0 255 255 192 0 255 255 192 0 0 0 48 0 255 255 48 0 255 255 176 0 255 255 240 0 255 255 224 0 255 255 128 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0])</body></methods><methods><class-id>Sudoku.SudokuIconLibrary class</class-id> <category>resources button</category><body package="SudokuViews">emptyButton20x20	"UIMaskEditor new openOnClass: self andSelector: #emptyButton20x20"	&lt;resource: #image&gt;	^((Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 1638 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 803 2473)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[0 0 0 0 2 0 0 0 21 85 85 85 82 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 26 170 170 170 146 0 0 0 21 85 85 85 82 0 0 0 0 0 0 0 2 0 0 0 170 170 170 170 170 0 0 0])) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">emptyButton20x20bw	"UIMaskEditor new openOnClass: self andSelector: #emptyButton20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 224 0 255 255 224 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 192 0 96 0 255 255 224 0 255 255 224 0 0 0 0 0])</body><body package="SudokuViews">filledButton20x20	"UIMaskEditor new openOnClass: self andSelector: #filledButton20x20"	&lt;resource: #image&gt;	^((Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 1638 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 803 2473)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 8191 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[0 0 0 0 2 0 0 0 21 85 85 85 82 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 31 255 255 255 210 0 0 0 21 85 85 85 82 0 0 0 0 0 0 0 2 0 0 0 170 170 170 170 170 0 0 0])) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">xyButton20x20	"UIMaskEditor new openOnClass: self andSelector: #xyButton20x20"	&lt;resource: #image&gt;	^((Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 1638 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 8191 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2055 4111 2055)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 803 2473)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'DQDQDQDQDQDQD @@EUUUUUUUUUUUD @@ESL3L3L3L3L5D @@ESL3L3L3L3L5D @@ESLDM@L3L3L5D @@ESM@PDL3L3L5D @@ESL4ACL3L3L5D @@ESM@PDL3L3L5D @@ESLDM@L3L3L5D @@ESL3L3L3L3L5D @@ESL3L3LDM@L5D @@ESL3L3M@PDL5D @@ESL3L3L4ACL5D @@ESL3L3L4ACL5D @@ESL3L3L3@3L5D @@ESL3L3L3L3L5D @@ESL3L3L3L3L5D @@EUUUUUUUUUUUD @@DQDQDQDQDQDQD @@H"H"H"H"H"H"H @@'))) convertForGraphicsDevice: Screen default</body><body package="SudokuViews">xyButton20x20bw	"UIMaskEditor new openOnClass: self andSelector: #xyButton20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 224 0 255 255 224 0 192 0 96 0 192 0 96 0 205 128 96 0 207 128 96 0 199 0 96 0 207 128 96 0 205 128 96 0 192 0 96 0 192 54 96 0 192 62 96 0 192 28 96 0 192 28 96 0 192 8 96 0 192 0 96 0 192 0 96 0 255 255 224 0 255 255 224 0 0 0 0 0])</body></methods><methods><class-id>Sudoku.SudokuServerDialog class</class-id> <category>interface specs</category><body package="SudokuViews">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'SUDOKU' 			#min: #(#{Core.Point} 300 300 ) 			#max: #(#{Core.Point} 300 300 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1100 900 ) 			#menu: #menu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 0 ) 					#name: #server 					#label: 'Server' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 25 0 -21 1 48 0 ) 					#name: #serverAspect 					#model: #serverAspect ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -20 1 25 0 -1 1 48 0 ) 					#name: #browseServers 					#model: #browseServers 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #browseServer 						#defaultString: 'Lookup known Servers' ) 					#label: '...' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 50 ) 					#name: #volume 					#label: 					#(#{Kernel.UserMessage} 						#key: #sudokuVolume 						#defaultString: '' ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 75 0 -21 1 98 0 ) 					#name: #volumeAspect 					#model: #volumeAspect 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -20 1 75 0 -1 1 98 0 ) 					#name: #browseVolumes 					#model: #browseVolumes 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #browseVolumes 						#defaultString: 'Browse Volumes' ) 					#label: '...' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 100 ) 					#name: #team 					#label: 'Team' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 125 0 -21 1 148 0 ) 					#name: #teamAspect 					#model: #teamAspect 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -20 1 125 0 -1 1 148 0 ) 					#name: #browseTeams 					#model: #browseTeams 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #browseTeams 						#defaultString: 'Browse Teams' ) 					#label: '...' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 150 ) 					#name: #sudokuUser 					#label: 					#(#{Kernel.UserMessage} 						#key: #sudokuUser 						#defaultString: nil ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 175 0 -21 0.5 198 0 ) 					#name: #userNameAspect 					#model: #userNameAspect ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 1 0.5 150 0 ) 					#name: #sudokuPassword 					#label: 					#(#{Kernel.UserMessage} 						#key: #sudokuPassword 						#defaultString: 'Label' ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 175 0 -21 1 198 0 ) 					#name: #passwordAspect 					#model: #passwordAspect 					#type: #password ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -83 1 -1 1 -60 1 ) 					#name: #connect 					#model: #connect 					#helpText: '' 					#label: 					#(#{Kernel.UserMessage} 						#key: #connectToServer 						#defaultString: 'Connect to the Server' ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -53 1 299 0 -30 1 ) 					#name: #closeRequest 					#model: #closeRequest 					#label: 					#(#{Kernel.UserMessage} 						#key: #sudokuAbort 						#defaultString: nil ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 0 1 0 1 ) 					#name: #statusAspect 					#model: #statusAspect 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Sudoku.SudokuLoginApp class</class-id> <category>interface specs</category><body package="SudokuViews">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'SUDOKU' 			#min: #(#{Core.Point} 0 0 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 876 732 ) 			#menu: #menu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 0 ) 					#name: #Label1 					#label: 'Server' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 25 0 -21 1 48 0 ) 					#name: #serverAspect 					#model: #serverAspect ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -20 1 25 0 -1 1 48 0 ) 					#name: #browseServers 					#model: #browseServers 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #browseServer 						#defaultString: 'Lookup known Servers' ) 					#label: '...' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 50 ) 					#name: #Label2 					#label: 'Volume' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 75 0 -21 1 98 0 ) 					#name: #volumeAspect 					#model: #volumeAspect ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -20 1 75 0 -1 1 98 0 ) 					#name: #browseVolumes 					#model: #browseVolumes 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #browseVolumes 						#defaultString: 'Browse Volumes' ) 					#label: '...' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 100 ) 					#name: #Label3 					#label: 'Team' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 125 0 -21 1 148 0 ) 					#name: #teamAspect 					#model: #teamAspect ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -20 1 125 0 -1 1 148 0 ) 					#name: #ActionButton1 					#model: #browseTeams 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #browseTeams 						#defaultString: 'Browse Teams' ) 					#label: '...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 175 0 -1 1 198 0 ) 					#name: #connect 					#model: #connect 					#helpText: '' 					#label: 					#(#{Kernel.UserMessage} 						#key: #connectToServer 						#defaultString: 'Connect to the Server' ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 200 0 -1 1 223 0 ) 					#name: #startLocal 					#model: #startLocal 					#label: 					#(#{Kernel.UserMessage} 						#key: #startLocalGame 						#defaultString: 'Start a local Game' ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 0 1 0 1 ) 					#name: #statusAspect 					#model: #statusAspect 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Sudoku.FactoryDialog class</class-id> <category>interface specs</category><body package="SudokuViews">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #sudokuSettings 				#defaultString: '' ) 			#min: #(#{Core.Point} 220 175 ) 			#max: #(#{Core.Point} 220 175 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1020 775 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 10 0 0 0 ) 					#name: #sudokuBoxSize 					#label: 					#(#{Kernel.UserMessage} 						#key: #sudokuBoxSize 						#defaultString: nil ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 30 0 -5 0.333333 51 0 ) 					#name: #sudokuWidth 					#label: 					#(#{Kernel.UserMessage} 						#key: #sudokuWidth 						#defaultString: nil ) ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 50 0 -5 0.333333 73 0 ) 					#name: #widthAspect 					#model: #widthAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateGridSize ) 					#type: #number 					#formatString: '0' 					#low: 1 					#high: 5 					#interval: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.333333 30 0 -5 0.666667 51 0 ) 					#name: #sudokuHeight 					#label: 					#(#{Kernel.UserMessage} 						#key: #sudokuHeight 						#defaultString: nil ) ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.333333 50 0 -5 0.666666 73 0 ) 					#name: #heightAspect 					#model: #heightAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateGridSize ) 					#type: #number 					#formatString: '0' 					#low: 1 					#high: 5 					#interval: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.666666 30 0 -10 1 51 0 ) 					#name: #sudokuGridSize 					#label: 					#(#{Kernel.UserMessage} 						#key: #sudokuGridSize 						#defaultString: nil ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.666666 50 0 -10 1 73 0 ) 					#name: #gridSizeAspect 					#model: #gridSizeAspect 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 80 ) 					#name: #sudokuLevel 					#label: 					#(#{Kernel.UserMessage} 						#key: #sudokuLevel 						#defaultString: 'Label' ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 100 0 -10 1 123 0 ) 					#name: #levelAspect 					#model: #levelAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateLevel ) 					#menu: #levelMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -33 1 90 0 -10 1 ) 					#name: #accept 					#model: #accept 					#label: 'OK' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 -33 1 180 0 -10 1 ) 					#name: #Cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #sudokuAbort 						#defaultString: '' ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Sudoku.AutoscaledView</class-id> <category>bounds changing</category><body package="SudokuViews">bounds: newBounds 	| outerBoundsFor |	super bounds: newBounds.	self transactionManager bestDisplayDo: 		[	outerBoundsFor := self outerBoundsFor: newBounds.			self outerBounds: outerBoundsFor		].</body><body package="SudokuViews">outerBounds	^ ( self at: #outerBounds ) ifNil: [ self bounds ]</body><body package="SudokuViews">outerBounds: outerBounds 	( self fastAt: #outerBounds ) = outerBounds ifFalse: [ self at: #outerBounds set: outerBounds ].</body><body package="SudokuViews">outerBoundsFor: bounds 	^ bounds</body></methods><methods><class-id>Sudoku.AutoscaledView</class-id> <category>computing</category><body package="SudokuViews">computePreferredBounds	^ ( self at: #outerBounds ) ifNil: [ super computePreferredBounds ]</body></methods><methods><class-id>Sudoku.AutoscaledView</class-id> <category>private</category><body package="SudokuViews">createViewForModel: aModel	| newView |	newView := super createViewForModel: aModel.	keyboardProcessor notNil ifTrue: [ newView addKeyboardConsumersTo: keyboardProcessor ].	^newView</body></methods><methods><class-id>Sudoku.AutoscaledView class</class-id> <category>slots</category><body package="SudokuViews">outerBoundsSlot	^ self slotSingleValue</body></methods><methods><class-id>Sudoku.GridController</class-id> <category>event dispatching</category><body package="SudokuViews">mouseWheelEvent: event 	view transactionManager displayDo: 		[ | next |			next := self nextHighlightedValue: event up.			view purgeHighlightedValues.			view at: #highlightedCandidates add: next.			lastHighlightedValue := next		].</body><body package="SudokuViews">nextHighlightedValue: up 	| current |	current := view highlightedValue.	^ current notNil 		ifTrue: 		[	up 				ifTrue: 				[	current = view gridMaxValue 						ifTrue: [ 1 ]						ifFalse: [ current + 1 ]				]				ifFalse: 				[	current = 1 						ifTrue: [ view gridMaxValue ]						ifFalse: [ current - 1 ]				]		]		ifFalse: 		[	lastHighlightedValue ifNil: 				[	up 						ifTrue: [ 1 ]						ifFalse: [ view gridMaxValue ]				]		]</body></methods><methods><class-id>Sudoku.CellController</class-id> <category>menu</category><body package="SudokuViews">candidatesMenu	| menu item gridCandidates candidates |	menu := Menu new.	item := MenuItem labeled: ''.	item value: #label.	item labelText: (( #sudokuMarkValue &gt;&gt; 'Mark Value' ) asText emphasizeAllWith: ( Array with: #bold with: #color -&gt; ColorValue darkGray )).	menu addItem: item.	gridCandidates := view gridCandidates.	candidates := view candidates.	gridCandidates do: 		[: value |			item := MenuItem labeled: value printString.			item labelText: value printString asText.			item value: value negated.			( candidates includes: value ) ifTrue: [ item beOn ].			menu addItem: item		].	candidates size = gridCandidates size ifFalse: [ menu addItem: ( MenuItem labeled: #sudokuReset &gt;&gt; 'X' ) value: #resetCandidates ].	^ menu</body><body package="SudokuViews">chooseValueMenu	| menu item possibleValues |	menu := Menu new.	item := MenuItem labeled: ''.	item value: #label.	item labelText: (( #sudokuSetValue &gt;&gt; 'Set Value' ) asText emphasizeAllWith: ( Array with: #bold with: #color -&gt; ColorValue darkGray )).	menu addItem: item.	possibleValues := view candidates.	possibleValues do: 		[: value |			item := MenuItem labeled: value printString.			item labelText: value printString asText.			item value: value.			menu addItem: item		].	view givenNumber notNil ifTrue: [ menu addItem: ( MenuItem labeled: 'X' ) value: nil ].	^ menu</body><body package="SudokuViews">fullMenu	| menu subMenu labelItem |	menu := Menu new.	subMenu := self chooseValueMenu.	labelItem := subMenu menuItems first.	subMenu removeItem: labelItem.	labelItem submenu: subMenu.	menu addItem: labelItem.	subMenu := self candidatesMenu.	labelItem := subMenu menuItems first.	subMenu removeItem: labelItem.	labelItem submenu: subMenu.	menu addItem: labelItem.	^ menu</body><body package="SudokuViews">requestMenu: menu at: point 	self ensureFocus.	self view transactionManager transactionSequenceDo: [ self sequencedRequestMenu: menu at: point ].</body><body package="SudokuViews">sequencedRequestMenu: menu at: point 	| item result |	( self sequenceDo: [ view canBeModified ]) ifFalse: [ ^ self ].	Notifier isDevelopment ifTrue: 		[	menu addLine;				addItem: ( MenuItem labeled: 'inspect' ) value: #inspect		].	item := self trackMenu: menu at: point centered: false.	item isNil ifTrue: [ ^ self ].	result := item value.	result = #inspect ifTrue: [ ^ self inspect ].	result = #resetCandidates ifTrue: [ ^ self sequenceDo: [ view resetCandidates ]].	result = #label ifTrue: [ ^ self ].	self sequenceDo: [ view givenNumber: result ].</body></methods><methods><class-id>Sudoku.CellController</class-id> <category>accessing</category><body package="SudokuViews">sequenceDo: block 	^ self view transactionManager sequenceDo: block</body><body package="SudokuViews">startPoint	^ startPoint ifNil: [ view model ]</body></methods><methods><class-id>Sudoku.CellController</class-id> <category>event dispatching</category><body package="SudokuViews">blueButtonPressedEvent: event 	| given |	view canBeModified ifFalse: [ ^ nil ].	given := view defaultRemoveValue.	given notNil ifTrue: [ ^ self view transactionManager transactionDo: [ view givenNumber: given negated ]].	self requestMenu: self chooseValueMenu at: event globalPoint.</body><body package="SudokuViews">doubleClickEvent: event 	view canBeModified ifFalse: [ ^ nil ].	view givenNumber isNil ifTrue: 		[ | given |			given := self view defaultGivenValue.			given notNil ifTrue: [ ^ self view transactionManager transactionDo: [ view givenNumber: given ]]		].	^ super doubleClickEvent: event</body><body package="SudokuViews">processDeleteKey	^ self view transactionManager transactionDo: [		self selectedViewsDo: [ : cellView | 			cellView canBeModified ifTrue: [				cellView givenNumber notNil 					ifTrue:	[ cellView givenNumber: nil ]					ifFalse:	[ cellView resetCandidates ]				]			]		]</body><body package="SudokuViews">processKeyBuffer	| value has undo nextUndo |	value := keyBuffer number.	value isNil ifTrue: [ ^ self ].	value &gt; view gridMaxValue ifTrue: 		[	keyBuffer reset.			value := value \\ 10		].	nextUndo := undo := keyBuffer popUndo.	value isZero ifTrue: [ ^ self processDeleteKey ].	self view transactionManager transactionDo: 		[( view gridView selectedComponents size &gt; 1 and: [ keyBuffer modifier isNil ]) 				ifTrue: [ keyBuffer := nil ]				ifFalse: 				[	self selectedViewsDo: 						[: cellView |							cellView canBeModified ifTrue: 								[	keyBuffer modifier notNil 										ifTrue: 										[	undo notNil ifTrue: [ cellView givenNumber: undo negated ].											has := cellView candidates includes: value.											has = ( keyBuffer modifier = $- ) ifTrue: 												[	cellView givenNumber: value negated.													nextUndo := value												]										]										ifFalse: 										[	nextUndo := nil.											cellView givenNumber: value										]								]						].					keyBuffer undo: nextUndo				]		].</body><body package="SudokuViews">processKeyboardEvent: event 	event isKeyPress ifFalse: [ ^ nil ].	event keyValue isSymbol ifTrue: [		^ self processSymbolKeyboardEvent: event		].	keyBuffer isNil ifTrue: [ keyBuffer := KeyBuffer new ].	(keyBuffer addKey: event keyValue) ifTrue: [		^ self processKeyBuffer		].	(view isSelectedCell and: [ event keyValue = $x ]) ifTrue: [		^ self processDeleteKey		].	^ nil</body><body package="SudokuViews">processSymbolKeyboardEvent: event 	#( #Left #Right #Up #Down ) with: ( Array with: -1 @ 0 with: 1 @ 0 with: 0 @ -1 with: 0 @ 1 )		do: 		[: key : delta | | point |			event keyValue = key ifTrue: 				[	point := ( self view model - ( 1 @ 1 ) + delta ) \\ self view container dimension + ( 1 @ 1 ).					self view container activateAt: point				]		].	^ nil</body><body package="SudokuViews">redButtonPressedEvent: event 	| given |	InputState default altDown ifTrue: [ ^ self selectAllSakes ].	( InputState default ctrlDown and: [ view canBeModified and: [ view givenNumber isNil ]]) ifTrue: 		[	given := self view defaultGivenValue.			( given notNil and: [ view candidates includes: given ]) ifTrue: [ ^ self view transactionManager transactionDo: [ view givenNumber: given negated ]]		].	self handleFocusEvent.</body><body package="SudokuViews">selectAllSakes	view transactionManager displayDo: 		[	InputState default ctrlDown ifFalse: [ self purgeOldSelection ].			( view at: #cellProperties ) allSakesDo: 				[: cell | | cellView |					cellView := self view container viewAt: cell sudokuCellPosition.					cellView notNil ifTrue: [ cellView isSelectedCell: true ]				]		].</body><body package="SudokuViews">selectedViewsDo: block 	view gridView selectedComponents do: block.</body><body package="SudokuViews">yellowButtonPressedEvent: event 	| menu |	view canBeModified ifFalse: [ ^ self ].	menu := ( self view parentGame showMarks and: [ view givenNumber isNil ]) 			ifTrue: [ self fullMenu ]			ifFalse: [ self chooseValueMenu ].	self requestMenu: menu at: event globalPoint.</body></methods><methods><class-id>Sudoku.CellController</class-id> <category>basic control sequence</category><body package="SudokuViews">ensureFocus	self grabKeyboard.	view transactionManager displayDo: [ view isSelectedCell: true ].</body><body package="SudokuViews">focusRangeKeepOld: keepOld 	view transactionManager displayDo: 		[ | rect otherController p1 p2 |			otherController := view keyboardProcessor currentConsumer.			( otherController notNil and: [ otherController class = self class ]) ifTrue: 				[	p1 := otherController startPoint.					p2 := view model.					rect := ( p1 min: p2 ) corner: ( p1 max: p2 ) + ( 1 @ 1 ).					view gridView components do: 						[: cellView | ( rect containsPoint: cellView model ) 								ifTrue: [ cellView isSelectedCell: true ]								ifFalse: [ keepOld ifFalse: [ cellView isSelectedCell: false ]]						].					self grabKeyboard.					startPoint := p1				]		].</body><body package="SudokuViews">grabKeyboard	| keyboardProcessor |	startPoint := nil.	keyBuffer := KeyBuffer new.	keyboardProcessor := view keyboardProcessor.	keyboardProcessor notNil ifTrue: [ keyboardProcessor setActive: self ].</body><body package="SudokuViews">handleFocusEvent	"multiselect"	| keepOld |	keepOld := InputState default ctrlDown.	InputState default shiftDown ifTrue: [ ^ self focusRangeKeepOld: keepOld ].	self grabKeyboard.	keepOld := keepOld or: [ view transactionManager displayDo: [ view gridView selectedComponents singleElementOrNil = view ]].	keepOld ifTrue: [ ^ self toggleFocus ].	self purgeOldSelection.	view transactionManager displayDo: [ view isSelectedCell: view isSelectedCell not ].</body><body package="SudokuViews">purgeOldSelection	| selectedComponents |	view transactionManager displayDo: 		[	selectedComponents := view gridView selectedComponents.			selectedComponents do: [: cell | cell isSelectedCell: false ]		].</body><body package="SudokuViews">release	| keyboardProcessor |	startPoint := nil.	keyboardProcessor := view keyboardProcessor.	keyboardProcessor notNil ifTrue: [ keyboardProcessor removeKeyboardReceiver: self ].	super release.</body><body package="SudokuViews">toggleFocus	view transactionManager displayDo: [ view isSelectedCell: view isSelectedCell not ].</body></methods><methods><class-id>Sudoku.GameApp</class-id> <category>accessing</category><body package="SudokuViews">atPos: position given: candidate 	self coastGrid atPos: position given: candidate.	self isValid ifTrue: [ self markAsWinner ].	^ candidate</body><body package="SudokuViews">childGames	^ self at: #childGames</body><body package="SudokuViews">coastGrid	^ self domainModel</body><body package="SudokuViews">findOrCreateSudokuUserNamed: name applicationClient: applicationClient 	| user |	user := self clusterManager findOrCreate: COAST.CoastUser named: name.	user name: name.	^ user</body><body package="SudokuViews">givenAtX: x y: y 	| coastGrid |	coastGrid := self coastGrid.	^ coastGrid notNil 		ifTrue: [ coastGrid givenAtX: x y: y ]		ifFalse: [ nil ]</body><body package="SudokuViews">grid	^ self coastGrid grid</body><body package="SudokuViews">grid: grid 	self coastGrid isNil ifTrue: [ self domainModel: ( Sudoku.CoastSudokuGrid newColocatedTo: self )].	self coastGrid grid: grid.	self parentGame isNil ifTrue: 		[	self winner: nil.			self depleteSlot: #newGameVoters.			self childGames do: [: game | game grid: grid ]		].</body><body package="SudokuViews">gridCandidates	^ self coastGrid gridCandidates</body><body package="SudokuViews">gridMaxValue	^ self coastGrid gridMaxValue</body><body package="SudokuViews">height	^ self coastGrid height</body><body package="SudokuViews">isValid	^ self coastGrid isValid</body><body package="SudokuViews">level	^ self at: #level.</body><body package="SudokuViews">level: level	self at: #level set: level.</body><body package="SudokuViews">localApplicationModelClass	^ LocalGameApp</body><body package="SudokuViews">name	| name |	name := self at: #name.	^ name notNil 		ifTrue: [ name ]		ifFalse: [ '' ]</body><body package="SudokuViews">name: name	self at: #name set: name asString.</body><body package="SudokuViews">numberOfValues	| coastGrid |	coastGrid := self coastGrid.	^ coastGrid isNil 		ifTrue: [ 0 ]		ifFalse: [ coastGrid numberOfValues ]</body><body package="SudokuViews">opponentApps	^ self parentGame childGames select: [: game | game ~= self and: [ Notifier isDevelopment or: [ game interestedUsers notEmpty ]]]</body><body package="SudokuViews">parentGame	^ self at: #parentGame</body><body package="SudokuViews">parentGame: parentGame 	self at: #parentGame set: parentGame.</body><body package="SudokuViews">score	^ self at: #score.</body><body package="SudokuViews">score: score	self at: #score set: score.</body><body package="SudokuViews">toggleAtPos: pos candidate: candidate 	self coastGrid toggleAtPos: pos candidate: candidate.</body><body package="SudokuViews">width	^ self coastGrid width</body><body package="SudokuViews">winner	^ self at: #winner</body><body package="SudokuViews">winner: winner 	self at: #winner set: winner.</body></methods><methods><class-id>Sudoku.GameApp</class-id> <category>settings</category><body package="SudokuViews">autoHideSakes	^ self settingsAt: #autoHideSakes default: true</body><body package="SudokuViews">autoHideSakes: hideSakes 	self settingsAt: #autoHideSakes put: hideSakes.</body><body package="SudokuViews">highlightFreeCells	^ self settingsAt: #highlightFreeCells default: true</body><body package="SudokuViews">highlightFreeCells: highlightFreeCells 	self settingsAt: #highlightFreeCells put: highlightFreeCells.</body><body package="SudokuViews">isSinglePlayerGame	| result |	result := 0.	self childGames do: 		[: app |			result := result + app interestedUsers size.			result &gt; 1 ifTrue: [ ^ false ]		].	^ true</body><body package="SudokuViews">settingsAt: key default: value 	^ self at: #settings atKey: key ifAbsent: [ value ]</body><body package="SudokuViews">settingsAt: key put: value 	^ self at: #settings atKey: key put: value</body><body package="SudokuViews">showMarks	^ self settingsAt: #showMarks default: false</body><body package="SudokuViews">showMarks: showMarks 	self settingsAt: #showMarks put: showMarks.</body></methods><methods><class-id>Sudoku.GameApp</class-id> <category>actions</category><body package="SudokuViews">ensureInitialGrid	self coastGrid isNil ifTrue: [ self grid: ( GridFactory dimension: 3 @ 3 ) grid ].</body><body package="SudokuViews">fixGrid	self parentGame grid: self grid.</body><body package="SudokuViews">markAsWinner	self parentGame winner: self.	self score: self score + 1.</body><body package="SudokuViews">newChild	| child |	child := Sudoku.GameApp newColocatedTo: self.	child domainModel: ( Sudoku.CoastSudokuGrid newColocatedTo: self ).	child parentGame: self.	self coastGrid notNil ifTrue: [ child grid: self grid ].	^ child</body><body package="SudokuViews">openFor: user 	^ self parentGame isNil 		ifTrue: 		[	self ensureInitialGrid.			self newChild openFor: user		]		ifFalse: [ super openFor: user ]</body><body package="SudokuViews">progress	| size |	size := self gridMaxValue.	^ self numberOfValues / size / size</body><body package="SudokuViews">restart	| parentGame |	parentGame := self parentGame.	parentGame winner notNil 		ifTrue: [ parentGame grid: parentGame grid	"reset for all" ]		ifFalse: [ self grid: self parentGame grid	"team reset" ].</body></methods><methods><class-id>Sudoku.GameApp</class-id> <category>testing</category><body package="SudokuViews">isEnemy: point 	^ ( self givenAtX: point x y: point y ) notNil 		ifTrue: [ false ]		ifFalse: [ self opponentApps contains: [: enemy | enemy ~= self and: [( enemy givenAtX: point x y: point y ) notNil ]]]</body><body package="SudokuViews">isInitial: point 	^ ( self parentGame givenAtX: point x y: point y ) notNil</body></methods><methods><class-id>Sudoku.GameApp</class-id> <category>new game</category><body package="SudokuViews">addNewGameVoter: user	self at: #newGameVoters add: user.</body><body package="SudokuViews">includesNewGameVoter: user 	^ self at: #newGameVoters includes: user.</body><body package="SudokuViews">newGameVoters	^ self at: #newGameVoters.</body><body package="SudokuViews">numberOfAllUsers	| result |	result := Set new.	self childGames do: [: app | result addAll: app interestedUsers ].	^ result size</body><body package="SudokuViews">numberOfNewGameVoters	^ self sizeAt: #newGameVoters</body><body package="SudokuViews">removeNewGameVoter: user	self at: #newGameVoters remove: user.</body></methods><methods><class-id>Sudoku.GameApp</class-id> <category>demons</category><body package="SudokuViews">updateUsers: newUsers oldUsers: oldUsers 	oldUsers do: [: user | self parentGame removeNewGameVoter: user ].</body></methods><methods><class-id>Sudoku.GameApp class</class-id> <category>slots</category><body package="SudokuViews">childGamesSlot	^ ( self slotOfType: #set )		range: GameApp;		invertsTo: #parentGame;		yourself</body><body package="SudokuViews">interestedUsersSlot	^ ( super interestedUsersSlot )		differencesDemon: #updateUsers:oldUsers:;		yourself</body><body package="SudokuViews">levelSlot	^ self slotSingleValue</body><body package="SudokuViews">nameSlot	^ ( self slotSingleValue )		range: String;		yourself</body><body package="SudokuViews">newGameVotersSlot	^ (self slotOfType: #set)		range: COAST.CoastUser;		yourself</body><body package="SudokuViews">parentGameSlot	^ ( self slotSingleValue )		range: GameApp;		invertsTo: #childGames;		yourself</body><body package="SudokuViews">scoreSlot	^ ( self slotSingleValue )		defaultValue: 0;		yourself</body><body package="SudokuViews">settingsSlot	^ self slotOfType: #dictionary</body><body package="SudokuViews">winnerSlot	^ ( self slotSingleValue )		range: GameApp;		yourself</body></methods><methods><class-id>Sudoku.AbstractCellView</class-id> <category>accessing</category><body package="SudokuViews">addKeyboardConsumersTo: aKeyboardProcessor 	"ignore"</body><body package="SudokuViews">defaultControllerClass	self subclassResponsibility.</body><body package="SudokuViews">frameColor	self subclassResponsibility.</body><body package="SudokuViews">gameApp	^ self gridView gameApp</body><body package="SudokuViews">givenNumber	^ self at: #givenNumber</body><body package="SudokuViews">grid	^ self gridView grid</body><body package="SudokuViews">gridView	^ self container</body><body package="SudokuViews">isInitial	^ self gridView isInitial: self model</body><body package="SudokuViews">localUser	^ self transactionManager localUser</body><body package="SudokuViews">parentGame	^ self gameApp parentGame</body><body package="SudokuViews">showMarks	^ false</body><body package="SudokuViews">x	^ self model x</body><body package="SudokuViews">y	^ self model y</body></methods><methods><class-id>Sudoku.AbstractCellView</class-id> <category>colors - computing</category><body package="SudokuViews">computeBackgroundColor	self subclassResponsibility.</body><body package="SudokuViews">computeBackgroundTargetColor	self backgroundColor: self computeBackgroundColor.</body></methods><methods><class-id>Sudoku.AbstractCellView</class-id> <category>colors - accessing</category><body package="SudokuViews">backgroundColor	^ self at: #backgroundColor</body><body package="SudokuViews">backgroundColor: color 	| oldColor |	oldColor := self fastAt: #backgroundColor.	oldColor = color ifFalse: [ self at: #backgroundColor set: color ].</body></methods><methods><class-id>Sudoku.AbstractCellView</class-id> <category>printing</category><body package="SudokuViews">printOn: stream 	super printOn: stream.	stream nextPutAll: ' on '.	self model printOn: stream.</body></methods><methods><class-id>Sudoku.AbstractCellView</class-id> <category>computing</category><body package="SudokuViews">computeCellProperties	| cell grid max |	grid := self grid.	max := grid width * grid height.	( max &lt; self model x or: [ max &lt; self model y ]) ifTrue: [ ^ nil ].	cell := grid cellAtX: self model x y: self model y.	^ cell</body><body package="SudokuViews">computePreferredBounds	| pos |	self givenNumber.	self backgroundColor.	pos := ( self model - ( 1 @ 1 )) * container gridExtent.	^ pos extent: container gridExtent</body></methods><methods><class-id>Sudoku.AbstractCellView</class-id> <category>displaying</category><body package="SudokuViews">composeBackgroundOn: aGraphicsContext bounds: bounds 	| backgroundColor gcc |	backgroundColor := self backgroundColor.	backgroundColor notNil ifTrue: 		[	gcc := aGraphicsContext copy.			gcc paint: backgroundColor.			gcc displayRectangle: bounds.			self composeFrame: bounds on: gcc		].</body><body package="SudokuViews">composeDisplayOn: aGraphicsContext 	| bounds givenNumber |	bounds := self bounds.	bounds isNil ifTrue: [ ^ 0 ].	bounds := bounds insetBy: 4.	self composeBackgroundOn: aGraphicsContext bounds: bounds.	givenNumber := self givenNumber.	givenNumber notNil ifTrue: [ self composeDisplayValue: givenNumber on: aGraphicsContext copy center: bounds center ].	^ givenNumber</body><body package="SudokuViews">composeDisplayValue: int on: gcc center: center 	( ComposedText withText: int displayString asText style: container style ) sudokuDisplayOn: gcc center: center.</body><body package="SudokuViews">composeFrame: bounds on: gcc 	| color |	color := self frameColor.	color notNil 		ifTrue: 		[	gcc paint: color.			( bounds insetBy: 1 ) displayStrokedOn: gcc.			bounds displayStrokedOn: gcc.			( bounds insetBy: -1 ) displayStrokedOn: gcc.			gcc paint: ( color sudokuMergeColor: ColorValue black ).			bounds displayStrokedOn: gcc		]		ifFalse: 		[	gcc paint: ColorValue black.			bounds displayStrokedOn: gcc		].</body></methods><methods><class-id>Sudoku.AbstractCellView class</class-id> <category>slots - colors</category><body package="SudokuViews">backgroundColorSlot	^ self slotSingleValue</body><body package="SudokuViews">backgroundTargetColorSlot	^ self slotComputedEagerBy: #computeBackgroundTargetColor</body></methods><methods><class-id>Sudoku.AbstractCellView class</class-id> <category>slots</category><body package="SudokuViews">cellPropertiesSlot	^ self slotComputedEagerBy: #computeCellProperties</body><body package="SudokuViews">givenNumberSlot	^ self slotSingleValue</body></methods><methods><class-id>Sudoku.KeyBuffer</class-id> <category>accessing</category><body package="SudokuViews">addKey: key 	| digitValue |	key isSymbol ifFalse: 		[	self checkTime.			( '+-' includes: key ) ifTrue: 				[	self reset.					modifier := key.					self setTime.					^ true				].			key isDigit ifTrue: 				[	digitValue := key digitValue.					number := number isNil 							ifTrue: [ digitValue ]							ifFalse: [ number * 10 + digitValue ].					self setTime.					^ true				]		].	self reset.	^ false</body><body package="SudokuViews">checkTime	Time millisecondClockValue - time &lt; 1250 ifFalse: [ self reset ].</body><body package="SudokuViews">initialize	self setTime.</body><body package="SudokuViews">modifier	^ modifier</body><body package="SudokuViews">number	^ number</body><body package="SudokuViews">popUndo	| result |	^ undo notNil 		ifTrue: 		[	result := undo.			undo := nil.			result		]		ifFalse: [ nil ]</body><body package="SudokuViews">reset	undo := number := modifier := nil.</body><body package="SudokuViews">setTime	time := Time millisecondClockValue.</body><body package="SudokuViews">undo: oldVal 	undo := oldVal.</body></methods><methods><class-id>Sudoku.KeyBuffer class</class-id> <category>instance creation</category><body package="SudokuViews">new	^ ( super new )		initialize;		yourself</body></methods><methods><class-id>Sudoku.LocalGameApp</class-id> <category>accessing</category><body package="SudokuViews">allUsers	^ self at: #allUsers</body><body package="SudokuViews">coastGrid	^ self domainModel</body><body package="SudokuViews">dimension	^ self at: #dimension</body><body package="SudokuViews">fetchLocalUser	^ self transactionManager localUser</body><body package="SudokuViews">fixGrid	self transactionSequenceDo: 		[ | grid |			grid := self sequenceDo: [ self grid copy ].			SolvingContext forValidation solveUnique: grid.			(grid isValid or: [ self confirmFix: grid ]) ifTrue: 				[	self sequenceDo: 						[	grid := self gridView coastGrid grid copy.							self grid: grid named: grid asString 						] 				] 		]</body><body package="SudokuViews">grid	^ self gridView grid</body><body package="SudokuViews">grid: grid 	| stream |	stream := String new writeStream.	stream nextPutAll: ( GridFactory levelFor: grid ) displayString.	stream nextPutAll: ' / '.	stream nextPutAll: grid asString.	self grid: grid named: stream contents.</body><body package="SudokuViews">grid: grid named: name 	self parentGame name: name.	self parentGame grid: grid.</body><body package="SudokuViews">height	^ self dimension y</body><body package="SudokuViews">ignoreBlueButton	^ false</body><body package="SudokuViews">level	^ self at: #level</body><body package="SudokuViews">name	^ self parentGame name</body><body package="SudokuViews">name: name 	self parentGame name: name.</body><body package="SudokuViews">newEmpty	self transactionDo: [ self grid: ( Grid width: self width height: self height ) named: ( #sudokuUserDefined &gt;&gt; 'User Defined' ) asString ].</body><body package="SudokuViews">nextSeed	^ ( Random new next * SmallInteger maxVal ) floor</body><body package="SudokuViews">parentGame	^ self teamGame parentGame</body><body package="SudokuViews">teamGame	^ self model</body><body package="SudokuViews">teamGrid: grid 	self teamGame grid: ( self gridView reverseScramble scrambleGrid: grid ).</body><body package="SudokuViews">width	^ self dimension x</body></methods><methods><class-id>Sudoku.LocalGameApp</class-id> <category>testing</category><body package="SudokuViews">autoHideSakes	^ self parentGame autoHideSakes</body><body package="SudokuViews">autoHideSakes: hideSakes 	self parentGame autoHideSakes: hideSakes.</body><body package="SudokuViews">canModifyGame	^ self isLocalGame or: [ self isSinglePlayerGame ]</body><body package="SudokuViews">highlightFreeCells	^ self parentGame highlightFreeCells</body><body package="SudokuViews">highlightFreeCells: highlightFreeCells 	self parentGame highlightFreeCells: highlightFreeCells.</body><body package="SudokuViews">isLocalGame	^ self teamGame isLocal</body><body package="SudokuViews">isNewGameVoter	^ self parentGame includesNewGameVoter: self localUser</body><body package="SudokuViews">showMarks	^ self parentGame showMarks</body><body package="SudokuViews">showMarks: showMarks 	self parentGame showMarks: showMarks.</body></methods><methods><class-id>Sudoku.LocalGameApp</class-id> <category>actions</category><body package="SudokuViews">confirmFix: grid 	"grid not unique solvable..."	| str |	SolvingContext forValidation solveGrid: grid.	str := grid isValid 			ifTrue: [ #sudokuMultipleSolutions &gt;&gt; '' ]			ifFalse: [ #sudokuNotSolvable &gt;&gt; '' ].	^ Dialog choose: str		labels: ( Array with: #sudokuIgnoreForFix &gt;&gt; 'OK' with: #Cancle &gt;&gt; 'Cancle' )		values: #( true false )		default: false		for: self mainWindow</body><body package="SudokuViews">copyToClipboard	Screen default putExternalSelection: self grid asString.</body><body package="SudokuViews">newFromString: string 	Cursor wait showWhile: 		[ | grids |			grids := OrderedCollection new.			Grid fromString: string do: [: grid | grids add: grid ].			grids do: 				[: grid | ( SolvingContext forValidation solveGrid: grid copy ) 						ifTrue: [ ^ self transactionDo: [ self grid: ( self gridView scramble reverse scrambleGrid: grid ) named: grid simpleString ]]				]		].</body><body package="SudokuViews">openGridOptions	| newFactory |	newFactory := FactoryDialog openOnGridFactory: self gridFactory parentView: self mainWindow.	newFactory notNil ifTrue: 		[	self transactionDo: 				[	self parentGame level: ( GridFactory defaultLevels indexOf: newFactory level ).					self grid: newFactory grid				]		].</body><body package="SudokuViews">pasteFromClipboard	self newFromString: Screen default getExternalSelection.</body><body package="SudokuViews">restart	Cursor wait showWhile: [ self transactionDo: [ self teamGame restart ]].</body><body package="SudokuViews">toggleHideSakes	self transactionDo: [ self autoHideSakes: self autoHideSakes not ].</body><body package="SudokuViews">toggleHighlightFreeCells	self transactionDo: [ self highlightFreeCells: self highlightFreeCells not ].</body><body package="SudokuViews">toggleShowMarks	self transactionDo: [ self showMarks: self showMarks not ].</body><body package="SudokuViews">verify	^ Dialog warn: ( self grid copy solve 				ifTrue: [ #sudokuSolvable &gt;&gt; 'Solvable' ]				ifFalse: [ #sudokuNotSolvable &gt;&gt; 'Not Solvable!' ])		for: self mainWindow</body><body package="SudokuViews">voteNewGame	self transactionDo: 		[	self isLocalGame 				ifTrue: 				[	Cursor wait showWhile: 						[ | count |							count := self teamGame numberOfValues.							( count &gt; 0 and: [ self gridFactory isDone not and: [ self parentGame numberOfValues = count ]]) 								ifTrue: [ self grid: ( Scramble scrambleGrid: self grid )]								ifFalse: [ self grid: self gridFactory grid ]						]				]				ifFalse: 				[ | parentGame |					parentGame := self parentGame.					( parentGame includesNewGameVoter: self localUser ) 						ifTrue: [ parentGame removeNewGameVoter: self localUser ]						ifFalse: [ parentGame addNewGameVoter: self localUser ]				]		].</body></methods><methods><class-id>Sudoku.LocalGameApp</class-id> <category>computing</category><body package="SudokuViews">computeButtonsState	| enableHints |	enableHints := self isSinglePlayerGame and: [ self parentGame winner isNil ].	self widgetAt: #prevHint		do: 		[: w | | hasPrev |			hasPrev := enableHints and: [ gridView previousAdornment notNil ].			hasPrev = w isEnabled ifFalse: [ w isEnabled: hasPrev ]		].	self widgetAt: #nextHint		do: 		[: w | | str label |			str := ( enableHints and: [ gridView adornment notNil ]) 					ifTrue: [ '&gt;' ]					ifFalse: [ '?' ].			str = w label text ifFalse: 				[	label := w label copy.					label text: str asText allBold.					w label: label				].			enableHints = w isEnabled ifFalse: [ w isEnabled: enableHints ]		].</body><body package="SudokuViews">computeDimension	| coastGrid dimension |	coastGrid := self coastGrid.	dimension := coastGrid notNil 			ifTrue: [ coastGrid width @ coastGrid height ]			ifFalse: [ 3 @ 4 ].	gridFactory notNil ifTrue: [ gridFactory dimension: dimension ].	^ dimension</body><body package="SudokuViews">computeLevel	| parentGame levelNumber level defaultLevels |	parentGame := self parentGame.	levelNumber := parentGame notNil 			ifTrue: [ parentGame level ]			ifFalse: [ nil ].	defaultLevels := GridFactory defaultLevels.	level := ( levelNumber isNil or: [ levelNumber &lt; 1 or: [ defaultLevels size &lt; levelNumber ]]) 			ifTrue: [ GridFactory defaultLevel ]			ifFalse: [ defaultLevels at: levelNumber ].	gridFactory notNil ifTrue: [ gridFactory level: level ].	^ level</body><body package="SudokuViews">computeNewGameNeeded	self coastGrid notNil ifTrue: 		[ | numberOfAllUsers |			numberOfAllUsers := self parentGame numberOfAllUsers.			( numberOfAllUsers &gt; 0 and: [ self parentGame numberOfNewGameVoters / numberOfAllUsers &gt; ( 1 / 2 )]) ifFalse: [ ^ self ]		].	[ Cursor wait showWhile: [ self transactionDo: [ self grid: self gridFactory grid ]]] fork.</body><body package="SudokuViews">computeSortedUsers	| result |	result := Set new.	self parentGame childGames do: [: app | result addAll: app interestedUsers ].	^ result sortedBy: [: user | user frameID ]	"	^ result asSortedCollection: [: u1 : u2 | u1 frameID &lt; u2 frameID ]"</body><body package="SudokuViews">computeWindowTitle	| stream parentGame n |	stream := String new writeStream.	stream nextPutAll: 'SUDOKU'.	parentGame := self parentGame.	stream nextPutAll: ' - '; nextPutAll: parentGame name.	n := parentGame := parentGame numberOfAllUsers.	n &gt; 1 ifTrue: 		[	stream nextPutAll: ' ('.			n printOn: stream.			stream space; nextPutAll: ( #sudokuUser &gt;&gt; '' ) asString; nextPutAll: ')'		].	builder window label: stream contents.</body><body package="SudokuViews">gridFactory	gridFactory isNil ifTrue: 		[	gridFactory := ForkedGridFactory dimension: self dimension level: self level.			gridFactory timeout: 2000000	"2 Seconds"		].	^ gridFactory</body><body package="SudokuViews">isSinglePlayerGame	^ self parentGame isSinglePlayerGame</body></methods><methods><class-id>Sudoku.LocalGameApp</class-id> <category>aspects</category><body package="SudokuViews">gridView	gridView isNil ifTrue: [ gridView := GridView model: self teamGame ].	^ gridView</body><body package="SudokuViews">hintAspect	^ hintAspect isNil 		ifTrue: [ hintAspect := COAST.CoastAspectAdaptor accessBlock: [ self gridView currentHintString ]]		ifFalse: [ hintAspect ]</body><body package="SudokuViews">radarView	radarView isNil ifTrue: [ radarView := RadarView model: self teamGame ].	^ radarView</body></methods><methods><class-id>Sudoku.LocalGameApp</class-id> <category>hints</category><body package="SudokuViews">availableTips	| grid context levels tips |	grid := self grid copy.	context := SolvingContext forValidation.	levels := GridFactory defaultLevels.	tips := OrderedCollection new.	FinalStateDetection allSubclasses do: 		[: strategy |			grid := self checkGrid: grid strategy: strategy context: context addTips: tips.			tips notEmpty ifTrue: [ ^ tips ]		].	levels do: 		[: level |			level strategies do: [: strategy | grid := self checkGrid: grid strategy: strategy context: context addTips: tips ].			tips notEmpty ifTrue: [ ^ tips ]		].	^ tips</body><body package="SudokuViews">checkGrid: grid strategy: strategy context: context addTips: tips 	strategy tipsIn: grid		context: context		do: 		[: tip |			tips add: tip.			^ self grid copy		].	^ grid</body><body package="SudokuViews">nextHint	self transactionDo: 		[ | adornment nextAdornment |			adornment := gridView adornment.			adornment notNil 				ifTrue: 				[	nextAdornment := adornment nextAdornment.					nextAdornment notNil 						ifTrue: [ gridView adornment: nextAdornment ]						ifFalse: 						[ | grid |							grid := self grid copy.							adornment modifyGrid: grid.							self teamGrid: grid.							self resetAdornment						]				]				ifFalse: [ self tip: self nextTip ]		].</body><body package="SudokuViews">nextTip	| availableTips tip |	availableTips := self availableTips.	availableTips isEmpty ifTrue: 		[	Dialog warn: #sudokuNoStrategyApplieable &gt;&gt; 'Sorry' for: self builder window.			^ nil		].	tip := Menu sudokuChoose: #sudokuStrategies &gt;&gt; 'Strategies' from: availableTips window: self builder window.	( tip notNil and: [ self showMarks not and: [ tip needsCandidates ]]) ifTrue: [ self showMarks: true ].	^ tip</body><body package="SudokuViews">prevHint	self transactionDo: 		[ | previousAdornment |			previousAdornment := gridView previousAdornment.			previousAdornment notNil ifTrue: [ gridView adornment: previousAdornment ]		].</body><body package="SudokuViews">purgeHighlightedValues	self gridView purgeHighlightedValues.</body><body package="SudokuViews">resetAdornment	self gridView resetAdornment.</body><body package="SudokuViews">solve	| isValid |	isValid := self transactionDo: 			[ | grid |				grid := self grid copy.				SolvingContext solveGrid: grid.				grid isValid ifTrue: [ self teamGame grid: grid ].				grid isValid			].	isValid ifFalse: [ Dialog warn: #sudokuNotSolvable &gt;&gt; 'Not Solvable!' for: self mainWindow ].</body><body package="SudokuViews">tip: tip 	tip isSudokuSolvingStrategy 		ifTrue: 		[	self purgeHighlightedValues.			self gridView adornment: ( tip adornmentsIn: self grid )		]		ifFalse: [ self gridView resetAdornment ].</body></methods><methods><class-id>Sudoku.LocalGameApp</class-id> <category>toolbar</category><body package="SudokuViews">currentToolBar	^ self at: #toolbarTrigger</body><body package="SudokuViews">itemForCandidate: candidate 	| item |	item := MenuItem labeled: candidate printString.	item helpText: item label.	item labelImage: ( SudokuIconLibrary visualFor: candidate ).	item value: (( PluggableAdaptor on: self ) getBlock: [: m | self gridView highlightedValues includes: candidate ]				putBlock: [: m : v | m transactionDo: [ m gridView highlight: candidate includes: v ]]				updateBlock: [: m : a : p | ]).	^ item</body><body package="SudokuViews">toolBar	toolBarAspect isNil ifTrue: [ toolBarAspect := COAST.CoastAspectAdaptor accessBlock: [ self currentToolBar ]].	^ toolBarAspect</body><body package="SudokuViews">updateToolbar	| menu item highlightedValues |	self canModifyGame.	menu := self class toolbar.	menu addLine.	1 to: self teamGame gridMaxValue		do: 		[: candidate |			item := self itemForCandidate: candidate.			menu addItem: item		].	item := MenuItem labeled: 'xy'.	item helpText: item label.	item labelImage: ( SudokuIconLibrary visualFor: #xyButton ).	highlightedValues := self gridView highlightedValues.	item value: (( PluggableAdaptor on: self ) getBlock: [: m | highlightedValues includes: #xy ]				putBlock: [: m : v | m transactionDo: [ m gridView highlight: #xy includes: v ]]				updateBlock: [: m : a : p | ]).	item enabled: self showMarks.	menu addItem: item.	self widgetWrapperAt: #toolBar do: [: w | w invalidate ].	^ menu</body></methods><methods><class-id>Sudoku.LocalGameApp</class-id> <category>interface opening</category><body package="SudokuViews">costifyMenu	| editMenuButton gameMenuHolder |	editMenuButton := self builder window menuBar.	gameMenuHolder := COAST.CoastAspectAdaptor accessBlock: 			[ | menu |				menu := self class menu.				self canModifyGame.				self teamGame notNil 					ifTrue: 					[	menu menuItems first submenu menuItems do: 							[: item |								#fixGrid = item nameKey ifTrue: [ item hidden: self parentGame numberOfValues &gt; 0 ].								#solve = item nameKey ifTrue: [ item hidden: self parentGame numberOfValues = 0 ]							]					]					ifFalse: [ gameMenuHolder standBy ].				menu			].	editMenuButton menuChannel: gameMenuHolder.</body><body package="SudokuViews">postBuildWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	aBuilder window damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new.	aBuilder == self builder ifTrue: [ self gridView addKeyboardConsumersTo: aBuilder keyboardProcessor ].	^ super postBuildWith: aBuilder</body><body package="SudokuViews">postOpenWith: aBuilder 	self costifyMenu.	^ super postOpenWith: aBuilder</body><body package="SudokuViews">setIconWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	aBuilder window icon: ( Icon figure: self class sudokuIcon shape: self class sudokuIconMask ).</body><body package="SudokuViews">specificationFor: aKey 	^ aKey == #changeableSpec 		ifTrue: 		[	self model isLocal 				ifTrue: [ super specificationFor: #singlePlayerSpec ]				ifFalse: [ super specificationFor: #multiPlayerSpec ]		]		ifFalse: [ super specificationFor: aKey ]</body></methods><methods><class-id>Sudoku.LocalGameApp class</class-id> <category>slots</category><body package="SudokuViews">buttonsStateSlot	^ self slotComputedEagerBy: #computeButtonsState</body><body package="SudokuViews">dimensionSlot	^ self slotComputedEagerBy: #computeDimension</body><body package="SudokuViews">levelSlot	^ self slotComputedEagerBy: #computeLevel</body><body package="SudokuViews">newGameNeededSlot	^ self slotComputedEagerBy: #computeNewGameNeeded</body><body package="SudokuViews">sortedUserSlot	^ self slotComputedBy: #computeSortedUsers</body><body package="SudokuViews">toolbarTriggerSlot	^ self slotComputedEagerBy: #updateToolbar</body><body package="SudokuViews">windowTitleSlot	^ self slotComputedEagerBy: #computeWindowTitle</body></methods><methods><class-id>Sudoku.SudokuIconLibrary</class-id> <category>resources</category><body package="SudokuViews">retrieveEnablementImageFor: symbolOrInteger 	^ symbolOrInteger isInteger 		ifTrue: 		[ | extent style pixmap image gc |			extent := iconSize asInteger @ ( iconSize copyFrom: ( iconSize indexOf: $x ) + 1 to: iconSize size ) asInteger.			style := self class styleAt: extent x - 3.			pixmap := Pixmap extent: extent.			image := self class visualFor: #filledButton.			gc := pixmap graphicsContext.			image displayOn: gc at: 0 @ 0.			gc paint: ColorValue black.			( ComposedText withText: symbolOrInteger printString asText style: style ) sudokuDisplayOn: gc center: extent // 2 - ( 0 @ 1 ).			image figure: pixmap shape: image shape		]		ifFalse: [ super retrieveEnablementImageFor: symbolOrInteger ]</body></methods><methods><class-id>Sudoku.SudokuIconLibrary class</class-id> <category>utility</category><body package="SudokuViews">styleAt: pixelSize 	^ self styleAt: pixelSize bold: pixelSize &lt; 21</body><body package="SudokuViews">styleAt: pixelSize bold: bold 	| style cStyle fontDescription |	cStyle := VariableCharacterAttributes newWithDefaultAttributes.	fontDescription := FontDescription new.	fontDescription		family: #( 'arial' '*' );		manufacturer: #( 'adobe' '*' );		fixedWidth: false;		serif: false;		italic: false;		boldness: ( bold 					ifTrue: [ 0.75 ]					ifFalse: [ 0.5 ]);		pixelSize: pixelSize.	cStyle setDefaultQuery: fontDescription.	cStyle noScaling.	style := TextAttributes new.	style setCharacterAttributes: cStyle.	style lineGrid: pixelSize;		baseline: pixelSize.	^ style</body></methods><methods><class-id>Sudoku.SudokuIconLibrary class</class-id> <category>resources grid</category><body package="SudokuViews">check20x20mask	^ self emptyGrid20x20mask</body><body package="SudokuViews">filledGrid20x20mask	^ self emptyGrid20x20mask</body><body package="SudokuViews">newGrid20x20mask	^ self emptyGrid20x20mask</body><body package="SudokuViews">resetGrid20x20mask	^ self emptyGrid20x20mask</body><body package="SudokuViews">settings20x20mask	^ self emptyGrid20x20mask</body></methods><methods><class-id>Sudoku.SudokuIconLibrary class</class-id> <category>resources button</category><body package="SudokuViews">filledButton20x20bw	^ self emptyButton20x20bw</body><body package="SudokuViews">filledButton20x20mask	^ self emptyButton20x20mask</body><body package="SudokuViews">xyButton20x20mask	^ self emptyButton20x20mask</body></methods><methods><class-id>Sudoku.SudokuServerDialog</class-id> <category>aspects</category><body package="SudokuViews">passwordAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^passwordAspect isNil		ifTrue:			[passwordAspect := String new asValue]		ifFalse:			[passwordAspect]</body><body package="SudokuViews">serverAspect	^ serverAspect isNil 		ifTrue: [ serverAspect := ( self iniAccess at: #host ifAbsent: [ String new ]) asValue ]		ifFalse: [ serverAspect ]</body><body package="SudokuViews">statusAspect	^ statusAspect isNil 		ifTrue: [ statusAspect := String new asValue ]		ifFalse: [ statusAspect ]</body><body package="SudokuViews">teamAspect	^ teamAspect isNil 		ifTrue: [ teamAspect := ( self iniAccess at: #team ifAbsent: [ String new ]) asValue ]		ifFalse: [ teamAspect ]</body><body package="SudokuViews">userNameAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userNameAspect isNil		ifTrue:			[userNameAspect := String new asValue]		ifFalse:			[userNameAspect]</body><body package="SudokuViews">volumeAspect	^ volumeAspect isNil 		ifTrue: [ volumeAspect := ( self iniAccess at: #volume ifAbsent: [ String new ]) asValue ]		ifFalse: [ volumeAspect ]</body></methods><methods><class-id>Sudoku.SudokuServerDialog</class-id> <category>actions</category><body package="SudokuViews">browseServers	| hostAndPorts server |	hostAndPorts := self recentHostAndPorts.	hostAndPorts isEmpty ifTrue: [ ^ self notifyError: #noKnownServers &gt;&gt; 'No known Servers' ].	server := self choose: 'Server' from: hostAndPorts.	server notNil ifTrue: [ self serverAspect value: server ].</body><body package="SudokuViews">browseTeams	| host error teams team volumes volume game |	host := self serverAspect value.	error := self checkHostVersion: host.	error notNil ifTrue: [ ^ self notifyError: error ].	self clientAt: host.	volumes := Cursor wait showWhile: [ client volumeManager volumesAtHost: host ].	volume := self volumeAspect value.	( volumes includes: volume ) ifFalse: [ ^ self notifyError: #invalidVolume &gt;&gt; 'Invalid Volume' ].	game := client volumeManager modelNamed: 'SUDOKU' inVolume: volume.	game isNil ifTrue: [ ^ self notifyError: #noGameAvailable &gt;&gt; 'No SUDOKU-Game specified' ].	teams := game childGames collect: [: e | e name ].	teams isEmpty ifTrue: [ ^ self notifyError: #noTeamAvailable &gt;&gt; 'No SUDOKU-Teams available' ].	team := self choose: 'Teams' from: teams.	team notNil ifTrue: [ self teamAspect value: team ].	self addRecentHostAndPort: host.</body><body package="SudokuViews">browseVolumes	| host error volumes volume |	host := self serverAspect value.	error := self checkHostVersion: self serverAspect value.	error notNil ifTrue: [ ^ self notifyError: error ].	volumes := Cursor wait showWhile: [ COAST.CoastClientVolumeManager volumesAtHost: host ].	volumes isEmpty ifTrue: [ ^ self notifyError: ( #noVolumesAvailable &gt;&gt; 'No volumes available' ) asString ].	volume := self choose: 'Volume' from: volumes.	volume notNil ifTrue: [ self volumeAspect value: volume ].</body><body package="SudokuViews">connect	| host error volume team app user |	host := self serverAspect value.	error := self checkHostVersion: host.	error notNil 		ifTrue: [ ^ self notifyError: error ]		ifFalse: [ self iniAccess at: #host put: host ].	volume := self volumeAspect value.	volume isEmpty 		ifTrue: [ ^ self notifyError: #noVolumeSpecified &gt;&gt; 'No Volume specified' ]		ifFalse: [ self iniAccess at: #volume put: volume ].	team := self teamAspect value.	team isEmpty 		ifTrue: [ ^ self notifyError: #noTeamSpecified &gt;&gt; 'No Team specified' ]		ifFalse: [ self iniAccess at: #team put: team ].	self clientAt: host.	client transactionManager transactionDo: 		[ | userName parentGame |			userName := CEnvironment getenv: 'USERNAME'.			parentGame := client volumeManager findOrCreate: GameApp named: 'SUDOKU' inVolume: volume.			parentGame ensureInitialGrid.			app := parentGame childGames 					detect: [: game | game name = team ]					ifNone: 					[( parentGame newChild )							name: team;							yourself					].			user := parentGame findOrCreateSudokuUserNamed: userName applicationClient: client.			user ensureLocalCopy.			user register.			app openFor: user		]		onFailure: [ ^ self ].	client transactionManager lastWishTransactionDo: [ app closeFor: user ].	self iniAccess writeFile.	self addRecentHostAndPort: host.	self accept value: true.	self closeRequest.</body><body package="SudokuViews">startLocal	self clientAt: nil.	client transactionManager transactionDo: 		[ | parentGame app user |			parentGame := GameApp newLocal.			parentGame ensureInitialGrid.			app := parentGame newChild.			app name: #local &gt;&gt; 'Local'.			user := COAST.CoastUser newLocal.			user ensureLocalCopy.			user register.			app openFor: user		].</body></methods><methods><class-id>Sudoku.SudokuServerDialog</class-id> <category>private</category><body package="SudokuViews">addRecentHostAndPort: hostAndPort 	| recentHostAndPorts writeStream |	recentHostAndPorts := self recentHostAndPorts.	( recentHostAndPorts includes: hostAndPort ) ifTrue: [ ^ self ].	writeStream := self hostFile appendStream.	[ writeStream nextPutAll: hostAndPort; cr ] ensure: [ writeStream close ].</body><body package="SudokuViews">checkHostVersion: hostname 	| mediatorVersion clientVersion |	hostname isNil ifTrue: [ ^ #noServersSpecified &gt;&gt; 'No Server specified' ].	mediatorVersion :=		[ COAST.CoastMediatorStub versionAtHost: hostname ] on: COAST.CoastError do: [: err | ^ #serversUnreachable &gt;&gt; 'Server unreachable' ].	clientVersion := COAST.CoastVersion defaultCoastVersion.	mediatorVersion = clientVersion ifFalse: [ ^ #serversNotCompatible &gt;&gt; 'Server not compatible' ].	^ nil</body><body package="SudokuViews">choose: title from: strings 	^ Menu sudokuChoose: title from: strings window: self builder window</body><body package="SudokuViews">clientAt: host 	client isNil ifTrue: 		[	client := COAST.CoastApplicationClientWithUI new.			client volumeManager generatePersistentClientIDUsing: Time microsecondClock printString asByteArray		].	client volumeManager defaultHost: host.	^ client</body><body package="SudokuViews">hostFile	^ 'sudokuserver.txt' asFilename</body><body package="SudokuViews">iniAccess	iniAccess isNil ifTrue: [ iniAccess := COAST.CoastIniAccess readFile: 'sudoku.ini' ].	^ iniAccess</body><body package="SudokuViews">notifyError: error 	self statusAspect value: error asString.</body><body package="SudokuViews">postBuildWith: aBuilder 	| win |	( win := aBuilder window ) notNil ifTrue: [ win icon: ( Icon new figure: LocalGameApp windowIcon shape: LocalGameApp windowIconMask )].	super postBuildWith: aBuilder.</body><body package="SudokuViews">recentHostAndPorts	| readStream recentHostAndPorts hostFile |	recentHostAndPorts := Set new.	hostFile := self hostFile.	hostFile definitelyExists ifFalse: [ ^ recentHostAndPorts ].	readStream := hostFile readStream.	[			[ readStream atEnd ] whileFalse: 			[ | string |				string := readStream upTo: Character cr.				string isEmpty ifFalse: [ recentHostAndPorts add: string ]			]	] ensure: [ readStream close ].	^ recentHostAndPorts</body></methods><methods><class-id>Sudoku.SudokuServerDialog class</class-id> <category>instance creation</category><body package="SudokuViews">connectToServer	| newInst |	newInst := self new.	newInst open.	^ newInst accept value</body><body package="SudokuViews">startLocal	self new startLocal.</body></methods><methods><class-id>Sudoku.SudokuLoginApp</class-id> <category>private</category><body package="SudokuViews">addRecentHostAndPort: hostAndPort 	| recentHostAndPorts writeStream |	recentHostAndPorts := self recentHostAndPorts.	( recentHostAndPorts includes: hostAndPort ) ifTrue: [ ^ self ].	writeStream := self hostFile appendStream.	[ writeStream nextPutAll: hostAndPort; cr ] ensure: [ writeStream close ].</body><body package="SudokuViews">checkHostVersion: hostname 	| mediatorVersion clientVersion |	hostname isNil ifTrue: [ ^ #noServersSpecified &gt;&gt; 'No Server specified' ].	mediatorVersion :=		[ COAST.CoastMediatorStub versionAtHost: hostname ] on: COAST.CoastError do: [: err | ^ #serversUnreachable &gt;&gt; 'Server unreachable' ].	clientVersion := COAST.CoastVersion defaultCoastVersion.	mediatorVersion = clientVersion ifFalse: [ ^ #serversNotCompatible &gt;&gt; 'Server not compatible' ].	^ nil</body><body package="SudokuViews">choose: title from: strings 	^ Menu sudokuChoose: title from: strings window: self builder window</body><body package="SudokuViews">clientAt: host 	client isNil ifTrue: 		[	client := COAST.CoastApplicationClientWithUI new.			client volumeManager generatePersistentClientIDUsing: Time microsecondClock printString asByteArray		].	client volumeManager defaultHost: host.	^ client</body><body package="SudokuViews">hostFile	^ 'sudokuserver.txt' asFilename</body><body package="SudokuViews">iniAccess	iniAccess isNil ifTrue: [ iniAccess := COAST.CoastIniAccess readFile: 'sudoku.ini' ].	^ iniAccess</body><body package="SudokuViews">notifyError: error 	self statusAspect value: error asString.</body><body package="SudokuViews">postBuildWith: aBuilder 	| win |	appsToClose := OrderedCollection new.	( win := aBuilder window ) notNil ifTrue: [ win icon: ( Icon new figure: LocalGameApp windowIcon shape: LocalGameApp windowIconMask )].	super postBuildWith: aBuilder.</body><body package="SudokuViews">recentHostAndPorts	| readStream recentHostAndPorts hostFile |	recentHostAndPorts := Set new.	hostFile := self hostFile.	hostFile definitelyExists ifFalse: [ ^ recentHostAndPorts ].	readStream := hostFile readStream.	[			[ readStream atEnd ] whileFalse: 			[ | string |				string := readStream upTo: Character cr.				string isEmpty ifFalse: [ recentHostAndPorts add: string ]			]	] ensure: [ readStream close ].	^ recentHostAndPorts</body></methods><methods><class-id>Sudoku.SudokuLoginApp</class-id> <category>actions</category><body package="SudokuViews">browseServers	| hostAndPorts server |	hostAndPorts := self recentHostAndPorts.	hostAndPorts isEmpty ifTrue: [ ^ self notifyError: #noKnownServers &gt;&gt; 'No known Servers' ].	server := self choose: 'Server' from: hostAndPorts.	server notNil ifTrue: [ self serverAspect value: server ].</body><body package="SudokuViews">browseTeams	| host error teams team volumes volume game |	host := self serverAspect value.	error := self checkHostVersion: host.	error notNil ifTrue: [ ^ self notifyError: error ].	self clientAt: host.	volumes := Cursor wait showWhile: [ client volumeManager volumesAtHost: host ].	volume := self volumeAspect value.	( volumes includes: volume ) ifFalse: [ ^ self notifyError: #invalidVolume &gt;&gt; 'Invalid Volume' ].	game := client volumeManager modelNamed: 'SUDOKU' inVolume: volume.	game isNil ifTrue: [ ^ self notifyError: #noGameAvailable &gt;&gt; 'No SUDOKU-Game specified' ].	teams := game childGames collect: [: e | e name ].	teams isEmpty ifTrue: [ ^ self notifyError: #noTeamAvailable &gt;&gt; 'No SUDOKU-Teams available' ].	team := self choose: 'Teams' from: teams.	team notNil ifTrue: [ self teamAspect value: team ].	self addRecentHostAndPort: host.</body><body package="SudokuViews">browseVolumes	| host error volumes volume |	host := self serverAspect value.	error := self checkHostVersion: self serverAspect value.	error notNil ifTrue: [ ^ self notifyError: error ].	volumes := Cursor wait showWhile: [ COAST.CoastClientVolumeManager volumesAtHost: host ].	volumes isEmpty ifTrue: [ ^ self notifyError: ( #noVolumesAvailable &gt;&gt; 'No volumes available' ) asString ].	volume := self choose: 'Volume' from: volumes.	volume notNil ifTrue: [ self volumeAspect value: volume ].</body><body package="SudokuViews">changeRequest	super changeRequest ifFalse: [ ^ false ].	client notNil ifTrue: 		[	client transactionManager transactionDo: [ appsToClose do: [: e | e close ]].			client release		].	^ true</body><body package="SudokuViews">connect	| host error volume team app user serverPassword statusResponse |	host := self serverAspect value.	error := self checkHostVersion: host.	error notNil 		ifTrue: [ ^ self notifyError: error ]		ifFalse: [ self iniAccess at: #host put: host ].	volume := self volumeAspect value.	volume isEmpty 		ifTrue: [ ^ self notifyError: #noVolumeSpecified &gt;&gt; 'No Volume specified' ]		ifFalse: [ self iniAccess at: #volume put: volume ].	team := self teamAspect value.	team isEmpty 		ifTrue: [ ^ self notifyError: #noTeamSpecified &gt;&gt; 'No Team specified' ]		ifFalse: [ self iniAccess at: #team put: team ].	self clientAt: host.	[	( client volumeManager availableVolumes includes: volume ) 			ifFalse: 			[	serverPassword := Dialog request: 'Mediator password to create a new volume:' initialAnswer: '' onCancel: [ nil ] for: self mainWindow.				serverPassword isNil 					ifTrue: [ ^ self ].				statusResponse := COAST.CoastMediatorStub createVolume: volume atHost: host remotePassword: serverPassword.				statusResponse ok 					ifFalse: [ COAST.CoastError raiseSignal: statusResponse message ]			].		client transactionManager transactionDo: 			[ | userName parentGame |				userName := CEnvironment getenv: 'USERNAME'.				parentGame := client volumeManager findOrCreate: GameApp named: 'SUDOKU' inVolume: volume.				parentGame ensureInitialGrid.				app := parentGame childGames 						detect: [: game | game name = team ]						ifNone: 						[	parentGame newChild name: team;								yourself						].				user := parentGame findOrCreateSudokuUserNamed: userName applicationClient: client.				user ensureLocalCopy.				user register.				app openFor: user.				appsToClose add: app			].		client transactionManager lastWishTransactionDo: [ app closeFor: user ].		self iniAccess writeFile.		self addRecentHostAndPort: host	] on: COAST.CoastError , OsError do: [: ex | Dialog warn: ex description for: self mainWindow ].</body><body package="SudokuViews">startLocal	self clientAt: nil.	client transactionManager transactionDo: 		[ | parentGame app user |			parentGame := GameApp newLocal.			parentGame ensureInitialGrid.			app := parentGame newChild.			app name: #local &gt;&gt; 'Local'.			user := COAST.CoastUser newLocal.			user ensureLocalCopy.			user register.			app openFor: user		].</body></methods><methods><class-id>Sudoku.SudokuLoginApp</class-id> <category>aspects</category><body package="SudokuViews">serverAspect	^ serverAspect isNil 		ifTrue: [ serverAspect := ( self iniAccess at: #host ifAbsent: [ String new ]) asValue ]		ifFalse: [ serverAspect ]</body><body package="SudokuViews">statusAspect	^ statusAspect isNil 		ifTrue: [ statusAspect := String new asValue ]		ifFalse: [ statusAspect ]</body><body package="SudokuViews">teamAspect	^ teamAspect isNil 		ifTrue: [ teamAspect := ( self iniAccess at: #team ifAbsent: [ String new ]) asValue ]		ifFalse: [ teamAspect ]</body><body package="SudokuViews">volumeAspect	^ volumeAspect isNil 		ifTrue: [ volumeAspect := ( self iniAccess at: #volume ifAbsent: [ String new ]) asValue ]		ifFalse: [ volumeAspect ]</body></methods><methods><class-id>Sudoku.FactoryDialog</class-id> <category>aspects</category><body package="SudokuViews">gridSizeAspect	^ self aspectsAt: #gridSize ifAbsentPut: [ String new asValue ]</body><body package="SudokuViews">heightAspect	^ self aspectsAt: #height ifAbsentPut: [ gridFactory dimension y asValue ]</body><body package="SudokuViews">levelAspect	^ self aspectsAt: #level ifAbsentPut: [ nil asValue ]</body><body package="SudokuViews">levelMenu	| menu |	menu := Menu new.	GridFactory defaultLevels do: [: level | menu addItem: (( MenuItem labeled: level displayString ) value: level )].	^ menu</body><body package="SudokuViews">widthAspect	^ self aspectsAt: #width ifAbsentPut: [ gridFactory dimension x asValue ]</body></methods><methods><class-id>Sudoku.FactoryDialog</class-id> <category>updating</category><body package="SudokuViews">preOpen	self updateGridSize.	^ super preOpen</body><body package="SudokuViews">updateGridSize	| stream int |	stream := String new writeStream.	gridFactory dimension: self widthAspect value @ self heightAspect value.	int := self widthAspect value * self heightAspect value.	int printOn: stream.	stream nextPutAll: ' x '.	int printOn: stream.	self gridSizeAspect value: stream contents.	self builder widgetAt: #accept do: [: w | w isEnabled: ( int &gt; 2 and: [ int &lt; 25 ])].</body><body package="SudokuViews">updateLevel	gridFactory level: self level.</body></methods><methods><class-id>Sudoku.FactoryDialog</class-id> <category>accessing</category><body package="SudokuViews">gridFactory: aFactory 	gridFactory := aFactory.	self level: aFactory level.</body><body package="SudokuViews">level	^ self levelAspect value</body><body package="SudokuViews">level: level 	self levelAspect value: level.	self widgetAt: #levelAspect do: [: widget | widget label: level displayString ].</body></methods><methods><class-id>Sudoku.FactoryDialog</class-id> <category>aspects - privat</category><body package="SudokuViews">aspectsAt: symbol ifAbsentPut: block 	aspects isNil ifTrue: [ aspects := Dictionary new ].	^ aspects at: symbol ifAbsentPut: block</body></methods><methods><class-id>Sudoku.FactoryDialog class</class-id> <category>instance creation</category><body package="SudokuViews">openOnGridFactory: gridFactory parentView: parent 	| dialog newFactory |	dialog := self new.	newFactory := gridFactory copy.	dialog parentView: parent.	dialog gridFactory: newFactory.	^ dialog open 		ifTrue: [ newFactory ]		ifFalse: [ nil ]</body></methods><methods><class-id>Sudoku.AbstractGridView</class-id> <category>accessing</category><body package="SudokuViews">basicComponents	| result dimension |	result := OrderedCollection new.	dimension := self dimension.	1 to: dimension y do: [: y | 1 to: dimension x do: [: x | result add: x @ y ]].	^ result</body><body package="SudokuViews">centerText	| size stream |	stream := String new writeStream.	"	stream nextPutAll: ( #sudokuProgress &gt;&gt; 'progress: ' ) asString."	self gameApp numberOfValues printOn: stream.	stream nextPutAll: ' / '.	size := self gameApp gridMaxValue.	size * size printOn: stream.	^ stream contents asText</body><body package="SudokuViews">coastGrid	^ self gameApp domainModel</body><body package="SudokuViews">computeReverseScramble	^ self scramble reverse</body><body package="SudokuViews">dimension	^ self at: #dimension</body><body package="SudokuViews">gameApp	^ self model</body><body package="SudokuViews">grid	^ self at: #grid</body><body package="SudokuViews">gridCandidates	^ self gameApp gridCandidates</body><body package="SudokuViews">gridExtent	| length |	length := self gridLength.	^ length @ length</body><body package="SudokuViews">gridLength	^ self at: #gridLength.</body><body package="SudokuViews">gridMaxValue	^ self gameApp gridMaxValue</body><body package="SudokuViews">infoTextSize	| b |	b := self outerBounds.	^ b isNil 		ifTrue: [ ^ 10 ]		ifFalse: [( self textRatio * b height / 5 ) floor * 6 ]</body><body package="SudokuViews">isInitial: position 	| reverseScramble |	reverseScramble := self reverseScramble.	^ self gameApp isInitial: ( reverseScramble scramblePos: position )</body><body package="SudokuViews">leftText	| stream |	stream := String new writeStream.	stream nextPutAll: self gameApp name.	self gameApp isLocal ifFalse: 		[	stream nextPutAll: ' ('.			self gameApp interestedUsers size printOn: stream.			stream nextPutAll: ')'		].	^ stream contents</body><body package="SudokuViews">parentGame	^ self gameApp parentGame</body><body package="SudokuViews">reverseScramble	^ self at: #reverseScramble</body><body package="SudokuViews">rightText	| stream |	stream := String new writeStream.	stream nextPutAll: ( #sudokuScore &gt;&gt; 'score ' ) asString.	self gameApp score printOn: stream.	^ stream contents asText</body><body package="SudokuViews">scramble	^ self at: #scramble</body><body package="SudokuViews">style	^ self styleAt: self gridLength * 9 // 10</body><body package="SudokuViews">styleAt: pixelSize 	^ fontDict at: pixelSize ifAbsentPut: [ SudokuIconLibrary styleAt: pixelSize ]</body><body package="SudokuViews">textRatio	^ 1 / 20</body><body package="SudokuViews">viewClassFor: aModel 	self subclassResponsibility.</body></methods><methods><class-id>Sudoku.AbstractGridView</class-id> <category>computing</category><body package="SudokuViews">computeDimension	| p domainModel |	domainModel := self gameApp.	p := domainModel width * domainModel height.	^ p @ p</body><body package="SudokuViews">computeGrid	^ self scramble scrambleGrid: self coastGrid grid</body><body package="SudokuViews">computeGridLength	| maxBounds dimension bounds |	dimension := self dimension.	bounds := self outerBounds.	^ bounds notNil 		ifTrue: 		[	maxBounds := bounds extent // dimension.			( maxBounds x min: maxBounds y ) rounded		]		ifFalse: [ ^ 1 ]</body><body package="SudokuViews">computeScramble	| seed random |	seed := self transactionManager localUser scrambleSeed.	^ seed = 0 		ifTrue: [ Scramble unionWidth: self parentGame width height: self parentGame height ]		ifFalse: 		[	random := Random new.			random seed: seed.			Scramble newWidth: self parentGame width height: self parentGame height random: random		].</body></methods><methods><class-id>Sudoku.AbstractGridView</class-id> <category>private-components</category><body package="SudokuViews">backgroundColor	"Answer the receiver's background color."	^ColorValue white.</body></methods><methods><class-id>Sudoku.AbstractGridView</class-id> <category>initialize-release</category><body package="SudokuViews">initialize	super initialize.	fontDict := Dictionary new.	oldComponentDictionary := Dictionary new.</body></methods><methods><class-id>Sudoku.AbstractGridView</class-id> <category>displaying</category><body package="SudokuViews">composeDisplayOn: aGraphicsContext 	super composeDisplayOn: aGraphicsContext.	self displayBoxBoundsOn: aGraphicsContext.	self displayInfoTextOn: aGraphicsContext.</body><body package="SudokuViews">displayBoxBoundsOn: aGraphicsContext 	self displayBoxBoundsOn: aGraphicsContext width: self maxOffset.</body><body package="SudokuViews">displayBoxBoundsOn: aGraphicsContext width: maxOffset 	| width height origin |	width := self grid width.	height := self grid height.	origin := self bounds origin.	maxOffset negated to: maxOffset		do: 		[: offset | | grid |			grid := self gridLength * width.			0 to: height - 0				do: 				[: i |					aGraphicsContext displayLineFrom: origin + (( i * grid + offset ) @ 0 ) to: origin + (( i * grid + offset ) @ ( height * grid ))				].			grid := self gridLength * height.			0 to: width - 0				do: [: i | aGraphicsContext displayLineFrom: origin + ( 0 @ ( i * grid + offset )) to: origin + (( width * grid ) @ ( i * grid + offset ))]		].</body><body package="SudokuViews">displayInfoTextOn: aGraphicsContext 	| bounds pos text height style infoTextSize |	infoTextSize := self infoTextSize.	( self components notEmpty and: [ infoTextSize &gt; 1 ]) ifTrue: 		[	style := self styleAt: infoTextSize.			bounds := self transactionManager withoutDependenciesDo: [ self components first bounds origin corner: self components last bounds corner ].			text := ComposedText withText: self centerText style: style.			height := text sudokuHeightFor: bounds bottom.			pos := ( bounds center x - ( text width / 2 )) rounded @ height.			text displayOn: aGraphicsContext at: pos.			text := ComposedText withText: self leftText style: style.			pos := ( bounds left + 3 ) @ height.			text displayOn: aGraphicsContext at: pos.			text := ComposedText withText: self rightText style: style.			pos := ( bounds right - text width - 3 ) @ height.			text displayOn: aGraphicsContext at: pos		].</body><body package="SudokuViews">maxOffset	self subclassResponsibility.</body></methods><methods><class-id>Sudoku.AbstractGridView</class-id> <category>bounds changing</category><body package="SudokuViews">outerBoundsFor: bounds 	| dimension textHeight x y |	dimension := self dimension.	x := bounds width // dimension x * dimension x.	textHeight := ( x * self textRatio / ( 1 - self textRatio )) floor.	y := x + textHeight.	y &lt;= bounds height ifFalse: 		[	textHeight := ( bounds height * self textRatio ) floor.			x := ( bounds height - textHeight ) // dimension x * dimension x.			y := x + textHeight		].	^ 0 @ 0 extent: x @ y</body></methods><methods><class-id>Sudoku.AbstractGridView class</class-id> <category>slots</category><body package="SudokuViews">dimensionSlot	^ self slotComputedBy: #computeDimension</body><body package="SudokuViews">gridLengthSlot	^ self slotComputedBy: #computeGridLength</body><body package="SudokuViews">gridSlot	^ self slotComputedBy: #computeGrid</body><body package="SudokuViews">reverseScrambleSlot	^ self slotComputedBy: #computeReverseScramble</body><body package="SudokuViews">scrambleSlot	^ self slotComputedBy: #computeScramble</body></methods><methods><class-id>Sudoku.CellView</class-id> <category>accessing</category><body package="SudokuViews">addKeyboardConsumersTo: aKeyboardProcessor 	( aKeyboardProcessor keyboardConsumers includes: self ) ifFalse: [ aKeyboardProcessor sendKeyboardTo: self ].</body><body package="SudokuViews">canBeModified	| parentGame |	parentGame := self parentGame.	^ parentGame winner isNil and: [ parentGame name = 'User Defined' or: [ self isInitial not ]]</body><body package="SudokuViews">candidates	^ ( self at: #candidates ) ifNil: [ #( )]</body><body package="SudokuViews">defaultControllerClass	^ CellController</body><body package="SudokuViews">defaultGivenValue	| candidate adornment |	candidate := self candidates singleElementOrNil.	candidate isNil ifTrue: 		[	adornment := self adornment.			adornment notNil ifTrue: [ candidate := adornment defaultGivenValue ].			candidate isNil ifTrue: 				[	candidate := self gridView highlightedValue.					( candidate notNil and: [ self candidates includes: candidate ]) ifFalse: [ candidate := nil ]				]		].	^ candidate</body><body package="SudokuViews">defaultRemoveValue	| candidate adornment |	self givenNumber notNil ifTrue: [ ^ nil ].	adornment := self adornment.	adornment notNil ifTrue: [ candidate := adornment defaultRemoveValue ].	candidate isNil ifTrue: 		[	candidate := self gridView highlightedValue.			( self candidates includes: candidate ) ifFalse: [ candidate := nil ]		].	^ candidate</body><body package="SudokuViews">givenNumber: candidate 	container ifNotNil: 		[: c | ( candidate isNil or: [ candidate &gt; 0 ]) 				ifTrue: [ c placedCandidate: candidate position: self ]				ifFalse: [ c toggleCandidate: candidate negated position: self ]		].</body><body package="SudokuViews">gridCandidates	^ self gridView gridCandidates</body><body package="SudokuViews">gridMaxValue	^ self gridView gridMaxValue</body><body package="SudokuViews">isHighlightedCell	| highlightedValues givenNumber |	highlightedValues := self gridView highlightedValues.	^ highlightedValues notEmpty and: 		[	givenNumber := self givenNumber.			givenNumber notNil 				ifTrue: [ highlightedValues singleElementOrNil = givenNumber ]				ifFalse: 				[	self parentGame highlightFreeCells and: 						[ | candidates |							candidates := self candidates.							candidates size &lt; self gridMaxValue and: 								[	highlightedValues allSatisfy: 										[: candidate |											candidate = #xy 												ifTrue: [ candidates size = 2 ]												ifFalse: [ candidates includes: candidate ]										]								]						]				]		]</body><body package="SudokuViews">isSelectedCell	^ self at: #isSelectedCell</body><body package="SudokuViews">isSelectedCell: isSelectedCell 	self at: #isSelectedCell set: isSelectedCell.</body><body package="SudokuViews">keyboardProcessor	^ container notNil 		ifTrue: [ container keyboardProcessor ]		ifFalse: [ nil ]</body><body package="SudokuViews">resetCandidates	| candidates |	candidates := self candidates.	self gridCandidates do: [: c | ( candidates includes: c ) ifFalse: [ container toggleCandidate: c position: self ]].</body><body package="SudokuViews">selectedComponents	^ self isSelectedCell 		ifTrue: [ Array with: self ]		ifFalse: [ super selectedComponents ]</body><body package="SudokuViews">showMarks	^ self parentGame showMarks or: [ self adornment notNil ]</body></methods><methods><class-id>Sudoku.CellView</class-id> <category>colors - accessing</category><body package="SudokuViews">frameColor	^ self at: #frameColor</body><body package="SudokuViews">frameColor: color 	| oldColor |	oldColor := self fastAt: #frameColor.	oldColor = color ifFalse: [ self at: #frameColor set: color ].</body></methods><methods><class-id>Sudoku.CellView</class-id> <category>displaying</category><body package="SudokuViews">composeBackgroundOn: aGraphicsContext bounds: bounds 	| info size gc |	super composeBackgroundOn: aGraphicsContext bounds: bounds.	info := self chainBackgroundInfoString.	info notNil ifTrue: 		[	gc := aGraphicsContext copy.			gc paint: ( self backgroundColor blendWith: ( ColorValue brightness: self backgroundColor brightness * 0.75 )).			size := info size = 1 					ifTrue: [ container gridLength * 9 // 10 ]					ifFalse: [ container gridLength * 65 // 100 ].			( ComposedText withText: info asText style: ( container styleAt: size )) sudokuDisplayOn: gc center: bounds center		].</body><body package="SudokuViews">composeDisplayCandidatesOn: aGraphicsContext 	| bounds dimension candidates candidate gcc size cellCenter markSize stepSize dimensionCenter adornment |	candidates := self candidates.	adornment := self adornment.	( candidates size = self gridMaxValue and: [ adornment isNil ]) ifTrue: [ ^ self ].	bounds := self bounds insetBy: 2.	cellCenter := bounds center.	dimension := self grid width @ self grid height.	dimensionCenter := ( dimension + ( 1 @ 1 )) / 2.	stepSize := ( dimension x / ( dimension x + 1 )) @ ( dimension y / ( dimension y + 1 )).	markSize := ( bounds extent - ( 3 @ 3 )) / ( dimension - (( 1 / 2 ) @ ( 1 / 2 ))).	gcc := aGraphicsContext copy.	candidate := 0.	size := dimension x * dimension y &gt; 9 			ifTrue: [(( markSize x min: markSize y ) * 3 / 4 ) floor ]			ifFalse: [( markSize x min: markSize y ) floor ].	size := self bounds height // ( dimension x max: dimension y ).	size &lt; 1 ifTrue: [ ^ self ].	gcc paint: ( self localUser sudokuColorAt: #candidate ).	1 to: dimension y		do: 		[: y |			1 to: dimension x				do: 				[: x | | center |					candidate := candidate + 1.					( candidates includes: candidate ) ifTrue: 						[	center := cellCenter - (( dimensionCenter - ( x @ y )) * stepSize * markSize ) floor.							self displayHighlightedCandidate: candidate at: center textSize: size on: gcc adornment: adornment						]				]		].</body><body package="SudokuViews">composeDisplayOn: aGraphicsContext 	| given |	given := super composeDisplayOn: aGraphicsContext.	given isNil ifTrue: [ self showMarks ifTrue: [ self composeDisplayCandidatesOn: aGraphicsContext ]].	^ given</body><body package="SudokuViews">composeDisplayValue: int on: gcc center: center 	self isInitial ifFalse: [ gcc paint: ( self localUser sudokuColorAt: #editCell )].	super composeDisplayValue: int on: gcc center: center.</body><body package="SudokuViews">displayHighlightedCandidate: candidate at: center textSize: size on: gc adornment: adornment 	| string style composedText origin delta colorSymbol |	string := size &gt; 9 			ifTrue: [ candidate displayString ]			ifFalse: [ '#' ].	style := container styleAt: size - 1.	composedText := ComposedText withText: string asText style: style.	colorSymbol := adornment notNil 			ifTrue: [ adornment colorAt: candidate ]			ifFalse: [ nil ].	colorSymbol notNil 		ifTrue: 		[ | gcc |			gcc := gc copy.			gcc paint: ( self localUser sudokuColorAt: colorSymbol ).			origin := ( center x - ( composedText width / 2 )) @ (( composedText sudokuHeightFor: center y ) - ( composedText height / 2 )).			delta := 0 @ ( 2 * ( center y - ( composedText height / 2 ) - origin y )) ceiling.			(( origin + delta extent: composedText width @ composedText height - delta ) insetBy: -1 ) displayFilledOn: gcc.			gcc paint: ( self localUser sudokuColorAt: #background1 ).			composedText sudokuDisplayOn: gcc center: center		]		ifFalse: [ composedText sudokuDisplayOn: gc center: center ].</body></methods><methods><class-id>Sudoku.CellView</class-id> <category>computing</category><body package="SudokuViews">computeCellProperties	| cell candidates |	cell := super computeCellProperties.	cell notNil ifTrue: 		[	cell hasCandidates not 				ifTrue: [( self fastAt: #givenNumber ) = cell givenOrNil ifFalse: [ self at: #givenNumber set: cell givenOrNil ]]				ifFalse: 				[	candidates := cell candidates.					( self fastAt: #givenNumber ) notNil ifTrue: [ self at: #givenNumber set: nil ].					( self fastAt: #candidates ) = candidates ifFalse: [ self at: #candidates set: candidates ]				]		].	^ cell</body><body package="SudokuViews">computePreferredBounds	self givenNumber isNil ifTrue: [ self showMarks ifTrue: [ self candidates ]].	self frameColor.	self adornment.	^ super computePreferredBounds</body></methods><methods><class-id>Sudoku.CellView</class-id> <category>colors - computing</category><body package="SudokuViews">computeBackgroundColor	^ self isHighlightedCell 		ifTrue: [ self localUser sudokuColorAt: #highlightedCell ]		ifFalse: 		[(( self model x - 1 ) // self grid width ) odd = (( self model y - 1 ) // self grid height ) odd 				ifTrue: [ self localUser sudokuColorAt: #background1 ]				ifFalse: [ self localUser sudokuColorAt: #background2 ]		]</body><body package="SudokuViews">computeBackgroundTargetColor	super computeBackgroundTargetColor.	self frameColor: self computeFrameColor.</body><body package="SudokuViews">computeFrameColor	"derzeit aus den tips ausgelesen"	^ self isSelectedCell 		ifTrue: [ self localUser sudokuColorAt: #selectedCell ]		ifFalse: [ nil ]</body></methods><methods><class-id>Sudoku.CellView</class-id> <category>adornment</category><body package="SudokuViews">adornment	^self at: #adornment</body><body package="SudokuViews">chainBackgroundInfoString	| adornment |	adornment := self adornment.	^ adornment notNil 		ifTrue: [ adornment background ]		ifFalse: [ nil ]</body><body package="SudokuViews">computeAdornment	| adornment |	adornment := self gridView adornment.	^ adornment notNil 		ifTrue: [ adornment bestAdornmentAt: self model ]		ifFalse: [ nil ]</body></methods><methods><class-id>Sudoku.CellView class</class-id> <category>slots</category><body package="SudokuViews">adornmentSlot	^ self slotComputedBy: #computeAdornment</body><body package="SudokuViews">candidatesSlot	^ self slotSingleValue</body><body package="SudokuViews">frameColorSlot	^ self slotSingleValue</body><body package="SudokuViews">isSelectedCellSlot	^ ( self slotSingleValue )		defaultValue: false;		yourself</body></methods><methods><class-id>Sudoku.RadarCellView</class-id> <category>accessing</category><body package="SudokuViews">defaultControllerClass	^ NoController</body><body package="SudokuViews">frameColor	^ nil</body><body package="SudokuViews">homeGameApp	^ self gridView homeGameApp</body></methods><methods><class-id>Sudoku.RadarCellView</class-id> <category>computing</category><body package="SudokuViews">computeCellProperties	| cell givenNumber |	cell := super computeCellProperties.	cell notNil ifTrue: 		[	givenNumber := cell hasCandidates 					ifTrue: [ nil ]					ifFalse: 					[( self isInitial or: [ self parentGame winner notNil ]) 							ifTrue: [ cell givenOrNil ]							ifFalse: [ '?' ]					].			( self fastAt: #givenNumber ) = givenNumber ifFalse: [ self at: #givenNumber set: givenNumber ]		].	^ cell</body><body package="SudokuViews">computePreferredBounds	| bounds |	bounds := super computePreferredBounds.	^ container bounds origin + bounds origin extent: bounds extent</body></methods><methods><class-id>Sudoku.RadarCellView</class-id> <category>colors - computing</category><body package="SudokuViews">computeBackgroundColor	| givenNumber |	self isInitial ifFalse: 		[	givenNumber := self givenNumber.			( givenNumber notNil and: [( self homeGameApp givenAtX: self x y: self y ) isNil ]) ifTrue: [ ^ self localUser sudokuColorAt: #enemyCell ].			( givenNumber isNil and: [( self homeGameApp givenAtX: self x y: self y ) notNil ]) ifTrue: [ ^ self localUser sudokuColorAt: #aheadCell ]		].	^ self localUser sudokuColorAt: #initialCell</body></methods><methods><class-id>Sudoku.RadarView</class-id> <category>accessing</category><body package="SudokuViews">basicComponents	| childGames |	childGames := self gameApp opponentApps.	^ childGames asSortedCollection: 		[: g1 : g2 |			g1 numberOfValues = g2 numberOfValues 				ifTrue: [ g1 name &lt; g2 name ]				ifFalse: [ g1 numberOfValues &gt; g2 numberOfValues ]		]</body><body package="SudokuViews">changedComponents	self bounds: self bounds.</body><body package="SudokuViews">gameApp	^ self model</body><body package="SudokuViews">handlerForMouseEvent: event 	^ event isMouseWheelEvent 		ifTrue: [ nil ]		ifFalse: [ super handlerForMouseEvent: event ]</body><body package="SudokuViews">parentGame	^ self gameApp parentGame</body><body package="SudokuViews">spaceBetween	^ 10</body><body package="SudokuViews">viewClassFor: gameApp 	^ RadarGridView</body></methods><methods><class-id>Sudoku.RadarView</class-id> <category>bounds changing</category><body package="SudokuViews">bounds: newBounds 	| outerBounds |	super bounds: newBounds.	outerBounds := self outerBounds.	self components do: [: view | view bounds: outerBounds ].</body><body package="SudokuViews">outerBoundsFor: bounds 	| components firstBounds |	components := self transactionManager bestDisplayDo: [ self components ].	^ components size = 0 		ifTrue: [ bounds ]		ifFalse: 		[	firstBounds := bounds origin extent: bounds width @ ( bounds width * 2 ).			firstBounds := components first outerBoundsFor: firstBounds.			0 @ 0 extent: firstBounds width @ (( firstBounds height + self spaceBetween ) * components size )		]</body></methods><methods><class-id>Sudoku.GridView</class-id> <category>accessing</category><body package="SudokuViews">basicComponents	self depleteSlot: #highlightedCandidates.	^ super basicComponents</body><body package="SudokuViews">defaultControllerClass	^ GridController</body><body package="SudokuViews">handlerForMouseEvent: event 	^ event isMouseWheelEvent 		ifTrue: [ self ]		ifFalse: [ super handlerForMouseEvent: event ]</body><body package="SudokuViews">highlightFreeCells	^ self parentGame highlightFreeCells</body><body package="SudokuViews">highlightedValue	| highlightedValue |	highlightedValue := self highlightedValues singleElementOrNil.	^ highlightedValue isInteger 		ifTrue: [ highlightedValue ]		ifFalse: [ nil ]</body><body package="SudokuViews">highlightedValues	^ self at: #highlightedCandidates</body><body package="SudokuViews">keyboardProcessor	^ super keyboardProcessor</body><body package="SudokuViews">maxOffset	^ 1</body><body package="SudokuViews">viewClassFor: aModel 	^ CellView</body></methods><methods><class-id>Sudoku.GridView</class-id> <category>grid adronment</category><body package="SudokuViews">adornment	^ self at: #adornment</body><body package="SudokuViews">adornment: adornment 	self at: #adornment set: adornment.</body><body package="SudokuViews">currentHintString	| winner |	winner := self parentGame winner.	^ winner notNil 		ifTrue: 		[ | message |			message := winner = self gameApp 					ifTrue: [ #sudokuYouWin &gt;&gt; 'You did win!' ]					ifFalse: [ #sudokuYouLost &gt;&gt; 'You lost!' ].			message asString		]		ifFalse: 		[ | adronment |			adronment := self adornment.			adronment notNil 				ifTrue: [ adronment string ]				ifFalse: [ '' ]		]</body><body package="SudokuViews">previousAdornment	| adornment |	adornment := self adornment.	^ adornment notNil 		ifTrue: [ adornment previousAdornment ]		ifFalse: [ nil ]</body><body package="SudokuViews">resetAdornment	self depleteSlot: #adornment.</body></methods><methods><class-id>Sudoku.GridView</class-id> <category>actions</category><body package="SudokuViews">activateAt: point 	| view |	view := self viewAt: point.	view notNil 		ifTrue: [ view controller handleFocusEvent ].</body><body package="SudokuViews">highlight: candidate includes: included 	( candidate = self highlightedValues singleElementOrNil or: [ InputState default shiftDown ]) 		ifTrue: 		[	included 				ifTrue: [ self at: #highlightedCandidates add: candidate ]				ifFalse: [ self at: #highlightedCandidates remove: candidate ]		]		ifFalse: 		[	self depleteSlot: #highlightedCandidates.			self at: #highlightedCandidates add: candidate		].</body><body package="SudokuViews">placedCandidate: candidate position: position 	| reverseScramble pos |	reverseScramble := self reverseScramble.	pos := reverseScramble scramblePos: position.	self gameApp atPos: pos given: ( reverseScramble scrambleGiven: candidate ).</body><body package="SudokuViews">purgeHighlightedValues	self depleteSlot: #highlightedCandidates.</body><body package="SudokuViews">toggleCandidate: candidate position: position 	| reverseScramble |	reverseScramble := self reverseScramble.	self gameApp toggleAtPos: ( reverseScramble scramblePos: position ) candidate: ( reverseScramble scrambleGiven: candidate ).</body><body package="SudokuViews">viewAt: point 	^ oldComponentDictionary at: point ifAbsent: nil</body></methods><methods><class-id>Sudoku.GridView</class-id> <category>computing</category><body package="SudokuViews">computeGrid	| grid |	self resetAdornment.	grid := super computeGrid copy.	self parentGame autoHideSakes ifTrue: [ CoverdByNeighbours modifyGrid: grid ].	^ grid</body></methods><methods><class-id>Sudoku.GridView</class-id> <category>deprecated</category><body package="SudokuViews">addKeyboardConsumersTo: aKeyboardProcessor 	( aKeyboardProcessor keyboardConsumers includes: self ) ifFalse: [ aKeyboardProcessor sendKeyboardTo: self ].</body></methods><methods><class-id>Sudoku.GridView class</class-id> <category>slots</category><body package="SudokuViews">adornmentSlot	^ self slotSingleValue</body><body package="SudokuViews">highlightedCandidatesSlot	^ self slotOfType: #set</body><body package="SudokuViews">selectedCellsSlot	^ self slotOfType: #set</body></methods><methods><class-id>Sudoku.RadarGridView</class-id> <category>accessing</category><body package="SudokuViews">computePreferredBounds	| bounds index |	bounds := super computePreferredBounds.	index := self container components indexOf: self.	bounds := bounds copy.	bounds moveBy: 0 @ (( bounds height + self container spaceBetween ) * ( index - 1 )).	^ bounds</body><body package="SudokuViews">displayBoxBoundsOn: aGraphicsContext 	| gc |	gc := aGraphicsContext copy.	gc paint: ColorValue lightGray.	^ super displayBoxBoundsOn: gc</body><body package="SudokuViews">homeGameApp	^ self container model</body><body package="SudokuViews">maxOffset	^ 0</body><body package="SudokuViews">viewClassFor: aModel 	^ RadarCellView</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="SudokuViews">sudokuMergeColor: aColorValue 	^ self blendWith: aColorValue</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>enhanced displaying</category><body package="SudokuViews">sudokuDisplayDashedLineFrom: startPoint to: endPoint 	"Display a line between startPoint and endPoint.	Use the current line width, cap style, join style, and paint."	| delta point totalr |	delta := endPoint - startPoint.	totalr := delta r.	totalr = 0 ifTrue: [ ^ 0 ].	delta := 8 * delta / totalr.	point := startPoint + ( delta / 2 ).	[( point - startPoint ) r &lt; totalr ] whileTrue: 		[	( point + delta - startPoint ) r &lt; totalr 				ifTrue: [ self displayLineFrom: point to: point + delta ]				ifFalse: [ self displayLineFrom: point to: endPoint ].			point := point + ( delta * 2 )		].</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>accessing</category><body package="SudokuViews">sudokuMergeColor: color 	^ color</body></methods><methods><class-id>COAST.CoastUser class</class-id> <category>slots</category><body package="SudokuViews">scrambleSeedSlot	^ self slotSingleValue</body><body package="SudokuViews">sudokuColorDictSlot	^ self slotOfType: #dictionary</body><body package="SudokuViews">sudokuDefaultDict	DefaultColors isNil ifTrue: 		[ | dict |			dict := Dictionary new.			"radar colors"			dict at: #enemyCell put: ( ColorValue red: 16rFF green: 16r80 blue: 16r80 range: 255 ).			dict at: #aheadCell put: ColorValue paleGreen.			"colors for cell background"			dict at: #highlightedCell put: ( ColorValue red: 2 green: 3 blue: 2 range: 3 ).			dict at: #initialCell put: ColorValue veryLightGray.			dict at: #background1 put: ColorValue white.			dict at: #background2 put: ( ColorValue brightness: 61 / 64 ).			"font colors"			dict at: #editCell put: ColorValue royalBlue.			dict at: #candidate put: ColorValue darkGreen.			"frame colors"			dict at: #selectedCell put: ( ColorValue red: 0.0 green: 0.2 blue: 0.6 ).			"candidate colors"			dict at: #setCandidate put: ColorValue green.			dict at: #removeCandidate put: ColorValue red.			dict at: #badCandidate put: ColorValue red.			dict at: #modifyingSake1 put: ColorValue navy.			dict at: #modifyingSake2 put: ColorValue orange.			dict at: #modifyingSake3 put: ColorValue yellow.			DefaultColors := dict		].	^ DefaultColors</body></methods><methods><class-id>COAST.CoastUser</class-id> <category>accessing</category><body package="SudokuViews">scrambleSeed	^ ( self at: #scrambleSeed ) ifNil: [ self hash ]</body><body package="SudokuViews">scrambleSeed: scrambleSeed	self at: #scrambleSeed set: scrambleSeed.</body><body package="SudokuViews">sudokuColorAt: key 	^ self at: #sudokuColorDict atKey: key ifAbsent: [ self class sudokuDefaultDict atKey: key ifAbsent: [ ColorValue gray ]]</body></methods><methods><class-id>UI.Menu class</class-id> <category>instance creation</category><body package="SudokuViews">sudokuChoose: title from: objects window: window 	| menu labelItem menuItem |	menu := self new.	labelItem := MenuItem labeled: title.	labelItem value: 0.	labelItem labelText: ( title asText emphasizeAllWith: ( Array with: #bold with: #color -&gt; ColorValue darkGray )).	menu addItem: labelItem.	menu addLine.	objects do: 		[: object | | string |			string := object displayString.			labelItem := MenuItem labeled: string.			labelItem labelText: string asText.			labelItem value: object.			menu addItem: labelItem		].	menuItem := ( window widgetPolicy menuViewForMenu: menu ) openFromView: window.	^ menuItem = 0 		ifTrue: [ nil ]		ifFalse: [ menuItem value ]</body></methods><methods><class-id>Graphics.ComposedText</class-id> <category>displaying</category><body package="SudokuViews">sudokuDisplayOn: gcc center: center 	| origin |	origin := ( center x - ( self width / 2 )) @ (( self sudokuHeightFor: center y ) - ( self height / 2 )).	"( Notifier isDevelopment and: [ InputState default shiftDown ]) ifTrue: 		[ | delta |			delta := 0 @ ( 2 * ( center y - ( self height // 2 ) - origin y )).			( origin + delta extent: self width @ self height - delta ) displayStrokedOn: gcc		]."	"display text bounds"	self displayOn: gcc at: origin rounded.</body><body package="SudokuViews">sudokuHeightFor: height 	| deltaY |	deltaY := self height / 6.	^ height - deltaY</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>displaying</category><body package="SudokuViews">sudokuDisplayDashedStrokedOn: aGraphicsContext width: width 	| x1 x2 y1 y2 |	x1 := self left.	x2 := self right.	y1 := self top.	y2 := self bottom.	0 to: width - 1		do: 		[: d |			aGraphicsContext sudokuDisplayDashedLineFrom: x1 @ ( y1 + d ) to: x2 @ ( y1 + d ).			aGraphicsContext sudokuDisplayDashedLineFrom: ( x2 - d ) @ y1 to: ( x2 - d ) @ y2.			aGraphicsContext sudokuDisplayDashedLineFrom: x2 @ ( y2 - d ) to: x1 @ ( y2 - d ).			aGraphicsContext sudokuDisplayDashedLineFrom: ( x1 + d ) @ y2 to: ( x1 + d ) @ y1		].</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>CoastLocalApplicationModel</name><environment>COAST</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sharedApplicationModel viewState localUser coastDialog closedLocally </inst-vars><class-inst-vars>viewStatePrototype </class-inst-vars><imports></imports><category>COASTUserInterface-UIApplicationModel</category><attributes><package>COASTViews</package></attributes></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ComposedText</name><environment>Graphics</environment><super>Graphics.TextLines</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text compositionWidth compositionHeight wordWrap fontPolicy lineTable fitWidth </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Graphics-Text Support</category><attributes><package>Graphics-Text Support</package></attributes></class><class><name>ToolbarIconLibrary</name><environment>Tools</environment><super>Tools.IconLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Resources</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>CoastUser</name><environment>COAST</environment><super>COAST.CoastModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>localCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>GraphicsContext</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>medium clipOriginX clipOriginY clipWidth clipHeight lineWidth capStyle joinStyle deviceFont devicePaint offsetX offsetY phaseX phaseY scaleX scaleY font paint paintPolicy fontPolicy clientData paintPreferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>CoastApplicationModel</name><environment>COAST</environment><super>COAST.CoastModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTClient</category><attributes><package>COASTClient</package></attributes></class><class><name>CoastView</name><environment>COAST</environment><super>COAST.CoastDependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class><class><name>CoastCompositeView</name><environment>COAST</environment><super>COAST.CoastView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldComponentDictionary subViewClassComputingBlock keyboardProcessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COASTUserInterface-UIViews</category><attributes><package>COASTViews</package></attributes></class></st-source>