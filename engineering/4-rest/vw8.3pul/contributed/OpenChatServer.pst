<?xml version="1.0"?><st-source><!-- Name: OpenChatServerComment: This is OpenChat chat server package. OpenChatServer is mediating the communication of OpenChat chat clients. Starting a Server:A server can be started from the Tools menu or by evaluating:	(OpenChatServer on: <aChatServerPortNumber>) openChat server host name and port number is needed when starting chat clients.Server UI:Left list pane shows parties connected to the server. Right list pane shows sessions in progress. Session items indicate the topic and the list of participants.Stopping a Server:To shut down a server, simply close the server window. All parties will be notified and disconnected.DbIdentifier: bear73DbTrace: 54787DevelopmentPrerequisites: #(#(#any 'Opentalk-STST' ''))PackageName: OpenChatServerParcel: #('OpenChatServer')PrerequisiteParcels: #(#('Opentalk-STST' ''))PrintStringCache: (11,mkobetic)Version: 11Date: 11:14:01 AM October 21, 2009 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7 (oct09.4) of October 21, 2009 on October 21, 2009 at 11:14:01 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OpenChatSession</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>topic server parties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OpenChatServer</category><attributes><package>OpenChatServer</package></attributes></class><comment><class-id>OpenChatSession</class-id><body></body></comment><class><name>OpenChatServer</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>broker parties partyList sessionList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OpenChatServer</category><attributes><package>OpenChatServer</package></attributes></class><comment><class-id>OpenChatServer</class-id><body></body></comment><shared-variable><name>Log</name><environment>OpenChatServer</environment><private>false</private><constant>false</constant><category>private</category><attributes><package>OpenChatServer</package></attributes></shared-variable><shared-variable><name>LogMessages</name><environment>OpenChatServer</environment><private>false</private><constant>false</constant><category>private</category><attributes><package>OpenChatServer</package></attributes></shared-variable><methods><class-id>OpenChatSession</class-id> <category>messages</category><body package="OpenChatServer" selector="addMessage:from:">addMessage: aString from: aPartyId	parties do: [ :p | p displayMessage: aString from: aPartyId ]</body></methods><methods><class-id>OpenChatSession</class-id> <category>initialization</category><body package="OpenChatServer" selector="initializeFor:and:on:about:">initializeFor: initiatingParty and: otherParty on: aServer about: aTopic	topic := aTopic.	server := aServer.	parties := Dictionary new		at: initiatingParty id put: initiatingParty;		at: otherParty id put: otherParty;		yourself</body></methods><methods><class-id>OpenChatSession</class-id> <category>parties</category><body package="OpenChatServer" selector="joining:">joining: aParty	| id |	id := aParty id.	parties at: id put: aParty.	parties do: [ :p |		p displayMessage: id, ' has joined the session !' from: nil ]</body><body package="OpenChatServer" selector="leaving:">leaving: aPartyId	parties removeKey: aPartyId.	parties isEmpty		ifTrue: [ server removeSession: self ]		ifFalse: [ parties do: [ :p |			p displayMessage: aPartyId, ' has left the session !' from: nil ] ]</body></methods><methods><class-id>OpenChatSession</class-id> <category>accessing</category><body package="OpenChatServer" selector="topic">topic	^topic</body></methods><methods><class-id>OpenChatSession</class-id> <category>printing</category><body package="OpenChatServer" selector="printOn:">printOn: aStream	aStream		nextPutAll: topic;		nextPut: $(.	parties keys inject: 1 into: [ :c :p |		aStream nextPutAll: p.		c &lt; parties size ifTrue: [ aStream nextPut: $, ].		c + 1].	aStream nextPut: $)</body></methods><methods><class-id>OpenChatSession class</class-id> <category>instance creation</category><body package="OpenChatServer" selector="for:and:on:about:">for: initiatingParty and: otherParty on: aChatServer about: aTopic	^self new initializeFor: initiatingParty and: otherParty on: aChatServer about: aTopic</body></methods><methods><class-id>OpenChatServer</class-id> <category>parties</category><body package="OpenChatServer" selector="addParty:">addParty: aClient	parties at: aClient id put: aClient.	self partyList list: parties keys asList.	parties do: [ :p | p partyList: parties keys asPassedByValue ]</body><body package="OpenChatServer" selector="removeParty:">removeParty: aClient	parties removeKey: aClient id.	self partyList list: parties keys asList.	parties do: [ :p | p partyList: parties keys asPassedByValue ]</body></methods><methods><class-id>OpenChatServer</class-id> <category>aspects</category><body package="OpenChatServer" selector="labelFor:">labelFor: aKey	^aKey = #windowLabel		ifTrue: [self windowLabel]		ifFalse: [super labelFor: aKey]</body><body package="OpenChatServer" selector="partyList">partyList	partyList isNil ifTrue: [partyList := SelectionInList with: parties keys asList].	^partyList</body><body package="OpenChatServer" selector="sessionList">sessionList	sessionList isNil ifTrue: [sessionList := SelectionInList with: List new ].	^sessionList</body><body package="OpenChatServer" selector="windowLabel">windowLabel	| s |	s := WriteStream on: String new.	s nextPutAll: 'ChatServer @ '.	broker objectAdaptor printAccessInfoOn: s.	^s contents</body></methods><methods><class-id>OpenChatServer</class-id> <category>private</category><body package="OpenChatServer" selector="log">log	^self class log</body><body package="OpenChatServer" selector="logMessages">logMessages	^self class logMessages</body><body package="OpenChatServer" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	parties do: [ :p | p serverStopping ].	broker stop</body><body package="OpenChatServer" selector="printOn:">printOn: aStream	aStream nextPutAll: 'ChatServer'</body><body package="OpenChatServer" selector="updateSessionList">updateSessionList	sessionList list: sessionList list</body></methods><methods><class-id>OpenChatServer</class-id> <category>sessions</category><body package="OpenChatServer" selector="invite:toJoin:from:">invite: otherPartyId toJoin: aSession from: initiatingParty	| otherParty accepted |	otherParty := parties at: otherPartyId ifAbsent: [^false].	accepted := otherParty doYouAcceptSession: aSession from: initiatingParty id on: aSession topic.	accepted ifTrue: [ aSession joining: otherParty. self updateSessionList ].	^accepted</body><body package="OpenChatServer" selector="removeSession:">removeSession: aSession	sessionList list remove: aSession.	self updateSessionList</body><body package="OpenChatServer" selector="startSessionFor:with:on:">startSessionFor: initiatingParty with: otherPartyId on: topic	| otherParty session accepted |	otherParty := parties at: otherPartyId ifAbsent: [^nil].	session := OpenChatSession for: initiatingParty and: otherParty on: self about: topic.	accepted := otherParty doYouAcceptSession: session from: initiatingParty id on: topic.	^accepted		ifTrue: [ sessionList list add: session.			self updateSessionList.			session ]		ifFalse: [nil]</body></methods><methods><class-id>OpenChatServer</class-id> <category>debugging</category><body package="OpenChatServer" selector="inspectLog">inspectLog	Log inspect</body><body package="OpenChatServer" selector="postBuildWith:">postBuildWith: aBuilder	self eventsHandled isEmpty ifFalse: [		(aBuilder menuAt: #partyMenu)			addLine;			addItem: (MenuItem labeled: 'Reset Log Clock') value: #resetLogClock;			addItem: (MenuItem labeled: 'Flush Log To Transcript') value: #flushLogToTranscript;			addItem: (MenuItem labeled: 'Inspect Log') value: #inspectLog ]</body></methods><methods><class-id>OpenChatServer</class-id> <category>menus</category><body package="OpenChatServer" selector="partyMenu">partyMenu	^Menu new		augmentFrom: self class to: OpenChatServer menuName: #partyMenu;		yourself</body></methods><methods><class-id>OpenChatServer</class-id> <category>initialization</category><body package="OpenChatServer" selector="initializeOnBroker:">initializeOnBroker: aBroker	broker := aBroker.	(InputState default shiftDown) ifTrue: [		broker sendAllEventsTo: self log ].	self logMessages ifTrue: [		#(sendingRequest:in: receivingRequest:in:) do: [ :ev |			broker objectAdaptor when: ev do: [ :rq :tr |				self log log: (					MessageSend						receiver: rq target						selector: rq message selector						arguments: rq message arguments) ] ] ].	broker start.	broker objectAdaptor export: self oid: #ChatServer.	parties := Dictionary new</body><body package="OpenChatServer" selector="initializeTcpOn:">initializeTcpOn: aPort	self initializeOnBroker: (Opentalk.RequestBroker newStstTcpAtPort: aPort)</body><body package="OpenChatServer" selector="initializeUdpOn:">initializeUdpOn: aPort	self initializeOnBroker: (Opentalk.RequestBroker newStstUdpAtPort: aPort)</body></methods><methods><class-id>OpenChatServer class</class-id> <category>instance creation</category><body package="OpenChatServer" selector="standard">standard"(((self standard open)))"	^self tcpOn: self standardPort</body><body package="OpenChatServer" selector="standardPort">standardPort	^4242</body><body package="OpenChatServer" selector="tcpOn:">tcpOn: aPort	^self new initializeTcpOn: aPort</body><body package="OpenChatServer" selector="udpOn:">udpOn: aPort	^self new initializeUdpOn: aPort</body></methods><methods><class-id>OpenChatServer class</class-id> <category>private</category><body package="OpenChatServer" selector="log">log"	Log := EventPrinter new.	Log := nil"	Log isNil ifTrue: [Log := Opentalk.EventCollector new resetClock; yourself].	^Log</body><body package="OpenChatServer" selector="logMessages">logMessages	^LogMessages ifNil: [false].</body></methods><methods><class-id>OpenChatServer</class-id> <category>debugging</category><body package="OpenChatServer" selector="flushLogToTranscript">flushLogToTranscript	&lt;menuItem: 'Flush Log To Transcript'		nameKey: nil		menu: #(#partyMenu)		position: 9.5&gt;	Log toTranscript</body><body package="OpenChatServer" selector="resetLogClock">resetLogClock	&lt;menuItem: 'Reset Log Clock'		nameKey: nil		menu: #(#partyMenu)		position: 9.7&gt;	Log resetClock</body></methods><methods><class-id>OpenChatServer class</class-id> <category>interface specs</category><body package="OpenChatServer" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#bounds: #(#{Graphics.Rectangle} 411 199 760 555 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -1 0.333333 -2 1) 					#model: #partyList 					#useModifierKeys: true					#menu: #partyMenu					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.333333 2 0 -2 1 -2 1 ) 					#model: #sessionList 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="OpenChatServer" selector="openChatServer">openChatServer	&lt;menuItem: 'Open Chat Server'		icon: nil		nameKey: nil		menu: #(#menuBar #tools)		position: 12.35&gt;	| port protocolMessage |	port := Dialog request: 'Which port number to use for the server ?' initialAnswer: '4242'.	port isEmpty ifTrue: [^self].	protocolMessage := Dialog choose: 'What type of protocol to use ?'				labels: #('TCP' 'UDP')				values: #(tcpOn: udpOn:)				default: #tcpOn:.	(OpenChatServer		perform: protocolMessage		with: port asNumber) open</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>