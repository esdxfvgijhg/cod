<?xml version="1.0"?><st-source><!-- Name: ByteOrderMarkSupportNotice: © Copyright 2013-2017 Georg Heeg e.K.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.(MIT License)Comment: Added support for ByteOrderMarks. The interface to use the new feature is implemented in EncodedStreamConstructor. This class is not really visible. Their objects are created with the method Filename>withEncoding:.

This method now takes new symbols:

#utf32 (new UTF32Encoding)
#utf32WithBOM
#utf16WithBOM
#utf8WithBOM
#autoDetect (this is the most interesting. It checks the file and selects between #utf32WithBOM, #utf16WithBOM, #utf8WithBOM, and default [if there is no BOM]).#autoDetectOr<Symbol> (It checks the file and selects between #utf32WithBOM, #utf16WithBOM, #utf8WithBOM, and <Symbol> [if there is no BOM], most important example #autoDetectOrUtf8)

The BOM support itself is implemented in a new class ByteOrderMarkedStream. This class is a sibling of EncodedStream. They have a common new superclass WrappingStream.
DbIdentifier: magdi.heeg.de.postgresDbTrace: 68773DbUsername: georgDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'StreamWrapping' '') #(#any 'URISupport' '') #(#any 'I18nRuntime' ''))PackageName: ByteOrderMarkSupportParcel: #('ByteOrderMarkSupport')ParcelDirectory: d:\visworks\vw8.3 jul17.1\image\HeegContributions-vw8.3-2017-07-10\ByteOrderMarkSupportParcelName: ByteOrderMarkSupportPrerequisiteDescriptions: #(#(#name 'StreamWrapping' #componentType #package) #(#name 'URISupport' #componentType #package) #(#name 'I18nRuntime' #componentType #package))PrerequisiteParcels: #(#('StreamWrapping' '') #('URISupport' '') #('I18nRuntime' ''))PrintStringCache: (8.3 - 2,georg)Version: 8.3 - 2Post-Load Block: 	[:package | StreamEncoder updateEncoderDirectory ]Post-Unload Block: 	[StreamEncoder updateEncoderDirectory]Date: 5:01:18 PM July 10, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jul17.1) of 7. Juli 2017 on 10. Juli 2017 at 17:01:18</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AutodetectStreamEncoder</name><environment>Core</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoderName name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ByteOrderMarkSupport</package></attributes></class><comment><class-id>Core.AutodetectStreamEncoder</class-id><body>AutodetectStreamEncoder can figure out the correct StreamEncoder for a given stream. It tries to read the first 4 bytes and decide which BOM they contain. If no BOM matches, the default encoding is used.The name of the encoder is used to figure out the default encoding. If the stream is used for writing and cannot be read from, the default encoding is used. If the write-encoding should differ from the default-encoding for reading, then it can be passed as the second keyword in the encoders name.Usage	(aFile withEncoding: #autodetect) readStream. 			"uses #default as encoding if no BOM is available."	(aFile withEncoding: #autodetectOrUTF8) readStream. 	"uses #UTF8 as encoding if no BOM is available"		"the next example will create a UTF8WithBOM writeStream.	Using UTF8WithBOM also as default for reading is useless as 	the default encoding is only used if no BOM is available, 	which is the oposite of what UTF8WithBOM is"	(aFile withEncoding: #autodetectOrUTF8:UTF8WithBOM:) writeStream.Instance Variables	encoderName	&lt;Symbol&gt;	name that was used to find the encoder	name 			&lt;Symbol&gt;	name that's used in #registerOn:. 								It is used when a AutodetectStreamEncoder is used in a CharacterEncoderPool shared-variable</body></comment><class><name>UTF32StreamEncoder</name><environment>Core</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bigEndian </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>ByteOrderMarkSupport</package></attributes></class><comment><class-id>Core.UTF32StreamEncoder</class-id><body>UTF32StreamEncoder is used for mapping data streams where Character data is mapped using the UTF-32 stream encoding.ImplementationThis is a straightforward mapping of Unicode to bytes, all other Unicode characters can be stored in 4 bytes.Instance Variables	bigEndian	&lt;Boolean&gt;	a flag indicating whether the stream data is read in big-endian order or little-endian</body></comment><class><name>ByteOrderMarkedStream</name><environment>Core</environment><super>Core.WrappingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ByteOrderMarkSupport</package></attributes></class><comment><class-id>Core.ByteOrderMarkedStream</class-id><body>ByteOrderMarkedStream adds a ByteOrder mark to streams. For reference see http://www.unicode.org/faq/utf_bom.html#BOM</body></comment><class><name>BOMStreamEncoder</name><environment>Core</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>streamEncoder name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ByteOrderMarkSupport</package></attributes></class><comment><class-id>Core.BOMStreamEncoder</class-id><body>BOMStreamEncoder is a StreamEncoder that wraps a ByteOrderMarkedStream around the encoded stream that's created using its streamEncoder instance variable. This encoder is registered in the CharacterEncoderPool with handcoded initializers. It is used for the different UTF-encodings that have the WithBOM-suffix.Instance Variables	name			&lt;Symbol&gt;			name of the encoding	streamEncoder	&lt;StreamEncoder&gt;	the stream encoder that's actually used for encoding</body></comment><shared-variable><name>UTF16BEWithBOM</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF-BOM</category><initializer>BOMStreamEncoder new				name:#UTF16BEWithBOM; 					streamEncoder: (UTF16StreamEncoder new									bigEndian: true;									yourself);				yourself</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>UTF16LE</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF</category><initializer>(UTF16StreamEncoder new						bigEndian: false;						yourself)</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>AutodetectOrUTF32LE_UTF32LEBOM_</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>false</constant><category>autodetect</category><initializer>AutodetectStreamEncoder named: #autodetectOrUTF32LE:UTF32LEWithBOM: encoderName: #autodetectOrUTF32LE:UTF32LEWithBOM:</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>UTF8WithBOM1</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF-BOM</category><initializer>BOMStreamEncoder new 					name:#'UTF-8WithBOM'; 					streamEncoder: UTF8StreamEncoder new;				yourself</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>AutodetectOrUTF16BE_UTF16BEBOM_</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>false</constant><category>autodetect</category><initializer>AutodetectStreamEncoder named: #autodetectOrUTF16BE:UTF16BEWithBOM: encoderName: #autodetectOrUTF16BE:UTF16BEWithBOM:</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>UTF16LEWithBOM</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF-BOM</category><initializer>BOMStreamEncoder new 					name:#UTF16LEWithBOM; 					streamEncoder: (UTF16StreamEncoder new									bigEndian: false;									yourself);				yourself</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>UTF32LEWithBOM</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF-BOM</category><initializer>BOMStreamEncoder new 					name:#UTF32LEWithBOM; 					streamEncoder: (UTF32StreamEncoder new									bigEndian: false;									yourself);				yourself</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>UTF8WithBOM2</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF-BOM</category><initializer>BOMStreamEncoder new 					name:#'UTF_8WithBOM'; 					streamEncoder: UTF8StreamEncoder new;				yourself</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>UTF32LE</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF</category><initializer>(UTF32StreamEncoder new						bigEndian: false;						yourself)</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>AutodetectOrUTF8</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>false</constant><category>autodetect</category><initializer>AutodetectStreamEncoder named: #autodetectOrUTF8 encoderName: #autodetectOrUTF8</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>UTF32BEWithBOM</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF-BOM</category><initializer>BOMStreamEncoder new 					name:#UTF32BEWithBOM; 					streamEncoder: (UTF32StreamEncoder new									bigEndian: true;									yourself);				yourself</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>AutodetectOrUTF32BE_UTF32BEBOM_</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>false</constant><category>autodetect</category><initializer>AutodetectStreamEncoder named: #autodetectOrUTF32BE:UTF32BEWithBOM: encoderName: #autodetectOrUTF32BE:UTF32BEWithBOM:</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>UTF16BE</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF</category><initializer>(UTF16StreamEncoder new						bigEndian: true;						yourself)</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>UTF32BE</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF</category><initializer>(UTF32StreamEncoder new						bigEndian: true;						yourself)</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>Dbg_text</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>false</constant><category>Other</category><initializer>AutodetectStreamEncoder named: #dbg_text encoderName: #dbg_autodetect:UTF8WithBOM:</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>AutodetectOrUTF8_UTF8BOM_</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>false</constant><category>autodetect</category><initializer>AutodetectStreamEncoder named: #autodetectOrUTF8:UTF8WithBOM: encoderName: #autodetectOrUTF8:UTF8WithBOM:</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>AutodetectOrUTF16LE_UTF16LEBOM_</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>false</constant><category>autodetect</category><initializer>AutodetectStreamEncoder named: #autodetectOrUTF16LE:UTF16LEWithBOM: encoderName: #autodetectOrUTF16LE:UTF16LEWithBOM:</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>UTF8WithBOM</name><environment>Core.CharacterEncoderPool</environment><private>false</private><constant>true</constant><category>UTF-BOM</category><initializer>BOMStreamEncoder new 					name:#UTF8WithBOM; 					streamEncoder: UTF8StreamEncoder new;				yourself</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><shared-variable><name>BOMCharacter</name><environment>Core.ByteOrderMarkedStream</environment><private>false</private><constant>false</constant><category>constants</category><initializer>Character value: 16rFEFF</initializer><attributes><package>ByteOrderMarkSupport</package></attributes></shared-variable><methods><class-id>Core.AutodetectStreamEncoder</class-id> <category>accessing</category><body package="ByteOrderMarkSupport">byteOrderMarks	| dict |	dict := Dictionary new.	dict		at: #[0 0 16rFE 16rFF] put: #utf32BEWithBOM;		at: #[16rFF 16rFE 0 0] put: #utf32LEWithBOM;		at: #[16rFE 16rFF] put: #utf16BEWithBOM;		at: #[16rFF 16rFE] put: #utf16LEWithBOM;		at: #[16rEF 16rBB 16rBF] put: #utf8WithBom;		yourself.	^dict</body><body package="ByteOrderMarkSupport">createEncodedStreamOn: aStream	^(self findStreamEncoderOn: aStream) createEncodedStreamOn: aStream</body><body package="ByteOrderMarkSupport">encoderName	^encoderName</body><body package="ByteOrderMarkSupport">encoderName: anObject	encoderName := anObject</body><body package="ByteOrderMarkSupport">findStreamEncoderOn: aStream	| first4Bytes isForReading |	first4Bytes := self firstFourBytesFrom: aStream.	(self byteOrderMarks keys sorted: #size descending) do: 			[:mark |			"read big marks first, otherwise UTF32LE will result in UTF16 LE, because their first two bytes are the same"			mark = (first4Bytes first: mark size)				ifTrue: [^StreamEncoder new: (self byteOrderMarks at: mark)]].	isForReading := aStream isReadable.	(aStream isWritable and:[first4Bytes isEmpty])		ifTrue: 			["there are readWriteStreams and the write-encoding takes precedence.			i.e. if the encoding is #autodetect:UTF8WithBom:"			isForReading := false].	^StreamEncoder new: (self nameOfDefaultEncodingForReading: isForReading)</body><body package="ByteOrderMarkSupport">firstFourBytesFrom: aStream	| first4Bytes |	aStream isReadable ifFalse: [^#[]].	first4Bytes := #[].	self preserveBinaryOn: aStream		while: [first4Bytes := aStream nextAvailable: 4].	aStream reset.	^first4Bytes</body><body package="ByteOrderMarkSupport">name	^name</body><body package="ByteOrderMarkSupport">name: anObject	name := anObject</body><body package="ByteOrderMarkSupport">nameOfDefaultEncodingForReading: reading	"the name of the default encoding is part of the encoderName, like in #autoDetectOrUTF8WithBom.	if the encoderName is just #autodetect, then #default is the encoding to use.	if we're not reading, then the second keyword of the selector has precedence as encoding"	| symbol |	(reading not and: [self encoderName keywords size &gt; 1])		ifTrue: 			["return the text of the second keyword, rejecting the traling $:"			^(self encoderName keywords at: 2) allButLast: 1].	symbol := self encoderName keywords first.	(symbol last: 1) = ':' asIs ifTrue: [symbol := symbol allButLast: 1].	(#('dbg_autodetect' 'autodetect') asIs includes: symbol asLowercase)		ifTrue: [^#default].	('dbg_*' asIs match: symbol)		ifTrue: [^(symbol allButFirst: #dbg_autoDetectOr size) asSymbol].	^(symbol allButFirst: #autoDetectOr size) asSymbol</body><body package="ByteOrderMarkSupport">nextFrom: aStream	^self shouldNotImplement</body><body package="ByteOrderMarkSupport">nextPut: aCharacter on: aStream	"Encode aCharacter and write it to encoded stream."	^self shouldNotImplement</body><body package="ByteOrderMarkSupport">preserveBinaryOn: aStream while: aBlock	| wasBinary |	(#(#binary #isBinary #setBinary)		allSatisfy: [:each | aStream respondsTo: each]) ifFalse: [^aBlock value].	wasBinary := aStream isBinary.	aStream binary.	aBlock value.	aStream setBinary: wasBinary</body><body package="ByteOrderMarkSupport">streamEncodingType	^self name ifNil: [self encoderName]</body></methods><methods><class-id>Core.AutodetectStreamEncoder</class-id> <category>registration</category><body package="ByteOrderMarkSupport">asEncoder	^self</body><body package="ByteOrderMarkSupport">registerOn: anIdentityDictionary	anIdentityDictionary at: self name put: self</body></methods><methods><class-id>Core.AutodetectStreamEncoder</class-id> <category>querying</category><body package="ByteOrderMarkSupport">characterSize: char	"Return the size in bytes of &lt;char&gt;."	^self shouldNotImplement</body></methods><methods><class-id>Core.AutodetectStreamEncoder class</class-id> <category>accessing</category><body package="ByteOrderMarkSupport">named: aString encoderName: encoderName	^(self new)		name: aString;		encoderName: encoderName;		yourself</body><body package="ByteOrderMarkSupport">streamEncodingType	"Answer the symbol of this encoding."	^nil</body><body package="ByteOrderMarkSupport">withEncoderName: aString	^(self new)		encoderName: aString;		yourself</body></methods><methods><class-id>Core.UTF32StreamEncoder</class-id> <category>accessing</category><body package="ByteOrderMarkSupport">bigEndian	^bigEndian</body><body package="ByteOrderMarkSupport">bigEndian: anObject	bigEndian := anObject</body><body package="ByteOrderMarkSupport">encoding	"Answer the encoding symbol."	^super encoding , (bigEndian ifTrue: ['BE' asIs] ifFalse: ['LE' asIs])</body><body package="ByteOrderMarkSupport">nextFrom: aStream	"Decode the next byte(s) in the UTF encoded stream,	 and answer the character."	^Character value: (self get32: aStream)</body><body package="ByteOrderMarkSupport">nextPut: aCharacter on: aStream	"Encode aCharacter and write it to the UTF stream."	self put32: aCharacter asInteger on: aStream.	^aCharacter</body></methods><methods><class-id>Core.UTF32StreamEncoder</class-id> <category>private</category><body package="ByteOrderMarkSupport">get32: aStream	"Decode the next byte(s) in the UTF encoded stream,	 and answer the character."	| bytes result |	bytes := ByteArray new: 4.	1 to: 4		do: [:i | aStream next ifNil: [^nil] ifNotNil: [:byte | bytes at: i put: byte]].	result := 0.	bigEndian		ifTrue: [bytes do: [:byte | result := (result bitShift: 8) + byte]]		ifFalse: [bytes reverseDo: [:byte | result := (result bitShift: 8) + byte]].	^result</body><body package="ByteOrderMarkSupport">put32: anInt on: aStream	"Decode the next byte(s) in the UTF encoded stream,	 and answer the character."	| bytes result |	result := anInt.	bytes := ByteArray new: 4.	bigEndian		ifTrue: 			[4 to: 1 by: -1 do: 					[:i |					bytes at: i put: (result bitAnd: 16rFF).					result := result bitShift: -8]]		ifFalse: 			[1 to: 4 do: 					[:i |					bytes at: i put: (result bitAnd: 16rFF).					result := result bitShift: -8]].	aStream nextPutAll: bytes</body></methods><methods><class-id>Core.UTF32StreamEncoder</class-id> <category>initialize</category><body package="ByteOrderMarkSupport">initialize	super initialize.	bigEndian := UninterpretedBytes isBigEndian</body></methods><methods><class-id>Core.UTF32StreamEncoder</class-id> <category>querying</category><body package="ByteOrderMarkSupport">characterSize: char	"Return the size in bytes of &lt;char&gt;."	^4</body></methods><methods><class-id>Core.UTF32StreamEncoder</class-id> <category>registration</category><body package="ByteOrderMarkSupport">asEncoder	^self</body><body package="ByteOrderMarkSupport">registerOn: anIdentityDictionary	| suffix |	suffix := self bigEndian ifTrue: [#be] ifFalse: [#le].	anIdentityDictionary at: (#utf32 , suffix) asSymbol put: self</body></methods><methods><class-id>Core.UTF32StreamEncoder class</class-id> <category>instance creation</category><body package="ByteOrderMarkSupport">new	^super new initialize</body></methods><methods><class-id>Core.UTF32StreamEncoder class</class-id> <category>accessing</category><body package="ByteOrderMarkSupport">alternateNames	"Answer the alternate symbols of this encoding."	^#(#UTF_32 #UTF32)</body><body package="ByteOrderMarkSupport">streamEncodingType	^#'UTF-32'</body></methods><methods><class-id>Core.ByteOrderMarkedStream</class-id> <category>accessing</category><body package="ByteOrderMarkSupport">contents	^self isBinary ifTrue: [super contents] ifFalse: [super contents allButFirst: 1]</body><body package="ByteOrderMarkSupport">encodedContents		^stream encodedContents</body><body package="ByteOrderMarkSupport">encoder	^stream encoder</body><body package="ByteOrderMarkSupport">encoder: aStreamEncoder	stream encoder: aStreamEncoder</body><body package="ByteOrderMarkSupport">encoding	^('&lt;1s&gt;WithBOM' asIs expandMacrosWith: stream encoding) asSymbol</body><body package="ByteOrderMarkSupport">next	self readBOM.	^super next</body><body package="ByteOrderMarkSupport">nextPut: anObject	self writeBOM.	^super nextPut: anObject</body><body package="ByteOrderMarkSupport">nextPutAll: anObject	self writeBOM.	^stream nextPutAll: anObject</body><body package="ByteOrderMarkSupport">peek	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	self readBOM.	^super peek</body><body package="ByteOrderMarkSupport">peekFor: anObject	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	self readBOM.	^super peekFor: anObject</body><body package="ByteOrderMarkSupport">readBOM	(self isText and: [stream readPosition = 0]) ifTrue: [stream next]</body><body package="ByteOrderMarkSupport">skip: anInteger	super skip: anInteger.	stream position = 0 ifTrue: [self stream position: 1]</body><body package="ByteOrderMarkSupport">skipToAll: aCollection	self readBOM.	^super skipToAll: aCollection</body><body package="ByteOrderMarkSupport">throughAll: aCollection	self readBOM.	^super throughAll: aCollection</body><body package="ByteOrderMarkSupport">upToAll: aString	self readBOM.	^super upToAll: aString</body><body package="ByteOrderMarkSupport">writeBOM	(self isText and: [stream writePosition = 0])		ifTrue: [stream nextPut: BOMCharacter]</body></methods><methods><class-id>Core.ByteOrderMarkedStream</class-id> <category>As yet unclassified</category><body package="ByteOrderMarkSupport">closed	^stream closed</body></methods><methods><class-id>Core.ByteOrderMarkedStream class</class-id> <category>instance creation</category><body package="ByteOrderMarkSupport">on: aStream	^self basicNew stream: aStream</body></methods><methods><class-id>Core.BOMStreamEncoder</class-id> <category>accessing</category><body package="ByteOrderMarkSupport">createEncodedStreamOn: aStream	^ByteOrderMarkedStream		on: (EncodedStream on: aStream encodedBy: self streamEncoder copy)</body><body package="ByteOrderMarkSupport">name	^name</body><body package="ByteOrderMarkSupport">name: anObject	name := anObject</body><body package="ByteOrderMarkSupport">nextFrom: aStream	"Decode the next byte(s) in the stream and answer the character."	^self shouldNotImplement</body><body package="ByteOrderMarkSupport">nextPut: aCharacter on: aStream	"Encode aCharacter and write it to encoded stream."	^self shouldNotImplement</body><body package="ByteOrderMarkSupport">streamEncoder	^streamEncoder</body><body package="ByteOrderMarkSupport">streamEncoder: anObject	streamEncoder := anObject</body><body package="ByteOrderMarkSupport">streamEncodingType	^self streamEncoder streamEncodingType</body></methods><methods><class-id>Core.BOMStreamEncoder</class-id> <category>registration</category><body package="ByteOrderMarkSupport">asEncoder	^self</body><body package="ByteOrderMarkSupport">registerOn: anIdentityDictionary	anIdentityDictionary at: self name asLowercase asSymbol put: self</body></methods><methods><class-id>Core.BOMStreamEncoder</class-id> <category>querying</category><body package="ByteOrderMarkSupport">characterSize: char	"Return the size in bytes of &lt;char&gt;."	^self shouldNotImplement</body></methods><methods><class-id>Core.BOMStreamEncoder class</class-id> <category>accessing</category><body package="ByteOrderMarkSupport">streamEncodingType	^nil</body></methods><methods><class-id>Core.StreamEncoder class</class-id> <category>private</category><body package="ByteOrderMarkSupport">lookupEncoderDirectory: sym	| val |	val := sym.		[('autodetect*' asIs match: val)		ifTrue: [^AutodetectStreamEncoder withEncoderName: val].	"the following match only fires for the tests. It makes it possible to remove the 'autodetect*' match: and still run the tests."	('dbg_autodetect*' asIs match: val)		ifTrue: [^AutodetectStreamEncoder withEncoderName: val].	val := self encoderDirectory at: val asLowercase asSymbol.	val class == BlockClosure ifTrue: [val := val value].	val isSymbol]			whileTrue.	^val</body><body package="ByteOrderMarkSupport">updateEncoderDirectory	| ascii |	ascii := ByteCharacterEncoder new.	ascii name: #'US-ASCII'.	ascii streamEncodingType: #'US-ASCII'.	ascii alternateNames: #(#ASCII #'646' #'ISO-646' #ISO646 #cp367).	0 to: 127		do: 			[:i |			ascii encode: i asCharacter as: i + 128.			ascii encode: i asCharacter as: i].	EncoderDirectory := (IdentityDictionary new)				at: #default put: [Locale current defaultStreamEncoder];				"overridden to change the #source encoding to use auto detection, for compatibility reasons source files are not written with BOM"				at: #source put: #autodetectOrUTF8:UTF8:;				yourself.	ascii registerOn: EncoderDirectory.	CharacterEncoderPool localBindings		do: [:bnd | bnd value registerOn: EncoderDirectory].	StreamEncoder allSubclasses do: 			[:class |			| sym |			sym := class streamEncodingType.			sym isNil				ifFalse: [EncoderDirectory at: sym asLowercase asSymbol put: class].			class alternateNames				do: [:nm | EncoderDirectory at: nm asLowercase asSymbol put: class]].	StreamEncoderConstructor installConstructorsOn: EncoderDirectory</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>private</category><body package="ByteOrderMarkSupport">ensureOpen: index	"Ensure the file at index is open.  If there are too	 many files open then close the least recently opened.	 Answer the open file."	| file sff |	(openIndices includes: index)		ifTrue: [openIndices remove: index]		ifFalse:			[openIndices size &gt;= MaxOpenFiles ifTrue:				[self close: openIndices first]].	openIndices addLast: index.	"If the file is not in files, or if its set to decompile then open it.	 Otherwise it should already be open."	(file := files at: index ifAbsent: #decompile) == #decompile ifTrue:			[| fileName fileSource |			(fileName := names at: index) == nil ifTrue:				[^self error: (#InvalidFileIndex &lt;&lt; #dialogs &gt;&gt; 'invalid file index')].			"overridden to use #source encoding, which defaults to #autoDetectOrUTF8:UTF8:"			fileSource := (fileName := fileName asFilename) withEncoding: #source.			file := files at: index put: (((writableIndices includes: index) and: [fileName canBeWritten])							ifTrue: [fileSource readAppendStream]							ifFalse: [fileSource readStream]).			file lineEndTransparent.			file size = 0				ifTrue: [sff := self systemFormatter]				ifFalse: [sff := (SourceFileFormat formatForStream: file) forFragment]]		ifFalse: [			(file ioConnection notNil and: [file ioConnection output notNil and: [file ioConnection output successful not]])				ifTrue: [file close. file stream reopen].			(file isExternalStream and:[ file closed])			ifTrue: [((self nameAt: index) exists and: [file size &gt; 0])				ifTrue: [sff := (SourceFileFormat formatForStream: file) forFragment]				ifFalse: [sff := self systemFormatter]]			ifFalse: [sff := nil]].	sff == nil		ifFalse: [sourceFormatters at: index put: sff].	^file</body></methods><methods><class-id>OS.FileURL</class-id> <category>accessing</category><body package="ByteOrderMarkSupport">resource	^XML.InputSource		uri: self		encoding: nil		stream: (self asFilename withEncoding: #source) readStream lineEndTransparent</body></methods><methods><class-id>Core.UTF16StreamEncoder</class-id> <category>registration</category><body package="ByteOrderMarkSupport">asEncoder	^self</body></methods><methods><class-id>Core.UTF16StreamEncoder</class-id> <category>accessing</category><body package="ByteOrderMarkSupport">encoding	"Answer the encoding symbol."	^super encoding , (bigEndian ifTrue: ['BE' asIs] ifFalse: ['LE' asIs])</body></methods><methods><class-id>Core.UTF16StreamEncoder</class-id> <category>registration</category><body package="ByteOrderMarkSupport">registerOn: anIdentityDictionary	| suffix |	suffix := self bigEndian ifTrue: [#be] ifFalse: [#le].	anIdentityDictionary at: (#utf16 , suffix) asSymbol put: self</body></methods><methods><class-id>Tools.FileBrowser class</class-id> <category>class initialization</category><body package="ByteOrderMarkSupport">initialize	"FileBrowser initialize"	"overridden to make sure that files with BOM are opened correctly"	DefaultPattern := '*'.	MaxAutoReadLength := 50000.	"50K seems like a nice number"	DefaultEncodings := IdentityDictionary new.	DefaultEncodings		at: #text put: #autoDetect:UTF8WithBOM:;		at: #source put: #Source;		at: #xml put: #autoDetectOrUTF8:UTF8WithBOM:;		at: #unknown put: #autoDetect:UTF8WithBOM:</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>private</category><body package="ByteOrderMarkSupport">encodingFor: filenameString	"Answer the encoding to use for the specified filename."	"overridden to make sure that files with BOM are opened correctly"	| type |	type := self class fileTypeFor: filenameString.	type == #unknown		ifTrue: [type := #text].		"default to #text"	^(defaultEncodings at: type ifAbsent: [#autoDetect:UTF8WithBOM:]) value</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>types/encodings-definitions</category><body package="ByteOrderMarkSupport">i18nPragmaIgnores	&lt;i18nPragmasToIgnore&gt;	^#(#patterns:priority:)</body><body package="ByteOrderMarkSupport">lblFiles	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;patterns: #('*.lbl') priority: 1&gt;	^#autodetectOrUTF8:UTF8WithBOM:</body><body package="ByteOrderMarkSupport">textEncoding	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;encodingFor: #text&gt;	^#autoDetect:UTF8WithBOM:</body><body package="ByteOrderMarkSupport">unknownEncoding	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;encodingFor: #unknown&gt;	^#autoDetect</body><body package="ByteOrderMarkSupport">xmlEncoding	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;encodingFor: #xml&gt;	^#AutoDetectOrUtf8</body></methods><initialize><class-id>Tools.FileBrowser</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>UTF16StreamEncoder</name><environment>Core</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bigEndian </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>FileURL</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>missingSlashes host </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>SourceFileManager</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files names writableIndices openIndices currentTarget isPadding sourceFormatters sourceToCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>WrappingStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StreamWrapping</package></attributes></class><class><name>FileBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName list myPattern selectionState autoRead lastModified currentFileEncoding defaultEncodings patternAspect menuBar showFullPath isDirty </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>