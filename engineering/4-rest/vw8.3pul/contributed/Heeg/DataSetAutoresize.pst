<?xml version="1.0"?><st-source><!-- Name: DataSetAutoresizeComment: This package defines a wrapper that automatically resizes certain columns of a DataSet in order to use the full width of the widgetDbIdentifier: magdi.heeg.de.postgresDbTrace: 67455DbUsername: danielDbVersion: 8.3 - 1PackageName: DataSetAutoresizeParcel: #('DataSetAutoresize')ParcelDirectory: d:\visworks\vw8.3 may17.4\image\HeegContributions-vw8.2.1-2017-05-31\DataSetAutoresizePrintStringCache: (8.3 - 1,daniel)Version: 8.3 - 1Date: 3:10:42 PM May 31, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (may17.4) of 26. Mai 2017 on 31. Mai 2017 at 15:10:42</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ColumnLeftHandSideAgent</name><environment>UI</environment><super>UI.ColumnResizeAgent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DataSetAutoresize</package></attributes></class><comment><class-id>UI.ColumnLeftHandSideAgent</class-id><body>ColumnLeftHandSideAgent is a Resize-Agent that resizes the column on the right of the current divider, effectively moving the left-hand edge of the column instead of the right-hand edge. It uses the instance-variables of the super-class in the same way as the super-class but with oposite meaning. leftEdge and leftLimit are actually the right-hand-side limits.</body></comment><class><name>DataSetAutoresizeWrapper</name><environment>UI</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resizeSpec numVariants minWidth isChangingBounds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>DataSetAutoresize</package></attributes></class><comment><class-id>UI.DataSetAutoresizeWrapper</class-id><body>DataSetAutoresizeWrapper is a Wrapper that injects itself between the DataSetScrollWrapper and the DataSetView.It detects changes to the bounds, by implementing #bounds:. In that case it adjusts the width of certain columns if that is desired.As the resizeWrapper is injected between the DataSetScrollWrapper and the DataSetView, it has to mimic both implementations to a certain extent. The DataSetScrollWrapper asks the DataSetView for hScrollBounds and vScrollBounds. The ColumnResizeAgent assumes that the DataSetView's container is a DataSetScrollWrapper and that's why the methods #scrollBy:, #scrollOffset and #visibleExtent are implemented and passed on to the scroll wrapper.Usage	"in postBuildWith: call the following code"	DataSetAutoresizeWrapper autoResizeColumnsIn: aDataSetView usingSpec: #(200 0 0)	"the array at the end holds the fixed widths of the various columns. 	If the width is 0 it means auto-resize. The width is then spread equally among the columns that have a 0 width.	In the example the first column has a width of 200 and the remaining two columns spread equally"Instance Variables:	isChangingBounds	&lt;Boolean&gt;	if true, changes to the widthHolder of a column descriptor is ignored.								see #isChangingBoundsWhile: for more information.	minWidth			&lt;Integer&gt;		the sum of the widths of columns that have a fixed width. 								Used to compute the amount of space that can be used by the variable-sized columns.	numVariants		&lt;Integer&gt;		the number of columns that have a variable width. 	resizeSpec			&lt;Array&gt;		Array of numbers. Each number corresponds to the width of the column at that index.								A number with the value 0 means that the size is computed dynamically.</body></comment><methods><class-id>UI.ColumnLeftHandSideAgent</class-id> <category>event driven</category><body package="DataSetAutoresize">mouseMovedTo: aPoint	| horizontalPosition  |	horizontalPosition := aPoint x. 	"flipped to only use points that are left of the right-edge of the column"	horizontalPosition &lt; leftLimit ifFalse: [^self].	self adjustTo: horizontalPosition</body><body package="DataSetAutoresize">okayToStartUpAt: aPoint 	| range otherEdge dragPoint |	dragPoint := aPoint + (2 @ 0).	(index := controller view columnIndexFor: dragPoint) == 0 ifTrue: [^false].	(controller view columnDescriptors at: index) allowResizing 		ifFalse: [^false].	range := controller view xRangesFor: index inBounds: controller view bounds.	"igore the fixed columns because they are only on the left hand side of the dataset. The right-hand side doesn't have these"	leftEdge := range last.	leftLimit := range last.	"the other edge is the left side and not the right-side, hence #first instead of #last"	otherEdge := range first.	self view dropEdit.	(dragPoint x between: otherEdge - 4 and: otherEdge + 4) 		ifFalse: 			[index := nil.			^false].	controller view invalidateSelectionIndex: controller view selectionIndex.	^true</body></methods><methods><class-id>UI.ColumnLeftHandSideAgent</class-id> <category>interaction</category><body package="DataSetAutoresize">adjustTo: anX	| cd x delta d box container rightGap |	cd := self view columnDescriptors.	"instead of last, use the first"	x := (controller view xRangesFor: index inBounds: controller view bounds)				first.	"flip the variables to get sign right"	delta := x - anX.	d := cd at: index.	d width: (d width + delta max: 1).	self view computeStarts.	box := self view bounds.	container := self view container.	rightGap := (container visibleExtent - self view right				+ container scrollOffset) x.	rightGap &gt; 0 ifTrue: [container scrollBy: rightGap negated @ 0].	self view changedPreferredGeometry.	box left: (leftEdge max: leftLimit).	self view invalidateRectangle: box.</body></methods><methods><class-id>UI.ColumnLeftHandSideAgent class</class-id> <category>instance creation</category><body package="DataSetAutoresize">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>UI.DataSetAutoresizeWrapper</class-id> <category>DataSetView-interface</category><body package="DataSetAutoresize">hScrollBounds	"this method is necessary because it is sent by the DataSetScrollWrapper, which assumes a DataSet as its component"	^component hScrollBounds</body><body package="DataSetAutoresize">vScrollBounds	"this method is necessary because it is sent by the DataSetScrollWrapper, which assumes a DataSet as its component"	^component vScrollBounds</body></methods><methods><class-id>UI.DataSetAutoresizeWrapper</class-id> <category>initialize-release</category><body package="DataSetAutoresize">resizeSpec: anArray	resizeSpec := anArray.	numVariants := (anArray select: #isZero) size.	minWidth := anArray inject: 0 into: [:all :each | all + each]</body></methods><methods><class-id>UI.DataSetAutoresizeWrapper</class-id> <category>ScrollWrapper-interface</category><body package="DataSetAutoresize">scrollBy: anObject	^container scrollBy: anObject</body><body package="DataSetAutoresize">scrollOffset	^container scrollOffset</body><body package="DataSetAutoresize">visibleExtent	^container visibleExtent</body></methods><methods><class-id>UI.DataSetAutoresizeWrapper</class-id> <category>bounds accessing</category><body package="DataSetAutoresize">adjustColumnsToBounds: newBounds	| newWidth variantWidth |	self isChangingBoundsWhile: 			[variantWidth := newBounds width - minWidth.			component columnDescriptors doWithIndex: 					[:each :index |					newWidth := self sizeSpecAt: index for: each.					newWidth = 0 ifTrue: [newWidth := (variantWidth / numVariants) rounded].					each width: newWidth].			component computeStarts]</body><body package="DataSetAutoresize">bounds: newBounds	"Set the components bounds based on newBounds extent."	super bounds: newBounds.	self adjustColumnsToBounds: newBounds</body></methods><methods><class-id>UI.DataSetAutoresizeWrapper</class-id> <category>private</category><body package="DataSetAutoresize">setComponent: aVisualComponent	"Set aVisualComponent to be the the receiver's component.	Set aVisualComponent's container to be the receiver."	component notNil		ifTrue: 			[component columnDescriptors				do: [:each | each widthHolder removeDependent: self]].	super setComponent: aVisualComponent.	component notNil		ifTrue: 			[component columnDescriptors				do: [:each | each widthHolder addDependent: self]]</body></methods><methods><class-id>UI.DataSetAutoresizeWrapper</class-id> <category>accessing</category><body package="DataSetAutoresize">sizeSpecAt: columnIndex for: columnDescription	(columnIndex between: 1 and: resizeSpec size)		ifFalse: [^columnDescription width].	^resizeSpec at: columnIndex</body></methods><methods><class-id>UI.DataSetAutoresizeWrapper</class-id> <category>updating</category><body package="DataSetAutoresize">isChangingBoundsWhile: aBlock	"i am a dependent on the widthHolders of the ColumnDescriptors.	The reason is that i need to be informed when the columns are manually resized.	In that case the size of a column is set to a fixed amount.	To not be confused with value-changes that are initiated by myself, the instVar &lt;isChangingBounds&gt; was introduced.	While this variable is true, the changes to the width-Holders are ignored, because they are initiated by myself"		isChangingBounds := true.	aBlock ensure: [isChangingBounds := false]</body><body package="DataSetAutoresize">update: aspect with: parameter from: sender	| index newSpec |	index := component columnDescriptors				findFirst: [:each | each widthHolder == sender].	(isChangingBounds or: [index = 0])		ifTrue: [^super update: aspect with: parameter from: sender].	newSpec := resizeSpec copy.	newSpec at: index put: sender value.	self resizeSpec: newSpec.	self adjustColumnsToBounds: self bounds.	self invalidate</body></methods><methods><class-id>UI.DataSetAutoresizeWrapper</class-id> <category>testing</category><body package="DataSetAutoresize">isIndexAfterAutoResizeColumn: anIndex	^(resizeSpec first: anIndex) includes: 0</body></methods><methods><class-id>UI.DataSetAutoresizeWrapper class</class-id> <category>instance creation</category><body package="DataSetAutoresize">autoResizeColumnsIn: widget usingSpec: anArray	| scrollWrapper resizeWrapper |	scrollWrapper := widget parent.	resizeWrapper := self on: widget.	resizeWrapper resizeSpec: anArray.	scrollWrapper setComponent: resizeWrapper</body><body package="DataSetAutoresize">wrap: widget	| scrollWrapper resizeWrapper |	scrollWrapper := widget parent.	resizeWrapper := self on: widget.	scrollWrapper setComponent: resizeWrapper</body></methods><methods><class-id>UI.ColumnResizeAgent</class-id> <category>interaction</category><body package="DataSetAutoresize">needsLeftResize	| autoresizeWrapper |	autoresizeWrapper := controller view container.	^autoresizeWrapper class = DataSetAutoresizeWrapper and:[autoresizeWrapper isIndexAfterAutoResizeColumn: index]</body></methods><methods><class-id>Graphics.Wrapper</class-id> <category>testing</category><body package="DataSetAutoresize">isIndexAfterAutoResizeColumn: anIndex	^false</body></methods><methods><class-id>UI.DataSetTracker</class-id> <category>events</category><body package="DataSetAutoresize">redButtonPressedEvent: aMouseButtonEvent	| aPoint columnTracker |	(controller acceptSelectDownWithEvent: aMouseButtonEvent) ifFalse: [^self].	aPoint := self cursorPointFor: aMouseButtonEvent.	controller isLocked		ifFalse: 			[self controller keyboardProcessor focusedView: self view.			self view widgetState hasKeyboardFocus: true.			controller focusIn].	controller lockCallbacks.	((self view labelAreaBounds containsPoint: aPoint)		and: [self view requestEditorFocusOut])			ifTrue: 				[| tempColumnResizeAgent |				self view editorFocusOut.				tempColumnResizeAgent := ColumnResizeAgent new controller: controller.				((tempColumnResizeAgent okayToStartUpAt: aPoint) and:[tempColumnResizeAgent needsLeftResize]) 					ifTrue:[tempColumnResizeAgent := ColumnLeftHandSideAgent new controller: controller].				columnTracker := (tempColumnResizeAgent okayToStartUpAt: aPoint)							ifTrue: [ColumnResizeTracker on: tempColumnResizeAgent]							ifFalse: 								[ColumnDraggingTracker on: (ColumnDraggingAgent new controller: controller)].				columnTracker redButtonPressedEvent: aMouseButtonEvent]			ifFalse: 				[(self startSelectingAt: aPoint)					ifTrue: [super redButtonPressedEvent: aMouseButtonEvent]					ifFalse: [controller unlockCallbacks]]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ColumnResizeAgent</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller outside index leftLimit leftEdge </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Datasets</category><attributes><package>UIBasics-Datasets</package></attributes></class><class><name>Wrapper</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>DataSetTracker</name><environment>UI</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cleared </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class></st-source>