<?xml version="1.0"?><st-source><!-- Name: Isam ToolboxNotice: © Copyright 1989-2016 Georg Heeg e.K.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.(MIT License)Comment: Isam Toolbox provides a simple, fast, and reliable persistancy mechanism for collections using the index sequential access method.DbIdentifier: magdi.heeg.de.postgresDbTrace: 65138DbUsername: danielDbVersion: 8.2.1 - 1DevelopmentPrerequisites: #(#(#any 'GHNamespaces' '') #(#any 'I18nRuntime' ''))InstallBeforeContinuing: MessageCatalog: isamPackageName: Isam ToolboxPackageName:: Isam ToolboxParcel: #('Isam Toolbox')ParcelDirectory: c:\visworks\vw8.2.1 dec16.1\image\HeegContributions-vw8.2.1-2017-01-16\Isam ToolboxParcelName: Isam ToolboxPrerequisiteDescriptions: #(#(#name 'GHNamespaces') #(#name 'I18nRuntime' #componentType #package))PrerequisiteParcels: #(#('GHNamespaces' '') #('I18nRuntime' ''))PrintStringCache: (8.2.1 - 1,daniel)Version: 8.2.1 - 1Date: 3:15:15 PM January 16, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.2.1 (dec16.1) of 22. Dezember 2016 on 16. Januar 2017 at 15:15:15</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Isam</name><environment>Heeg</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>As yet unclassified</category><attributes><package>Isam Toolbox</package></attributes></name-space><class><name>IsamCollection</name><environment>Heeg.Isam</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>recordClass recordStream indices currentIndexClass primaryIndexClass currentIndex streamEnd streamFragmentation inFlux dirty accessSemaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam</category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.IsamCollection</class-id><body>IsamCollection is a collection of several indices that define an ordering on keyed data.The data records and the keys are assumed to be a kind of IsamItem.Instance Variables:	accessSemaphore	&lt;Semaphore&gt;			to protect concurrent access to the recordStream	currentIndex		&lt;IsamIndex&gt;			the default index	currentIndexClass	&lt;IsamIndex class&gt;		the class of the currently selected index	dirty				&lt;Boolean&gt;			description of dirty	indices			&lt;Dictionary&gt;			associates key classes and indices	inFlux			&lt;Boolean&gt;			description of inFlux	primaryIndexClass	&lt;IsamIndex class&gt;		the class of the primary index	recordClass		&lt;IsamItem class&gt;		IsamItem subclass that describes every record	recordStream		&lt;BufferedExternalStream&gt;	a (byte) stream that holds the records.	streamEnd			&lt;ArithmeticValue&gt;		position of first free byte in stream	streamFragmentation	&lt;ArithmeticValue&gt;		number of inaccessible bytes in the stream</body></comment><class><name>ExtendedIsamCollection</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchString searchPattern filterBlock filterMode hasChanged </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam</category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.ExtendedIsamCollection</class-id><body>ExtendedIsamCollection is mainly a preparation to provide network and multi user access to IsamCollection, as well as getting user programs independent of the ways how keys are stored (so that the storage mechanism for example could be changed to B-Trees residing on the hard disk without having to applications).The main extensions are:Searching: searching for keys 'greater equal', 'less equal', 'after an item', 'before an item' ...Pattern search: By setting a search pattern, all search messages only return keys matching this pattern.Filtering: As an addition to the efficient, but restricted pattern search, filter expressions can be given for searching.Paging: As a preparation for efficent network access, all search messages return collections of keys (for example, "searchNext: 10 greaterEqual: aKey' returns the first 10 keys greater than or equal to aKey that match the current search pattern and the current filter, if given).Change flag: Every add, rewrite or remove message set the instance variable 'hasChanged' to true, so that it is possible to decide wether a isam collection has to be saved or not.Symbols for class names: All methods that require class names as parameters, also accept symbols ('selectIndex: #MyKey' instead of 'selectIndex: MyKey'). This is useful for remote access.</body></comment><class><name>SharedIsamCollection</name><environment>Heeg.Isam</environment><super>Heeg.Isam.ExtendedIsamCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clients busy globalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam</category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.SharedIsamCollection</class-id><body>A SharedIsamCollection is an ExtendedIsamCollection for multi user access. Every user is a 'client', using an instance of class IsamClient as interface. An IsamClient connects by sending the message 'addClient: self' and disconnects with the message 'removeClient: self'.Everytime a client requests service, he sends the message 'activateClient: self', which gets his environment copied in the SharedIsamCollection's instance variables (e.g. the correct current key, filters and search patterns). Furthermore, 'activateClient:' leads to a wait on semaphore busy (an instance variable), so that mutual exclusion in multi user access is guranteed. After activation, the IsamClient may send its database messages. Each time a record is removed or updated, all clients are informed about that with the messages 'pageRemove: anItem' or 'pageUpdate: anItem with: aRecord', so that they can update their current pages, if neccessary. When service is finished, the IsamClient sends 'passivateClient', which resets the busy semaphore and thereby gives other clients a chance to get service.The IsamCollection's instance creation message 'on:records:keys' is redefined in SharedIsamCollection. Receiving this message, SharedIsamCollection looks in the class variable SharedIsamFiles, whether the file is already open. If so, no new instance is created, and the instance already using this file is returned, so that the IsamClient can add itself as an additional client.</body></comment><class><name>IsamField</name><environment>Heeg.Isam</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.IsamField</class-id><body>An IsamField describes one of the fields in an IsamItem.It holds the type of the field and is therefor responsible for typechecking.IsamFields are use too for reading and writing of those fields in a dense byte form and theyknow about the size of this form for a given field.The classnames are assumed to have the following generic form:Isam&lt;Typename&gt;Field where &lt;Typename&gt; is the name given in the type declaration part of the IsamItem fields. ie. IsamIntegerField or IsamArrayOfStringField</body></comment><class><name>IsamCharacterArrayField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamAbstractSymbolField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamCharacterArrayField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamUTF8SymbolField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamAbstractSymbolField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.IsamUTF8SymbolField</class-id><body>encoding	^#utf8</body></comment><class><name>IsamFieldProxy</name><environment>Heeg.Isam</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Proxy</category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamTypedStringField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamCharacterArrayField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.IsamTypedStringField</class-id><body>IsamTypedStringField can write any string class, because it stores a type byte in front of data. The bytes of the string are written unchanged, which is faster than encoding/decoding a byte array.</body></comment><class><name>FilterExpression</name><environment>Heeg.Isam</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Filters</category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.FilterExpression</class-id><body>A FilterExpression compiles a filter expression into a block that computes this filter.Syntax is :expression := 	expression | term				expression &amp; term				termterm :=			( expression )				~ term				matchtermmatchterm :=	string = stringThe operator preceedence is = &gt; ~ &gt; &amp; &gt; |A matchterm 'string1 = string2' is compiled into an expression 'string2 match: self string1'.Thus the first string stands for a message selector that returns the terms value and the second string is matched (with wildcards * and #) against this value.</body></comment><class><name>IsamStringField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamCharacterArrayField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamUTF8StringField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamCharacterArrayField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamAbstractTextField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamTextField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamAbstractTextField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamFixedPointField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamItem</name><environment>Heeg.Isam</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>recordPosition recordLength </inst-vars><class-inst-vars>isamFields isamTypes </class-inst-vars><imports></imports><category>Files-Isam</category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.IsamItem</class-id><body>Version 3 24 January 1989I am the basic item for both records and indices.I store the recordPosition in the file and the size of that last written record.Every record is preceeded by a ValidTag. If a record is made invalid (ie. it is deleted) then it will be replaced by an InvalidTag followed by the length of the deleted record.My indexable instance variables contain the actual values.Class variable	'className'Fields stores name -&gt; variable index associations and	'className'Types stores index -&gt; type classnames associations.</body></comment><class><name>IsamCollectionField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elementField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.IsamCollectionField</class-id><body>I am the abstract superclass of all fields that store homogenous collections.elementField is a kind of IsamField that is used to operate on the elements of me</body></comment><class><name>IsamCollectionOfIntegerField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamCollectionField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamSymbolField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamAbstractSymbolField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamCollectionCharacterArrayField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamCollectionField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamPager</name><environment>Heeg.Isam</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isamCollection keyClasses currentItem currentKeyClass currentPage pageSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam</category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.IsamPager</class-id><body>An IsamPager provides a programming interface to an IsamClient (with minor changes, it will also work directly on an ExtendedIsamCollection). It bundles isam-related information such as key classes and record class and handles a paged access, providing a "currentPage" of keys momentarily visible to the application, and a "currentItem".Instead of the basic isam add/rewrite/remove protocol an isamPager provides the methods addRecord, rewriteWith: and removeRecord:, which access the current item. Some methods are more screen oriented, e.g. include prompting and cursor changes during time consuming operations.A basic enumeration protocol for isam collections is provided, as well as screen oriented standard protocol for change sort key, search patterns, page up, page down, top page and bottom page or direct positioning in a key list.In remote isam access, an application specific subclass of IsamPager should be thought of as the isam front end on the local machine, communicating with an IsamClient on the remote machine.</body></comment><class><name>IsamIndex</name><environment>Heeg.Isam</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally patternsToKeys allKeysSorted maxKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam</category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.IsamIndex</class-id><body>An IsamIndex is a SortedCollection with efficient access methods to elements.For optimization purposes the IsamIndex works internally on a dictionary of patterns -&gt; collection with keys. The pattern is an isam key item which contain only the field variables for comparing. The keys itself are full isam key instances with record length and record position. All keys that matches the same pattern are grouped, which makes accesses for Eurydike faster, because the field rows are grouped per IsamFieldRowKey which has the field #objectID.The old IsamIndex used a sorted collection and makes sequential index access. For compatibility reasons most of the index based methods are still there, but not used anymore by new frameworks like Eurydike. Because of the sorted collection it was easy to access the greatest key in index, which is just the last one. The old isam index was also written in that sequential sorted order, but it does not matter, because all records are read one by one and added one by one to the IsamIndex. So in the new framework we write the index keys in unsorted order, which is faster.Eurydike needs also the greatest key to determine the highest #objectID, so that new object ids can be created. For us it is not important to know the greatest key which is currently in the index, it is enough to know the greatest key which was ever in the index. So we do not need to worry about removing keys, we just add it and adapt the #maxKey variable. Instance Variables:	tally				-	current number of keys in index	patternsToKeys		-	a dictionary that groups isam keys by patterns	maxKey			-	the greatest key that was ever in the index, it can be that it is not in the index anymore</body></comment><class><name>IsamIntegerField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamClient</name><environment>Heeg.Isam</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isamCollection currentKeyClass searchString searchPattern filterBlock filterMode currentPage savedPages addedItem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam</category><attributes><package>Isam Toolbox</package></attributes></class><comment><class-id>Heeg.Isam.IsamClient</class-id><body>An IsamClient is the user front end of a SharedIsamCollection (a SharedIsamCollection has a collection of clients, each one representing an independent user interface). IsamClients understand most of the messages a SeperartedIsamCollection understands. Instead of sending messages directly to a SharedIsamCollection, a user should only communicate with IsamClients.An IsamClient has two main tasks:-	setting the correct user context - e.g. the current key class, filter and search 	pattern - whenever a client becomes active.-	keeping track of the change of record positions inflicted by remove or rewrite	operations of other clients.The first aim is achieved simply by keeping the current user context in instance variables which are automatically copied to the SharedIsamCollection whenever a client becomes active.The second aim is achieved by the concept of current pages. Whenever a user gets keys or records as a result of a message to an IsamClient, their record positions should be viewed as 'virtual positions'. The IsamClient keeps these virtual positions as well as their corresponding real positions in its current page. The SharedIsamCollection broadcasts all remove/rewrite operations to its clients, so that each client can update the real positions in its current page if neccessary. Whenever the user sends an item to his IsamClient, the client transforms the item's virtual position into a real position before sending it to the SharedIsamCollection.As a consequence, the user can rely only on those items whose virtual positions are stored in his client's current page (this might look like a severe restriction, but compared with traditional database approaches providing a single 'current record' instead of a current page, it is rather comfortable). The items in the current page are-	those returned from the last search message-	plus the item returned from the last add message (it remains in the page	until the page is overwritten by the next search message).For the user's convenience, there are three additional rules:-	the virtual position of an item remains unchanged across a rewrite.-	if a search message returns an empty collection, the current page	remains unchanged.-	if the backward search messages "searchNext:beforeItem" and	"searchNext:backwardFromItem:" return fewer items than the	current page has had before, then the found items will be 'rolled	into" the page, so that the page's size remains unchanged, and the	first old items are still valid (this may sound confusing, but proves	helpful when programming paged list views for isam collections).In case a user needs a new page without his current page becoming invalid for later use, the message saveCurrentPage tells an IsamClient to push its current page on a stack. The user then has a new, independent page, but can later pop the saved page by sending restoreCurrentPage. With saveCurrentPage / restoreCurrentPage working as push and pop, it is also possible to save more than one page. But it should be kept in mind that after every remove or rewrite message of any client the current pages as well as the saved pages of all clients have to be looked up (if they contain the affected key, its position must be updated).</body></comment><class><name>IsamCollectionOfStringField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamCollectionCharacterArrayField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamTimestampField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamDateField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamGermanDateField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamDateField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Buchhaltung Tools</category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamUTF8TextField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamAbstractTextField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Isam Toolbox</package></attributes></class><class><name>IsamCollectionOfUTF8StringField</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamCollectionCharacterArrayField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam Fields</category><attributes><package>Isam Toolbox</package></attributes></class><shared-variable><name>SharedIsamFiles</name><environment>Heeg.Isam.SharedIsamCollection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Isam Toolbox</package></attributes></shared-variable><shared-variable><name>InvalidTag</name><environment>Heeg.Isam.IsamItem</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Isam Toolbox</package></attributes></shared-variable><shared-variable><name>ValidTag</name><environment>Heeg.Isam.IsamItem</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Isam Toolbox</package></attributes></shared-variable><shared-variable><name>Priorities</name><environment>Heeg.Isam.FilterExpression</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Isam Toolbox</package></attributes></shared-variable><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>enumerating</category><body package="Isam Toolbox">collectRecords: aBlock  	"Evaluate aBlock with each of the records of the receiver as the  	argument.  Collect the resulting values into a collection that is like 	the receiver.  Answer the new collection."	| newCollection |	newCollection := self species new.	self recordsDo: [:each | newCollection add: (aBlock value: each)].	^newCollection</body><body package="Isam Toolbox">do: aBlock	"evaluate the block for each of my items"	currentIndex do: [:key| aBlock value: key]</body><body package="Isam Toolbox">recordsDo: aBlock 	"evaluate the block for each record"	| record |	recordStream reset.	[recordStream atEnd not and: [(record := (recordClass basicNew: recordClass fieldsDictionary size)					readNextRecordFrom: recordStream) notNil]]		whileTrue: [aBlock value: record]</body><body package="Isam Toolbox">rejectRecords: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for which	aBlock evaluates to false.  Answer the new collection."	^self selectRecords: [:element | (aBlock value: element) not]</body><body package="Isam Toolbox">selectRecords: aBlock 	"Evaluate aBlock with each of the receiver's records as the argument. 	Collect into a new collection like the receiver, only those elements for which	aBlock evaluates to true.  Answer the new collection."	| newCollection |	newCollection := self species new.	self recordsDo: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>accessing</category><body package="Isam Toolbox">as: keyClass 	"return a copy of me that uses the new index keyClass"	| copy |	copy := self copy.	copy selectIndex: keyClass.	^copy</body><body package="Isam Toolbox">atRandom: aRandom	^self shouldNotImplement</body><body package="Isam Toolbox">currentIndex	^ currentIndex</body><body package="Isam Toolbox">fragmentation	"Return the ratio of fragments and stream size"	^ streamFragmentation / recordStream size</body><body package="Isam Toolbox">indexKey	"return a new empty key for the currently selected index"	^ currentIndexClass new</body><body package="Isam Toolbox">size	"Answer how many records I contain"	^ (indices at: primaryIndexClass) size</body><body package="Isam Toolbox">streamFragmentation	"Answer the number of unused bytes"	^ streamFragmentation</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>removing</category><body package="Isam Toolbox">invalidate: key	accessSemaphore critical: 			[key invalidateRecordOn: recordStream.			streamFragmentation := streamFragmentation + key recordLength]</body><body package="Isam Toolbox">remove: item ifAbsent: aBlock	"Remove the item from the record stream and indices. The item need not to be a full	 specified record, but at least it must have an initialized record position. The full record	 is read from that record position, invalidated and is used to build the index keys from.	 The index keys can be only builded from a full record, because we do not know which	 fields are used by the index keys."	| record |	self checkFlux.	item isNil ifTrue: [^aBlock value].	inFlux := true.	dirty := true.	record := self recordAtPosition: item recordPosition.	self invalidate: record.	indices keysAndValuesDo: [:keyClass :index |		index removeKey: (keyClass new copyAllFrom: record)].	inFlux := false</body><body package="Isam Toolbox">removeAllAtPattern: aPattern	"remove all items from the stream and indices where the index key matches the pattern"	self checkFlux.	inFlux := true.	dirty := true.	indices do: 			[:index |			| keys |			keys := index allKeysAtPattern: aPattern ifAbsent: [#()].			keys do: [:key | self invalidate: key].			index removeAllKeysAtPattern: aPattern ifAbsent: []].	inFlux := false</body><body package="Isam Toolbox">removeIndex: keyClass	"remove the index associated by keyClass"	keyClass == primaryIndexClass		ifTrue: 			[^self				error: (#CannotRemoveThePrimaryKey &lt;&lt; #isam						&gt;&gt; 'Cannot remove the primary key') asString].	indices removeKey: keyClass		ifAbsent: 			[^self error: (#UnknownKey1s_ &lt;&lt; #isam &gt;&gt; 'Unknown key &lt;1s&gt;'						expandMacrosWith: keyClass name)].	dirty := true</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>adding</category><body package="Isam Toolbox">add: aRecord	"add the record to the collection. First find free space in the      	recordStream and write the data to the stream. Then add the record 	 to each index"	self checkFlux.	inFlux := true.	dirty := true.	accessSemaphore critical: 			[aRecord writeRecordAt: (self findSpace: aRecord recordSize)				on: recordStream.			streamEnd := recordStream position.			indices				keysDo: [:keyClass | (indices at: keyClass) add: (keyClass new copyAllFrom: aRecord)].			self flush].	inFlux := false.	^aRecord</body><body package="Isam Toolbox">addIndex: keyClass 	"add a new index to the indices for the key class"	| index |	inFlux := true.	dirty := true.	index := IsamIndex new.	indices at: keyClass put: index.	primaryIndexClass isNil ifTrue: [primaryIndexClass := keyClass].	self recordsDo: [:record | index add: (keyClass new copyAllFrom: record)].	inFlux := false</body><body package="Isam Toolbox">rewrite: record		^self rewrite: record with: record</body><body package="Isam Toolbox">rewrite: aRecord with: aNewRecord	"rewrite the record referenced by item with record"	self remove: aRecord ifAbsent: [nil].	self add: aNewRecord.	^aNewRecord</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>private</category><body package="Isam Toolbox">checkFlux	"Notify the user iff the flux signal is set (i.e. a change to the data was  	not finished properly)"	inFlux		ifTrue: 			[self				error: (#DataMayBeCorruptedProceedToIgnoreThis &lt;&lt; #isam						&gt;&gt; 'Data may be corrupted. Proceed to ignore this') asString.			inFlux := false]</body><body package="Isam Toolbox">compaction	"Scan all records, copy them to another file and rebuild the indices 	from them. Update the streamEnd and streamFragmentation 	information"	| s newFile |	newFile := (Filename named: 'compact.tmp' asIs) readWriteStream.	newFile binary.	s := indices keys.	streamEnd := 0.	indices := Dictionary new.	s do: [:e | indices at: e put: IsamIndex new].	self selectIndex: primaryIndexClass.	streamFragmentation := 0.	self		recordsDo: 			[:each | 			each writeRecordAt: newFile position on: newFile.			indices keysDo: [:key | (indices at: key)					add: (key new copyAllFrom: each)].			streamEnd := newFile position].	recordStream flush; close.	newFile nextPutAll: (ByteArray new: 8192).	newFile close.	(Filename named: recordStream name) delete.	(Filename named: 'compact.tmp' asIs)		renameTo: (Filename named: recordStream name).	recordStream := (Filename named: recordStream name) readWriteStream.	recordStream binary.	indices do: [:each | each reSort].	dirty := true</body><body package="Isam Toolbox">findSpace: length 	"Check if streamEnd + length runs past the end of the record stream. 	Extend it then"	streamEnd + length &gt; recordStream size		ifTrue: 			[recordStream setToEnd.			recordStream nextPutAll: (ByteArray new: 8192).			recordStream flush; close].	^streamEnd</body><body package="Isam Toolbox">primitiveAddIndex: keyClass 	"add a new index to the indices for the key class"	| index |	inFlux := true.	index := IsamIndex new.	indices at: keyClass put: index.	primaryIndexClass isNil ifTrue: [primaryIndexClass := keyClass].	inFlux := false</body><body package="Isam Toolbox">rebuildIndices	"Scan all records and rebuild the indices from them. Update the 	streamEnd and streamFragmentation information"	| s |	Transcript		show: (#IndexDataFor1sOutdatedR___dingIndicesPleaseWait_ &lt;&lt; #isam	&gt;&gt; 'Index data for &lt;1s&gt; outdated. Rebuilding indices, please wait.'					expandMacrosWith: recordStream name);		cr.	s := indices keys.	streamEnd := 0.	indices := Dictionary new.	s do: [:e | indices at: e put: IsamIndex new].	self selectIndex: primaryIndexClass.	streamFragmentation := 0.	self recordsDo: 			[:each |			indices associationsDo: 					[:assoc |					assoc value addAll: (Array with: (assoc key new copyAllFrom: each))].			each recordPosition = streamEnd				ifFalse: 					[streamFragmentation := streamFragmentation								+ (each recordPosition - streamEnd)].			streamEnd := recordStream position].	indices do: [:each | each reSort].	dirty := true</body><body package="Isam Toolbox">selectIndex: keyClass	"select the given index. Note that recordClass has special meaning and 	installs IsamItem as key"	currentIndexClass := keyClass.	currentIndex := indices at: currentIndexClass				ifAbsent: 					[^self error: (#Index1pNotAvailable &lt;&lt; #isam &gt;&gt; 'Index &lt;1p&gt; not available' expandMacrosWith: keyClass)]</body><body package="Isam Toolbox">species	"This is the class that is used to recreate me. It is used mainly by enumeration methods to obtain a collector"	^ OrderedCollection</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>record accessing</category><body package="Isam Toolbox">allRecordsAt: item 	"Return all records that are addressed by item"	| col keys |	col := OrderedCollection new.	keys := self allKeysAt: item.	keys notNil ifTrue: [keys do: [:key | col add: (self recordAtKey: key)]].	^col</body><body package="Isam Toolbox">recordAt: item 	"find the item in me. First check if item has a record position attached 	 already. If this is not true, check if one of my indices knows about  	such items. At last search my records sequentially"	| key |	item recordPosition isNil ifFalse: [^self recordAtKey: item].	key := self keyAt: item.	key isNil ifFalse: [^self recordAtKey: key].	self recordsDo: [:record | (item equal: record) ifTrue: [^record]].	^nil</body><body package="Isam Toolbox">recordAtKey: item	"return the record for the given key. Signal an error if item has no 	valid record position"	item recordPosition isNil		ifTrue: 			[^self				error: (#UseRecordAtToFindARecordForThisItem &lt;&lt; #isam						&gt;&gt; 'Use recordAt: to find a record for this item') asString].	^self recordAtPosition: item recordPosition</body><body package="Isam Toolbox">recordAtPosition: position	"return the record at the given position"	^accessSemaphore		critical: [recordClass new readRecordAt: position from: recordStream]</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>file accessing</category><body package="Isam Toolbox">close	"close my recordStream"	recordStream closed		ifFalse: 			[recordStream setToEnd.			recordStream close.			dirty := false]</body><body package="Isam Toolbox">flush	"flush all written data to the stream"	recordStream flush</body><body package="Isam Toolbox">loadFrom: filename	"load my data from the file."	| indexFile |	inFlux := true.	recordStream notNil ifTrue: [self close].	recordStream := ((Filename named: filename , '.dat' asIs) withEncoding: #binary ) readWriteStreamExclusively.	indexFile := (Filename named: filename , '.idx' asIs) readWriteStream.	indexFile binary.	self readFrom: indexFile.	indexFile close.	recordStream position: streamEnd.	dirty := false.	(recordStream atEnd or: [recordStream next ~= 0])		ifTrue: 			["index data is outdated"			inFlux := false.			self rebuildIndices.			self saveTo: filename.			inFlux := true].	self selectIndex: primaryIndexClass.	inFlux := false</body><body package="Isam Toolbox">recordData	"Return the byte array currently stored in the stream"	^recordStream contents</body><body package="Isam Toolbox">saveTo: filename 	"save the indices to the given file. If my recordStream has a different 	filename, then save it too"	| indexFile recordFile |	self checkFlux.	indexFile := (Filename named: filename , '.idx' asIs) writeStream.	indexFile binary.	self writeOn: indexFile.	indexFile close.	recordStream name = (filename , '.dat' asIs)		ifFalse: 			[recordFile := (Filename named: filename , '.dat' asIs) readWriteStream.			recordFile binary.			recordFile nextPutAll: self recordData.			recordStream := recordFile.			recordFile close].	recordStream reopen</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>testing</category><body package="Isam Toolbox">includesItem: item	"true iff I contain item"	^ (self recordAt: item) notNil</body><body package="Isam Toolbox">isDirty	"True, if the data should be written to a file prior shutdown"	^ dirty</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>key accessing</category><body package="Isam Toolbox">allKeysAt: item 	"find and return all keys matching item"	^ (indices at: item class ifAbsent: [^nil])		findAllKeys: item</body><body package="Isam Toolbox">keyAt: item 	"find and return the key matching item"	item recordPosition notNil		ifTrue: [^self keyOf: (indices at: item class ifAbsent: [^self keyAtPosition: item recordPosition])				atPosition: item recordPosition]		ifFalse: [^(indices at: item class ifAbsent: [^nil])				findKey: item]</body><body package="Isam Toolbox">keyAtPosition: position 	"return the key for the record at the given position. Used for chaining 	index accessing"	^ self keyOf: currentIndex atPosition: position</body><body package="Isam Toolbox">keyOf: index atPosition: position 	"return the key for the record at the given position. Used for chaining 	index accessing"	index do: [:key | key recordPosition = position ifTrue: [^key]].	^ nil</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>initialize-release</category><body package="Isam Toolbox">initialize	"initialize the important instance variables"	super initialize.	indices := Dictionary new.	streamEnd := 0.	streamFragmentation := 0.	inFlux := false.	dirty := false.	accessSemaphore := Semaphore forMutualExclusion</body><body package="Isam Toolbox">on: filename records: rClass keys: collection	"Setup the internal data"	| indexFilename datFilename shouldRebuildIndices |	indexFilename := Filename named: filename , '.idx' asIs.	(indexFilename exists and: [indexFilename fileSize &gt; 0])		ifTrue: 			["ISAM files exist"			self loadFrom: filename]		ifFalse: 			[datFilename := Filename named: filename , '.dat' asIs.			shouldRebuildIndices := datFilename exists.			recordStream := (datFilename withEncoding: #binary) readWriteStreamExclusively.			recordClass := rClass.			collection do: 					[:each |					self						primitiveAddIndex: ((LiteralBindingReference pathString: each)								method: thisContext method) value].			self selectIndex: primaryIndexClass.			shouldRebuildIndices ifTrue: [self rebuildIndices]]</body><body package="Isam Toolbox">release	| keys |	super release.	currentIndexClass := nil.	currentIndex := nil.	keys := OrderedCollection new.	indices keysDo: [:each | keys add: each].	keys do: [:each | indices removeKey: each].	keys := nil.	self close.	recordStream := nil</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>checking</category><body package="Isam Toolbox">checkForOverlappings: collection 	"check the collection of IsamItems for overlappings"	| s t |	s := collection asSortedCollection: [:a :b | a recordPosition &lt; b recordPosition].	t := -1.	s do: 		[:each | 		each recordPosition &lt; t ifTrue: [^true].		t := each recordPosition + each recordLength].	^ false</body><body package="Isam Toolbox">checkIndicesAgainstRecords	"check the index data against the actual records. Note! check the 	indices first for overlappings"	self recordsDo: 			[:record |			indices do: 					[:index |					((self keyOf: index atPosition: record recordPosition) equal: record)						ifFalse: 							[^self								error: (#ConflictBetweenRecordDataAndIndex1p_ &lt;&lt; #isam										&gt;&gt; 'Conflict between record data and index &lt;1p&gt;'											expandMacrosWith: (indices keyAtValue: index))]]]</body><body package="Isam Toolbox">checkIndicesForOverlappings	"check my indices for conflicts with themself and the free record list"	| size |	size := self size.	indices do: 			[:each |			each size = size				ifFalse: 					[^self error: (#Index1pHasASizeConflict_ &lt;&lt; #isam &gt;&gt; 'Index &lt;1p&gt; has a size conflict.'								expandMacrosWith: (indices keyAtValue: each))]].	indices do: 			[:each |			(self checkForOverlappings: each asOrderedCollection)				ifTrue: 					[^self error: (#Index1pConflicts_ &lt;&lt; #isam &gt;&gt; 'Index &lt;1p&gt; conflicts.'								expandMacrosWith: (indices keyAtValue: each))]]</body><body package="Isam Toolbox">checkIntegrity	"check the indices against themself and the records"	Cursor wait		showWhile: 			[self checkIndicesForOverlappings.			self checkIndicesAgainstRecords]</body></methods><methods><class-id>Heeg.Isam.IsamCollection</class-id> <category>printing</category><body package="Isam Toolbox">printOn: aStream	"write a shorthand description of me to the stream"	aStream		nextPutAll: recordClass printString;		nextPut: $(.	indices keysDo: 			[:keyClass |			aStream				nextPutAll: keyClass printString;				space].	aStream		nextPutAll: ') (' asIs;		nextPutAll: self size printString;		nextPutAll: ') ' asIs</body><body package="Isam Toolbox">readFrom: stream	"read all my data from the stream"	| index size reader key |	reader := IsamStringField new.	recordClass := ((LiteralBindingReference pathString: (reader readFrom: stream))				method: thisContext method) value.	primaryIndexClass := ((LiteralBindingReference pathString: (reader readFrom: stream))				method: thisContext method) value.	streamEnd := reader readIntegerFrom: stream.	streamFragmentation := reader readIntegerFrom: stream.	[stream atEnd] whileFalse: 			[key := ((LiteralBindingReference pathString: (reader readFrom: stream))						method: thisContext method) value.			size := reader readIntegerFrom: stream.			index := IsamIndex new: size.			1 to: size do: [:i | index add: (key new readFrom: stream)].			indices at: key put: index]</body><body package="Isam Toolbox">writeOn: stream 	"write my data to the stream"	| writer index|	writer := IsamStringField new.	writer write: recordClass name to: stream.	writer write: primaryIndexClass name to: stream.	writer writeInteger: streamEnd to: stream.	writer writeInteger: streamFragmentation to: stream.	indices keysDo: 		[:keyClass | 		index := indices at: keyClass.		writer write: keyClass name to: stream.		writer writeInteger: index size to: stream.		index do: [:key | key writeOn: stream]]</body></methods><methods><class-id>Heeg.Isam.IsamCollection class</class-id> <category>instance creation</category><body package="Isam Toolbox">new	^ super new initialize</body><body package="Isam Toolbox">on: fileName records: recordClass keys: collectionOfKeyClasses 	"Open an IsamCollection on fileName. Use the given record and key 	classes. If fileName.idx already exists then load it (this overrides the 	record and key classes)"	^self new		on: fileName		records: recordClass		keys: collectionOfKeyClasses</body></methods><methods><class-id>Heeg.Isam.ExtendedIsamCollection</class-id> <category>searching</category><body package="Isam Toolbox">searchAll	"search all keys fitting into the given filter according to searchKey"	^self searchNext: self size forwardFrom: 1</body><body package="Isam Toolbox">searchFirst: count 	^self searchNext: count forwardFrom: 1</body><body package="Isam Toolbox">searchLast: count 	^self searchNext: count backwardFrom: self size</body><body package="Isam Toolbox">searchNext: count afterItem: anItem 	"same as searchNext:forwardFrom:, except that an item is given instead of 	a position, and we don't search for the item itself"	| start |	(start := self findIndexOf: anItem) isNil ifTrue: [^OrderedCollection new].	^self searchNext: count forwardFrom: start + 1</body><body package="Isam Toolbox">searchNext: count backwardFromItem: anItem	"same as searchNext:backwardFrom:, except that an item is given instead of 	a position"	| start |	(start := self findIndexOf: anItem) isNil ifTrue: [^OrderedCollection new].	^self searchNext: count backwardFrom: start</body><body package="Isam Toolbox">searchNext: count beforeItem: anItem	"same as searchNext:backwardFrom:, except that an item is given instead of 	a position, and we don't search for the item itself"	| start |	(start := self findIndexOf: anItem) isNil ifTrue: [^OrderedCollection new].	^self searchNext: count backwardFrom: start - 1</body><body package="Isam Toolbox">searchNext: count forwardFromItem: anItem 	"same as searchNext:forwardFrom:, except that an item is given instead of 	a position"	| start |	(start := self findIndexOf: anItem) isNil ifTrue: [^OrderedCollection new].	^self searchNext: count forwardFrom: start</body><body package="Isam Toolbox">searchNext: count greaterEqual: aKey 	"search for the first key greater than or equal to aKey. Return the next 	count items according to searchPattern as an OrderedCollection"	| index |	aKey notNil		ifTrue: 			[index := currentIndex indexOfGreaterEqual: aKey ifAbsent: [].			index isNil ifTrue: [^OrderedCollection new]]		ifFalse: [index := 1].	^self searchNext: count forwardFrom: index</body><body package="Isam Toolbox">searchNext: count lessEqual: aKey 	"search for the last key less than or equal to aKey. Return the previous 	count items according to searchPattern as an OrderedCollection"	| index |	aKey notNil		ifTrue: 			[index := currentIndex indexOfLessEqual: aKey ifAbsent: [].			index isNil ifTrue: [^OrderedCollection new]]		ifFalse: [index := 1].	^self searchNext: count backwardFrom: index</body><body package="Isam Toolbox">setFilterBlock: aFilter applyTo: keysOrRecords	"set filterBlock to the result result of compiling aFilter. Store in filterMode whether to apply filterBlock to keys (applyTo: #keys) or to records (applyTo: #records)"	filterBlock := aFilter. "this is for nil filters"	aFilter notNil ifTrue: [filterBlock := (FilterExpression fromString: aFilter) filter].	filterMode := keysOrRecords</body><body package="Isam Toolbox">setSearchPattern: aPattern 	"Memorize aPattern as well as its fully qualified part before its first 	wildcard in my instance variables. My pattern search methods will use 	these variables"	| firstWildCard oldPattern |	oldPattern := searchPattern.	aPattern isNil ifTrue: [^searchPattern := nil].	searchPattern := aPattern copy.	firstWildCard := self indexOfFirstWildCardIn: aPattern.	firstWildCard == 0		ifTrue: [searchString := aPattern copy]		ifFalse: [firstWildCard == 1				ifTrue: [searchString := nil]				ifFalse: [searchString := aPattern copyFrom: 1 to: firstWildCard - 1]].	^oldPattern</body></methods><methods><class-id>Heeg.Isam.ExtendedIsamCollection</class-id> <category>index selection</category><body package="Isam Toolbox">isamSelectIndex: keyClass 	"this method gives subclasses the chance to use the original selectindex: 	protocol in IsamCollection"	super selectIndex: keyClass</body><body package="Isam Toolbox">selectIndex: keyClass 	"a given search pattern or a key filter usually don't make sense for 	another index. 	Furthermore, as a preparation for remote access, selectIndex should be 	called with 	a symbol instead of a class name"	self setSearchPattern: nil.	filterMode == #keys ifTrue: [filterMode := #records].	super selectIndex: (keyClass isSymbol			ifTrue: [((LiteralBindingReference pathString: keyClass) method: thisContext method) value]			ifFalse: [keyClass])</body></methods><methods><class-id>Heeg.Isam.ExtendedIsamCollection</class-id> <category>change flag</category><body package="Isam Toolbox">compaction	super compaction.	hasChanged := true</body><body package="Isam Toolbox">hasChanged	^hasChanged</body><body package="Isam Toolbox">hasChanged: aBoolean	hasChanged := aBoolean</body></methods><methods><class-id>Heeg.Isam.ExtendedIsamCollection</class-id> <category>record access</category><body package="Isam Toolbox">getAllRecords	"return all records that fit into the current filter according to searchKey.	This is a very simple and stupid implementation"	^self getRecordsFor: self searchAll</body><body package="Isam Toolbox">getRecordsFor: aKeyPage	"aKeyPage is an OrderedCollection of Associations as returned by the search methods. getRecords returns all records pointed to by the keys in aKeyPage"	| records |	records := OrderedCollection new: aKeyPage size.	aKeyPage do: [:each | records addLast: (self recordAtKey: each)].	^records</body></methods><methods><class-id>Heeg.Isam.ExtendedIsamCollection</class-id> <category>private</category><body package="Isam Toolbox">findIndexOf: anItem	"tell the position of anItem in the current index"	| searchKey index recPos |	searchKey := currentIndexClass new copyFrom: anItem.	index := currentIndex indexOf: searchKey ifAbsent: [^nil].	(recPos := anItem recordPosition) ~~ nil		ifTrue: 			[index to: self size				do: 					[:i |					searchKey := currentIndex at: i.					searchKey recordPosition = recPos ifTrue: [^i].					(searchKey equal: anItem) ifFalse: [^nil]]]		ifFalse: 			[index to: self size				do: 					[:i |					searchKey := currentIndex at: i.					((self recordAtPosition: searchKey recordPosition)						equal: anItem) ifTrue: [^i].					(searchKey less: anItem) ifFalse: [^nil]]]</body><body package="Isam Toolbox">fitsToFilter: index	"return true if the item at index fullfills the given filter condition"	filterBlock isNil ifTrue: [^true].	filterMode == #keys ifTrue: [^filterBlock value: (self currentIndex at: index)].	^filterBlock value: (self recordAtPosition: (self currentIndex at: index) recordPosition)</body><body package="Isam Toolbox">getNext: count backwardFrom: start 	"get upto count keys, starting at start in the current index. Return them  	as anOrderedCollection"	| keys |	keys := OrderedCollection new: count.	start to: 1 by: -1 do: 		[:i | 		(self fitsToFilter: i)			ifTrue: 				[keys addFirst: (currentIndex at: i).				keys size &gt;= count ifTrue: [^keys]]].	^keys</body><body package="Isam Toolbox">getNext: count forwardFrom: start 	"get upto count keys, starting at start in the current index. Return them  	as anOrderedCollection"	| keys |	keys := OrderedCollection new: count.	start to: self size do: 		[:i | 		(self fitsToFilter: i)			ifTrue: 				[keys addLast: (currentIndex at: i).				keys size &gt;= count ifTrue: [^keys]]].	^keys</body><body package="Isam Toolbox">indexOfFirstWildCardIn: aPattern	"return the index of the first '*' or '#' in aPattern, or 0, if aPattern doesn't contain thes characters"	| i |	i := 1.	aPattern do: 			[:c |			(c == $* or: [c == $#]) ifTrue: [^i].			i := i + 1].	^0</body><body package="Isam Toolbox">searchNext: count backwardFrom: start 	"search for upto count keys matching the pattern defined by the instance 	variables (searchString , restPattern). Return all found keys as an 	OrderedCollection"	| index searchKey foundKeys string stopString |	(searchPattern isNil or: [currentIndexClass canBeSearchedByPattern not])		ifTrue: [^self getNext: count backwardFrom: start].	foundKeys := OrderedCollection new: count.	searchKey := currentIndexClass new.	searchString notNil		ifTrue: 			[searchKey at: 1 put: searchString , (String with: 255 asCharacter).			index := currentIndex indexOfLessEqual: searchKey ifAbsent: [].			index isNil ifTrue: [^foundKeys].			index := index min: start.			stopString := searchString]		ifFalse: 			[index := start.			stopString := String with: 1 asCharacter].	index to: 1 by: -1 do: 		[:i | 		(string := (currentIndex at: i)					at: 1) &lt; stopString ifTrue: [^foundKeys].		((searchPattern match: string) and: [self fitsToFilter: i])			ifTrue: 				[foundKeys addFirst: (currentIndex at: i).				foundKeys size &gt;= count ifTrue: [^foundKeys]]].	^foundKeys</body><body package="Isam Toolbox">searchNext: count forwardFrom: start 	"search for upto count keys matching the pattern defined by the instance 	variables (searchString , restPattern). Return all found keys as an 	OrderedCollection"	| index searchKey foundKeys string stopString |	(searchPattern isNil or: [currentIndexClass canBeSearchedByPattern not])		ifTrue: [^self getNext: count forwardFrom: start].	foundKeys := OrderedCollection new: count.	searchKey := currentIndexClass new.	searchString notNil		ifTrue: 			[searchKey at: 1 put: searchString.			index := currentIndex indexOfGreaterEqual: searchKey ifAbsent: [].			index isNil ifTrue: [^foundKeys].			index := index max: start.			stopString := searchString copy , (String with: 255 asCharacter)]		ifFalse: 			[index := start.			stopString := String with: 255 asCharacter].	index to: self size do: 		[:i | 		(string := (currentIndex at: i)					at: 1) &gt;= stopString ifTrue: [^foundKeys].		((searchPattern match: string) and: [self fitsToFilter: i])			ifTrue: 				[foundKeys addLast: (currentIndex at: i).				foundKeys size &gt;= count ifTrue: [^foundKeys]]].	^foundKeys</body></methods><methods><class-id>Heeg.Isam.ExtendedIsamCollection</class-id> <category>add/rewrite/remove</category><body package="Isam Toolbox">add: aRecord 	"this is apreparation for remote access. add: sets recordPosition in aRecord. 	Using remote access, the sender of add: can't share aRecord anymore; 	therefore aRecord is explicitly returned"	super add: aRecord.	hasChanged := true.	^aRecord</body><body package="Isam Toolbox">remove: anItem ifAbsent: aBlock	super remove: anItem ifAbsent: aBlock.	hasChanged := true</body><body package="Isam Toolbox">rewrite: item with: record	"see comment of add:"	super remove: item ifAbsent: [].	self add: record.	^record</body></methods><methods><class-id>Heeg.Isam.ExtendedIsamCollection</class-id> <category>initialize-release</category><body package="Isam Toolbox">on: filename records: records keys: keys 	"as a preparation for remote access, allow records to be a symbol as well 	as a class name"	super		on: filename		records: (records isSymbol				ifTrue: [((LiteralBindingReference pathString: records) method: thisContext method) value]				ifFalse: [records])		keys: keys.	hasChanged := false</body></methods><methods><class-id>Heeg.Isam.SharedIsamCollection</class-id> <category>clients</category><body package="Isam Toolbox">activateClient: aClient	busy wait.	searchString := aClient searchString.	searchPattern := aClient searchPattern.	filterBlock := aClient filterBlock.	filterMode := aClient filterMode.	self isamSelectIndex: aClient currentKeyClass</body><body package="Isam Toolbox">addClient: aClient 	busy critical: [clients add: aClient]</body><body package="Isam Toolbox">numberOfClients	^clients size</body><body package="Isam Toolbox">passivateClient	busy signal</body><body package="Isam Toolbox">removeClient: aClient 	"remove aClient from my collection of clients. If it was my last client, I   	close"	busy		critical: 			[clients remove: aClient.			clients size = 0				ifTrue: 					[self saveTo: globalName asString.					self release]]</body><body package="Isam Toolbox">removeClientNoSaving: aClient 	"remove aClient from my collection of clients. If it was my last client, I    	close without saving"	busy		critical: 			[clients remove: aClient.			clients size = 0 ifTrue: [self release]]</body></methods><methods><class-id>Heeg.Isam.SharedIsamCollection</class-id> <category>removing</category><body package="Isam Toolbox">remove: anItem ifAbsent: aBlock 	"remove anItem and tell it to all my clients, so that they can remove it 	from their current page, if neccessary"	clients do: [:each | each pageRemove: anItem].	super remove: anItem ifAbsent: aBlock</body><body package="Isam Toolbox">rewrite: anItem with: aRecord	"rewrite anItem with aRecord and tell it to all my clients, so that they 	can update their current page, if neccessary"		| oldItem |	oldItem := anItem copy.	super rewrite: oldItem with: aRecord.	clients do: [:each | each pageUpdate: oldItem with: aRecord].	^aRecord</body></methods><methods><class-id>Heeg.Isam.SharedIsamCollection</class-id> <category>initialize-release</category><body package="Isam Toolbox">globalName: aSymbol	globalName := aSymbol.	clients := OrderedCollection new.	busy := Semaphore forMutualExclusion</body><body package="Isam Toolbox">release	super release.	SharedIsamFiles removeKey: globalName ifAbsent: []</body></methods><methods><class-id>Heeg.Isam.SharedIsamCollection</class-id> <category>saving</category><body package="Isam Toolbox">saveTo: aFile	"try to avoid multiple saving by different users"	aFile = globalName asString		ifTrue: [hasChanged ifTrue: [super saveTo: aFile. hasChanged := false]]		ifFalse: [super saveTo: aFile].</body></methods><methods><class-id>Heeg.Isam.SharedIsamCollection class</class-id> <category>instance creation</category><body package="Isam Toolbox">on: filename records: records keys: keys	"if there is already a SharedIsamCollection on filename, then return it.	Otherwise create one"	| new globalName |	globalName := filename asSymbol.	new := SharedIsamFiles at: globalName ifAbsent: [nil].	new isNil		ifTrue:			[new := super on: filename records: records keys: keys.			new globalName: globalName.			SharedIsamFiles at: globalName put: new].	^new</body></methods><methods><class-id>Heeg.Isam.SharedIsamCollection class</class-id> <category>class initialization</category><body package="Isam Toolbox">initialize	"SharedIsamCollection initialize"	SharedIsamFiles := IdentityDictionary new</body></methods><methods><class-id>Heeg.Isam.IsamField</class-id> <category>comparing</category><body package="Isam Toolbox">equal: field1 to: field2	"return true if field1 equals field2"	^ field1 = field2</body><body package="Isam Toolbox">greater: field1 than: field2	"return true if field1 is greater than field2"	^ field1 &gt; field2</body><body package="Isam Toolbox">greaterOrEqual: field1 than: field2	"return true if field1 is greater than field2"	^ field1 &gt;= field2</body><body package="Isam Toolbox">less: field1 than: field2	"return true if field1 is less than field2"	^ field1 &lt; field2</body><body package="Isam Toolbox">lessOrEqual: field1 than: field2	"return true if field1 is less or equal than field2"	^ field1 &lt;= field2</body></methods><methods><class-id>Heeg.Isam.IsamField</class-id> <category>reading-writing</category><body package="Isam Toolbox">readByteArrayFrom: aStream	"read a ByteArray from the stream"	| length |	length := self readIntegerFrom: aStream.	^aStream next: length</body><body package="Isam Toolbox">readFrom: byteStream	"read a value from the byteStream"	^self subclassResponsibility</body><body package="Isam Toolbox">readIntegerFrom: aStream 	"read a byte description of an integer from the stream"	| length negative result shiftCount |	length := aStream next.	(length bitAnd: 128) = 0		ifFalse: 			[length := length bitAnd: 127.			negative := true]		ifTrue: [negative := false].	length = 1 ifTrue: [negative			ifTrue: [^0 - aStream next]			ifFalse: [^aStream next]].	length &lt;= 4		ifTrue: 			[result := 0.			shiftCount := 0.			[length &gt; 0]				whileTrue: 					[result := result + (aStream next bitShift: shiftCount).					length := length - 1.					shiftCount := shiftCount + 8].			negative				ifTrue: [^0 - result]				ifFalse: [^result]].	result := Integer new: length neg: negative.	1 to: length do: [:i | result digitAt: i put: aStream next].	^result</body><body package="Isam Toolbox">write: value to: byteStream	"write the value in byte form to the byteStream"	^ self subclassResponsibility</body><body package="Isam Toolbox">writeByteArray: aByteArray to: aStream 	"write the Bytes to the stream."	self writeInteger: aByteArray size to: aStream.	aStream nextPutAll: aByteArray</body><body package="Isam Toolbox">writeInteger: anInt to: aStream	"store a binary description of the int for fast reading. The int fields 	are preceeded by a byte for the number of indexable fields. If the 	number is negative, then this byte has bit 8 set"	| i |	anInt &gt; 0		ifTrue: 			[anInt &lt; 256				ifTrue: 					[aStream						nextPut: 1;						nextPut: anInt.					^self]				ifFalse: 					[anInt &lt; 65536						ifTrue: 							[aStream								nextPut: 2;								nextPut: (anInt bitAnd: 255);								nextPut: (anInt bitShift: -8).							^self]						ifFalse: 							[anInt &lt; 16777216								ifTrue: 									[aStream										nextPut: 3;										nextPut: (anInt bitAnd: 255);										nextPut: ((anInt bitShift: -8) bitAnd: 255);										nextPut: (anInt bitShift: -16).									^self]]].			i := anInt digitLength.			aStream nextPut: i]		ifFalse: 			[i := anInt digitLength.			aStream nextPut: (i bitOr: 128)].	1 to: i do: [:j | aStream nextPut: (anInt digitAt: j)]</body></methods><methods><class-id>Heeg.Isam.IsamField</class-id> <category>searching</category><body package="Isam Toolbox">canBeSearchedByPattern	"return true, if a key with this type of field as its first component can be 	searched using the pattern search methods in SeparatedIsamCollection. 	Since this methods may be applied only to special subclasses of me (e.g. 	string fields), I return false by default"	^false</body></methods><methods><class-id>Heeg.Isam.IsamField</class-id> <category>accessing</category><body package="Isam Toolbox">byteArraySizeOf: aByteArray	"return the number of bytes for this string + the number of bytes to store the string size"	| size |	size := aByteArray size.	^size + (self integerSizeOf: size)</body><body package="Isam Toolbox">byteSizeOf: value	"return the number of bytes the concrete value would use up"	^ self subclassResponsibility</body><body package="Isam Toolbox">check: value	"return true iff value is of the correct type"	^self subclassResponsibility</body><body package="Isam Toolbox">integerSizeOf: anInt	"return the number of bytes for this integer"		^ anInt digitLength + 1</body><body package="Isam Toolbox">type	"the class name for this field"	^ nil</body></methods><methods><class-id>Heeg.Isam.IsamField class</class-id> <category>instance creation</category><body package="Isam Toolbox">type: aString	"return a IsamField symbol for the given type"	| classname |	classname := 'Isam&lt;1s&gt;Field' asIs expandMacrosWith: aString.	^self allSubclasses detect: [:aClass | aClass name asString = classname]</body></methods><methods><class-id>Heeg.Isam.IsamCharacterArrayField</class-id> <category>converting</category><body package="Isam Toolbox">asByteArray: aString	^aString asByteArrayEncoding: self class encoding</body><body package="Isam Toolbox">asString: aByteArray	^aByteArray asStringEncoding: self class encoding</body></methods><methods><class-id>Heeg.Isam.IsamCharacterArrayField</class-id> <category>accessing</category><body package="Isam Toolbox">byteSizeOf: aString	^self byteArraySizeOf: (self asByteArray: aString)</body><body package="Isam Toolbox">check: value	^ value isString</body><body package="Isam Toolbox">type	^self subclassResponsibility</body></methods><methods><class-id>Heeg.Isam.IsamCharacterArrayField</class-id> <category>reading-writing</category><body package="Isam Toolbox">readFrom: aStream	^self asString: (self readByteArrayFrom: aStream)</body><body package="Isam Toolbox">write: value to: aStream	| newValue |	newValue := self asByteArray: value.	^self writeByteArray: newValue to: aStream</body></methods><methods><class-id>Heeg.Isam.IsamCharacterArrayField</class-id> <category>searching</category><body package="Isam Toolbox">canBeSearchedByPattern	"Yes! If I am the first component of a key, this key can be searched using 	the pattern search methods of SeparatedIsamCollection."	^true</body></methods><methods><class-id>Heeg.Isam.IsamCharacterArrayField class</class-id> <category>accessing</category><body package="Isam Toolbox">encoding	^self subclassResponsibility</body></methods><methods><class-id>Heeg.Isam.IsamAbstractSymbolField</class-id> <category>reading-writing</category><body package="Isam Toolbox">readFrom: aStream	^(super readFrom: aStream) asSymbol</body></methods><methods><class-id>Heeg.Isam.IsamUTF8SymbolField</class-id> <category>accessing</category><body package="Isam Toolbox">type	^'UTF8Symbol' asIs</body></methods><methods><class-id>Heeg.Isam.IsamUTF8SymbolField class</class-id> <category>accessing</category><body package="Isam Toolbox">encoding	^#utf8</body></methods><methods><class-id>Heeg.Isam.IsamFieldProxy</class-id> <category>accessing</category><body package="Isam Toolbox">equal: a to: b	^self field equal: a to: b</body><body package="Isam Toolbox">field	field isNil ifTrue: [field := (IsamField type: self type) new].	^field</body><body package="Isam Toolbox">type	^type</body><body package="Isam Toolbox">type: aString	type := aString</body></methods><methods><class-id>Heeg.Isam.IsamFieldProxy</class-id> <category>error handling</category><body package="Isam Toolbox">doesNotUnderstand: aMessage 	^self field perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>Heeg.Isam.IsamFieldProxy class</class-id> <category>instance creation</category><body package="Isam Toolbox">type: aString	^self new type: aString</body></methods><methods><class-id>Heeg.Isam.IsamTypedStringField</class-id> <category>accessing</category><body package="Isam Toolbox">byteSizeOf: value	^1 + (self integerSizeOf: value basicSize) + value basicSize</body><body package="Isam Toolbox">type	^'TypedString' asIs</body><body package="Isam Toolbox">typeFromID: aTypeID	String		allSubclassesDo: [:each | each isamTypedStringFieldID = aTypeID ifTrue: [^each]].	^self error: 'isam string type class not found'</body><body package="Isam Toolbox">typeIDFromValue: value	^value isamTypedStringFieldID</body></methods><methods><class-id>Heeg.Isam.IsamTypedStringField</class-id> <category>reading-writing</category><body package="Isam Toolbox">readFrom: byteStream	| typeID type bytes |	typeID := byteStream next.	type := self typeFromID: typeID.	bytes := self readByteArrayFrom: byteStream.	^bytes changeClassTo: type</body><body package="Isam Toolbox">write: value to: byteStream	byteStream nextPut: (self typeIDFromValue: value).	self writeByteArray: value convertToByteArray to: byteStream</body></methods><methods><class-id>Heeg.Isam.FilterExpression</class-id> <category>compiling</category><body package="Isam Toolbox">buildFilter: source	"Build a block context from source"	^Compiler new		evaluate: source		in: nil		receiver: self		notifying: nil		ifFail: [^self error: (#Error &lt;&lt; #isam &gt;&gt; 'Error') asString]</body><body package="Isam Toolbox">compileFilter	"Translate the expression to a smalltalk block expression and compile it then"	| tokens parseTree filterText|	tokens := ReadStream on: (Scanner new scanTokens: expression).	parseTree := self parseExpression: tokens.	filterText := self translateTree: parseTree.	^self buildFilter: filterText</body><body package="Isam Toolbox">filter	^ self compileFilter</body><body package="Isam Toolbox">parseExpression: tokens 	"Parse an expression"	| tree token next node expressionFirst |	expressionFirst := tokens peek isMemberOf: Array.	tree := self parseTerm: tokens.	[tokens atEnd]		whileFalse: 			[token := tokens next.			next := self parseTerm: tokens.			(Priorities at: token)				&lt;= (Priorities at: (tree at: 1)) | expressionFirst				ifTrue: 					[tree := Array								with: token								with: tree								with: next.					expressionFirst := false]				ifFalse: 					[node := Array								with: token								with: (tree at: 3)								with: next.					tree at: 3 put: node]].	^tree</body><body package="Isam Toolbox">parseMatchterm: tokens 	"Parse a matchterm (string = string)"	| left |	left := tokens next.	tokens next ~= #= ifTrue: [^self error: (#_Expected &lt;&lt; #isam &gt;&gt; '= expected') asString].	^Array		with: #=		with: left		with: tokens next</body><body package="Isam Toolbox">parseTerm: tokens 	"Parse a term"	(tokens peek isMemberOf: Array)		ifTrue: [^self parseExpression: (ReadStream on: tokens next)].	tokens peek == #~		ifTrue: 			[tokens next.			^Array with: #~ with: (self parseTerm: tokens)].	^self parseMatchterm: tokens</body><body package="Isam Toolbox">translateTree: tree 	"Translate the parse tree into a boolean expression"	| source |	source := WriteStream on: String new.	source nextPutAll: '[:each| ' asIs.	self translateTree: tree on: source.	source nextPut: $].	^source contents</body><body package="Isam Toolbox">translateTree: tree on: source 	"Translate the parse tree into a boolean expression"	| token |	token := tree at: 1.	source nextPut: $(.	token == #~		ifTrue: 			[source nextPutAll: '('.			self translateTree: (tree at: 2) on: source.			source nextPutAll: ') not']		ifFalse: [token == #|				ifTrue: 					[self translateTree: (tree at: 2) on: source.					source nextPutAll: ' or: ['.					self translateTree: (tree at: 3) on: source.					source nextPut: $]]				ifFalse: [token == #&amp;						ifTrue: 							[self translateTree: (tree at: 2) on: source.							source nextPutAll: ' and: ['.							self translateTree: (tree at: 3) on: source.							source nextPut: $]]						ifFalse: [source nextPutAll: (tree at: 3) printString; nextPutAll: ' match: each '; nextPutAll: (tree at: 2) printString; nextPutAll: ' printString']]].	source nextPut: $)</body></methods><methods><class-id>Heeg.Isam.FilterExpression</class-id> <category>accessing</category><body package="Isam Toolbox">expression	"The expression before compilation"	^ expression</body><body package="Isam Toolbox">expression: aString	"Set the high-level statement"	expression := aString</body></methods><methods><class-id>Heeg.Isam.FilterExpression</class-id> <category>composing</category><body package="Isam Toolbox">intersect: aFilterexpression	"Intersect both filter expressions"	| s |	s := WriteStream on: String new.	s		nextPut: $(;		nextPutAll: self expression;		nextPutAll: ') &amp; (' asIs.	s		nextPutAll: aFilterexpression expression;		nextPut: $).	^self class new expression: s contents</body><body package="Isam Toolbox">join: aFilterexpression	"Join both filter expressions"	| s |	s := WriteStream on: String new.	s		nextPut: $(;		nextPutAll: self expression;		nextPutAll: ') | (' asIs;		nextPutAll: aFilterexpression expression;		nextPut: $).	^self class new expression: s contents</body></methods><methods><class-id>Heeg.Isam.FilterExpression</class-id> <category>printing</category><body package="Isam Toolbox">formatExpression	"Format the expression"	| tokens parseTree s |	tokens := ReadStream on: (Scanner new scanTokens: expression).	parseTree := self parseExpression: tokens.	s := WriteStream on: self class new.	self		formatExpression: parseTree		prio: 0		level: 0		on: s.	^s contents</body><body package="Isam Toolbox">formatExpression: parseTree prio: prio level: level on: stream	"Format the expression"	| token |	token := parseTree at: 1.	(Priorities at: token) &lt; prio		ifTrue: 			[stream nextPut: $(.			self				formatExpression: parseTree				prio: 0				level: level + 2				on: stream.			^stream nextPut: $)].	token = #~		ifTrue: 			[stream nextPut: $~.			^self				formatExpression: (parseTree at: 2)				prio: (Priorities at: token)				level: level				on: stream].	token = #&amp;		ifTrue: 			[self				formatExpression: (parseTree at: 2)				prio: (Priorities at: token)				level: level				on: stream.			(((parseTree at: 2) at: 1) == #=				and: [((parseTree at: 3) at: 1) == #=])					ifFalse: 						[stream cr.						1 to: level + 1 do: [:i | stream tab]].			stream nextPutAll: ' &amp; '.			^self				formatExpression: (parseTree at: 3)				prio: (Priorities at: token)				level: level				on: stream].	token = #|		ifTrue: 			[self				formatExpression: (parseTree at: 2)				prio: (Priorities at: token)				level: level				on: stream.			(((parseTree at: 2) at: 1) == #=				and: [((parseTree at: 3) at: 1) == #=])					ifFalse: 						[stream cr.						1 to: level do: [:i | stream tab]].			stream nextPutAll: ' | '.			^self				formatExpression: (parseTree at: 3)				prio: (Priorities at: token)				level: level				on: stream].	token = #=		ifTrue: 			[stream				nextPutAll: (parseTree at: 2);				nextPutAll: ' = ';				nextPutAll: (parseTree at: 3) printString.			^self].	^self error: 'Unknown token type ' , token printString</body></methods><methods><class-id>Heeg.Isam.FilterExpression class</class-id> <category>class initialization</category><body package="Isam Toolbox">initialize	"Initialize the operator priorities"	"FilterExpression initialize"	Priorities := Dictionary new.	Priorities at: #= put: 4.	Priorities at: #~ put: 3.	Priorities at: #&amp; put: 2.	Priorities at: #| put: 1</body></methods><methods><class-id>Heeg.Isam.IsamStringField</class-id> <category>accessing</category><body package="Isam Toolbox">type	^'String' asIs</body></methods><methods><class-id>Heeg.Isam.IsamStringField class</class-id> <category>accessing</category><body package="Isam Toolbox">encoding	^#ms_cp_1252</body></methods><methods><class-id>Heeg.Isam.IsamUTF8StringField</class-id> <category>accessing</category><body package="Isam Toolbox">type	^'UTF8String' asIs</body></methods><methods><class-id>Heeg.Isam.IsamUTF8StringField</class-id> <category>converting</category><body package="Isam Toolbox">asByteArray: aString	"We build the encoded stream directly, because it is faster than using #asByteArrayEncoding:, because	 lookup for the encoder is too expensive. We know already the encoder and can use it directly."	| ws |	ws := EncodedStream on: (ByteArray new: aString size) writeStream				encodedBy: UTF8StreamEncoder asEncoder.	ws nextPutAll: aString.	^ws encodedContents</body><body package="Isam Toolbox">asString: aByteArray	"We build the encoded stream directly, because it is faster than using #asStringEncoding:, because	 lookup for the encoder is too expensive. We know already the encoder and can use it directly."	^(EncodedStream on: aByteArray readStream		encodedBy: UTF8StreamEncoder asEncoder) contents</body></methods><methods><class-id>Heeg.Isam.IsamUTF8StringField class</class-id> <category>accessing</category><body package="Isam Toolbox">encoding	^#utf8</body></methods><methods><class-id>Heeg.Isam.IsamAbstractTextField</class-id> <category>accessing</category><body package="Isam Toolbox">byteSizeOf: aText	"return the number of bytes for this text"	| size runs values |	runs := aText runs runs.	values := aText runs values.	size := (self class isamStringFieldClass new byteSizeOf: aText string) + (self integerSizeOf: runs size) + (self integerSizeOf: values size).	size := runs inject: size into: [:old :each | old + (self integerSizeOf: each)].	size := values inject: size into: [:old :each | old + (self integerSizeOf: each)].	^size</body><body package="Isam Toolbox">check: value	^value isKindOf: Text</body></methods><methods><class-id>Heeg.Isam.IsamAbstractTextField</class-id> <category>reading-writing</category><body package="Isam Toolbox">readFrom: stream 	"read a text from the stream"	| string runs values |	string := self class isamStringFieldClass new readFrom: stream.	runs := Array new: (self readIntegerFrom: stream).	values := Array new: (self readIntegerFrom: stream).	1 to: runs size do: [:i | runs at: i put: (self readIntegerFrom: stream)].	1 to: values size do: [:i | values at: i put: (self readIntegerFrom: stream)].	^Text string: string runs: (RunArray new setRuns: runs setValues: values)</body><body package="Isam Toolbox">write: aText to: stream	"write a binary representation of the text to the stream"	| runs values |	self class isamStringFieldClass new write: aText string to: stream.	runs := aText runs runs.	values := aText runs values.	self writeInteger: runs size to: stream.	self writeInteger: values size to: stream.	1 to: runs size do: [:i | self writeInteger: (runs at: i) to: stream].	1 to: values size do: [:i | self writeInteger: (values at: i) to: stream]</body></methods><methods><class-id>Heeg.Isam.IsamAbstractTextField class</class-id> <category>accessing</category><body package="Isam Toolbox">isamStringFieldClass	^self subclassResponsibility</body></methods><methods><class-id>Heeg.Isam.IsamTextField</class-id> <category>accessing</category><body package="Isam Toolbox">type	^'Text' asIs</body></methods><methods><class-id>Heeg.Isam.IsamTextField class</class-id> <category>accessing</category><body package="Isam Toolbox">isamStringFieldClass	^IsamStringField</body></methods><methods><class-id>Heeg.Isam.IsamFixedPointField</class-id> <category>accessing</category><body package="Isam Toolbox">byteSizeOf: aFixed 	^self integerSizeOf: (aFixed * 100) asInteger</body><body package="Isam Toolbox">check: value	^value isKindOf: FixedPoint</body><body package="Isam Toolbox">type	^'FixedPoint' asIs</body></methods><methods><class-id>Heeg.Isam.IsamFixedPointField</class-id> <category>reading-writing</category><body package="Isam Toolbox">readFrom: aStream	^FixedPoint		numerator: (self readIntegerFrom: aStream)		denominator: 100		scale: 2</body><body package="Isam Toolbox">write: aFixed to: aStream 	self writeInteger: (aFixed * 100) asInteger to: aStream</body></methods><methods><class-id>Heeg.Isam.IsamItem</class-id> <category>field accessing</category><body package="Isam Toolbox">readField: index from: aStream 	"read the numbered field from aStream"	self at: index put: ((self class types at: index)			readFrom: aStream)</body><body package="Isam Toolbox">readFieldsFrom: aStream 	"read values for all my indexable instance variables from the stream"	1 to: super size do: [:i | self readField: i from: aStream]</body><body package="Isam Toolbox">writeField: index to: aStream 	"write the numbered field to aStream"	(self class types at: index)		write: (self at: index)		to: aStream</body><body package="Isam Toolbox">writeFieldsTo: aStream 	"write all indexable instance variables to the stream"	1 to: self size do: [:i | (self class isamTypes at: i)			write: (self at: i)			to: aStream]</body></methods><methods><class-id>Heeg.Isam.IsamItem</class-id> <category>record accessing</category><body package="Isam Toolbox">invalidateRecordOn: stream	"delete myself from the stream by replacing me with an InvalidTag and 	my record length"	(self recordPosition isNil or: [self recordLength isNil])		ifTrue: 			[^self				error: (#TryingToDeleteNonSpecifiedRecord1pFrom2p_ &lt;&lt; #isam						&gt;&gt; 'Trying to delete non-specified record &lt;1p&gt; from &lt;2p&gt;'							expandMacrosWith: self							with: stream)].	stream position: self recordPosition.	stream nextPut: InvalidTag.	IsamField new writeInteger: self recordLength to: stream</body><body package="Isam Toolbox">readFrom: aStream 	"read my indexable fields and my instance variables from the stream. 	This method is used for reading the index keys upon startup"	| field |	field := IsamField new.	recordPosition := field readIntegerFrom: aStream.	recordLength := field readIntegerFrom: aStream.	self readFieldsFrom: aStream</body><body package="Isam Toolbox">readNextRecordFrom: stream	"Read the next record encountered on stream. Skip invalid records and  	return nil if either the end of the stream or a zero tag was encountered  	(which simply means that the unused portion of the stream is reached)"	| oldPosition tag length |		[stream atEnd ifTrue: [^nil].	oldPosition := stream position.	tag := stream peek.	tag == InvalidTag]			whileTrue: 				[stream skip: 1.				length := IsamField new readIntegerFrom: stream.				stream skip: length - stream position + oldPosition].	tag == ValidTag ifTrue: [^self readRecordAt: oldPosition from: stream].	tag == 0 ifTrue: [^nil].	^self error: (#RecordstreamGarbledAt1pIn2p_ &lt;&lt; #isam	&gt;&gt; 'Recordstream garbled at &lt;1p&gt; in &lt;2p&gt;'				expandMacrosWith: oldPosition				with: stream)</body><body package="Isam Toolbox">readRecordAt: position from: stream	"read my indexable fields from the stream"	stream position: position.	stream next = ValidTag		ifFalse: 			[^self				error: (#TryingToReadAnInvalidRecordAt1pFrom2p_ &lt;&lt; #isam						&gt;&gt; 'Trying to read an invalid record at &lt;1p&gt; from &lt;2p&gt;'							expandMacrosWith: position							with: stream)].	self readFieldsFrom: stream.	recordLength := stream position - position.	recordPosition := position</body><body package="Isam Toolbox">recordSize	"return the size of the record (fields without instance variables and ValidTag)"	| value type size |	size := 0.	1 to: self size do: 		[:i | 		value := self at: i.		type := self class types at: i.		size := size + (type byteSizeOf: value)].	^size</body><body package="Isam Toolbox">writeOn: aStream 	"write my indexable fields and my instance variables to the stream. This 	method is used to store the index keys in a file when the isam collection 	is closed"	| field |	field := IsamField new.	field writeInteger: recordPosition to: aStream.	field writeInteger: recordLength to: aStream.	self writeFieldsTo: aStream</body><body package="Isam Toolbox">writeRecordAt: position on: stream	"write my indexable fields on the stream at the position"	stream position: position.	stream nextPut: ValidTag.	self writeFieldsTo: stream.	recordPosition := position.	recordLength := stream position - position</body></methods><methods><class-id>Heeg.Isam.IsamItem</class-id> <category>accessing</category><body package="Isam Toolbox">recordLength	"return the length of my at my recordPosition. My actual size may differ"	^ recordLength</body><body package="Isam Toolbox">recordLength: int	recordLength := int</body><body package="Isam Toolbox">recordPosition	"return the byte position of this item in the data file"	^ recordPosition</body><body package="Isam Toolbox">recordPosition: int	recordPosition := int</body></methods><methods><class-id>Heeg.Isam.IsamItem</class-id> <category>copying</category><body package="Isam Toolbox">copyAllFrom: anItem 	"used to copy both indexable fields and the instance variables to me"	self copyFrom: anItem.	recordPosition := anItem recordPosition.	recordLength := anItem recordLength</body><body package="Isam Toolbox">copyFrom: anItem	"copy all my named indexable fields from anItem. Provide an error 	notification if anItem doesn't contain all my fields"	self class fieldsDictionary associationsDo: 			[:assoc |			self at: assoc value				put: (anItem at: (anItem class fieldsDictionary at: assoc key								ifAbsent: 									[^self										error: (#CopySourceDidntContain1s_ &lt;&lt; #isam												&gt;&gt; 'Copy source didn''t contain &lt;1s&gt;' expandMacrosWith: assoc key)]))						copy]</body><body package="Isam Toolbox">copyPositionFrom: anItem	"copy recordPosition and length from the item"	recordPosition := anItem recordPosition.	recordLength := anItem recordLength</body><body package="Isam Toolbox">copyTo: anItem	"copy all my named indexable fields to anItem. Provide an error  	notification if anItem doesn't contain all my fields"	self class fieldsDictionary keysDo: 			[:key |			self at: (anItem class fieldsDictionary at: key						ifAbsent: 							[^self								error: (#CopySourceDidntContain1s_ &lt;&lt; #isam										&gt;&gt; 'Copy source didn''t contain &lt;1s&gt;' expandMacrosWith: key)])				put: (self at: (self class fieldsDictionary at: key)) copy]</body></methods><methods><class-id>Heeg.Isam.IsamItem</class-id> <category>comparing</category><body package="Isam Toolbox">&lt; anItem 	"true iff myself is less than anItem and has the same class"	| a b type |	self class == anItem class ifFalse: [^false].	1 to: self size do: 		[:i | 		type := self class types at: i.		a := self at: i.		b := anItem at: i.		(type less: a than: b)			ifTrue: [^true]			ifFalse: [(type greater: a than: b)					ifTrue: [^false]]].	^ false</body><body package="Isam Toolbox">&lt;= anItem 	"true iff myself is less or equal than anItem and has the same class"	| a b type |	self class == anItem class ifFalse: [^false].	1 to: self size do: 		[:i | 		type := self class types at: i.		a := self at: i.		b := anItem at: i.		(type less: a than: b)			ifTrue: [^true]			ifFalse: [(type greater: a than: b)					ifTrue: [^false]]].	^ true</body><body package="Isam Toolbox">= anItem 	"true iff myself equals to anItem and has the same class"	self class == anItem class ifFalse: [^ false].	1 to: self size do: [:i | ((self class types at: i)			equal: (self at: i)			to: (anItem at: i))			ifFalse: [^false]].	(self recordPosition notNil and: [anItem recordPosition notNil])		ifTrue: [^self recordPosition = anItem recordPosition]		ifFalse: [^true]</body><body package="Isam Toolbox">&gt; anItem	"True if myself is greater than anItem and has the same class"	^ (self &lt;= anItem) not</body><body package="Isam Toolbox">&gt;= anItem	"True if myself is greater or equal than anItem and has the same class"	^ (self &lt; anItem) not</body><body package="Isam Toolbox">equal: anItem 	"true iff myself equals to anItem. All my indexable fields must be    	shared by anItem"	1 to: self size do: [:i | ((self class types at: i)			equal: (self at: i)			to: (anItem at: (anItem class fieldsDictionary at: (self class fieldsDictionary keyAtValue: i) ifAbsent: [^false])))			ifFalse: [^false]].	(self recordPosition notNil and: [anItem recordPosition notNil])		ifTrue: [^self recordPosition = anItem recordPosition]		ifFalse: [^true]</body><body package="Isam Toolbox">greater: anItem 	"true iff myself is greater than anItem. All my indexable fields must 	be shared by anItem"	^(self lessOrEqual: anItem) not</body><body package="Isam Toolbox">greaterOrEqual: anItem 	"true iff myself is greater or equal than anItem. All my indexable 	fields must be shared by anItem"	^(self less: anItem) not</body><body package="Isam Toolbox">hash	"return a hash value for myself"	| hash |	hash := 0.	self class fieldsDictionary keysDo: 			[:key |			hash := hash						bitXor: (self at: (self class fieldsDictionary at: key)) hashISAM].	self recordPosition notNil		ifTrue: [^recordPosition hash bitXor: recordLength]		ifFalse: [^hash]</body><body package="Isam Toolbox">less: anItem 	"true iff myself is less than anItem. All my indexable fields must be    	shared by anItem"	| a b type |	1 to: self size do: 		[:i | 		type := self class types at: i.		a := self at: i.		b := anItem at: (anItem class fieldsDictionary at: (self class fieldsDictionary keyAtValue: i)						ifAbsent: [^false]).		(type less: a than: b)			ifTrue: [^true]			ifFalse: [(type greater: a than: b)					ifTrue: [^false]]].	(self recordPosition notNil and: [anItem recordPosition notNil])		ifTrue: [^self recordPosition &lt; anItem recordPosition]		ifFalse: [^false]</body><body package="Isam Toolbox">lessOrEqual: anItem 	"true iff myself is less than anItem. All my indexable fields must be    	shared by anItem"	| a b type |	1 to: self size do: 		[:i | 		type := self class types at: i.		a := self at: i.		b := anItem at: (anItem class fieldsDictionary at: (self class fieldsDictionary keyAtValue: i)						ifAbsent: [^false]).		(type greater: a than: b)			ifTrue: [^false]].	(self recordPosition notNil and: [anItem recordPosition notNil])		ifTrue: [^self recordPosition &lt; anItem recordPosition]		ifFalse: [^false]</body></methods><methods><class-id>Heeg.Isam.IsamItem</class-id> <category>printing</category><body package="Isam Toolbox">printOn: aStream	"Store a short description of me on aStream"	aStream nextPutAll: recordPosition printString; nextPutAll: ' to ' asIs.	recordLength isNil | recordPosition isNil		ifTrue: [aStream nextPutAll: ' unknown ' asIs]		ifFalse: [aStream nextPutAll: (recordPosition + recordLength - 1) printString; space]</body></methods><methods><class-id>Heeg.Isam.IsamItem</class-id> <category>searching</category><body package="Isam Toolbox">canBeSearchedByPattern	"return true, if the pattern search methods of SeparatedIsamCollection can be applied to me."	^self class canBeSearchedByPattern</body></methods><methods><class-id>Heeg.Isam.IsamItem</class-id> <category>initialize-release</category><body package="Isam Toolbox">initialize	super initialize.	recordPosition := nil.	recordLength := 0</body></methods><methods><class-id>Heeg.Isam.IsamItem</class-id> <category>converting</category><body package="Isam Toolbox">asPattern	^(self species new)		copyFrom: self;		yourself</body></methods><methods><class-id>Heeg.Isam.IsamItem class</class-id> <category>class initialization</category><body package="Isam Toolbox">initialize	"Initialize the validation tags"	"IsamItem initialize"	ValidTag := 2r01010101.	InvalidTag := 2r10101010</body></methods><methods><class-id>Heeg.Isam.IsamItem class</class-id> <category>subclass creation</category><body package="Isam Toolbox">createClassMethodsFor: fields types: types 	"build class methods for initialization, instance creation and accessing"	| ft s |	ft := 'fieldsAndTypes'.	s := ReadWriteStream on: String new.	s nextPutAll: 'initialize'; cr; tab; nextPutAll: '"Initialize my type tables"'.	s cr; tab; nextPut: $"; nextPutAll: self name.	s nextPutAll: ' initialize"'; cr; cr.	s tab; nextPutAll: ft; nextPutAll: ' := IdentityDictionary new.'; cr.	1 to: types size do: 		[:i | 		s tab; nextPutAll: ft; nextPutAll: ' at: '; nextPutAll: (fields at: i) asString; nextPutAll: ' put: '.		s nextPutAll: (types at: i) printString; nextPutAll: ' new.'; cr].	s cr.	self class compile: s contents classified: 'class initialization'.	"initialiser finished "	"s := ReadWriteStream on: String new.	s nextPutAll: 'new '; cr; tab; nextPutAll: '""create an instance of me""'; cr; cr.	s tab; nextPutAll: '^ super new: '; nextPutAll: f; nextPutAll: ' size'.	self class compile: s contents classified: 'instance creation'."	self class compile: 'types' , (String with: Character cr) ,  '"Return the class variable fieldsAndTypes"' , (String with: Character cr) , '^ ' , 'self types' classified: 'accessing'.	self class compile: 'fields' , (String with: Character cr) , '"Return the class variable for the fields"' , (String with: Character cr) , '^ ' , '' classified: 'accessing'.	self initialize</body><body package="Isam Toolbox">createForbiddenMethodsFor: fields 	"create the methods that forbide access to the superclass's fields"	| s |	fields do: 		[:each | 		s := ReadWriteStream on: String new.		s nextPutAll: each; cr; tab; nextPutAll: '"This is a superclass field"'; cr; cr; tab.		s nextPutAll: '^ self shouldNotImplement'.		self compile: s contents classified: 'accessing'.		s := ReadWriteStream on: String new.		s nextPutAll: each; nextPutAll: ': ignored'; cr; tab.		s nextPutAll: '"This is a superclass field"'; cr; cr; tab.		s nextPutAll: '^ self shouldNotImplement'.		self compile: s contents classified: 'accessing']</body><body package="Isam Toolbox">createInstanceMethodsFor: fields types: types 	"create the instance methods to access the fields"	| s |	fields		keysDo: 			[:each | 			s := ReadWriteStream on: String new.			s nextPutAll: each; cr; tab; nextPutAll: '"Return the named field"'; cr; cr; tab.			s nextPutAll: '^ self at: '; nextPutAll: (fields at: each) printString.			self compile: s contents classified: 'accessing'.			s := ReadWriteStream on: String new.			s nextPutAll: each; nextPutAll: ': object'; cr; tab.			s nextPutAll: '"Enter new value for the field if it''s valid"'; cr; cr; tab.			s nextPutAll: '((self class types at: '; nextPutAll: (fields at: each) printString; nextPutAll: ') check: object)'.			s cr; tab; tab; nextPutAll: 'ifFalse: [^ self error: ''Invalid field''].'; cr; tab.			s nextPutAll: '^self at: '; nextPutAll: (fields at: each) printString; nextPutAll: ' put: object'.			self compile: s contents classified: 'accessing']</body><body package="Isam Toolbox">createProtocolFor: string	"string is a list of variable names with possible types, which must be 	splitted. Compute class and instance protocol to access these 	variables in my variable instance variables"	self initializeClassVariablesFrom: string.	self createInstanceMethodsFor: isamFields types: isamTypes.	self createForbiddenMethodsFor: (superclass isamFields keys				reject: [:each | isamFields includesKey: each])</body><body package="Isam Toolbox">initializeClassVariablesFrom: string	| tokens s i n |	tokens := Scanner new scanTokens: string.	s := ReadStream on: tokens.	isamTypes := OrderedCollection new.	isamFields := Dictionary new.	i := 1.	[s atEnd] whileFalse: 			[n := s next.			isamFields at: n put: i.			s atEnd not &amp; (s peek = #=)				ifTrue: 					[s next.					isamTypes add: (IsamFieldProxy type: s next asString)]				ifFalse: 					[isamTypes add: (IsamFieldProxy								type: (superclass isamTypes at: (superclass isamFields at: n)) type										asString)].			i := i + 1]</body><body package="Isam Toolbox">subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is a special method to create subclasses of IsamItems which 	carry certain default protocol and associate names to positions in 	my indexable instance variables. Instance variables may be given 	either with or without =Class suffixes. If they are given with a type 	suffix they are entered in the class variable Types which is added 	for each direct subclass of IsamItem (ugly!). If no type is given they 	must be typed in a superclass"	| classVars aClass |	classVars := '&lt;1s&gt; &lt;2s&gt;Fields &lt;3s&gt;Types' expandMacrosWith: d with: t with: t.	aClass := (self classBuilder)				superclass: self;				environment: self environment;				className: t;				instVarString: '';				classVarString: classVars;				poolString: s;				category: cat;				beFixed;				reviseSystem;				yourself.	aClass createProtocolFor: f.	^aClass</body><body package="Isam Toolbox">variableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is a special method to create subclasses of IsamItems which 	carry certain default protocol and associate names to positions in 	my indexable instance variables. Instance variables may be given 	either with or without =Class suffixes. If they are given with a type 	suffix they are entered in the class variable Types which is added 	for each direct subclass of IsamItem (ugly!). If no type is given they 	must be typed in a superclass"	| classVars aClass |	classVars := '&lt;1s&gt; &lt;2s&gt;Fields &lt;3s&gt;Types' asIs expandMacrosWith: d with: t with: t.	aClass := (self classBuilder)				superclass: self;				environment: self environment;				className: t;				instVarString: '';				classVarString: classVars;				poolString: s;				category: cat;				beVariable;				reviseSystem;				yourself.	aClass createProtocolFor: f.	^aClass</body></methods><methods><class-id>Heeg.Isam.IsamItem class</class-id> <category>searching</category><body package="Isam Toolbox">canBeSearchedByPattern	"retrun true, if my instances can be searched using the pattern search 	methods of SeparatedIsamCollection"	^(self types at: 1) canBeSearchedByPattern</body></methods><methods><class-id>Heeg.Isam.IsamItem class</class-id> <category>accessing</category><body package="Isam Toolbox">extraAttributesForDefinition	(self superclass respondsTo: #fieldsDictionary)		ifFalse: [^super extraAttributesForDefinition].	^Array with: (Array with: #fields with: self fieldsAndTypesString)</body><body package="Isam Toolbox">extraAttributesFrom: aFieldsAndTypesString	^Array with: (Array with: #fields with: aFieldsAndTypesString)</body><body package="Isam Toolbox">isamFields		^isamFields ifNil: [Dictionary new]</body><body package="Isam Toolbox">isamTypes		^isamTypes ifNil: [Array new]</body><body package="Isam Toolbox">readExtraAttributes: aDictionary oldSuperclass: oldSuper	super readExtraAttributes: aDictionary oldSuperclass: oldSuper.	^self createProtocolFor: (aDictionary at: #fields ifAbsent: [^self]).</body></methods><methods><class-id>Heeg.Isam.IsamItem class</class-id> <category>fake fields</category><body package="Isam Toolbox">fieldsDictionary	"This methods are provided to allow special methods for subclasses of me to be stored in my metaclass. Otherwise one must reimplement those methods for each subclass"	^self isamFields</body><body package="Isam Toolbox">types	^self isamTypes</body></methods><methods><class-id>Heeg.Isam.IsamItem class</class-id> <category>instance creation</category><body package="Isam Toolbox">new	^(self new: self isamFields size) initialize</body></methods><methods><class-id>Heeg.Isam.IsamItem class</class-id> <category>printing</category><body package="Isam Toolbox">fieldsAndTypesString	| stream fields types |	stream := WriteStream on: String new.	fields := self isamFields keys				sorted: [:a :b | (self isamFields at: a) &lt;= (self isamFields at: b)].	types := self isamTypes.	1 to: fields size		do: 			[:index |			stream				nextPutAll: (fields at: index) asString;				nextPut: $=;				nextPutAll: (types at: index) field type;				space].	^stream contents</body><body package="Isam Toolbox">importFieldsAndTypes	"WikiPageEntry importFieldsAndTypes"	| stream fields fieldsVarName typesVarName fieldsVar typesVar|	stream := WriteStream on: String new.	fieldsVarName := (self name , 'Fields' asIs) asSymbol.	typesVarName := (self name , 'Types' asIs) asSymbol.	fieldsVar := ((self classPool bindingFor: fieldsVarName) value).	typesVar := ((self classPool bindingFor: typesVarName) value).	fields := fieldsVar keys				sorted: [:a :b | (fieldsVar at: a) &lt;= (fieldsVar at: b)].	1 to: fields size		do: 			[:index |			stream				nextPutAll: (fields at: index) asString;				nextPut: $=;				nextPutAll: ((typesVar at: index) type);				space].	^stream contents</body></methods><methods><class-id>Heeg.Isam.IsamItem class</class-id> <category>binary storage</category><body package="Isam Toolbox">readNewSubclassOn: aCodeReader in: aNameSpace	| fields newclass |	newclass := super readNewSubclassOn: aCodeReader in: aNameSpace.	newclass ~= IsamItem		ifTrue: 			[fields := aCodeReader readTwoByteString.			^newclass				initializeClassVariablesFrom: fields;				yourself]		ifFalse: [^newclass]</body><body package="Isam Toolbox">storeGeneralStructureOn: aCodeWriter	super storeGeneralStructureOn: aCodeWriter.	self ~= IsamItem ifTrue: [aCodeWriter storeString: self fieldsAndTypesString]</body></methods><methods><class-id>Heeg.Isam.IsamCollectionField</class-id> <category>comparing</category><body package="Isam Toolbox">greater: field1 than: field2 	"comparison defined over the elements"	field1 size = field2 size		ifTrue: 			["compare the elements"			1 to: field1 size do: [:i | (field1 at: i) &gt; (field2 at: i)					ifTrue: [^true]					ifFalse: [(field1 at: i) &lt; (field2 at: i) ifTrue: [^false]]].			^true]		ifFalse: [^field1 size &gt; field2 size]</body><body package="Isam Toolbox">greaterOrEqual: field1 than: field2 	"comparison defined over the elements"	field1 size = field2 size		ifTrue: 			["compare the elements"			1 to: field1 size do: [:i | (field1 at: i) &gt;= (field2 at: i)					ifTrue: [^true]					ifFalse: [^false]].			^true]		ifFalse: [^field1 size &gt; field2 size]</body><body package="Isam Toolbox">less: field1 than: field2 	"comparison defined over the elements"	field1 size = field2 size		ifTrue: 			["compare the elements"			1 to: field1 size do: [:i | (field1 at: i) &lt; (field2 at: i)					ifTrue: [^true]					ifFalse: [(field1 at: i) &gt; (field2 at: i) ifTrue: [^false]]].			^true]		ifFalse: [^field1 size &lt; field2 size]</body><body package="Isam Toolbox">lessOrEqual: field1 than: field2 	"comparison defined over the elements"	field1 size = field2 size		ifTrue: 			["compare the elements"			1 to: field1 size do: [:i | (field1 at: i) &lt;= (field2 at: i)					ifTrue: [^true]					ifFalse: [^false]].			^true]		ifFalse: [^field1 size &lt; field2 size]</body></methods><methods><class-id>Heeg.Isam.IsamCollectionField</class-id> <category>reading-writing</category><body package="Isam Toolbox">readFrom: aStream 	"read the collection from the stream"	| col numElements |	col := OrderedCollection new.	numElements := self readIntegerFrom: aStream.	1 to: numElements do: [:i | col add: (elementField readFrom: aStream)].	^col</body><body package="Isam Toolbox">write: col to: aStream 	"write the elements of the collection to the stream"	self writeInteger: col size to: aStream.	col do: [:each | elementField write: each to: aStream]</body></methods><methods><class-id>Heeg.Isam.IsamCollectionField</class-id> <category>initialize-release</category><body package="Isam Toolbox">elementType	"return the type of the elements"	^ nil</body><body package="Isam Toolbox">initialize	super initialize.	elementField := self elementType new</body></methods><methods><class-id>Heeg.Isam.IsamCollectionField</class-id> <category>accessing</category><body package="Isam Toolbox">byteSizeOf: value 	"return the byte size of the elements"	^(value inject: 0 into: [:sum :el | sum + (elementField byteSizeOf: el)])		+ (self integerSizeOf: value size)</body><body package="Isam Toolbox">check: value	"return true iff value is a collection with elementtype as elements only"	(value isKindOf: Collection) ifFalse: [^ false].	value do: [:each| (elementField check: each) ifFalse: [^ false]].	^ true</body></methods><methods><class-id>Heeg.Isam.IsamCollectionField class</class-id> <category>initialize-release</category><body package="Isam Toolbox">new	^ super new initialize</body></methods><methods><class-id>Heeg.Isam.IsamCollectionOfIntegerField</class-id> <category>initialize-release</category><body package="Isam Toolbox">elementType	^ IsamIntegerField</body></methods><methods><class-id>Heeg.Isam.IsamCollectionOfIntegerField</class-id> <category>accessing</category><body package="Isam Toolbox">type	^'CollectionOfInteger' asIs</body></methods><methods><class-id>Heeg.Isam.IsamSymbolField</class-id> <category>accessing</category><body package="Isam Toolbox">type	^'Symbol' asIs</body></methods><methods><class-id>Heeg.Isam.IsamSymbolField class</class-id> <category>accessing</category><body package="Isam Toolbox">encoding	^#ms_cp_1252</body></methods><methods><class-id>Heeg.Isam.IsamPager</class-id> <category>database functions</category><body package="Isam Toolbox">addRecord: aRecord	"add aRecord to my isamCollection"	currentItem := aRecord.	isamCollection add: aRecord.	pageSize &lt; isamCollection size		ifTrue: 			[currentPage := isamCollection searchNext: pageSize						forwardFromItem: currentItem]		ifFalse: [currentPage := OrderedCollection new].	currentPage isEmpty		ifTrue: 			[(currentPage := isamCollection searchFirst: pageSize) isEmpty				ifTrue: [currentItem := nil]]		ifFalse: [currentItem copyPositionFrom: currentPage first]</body><body package="Isam Toolbox">changeSortKey: newSortKey 	"change the keyed index for the addresses"	| menu index |	newSortKey == #prompt		ifTrue: 			[menu := Menu labelList: (Array with: #('A') asIs).			index := menu startUp.			index = 0 ifTrue: [^self]]		ifFalse: [index := newSortKey].	currentKeyClass := ((LiteralBindingReference path: (keyClasses at: index))				method: thisContext method) value.	isamCollection selectIndex: (keyClasses at: index).	currentPage := currentItem isNil				ifTrue: [isamCollection searchFirst: pageSize]				ifFalse: [isamCollection searchNext: pageSize forwardFromItem: currentItem].	currentPage isEmpty		ifTrue: [self resetCurrent]		ifFalse: [currentItem notNil ifTrue: [currentItem copyPositionFrom: currentPage first]]</body><body package="Isam Toolbox">gotoKey: aKey	"go to the first item greater than or equal to a Key; 	unlike search key, the filter remains unchanged"	| pattern key list |	aKey == #prompt		ifTrue: 			[currentKeyClass canBeSearchedByPattern ifFalse: [^self].			pattern := self requestSearchPatternOnCancel: [^self].			key := currentKeyClass new.			key at: 1 put: pattern]		ifFalse: [key := aKey].	Cursor execute showWhile: 			[list := isamCollection searchNext: pageSize greaterEqual: key.			list isEmpty				ifFalse: 					[currentPage := list.					currentItem := nil]]</body><body package="Isam Toolbox">removeRecord: promptCode	"remove the selected record"	| key |	currentItem isNil ifTrue: [^self].	promptCode == #prompt		ifTrue:			[(Dialog confirm: (#ReallyRemoveSelectedRecord_ &lt;&lt; #isam &gt;&gt; 'Really remove selected record?')	asString)			ifFalse: [^self]].	key := self currentKey.	isamCollection		remove: key		ifAbsent: [].	currentPage first recordPosition = currentItem recordPosition		ifTrue: [currentPage := isamCollection					searchNext: pageSize					backwardFromItem: currentPage last]		ifFalse: [currentPage := isamCollection					searchNext: pageSize					forwardFromItem: currentPage first].	currentPage isEmpty		ifTrue: [currentPage := isamCollection searchLast: pageSize].	currentItem := nil</body><body package="Isam Toolbox">rewriteWith: aRecord 	"rewrite current item with aRecord"	| pos |	currentItem isNil ifTrue: [^self].	pos := currentItem recordPosition.	currentItem := isamCollection rewrite: self currentKey with: aRecord.	currentPage do:		[:each | each recordPosition = pos ifTrue: [^each copyAllFrom: currentItem]]</body><body package="Isam Toolbox">searchKey: aPattern	"search for a key that matches a given pattern"	| pattern list |	currentKeyClass canBeSearchedByPattern ifFalse: [^self].	pattern := aPattern == #prompt				ifTrue: 					[self						requestSearchPattern: (#Pattern_ &lt;&lt; #isam &gt;&gt; 'Pattern?') asString						initialAnswer: '*' asIs						onCancel: [^self]]				ifFalse: [aPattern].	pattern := isamCollection setSearchPattern: pattern.	Cursor execute showWhile: 			[list := isamCollection searchFirst: pageSize.			list isEmpty				ifTrue: [isamCollection setSearchPattern: pattern]				ifFalse: 					[currentPage := list.					currentItem := nil]]</body></methods><methods><class-id>Heeg.Isam.IsamPager</class-id> <category>private</category><body package="Isam Toolbox">defaultPageSize	^10</body><body package="Isam Toolbox">requestSearchPattern: promptString initialAnswer: aString onCancel: aBlock 	"request a search pattern string from user and return it; 	evaluate &lt;aBlock&gt; if user cancels or enters an empty string"	| answer |	^(answer := Dialog request: promptString initialAnswer: aString) isEmpty		ifTrue: [aBlock value]		ifFalse: [answer]</body><body package="Isam Toolbox">requestSearchPatternOnCancel: aBlock	"request a search pattern string from user and return it; 	evaluate &lt;aBlock&gt; if user cancels or enters an empty string"	^self		requestSearchPattern: (#Pattern_ &lt;&lt; #isam &gt;&gt; 'Pattern?') asString		initialAnswer: String new		onCancel: aBlock</body><body package="Isam Toolbox">resetCurrent	"reset currentPage, currentPageStart and currentItem"	currentItem := nil.	currentPage := nil</body></methods><methods><class-id>Heeg.Isam.IsamPager</class-id> <category>paging</category><body package="Isam Toolbox">searchBackward	"select the previous PageSize records before the current page"	| newPage |	currentPage isNil ifTrue: [^self searchTop].	Cursor execute showWhile: 			[newPage := isamCollection searchNext: pageSize						beforeItem: currentPage first.			newPage isEmpty ifTrue: [^currentPage].			newPage addAll: (currentPage copyFrom: 1						to: currentPage size - newPage size).			currentItem := nil.			^currentPage := newPage]</body><body package="Isam Toolbox">searchBottom	"select the last PageSize records as current page"	currentItem := nil.	Cursor execute		showWhile: [currentPage := isamCollection searchLast: pageSize].	^currentPage</body><body package="Isam Toolbox">searchForward	"select the next PageSize records after the current page"	| newPage |	currentPage isNil ifTrue: [^self searchTop].	Cursor execute showWhile: 			[newPage := isamCollection searchNext: pageSize						afterItem: currentPage last.			newPage isEmpty				ifFalse: 					[currentItem := nil.					currentPage := newPage].			^currentPage]</body><body package="Isam Toolbox">searchTop	"select the first PageSize records as current page"	currentItem := nil.	Cursor execute		showWhile:			[currentPage := isamCollection searchFirst: pageSize].	^currentPage</body></methods><methods><class-id>Heeg.Isam.IsamPager</class-id> <category>enumerating</category><body package="Isam Toolbox">keysDo: aBlock	"do aBlock for all keys. Access the isam collection in blocks of pageSize keys"	self keysDo: aBlock pageSize: pageSize</body><body package="Isam Toolbox">keysDo: aBlock pageSize: count	"do aBlock for all keys. Access the isam collection in blocks of count keys"	| page |	isamCollection saveCurrentPage.	page := isamCollection searchFirst: count.	[page isEmpty]		whileFalse:			[page do: [:each | aBlock value: each].			page := isamCollection searchNext: count afterItem: page last].	isamCollection restoreCurrentPage</body><body package="Isam Toolbox">recordsDo: aBlock 	"do aBlock for all records. Access the isam collection in blocks of pageSize 	records "	self recordsDo: aBlock pageSize: pageSize</body><body package="Isam Toolbox">recordsDo: aBlock pageSize: count	"do aBlock for all records. Access the isam collection in blocks of count keys"	| page |	isamCollection saveCurrentPage.	page := isamCollection searchFirst: count.	[page isEmpty]		whileFalse:			[(isamCollection getRecords)				do: [:each | aBlock value: each].			page := isamCollection searchNext: count afterItem: page last].	isamCollection restoreCurrentPage</body></methods><methods><class-id>Heeg.Isam.IsamPager</class-id> <category>accessing</category><body package="Isam Toolbox">currentItem	^currentItem</body><body package="Isam Toolbox">currentKey	"return the currently selected index of currentItem"	currentItem isNil ifTrue: [^nil].	^currentKeyClass new copyAllFrom: currentItem</body><body package="Isam Toolbox">currentKey: aKey 	"set current item according to aKey"	currentItem := aKey isNil ifFalse: [isamCollection recordAtKey: aKey]</body><body package="Isam Toolbox">currentKeyClass	^currentKeyClass</body><body package="Isam Toolbox">currentPage	^currentPage</body><body package="Isam Toolbox">isamCollection	^isamCollection</body><body package="Isam Toolbox">keyClasses	^keyClasses</body><body package="Isam Toolbox">keyNames	"return a collection containing the names of my keys. This is a default 	implementation that should ber overwritten by my subclasses"	| keyNames |	keyNames := OrderedCollection new: keyClasses size.	keyClasses do: [:each | keyNames add: each printString].	^keyNames asArray</body><body package="Isam Toolbox">pageSize	^pageSize</body><body package="Isam Toolbox">pageSize: anInteger	pageSize := anInteger</body></methods><methods><class-id>Heeg.Isam.IsamPager</class-id> <category>maintainance</category><body package="Isam Toolbox">checkData	"check the isam data for integrity. This takes a long time"	(Dialog		confirm: (#ThisWillTakeSomeTimeDoYouWantToWait_ &lt;&lt; #isam				&gt;&gt; 'This will take some time.\Do you want to wait?') asString				withCRs)			ifTrue: [isamCollection checkIntegrity]</body><body package="Isam Toolbox">checkOverlap	"check the isam indices for overlapping"	isamCollection checkIndicesForOverlappings</body><body package="Isam Toolbox">compact	"compaction of isam collection"	isamCollection compaction.	self resetCurrent</body></methods><methods><class-id>Heeg.Isam.IsamPager</class-id> <category>initialize-release</category><body package="Isam Toolbox">initialize	"initialize instance variables"	super initialize.	pageSize := self defaultPageSize.	self resetCurrent</body><body package="Isam Toolbox">on: filename records: records keys: keys 	keyClasses := keys.	currentKeyClass := ((LiteralBindingReference path: keyClasses first)				method: thisContext method) value.	Cursor read showWhile: [isamCollection := IsamClient					on: filename					records: records					keys: keys]</body><body package="Isam Toolbox">release	super release.	isamCollection detach</body></methods><methods><class-id>Heeg.Isam.IsamPager class</class-id> <category>instance creation</category><body package="Isam Toolbox">on: filename records: records keys: keys	"Open a new view"	| new |	new := self new initialize.	^new on: filename records: records keys: keys</body></methods><methods><class-id>Heeg.Isam.IsamIndex</class-id> <category>accessing</category><body package="Isam Toolbox">at: anIndex	^self keyAtIndex: anIndex</body><body package="Isam Toolbox">at: anIndex put: anItem	^self shouldNotImplement</body><body package="Isam Toolbox">last	^self allKeysSorted last</body><body package="Isam Toolbox">maxAllKeys: aCollection	aCollection do: [:each | self maxKey: each]</body><body package="Isam Toolbox">maxKey	^maxKey</body><body package="Isam Toolbox">maxKey: aKey	(maxKey isNil or: [maxKey &lt; aKey]) ifTrue: [maxKey := aKey]</body><body package="Isam Toolbox">size	^tally</body></methods><methods><class-id>Heeg.Isam.IsamIndex</class-id> <category>searching</category><body package="Isam Toolbox">findAllKeys: aPattern	"Find and return all elements in self that are equal to &lt;aPattern&gt;. This   	means find all keys that have the same fields"	^self findAllKeys: aPattern ifAbsent: [^nil]</body><body package="Isam Toolbox">findAllKeys: aPattern ifAbsent: aBlock	"Find and return all elements in self that are equal to &lt;aPattern&gt;. This   	means find all keys that have the same fields"	^self allKeysAtPattern: aPattern ifAbsent: aBlock</body><body package="Isam Toolbox">findKey: aPattern	"Find and return the first element in self that is equal to &lt;aPattern&gt;."	^self findKey: aPattern ifAbsent: [nil]</body><body package="Isam Toolbox">findKey: aPattern ifAbsent: aBlock	"Find and return the first element in self that is equal to &lt;aPattern&gt;."	^self keyAtPattern: aPattern ifAbsent: aBlock</body><body package="Isam Toolbox">indexOfGreater: object ifAbsent: aBlock	"Find the index of the first object in me that is greater than a given object"	| index low high |	low := 1.	high := self size.		[index := (high + low) // 2.	low &gt; high or: [object &lt; (self at: low)]]			whileFalse: 				[(self at: index) &lt;= object					ifTrue: [low := index + 1]					ifFalse: [high := index - 1]].	low &gt; self size ifTrue: [^aBlock value].	^low</body><body package="Isam Toolbox">indexOfGreaterEqual: object ifAbsent: aBlock	"Find the index of the first object in me that is greater or equal than a given object"	| index low high |	low := 1.	high := self size.		[index := (high + low) // 2.	low &gt; high or: [object &lt;= (self at: low)]]			whileFalse: 				[(self at: index) &lt; object					ifTrue: [low := index + 1]					ifFalse: [high := index - 1]].	low &gt; self size ifTrue: [^aBlock value].	^low</body><body package="Isam Toolbox">indexOfLess: object ifAbsent: aBlock	"Find the index of the last object in me that is less than a given object"	| index low high |	low := 1.	high := self size.		[index := (high + low) // 2.	low &gt; high or: [(self at: high) &lt; object]]			whileFalse: 				[(self at: index) &lt; object					ifTrue: [low := index + 1]					ifFalse: [high := index - 1]].	high &lt; 1 ifTrue: [^aBlock value].	^high</body><body package="Isam Toolbox">indexOfLessEqual: object ifAbsent: aBlock	"Find the index of the last object in me that is less or equal than a given object"	| index low high |	low := 1.	high := self size.		[index := (high + low) // 2.	low &gt; high or: [(self at: high) &lt;= object]]			whileFalse: 				[(self at: index) &lt;= object					ifTrue: [low := index + 1]					ifFalse: [high := index - 1]].	high &lt; 1 ifTrue: [^aBlock value].	^high</body></methods><methods><class-id>Heeg.Isam.IsamIndex</class-id> <category>accessing keys</category><body package="Isam Toolbox">allKeys	| allKeys |	allKeys := OrderedCollection new.	patternsToKeys do: [:subKeys | allKeys addAll: subKeys].	^allKeys</body><body package="Isam Toolbox">allKeysAtIndex: aStartIndex count: aCount	^self allKeysAtIndex: aStartIndex to: aStartIndex + aCount - 1</body><body package="Isam Toolbox">allKeysAtIndex: aStartIndex to: aStopIndex	aStartIndex &gt; aStopIndex ifTrue: [^#()].	(aStartIndex &lt;= 0 or: [self allKeysSorted size &lt; aStopIndex])		ifTrue: 			[^self				error: (#indexOutOfBounds &lt;&lt; #isam &gt;&gt; 'index out of bounds') asString].	^self allKeysSorted copyFrom: aStartIndex to: aStopIndex</body><body package="Isam Toolbox">allKeysAtPattern: aPattern	^self allKeysAtPattern: aPattern		ifAbsent: 			[self error: (#cannotFindKeys &lt;&lt; #isam &gt;&gt; 'cannot find keys') asString]</body><body package="Isam Toolbox">allKeysAtPattern: aPattern ifAbsent: aBlock	^patternsToKeys at: aPattern ifAbsent: aBlock</body><body package="Isam Toolbox">allKeysAtPattern: aPattern ifAbsentPut: aBlock	^self allKeysAtPattern: aPattern		ifAbsent: [self allKeysAtPattern: aPattern put: aBlock value]</body><body package="Isam Toolbox">allKeysAtPattern: aPattern put: aCollection	| oldKeys |	oldKeys := patternsToKeys at: aPattern ifAbsent: [#()].	patternsToKeys at: aPattern put: aCollection.	tally := tally - oldKeys size + aCollection size.	self maxAllKeys: aCollection.	self reSort.	^aCollection</body><body package="Isam Toolbox">allKeysSorted	allKeysSorted ifNil: [allKeysSorted := self allKeys sorted].	^allKeysSorted</body><body package="Isam Toolbox">keyAtIndex: anIndex	^(self allKeysAtIndex: anIndex to: anIndex) first</body><body package="Isam Toolbox">keyAtPattern: aPattern	^self keyAtPattern: aPattern ifAbsent: [self error: (#cannotFindKey &lt;&lt; #isam &gt;&gt; 'cannot find key') asString]</body><body package="Isam Toolbox">keyAtPattern: aPattern ifAbsent: aBlock	| keys |	keys := self allKeysAtPattern: aPattern ifAbsent: [^aBlock value].	keys isEmpty ifTrue: [^aBlock value].	^keys first</body><body package="Isam Toolbox">keyAtPattern: aPattern ifAbsentPut: aBlock	^self keyAtPattern: aPattern		ifAbsent: [self keyAtPattern: aPattern put: aBlock value]</body><body package="Isam Toolbox">keyAtPattern: aPattern put: aKey	| keys |	keys := self allKeysAtPattern: aPattern				ifAbsentPut: [OrderedCollection new].	keys add: aKey.	tally := tally + 1.	self maxKey: aKey.	self reSort.	^aKey</body></methods><methods><class-id>Heeg.Isam.IsamIndex</class-id> <category>removing keys</category><body package="Isam Toolbox">removeAllKeysAtPattern: aPattern	^self removeAllKeysAtPattern: aPattern		ifAbsent: 			[self error: (#cannotFindKeys &lt;&lt; #isam &gt;&gt; 'cannot find keys') asString]</body><body package="Isam Toolbox">removeAllKeysAtPattern: aPattern ifAbsent: aBlock	| oldKeys |	oldKeys := patternsToKeys removeKey: aPattern ifAbsent: [^aBlock value].	tally := tally - oldKeys size.	^oldKeys</body><body package="Isam Toolbox">removeAtIndex: anIndex	^self removeKeyAtIndex: anIndex</body><body package="Isam Toolbox">removeKey: aKey	^self removeKey: aKey ifAbsent: [self error: (#cannotFindKey &lt;&lt; #isam &gt;&gt; 'cannot find key') asString]</body><body package="Isam Toolbox">removeKey: aKey ifAbsent: aBlock	| pattern keys |	pattern := aKey asPattern.	keys := self allKeysAtPattern: pattern ifAbsent: [^aBlock value].	keys remove: aKey ifAbsent: [^aBlock value].	tally := tally - 1.	^aKey</body><body package="Isam Toolbox">removeKeyAtIndex: anIndex	| key |	key := self keyAtIndex: anIndex.	^self removeKey: key</body></methods><methods><class-id>Heeg.Isam.IsamIndex</class-id> <category>initialize-release</category><body package="Isam Toolbox">initializeFor: size	self initialize.	tally := 0.	patternsToKeys := Dictionary new: size</body></methods><methods><class-id>Heeg.Isam.IsamIndex</class-id> <category>private</category><body package="Isam Toolbox">addAll: anArray 		anArray do: [:each | self add: each ].</body><body package="Isam Toolbox">reSort	allKeysSorted := nil</body></methods><methods><class-id>Heeg.Isam.IsamIndex</class-id> <category>enumerating</category><body package="Isam Toolbox">do: aBlock	patternsToKeys do: [:keys | keys do: aBlock]</body></methods><methods><class-id>Heeg.Isam.IsamIndex</class-id> <category>testing</category><body package="Isam Toolbox">isEmpty	^self size isZero</body></methods><methods><class-id>Heeg.Isam.IsamIndex</class-id> <category>adding</category><body package="Isam Toolbox">add: aKey	^self keyAtPattern: aKey asPattern put: aKey</body></methods><methods><class-id>Heeg.Isam.IsamIndex class</class-id> <category>instance creation</category><body package="Isam Toolbox">new	^self new: 0</body><body package="Isam Toolbox">new: aSize	^self basicNew initializeFor: aSize</body></methods><methods><class-id>Heeg.Isam.IsamIntegerField</class-id> <category>reading-writing</category><body package="Isam Toolbox">readFrom: aStream 	"read a byte description of an integer from the stream"	^ self readIntegerFrom: aStream</body><body package="Isam Toolbox">write: anInt to: aStream 	"store a binary description of the int for fast reading. The int fields   	are preceeded by a byte for the number of indexable fields. If the  	number is negative, then this byte has bit 8 set"	self writeInteger: anInt to: aStream</body></methods><methods><class-id>Heeg.Isam.IsamIntegerField</class-id> <category>accessing</category><body package="Isam Toolbox">byteSizeOf: anInt	"return the number of bytes for this integer"		^ self integerSizeOf: anInt</body><body package="Isam Toolbox">check: value	^value isKindOf: Integer</body><body package="Isam Toolbox">type	"the class name that describes the type"	^'Integer' asIs</body></methods><methods><class-id>Heeg.Isam.IsamClient</class-id> <category>isam protocol access</category><body package="Isam Toolbox">checkIndicesForOverlap	| result |	isamCollection activateClient: self.	result := isamCollection checkIndicesForOverlap.	isamCollection passivateClient.	^result</body><body package="Isam Toolbox">checkIntegrity	| result |	isamCollection activateClient: self.	result := isamCollection checkIntegrity.	isamCollection passivateClient.	^result</body><body package="Isam Toolbox">compaction	"Be careful! In a multi user environment, this is a very dangerous message!"	| result |	isamCollection activateClient: self.	result := isamCollection compaction.	isamCollection passivateClient.	^result</body><body package="Isam Toolbox">fragmentation	^isamCollection fragmentation</body><body package="Isam Toolbox">loadFrom: aFile	"Be careful! In a multi user environment, this is a very dangerous message!"	| result |	isamCollection activateClient: self.	result := isamCollection loadFrom: aFile.	isamCollection passivateClient.	^result</body><body package="Isam Toolbox">saveTo: aFile	| result |	isamCollection activateClient: self.	result := isamCollection saveTo: aFile.	isamCollection passivateClient.	^result</body><body package="Isam Toolbox">size	^isamCollection size</body><body package="Isam Toolbox">streamFragmentation	^isamCollection streamFragmentation</body></methods><methods><class-id>Heeg.Isam.IsamClient</class-id> <category>initialize-release</category><body package="Isam Toolbox">detach	self release</body><body package="Isam Toolbox">detachWithoutSaving	"remove myself from my isam collection's clients. Even if I was the last   	client, my isam collection will not save itself. In a multi user  	environment, this message should be used in emergency situations only"	isamCollection notNil ifTrue: [isamCollection removeClient: self].	isamCollection := nil.	currentPage := nil.	savedPages := nil</body><body package="Isam Toolbox">release	super release.	isamCollection notNil		ifTrue: [isamCollection removeClient: self].	isamCollection := nil.	currentPage := nil.	savedPages := nil</body></methods><methods><class-id>Heeg.Isam.IsamClient</class-id> <category>accessing</category><body package="Isam Toolbox">currentKeyClass	^currentKeyClass</body><body package="Isam Toolbox">currentKeyClass: classOrSymbol 	currentKeyClass := classOrSymbol isSymbol				ifTrue: [((LiteralBindingReference pathString: classOrSymbol)						method: thisContext method) value]				ifFalse: [classOrSymbol]</body><body package="Isam Toolbox">filterBlock	^filterBlock</body><body package="Isam Toolbox">filterBlock: aString	filterBlock := aString</body><body package="Isam Toolbox">filterMode	^filterMode</body><body package="Isam Toolbox">filterMode: aSymbol	filterMode := aSymbol</body><body package="Isam Toolbox">isamCollection	^isamCollection</body><body package="Isam Toolbox">isamCollection: anIsamCollection	isamCollection := anIsamCollection</body><body package="Isam Toolbox">searchPattern	^searchPattern</body><body package="Isam Toolbox">searchPattern: aPattern	searchPattern := aPattern</body><body package="Isam Toolbox">searchString	^searchString</body><body package="Isam Toolbox">searchString: aString	searchString := aString</body></methods><methods><class-id>Heeg.Isam.IsamClient</class-id> <category>record access</category><body package="Isam Toolbox">getAllRecords	"return a copy of all records from my isam collection according to search 	key and the current filter. My user should treat them as read only, 	because I don't keep track of them in my current page"	| r |	isamCollection activateClient: self.	r := isamCollection getAllRecords.	isamCollection passivateClient.	^r copy</body><body package="Isam Toolbox">getRecords	"get all records for the keys contained in currentPage"	| r k keys |	keys := OrderedCollection new: currentPage size.	1 to: (addedItem			ifTrue: [currentPage size - 1]			ifFalse: [currentPage size])		do: [:i | (k := currentPage at: i) ~= -1 ifTrue: [keys add: k value]].	isamCollection activateClient: self.	r := isamCollection getRecordsFor: keys.	isamCollection passivateClient.	^r copy</body><body package="Isam Toolbox">recordAtKey: aKey	| newItem r |	(newItem := self getRealItemFrom: aKey) isNil ifTrue: [^nil].	isamCollection activateClient: self.	r := (isamCollection recordAtKey: newItem) copy.	r copyPositionFrom: aKey. "So the positions in record and my curren page are consistent"	isamCollection passivateClient.	^r</body></methods><methods><class-id>Heeg.Isam.IsamClient</class-id> <category>current page</category><body package="Isam Toolbox">addToPage: anItem	"extend my currentPage with the recordPosition of anItem"	| posItem |	posItem := IsamItem new copyPositionFrom: anItem.	addedItem		ifTrue: [currentPage last key: posItem value: posItem copy]		ifFalse: [currentPage add: (Association key: posItem value: posItem copy).				addedItem := true]</body><body package="Isam Toolbox">buildPage: aPage 	"an OrderedCollection of items, aPage, is about to be sent to the user. 	Save all of its record positions and lengths for future update"	| r |	aPage isEmpty ifTrue: [^self].	addedItem := false.	self newCurrentPage: aPage size.	r := ReadStream on: aPage.	currentPage do: 		[:each | 		each key copyPositionFrom: r next.		each value: each key copy]</body><body package="Isam Toolbox">getRealItemFrom: anItem 	"my user sends me an item, containing the position and length it had 	when I made it visible to him, but may have changed in between. So I 	have to look up in my current page and construct a copy of this item 	with the correct record position and length"	| oldPos newItem |	currentPage isNil ifTrue: [^nil].	oldPos := anItem recordPosition.	currentPage notNil		ifTrue:			[currentPage do: [:each | each key recordPosition = oldPos				ifTrue: 					[each value recordPosition = -1 ifTrue: [^nil].					newItem := anItem copy.					newItem copyPositionFrom: each value.					^newItem]]].	^nil</body><body package="Isam Toolbox">pageRemove: anItem 	"anItem was removed from my isam collection. If currentPage contains this item, 	then mark it as removed"	| oldPos |	oldPos := anItem recordPosition.	currentPage do:		[:each | each value recordPosition = oldPos					ifTrue: [^each value recordPosition: -1]].	savedPages do:		[:page | page do:			[:each | each value recordPosition = oldPos					ifTrue: [^each value recordPosition: -1]]]</body><body package="Isam Toolbox">pageUpdate: oldItem with: newItem 	"record position and length of oldItem have changed to those of newItem. 	If currentPage contains oldItem, then keep track of these changes"	| oldPos |	currentPage isNil ifTrue: [^self].	oldPos := oldItem recordPosition.	currentPage do:		[:each | each value recordPosition = oldPos					ifTrue: [^each value copyPositionFrom: newItem]].	savedPages do:		[:page | page do:			[:each | each value recordPosition = oldPos					ifTrue: [^each value copyPositionFrom: newItem]]]</body><body package="Isam Toolbox">resetCurrentPage	currentPage := OrderedCollection new</body><body package="Isam Toolbox">restoreCurrentPage	"pop the last saved page and use it again as current page"	currentPage := savedPages removeLast</body><body package="Isam Toolbox">rollPage: aPage	"Same as buildPage, except that if aPage has fewer records than  	currentPage, than currentPage's size remains unchanged, with aPage's  	records inserted at the beginning. This is useful in backward paging,  	because it leads to a full first page of valid keys"		| restOfOldPage oldSize |	aPage isEmpty ifTrue: [^self].	oldSize := addedItem		ifTrue: [currentPage size - 1]		ifFalse: [currentPage size].	restOfOldPage := currentPage		copyFrom: 1		to: oldSize - aPage size.	self buildPage: aPage.	currentPage addAll: restOfOldPage</body><body package="Isam Toolbox">saveCurrentPage	"add my current page to savedPages, so that another page can be used 	without using the current page"	savedPages addLast: currentPage.	currentPage := OrderedCollection new</body></methods><methods><class-id>Heeg.Isam.IsamClient</class-id> <category>add/remove/rewrite</category><body package="Isam Toolbox">add: aRecord	isamCollection activateClient: self.	isamCollection add: aRecord.	self addToPage: aRecord.	isamCollection passivateClient.	^aRecord copy</body><body package="Isam Toolbox">remove: aRecord ifAbsent: aBlock	| newItem r |	(newItem := self getRealItemFrom: aRecord) isNil ifTrue: [^nil].	isamCollection activateClient: self.	r := isamCollection remove: newItem ifAbsent: aBlock.	isamCollection passivateClient.	^r</body><body package="Isam Toolbox">rewrite: aKey with: aRecord	"As opposed to IsamCollection and ExtendedIsamCollection, the 	recordPosition of aKey from the user's point of view remains valid across 	a rewrite"	| newItem r |	isamCollection activateClient: self.	(newItem := self getRealItemFrom: aKey) isNil		ifTrue: 			[r := aRecord.			isamCollection add: aRecord.			self pageUpdate: newItem with: aRecord]		ifFalse: [r := isamCollection rewrite: newItem with: aRecord].	isamCollection passivateClient.	^r copy copyPositionFrom: aKey</body></methods><methods><class-id>Heeg.Isam.IsamClient</class-id> <category>index selection</category><body package="Isam Toolbox">selectIndex: keyClass 	"a given search pattern or a key filter usually don't make sense for 	another index. 	Furthermore, as a preparation for remote access, selectIndex should be 	called with 	a symbol instead of a class name"	searchString := searchPattern := nil.	filterMode == #keys ifTrue: [filterMode := #records].	currentKeyClass := keyClass isSymbol				ifTrue: [((LiteralBindingReference pathString: keyClass)						method: thisContext method) value]				ifFalse: [keyClass]</body></methods><methods><class-id>Heeg.Isam.IsamClient</class-id> <category>searching</category><body package="Isam Toolbox">searchAll	"search all keys fitting into the given filter according to searchKey"	| newPage |	isamCollection activateClient: self.	newPage := isamCollection searchAll.	isamCollection passivateClient.	self buildPage: newPage.	^newPage copy</body><body package="Isam Toolbox">searchFirst: count	"search the first count keys fitting into the given filter according to searchKey"	| newPage |	isamCollection activateClient: self.	newPage := isamCollection searchFirst: count.	isamCollection passivateClient.	self buildPage: newPage.	^newPage copy</body><body package="Isam Toolbox">searchLast: count	"search the last count keys fitting into the given filter according to searchKey"	| newPage |	isamCollection activateClient: self.	newPage := isamCollection searchLast: count.	isamCollection passivateClient.	self buildPage: newPage.	^newPage copy</body><body package="Isam Toolbox">searchNext: count afterItem: anItem	| newItem newPage |	(newItem := self getRealItemFrom: anItem) isNil ifTrue: [^OrderedCollection new].	isamCollection activateClient: self.	newPage := isamCollection searchNext: count afterItem: newItem.	isamCollection passivateClient.	self buildPage: newPage.	^newPage copy</body><body package="Isam Toolbox">searchNext: count backwardFromItem: anItem	| newItem newPage |	(newItem := self getRealItemFrom: anItem) isNil ifTrue: [^OrderedCollection new].	isamCollection activateClient: self.	newPage := isamCollection searchNext: count backwardFromItem: newItem.	isamCollection passivateClient.	self rollPage: newPage.	^newPage copy</body><body package="Isam Toolbox">searchNext: count beforeItem: anItem	| newItem newPage |	(newItem := self getRealItemFrom: anItem) isNil ifTrue: [^OrderedCollection new].	isamCollection activateClient: self.	newPage := isamCollection searchNext: count beforeItem: newItem.	isamCollection passivateClient.	self rollPage: newPage.	^newPage copy</body><body package="Isam Toolbox">searchNext: count forwardFromItem: anItem	| newItem newPage |	(newItem := self getRealItemFrom: anItem) isNil ifTrue: [^OrderedCollection new].	isamCollection activateClient: self.	newPage := isamCollection searchNext: count forwardFromItem: newItem.	isamCollection passivateClient.	self buildPage: newPage.	^newPage copy</body><body package="Isam Toolbox">searchNext: count greaterEqual: aKey	| newPage |	isamCollection activateClient: self.	newPage := isamCollection searchNext: count greaterEqual: aKey.	isamCollection passivateClient.	self buildPage: newPage.	^newPage copy</body><body package="Isam Toolbox">searchNext: count lessEqual: aKey	| newPage |	isamCollection activateClient: self.	newPage := isamCollection searchNext: count lessEqual: aKey.	isamCollection passivateClient.	self buildPage: newPage.	^newPage copy</body><body package="Isam Toolbox">setFilterBlock: aFilter applyTo: keysOrRecords 	"set filterBlock to the result result of compiling aFilter. Store in filterMode 	whether to apply filterBlock to keys (applyTo: #keys) or to records 	(applyTo: #records)"	filterBlock := aFilter. "this is for nil filters"	aFilter notNil ifTrue: [filterBlock := (FilterExpression fromString: aFilter) filter].	filterMode := keysOrRecords</body><body package="Isam Toolbox">setSearchPattern: aPattern	"Memorize aPattern as well as its fully qualified part before its first 	wildcard in my instance variables. My pattern search methods will use 	these variables"	| firstWildCard oldPattern |	oldPattern := searchPattern.	aPattern isNil ifTrue: [^searchPattern := nil].	searchPattern := aPattern copy.	firstWildCard := isamCollection indexOfFirstWildCardIn: aPattern.	firstWildCard == 0		ifTrue: [searchString := aPattern copy]		ifFalse: [firstWildCard == 1				ifTrue: [searchString := nil]				ifFalse: [searchString := aPattern copyFrom: 1 to: firstWildCard - 1]].	^oldPattern</body></methods><methods><class-id>Heeg.Isam.IsamClient</class-id> <category>As yet unclassified</category><body package="Isam Toolbox">on: filename records: records keys: keys	currentPage := OrderedCollection new.	savedPages := OrderedCollection new.	addedItem := false.	isamCollection := SharedIsamCollection on: filename records: records keys: keys.	isamCollection addClient: self</body></methods><methods><class-id>Heeg.Isam.IsamClient</class-id> <category>private</category><body package="Isam Toolbox">newCurrentPage: size 	"if the required size of my currentPage has changed, set my current page 	 to an OrderedCollection of size elements, each one an Association of two 	 isam items"	currentPage size = size		ifFalse: 			[currentPage := OrderedCollection new: size.			1 to: size do: [:i | currentPage add: (Association key: IsamItem new value: nil)]]</body></methods><methods><class-id>Heeg.Isam.IsamClient class</class-id> <category>instance creation</category><body package="Isam Toolbox">on: filename records: records keys: keys	^self new on: filename records: records keys: keys</body></methods><methods><class-id>Heeg.Isam.IsamCollectionOfStringField</class-id> <category>accessing</category><body package="Isam Toolbox">type	"the type(name) of this field"	^'CollectionOfString' asIs</body></methods><methods><class-id>Heeg.Isam.IsamCollectionOfStringField</class-id> <category>initialize-release</category><body package="Isam Toolbox">elementType	^ IsamStringField</body></methods><methods><class-id>Heeg.Isam.IsamTimestampField</class-id> <category>reading-writing</category><body package="Isam Toolbox">readFrom: aStream	"read a byte description of an timestamp in microseconds from the stream"	| microsec |	microsec := self readIntegerFrom: aStream.	^TimeZone default		universalToLocal: (Timestamp new setFromMicroseconds: microsec)</body><body package="Isam Toolbox">write: aTimestamp to: aStream 	"store a binary description of the date for fast reading."	self writeInteger: aTimestamp asMicrosecondsGMT to: aStream</body></methods><methods><class-id>Heeg.Isam.IsamTimestampField</class-id> <category>accessing</category><body package="Isam Toolbox">byteSizeOf: aTimestamp	"return the number of bytes the concrete value would use up"		^self integerSizeOf: aTimestamp asMicroseconds</body><body package="Isam Toolbox">check: value	^value isKindOf: Timestamp</body><body package="Isam Toolbox">type	"the class name that describes the type"	^'Timestamp' asIs</body></methods><methods><class-id>Heeg.Isam.IsamDateField</class-id> <category>accessing</category><body package="Isam Toolbox">byteSizeOf: date	"return the number of bytes for this date"		^ self integerSizeOf: date asDays</body><body package="Isam Toolbox">check: value	^value isKindOf: Date</body><body package="Isam Toolbox">type	"the class name that describes the type"	^'Date' asIs</body></methods><methods><class-id>Heeg.Isam.IsamDateField</class-id> <category>reading-writing</category><body package="Isam Toolbox">readFrom: aStream 	"read a byte description of an date from the stream"	^Date fromDays: (self readIntegerFrom: aStream)</body><body package="Isam Toolbox">write: date to: aStream 	"store a binary description of the date for fast reading."	self writeInteger: date asDays to: aStream</body></methods><methods><class-id>Heeg.Isam.IsamGermanDateField</class-id> <category>accessing</category><body package="Isam Toolbox">type	"the class name that describes the type"	^'GermanDate' asIs</body></methods><methods><class-id>Heeg.Isam.IsamUTF8TextField</class-id> <category>accessing</category><body package="Isam Toolbox">type	^'UTF8Text' asIs</body></methods><methods><class-id>Heeg.Isam.IsamUTF8TextField class</class-id> <category>accessing</category><body package="Isam Toolbox">isamStringFieldClass	^IsamUTF8StringField</body></methods><methods><class-id>Heeg.Isam.IsamCollectionOfUTF8StringField</class-id> <category>initialize-release</category><body package="Isam Toolbox">elementType	^IsamUTF8StringField</body></methods><methods><class-id>Heeg.Isam.IsamCollectionOfUTF8StringField</class-id> <category>accessing</category><body package="Isam Toolbox">type	"the type(name) of this field"	^'CollectionOfUTF8String' asIs</body></methods><methods><class-id>Core.Timestamp</class-id> <category>conversion</category><body package="Isam Toolbox">asMicrosecondsGMT	"Answer the number of microseconds since January 1, 1901."	| localSeconds secondsGMT |	localSeconds := self asSeconds.	secondsGMT := TimeZone default convertLocalSecondsToGMT: localSeconds.	^( secondsGMT * 1000000) + (milliseconds * 1000)</body></methods><methods><class-id>OS.Filename</class-id> <category>testing</category><body package="Isam Toolbox">isExclusivelyAccessable	^	[| accessableFilename |	self exists not or: 			[accessableFilename := (self asString , '.accessable') asFilename.			self renameTo: accessableFilename.			accessableFilename renameTo: self.			true]]			on: Error			do: [false]</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="Isam Toolbox">hashISAM	^self hash</body></methods><methods><class-id>OS.FileEncodedStreamConstructor</class-id> <category>comparing</category><body package="Isam Toolbox">readWriteStreamExclusively	dataRepository isExclusivelyAccessable		ifFalse: 			[^self				error: ('cannot open file &lt;1p&gt; exclusively, seems it is opened by another process'						expandMacrosWith: self printString)].	^self readWriteStream</body></methods><methods><class-id>Core.Integer</class-id> <category>comparing</category><body package="Isam Toolbox">hashISAM	^self hashMultiply</body></methods><methods><class-id>Heeg.Isam.FilterExpression</class-id> <category>i18n</category><body package="Isam Toolbox">i18nIgnores	&lt;i18nSelectorsToIgnore&gt;	^#(#formatExpression:prio:level:on: #translateTree:on:)</body></methods><methods><class-id>Heeg.Isam.IsamItem class</class-id> <category>i18n</category><body package="Isam Toolbox">i18nIgnores	&lt;i18nSelectorsToIgnore&gt;	^#(#createClassMethodsFor:types: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: #variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: #createInstanceMethodsFor:types: #createForbiddenMethodsFor:)</body></methods><initialize><class-id>Heeg.Isam.SharedIsamCollection</class-id></initialize><initialize><class-id>Heeg.Isam.FilterExpression</class-id></initialize><initialize><class-id>Heeg.Isam.IsamItem</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>FileEncodedStreamConstructor</name><environment>OS</environment><super>Core.EncodedStreamConstructor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>