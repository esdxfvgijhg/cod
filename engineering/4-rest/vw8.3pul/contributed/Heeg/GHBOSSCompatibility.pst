<?xml version="1.0"?><st-source><!-- Name: GHBOSSCompatibilityNotice: © Copyright 2010 Georg Heeg e.K.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.(MIT License)Comment: This package provides compatibility for BOSS to read and write BOSS files that are compatible with VisualWorks 2.5.x and 3.x. This functionality mainly covers the namespace handling for older BOSS formats.The application developer must register the namespaces that contain the classes of objects in BOSS files. We only check local bindings - that means we do not check imported bindings. This is done as we have no control over imports in namespaces and we want to avoid name clashes when there are classes in the image with the same name but different namespaces. To register a namespace call the class method registerNamespace: in class BOSSCompatReader, i.e: 	BOSSCompatReader registerNamespace: HeegUsing the compatible BinaryObjectStorage uses the same methods as the regular BinaryObjectStorage.Examples:	reading objects:		CompatibleBinaryObjectStorage onOld: 'written-by-vw252.bos' asFilename readStream	writing objects:		CompatibleBinaryObjectStorage onNew: 'to-be-read-by-vw252.bos' asFilename writeStream===================Version History:1.5 - Holger Guhl; June 08, 2010- Updated Copyright notice1.4 - Holger Guhl; December 19, 2006- Verified for VisualWorks 7.5- added BOSSCompatReader class>>unregisterNamespace:1.3 - Holger Guhl; November 16, 2004- Bug fix in BOSSCompatWriter>>represent: 	Class should be written with plain unqualified name (i.e. symbol). 	But for meta-classes we ended up in 'xxx class'. 	We must use the instance behavior name, since meta flag is included in arg array.- Fix BinaryObjectStorage>>beBackwardCompatible (Remove redundant namespace qualifier 'Heeg')- New more reliable class resolution	Added BOSSCompatReader class>>resolveClass: (checks uniqueness of resolution)- Optimization in BOSSCompatReader>>importClass: 	Use improved #resolveClass:, save double class resolution by using #fullyQualifiedReference.- Robustness in BOSSCompatReader class>>registerNamespace: 	Reuse #registeredNamespaces, protect against invalid arguments.- Maintainance (package/class/method comments, all categories now 'GHBOSSCompatibility')1.2 - fixed some comments1.1 - replaced call to 'asTokensUsingDelimiter:' , which is not in the base system, with more compatible re-write1.0 - first public versionDbIdentifier: magdi.heeg.de.postgresDbTrace: 17594DbUsername: georgDbVersion: 7.7.1 - 1DevelopmentPrerequisites: #(#(#any 'BOSS' ''))PackageName: GHBOSSCompatibilityParcel: #('GHBOSSCompatibility')ParcelDirectory: c:\visworks\vw8.0 sep14.2\image\HeegContributions-vw8.0-2014-09-25-2\GHBOSSCompatibilityParcelName: GHBOSSCompatibilityPrerequisiteParcels: #(#('BOSS' ''))PrintStringCache: (7.7.1 - 1,georg)Version: 7.7.1 - 1Date: 3:30:43 PM September 25, 2014 --><time-stamp>From VisualWorks®, 8.0 of 15. September 2014 on 25. September 2014 at 15:30:43</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BOSSCompatReader</name><environment>Kernel</environment><super>Kernel.BOSSReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>registeredNamespaces </class-inst-vars><imports></imports><category>GHBOSSCompatibility</category><attributes><package>GHBOSSCompatibility</package></attributes></class><comment><class-id>Kernel.BOSSCompatReader</class-id><body>This subclass of BOSSReader supports reading of old BOSS files (from VW2.5.2) which have unqualified names for classes. In this class, names are looked up in the registered namespaces. Note: If a registered namespace is structured into more sub-namespaces, the current lookup mechanism may not be sufficient.Class Instance Variables:	registeredNamespaces 	&lt;Array of: GeneralNameSpace&gt; 	Namespaces to be looked up when resolving an unqualified class name. Each subclass may have an own registry.</body></comment><class><name>CompatibleBinaryObjectStorage</name><environment>Kernel</environment><super>Kernel.BinaryObjectStorage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GHBOSSCompatibility</category><attributes><package>GHBOSSCompatibility</package></attributes></class><comment><class-id>Kernel.CompatibleBinaryObjectStorage</class-id><body>CompatibleBinaryObjectStorage is a hook to create a BinaryObjectStorage that use different reader and writer to handle old BOSS data</body></comment><class><name>BOSSCompatWriter</name><environment>Kernel</environment><super>Kernel.BOSSWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GHBOSSCompatibility</category><attributes><package>GHBOSSCompatibility</package></attributes></class><comment><class-id>Kernel.BOSSCompatWriter</class-id><body>This class supports writing VW2.5.2-compatible BOSS streams. The main transformations are:- classes are written with their unqualified names- ByteStrings are written without a special encoding, because that encoding was only introduced in VW 5i.4</body></comment><shared-variable><name>NonuniqueClassSignal</name><environment>Kernel.BOSSCompatReader</environment><private>false</private><constant>false</constant><category>Signals</category><initializer>BOSSCompatReader initializeNonuniqueClassSignal</initializer><attributes><package>GHBOSSCompatibility</package></attributes></shared-variable><methods><class-id>Kernel.BOSSCompatReader</class-id> <category>private</category><body package="GHBOSSCompatibility">commitSources	" If we loaded any compiled methods,	commit the changes file and update the	source pointers now. "	compiledCode == nil ifFalse:		[compiledCode do: [:info | | code |			code := info code.			info become: code.  "identities are now swapped"			code commitCompiling: info]]</body></methods><methods><class-id>Kernel.BOSSCompatReader</class-id> <category>reading</category><body package="GHBOSSCompatibility">importClass: anArray 	"If the name specified in anArray is unqualified, resolve it from registered namespaces 	and replace the plain class name with the fully resolved class reference for further processing 	(see super implementor)"	| className existingClass |	className := anArray first.	existingClass := self class resolveClass: className.	existingClass isNil 		ifFalse: [anArray at: 1 put: existingClass fullyQualifiedReference].	^super importClass: anArray</body><body package="GHBOSSCompatibility">importSend: msgArray 	| msgReceiver |	(msgReceiver := msgArray first) isBehavior 		ifTrue: 			[| msgSelector newArray existingClass className |			(msgSelector := msgArray at: 2) == #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: 				ifTrue: 					["Build a subclass creation message for the Kernel namespace"					className := msgArray at: 3.					existingClass := self class resolveClass: className.					existingClass isNil 						ifTrue: [newArray := msgArray copyWith: nil]						ifFalse: 							[(existingClass superclass == msgReceiver and: [existingClass instanceVariablesString = (msgArray at: 4)])								ifTrue: [^existingClass].							newArray := msgArray copyWith: existingClass environment].					newArray at: 2						put: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:environment:.					^super importSend: newArray].			msgSelector == #classSideInstanceVariableNames: 				ifTrue: 					["Don't change the class if there is no difference"					msgReceiver class definitionMessage arguments first = (msgArray at: 3) 						ifTrue: [^msgReceiver class]]].	^super importSend: msgArray</body></methods><methods><class-id>Kernel.BOSSCompatReader class</class-id> <category>accessing</category><body package="GHBOSSCompatibility">defaultNamespaces	"Answer the namespaces that should always be registered.	Return: Array of: NameSpace"	^Array new</body><body package="GHBOSSCompatibility">namespaceForClass: className	"A class name may (5i.x or 7.x) or may not (2.5.x or 3.x) have a namespace attached.	If there is a namespace attached and the namespace is in the list of registered 	namespaces then ignore this.	If there is a namespace and it is not in the list of registered namespaces then	ignore the attached namespace and search for the class in the registered namespaces.	If there is no namespace attached then search for the class in the registered 	namespaces." 	| noNamespace dotIndex | 	self registeredNamespaces do: [:aNamespace |		| targetNamespace |		targetNamespace := aNamespace fullName asString copyWith: $..		((targetNamespace copyWith: $*) match: className) ifTrue: [^nil]].	noNamespace := className asString.	dotIndex := noNamespace lastIndexOf: $..	noNamespace := dotIndex = 0			ifTrue: [noNamespace asSymbol]			ifFalse: [(noNamespace copyFrom: dotIndex to: noNamespace size) asSymbol].	self registeredNamespaces do: [:aNamespace |		| targetNamespace |		"We only look into the local namespace without imports to be sure we 		only use classes from the registered namespaces. This avoids unintended		access to classes in not registered namespaces and therefore avoids 		namespace clashes"		targetNamespace := aNamespace localBindingFor: noNamespace.		targetNamespace isNil			ifFalse: [^aNamespace]].	^nil</body><body package="GHBOSSCompatibility">registerNamespace: aNamespace 	"Add a namespace to be looked up when resolving an unqualified class name."	| registered |	aNamespace isNameSpace 		ifFalse: [self error: 'Invalid object to be registered as namespace'].	((registered := self registeredNamespaces) includes: aNamespace) 		ifFalse: [registeredNamespaces := registered copyWith: aNamespace]</body><body package="GHBOSSCompatibility">registeredNamespaces	"Answer the namespaces to be looked up when resolving an unqualified class name.	Return: Array of: GeneralNameSpace"	^registeredNamespaces isNil 		ifTrue: [registeredNamespaces := Array new]		ifFalse: [registeredNamespaces]</body><body package="GHBOSSCompatibility">resolveClass: className 	"A class name may or may (5i4) or may not (252) have a namespace attached.	If there is a namespace attached and the namespace is in the list of registered 	namespaces then ignore this.	If there is a namespace and it is not in the list of registered namespaces then	ignore the attached namespace and search for the class in the registered namespaces.	If there is no namespace attached then search for the class in the registered 	namespaces."	| aBinding |	^(aBinding := BindingReference pathString: className) 		ifDefinedDo: [:theClass | theClass]		elseDo: 			[| matchingBindings simpleClassName sz |			matchingBindings := OrderedCollection new.			simpleClassName := aBinding simpleName.			self registeredNamespaces do: 				[:aNamespace | | aClass |				(aClass := aNamespace localBindingFor: simpleClassName) isNil 					ifFalse: [matchingBindings add: aClass]].			^(sz := matchingBindings size) = 0				ifTrue: ["return nil"]				ifFalse:					[sz &gt; 1 ifTrue: [NonuniqueClassSignal raiseSignal].					matchingBindings first value]]</body><body package="GHBOSSCompatibility">unregisterNamespace: aNamespace 	"Remove a namespace to be looked up when resolving an unqualified class name."	registeredNamespaces := self registeredNamespaces copyWithout: aNamespace</body></methods><methods><class-id>Kernel.BOSSCompatReader class</class-id> <category>class initialization</category><body package="GHBOSSCompatibility">initialize	"BOSSCompatReader initialize"	self defaultNamespaces 		do: [:aNamespace | self registerNamespace: aNamespace]</body><body package="GHBOSSCompatibility">initializeNonuniqueClassSignal	"BOSSCompatReader initializeNonuniqueClassSignal"	^(NonuniqueClassSignal := Object errorSignal newSignalMayProceed: true) 		notifierString: ('Class resolution in &lt;1s&gt; was not unique' 				expandMacrosWith: self name)</body></methods><methods><class-id>Kernel.CompatibleBinaryObjectStorage</class-id> <category>private-initialize-release</category><body package="GHBOSSCompatibility">initialize	"Hookup compatibility reader and writer"	super initialize.	self beBackwardCompatible</body></methods><methods><class-id>Kernel.BOSSCompatWriter</class-id> <category>representation</category><body package="GHBOSSCompatibility">represent: anObject 	"Represent objects so that they can be read by VW 2.5.2"	| rep |	rep := super represent: anObject.	(rep isMemberOf: Association) 		ifTrue: 			[rep key = storage class indexImportClass 				ifTrue: 					["Class is written with plain unqualified name (i.e. symbol). 					Note: Use name of instance behavior, since meta flag is included in arg array."					rep value at: 1 put: anObject instanceBehavior name]				ifFalse: 					[rep key = storage class indexImportByteString 						ifTrue: 							["ByteStrings do not have a special representation in 2.5.2"							rep := nil]]].	^rep</body></methods><methods><class-id>Kernel.BinaryObjectStorage</class-id> <category>initialize-release</category><body package="GHBOSSCompatibility">beBackwardCompatible	"Configure for using compatibility reader/writer."	self readerClass: BOSSCompatReader.	self writerClass: BOSSCompatWriter</body></methods><methods><class-id>Kernel.BOSSCompiledCodeHolder</class-id> <category>installing</category><body package="GHBOSSCompatibility">commitCompiling: code	"Install from source"	class notNil ifTrue:		[category notNil			ifTrue: [class compile: source classified: category]			ifFalse: [class compile: source]]</body></methods><initialize><class-id>Kernel.BOSSCompatReader</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>BOSSWriter</name><environment>Kernel</environment><super>Kernel.BOSSAbstractWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>BOSSCompiledCodeHolder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class selector category codeClass codeContents source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>BOSSReader</name><environment>Kernel</environment><super>Kernel.BOSSAbstractReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>BinaryObjectStorage</name><environment>Kernel</environment><super>Kernel.AbstractBinaryObjectStorage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class></st-source>