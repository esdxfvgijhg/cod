<?xml version="1.0"?><st-source><!-- Name: BackgroundColorNotice: © Copyright 2010 Boris Popov© Copyright 2010-2017 Georg Heeg e.K.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.(MIT License)Comment: Package BackgroundColor added methods in the Launcher system menu to allow a user to change the back color of the windows of an image. This allows a user to easily identify the windows of different images that are running to the same time on the same computer.DbIdentifier: magdi.heeg.de.postgresDbTrace: 67729DbUsername: danielDbVersion: 8.3 - 5PackageName: BackgroundColorParcel: #('BackgroundColor')ParcelDirectory: d:\visworks\vw8.3 jun17.2\HeegContributions-vw8.3-2017-06-13\BackgroundColorParcelName: BackgroundColorPrintStringCache: (8.3 - 5,daniel)Version: 8.3 - 5Date: 1:41:30 PM June 13, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.2) of 9. Juni 2017 on 13. Juni 2017 at 13:41:30</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CustomizableSkin</name><environment>UI.Skins.Default</environment><super>UI.Skins.Default.DefaultSkin</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>BackgroundColor</package></attributes></class><comment><class-id>UI.Skins.Default.CustomizableSkin</class-id><body>CustomizableSkin is a skin that has customizable colorPreferencesInstance Variables:	colorPreferences	&lt;ColorPreferencesDictionary&gt;	stores the colors</body></comment><class><name>VisualArtistPatch</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>BackgroundColor</package></attributes></class><class><name>EnvironmentTintedIcon</name><environment>UI</environment><super>UI.Icon</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalPalette </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>BackgroundColor</package></attributes></class><comment><class-id>UI.EnvironmentTintedIcon</class-id><body>EnvironmentTintedIcon is an icon that is tinted with a color that's installed in the Environment at Screen.EnvironmentColor. Before installing on a Window, it'll update its figure's palette to match the tint.Instance Variables:	originalPalette	&lt;Palette&gt;		the unmodified palette of the figure. The figure's palette will be updated before it is installed</body></comment><class><name>TintedPalette</name><environment>Graphics</environment><super>Graphics.ColorPalette</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tint originalPalette </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>BackgroundColor</package></attributes></class><comment><class-id>Graphics.TintedPalette</class-id><body>TintedPalette is a palette that returns ColorValues that have a different hue than the original palette. It is used to tint an existing palette with a certain color.The primise is that tinting every requested Color for an image is faster than tinting every color of a Palette in one slide.As a result this palette should only be used for smaller images (like those used in Icon objects, which is what this palette was made for).Instance Variables:	originalPalette	&lt;Palette&gt;		The palette that's being tinted	tint			&lt;ColorValue&gt; 	the color that provides the Hue value.</body></comment><shared-variable><name>EnvironmentColor</name><environment>Graphics.Screen</environment><private>false</private><constant>false</constant><category>colors</category><attributes><package>BackgroundColor</package></attributes></shared-variable><shared-variable><name>CurrentBaseColor</name><environment>UI.Skins.SkinRegistry</environment><private>false</private><constant>false</constant><category>singleton</category><initializer>ColorValue green</initializer><attributes><package>BackgroundColor</package></attributes></shared-variable><shared-variable><name>CurrentSkin</name><environment>UI.Skins.SkinRegistry</environment><private>false</private><constant>false</constant><category>singleton</category><attributes><package>BackgroundColor</package></attributes></shared-variable><methods><class-id>UI.Skins.Default.CustomizableSkin</class-id> <category>menus - icons</category><body package="BackgroundColor">setBaseColor: aColorValue	| lightColor highlightColor darkColor |	darkColor := ColorValue				hue: aColorValue hue				saturation: aColorValue saturation				brightness: aColorValue brightness / 2.	highlightColor := ColorValue				hue: darkColor hue				saturation: (darkColor saturation max: 0.3)				brightness: (darkColor brightness * 1.2 min: 1).	lightColor := ColorValue				hue: aColorValue hue				saturation: (aColorValue saturation min: 0.2)				brightness: (aColorValue brightness * 2 min: 1).	colorPreferences		at: #selectedFocusedElementBackgroundColor put: highlightColor;		at: #selectedElementBackgroundColor put: lightColor;		at: #lightColor put: lightColor;		at: #darkColor put: darkColor;		at: #highlightColor put: highlightColor;		at: #focusRingColor put: darkColor;		yourself</body></methods><methods><class-id>UI.Skins.Default.CustomizableSkin</class-id> <category>initialize-release</category><body package="BackgroundColor">initialize	super initialize.	colorPreferences := self class colorPreferences copy</body></methods><methods><class-id>Tools.VisualArtistPatch class</class-id> <category>class initialization</category><body package="BackgroundColor">initialize	"reset the visual artist so that its artists are recomputed with the provided override in place"	VisualArtist reset</body></methods><methods><class-id>UI.EnvironmentTintedIcon</class-id> <category>initialize-release</category><body package="BackgroundColor">figure: newFigure shape: newShape	super figure: newFigure shape: newShape.	originalPalette := newFigure image palette</body><body package="BackgroundColor">updatePalette	figure image palette: (Screen.EnvironmentColor				ifNil: [originalPalette]				ifNotNil: [:targetcolor | TintedPalette tintPalette: originalPalette using: targetcolor]).	(figure respondsTo: #flushCache) ifTrue:[figure flushCache].</body></methods><methods><class-id>UI.EnvironmentTintedIcon</class-id> <category>displaying</category><body package="BackgroundColor">displayOn: aGraphicsContext	(aGraphicsContext copy)		paint: Graphics.Screen.EnvironmentColor;		displayRectangle: (aGraphicsContext clippingRectangleOrNil					ifNil: [0@0 extent: 1000@1000]).	^super displayOn: aGraphicsContext</body><body package="BackgroundColor">installOn: aWindow	self updatePalette.	^super installOn: aWindow</body></methods><methods><class-id>UI.EnvironmentTintedIcon</class-id> <category>converting</category><body package="BackgroundColor">asColoredIcon	^self</body><body package="BackgroundColor">asNormalIcon	| uncoloredFigure |	uncoloredFigure := figure copy.	uncoloredFigure setImage: figure image copy.	uncoloredFigure image palette: originalPalette.	^Icon figure: uncoloredFigure shape: shape</body></methods><methods><class-id>UI.EnvironmentTintedIcon class</class-id> <category>initialize-release</category><body package="BackgroundColor">obsolete	ScheduledWindow scheduledWindows		do: [:each | each icon: each icon asNormalIcon].	UI.Skins.SkinRegistry		factoryMethodSelector: ((UI.Skins.SkinRegistry factoryMethodSelector				beginsWith: #default) ifTrue: [#defaultSkin] ifFalse: [#nativeSkin]).	super obsolete</body></methods><methods><class-id>Graphics.TintedPalette</class-id> <category>initialize-release</category><body package="BackgroundColor">initialize	super initialize.	tint := ColorValue white.	originalPalette := FixedPalette rgb8Bit</body><body package="BackgroundColor">tintPalette: aPalette using: aColor	originalPalette := aPalette.	tint := aColor</body></methods><methods><class-id>Graphics.TintedPalette</class-id> <category>collection accessing</category><body package="BackgroundColor">at: aKey put: anObject	self shouldNotImplement</body></methods><methods><class-id>Graphics.TintedPalette</class-id> <category>accessing</category><body package="BackgroundColor">asTintedColor: color	^ColorValue		hue: tint hue		saturation: color saturation		brightness: color brightness</body><body package="BackgroundColor">at: pixelValue ifAbsent: aBlock	| color |	color := originalPalette at: pixelValue ifAbsent: [^aBlock value].	^self asTintedColor: color</body><body package="BackgroundColor">indexOf: paintValue ifAbsent: exceptionBlock	^exceptionBlock value</body><body package="BackgroundColor">maxIndex	^originalPalette maxIndex</body><body package="BackgroundColor">size	^originalPalette size</body></methods><methods><class-id>Graphics.TintedPalette</class-id> <category>testing</category><body package="BackgroundColor">hasColor	^true</body><body package="BackgroundColor">hasGrayOrColor	^originalPalette hasGrayOrColor</body><body package="BackgroundColor">isMonochrome	^false</body></methods><methods><class-id>Graphics.TintedPalette</class-id> <category>removing</category><body package="BackgroundColor">removeKey: key ifAbsent: aBlock	self shouldNotImplement</body></methods><methods><class-id>Graphics.TintedPalette</class-id> <category>enumerating</category><body package="BackgroundColor">keysAndValuesDo: aBlock	originalPalette		keysAndValuesDo: [:key :value | aBlock value: key value: (self asTintedColor: value)]</body></methods><methods><class-id>Graphics.TintedPalette class</class-id> <category>instance creation</category><body package="BackgroundColor">new	^super new initialize</body><body package="BackgroundColor">tintPalette: aPalette using: aColor	^self new tintPalette: aPalette using: aColor</body></methods><methods><class-id>UI.Skins.Default.DefaultSkin class</class-id> <category>instance creation</category><body package="BackgroundColor">new	^super new initialize</body></methods><methods><class-id>Graphics.Screen class</class-id> <category>accessing</category><body package="BackgroundColor">environmentColor: aColorValue	EnvironmentColor = aColorValue		ifTrue: 			["Whenever #nativeSkin is called, the environmentColor will be reset. That creates a strange flickering window icon. If the color doesn't change nothing flickers."			^self].	EnvironmentColor := aColorValue.	ScheduledWindow		allInstancesDo: [:each | each icon ifNotNil: [:icon | each icon: icon asColoredIcon]]</body></methods><methods><class-id>Graphics.Screen</class-id> <category>private</category><body package="BackgroundColor">flushPaintPreferencesCache	super flushPaintPreferencesCache.	EnvironmentColor ifNotNil: 			[| policy |			policy := Screen default defaultPaintPreferences.			(Array 				with: SymbolicPaint menuBarBackground				with: SymbolicPaint menuBackground				with: SymbolicPaint background) 					do: [:paint | policy matchAt: paint put: EnvironmentColor]]</body></methods><methods><class-id>UI.Skins.SkinRegistry class</class-id> <category>singleton</category><body package="BackgroundColor">blueColor	^ColorValue		red: 160		green: 217		blue: 249		range: 255</body></methods><methods><class-id>UI.Skins.SkinRegistry class</class-id> <category>compiling</category><body package="BackgroundColor">classMethodsChanged	"tell VisualLauncher that its instanceMethodsChanged, resulting in recomputation of its menu. The Launcher's menu contains the Skin Menu and it needs to be rebuild to reflect the changes to our skin methods."	super instanceMethodsChanged.	VisualLauncher instanceMethodsChanged</body></methods><methods><class-id>UI.Skins.SkinRegistry class</class-id> <category>singleton</category><body package="BackgroundColor">createAndUseSkinForColor: color	| skin |	skin := UI.Skins.Default.CustomizableSkin new.	CurrentBaseColor := color.	skin setBaseColor: color.	Screen environmentColor: color.	^skin</body><body package="BackgroundColor">current	"Answer the singleton instance of the image's current skin."	HeadlessImage isHeadless ifTrue: [^UI.Skins.Default.DefaultSkinForRunningHeadless current].	"overridden to use the CurrentSkin variable. The normal impelementation would perform 	the #factoryMethodSelector again and rely on it using a DefaultSkin subclass's singleton.	CustomizableSkin instances can not return their singleton when the factoryMethod is called"	CurrentSkin isNil ifTrue:[CurrentSkin := self perform: self factoryMethodSelector].	^CurrentSkin</body><body package="BackgroundColor">factoryMethodSelector: aSelector	"Overridden to reset the CurrentSkin"	CurrentSkin := nil.	FactoryMethodSelector := aSelector.	UILookPolicy installLookPreferences</body><body package="BackgroundColor">useNativeSkinWithIconColor: aColor	"this implementation was copied from #defaultSkin"	Screen environmentColor: aColor.	self nativeSkinClassOrNil ifNotNil: [:class | ^class current].	^self defaultSkin</body></methods><methods><class-id>UI.VisualArtist class</class-id> <category>accessing</category><body package="BackgroundColor">computeArtists	"self computeArtists"	| computedArtists skinSelectors nativeDict |	computedArtists := Dictionary new.	self allSubclassesDo: 			[:artistClass |			artistClass isValid				ifTrue: 					[(Pragma allNamed: #view:skin:variant: in: artistClass class) do: 							[:pragma |														[:viewClassBinding :skinName :variantName |							((computedArtists at: viewClassBinding value ifAbsentPut: [Dictionary new])								at: skinName								ifAbsentPut: [Dictionary new]) at: variantName put: artistClass]									valueWithArguments: pragma arguments]]].	"overridden to inject all the other native-skin creation methods into the dictionary. 	An alternative approach would be to create more pragma-defining methods in the	various sub-classes but that can cause errors if new classes are added but no methods	are defined or if a class is removed"	skinSelectors := ((Pragma allNamed: #skin:				in: UI.Skins.SkinRegistry classBehavior) collect: #selector)				select: 					[:each |					"return all selectors that create a native skin except for the #native selector, that's already part of the &lt;computedArtists&gt; dictionaries"					(each beginsWith: #native) and: [each size &gt; #native size]].	computedArtists do: 			[:each |			nativeDict := each at: #native.			skinSelectors do: 					[:skinSelector |					"names in the dictionary are the selectors without the tailing #Skin"					each at: (skinSelector allButLast: 4) asSymbol put: nativeDict]].	Artists := computedArtists</body></methods><methods><class-id>UI.Icon class</class-id> <category>constants</category><body package="BackgroundColor">default	"Return the standard VisualWorks product icon."		"overridden to send #asColoredIcon. Otherwise new windows wouldn't have a colored icon"	^(self new		figure: self defaultFigure		shape: self defaultShape) asColoredIcon</body></methods><methods><class-id>UI.Icon</class-id> <category>converting</category><body package="BackgroundColor">asColoredIcon	^EnvironmentTintedIcon figure: figure shape: shape</body><body package="BackgroundColor">asNormalIcon	^self</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="BackgroundColor">newSystemIconApplyEnvironmentColor	&lt;triggerAtSystemEvent: #returnFromSnapshot&gt;	HeadlessImage isHeadless		ifFalse: 			[Screen default updatePaintPreferences.			WindowManager restoreAll]</body></methods><methods><class-id>UI.Skins.SkinRegistry class</class-id> <category>singleton</category><body package="BackgroundColor">defaultCustomBlueSkin	&lt;skin: 'Background - Blue'&gt;	^self createAndUseSkinForColor: self blueColor</body><body package="BackgroundColor">defaultCustomGreenSkin	&lt;skin: 'Background - Green'&gt;	^self createAndUseSkinForColor: (ColorValue red: 162 green: 249 blue: 160 range: 255)</body><body package="BackgroundColor">defaultCustomOrangeSkin	&lt;skin: 'Background - Orange'&gt;	^self createAndUseSkinForColor: (ColorValue red: 244 green: 192 blue: 160 range: 255)</body><body package="BackgroundColor">defaultCustomPinkSkin	&lt;skin: 'Background - Pink'&gt;	^self createAndUseSkinForColor: (ColorValue red: 244 green: 189 blue: 238 range: 255)</body><body package="BackgroundColor">defaultCustomRedSkin	&lt;skin: 'Background - Red'&gt;	^self createAndUseSkinForColor: (ColorValue red: 249 green: 160 blue: 160 range: 255)</body><body package="BackgroundColor">defaultCustomYellowSkin	&lt;skin: 'Background - Yellow'&gt;	^self createAndUseSkinForColor: (ColorValue red: 249 green: 248 blue: 160 range: 255)</body><body package="BackgroundColor">defaultGreenSkin	&lt;skin: 'Default - Green'&gt;	| skin |	skin := UI.Skins.Default.DefaultGreenSkin current.	"Overridden to set the environment color"	Screen environmentColor: (skin colorPreferences at: #selectedElementBackgroundColor).	^skin</body><body package="BackgroundColor">defaultRedSkin	&lt;skin: 'Default - Red'&gt;	| skin |	skin :=UI.Skins.Default.DefaultRedSkin current.	"overridden to set the environmentColor"	Screen environmentColor: (skin colorPreferences at: #selectedElementBackgroundColor).	^skin</body><body package="BackgroundColor">defaultSkin	&lt;skin: 'Default - Blue'&gt;	| skin |	skin :=UI.Skins.Default.DefaultSkin new.	"overridden to set the environment color"	Screen environmentColor: nil.	^skin</body><body package="BackgroundColor">emulatedWindowsSkin	&lt;skin: 'Emulated Windows'&gt;	"overridden to set the environment color"	Screen environmentColor: nil.	^UI.Skins.Windows.WindowsEmulatedSkin current</body><body package="BackgroundColor">nativeBlueIconSkin	&lt;skin: 'Native - Blue'&gt;	^self useNativeSkinWithIconColor: self blueColor</body><body package="BackgroundColor">nativeGreenIconSkin	&lt;skin: 'Native - Green'&gt;	^self useNativeSkinWithIconColor: (ColorValue red: 162 green: 249 blue: 160 range: 255)</body><body package="BackgroundColor">nativeOrangeIconSkin	&lt;skin: 'Native - Orange'&gt;	^self useNativeSkinWithIconColor: (ColorValue red: 244 green: 192 blue: 160 range: 255)</body><body package="BackgroundColor">nativePinkIconSkin	&lt;skin: 'Native - Pink'&gt;	^self useNativeSkinWithIconColor: (ColorValue red: 244 green: 189 blue: 238 range: 255)</body><body package="BackgroundColor">nativeRedIconSkin	&lt;skin: 'Native - Red'&gt;	^self useNativeSkinWithIconColor: (ColorValue red: 249 green: 160 blue: 160 range: 255)</body><body package="BackgroundColor">nativeSkin	&lt;skin: 'Native'&gt;	"overridden to set the environment color"	Screen environmentColor: nil.	self nativeSkinClassOrNil ifNotNil: [:class | ^class current].	^self defaultSkin</body><body package="BackgroundColor">nativeYellowIconSkin	&lt;skin: 'Native - Yellow'&gt;	^self useNativeSkinWithIconColor: (ColorValue red: 249 green: 248 blue: 160 range: 255)</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - icons</category><body package="BackgroundColor">skinMenu	&lt;itemInMenu: #(#menuBar #system) position: 50.02&gt;	| subMenu items groupedItems group |	items := (Pragma allNamed: #skin: in: UI.Skins.SkinRegistry classBehavior)				collect: 					[:each |					(MenuItem labeled: (each argumentAt: 1))						value: [UI.Skins.SkinRegistry factoryMethodSelector: each selector];						indication: [UI.Skins.SkinRegistry factoryMethodSelector = each selector];						yourself].	groupedItems := items				groupedBy: [:each | each label asString readStream upToAll: ' - '].	subMenu := Menu new.	groupedItems keys sorted do: 			[:key |			group := groupedItems at: key.			subMenu				addItemGroup: (group sorted: [:each | each label asString] ascending)].	^(MenuItem labeled: #skinMenu &lt;&lt; #menu &gt;&gt; 'Skin')		submenu: subMenu;		yourself</body></methods><initialize><class-id>Tools.VisualArtistPatch</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ColorPalette</name><environment>Graphics</environment><super>Graphics.Palette</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Palettes</category><attributes><package>Graphics-Palettes</package></attributes></class><class><name>Screen</name><environment>Graphics</environment><super>Graphics.HostGraphicsDevice</super><private>false</private><indexed-type>none</indexed-type><inst-vars>boundingBox subRegions resolution rendererName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>Icon</name><environment>UI</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figure shape </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>DefaultSkin</name><environment>UI.Skins.Default</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debug artistPrototypes coloredImages textStyles textAttributesForMenubar textAttributesForWidgets textAttributesForLists colorPreferences </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category></category><attributes><package>UISkinning-Skins-Default</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>