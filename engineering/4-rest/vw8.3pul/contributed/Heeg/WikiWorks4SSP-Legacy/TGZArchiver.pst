<?xml version="1.0"?><st-source><!-- Name: TGZArchiverNotice: Copyright © 1999-2010 Cincom Systems, Inc.  All Rights Reserved.Comment: Extracted from VW-Installer Framework for WikiWorks4SSPDbIdentifier: magdi.heeg.de.postgresDbTrace: 32840DbUsername: gheegDbVersion: 7.7.1 - 1DevelopmentPrerequisites: #(#(#any 'Compression-ZLib' '') #(#any 'StreamWritingExtensions' ''))PackageName: TGZArchiverPadded: trueParcel: #('TGZArchiver')ParcelDirectory: c:\visworks\vw8.0 sep14.2\image\HeegContributions-vw8.0-2014-09-25-2\WikiWorks4SSP\TGZArchiverParcelName: TGZArchiverPrerequisiteDescriptions: #(#(#name 'Compression-ZLib') #(#name 'StreamWritingExtensions' #componentType #package))PrerequisiteParcels: #(#('Compression-ZLib' '') #('StreamWritingExtensions' ''))PrintStringCache: (7.7.1 - 1,gheeg)Version: 7.7.1 - 1Datum:3:33:31 PM September 25, 2014 --><time-stamp>Von VisualWorks®, 8.0 von 15. September 2014 am 25. September 2014 um 15:33:31</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TGZArchiver</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buffer fileAttributes incrementAspect updateIncrement </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			OS.ZLib.*			</imports><category>System-Compression</category><attributes><package>TGZArchiver</package></attributes></class><comment><class-id>Tools.TGZArchiver</class-id><body>TGZArchiver is taken from VisualWorks-Installer-Framework.TGZArchiver is used to uncompress and untar the file 'wiki_supplementary.tar.gz' which contains the needed .ssp files.Below is the original comment-----------Handles zip, unzip and untar.  Tar not yet implemented.Instance Variables:	buffer	&lt;ByteArray&gt;	buffer used for copying files	fileAttributes	&lt;Dictionary&gt;	holds attributes from tar file record headers	incrementAspect	&lt;ByteSymbol&gt;	aspect representing bytes decompressed or extracted	updateIncrement	&lt;SmallInteger&gt;	threshold for forwarding incremental progress updates</body></comment><shared-variable><name>TARBlockSize</name><environment>Tools.TGZArchiver</environment><private>false</private><constant>false</constant><category>TAR constants</category><initializer>512</initializer><attributes><package>TGZArchiver</package></attributes></shared-variable><methods><class-id>Tools.TGZArchiver</class-id> <category>accessing</category><body package="TGZArchiver">buffer	^buffer isNil 		ifTrue: [buffer := ByteArray new: TARBlockSize]		ifFalse: [buffer]</body><body package="TGZArchiver">fileAttributes	^fileAttributes isNil 		ifTrue: [self resetFileAttributes]		ifFalse: [fileAttributes]</body><body package="TGZArchiver">updateIncrement	^updateIncrement isNil 		ifTrue: [updateIncrement := 0]		ifFalse: [updateIncrement]</body><body package="TGZArchiver">updateIncrement: anInteger	updateIncrement := anInteger</body></methods><methods><class-id>Tools.TGZArchiver</class-id> <category>accessing - file attributes</category><body package="TGZArchiver">canonicalizedFileString	^ self canonicalizeFileString: (self fileAttributes at: #filenameStringCanonicalized)</body><body package="TGZArchiver">canonicalizedLinkString	^self fileAttributes at: #linknameStringCanonicalized</body><body package="TGZArchiver">fileIsDirectory	^(self fileMode at: 3) = $4</body><body package="TGZArchiver">fileMode	^self fileAttributes at: #fileMode</body><body package="TGZArchiver">filePermissions	^self fileAttributes at: #permissions</body><body package="TGZArchiver">fileSize	^self fileAttributes at: #size</body><body package="TGZArchiver">fileTypeFlag	^self fileAttributes at: #fileType ifAbsent: []</body><body package="TGZArchiver">filename	^self fileAttributes at: #targetFile</body><body package="TGZArchiver">resetFileAttributes	^fileAttributes := Dictionary new</body><body package="TGZArchiver">setFileMode: aString 	self fileAttributes at: #fileMode put: aString</body><body package="TGZArchiver">setFilePermissions: aString 	self fileAttributes at: #permissions put: aString</body><body package="TGZArchiver">setFileSize: anInteger 	self fileAttributes at: #size put: anInteger</body><body package="TGZArchiver">setFileTypeFlag: aCharacter	self fileAttributes at: #fileType put: aCharacter</body><body package="TGZArchiver">setFilename: aFilename 	self fileAttributes at: #targetFile put: aFilename</body><body package="TGZArchiver">setFilenameStringCanonicalized: aString 	self fileAttributes at: #filenameStringCanonicalized		put: (self canonicalizeUnixFileString: aString)</body><body package="TGZArchiver">setLinknameStringCanonicalized: aString 	self fileAttributes at: #linknameStringCanonicalized		put: (self canonicalizeUnixFileString: aString)</body></methods><methods><class-id>Tools.TGZArchiver</class-id> <category>utils</category><body package="TGZArchiver">canonicalizeFileString: aString 	| comp1 comp2 |	comp1 := UnixFilename components: aString.	comp2 := NTFSFilename components: aString.	^  (Filename fromComponents: ((comp1 size &gt; comp2 size) 			ifTrue: [ comp1 ] ifFalse: [ comp2 ])) asString</body><body package="TGZArchiver">canonicalizeUnixFileString: aString 	^(Filename fromComponents: (UnixFilename components: aString)) asString</body><body package="TGZArchiver">preserveFilePermissions	| permissionsString permissions target |	target := self filename.	target class == UnixFilename 		ifTrue: 			[permissionsString := self filePermissions.			permissions := Integer readFrom: permissionsString readStream radix: 8.			target setProtection: permissions]</body><body package="TGZArchiver">untarFileContentsFrom: tarStream toFile: aFilename 	| writeStream |	aFilename ensureDirectoryNotifying: self.	writeStream := (aFilename withEncoding: #binary) writeStream.		[aFilename hasTextExtension 		ifTrue: 			[(self readStreamFrom: tarStream forTextFile: aFilename)				addDependent: self;				writeAllOn: writeStream					using: self buffer					notificationIncrement: self updateIncrement;				removeDependent: self]		ifFalse: 			[tarStream 				writeNext: self fileSize				on: writeStream				using: self buffer				notificationIncrement: self updateIncrement]] 			ensure: [writeStream close].	tarStream padTo: TARBlockSize</body><body package="TGZArchiver">untarLinkTo: aDirectory 	| source |	OSHandle currentOS = #unix ifFalse: [^self copyLinkTo: aDirectory].	source := aDirectory construct: self canonicalizedLinkString.	UnixProcess 		cshOne: 'ln -s "' , source asString , '" "' , self filename asString , '"'</body></methods><methods><class-id>Tools.TGZArchiver</class-id> <category>archiving</category><body package="TGZArchiver">copyLinkTo: aDirectory 	| source |	source := aDirectory construct: self canonicalizedLinkString.	source exists 		ifFalse: [^self changed: #untarLinkFailure with: self canonicalizedLinkString].	source copyTo: self filename.	self preserveFilePermissions</body><body package="TGZArchiver">untarArchive: tarFile 	^self untarArchive: tarFile to: tarFile directory</body><body package="TGZArchiver">untarArchive: tarFile to: aDirectory 	| tarStream |	incrementAspect := #untarIncrement.	tarStream := (tarFile withEncoding: #binary) readStream.		[tarStream addDependent: self.	self changed: #untarArchive with: tarFile.	self changed: #untarArchiveInitialize with: tarFile fileSize.	[tarStream atEnd not] 		whileTrue: [self untarNextFileFrom: tarStream to: aDirectory]] 			ensure: 				[tarStream					close;					removeDependent: self].	self changed: #untarArchiveComplete</body><body package="TGZArchiver">untarNextFileFrom: tarStream to: aDirectory 	| target |	self readFileAttributesFrom: tarStream.	self fileAttributes isEmpty ifTrue: [^self].	self foundLongLink ifTrue: [self processLongLinkFrom: tarStream].	target := aDirectory construct: self canonicalizedFileString.	self fileIsDirectory ifTrue:		[^target exists ifFalse: [target createDirectoryNotifying: self]].	self setFilename: target.	self fileIsLink ifTrue:		[^self untarLinkTo: aDirectory].	self		changed: #untarFile with: target asString;		changed: #untarFileInitialize with: self fileSize;		untarFileContentsFrom: tarStream toFile: target;		preserveFilePermissions.	self changed: #untarFileComplete with: self fileAttributes</body><body package="TGZArchiver">unzipFile: zippedFilename 	"Create an uncompressed version of zippedFilename.  Answer the newly created filename."	^self unzipFile: zippedFilename		to: (self unzippedNameOfFile: zippedFilename)</body><body package="TGZArchiver">unzipFile: zippedFilename to: unzippedFilename 	"Create an uncompressed version of zippedFilename.  Answer the newly created filename."	| zippedStream unzippedStream |	self changed: #unzipFile with: zippedFilename.	self changed: #unzipInitialize with: zippedFilename fileSize.	incrementAspect := #unzipIncrement.	zippedStream := GZipReadStream 				on: (zippedFilename withEncoding: #binary) readStream.	unzippedStream := (unzippedFilename withEncoding: #binary) writeStream.		[zippedStream addDependent: self.	zippedStream 		writeAllOn: unzippedStream		using: self buffer		notificationIncrement: self updateIncrement] 			ensure: 				[zippedStream					close;					removeDependent: self.				unzippedStream close].	self changed: #unzipComplete.	^unzippedFilename</body><body package="TGZArchiver">unzippedNameOfFile: zippedFilename 	"Answer the appropriate unzipped version of zippedFilename."	| tail extension newExtension newTail |	tail := zippedFilename tail.	extension := zippedFilename extension.	newExtension := extension = '.tgz' ifTrue: ['.tar'] ifFalse: [String new].	newTail := (tail copyFrom: 1 to: tail size - extension size) 				, newExtension.	^zippedFilename directory construct: newTail</body><body package="TGZArchiver">zipFile: unzippedFilename 	"Create a compressed version of unzippedFilename, with an appropriate extension.  Answer the newly created filename."	^self zipFile: unzippedFilename		to: (unzippedFilename directory construct: unzippedFilename tail , '.gz')</body><body package="TGZArchiver">zipFile: unzippedFilename to: zippedFilename 	"Create a compressed version of aFilename, with an appropriate extension.  Answer the newly created filename."	| unzippedStream zippedStream |	self changed: #zipFilename with: unzippedFilename asString.	self changed: #zipInitialize with: unzippedFilename fileSize.	incrementAspect := #zipIncrement.	unzippedStream := (unzippedFilename withEncoding: #binary) readStream.	zippedStream := GZipWriteStream 				on: (zippedFilename withEncoding: #binary) writeStream.		[unzippedStream addDependent: self.	unzippedStream 		writeAllOn: zippedStream		using: self buffer		notificationIncrement: self updateIncrement] 			ensure: 				[zippedStream close.				unzippedStream					close;					removeDependent: self].	self changed: #zipComplete.	^zippedFilename</body><body package="TGZArchiver">zippedNameOfFile: unzippedFilename 	"Answer a copy of zippedFilename with the gzip file extension '.gz' appended to it."	^unzippedFilename directory construct: unzippedFilename tail , '.gz'</body></methods><methods><class-id>Tools.TGZArchiver</class-id> <category>testing</category><body package="TGZArchiver">fileIsLink	^self fileTypeFlag == $1</body><body package="TGZArchiver">foundLongLink	^'*@LongLink' match: self canonicalizedFileString</body></methods><methods><class-id>Tools.TGZArchiver</class-id> <category>parsing</category><body package="TGZArchiver">processLongLinkFrom: tarStream 	| filenameString writeStream |	writeStream := ByteArray new writeStream.	tarStream 		writeNext: self fileSize		on: writeStream		using: self buffer.	tarStream padTo: TARBlockSize.	filenameString := (writeStream contents readStream upTo: 0) asString.	self		readFileAttributesFrom: tarStream;		setFilenameStringCanonicalized: filenameString</body><body package="TGZArchiver">readFileAttributesFrom: tarStream 	| bufferReadStream |	self resetFileAttributes.	(tarStream 		nextAvailable: TARBlockSize		into: self buffer		startingAt: 1) &lt; TARBlockSize 		ifTrue: [self error: 'TAR padding error'].	self buffer first = 0 ifTrue: [^self].	bufferReadStream := self buffer readStream.	self		readFilenameFrom: bufferReadStream;		readFileModeFrom: bufferReadStream;		readPermissionsFrom: bufferReadStream;		readSizeFrom: bufferReadStream;		readTypeFlagFrom: bufferReadStream.	self fileIsLink ifTrue:		[self readLinknameFrom: bufferReadStream]</body><body package="TGZArchiver">readFileModeFrom: readStream 	readStream position: 100.	self setFileMode: (readStream next: 4) asString</body><body package="TGZArchiver">readFilenameFrom: readStream 	| filenameString |	readStream position: 0.	filenameString := (readStream upTo: 0) asString.	self setFilenameStringCanonicalized: filenameString</body><body package="TGZArchiver">readLinknameFrom: readStream 	| filenameString |	readStream position: 157.	filenameString := (readStream upTo: 0) asString.	self setLinknameStringCanonicalized: filenameString</body><body package="TGZArchiver">readPermissionsFrom: readStream 	readStream position: 104.	self setFilePermissions: (readStream next: 3) asString</body><body package="TGZArchiver">readSizeFrom: readStream 	| sizeStream nextChar |	readStream position: 124.	sizeStream := String new writeStream.	[(nextChar := Character value: readStream next) isDigit] 		whileTrue: [sizeStream nextPut: nextChar].	self setFileSize: (Integer readFrom: sizeStream contents readStream				radix: 8)</body><body package="TGZArchiver">readTypeFlagFrom: readStream 	readStream position: 156.	self setFileTypeFlag: (Character value: readStream next)</body></methods><methods><class-id>Tools.TGZArchiver</class-id> <category>line ends</category><body package="TGZArchiver">readStreamFrom: tarStream forTextFile: aFilename 	"Read the entire text file into a byteArray.  Change all line ends to cr, then to the appropriate line end for the current platform."	| bytes |	bytes := ByteArray new: self fileSize.	tarStream 		writeNext: bytes size		on: bytes writeStream		using: self buffer		notificationIncrement: self updateIncrement.	bytes := bytes copyReplaceAll: #[13 10] with: #[13].	bytes replaceAll: 10 with: 13.	IOAccessor defaultLineEndConvention = LineEndCRLF 		ifTrue: [^(bytes copyReplaceAll: #[13] with: #[13 10]) readStream].	IOAccessor defaultLineEndConvention = LineEndLF 		ifTrue: [^(bytes replaceAll: 13 with: 10) readStream].	^bytes readStream</body></methods><methods><class-id>Tools.TGZArchiver</class-id> <category>updating</category><body package="TGZArchiver">update: anAspect with: aParameter	anAspect == #increment 		ifTrue: [^self changed: incrementAspect with: aParameter].	anAspect == #directoryCreated 		ifTrue: [^self changed: anAspect with: aParameter].	self halt.</body></methods><methods><class-id>Tools.TGZArchiver class</class-id> <category>documentation</category><body package="TGZArchiver">tarFileFormat	"`tar' Header Block, from POSIX 1003.1-1990.	POSIX header.	struct posix_header	{                               /* byte offset */	  char name[100];               /*   0 */	  char mode[8];                 /* 100 */	  char uid[8];                  /* 108 */	  char gid[8];                  /* 116 */	  char size[12];                /* 124 */	  char mtime[12];               /* 136 */	  char chksum[8];               /* 148 */	  char typeflag;                /* 156 */	  char linkname[100];           /* 157 */	  char magic[6];                /* 257 */	  char version[2];              /* 263 */	  char uname[32];               /* 265 */	  char gname[32];               /* 297 */	  char devmajor[8];             /* 329 */	  char devminor[8];             /* 337 */	  char prefix[155];             /* 345 */	                                /* 500 */	};		#define TMAGIC   ''ustar''        /* ustar and a null */	#define TMAGLEN  6	#define TVERSION ''00''           /* 00 and no null */	#define TVERSLEN 2		/* Values used in typeflag field.  */	#define REGTYPE  '0'            /* regular file */	#define AREGTYPE '\0'           /* regular file */	#define LNKTYPE  '1'            /* link */	#define SYMTYPE  '2'            /* reserved */	#define CHRTYPE  '3'            /* character special */	#define BLKTYPE  '4'            /* block special */	#define DIRTYPE  '5'            /* directory */	#define FIFOTYPE '6'            /* FIFO special */	#define CONTTYPE '7'            /* reserved */		/* Bits used in the mode field, values in octal.  */	#define TSUID    04000          /* set UID on execution */	#define TSGID    02000          /* set GID on execution */	#define TSVTX    01000          /* reserved file permissions */	#define TUREAD   00400          /* read by owner */	#define TUWRITE  00200          /* write by owner */	#define TUEXEC   00100          /* execute/search by owner */	#define TGREAD   00040          /* read by group */	#define TGWRITE  00020          /* write by group */	#define TGEXEC   00010          /* execute/search by group */	#define TOREAD   00004          /* read by other */	#define TOWRITE  00002          /* write by other */	#define TOEXEC   00001          /* execute/search by other */""16r0000 = filename16r0200 = next filename (or start of file contents)16r0264 = 	0040755 755 is file perms rwxr-xr-x, 0040 is dir			0100444 444 is file perms r--r--r--, 0100 is fileperms			size		date0040755	17				7541443	127	011006	5	bin0040755	17				7541443	161	011601	5	bin/win0100444	17	0130406	7513714	143	013537	0	bin/win/herald.bmp0100644	17	1170340	7513714	143	013562	0	.wav0100644	17	8r0130406	7513714	143	014067	0	heraldcs.bmp0100644	17	0401000	7513714	144	014440	0	linkmaster.dll0100644	17	0012600	7541443	131	013570	0	readme.txt0100555	17	2170000	8r7513714	145	013607	0	visual.exe				8r255134files padded to 16r200 bytes"	^self commentOnly</body></methods><methods><class-id>OS.Filename class</class-id> <category>utilities</category><body package="TGZArchiver">isTextExtension: aString 	^#('.htm' '.html' '.inc' '.ini' '.ssp' '.st' '.tld' '.txt') 		includes: aString</body></methods><methods><class-id>OS.Filename</class-id> <category>utilities</category><body package="TGZArchiver">createDirectoryNotifying: anObject 	| retried |		[self makeDirectory.	anObject update: #directoryCreated with: self] 			on: OSErrorHolder nonexistentSignal			do: 				[:ex | 				retried == true ifTrue: [ex pass].				self ensureDirectoryNotifying: anObject.				retried := true.				ex retry]</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="TGZArchiver">ensureDirectoryNotifying: anObject	| parent |	parent := self directory.	"Avoid looping on non-existent root directories, such as absent removable media."	parent = self ifTrue: [^self].	parent exists 		ifFalse: 			[parent				ensureDirectoryNotifying: anObject;				makeDirectory.			anObject update: #directoryCreated with: parent]</body></methods><methods><class-id>OS.Filename</class-id> <category>testing</category><body package="TGZArchiver">hasTextExtension	^self class isTextExtension: self extension</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>