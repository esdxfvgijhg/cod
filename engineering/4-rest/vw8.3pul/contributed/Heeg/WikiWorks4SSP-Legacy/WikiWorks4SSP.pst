<?xml version="1.0"?><st-source><!-- Name: WikiWorks4SSPNotice: © Copyright 2005-2013 Georg Heeg e.K.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.(MIT License)WikiWorks4SSP uses the following 3rd Party Software:TinyMCE - http://www.tinymce.com licensed under LGPL 2.1Comment: In VisualWorks 7.10 WikiWorks4SSP requires Web Application Server (Legacy) to be installed.WikiWorks4SSP with CSS support adapted to Web Toolkit 			by Martin Althuizes, Chris Burkert, Simone Ehrlich, Ulli John, Daniel Kümmel, Karsten Kusche, Markus Rips	and Roland Wagenerat Georg Heeg eKSee accompanying file "WikiWorks4SSP.pdf" for more infomation on installation, setup and administration.DbIdentifier: magdi.heeg.de.postgresDbTrace: 58291DbUsername: danielDbVersion: 7.10 - 12DevelopmentPrerequisites: #(#(#any 'WebToolkit' '') #(#any 'WebToolkit-Compatibility-API' '') #(#any 'TGZArchiver' '') #(#any 'Isam Toolbox' '') #(#any 'GHSpeedUpXMLParser' '') #(#any 'GHXhtmlSupport' ''))DialectVersion: VisualWorks 7.9PackageName: WikiWorks4SSPPadded: trueParcel: #('WikiWorks4SSP')ParcelDirectory: c:\visworks\vw8.1.1 feb16.2\image\Contributor\HeegContributions-vw8.1.1-2016-03-10\WikiWorks4SSP-Legacy\WikiWorks4SSPParcelName: WikiWorks4SSPPrerequisiteDescriptions: #(#(#name 'WebToolkit') #(#name 'WebToolkit-Compatibility-API') #(#name 'TGZArchiver') #(#name 'Isam Toolbox') #(#name 'GHSpeedUpXMLParser' #componentType #package) #(#name 'GHXhtmlSupport' #componentType #package))PrerequisiteParcels: #(#('WebToolkit' '') #('WebToolkit-Compatibility-API' '') #('TGZArchiver' '') #('Isam Toolbox' '') #('GHSpeedUpXMLParser' '') #('GHXhtmlSupport' ''))PrintStringCache: (7.10 - 12,daniel)Version: 7.10 - 12Post-Load Block: 	[:package |WikiWorks.Wiki installSSPFilesAndInitialize.Subsystem	allGeneralInstancesDo: [:subsystem | subsystem resetPrerequisites]]Date: 9:11:18 AM March 10, 2016 --><time-stamp>From VisualWorks®, 8.1.1 of 25. Februar 2016 on 10. März 2016 at 09:11:18</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>WikiWorks</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>WikiWorks</category><attributes><package>WikiWorks4SSP</package></attributes></name-space><class><name>CollectionAdapter</name><environment>WikiWorks</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>WikiWorks4SSP</package></attributes></class><class><name>WikiPage</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>author timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.WikiPage</class-id><body>aWiki consists of many pages. These instances of (subclasses of) WikiPage. Subclasses must implement the following messages:	accessing		allTitlesInto:		contents		title		versionNumber		versionsDo:		versionsReverseDo:	flat file		specificData:Instance Variables:	author	&lt;String&gt;	description of author	timestamp	&lt;Timestamp&gt;	description of timestamp</body></comment><class><name>ChangedWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.WikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>previousVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.ChangedWikiPage</class-id><body>ChangedWikiPage is the abstract superclass WikiPages which are not a "boring" OriginalWikiPage Instance Variables:	previousVersion	&lt;WikiPage&gt;	description of previousVersion</body></comment><class><name>EditedWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.ChangedWikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.EditedWikiPage</class-id><body>Most of the wikiPages in a Wiki are EditedWikiPages. If the content of a page changes (no rename or reverting) a new EditedWikiPage is created.Instance Variables:	contents	&lt;FlatFileWiki&gt;	description of contents</body></comment><class><name>ConfigurationSection</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name dataMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.ConfigurationSection</class-id><body>ConfigurationRegistry and ConfigurationSection are used to parse the wiki.ini configuration file.Instance Variables:	dataMap	&lt;Dictionary&gt;	description of dataMap	name	&lt;Object | Proxy&gt;	description of name</body></comment><class><name>RevertedWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.ChangedWikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>revertedVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.RevertedWikiPage</class-id><body>a reverted Page is an old version of a page which has been made the actual one.for example: Version 0 is the OriginalWikiPage.Version 1 and version 2 are EditedWikiPages.Now someone created accidently a new version (version 3).If you want to restore version 2, you can use the "Revert" function.The new version 4 is created. The content is similar to version 2, but timstamp and Author (IP Adress) are new.Instance Variables:	revertedVersion	&lt;WikiPage&gt;	description of revertedVersion</body></comment><class><name>ConfigurationRegistry</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.ConfigurationRegistry</class-id><body>ConfigurationRegistry and ConfigurationSection are used to parse the wiki.ini configuration file.Instance Variables:	sections	&lt;(Collection of: (AbsentClassImport | AbstractModification | AbstractTag | AssociationTree | AttributeDef | Behavior | BehaviorShell | BlessingLevel | BlockAnalysisVariable | BufferedExternalStream | Change | CharacterEncoder | ClassDescriptor | ClassDiagramModel | CMacroDefinition | CodeComponent | CodeToolSelectionPolicy | ComponentDescription | CompositeWiki | ConfigurationSection | ConnectionProfile | CType | Cursor | DatumDescriptor | DBRecord | DBUserGroup | DefClassModel | DefNameSpaceModel | EncodedStream | Entity | ExternalConnection | ExternalDatabaseColumnDescription | ExternalLibrary | ExternalLibraryHolder | ExternalMethod | ExternalObject | FontDescription | FontDescriptionBundle | GeneralBindingReference | GetPropertyTag | HeaderField | HostSpec | HTTPCookie | ImplementationFont | LDMPerspective | LDMRelationship | LintRule | Locale | MethodDescriptor | ModificationSet | NamedChangeSet | NamedVariable | NamePattern | NameSpace | NameSpaceDescriptor | NetUser | Notation | Override | ParameterNode | ParcelFileItem | ParcelGroup | ParcelInImageItem | ParcelPrereqItem | ParcelPrereqReference | PI | PostScriptFontBody | Prerequisite | Process | ProcessMonitorRecord | ProtocolSortOrder | PseudoPackage | RBCommand | RBProgramItem | RBVariableNode | RefactoryChange | ServerContextPatternSpec | SetPropertyTag | SettingsDomain | SourceCodeStream | SystemError | SystemVariable | TagAttributeSpec | TagLibrary | TagOccurrence | TagSpec | TestResource | TestSuite | UDSocketAddress | UISpecification | UnparceledParcel | VariableNode | WebSettingsSection | WebSite | WikiPageLink))&gt;	description of sections</body></comment><class><name>HTTPUserAgent</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isIE webRequest isFirefox3 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WikiWorks4SSP</package></attributes></class><class><name>WikiPageLink</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>address pathComponents name isMethod fragment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.WikiPageLink</class-id><body>WikiPageLink is used to handle [links] in a page. This can be an external link [http://google.de] or a link to another page [] or a link to a file which someone has uploaded [News][despriction&gt;subdir/file.pdf]Instance Variables:	address	&lt;SequenceableCollection&gt;	description of address	fragment	&lt;Object | RemoteObject&gt;	description of fragment	isMethod	&lt;Boolean&gt;	description of isMethod	name	&lt;Object | RemoteObject&gt;	description of name</body></comment><class><name>NotAuthorizedError</name><environment>WikiWorks</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WikiWorks4SSP</package></attributes></class><class><name>HtmlRender4ssp</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>myReplyStream handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.HtmlRender4ssp</class-id><body>HtmlRender4ssp and it´s subclasses are used to render the Wiki Syntax to Hml. Special characters like '|' or '*' are subsituted by '&lt;table&gt;...&lt;tr&gt;...' stuff , &lt;li&gt; and so on.Instance Variables:	handler	&lt;Wiki&gt;	stores an instance of a wiki	myReplyStream	&lt;Stream&gt;	the 'rendered' output is written on this stream</body></comment><class><name>WikiRender4ssp</name><environment>WikiWorks</environment><super>WikiWorks.HtmlRender4ssp</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.WikiRender4ssp</class-id><body>WikiRender4ssp and CompositeWikiRender4ssp are needed to to things like 'Recent Changes', 'Pages' and 'Search' on the index page.Instance Variables:	searchString	&lt;String&gt;	the string the user typed in to look for</body></comment><class><name>CompositeWikiRender4ssp</name><environment>WikiWorks</environment><super>WikiWorks.WikiRender4ssp</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.CompositeWikiRender4ssp</class-id><body>WikiRender4ssp and CompositeWikiRender4ssp are needed to to things like 'Recent Changes', 'Pages' and 'Search' on the index page.Instance Variables:	components	&lt;(Collection of: (Wiki | WikiRender4ssp))&gt;	description of components</body></comment><class><name>WebResponder</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wiki FileResponder</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.WebResponder</class-id><body>WebResponder is taken somewhere from Wave-Server which required a lot of other stuff. But the only needed class is WebResponder (and FileResponder although)Subclasses must implement the following messages:	public interface		answerFor:</body></comment><class><name>WikiPageRender4ssp</name><environment>WikiWorks</environment><super>WikiWorks.HtmlRender4ssp</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentStream currentChar lastChar headingLevel inTable bulletLevel numberLevel page isHTML </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.WikiPageRender4ssp</class-id><body>WikiPageRender4ssp generates the output. The handler and the page are set  by request:in: . pageContents is the central processing unit.Instance Variables:	bulletLevel	&lt;Integer&gt;	description of bulletLevel	contentStream	&lt;PositionableStream&gt;	description of contentStream	currentChar	&lt;Character&gt;	description of currentChar	headingLevel	&lt;ArithmeticValue&gt;	description of headingLevel	inTable	&lt;Boolean&gt;	description of inTable	lastChar	&lt;Character&gt;	description of lastChar	numberLevel	&lt;Integer&gt;	description of numberLevel	page	&lt;WikiPage&gt;	description of page</body></comment><class><name>DifferenceRender4ssp</name><environment>WikiWorks</environment><super>WikiWorks.WikiPageRender4ssp</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newVersion oldVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.DifferenceRender4ssp</class-id><body>DifferenceRender4ssp renders the differences between two versions of a page... like the unix tool diffInstance Variables:	newVersion	&lt;BlessingLevel | CharacterArray | CharacterBlock | JumpRecord | Magnitude | MethodFilter&gt;	description of newVersion	oldVersion	&lt;Object | RemoteObject&gt;	description of oldVersion</body></comment><class><name>CompositeWiki</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readUsers writeUsers directory components name readableForPublic serverType port cssUrl base host </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.CompositeWiki</class-id><body>CompositeWiki used singleton pattern to access the different Wiki´s. Use 'WikiWorks.CompositeWiki current' or 'WikiWorks.CompositeWiki current componentNamed: ...' and so on. To verify username and password (kept in a request of the clients WebBrowser) use: 'CompositeWiki authorizeRequest: aRequest for: aWikiName'. Instance Variables:	components	&lt;(Dictionary of: FlatFileWiki)&gt;	keeps each single FlatFileWiki	directory	&lt;Filename&gt;	description of directory	name	&lt;Object&gt;	description of name	port	&lt;Object | Proxy&gt;	description of port	readableForPublic	&lt;Boolean&gt;	description of readableForPublic	readUsers	&lt;Dictionary&gt;	 a Dictionary of users with global read access (only one entry is used)	serverType	&lt;Object | Proxy&gt;	kind of server 'WaveIPRequestBroker' or 'WaveHTTPRequestBroker'	writeUsers	&lt;Dictionary&gt;	 a Dictionary of users with global write access (only one entry is used)</body></comment><class><name>Wiki</name><environment>WikiWorks</environment><super>WikiWorks.CompositeWiki</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pages rootPageTitle idMap formattingPageTitle fileServer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.Wiki</class-id><body>Here comes the old comment from the original WikiWorks Wiki. This ist partially obsolete now.WikiServer is replaced by WebToolKit, WikiRendering is now done by HTMLRender4ssp (and subclasses)-----------------A Wiki is made up of four kinds of classes; Wiki, WikiServer, WikiPage, and WikiRendering.A Wiki has a collection of pages, which can be read or edited over the web.  A WikiServercatches http requests and converts them into operations on the Wiki.  It can manage aset of Wikis.  The Wiki finds the appropriate page for a request, determines the command being performed on the page, and selects a WikiRendering to match that command.  The WikiRendering then produces HTML for the page, which the WikiServer will sendback to the web browser.There are many subclasses of WikiRendering, one for each way that a page can beconverted into HTML.  Each subclass represents a different command, such as editing,changing the name of a page, or looking at old versions of a page.There are also many subclasses of WikiPage.  Except for the original page, eachversion points to the previous version of the page.  Since the original page is alwaysof the form "Describe XXX here", it is not very interesting.  Other versions of the pagecan have a custom contents or can be renamed or have an attachment.Wiki is currently only subclassed to provide different forms of persistence.Instance Variables	formattingPageTitle	&lt;Character | CharacterArray&gt;		name	&lt;String&gt;		pages	&lt;(Dictionary of: (ChangedWikiPage | OriginalWikiPage | TextPage ))&gt;		rootPageTitle	&lt;Character | CharacterArray&gt;	fileServer	&lt;Boolean&gt;	Upload/Download is enabled/disabled. to change fileServer you must modify the wiki.ini file...	idMap	&lt;Dictionary&gt;	maps page to its unique id</body></comment><class><name>IsamFileWiki</name><environment>WikiWorks</environment><super>WikiWorks.Wiki</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iD isam </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.IsamFileWiki</class-id><body>IsamFileWiki store each page in a IsamFile-Set (*.idx, *.dat)Instance Variables	iD	&lt;ArithmeticValue&gt;	Latest iD used in isam	isam	&lt;IsamCollection&gt;	The IsamCollection which stores the pages of the wiki</body></comment><class><name>IM_ApplicationWWWFormUrlEncoded</name><environment>VisualWave</environment><super>VisualWave.InternetMedia</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameValueDictionary orderedNameValues charsetEncoder dataStream request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Net</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>VisualWave.IM_ApplicationWWWFormUrlEncoded</class-id><body>IM_ApplicationWWWFormUrlEncoded represents the data which HTTP user agents (web browsers) return for a fill-out form. Because multiple values can come back for the same "name", or even the same value repeatedly for the same name, and such info may in rare applications be significant, Bags of values are used in the nameValueDictionary, and a version of the form data maintaining order info is kept as well. Instance Variables:	nameValueDictionary	&lt;Dictionary&gt;  For each name in returned data, holds a Bag of values returned. 	orderedNameValues	&lt;OrderedCollection&gt;  Order may be important for some applications, so this collection keeps </body></comment><class><name>TokenDifference</name><environment>WikiWorks</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>old new results newPos oldPos </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Network-Support</category><attributes><package>WikiWorks4SSP</package></attributes></class><class><name>HtmlEncoder</name><environment>Core</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>Core.HtmlEncoder</class-id><body>HtmlEncoder tries to write a string with any Characters as HTML Entities on streamCharacter value: 8364	-&gt; $€ "16r20AC"		-&gt; &amp;#8364 (Unicode)Character value: 128		-&gt; $ "16r0080"		-&gt; &amp;#128 (ASCII)</body></comment><class><name>WikiPageEntry</name><environment>Heeg.Isam</environment><super>Heeg.Isam.IsamItem</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Files-Isam</category><attributes><fields>id=Integer pageClass=UTF8String previousVersion=Integer author=UTF8String timestamp=Timestamp datum=UTF8String </fields><package>WikiWorks4SSP</package></attributes></class><class><name>WikiPageKey</name><environment>Heeg.Isam</environment><super>Heeg.Isam.WikiPageEntry</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><fields>id=Integer </fields><package>WikiWorks4SSP</package></attributes></class><comment><class-id>Heeg.Isam.WikiPageKey</class-id><body></body></comment><class><name>HTTPRequest</name><environment>VisualWave</environment><super>VisualWave.HTTPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method uri encoder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Net</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>VisualWave.HTTPRequest</class-id><body>HTTPRequest represents a full HTTP/1.0 request, without any context which is not part of the protocol (an example of such context would be the host name/address from which the request came). Instance Variables:	method	&lt;String&gt;  GET, POST, or HEAD	uri	&lt;String&gt;  String version of the URI in the request line. </body></comment><class><name>VersionRender4ssp</name><environment>WikiWorks</environment><super>WikiWorks.WikiPageRender4ssp</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Rendering</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.VersionRender4ssp</class-id><body>The VersionRender4ssp is used to render a version of a Page which is different then the latest one.Instance Variables:	version	&lt;Object | Proxy&gt;	 stores versionnumber </body></comment><class><name>OriginalWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.WikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.OriginalWikiPage</class-id><body>just a fresh Page. You cannot edit them because the content is fixed. Instead a EditedWikiPage will be createdInstance Variables:	title	&lt;Object | Proxy&gt;	description of title</body></comment><class><name>WikiRedirectionAnswer</name><environment>WikiWorks</environment><super>VisualWave.RedirectionAnswer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>theWikiname </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>WikiWorks</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.WikiRedirectionAnswer</class-id><body>WikiRedirectionAnswer is a subclass of Redirection Answer (suprise!). The requested URL is parsed and the Clients (WebBrowser) gets a redirection to the new URL.With WikiRedirectionAnswer you can use old Bookmarks etc. altough the syntax of the URL has changed Instance Variables:	theWikiname	&lt;CharacterArray&gt;	description of theWikiname</body></comment><class><name>WikiWorks4SSPSystem</name><environment>WikiWorks</environment><super>Core.UserApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.WikiWorks4SSPSystem</class-id><body>This handles the setup/tearDown of the WikiWorks4SSP Wikis</body></comment><class><name>EditPageRender4ssp</name><environment>WikiWorks</environment><super>WikiWorks.WikiPageRender4ssp</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.EditPageRender4ssp</class-id><body>EditPageRender4ssp renders a page for the editor, which renders everything except for anchors. That's necesarry for the TinyMCE Editor to work on the HTML but not on the links</body></comment><class><name>RenamedWikiPage</name><environment>WikiWorks</environment><super>WikiWorks.ChangedWikiPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.RenamedWikiPage</class-id><body>If someone renames a WikiPage a new Page is created with the content of the previous one but with a new title.Instance Variables:	title	&lt;Object | Proxy&gt;	description of title</body></comment><class><name>FileResponder</name><environment>WikiWorks</environment><super>WikiWorks.WebResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultDir </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wiki FileResponder</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.FileResponder</class-id><body>I can serve files that are created as the appropriate MIME type based on the file extensionInstance Variables:	defaultDir	&lt;Filename&gt;  where to start looking for a fileClass Variables:	Types	&lt;IdentityDictionary key: Symbol value: String&gt;  keys are filename extensions (minus the period) and values are MIME types</body></comment><class><name>FlatFileWiki</name><environment>WikiWorks</environment><super>WikiWorks.Wiki</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileCounter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web-Wiki-Model</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.FlatFileWiki</class-id><body>FlatFileWiki store each page in a separate file (nomen est omen)Instance Variables	fileCounter	&lt;ArithmeticValue&gt;	Counter for the next page number</body></comment><class><name>FileResponder4ssp</name><environment>WikiWorks</environment><super>WikiWorks.FileResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wiki FileResponder</category><attributes><package>WikiWorks4SSP</package></attributes></class><comment><class-id>WikiWorks.FileResponder4ssp</class-id><body>FileResponder is an extends original FileResponder (more MIME-Types, 'application/octet-stream' is new default MIME-Type). </body></comment><shared-variable><name>EncodingTranslations</name><environment>VisualWave.HTTPRequest</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>WikiWorks4SSP</package></attributes></shared-variable><shared-variable><name>EncodingsDict</name><environment>VisualWave.HTTPRequest</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>WikiWorks4SSP</package></attributes></shared-variable><shared-variable><name>SpecialCharactersToUnicode</name><environment>WikiWorks</environment><private>false</private><constant>false</constant><category>www</category><initializer>	(Dictionary new)		at: $&lt; put: '&amp;lt;';		at: $&gt; put: '&amp;gt;';		at: $&amp; put: '&amp;amp;';		yourself	</initializer><attributes><package>WikiWorks4SSP</package></attributes></shared-variable><shared-variable><name>Access</name><environment>WikiWorks.FileResponder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>WikiWorks4SSP</package></attributes></shared-variable><shared-variable><name>Types</name><environment>WikiWorks.FileResponder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>WikiWorks4SSP</package></attributes></shared-variable><methods><class-id>WikiWorks.CollectionAdapter</class-id> <category>enumerating</category><body package="WikiWorks4SSP">do: aBlock 	collection do: [:each | each value: aBlock]</body></methods><methods><class-id>WikiWorks.CollectionAdapter</class-id> <category>adding</category><body package="WikiWorks4SSP">add: anObject 	^collection add: anObject</body></methods><methods><class-id>WikiWorks.CollectionAdapter</class-id> <category>removing</category><body package="WikiWorks4SSP">remove: oldObject ifAbsent: anExceptionBlock 	collection remove: (collection 				detect: [:each | (self class with: each) includes: oldObject]				ifNone: [^anExceptionBlock value]).	^oldObject</body></methods><methods><class-id>WikiWorks.CollectionAdapter</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">initialize	collection := Set new</body></methods><methods><class-id>WikiWorks.CollectionAdapter class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">new	^super new initialize</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>accessing</category><body package="WikiWorks4SSP">allTitles	| oc |	oc := OrderedCollection new.	self allTitlesInto: oc.	^oc</body><body package="WikiWorks4SSP">allTitlesInto: aCollection 	self subclassResponsibility</body><body package="WikiWorks4SSP">author	^author</body><body package="WikiWorks4SSP">author: authorName 	author := authorName</body><body package="WikiWorks4SSP">contents	self subclassResponsibility</body><body package="WikiWorks4SSP">firstVersion	self subclassResponsibility</body><body package="WikiWorks4SSP">previousVersion	self subclassResponsibility</body><body package="WikiWorks4SSP">references: aString 	^(aString match: self contents) or: [aString match: self title]</body><body package="WikiWorks4SSP">tabularHistoricalSynopsis	^'?'</body><body package="WikiWorks4SSP">timestamp	^timestamp</body><body package="WikiWorks4SSP">timestamp: aTimestamp 	timestamp := aTimestamp asTimestamp</body><body package="WikiWorks4SSP">title	self subclassResponsibility</body><body package="WikiWorks4SSP">type	self subclassResponsibility</body><body package="WikiWorks4SSP">versionAt: aNumber 	self versionsDo: [:each | each versionNumber = aNumber ifTrue: [^each]].	^self subscriptBoundsError: aNumber</body><body package="WikiWorks4SSP">versionNumber	self subclassResponsibility</body><body package="WikiWorks4SSP">versionsDo: aBlock 	self subclassResponsibility</body><body package="WikiWorks4SSP">versionsReverseDo: aBlock 	self subclassResponsibility</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>editing</category><body package="WikiWorks4SSP">changeTitle: titleString by: authorName 	| newGuy |	titleString ifNil: [^self].	titleString isEmpty ifTrue: [^self].	titleString = self title ifTrue: [^self].	newGuy := self newVersionOf: RenamedWikiPage by: authorName.	newGuy title: titleString.	^newGuy</body><body package="WikiWorks4SSP">newContents: contentsString by: anAuthor 	| newGuy |	contentsString ifNil: [^self].	(self maliciousTags contains: [:each | each match: contentsString]) 		ifTrue: [^self].	newGuy := self newVersionOf: EditedWikiPage by: anAuthor.	newGuy contents: contentsString.	^newGuy contents = self contents ifTrue: [self] ifFalse: [newGuy]</body><body package="WikiWorks4SSP">newVersionOf: aWikiPageSubClass by: authorName 	| newGuy |	newGuy := aWikiPageSubClass new.	newGuy previousVersion: self.	newGuy author: authorName.	^newGuy</body><body package="WikiWorks4SSP">revertVersion: anInteger by: anAuthor 	| newGuy |	(anInteger &lt;= 0 or: [anInteger &gt;= self versionNumber]) ifTrue: [^self].	newGuy := self newVersionOf: RevertedWikiPage by: anAuthor.	newGuy specificData: (self versionAt: anInteger).	^newGuy</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>testing</category><body package="WikiWorks4SSP">canBeReleased	^false</body><body package="WikiWorks4SSP">hasSeveralSuccessorsIn: aPageCollection	"answer whether I am the previous version of at least two pages in the given collection"	| count |	count := 0.	aPageCollection do: [:page | 		(page previousVersion = self) ifTrue: [			(count = 0 ) ifTrue: [ count := 1 ] ifFalse: [ ^ true ]]			].	^ false</body><body package="WikiWorks4SSP">hastSuccessorIn: aPageCollection	"answer whether I am the previous version of a page in the given collection"	| successor |	successor := aPageCollection 		detect: [:page | page previousVersion = self ]		ifNone: [ ^ false ].	^ true</body><body package="WikiWorks4SSP">isOriginal	^false</body><body package="WikiWorks4SSP">isPromoted	^false</body><body package="WikiWorks4SSP">isReverted	^false</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>constants</category><body package="WikiWorks4SSP">maliciousTags	"See http://www.cert.org/advisories/CA-2000-02.html"	^#('*&lt;SCRIPT*' '*&lt;OBJECT*' '*&lt;APPLET*' '*&lt;EMBED*' '*&lt;FORM*')</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>flat file</category><body package="WikiWorks4SSP">saveToFile: aFileStream under: aWiki 	aFileStream		nextPutAll: self class name;		cr.	aFileStream		nextPutAll: author;		cr.	aFileStream		print: timestamp asSeconds;		cr</body><body package="WikiWorks4SSP">specificData: anObject 	self subclassResponsibility</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">initialize	timestamp := Timestamp now.	author := ''</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>comparing</category><body package="WikiWorks4SSP">&lt;= aPage	^self title &lt;= aPage title</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>printing</category><body package="WikiWorks4SSP">printAdditionalInformationOn: aStream</body><body package="WikiWorks4SSP">printOn: aStream 	aStream		nextPut: $[;		nextPutAll: self title;		nextPut: $(;		print: self versionNumber;		nextPutAll: ' typ:',self type asString;		nextPut: $);		nextPut: $];		cr.	aStream		nextPut: ${;		nextPutAll: author;		space;		print: timestamp.	self printAdditionalInformationOn: aStream.	aStream		nextPut: $}</body></methods><methods><class-id>WikiWorks.WikiPage</class-id> <category>isam</category><body package="WikiWorks4SSP">asIsamEntryId: id wiki: aWiki	^ Heeg.Isam.WikiPageEntry new		id: id;		pageClass: self class name;		author: author;		timestamp: timestamp ;		yourself</body><body package="WikiWorks4SSP">fromIsamEntry: isamEntry wiki: aWiki		self		author: isamEntry author;		timestamp: isamEntry timestamp;		yourself</body><body package="WikiWorks4SSP">fromPageEntry: isamEntry</body><body package="WikiWorks4SSP"> storeOnIsam: isam under: aWiki id: id	| isamEntry |	isamEntry := self asIsamEntryId: id wiki: aWiki.	isam add: isamEntry.</body></methods><methods><class-id>WikiWorks.WikiPage class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">fromIsamEntry: isamEntry wiki: aWiki	| aClass page |	aClass := self pageClassForIsamEntry: isamEntry.	page := aClass new.	page fromIsamEntry: isamEntry wiki: aWiki.	^ page</body><body package="WikiWorks4SSP">new	^super new initialize</body><body package="WikiWorks4SSP">pageClassForIsamEntry: entry	^ ((LiteralBindingReference simpleName: entry pageClass) method: thisContext method) value</body></methods><methods><class-id>WikiWorks.ChangedWikiPage</class-id> <category>accessing</category><body package="WikiWorks4SSP">allTitlesInto: aCollection 	previousVersion allTitlesInto: aCollection</body><body package="WikiWorks4SSP">contents	^previousVersion contents</body><body package="WikiWorks4SSP">firstVersion	^ self previousVersion firstVersion</body><body package="WikiWorks4SSP">previousVersion	^previousVersion</body><body package="WikiWorks4SSP">previousVersion: aPage 	previousVersion := aPage</body><body package="WikiWorks4SSP">title	^previousVersion title</body><body package="WikiWorks4SSP">versionNumber	^previousVersion versionNumber + 1</body><body package="WikiWorks4SSP">versions 	| versions |	versions := OrderedCollection new.	self versionsDo: [:each | versions add: each].	^versions</body><body package="WikiWorks4SSP">versionsDo: aBlock 	aBlock value: self.	previousVersion versionsDo: aBlock</body><body package="WikiWorks4SSP">versionsReverseDo: aBlock 	previousVersion versionsReverseDo: aBlock.	aBlock value: self</body></methods><methods><class-id>WikiWorks.ChangedWikiPage</class-id> <category>flat file</category><body package="WikiWorks4SSP">saveToFile: aFileStream under: aWiki 	super saveToFile: aFileStream under: aWiki.	aFileStream		print: (aWiki idForPage: self previousVersion);		cr</body></methods><methods><class-id>WikiWorks.ChangedWikiPage</class-id> <category>printing</category><body package="WikiWorks4SSP">printAdditionalInformationOn: aStream	aStream nextPutAll: 'prev: ',self previousVersion versionNumber printString.</body></methods><methods><class-id>WikiWorks.ChangedWikiPage</class-id> <category>isam</category><body package="WikiWorks4SSP">asIsamEntryId: id wiki: aWiki	^ (super asIsamEntryId: id wiki: aWiki)		previousVersion: (aWiki idForPage: self previousVersion);		yourself</body><body package="WikiWorks4SSP">fromIsamEntry: isamEntry wiki: aWiki		super fromIsamEntry: isamEntry wiki: aWiki.	self previousVersion: (aWiki pageForId: isamEntry previousVersion)</body></methods><methods><class-id>WikiWorks.EditedWikiPage</class-id> <category>accessing</category><body package="WikiWorks4SSP">contents	^self isInImage		ifTrue: [self getContents]		ifFalse: [self getContents readContentsOfPage: self]</body><body package="WikiWorks4SSP">contents: contentsString 	"trim off trailing CRs"	| index |	index := contentsString size.	[index &gt; 1 and: [(contentsString at: index) = Character cr]] 		whileTrue: [index := index - 1].	contents := contentsString copyTo: index</body><body package="WikiWorks4SSP">getContents	^contents</body><body package="WikiWorks4SSP">setContents: newContents 	contents := newContents</body><body package="WikiWorks4SSP">tabularHistoricalSynopsis	^'Edited'</body><body package="WikiWorks4SSP">type	^  #edited</body></methods><methods><class-id>WikiWorks.EditedWikiPage</class-id> <category>testing</category><body package="WikiWorks4SSP">canBeReleased	^self isInImage</body><body package="WikiWorks4SSP">isInImage	^self getContents isString</body></methods><methods><class-id>WikiWorks.EditedWikiPage</class-id> <category>flat file</category><body package="WikiWorks4SSP">saveToFile: aFileStream under: aWiki 	[ super saveToFile: aFileStream under: aWiki.		"contents := aWiki encodeForSave: contents."		aFileStream nextPutAll: self contents. ] 		on: UnsupportedCharacterError 		do: [:ex | aFileStream close.				contents replaceAll: ex parameter value with: $?.				ex retry].</body><body package="WikiWorks4SSP">specificData: aString 	self contents: aString</body></methods><methods><class-id>WikiWorks.EditedWikiPage</class-id> <category>isam</category><body package="WikiWorks4SSP">asIsamEntryId: id wiki: aWiki	^ (super asIsamEntryId: id wiki: aWiki)		datum: self contents;		yourself</body><body package="WikiWorks4SSP">fromIsamEntry: isamEntry wiki: aWiki		super fromIsamEntry: isamEntry wiki: aWiki.	self contents: isamEntry datum</body></methods><methods><class-id>WikiWorks.ConfigurationSection</class-id> <category>querying</category><body package="WikiWorks4SSP">at: key	^self at: key ifAbsent: [self error: 'No such key: ', key printString]</body><body package="WikiWorks4SSP">at: key ifAbsent: aOneArgumentBlock 	^dataMap at: key asLowercase ifAbsent: aOneArgumentBlock</body><body package="WikiWorks4SSP">keys	^dataMap keys</body><body package="WikiWorks4SSP">keysAndValuesDo: aTwoArgumentBlock 	^dataMap keysAndValuesDo: aTwoArgumentBlock</body><body package="WikiWorks4SSP">name	^name</body></methods><methods><class-id>WikiWorks.ConfigurationSection</class-id> <category>initializing</category><body package="WikiWorks4SSP">initialize: aString 	dataMap := Dictionary new.	name := aString asLowercase</body></methods><methods><class-id>WikiWorks.ConfigurationSection</class-id> <category>adding</category><body package="WikiWorks4SSP">at: key put: value	dataMap at: key asLowercase put: value</body></methods><methods><class-id>WikiWorks.ConfigurationSection</class-id> <category>printing</category><body package="WikiWorks4SSP">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: name;		nextPut: $)</body></methods><methods><class-id>WikiWorks.ConfigurationSection class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">named: aString	^self new initialize: aString; yourself</body></methods><methods><class-id>WikiWorks.RevertedWikiPage</class-id> <category>flat file</category><body package="WikiWorks4SSP">saveToFile: aFileStream under: aWiki 	super saveToFile: aFileStream under: aWiki.	aFileStream print: (aWiki idForPage: revertedVersion)</body><body package="WikiWorks4SSP">specificData: aPage 	revertedVersion := aPage</body></methods><methods><class-id>WikiWorks.RevertedWikiPage</class-id> <category>accessing</category><body package="WikiWorks4SSP">contents	^revertedVersion contents</body><body package="WikiWorks4SSP">tabularHistoricalSynopsis	^'Reverted To Version ', revertedVersion versionNumber printString</body><body package="WikiWorks4SSP">title	^revertedVersion title</body><body package="WikiWorks4SSP">type	^  #reverted</body></methods><methods><class-id>WikiWorks.RevertedWikiPage</class-id> <category>testing</category><body package="WikiWorks4SSP">isReverted	^true</body></methods><methods><class-id>WikiWorks.RevertedWikiPage</class-id> <category>isam</category><body package="WikiWorks4SSP">asIsamEntryId: id wiki: aWiki	^ (super asIsamEntryId: id wiki: aWiki)		datum: (aWiki idForPage: revertedVersion) printString ;		yourself</body><body package="WikiWorks4SSP">fromIsamEntry: isamEntry wiki: aWiki		super fromIsamEntry: isamEntry wiki: aWiki.	revertedVersion := (aWiki pageForId: (Number readFromString: isamEntry datum)).</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry</class-id> <category>constructing</category><body package="WikiWorks4SSP">addSectionNamed: aString 	"	^	&lt;WikiConfigurationSection&gt;"	^sections add: (ConfigurationSection named: aString asLowercase)</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry</class-id> <category>querying</category><body package="WikiWorks4SSP">sectionNamed: name 	^self sectionNamed: name asLowercase		ifAbsent: [self error: 'No section named ' , name printString]</body><body package="WikiWorks4SSP">sectionNamed: name ifAbsent: aBlock 	^sections detect: [:first | first name = name asLowercase]		ifNone: [^aBlock value]</body><body package="WikiWorks4SSP">sectionsNamed: name 	^sections select: [:each | each name = name asLowercase]</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry</class-id> <category>enumerating</category><body package="WikiWorks4SSP">sectionsNamed: name do: aOneArgumentBlock 	^(self sectionsNamed: name asLowercase) do: aOneArgumentBlock</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry</class-id> <category>initializing</category><body package="WikiWorks4SSP">initialize	sections := OrderedCollection new</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry class</class-id> <category>private-parsing</category><body package="WikiWorks4SSP">keyValuePairFrom: line into: configurationSection	"line		&lt;String like: '... = ...'&gt;"	| stream key value |	stream := ReadStream on: line.	key := (stream upTo: $=) trimSeparators.	value := stream upToEnd trimSeparators.		configurationSection at: key put: value</body><body package="WikiWorks4SSP">sectionFrom: line into: wikiConfiguration	"line		&lt;String like: '[...]'&gt;	Private"	^wikiConfiguration addSectionNamed: (line copyFrom: 2 to: line size - 1)</body></methods><methods><class-id>WikiWorks.ConfigurationRegistry class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">fromFileNamed: filename 	"filename		&lt;String&gt;	^				&lt;WikiConfiguration&gt;	Answer a new instance of the receiver parsed from the given file."	| stream configuration currentSection line |	configuration := self new.	stream := filename asFilename readStream.	stream lineEndAuto.	[stream atEnd] whileFalse: 			[line := (stream upTo: Character cr) trimSeparators.			line isEmpty 				ifFalse: 					[line first = $[ 						ifTrue: [currentSection := self sectionFrom: line into: configuration]						ifFalse: [self keyValuePairFrom: line into: currentSection]]].	stream close.	^configuration</body><body package="WikiWorks4SSP">new	^super new initialize</body></methods><methods><class-id>WikiWorks.HTTPUserAgent</class-id> <category>testing</category><body package="WikiWorks4SSP">isFirefox3	^isFirefox3 ifNil: [false]</body><body package="WikiWorks4SSP">isIE	^isIE ifNil: [false]</body></methods><methods><class-id>WikiWorks.HTTPUserAgent</class-id> <category>public-interface</category><body package="WikiWorks4SSP">headerFeld: aFeld	self isIE ifTrue: [^[ISO8859L1String fromString: aFeld] on: UnsupportedCharacterError do: [^nil]].	^(aFeld asByteArrayEncoding: #UTF8) asByteString.</body></methods><methods><class-id>WikiWorks.HTTPUserAgent</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">initialize	| userAgent |	userAgent := self webRequest envAt: 'HTTP_USER_AGENT'.	self isIE: ('*MSIE*' match: userAgent).	self isFirefox3: ('*Firefox*3.*' match: userAgent)</body></methods><methods><class-id>WikiWorks.HTTPUserAgent</class-id> <category>accessing</category><body package="WikiWorks4SSP">isFirefox3: aBoolean	isFirefox3 := aBoolean</body><body package="WikiWorks4SSP">isIE: aBoolean	isIE := aBoolean</body><body package="WikiWorks4SSP">webRequest	^webRequest</body><body package="WikiWorks4SSP">webRequest: aWebRequest	webRequest := aWebRequest</body></methods><methods><class-id>WikiWorks.HTTPUserAgent class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">from: aWebRequest	^self new webRequest: aWebRequest; initialize</body></methods><methods><class-id>WikiWorks.WikiPageLink</class-id> <category>testing</category><body package="WikiWorks4SSP">hasFragment	^fragment notNil</body><body package="WikiWorks4SSP">isAnonymous	^name isNil</body><body package="WikiWorks4SSP">isExternalLink	^self externalLinkPrefixes anySatisfy: [:each | each match: address]</body><body package="WikiWorks4SSP">isMethod	^isMethod</body></methods><methods><class-id>WikiWorks.WikiPageLink</class-id> <category>accessing</category><body package="WikiWorks4SSP">address	^address</body><body package="WikiWorks4SSP">fragment	^fragment</body><body package="WikiWorks4SSP">name	| externalLinkPrefix |	self isAnonymous ifFalse: [^name].	externalLinkPrefix := self externalLinkPrefixes 				detect: [:each | each match: address]				ifNone: [^address].	^address copyFrom: externalLinkPrefix size</body><body package="WikiWorks4SSP">pathComponents	^pathComponents</body></methods><methods><class-id>WikiWorks.WikiPageLink</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">contents: aString		| realString rs isAnonymous decodedString |	realString := aString trimSeparators.	rs := realString readStream.	(rs insensitivePeekForAll: 'ISBN:')		ifTrue:			[name := realString.			address := self isbnUrlPrefix , rs upToEnd trimSeparators.			^self].	decodedString := self decodeHTML: realString.	rs := decodedString readStream.	name := (rs upTo: $&gt; escaper: $\) trimSeparators.	isMethod := rs peekForAll: '&gt;#'.	isMethod		ifTrue:			[address := rs upToEnd trimSeparators asSymbol.			^self].	isAnonymous := rs atEnd.	address := isAnonymous		ifTrue: [name]		ifFalse: [rs upToEnd trimSeparators].	isAnonymous ifTrue: [name := nil].	self isExternalLink ifTrue: [^self].	pathComponents := address asArrayOfSubstringsSeparator: $/</body><body package="WikiWorks4SSP">decodeHTML: aString	"decode the &amp;gt; and other HTML entities to &gt; or whatever the entities mean."	^GHXhtmlDecoder decodeString: aString</body><body package="WikiWorks4SSP">fragmentize	| rs |	rs := address readStream.	address := rs upTo: $# escaper: $\.	rs atEnd ifFalse: [fragment := rs upToEnd]</body><body package="WikiWorks4SSP">htmlDecoderTable	^#(#('&amp;Acirc;' '&amp;#194;') #('&amp;acirc;' '&amp;#226;') #('&amp;acute;' '&amp;#180;') #('&amp;AElig;' '&amp;#198;') #('&amp;aelig;' '&amp;#230;') #('&amp;Agrave;' '&amp;#192;') #('&amp;agrave;' '&amp;#224;') #('&amp;alefsym;' '&amp;#8501;') #('&amp;Alpha;' '&amp;#913;') #('&amp;alpha;' '&amp;#945;') #('&amp;amp;' '&amp;#38;') #('&amp;and;' '&amp;#8743;') #('&amp;ang;' '&amp;#8736;') #('&amp;apos;' '&amp;#39;') #('&amp;Aring;' '&amp;#197;') #('&amp;aring;' '&amp;#229;') #('&amp;asymp;' '&amp;#8776;') #('&amp;Atilde;' '&amp;#195;') #('&amp;atilde;' '&amp;#227;') #('&amp;Auml;' '&amp;#196;') #('&amp;auml;' '&amp;#228;') #('&amp;bdquo;' '&amp;#8222;') #('&amp;Beta;' '&amp;#914;') #('&amp;beta;' '&amp;#946;') #('&amp;brvbar;' '&amp;#166;') #('&amp;bull;' '&amp;#8226;') #('&amp;cap;' '&amp;#8745;') #('&amp;Ccedil;' '&amp;#199;') #('&amp;ccedil;' '&amp;#231;') #('&amp;cedil;' '&amp;#184;') #('&amp;cent;' '&amp;#162;') #('&amp;Chi;' '&amp;#935;') #('&amp;chi;' '&amp;#967;') #('&amp;circ;' '&amp;#710;') #('&amp;clubs;' '&amp;#9827;') #('&amp;cong;' '&amp;#8773;') #('&amp;copy;' '&amp;#169;') #('&amp;crarr;' '&amp;#8629;') #('&amp;cup;' '&amp;#8746;') #('&amp;curren;' '&amp;#164;') #('&amp;Dagger;' '&amp;#8225;') #('&amp;dagger;' '&amp;#8224;') #('&amp;dArr;' '&amp;#8659;') #('&amp;darr;' '&amp;#8595;') #('&amp;deg;' '&amp;#176;') #('&amp;Delta;' '&amp;#916;') #('&amp;delta;' '&amp;#948;') #('&amp;diams;' '&amp;v#9830;') #('&amp;divide;' '&amp;#247;') #('&amp;Eacute;' '&amp;#201;') #('&amp;eacute;' '&amp;#233;') #('&amp;Ecirc;' '&amp;#202;') #('&amp;ecirc;' '&amp;#234;') #('&amp;Egrave;' '&amp;#200;') #('&amp;egrave;' '&amp;#232;') #('&amp;empty;' '&amp;#8709;') #('&amp;emsp;' '&amp;#8195;') #('&amp;ensp;' '&amp;#8194;') #('&amp;Epsilon;' '&amp;#917;') #('&amp;epsilon;' '&amp;#949;') #('&amp;equiv;' '&amp;#8801;') #('&amp;Eta;' '&amp;#919;') #('&amp;eta;' '&amp;#951;') #('&amp;ETH;' '&amp;#208;') #('&amp;eth;' '&amp;#240;') #('&amp;Euml;' '&amp;#203;') #('&amp;euml;' '&amp;#235;') #('&amp;euro;' '&amp;#8364;') #('&amp;exist;' '&amp;#8707;') #('&amp;fnof;' '&amp;#402;') #('&amp;forall;' '&amp;#8704;') #('&amp;frac12;' '&amp;#189;') #('&amp;frac14;' '&amp;#188;') #('&amp;frac34;' '&amp;#190;') #('&amp;frasl;' '&amp;#8260;') #('&amp;Gamma;' '&amp;#915;') #('&amp;gamma;' '&amp;#947;') #('&amp;ge;' '&amp;#8805;') #('&amp;gt;' '&amp;#62;') #('&amp;hArr;' '&amp;#8660;') #('&amp;harr;' '&amp;#8596;') #('&amp;hearts;' '&amp;#9829;') #('&amp;hellip;' '&amp;#8230;') #('&amp;Iacute;' '&amp;#205;') #('&amp;iacute;' '&amp;#237;') #('&amp;Icirc;' '&amp;#206;') #('&amp;icirc;' '&amp;#238;') #('&amp;iexcl;' '&amp;#161;') #('&amp;Igrave;' '&amp;#204;') #('&amp;igrave;' '&amp;#236;') #('&amp;image;' '&amp;#8465;') #('&amp;infin;' '&amp;#8734;') #('&amp;int;' '&amp;#8747;') #('&amp;Iota;' '&amp;#921;') #('&amp;iota;' '&amp;#953;') #('&amp;iquest;' '&amp;#191;') #('&amp;isin;' '&amp;#8712;') #('&amp;Iuml;' '&amp;#207;') #('&amp;iuml;' '&amp;#239;') #('&amp;Kappa;' '&amp;#922;') #('&amp;kappa;' '&amp;#954;') #('&amp;Lambda;' '&amp;#923;') #('&amp;lambda;' '&amp;#955;') #('&amp;lang;' '&amp;#9001;') #('&amp;laquo;' '&amp;#171;') #('&amp;lArr;' '&amp;#8656;') #('&amp;larr;' '&amp;#8592;') #('&amp;lceil;' '&amp;#8968;') #('&amp;ldquo;' '&amp;#8220;') #('&amp;le;' '&amp;#8804;') #('&amp;lfloor;' '&amp;#8970;') #('&amp;lowast;' '&amp;#8727;') #('&amp;loz;' '&amp;#9674;') #('&amp;lrm;' '&amp;#8206;') #('&amp;lsaquo;' '&amp;#8249;') #('&amp;lsquo;' '&amp;#8216;') #('&amp;lt;' '&amp;#60;') #('&amp;macr;' '&amp;#175;') #('&amp;mdash;' '&amp;#8212;') #('&amp;micro;' '&amp;#181;') #('&amp;middot;' '&amp;#183;') #('&amp;minus;' '&amp;#8722;') #('&amp;Mu;' '&amp;#924;') #('&amp;mu;' '&amp;#956;') #('&amp;nabla;' '&amp;#8711;') #('&amp;nbsp;' '&amp;#160;') #('&amp;ndash;' '&amp;#8211;') #('&amp;ne;' '&amp;#8800;') #('&amp;ni;' '&amp;#8715;') #('&amp;not;' '&amp;#172;') #('&amp;notin;' '&amp;#8713;') #('&amp;nsub;' '&amp;#8836;') #('&amp;Ntilde;' '&amp;#209;') #('&amp;ntilde;' '&amp;#241;') #('&amp;Nu;' '&amp;#925;') #('&amp;nu;' '&amp;#957;') #('&amp;Oacute;' '&amp;#211;') #('&amp;oacute;' '&amp;#243;') #('&amp;Ocirc;' '&amp;#212;') #('&amp;ocirc;' '&amp;#244;') #('&amp;OElig;' '&amp;#338;') #('&amp;oelig;' '&amp;#339;') #('&amp;Ograve;' '&amp;#210;') #('&amp;ograve;' '&amp;#242;') #('&amp;oline;' '&amp;#8254;') #('&amp;Omega;' '&amp;#937;') #('&amp;omega;' '&amp;#969;') #('&amp;Omicron;' '&amp;#927;') #('&amp;omicron;' '&amp;#959;') #('&amp;oplus;' '&amp;#8853;') #('&amp;or;' '&amp;#8744;') #('&amp;ordf;' '&amp;#170;') #('&amp;ordm;' '&amp;#186;') #('&amp;Oslash;' '&amp;#216;') #('&amp;oslash;' '&amp;#248;') #('&amp;Otilde;' '&amp;#213;') #('&amp;otilde;' '&amp;#245;') #('&amp;otimes;' '&amp;#8855;') #('&amp;Ouml;' '&amp;#214;') #('&amp;ouml;' '&amp;#246;') #('&amp;para;' '&amp;#182;') #('&amp;part;' '&amp;#8706;') #('&amp;permil;' '&amp;#8240;') #('&amp;perp;' '&amp;#8869;') #('&amp;Phi;' '&amp;#934;') #('&amp;phi;' '&amp;#966;') #('&amp;Pi;' '&amp;#928;') #('&amp;pi;' '&amp;#960;') #('&amp;piv;' '&amp;#982;') #('&amp;plusmn;' '&amp;#177;') #('&amp;pound;' '&amp;#163;') #('&amp;Prime;' '&amp;#8243;') #('&amp;prime;' '&amp;#8242;') #('&amp;prod;' '&amp;#8719;') #('&amp;prop;' '&amp;#8733;') #('&amp;Psi;' '&amp;#936;') #('&amp;psi;' '&amp;#968;') #('&amp;quot;' '&amp;#34;') #('&amp;radic;' '&amp;#8730;') #('&amp;rang;' '&amp;#9002;') #('&amp;raquo;' '&amp;#187;') #('&amp;rArr;' '&amp;#8658;') #('&amp;rarr;' '&amp;#8594;') #('&amp;rceil;' '&amp;#8969;') #('&amp;rdquo;' '&amp;#8221;') #('&amp;real;' '&amp;#8476;') #('&amp;reg;' '&amp;#174;') #('&amp;rfloor;' '&amp;#8971;') #('&amp;Rho;' '&amp;#929;') #('&amp;rho;' '&amp;#961;') #('&amp;rlm;' '&amp;#8207;') #('&amp;rsaquo;' '&amp;#8250;') #('&amp;rsquo;' '&amp;#8217;') #('&amp;sbquo;' '&amp;#8218;') #('&amp;Scaron;' '&amp;#352;') #('&amp;scaron;' '&amp;#353;') #('&amp;sdot;' '&amp;#8901;') #('&amp;sect;' '&amp;#167;') #('&amp;shy;' '&amp;#173;') #('&amp;Sigma;' '&amp;#931;') #('&amp;sigma;' '&amp;#963;') #('&amp;sigmaf;' '&amp;#962;') #('&amp;sim;' '&amp;#8764;') #('&amp;spades;' '&amp;#9824;') #('&amp;sub;' '&amp;#8834;') #('&amp;sube;' '&amp;#8838;') #('&amp;sum;' '&amp;#8721;') #('&amp;sup;' '&amp;#8835;') #('&amp;sup1;' '&amp;#185;') #('&amp;sup2;' '&amp;#178;') #('&amp;sup3;' '&amp;#179;') #('&amp;supe;' '&amp;#8839;') #('&amp;szlig;' '&amp;#223;') #('&amp;Tau;' '&amp;#932;') #('&amp;tau;' '&amp;#964;') #('&amp;there4;' '&amp;#8756;') #('&amp;Theta;' '&amp;#920;') #('&amp;theta;' '&amp;#952;') #('&amp;thetasym;' '&amp;#977;') #('&amp;thinsp;' '&amp;#8201;') #('&amp;THORN;' '&amp;#222;') #('&amp;thorn;' '&amp;#254;') #('&amp;tilde;' '&amp;#732;') #('&amp;times;' '&amp;#215;') #('&amp;trade;' '&amp;#8482;') #('&amp;Uacute;' '&amp;#218;') #('&amp;uacute;' '&amp;#250;') #('&amp;uArr;' '&amp;#8657;') #('&amp;uarr;' '&amp;#8593;') #('&amp;Ucirc;' '&amp;#219;') #('&amp;ucirc;' '&amp;#251;') #('&amp;Ugrave;' '&amp;#217;') #('&amp;ugrave;' '&amp;#249;') #('&amp;uml;' '&amp;#168;') #('&amp;upsih;' '&amp;#978;') #('&amp;Upsilon;' '&amp;#933;') #('&amp;upsilon;' '&amp;#965;') #('&amp;Uuml;' '&amp;#220;') #('&amp;uuml;' '&amp;#252;') #('&amp;weierp;' '&amp;#8472;') #('&amp;Xi;' '&amp;#926;') #('&amp;xi;' '&amp;#958;') #('&amp;Yacute;' '&amp;#221;') #('&amp;yacute;' '&amp;#253;') #('&amp;yen;' '&amp;#165;') #('&amp;Yuml;' '&amp;#376;') #('&amp;yuml;' '&amp;#255;') #('&amp;Zeta;' '&amp;#918;') #('&amp;zeta;' '&amp;#950;') #('&amp;zwj;' '&amp;#8205;') #('&amp;zwnj;' '&amp;#8204;'))</body><body package="WikiWorks4SSP">initialize	isMethod := false</body><body package="WikiWorks4SSP">xhtmlDTD	^'&lt;!--   Extensible HTML version 1.0 Strict DTD   This is the same as HTML 4 Strict except for   changes due to the differences between XML and SGML.   Namespace = http://www.w3.org/1999/xhtml   For further information, see: http://www.w3.org/TR/xhtml1   Copyright (c) 1998-2002 W3C (MIT, INRIA, Keio),   All Rights Reserved.    This DTD module is identified by the PUBLIC and SYSTEM identifiers:   PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"   SYSTEM "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"   $Revision: 1.1 $   $Date: 2002/08/01 13:56:03 $--&gt;&lt;!--================ Character mnemonic entities =========================--&gt;&lt;!ENTITY % HTMLlat1 PUBLIC   "-//W3C//ENTITIES Latin 1 for XHTML//EN"   "xhtml-lat1.ent"&gt;%HTMLlat1;&lt;!ENTITY % HTMLsymbol PUBLIC   "-//W3C//ENTITIES Symbols for XHTML//EN"   "xhtml-symbol.ent"&gt;%HTMLsymbol;&lt;!ENTITY % HTMLspecial PUBLIC   "-//W3C//ENTITIES Special for XHTML//EN"   "xhtml-special.ent"&gt;%HTMLspecial;&lt;!--================== Imported Names ====================================--&gt;&lt;!ENTITY % ContentType "CDATA"&gt;    &lt;!-- media type, as per [RFC2045] --&gt;&lt;!ENTITY % ContentTypes "CDATA"&gt;    &lt;!-- comma-separated list of media types, as per [RFC2045] --&gt;&lt;!ENTITY % Charset "CDATA"&gt;    &lt;!-- a character encoding, as per [RFC2045] --&gt;&lt;!ENTITY % Charsets "CDATA"&gt;    &lt;!-- a space separated list of character encodings, as per [RFC2045] --&gt;&lt;!ENTITY % LanguageCode "NMTOKEN"&gt;    &lt;!-- a language code, as per [RFC3066] --&gt;&lt;!ENTITY % Character "CDATA"&gt;    &lt;!-- a single character, as per section 2.2 of [XML] --&gt;&lt;!ENTITY % Number "CDATA"&gt;    &lt;!-- one or more digits --&gt;&lt;!ENTITY % LinkTypes "CDATA"&gt;    &lt;!-- space-separated list of link types --&gt;&lt;!ENTITY % MediaDesc "CDATA"&gt;    &lt;!-- single or comma-separated list of media descriptors --&gt;&lt;!ENTITY % URI "CDATA"&gt;    &lt;!-- a Uniform Resource Identifier, see [RFC2396] --&gt;&lt;!ENTITY % UriList "CDATA"&gt;    &lt;!-- a space separated list of Uniform Resource Identifiers --&gt;&lt;!ENTITY % Datetime "CDATA"&gt;    &lt;!-- date and time information. ISO date format --&gt;&lt;!ENTITY % Script "CDATA"&gt;    &lt;!-- script expression --&gt;&lt;!ENTITY % StyleSheet "CDATA"&gt;    &lt;!-- style sheet data --&gt;&lt;!ENTITY % Text "CDATA"&gt;    &lt;!-- used for titles etc. --&gt;&lt;!ENTITY % Length "CDATA"&gt;    &lt;!-- nn for pixels or nn% for percentage length --&gt;&lt;!ENTITY % MultiLength "CDATA"&gt;    &lt;!-- pixel, percentage, or relative --&gt;&lt;!ENTITY % Pixels "CDATA"&gt;    &lt;!-- integer representing length in pixels --&gt;&lt;!-- these are used for image maps --&gt;&lt;!ENTITY % Shape "(rect|circle|poly|default)"&gt;&lt;!ENTITY % Coords "CDATA"&gt;    &lt;!-- comma separated list of lengths --&gt;&lt;!--=================== Generic Attributes ===============================--&gt;&lt;!-- core attributes common to most elements  id       document-wide unique id  class    space separated list of classes  style    associated style info  title    advisory title/amplification--&gt;&lt;!ENTITY % coreattrs "id          ID             #IMPLIED  class       CDATA          #IMPLIED  style       %StyleSheet;   #IMPLIED  title       %Text;         #IMPLIED"  &gt;&lt;!-- internationalization attributes  lang        language code (backwards compatible)  xml:lang    language code (as per XML 1.0 spec)  dir         direction for weak/neutral text--&gt;&lt;!ENTITY % i18n "lang        %LanguageCode; #IMPLIED  xml:lang    %LanguageCode; #IMPLIED  dir         (ltr|rtl)      #IMPLIED"  &gt;&lt;!-- attributes for common UI events  onclick     a pointer button was clicked  ondblclick  a pointer button was double clicked  onmousedown a pointer button was pressed down  onmouseup   a pointer button was released  onmousemove a pointer was moved onto the element  onmouseout  a pointer was moved away from the element  onkeypress  a key was pressed and released  onkeydown   a key was pressed down  onkeyup     a key was released--&gt;&lt;!ENTITY % events "onclick     %Script;       #IMPLIED  ondblclick  %Script;       #IMPLIED  onmousedown %Script;       #IMPLIED  onmouseup   %Script;       #IMPLIED  onmouseover %Script;       #IMPLIED  onmousemove %Script;       #IMPLIED  onmouseout  %Script;       #IMPLIED  onkeypress  %Script;       #IMPLIED  onkeydown   %Script;       #IMPLIED  onkeyup     %Script;       #IMPLIED"  &gt;&lt;!-- attributes for elements that can get the focus  accesskey   accessibility key character  tabindex    position in tabbing order  onfocus     the element got the focus  onblur      the element lost the focus--&gt;&lt;!ENTITY % focus "accesskey   %Character;    #IMPLIED  tabindex    %Number;       #IMPLIED  onfocus     %Script;       #IMPLIED  onblur      %Script;       #IMPLIED"  &gt;&lt;!ENTITY % attrs "%coreattrs; %i18n; %events;"&gt;&lt;!--=================== Text Elements ====================================--&gt;&lt;!ENTITY % special.pre   "br | span | bdo | map"&gt;&lt;!ENTITY % special   "%special.pre; | object | img "&gt;&lt;!ENTITY % fontstyle "tt | i | b | big | small "&gt;&lt;!ENTITY % phrase "em | strong | dfn | code | q |                   samp | kbd | var | cite | abbr | acronym | sub | sup "&gt;&lt;!ENTITY % inline.forms "input | select | textarea | label | button"&gt;&lt;!-- these can occur at block or inline level --&gt;&lt;!ENTITY % misc.inline "ins | del | script"&gt;&lt;!-- these can only occur at block level --&gt;&lt;!ENTITY % misc "noscript | %misc.inline;"&gt;&lt;!ENTITY % inline "a | %special; | %fontstyle; | %phrase; | %inline.forms;"&gt;&lt;!-- %Inline; covers inline or "text-level" elements --&gt;&lt;!ENTITY % Inline "(#PCDATA | %inline; | %misc.inline;)*"&gt;&lt;!--================== Block level elements ==============================--&gt;&lt;!ENTITY % heading "h1|h2|h3|h4|h5|h6"&gt;&lt;!ENTITY % lists "ul | ol | dl"&gt;&lt;!ENTITY % blocktext "pre | hr | blockquote | address"&gt;&lt;!ENTITY % block     "p | %heading; | div | %lists; | %blocktext; | fieldset | table"&gt;&lt;!ENTITY % Block "(%block; | form | %misc;)*"&gt;&lt;!-- %Flow; mixes block and inline and is used for list items etc. --&gt;&lt;!ENTITY % Flow "(#PCDATA | %block; | form | %inline; | %misc;)*"&gt;&lt;!--================== Content models for exclusions =====================--&gt;&lt;!-- a elements use %Inline; excluding a --&gt;&lt;!ENTITY % a.content   "(#PCDATA | %special; | %fontstyle; | %phrase; | %inline.forms; | %misc.inline;)*"&gt;&lt;!-- pre uses %Inline excluding big, small, sup or sup --&gt;&lt;!ENTITY % pre.content   "(#PCDATA | a | %fontstyle; | %phrase; | %special.pre; | %misc.inline;      | %inline.forms;)*"&gt;&lt;!-- form uses %Block; excluding form --&gt;&lt;!ENTITY % form.content "(%block; | %misc;)*"&gt;&lt;!-- button uses %Flow; but excludes a, form and form controls --&gt;&lt;!ENTITY % button.content   "(#PCDATA | p | %heading; | div | %lists; | %blocktext; |    table | %special; | %fontstyle; | %phrase; | %misc;)*"&gt;&lt;!--================ Document Structure ==================================--&gt;&lt;!-- the namespace URI designates the document profile --&gt;&lt;!ELEMENT html (head, body)&gt;&lt;!ATTLIST html  %i18n;  id          ID             #IMPLIED  xmlns       %URI;          #FIXED ''http://www.w3.org/1999/xhtml''  &gt;&lt;!--================ Document Head =======================================--&gt;&lt;!ENTITY % head.misc "(script|style|meta|link|object)*"&gt;&lt;!-- content model is %head.misc; combined with a single     title and an optional base element in any order --&gt;&lt;!ELEMENT head (%head.misc;,     ((title, %head.misc;, (base, %head.misc;)?) |      (base, %head.misc;, (title, %head.misc;))))&gt;&lt;!ATTLIST head  %i18n;  id          ID             #IMPLIED  profile     %URI;          #IMPLIED  &gt;&lt;!-- The title element is not considered part of the flow of text.       It should be displayed, for example as the page header or       window title. Exactly one title is required per document.    --&gt;&lt;!ELEMENT title (#PCDATA)&gt;&lt;!ATTLIST title   %i18n;  id          ID             #IMPLIED  &gt;&lt;!-- document base URI --&gt;&lt;!ELEMENT base EMPTY&gt;&lt;!ATTLIST base  href        %URI;          #REQUIRED  id          ID             #IMPLIED  &gt;&lt;!-- generic metainformation --&gt;&lt;!ELEMENT meta EMPTY&gt;&lt;!ATTLIST meta  %i18n;  id          ID             #IMPLIED  http-equiv  CDATA          #IMPLIED  name        CDATA          #IMPLIED  content     CDATA          #REQUIRED  scheme      CDATA          #IMPLIED  &gt;&lt;!--  Relationship values can be used in principle:   a) for document specific toolbars/menus when used      with the link element in document head e.g.        start, contents, previous, next, index, end, help   b) to link to a separate style sheet (rel="stylesheet")   c) to make a link to a script (rel="script")   d) by stylesheets to control how collections of      html nodes are rendered into printed documents   e) to make a link to a printable version of this document      e.g. a PostScript or PDF version (rel="alternate" media="print")--&gt;&lt;!ELEMENT link EMPTY&gt;&lt;!ATTLIST link  %attrs;  charset     %Charset;      #IMPLIED  href        %URI;          #IMPLIED  hreflang    %LanguageCode; #IMPLIED  type        %ContentType;  #IMPLIED  rel         %LinkTypes;    #IMPLIED  rev         %LinkTypes;    #IMPLIED  media       %MediaDesc;    #IMPLIED  &gt;&lt;!-- style info, which may include CDATA sections --&gt;&lt;!ELEMENT style (#PCDATA)&gt;&lt;!ATTLIST style  %i18n;  id          ID             #IMPLIED  type        %ContentType;  #REQUIRED  media       %MediaDesc;    #IMPLIED  title       %Text;         #IMPLIED  xml:space   (preserve)     #FIXED ''preserve''  &gt;&lt;!-- script statements, which may include CDATA sections --&gt;&lt;!ELEMENT script (#PCDATA)&gt;&lt;!ATTLIST script  id          ID             #IMPLIED  charset     %Charset;      #IMPLIED  type        %ContentType;  #REQUIRED  src         %URI;          #IMPLIED  defer       (defer)        #IMPLIED  xml:space   (preserve)     #FIXED ''preserve''  &gt;&lt;!-- alternate content container for non script-based rendering --&gt;&lt;!ELEMENT noscript %Block;&gt;&lt;!ATTLIST noscript  %attrs;  &gt;&lt;!--=================== Document Body ====================================--&gt;&lt;!ELEMENT body %Block;&gt;&lt;!ATTLIST body  %attrs;  onload          %Script;   #IMPLIED  onunload        %Script;   #IMPLIED  &gt;&lt;!ELEMENT div %Flow;&gt;  &lt;!-- generic language/style container --&gt;&lt;!ATTLIST div  %attrs;  &gt;&lt;!--=================== Paragraphs =======================================--&gt;&lt;!ELEMENT p %Inline;&gt;&lt;!ATTLIST p  %attrs;  &gt;&lt;!--=================== Headings =========================================--&gt;&lt;!--  There are six levels of headings from h1 (the most important)  to h6 (the least important).--&gt;&lt;!ELEMENT h1  %Inline;&gt;&lt;!ATTLIST h1   %attrs;   &gt;&lt;!ELEMENT h2 %Inline;&gt;&lt;!ATTLIST h2   %attrs;   &gt;&lt;!ELEMENT h3 %Inline;&gt;&lt;!ATTLIST h3   %attrs;   &gt;&lt;!ELEMENT h4 %Inline;&gt;&lt;!ATTLIST h4   %attrs;   &gt;&lt;!ELEMENT h5 %Inline;&gt;&lt;!ATTLIST h5   %attrs;   &gt;&lt;!ELEMENT h6 %Inline;&gt;&lt;!ATTLIST h6   %attrs;   &gt;&lt;!--=================== Lists ============================================--&gt;&lt;!-- Unordered list --&gt;&lt;!ELEMENT ul (li)+&gt;&lt;!ATTLIST ul  %attrs;  &gt;&lt;!-- Ordered (numbered) list --&gt;&lt;!ELEMENT ol (li)+&gt;&lt;!ATTLIST ol  %attrs;  &gt;&lt;!-- list item --&gt;&lt;!ELEMENT li %Flow;&gt;&lt;!ATTLIST li  %attrs;  &gt;&lt;!-- definition lists - dt for term, dd for its definition --&gt;&lt;!ELEMENT dl (dt|dd)+&gt;&lt;!ATTLIST dl  %attrs;  &gt;&lt;!ELEMENT dt %Inline;&gt;&lt;!ATTLIST dt  %attrs;  &gt;&lt;!ELEMENT dd %Flow;&gt;&lt;!ATTLIST dd  %attrs;  &gt;&lt;!--=================== Address ==========================================--&gt;&lt;!-- information on author --&gt;&lt;!ELEMENT address %Inline;&gt;&lt;!ATTLIST address  %attrs;  &gt;&lt;!--=================== Horizontal Rule ==================================--&gt;&lt;!ELEMENT hr EMPTY&gt;&lt;!ATTLIST hr  %attrs;  &gt;&lt;!--=================== Preformatted Text ================================--&gt;&lt;!-- content is %Inline; excluding "img|object|big|small|sub|sup" --&gt;&lt;!ELEMENT pre %pre.content;&gt;&lt;!ATTLIST pre  %attrs;  xml:space (preserve) #FIXED ''preserve''  &gt;&lt;!--=================== Block-like Quotes ================================--&gt;&lt;!ELEMENT blockquote %Block;&gt;&lt;!ATTLIST blockquote  %attrs;  cite        %URI;          #IMPLIED  &gt;&lt;!--=================== Inserted/Deleted Text ============================--&gt;&lt;!--  ins/del are allowed in block and inline content, but its  inappropriate to include block content within an ins element  occurring in inline content.--&gt;&lt;!ELEMENT ins %Flow;&gt;&lt;!ATTLIST ins  %attrs;  cite        %URI;          #IMPLIED  datetime    %Datetime;     #IMPLIED  &gt;&lt;!ELEMENT del %Flow;&gt;&lt;!ATTLIST del  %attrs;  cite        %URI;          #IMPLIED  datetime    %Datetime;     #IMPLIED  &gt;&lt;!--================== The Anchor Element ================================--&gt;&lt;!-- content is %Inline; except that anchors shouldn''t be nested --&gt;&lt;!ELEMENT a %a.content;&gt;&lt;!ATTLIST a  %attrs;  %focus;  charset     %Charset;      #IMPLIED  type        %ContentType;  #IMPLIED  name        NMTOKEN        #IMPLIED  href        %URI;          #IMPLIED  hreflang    %LanguageCode; #IMPLIED  rel         %LinkTypes;    #IMPLIED  rev         %LinkTypes;    #IMPLIED  shape       %Shape;        "rect"  coords      %Coords;       #IMPLIED  &gt;&lt;!--===================== Inline Elements ================================--&gt;&lt;!ELEMENT span %Inline;&gt; &lt;!-- generic language/style container --&gt;&lt;!ATTLIST span  %attrs;  &gt;&lt;!ELEMENT bdo %Inline;&gt;  &lt;!-- I18N BiDi over-ride --&gt;&lt;!ATTLIST bdo  %coreattrs;  %events;  lang        %LanguageCode; #IMPLIED  xml:lang    %LanguageCode; #IMPLIED  dir         (ltr|rtl)      #REQUIRED  &gt;&lt;!ELEMENT br EMPTY&gt;   &lt;!-- forced line break --&gt;&lt;!ATTLIST br  %coreattrs;  &gt;&lt;!ELEMENT em %Inline;&gt;   &lt;!-- emphasis --&gt;&lt;!ATTLIST em %attrs;&gt;&lt;!ELEMENT strong %Inline;&gt;   &lt;!-- strong emphasis --&gt;&lt;!ATTLIST strong %attrs;&gt;&lt;!ELEMENT dfn %Inline;&gt;   &lt;!-- definitional --&gt;&lt;!ATTLIST dfn %attrs;&gt;&lt;!ELEMENT code %Inline;&gt;   &lt;!-- program code --&gt;&lt;!ATTLIST code %attrs;&gt;&lt;!ELEMENT samp %Inline;&gt;   &lt;!-- sample --&gt;&lt;!ATTLIST samp %attrs;&gt;&lt;!ELEMENT kbd %Inline;&gt;  &lt;!-- something user would type --&gt;&lt;!ATTLIST kbd %attrs;&gt;&lt;!ELEMENT var %Inline;&gt;   &lt;!-- variable --&gt;&lt;!ATTLIST var %attrs;&gt;&lt;!ELEMENT cite %Inline;&gt;   &lt;!-- citation --&gt;&lt;!ATTLIST cite %attrs;&gt;&lt;!ELEMENT abbr %Inline;&gt;   &lt;!-- abbreviation --&gt;&lt;!ATTLIST abbr %attrs;&gt;&lt;!ELEMENT acronym %Inline;&gt;   &lt;!-- acronym --&gt;&lt;!ATTLIST acronym %attrs;&gt;&lt;!ELEMENT q %Inline;&gt;   &lt;!-- inlined quote --&gt;&lt;!ATTLIST q  %attrs;  cite        %URI;          #IMPLIED  &gt;&lt;!ELEMENT sub %Inline;&gt; &lt;!-- subscript --&gt;&lt;!ATTLIST sub %attrs;&gt;&lt;!ELEMENT sup %Inline;&gt; &lt;!-- superscript --&gt;&lt;!ATTLIST sup %attrs;&gt;&lt;!ELEMENT tt %Inline;&gt;   &lt;!-- fixed pitch font --&gt;&lt;!ATTLIST tt %attrs;&gt;&lt;!ELEMENT i %Inline;&gt;   &lt;!-- italic font --&gt;&lt;!ATTLIST i %attrs;&gt;&lt;!ELEMENT b %Inline;&gt;   &lt;!-- bold font --&gt;&lt;!ATTLIST b %attrs;&gt;&lt;!ELEMENT big %Inline;&gt;   &lt;!-- bigger font --&gt;&lt;!ATTLIST big %attrs;&gt;&lt;!ELEMENT small %Inline;&gt;   &lt;!-- smaller font --&gt;&lt;!ATTLIST small %attrs;&gt;&lt;!--==================== Object ======================================--&gt;&lt;!--  object is used to embed objects as part of HTML pages.  param elements should precede other content. Parameters  can also be expressed as attribute/value pairs on the  object element itself when brevity is desired.--&gt;&lt;!ELEMENT object (#PCDATA | param | %block; | form | %inline; | %misc;)*&gt;&lt;!ATTLIST object  %attrs;  declare     (declare)      #IMPLIED  classid     %URI;          #IMPLIED  codebase    %URI;          #IMPLIED  data        %URI;          #IMPLIED  type        %ContentType;  #IMPLIED  codetype    %ContentType;  #IMPLIED  archive     %UriList;      #IMPLIED  standby     %Text;         #IMPLIED  height      %Length;       #IMPLIED  width       %Length;       #IMPLIED  usemap      %URI;          #IMPLIED  name        NMTOKEN        #IMPLIED  tabindex    %Number;       #IMPLIED  &gt;&lt;!--  param is used to supply a named property value.  In XML it would seem natural to follow RDF and support an  abbreviated syntax where the param elements are replaced  by attribute value pairs on the object start tag.--&gt;&lt;!ELEMENT param EMPTY&gt;&lt;!ATTLIST param  id          ID             #IMPLIED  name        CDATA          #IMPLIED  value       CDATA          #IMPLIED  valuetype   (data|ref|object) "data"  type        %ContentType;  #IMPLIED  &gt;&lt;!--=================== Images ===========================================--&gt;&lt;!--   To avoid accessibility problems for people who aren''t   able to see the image, you should provide a text   description using the alt and longdesc attributes.   In addition, avoid the use of server-side image maps.   Note that in this DTD there is no name attribute. That   is only available in the transitional and frameset DTD.--&gt;&lt;!ELEMENT img EMPTY&gt;&lt;!ATTLIST img  %attrs;  src         %URI;          #REQUIRED  alt         %Text;         #REQUIRED  longdesc    %URI;          #IMPLIED  height      %Length;       #IMPLIED  width       %Length;       #IMPLIED  usemap      %URI;          #IMPLIED  ismap       (ismap)        #IMPLIED  &gt;&lt;!-- usemap points to a map element which may be in this document  or an external document, although the latter is not widely supported --&gt;&lt;!--================== Client-side image maps ============================--&gt;&lt;!-- These can be placed in the same document or grouped in a     separate document although this isn''t yet widely supported --&gt;&lt;!ELEMENT map ((%block; | form | %misc;)+ | area+)&gt;&lt;!ATTLIST map  %i18n;  %events;  id          ID             #REQUIRED  class       CDATA          #IMPLIED  style       %StyleSheet;   #IMPLIED  title       %Text;         #IMPLIED  name        NMTOKEN        #IMPLIED  &gt;&lt;!ELEMENT area EMPTY&gt;&lt;!ATTLIST area  %attrs;  %focus;  shape       %Shape;        "rect"  coords      %Coords;       #IMPLIED  href        %URI;          #IMPLIED  nohref      (nohref)       #IMPLIED  alt         %Text;         #REQUIRED  &gt;&lt;!--================ Forms ===============================================--&gt;&lt;!ELEMENT form %form.content;&gt;   &lt;!-- forms shouldn''t be nested --&gt;&lt;!ATTLIST form  %attrs;  action      %URI;          #REQUIRED  method      (get|post)     "get"  enctype     %ContentType;  "application/x-www-form-urlencoded"  onsubmit    %Script;       #IMPLIED  onreset     %Script;       #IMPLIED  accept      %ContentTypes; #IMPLIED  accept-charset %Charsets;  #IMPLIED  &gt;&lt;!--  Each label must not contain more than ONE field  Label elements shouldn''t be nested.--&gt;&lt;!ELEMENT label %Inline;&gt;&lt;!ATTLIST label  %attrs;  for         IDREF          #IMPLIED  accesskey   %Character;    #IMPLIED  onfocus     %Script;       #IMPLIED  onblur      %Script;       #IMPLIED  &gt;&lt;!ENTITY % InputType  "(text | password | checkbox |    radio | submit | reset |    file | hidden | image | button)"   &gt;&lt;!-- the name attribute is required for all but submit &amp; reset --&gt;&lt;!ELEMENT input EMPTY&gt;     &lt;!-- form control --&gt;&lt;!ATTLIST input  %attrs;  %focus;  type        %InputType;    "text"  name        CDATA          #IMPLIED  value       CDATA          #IMPLIED  checked     (checked)      #IMPLIED  disabled    (disabled)     #IMPLIED  readonly    (readonly)     #IMPLIED  size        CDATA          #IMPLIED  maxlength   %Number;       #IMPLIED  src         %URI;          #IMPLIED  alt         CDATA          #IMPLIED  usemap      %URI;          #IMPLIED  onselect    %Script;       #IMPLIED  onchange    %Script;       #IMPLIED  accept      %ContentTypes; #IMPLIED  &gt;&lt;!ELEMENT select (optgroup|option)+&gt;  &lt;!-- option selector --&gt;&lt;!ATTLIST select  %attrs;  name        CDATA          #IMPLIED  size        %Number;       #IMPLIED  multiple    (multiple)     #IMPLIED  disabled    (disabled)     #IMPLIED  tabindex    %Number;       #IMPLIED  onfocus     %Script;       #IMPLIED  onblur      %Script;       #IMPLIED  onchange    %Script;       #IMPLIED  &gt;&lt;!ELEMENT optgroup (option)+&gt;   &lt;!-- option group --&gt;&lt;!ATTLIST optgroup  %attrs;  disabled    (disabled)     #IMPLIED  label       %Text;         #REQUIRED  &gt;&lt;!ELEMENT option (#PCDATA)&gt;     &lt;!-- selectable choice --&gt;&lt;!ATTLIST option  %attrs;  selected    (selected)     #IMPLIED  disabled    (disabled)     #IMPLIED  label       %Text;         #IMPLIED  value       CDATA          #IMPLIED  &gt;&lt;!ELEMENT textarea (#PCDATA)&gt;     &lt;!-- multi-line text field --&gt;&lt;!ATTLIST textarea  %attrs;  %focus;  name        CDATA          #IMPLIED  rows        %Number;       #REQUIRED  cols        %Number;       #REQUIRED  disabled    (disabled)     #IMPLIED  readonly    (readonly)     #IMPLIED  onselect    %Script;       #IMPLIED  onchange    %Script;       #IMPLIED  &gt;&lt;!--  The fieldset element is used to group form fields.  Only one legend element should occur in the content  and if present should only be preceded by whitespace.--&gt;&lt;!ELEMENT fieldset (#PCDATA | legend | %block; | form | %inline; | %misc;)*&gt;&lt;!ATTLIST fieldset  %attrs;  &gt;&lt;!ELEMENT legend %Inline;&gt;     &lt;!-- fieldset label --&gt;&lt;!ATTLIST legend  %attrs;  accesskey   %Character;    #IMPLIED  &gt;&lt;!-- Content is %Flow; excluding a, form and form controls--&gt; &lt;!ELEMENT button %button.content;&gt;  &lt;!-- push button --&gt;&lt;!ATTLIST button  %attrs;  %focus;  name        CDATA          #IMPLIED  value       CDATA          #IMPLIED  type        (button|submit|reset) "submit"  disabled    (disabled)     #IMPLIED  &gt;&lt;!--======================= Tables =======================================--&gt;&lt;!-- Derived from IETF HTML table standard, see [RFC1942] --&gt;&lt;!-- The border attribute sets the thickness of the frame around the table. The default units are screen pixels. The frame attribute specifies which parts of the frame around the table should be rendered. The values are not the same as CALS to avoid a name clash with the valign attribute.--&gt;&lt;!ENTITY % TFrame "(void|above|below|hsides|lhs|rhs|vsides|box|border)"&gt;&lt;!-- The rules attribute defines which rules to draw between cells: If rules is absent then assume:     "none" if border is absent or border="0" otherwise "all"--&gt;&lt;!ENTITY % TRules "(none | groups | rows | cols | all)"&gt;  &lt;!-- horizontal alignment attributes for cell contents  char        alignment char, e.g. char='':''  charoff     offset for alignment char--&gt;&lt;!ENTITY % cellhalign  "align      (left|center|right|justify|char) #IMPLIED   char       %Character;    #IMPLIED   charoff    %Length;       #IMPLIED"  &gt;&lt;!-- vertical alignment attributes for cell contents --&gt;&lt;!ENTITY % cellvalign  "valign     (top|middle|bottom|baseline) #IMPLIED"  &gt;&lt;!ELEMENT table     (caption?, (col*|colgroup*), thead?, tfoot?, (tbody+|tr+))&gt;&lt;!ELEMENT caption  %Inline;&gt;&lt;!ELEMENT thead    (tr)+&gt;&lt;!ELEMENT tfoot    (tr)+&gt;&lt;!ELEMENT tbody    (tr)+&gt;&lt;!ELEMENT colgroup (col)*&gt;&lt;!ELEMENT col      EMPTY&gt;&lt;!ELEMENT tr       (th|td)+&gt;&lt;!ELEMENT th       %Flow;&gt;&lt;!ELEMENT td       %Flow;&gt;&lt;!ATTLIST table  %attrs;  summary     %Text;         #IMPLIED  width       %Length;       #IMPLIED  border      %Pixels;       #IMPLIED  frame       %TFrame;       #IMPLIED  rules       %TRules;       #IMPLIED  cellspacing %Length;       #IMPLIED  cellpadding %Length;       #IMPLIED  &gt;&lt;!ATTLIST caption  %attrs;  &gt;&lt;!--colgroup groups a set of col elements. It allows you to groupseveral semantically related columns together.--&gt;&lt;!ATTLIST colgroup  %attrs;  span        %Number;       "1"  width       %MultiLength;  #IMPLIED  %cellhalign;  %cellvalign;  &gt;&lt;!-- col elements define the alignment properties for cells in one or more columns. The width attribute specifies the width of the columns, e.g.     width=64        width in screen pixels     width=0.5*      relative width of 0.5 The span attribute causes the attributes of one col element to apply to more than one column.--&gt;&lt;!ATTLIST col  %attrs;  span        %Number;       "1"  width       %MultiLength;  #IMPLIED  %cellhalign;  %cellvalign;  &gt;&lt;!--    Use thead to duplicate headers when breaking table    across page boundaries, or for static headers when    tbody sections are rendered in scrolling panel.    Use tfoot to duplicate footers when breaking table    across page boundaries, or for static footers when    tbody sections are rendered in scrolling panel.    Use multiple tbody sections when rules are needed    between groups of table rows.--&gt;&lt;!ATTLIST thead  %attrs;  %cellhalign;  %cellvalign;  &gt;&lt;!ATTLIST tfoot  %attrs;  %cellhalign;  %cellvalign;  &gt;&lt;!ATTLIST tbody  %attrs;  %cellhalign;  %cellvalign;  &gt;&lt;!ATTLIST tr  %attrs;  %cellhalign;  %cellvalign;  &gt;&lt;!-- Scope is simpler than headers attribute for common tables --&gt;&lt;!ENTITY % Scope "(row|col|rowgroup|colgroup)"&gt;&lt;!-- th is for headers, td for data and for cells acting as both --&gt;&lt;!ATTLIST th  %attrs;  abbr        %Text;         #IMPLIED  axis        CDATA          #IMPLIED  headers     IDREFS         #IMPLIED  scope       %Scope;        #IMPLIED  rowspan     %Number;       "1"  colspan     %Number;       "1"  %cellhalign;  %cellvalign;  &gt;&lt;!ATTLIST td  %attrs;  abbr        %Text;         #IMPLIED  axis        CDATA          #IMPLIED  headers     IDREFS         #IMPLIED  scope       %Scope;        #IMPLIED  rowspan     %Number;       "1"  colspan     %Number;       "1"  %cellhalign;  %cellvalign;  &gt;'</body></methods><methods><class-id>WikiWorks.WikiPageLink</class-id> <category>constants</category><body package="WikiWorks4SSP">externalLinkPrefixes	^#('http://*' 'https://*' 'mailto:*' 'file:/*' 'ftp://*' 'news:*' 'nntp://*' 'telnet://*' 'prospero://*' 'gopher://*' 'wais://*')</body><body package="WikiWorks4SSP">isbnUrlPrefix	^'http://www.amazon.com/exec/obidos/ASIN/'</body></methods><methods><class-id>WikiWorks.WikiPageLink class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">new	^super new initialize</body></methods><methods><class-id>WikiWorks.HtmlRender4ssp</class-id> <category>html-tags</category><body package="WikiWorks4SSP">bulletList: aBlock 	self startBulletList.	aBlock value.	self closeBulletList</body><body package="WikiWorks4SSP">closeBulletList	self != '&lt;/ul&gt;'</body><body package="WikiWorks4SSP">closeListItem	self != '&lt;/li&gt;'</body><body package="WikiWorks4SSP">closeNumberList	self != '&lt;/ol&gt;'</body><body package="WikiWorks4SSP">closeTableCell	self != '&lt;/td&gt;'</body><body package="WikiWorks4SSP">heading: aBlock 	self heading: aBlock level: 2</body><body package="WikiWorks4SSP">heading: aBlock level: anInteger 	self		,= '&lt;h';		,= anInteger;		,= ' &gt;&lt;font face="Arial" &gt;'.	aBlock value.	self		,= '&lt;/font&gt;&lt;/h';		,= anInteger;		!= '&gt;'</body><body package="WikiWorks4SSP">horizontalRule	self != '&lt;hr&gt;'</body><body package="WikiWorks4SSP">italicize: aBlock 	self ,= '&lt;i&gt;'.	aBlock value.	self ,= '&lt;/i&gt;'</body><body package="WikiWorks4SSP">linkTo: urlBlock titled: titleBlock 	self ,= '&lt;a href="'.	urlBlock value.	self ,= '" &gt;'.	titleBlock value.	self ,= '&lt;/a&gt;'</body><body package="WikiWorks4SSP">listItem: aBlock 	self startListItem.	aBlock value.	self closeListItem</body><body package="WikiWorks4SSP">precise: aBlock 	self ,= '&lt;pre&gt;'.	aBlock value.	self != '&lt;/pre&gt;'</body><body package="WikiWorks4SSP">startBulletList	self ,= '&lt;ul&gt;'</body><body package="WikiWorks4SSP">startListItem	self ,= '&lt;li&gt;'</body><body package="WikiWorks4SSP">startNumberList	self ,= '&lt;ol&gt;'</body><body package="WikiWorks4SSP">startTableCell: align 	self ,= '&lt;td align="'.	self ,= align.	self ,= '" &gt;'</body><body package="WikiWorks4SSP">startTableRow: align 	self ,= '&lt;tr&gt;'.	self startTableCell: align</body></methods><methods><class-id>WikiWorks.HtmlRender4ssp</class-id> <category>accessing-handler</category><body package="WikiWorks4SSP">handler	^handler</body><body package="WikiWorks4SSP">handlerName	^handler name</body></methods><methods><class-id>WikiWorks.HtmlRender4ssp</class-id> <category>streaming</category><body package="WikiWorks4SSP">!= anObject 	self		,= anObject;		cr.	^anObject</body><body package="WikiWorks4SSP">,= anObject 	^anObject sendOver: myReplyStream</body><body package="WikiWorks4SSP">cr	myReplyStream cr</body><body package="WikiWorks4SSP">pageURLfor: aPageTitle 	self ,= 'page.ssp?wikiname='.	self ,= handler name encodedHTTP.	self ,= '&amp;amp;pagename='.	self ,= aPageTitle encodedHTTP</body><body package="WikiWorks4SSP">space	myReplyStream space</body></methods><methods><class-id>WikiWorks.WikiRender4ssp</class-id> <category>defaults-changes</category><body package="WikiWorks4SSP">numberOfChanges	^20</body><body package="WikiWorks4SSP">numberOfDays	^7</body></methods><methods><class-id>WikiWorks.WikiRender4ssp</class-id> <category>accessing-pages</category><body package="WikiWorks4SSP">numberOfPages	^handler pages size</body><body package="WikiWorks4SSP">pageList		[self 		bulletList: [self pages do: [:each | self listItem: [self renderPage: each]]]] 			niceValue</body><body package="WikiWorks4SSP">pages	^handler pages asSortedCollection</body></methods><methods><class-id>WikiWorks.WikiRender4ssp</class-id> <category>rendering-references</category><body package="WikiWorks4SSP">renderNoreferences	self heading: [self ,= ' No references to: '].	self italicize: 			[self				,= ' ...';				,= self searchString;				,= '... ']</body><body package="WikiWorks4SSP">renderReferences: pages 	self heading: 			[pages size = 1 				ifTrue: [self ,= ' There is 1 reference to: ']				ifFalse: 					[self						,= ' There are ';						,= pages size;						,= ' references to: '.					self searchString printOn: myReplyStream quoteCharacter: $"]].	self horizontalRule.	self 		bulletList: [pages do: [:each | self listItem: [self renderPage: each]]]</body></methods><methods><class-id>WikiWorks.WikiRender4ssp</class-id> <category>accessing-changes</category><body package="WikiWorks4SSP">changesFor: aDate 	^handler changesFor: aDate</body><body package="WikiWorks4SSP">recentChanges	| day minDate startDate changesShown |	day := Date today.	minDate := day subtractDays: self numberOfDays.	changesShown := 0.	startDate := self startDate.		[	[day &lt; startDate 		or: [changesShown &gt; self numberOfChanges and: [day &lt; minDate]]] 			whileFalse: 				[changesShown := changesShown + (self renderChangesFor: day).				day := day subtractDays: 1]] 			niceValue</body><body package="WikiWorks4SSP">startDate	^handler startDate</body></methods><methods><class-id>WikiWorks.WikiRender4ssp</class-id> <category>accessing-references</category><body package="WikiWorks4SSP">references		[| referringPages |	referringPages := self referencesFor: self searchString.	referringPages isEmpty 		ifTrue: [self renderNoreferences]		ifFalse: [self renderReferences: referringPages]] 			niceValue</body><body package="WikiWorks4SSP">referencesFor: aString 	^handler referencesFor: aString</body><body package="WikiWorks4SSP">searchString	^searchString</body><body package="WikiWorks4SSP">searchString: aString 	searchString := aString</body></methods><methods><class-id>WikiWorks.WikiRender4ssp</class-id> <category>rendering-page</category><body package="WikiWorks4SSP">renderPage: aPage 	self linkTo: [self renderPageURL: aPage]		titled: [self renderPageTitle: aPage]</body><body package="WikiWorks4SSP">renderPageDetail: aPage 	self space.	TimestampPrintPolicy 		print: aPage timestamp		on: myReplyStream		using: 'hh:mm:ss'.	self ,= ' ('.	self ,= aPage author.	self ,= $)</body><body package="WikiWorks4SSP">renderPageTitle: aPage 	self ,= aPage title</body><body package="WikiWorks4SSP">renderPageURL: aPage 	self pageURLfor: aPage title</body></methods><methods><class-id>WikiWorks.WikiRender4ssp</class-id> <category>rendering-changes</category><body package="WikiWorks4SSP">renderChangesFor: aDate 	| sc |	sc := self changesFor: aDate.	sc isEmpty ifTrue: [^0].	self heading: 			[TimestampPrintPolicy 				print: aDate				on: myReplyStream				using: 'mmmm d yyyy']		level: 3.	self bulletList: 			[sc do: 					[:each | 					self listItem: 							[self renderPage: each.							self renderPageDetail: each]]].	^sc size</body></methods><methods><class-id>WikiWorks.CompositeWikiRender4ssp</class-id> <category>rendering-page</category><body package="WikiWorks4SSP">renderPage: pageAndWiki 	handler := pageAndWiki value.	super renderPage: pageAndWiki key</body><body package="WikiWorks4SSP">renderPageDetail: pageAndWiki 	super renderPageDetail: pageAndWiki key</body><body package="WikiWorks4SSP">renderPageTitle: aPage 	self ,= self handlerName.	self ,= ' -&gt; '.	super renderPageTitle: aPage</body></methods><methods><class-id>WikiWorks.CompositeWikiRender4ssp</class-id> <category>accessing-pages</category><body package="WikiWorks4SSP">numberOfPages	^components inject: 0 into: [:size :each | size + each latestPages size]</body><body package="WikiWorks4SSP">pageList	| savedHandler |	savedHandler := handler.	[super pageList] ensure: [handler := savedHandler].	^myReplyStream</body><body package="WikiWorks4SSP">pages	| sc |	sc := SortedCollection sortBlock: [:a :b | a key title &lt; b key title].	components do: [:wiki | wiki latestPages do: [:page | sc add: page -&gt; wiki]].	^sc</body></methods><methods><class-id>WikiWorks.CompositeWikiRender4ssp</class-id> <category>accessing-references</category><body package="WikiWorks4SSP">references	| savedHandler |	savedHandler := handler.	[super references] ensure: [handler := savedHandler].	^myReplyStream</body><body package="WikiWorks4SSP">referencesFor: aString 	| sc |	sc := SortedCollection sortBlock: [:a :b | a key title &lt; b key title].	components 		do: [:wiki | (wiki referencesFor: aString) do: [:page | sc add: page -&gt; wiki]].	^sc</body></methods><methods><class-id>WikiWorks.CompositeWikiRender4ssp</class-id> <category>accessing-changes</category><body package="WikiWorks4SSP">changesFor: aDate 	| sc |	sc := SortedCollection 				sortBlock: [:a :b | a key timestamp &gt; b key timestamp].	components 		do: [:wiki | (wiki changesFor: aDate) do: [:page | sc add: page -&gt; wiki]].	^sc</body><body package="WikiWorks4SSP">recentChanges	| savedHandler |	savedHandler := handler.	[super recentChanges] ensure: [handler := savedHandler].	^myReplyStream</body><body package="WikiWorks4SSP">startDate	^components inject: Date today		into: [:bottom :each | each startDate min: bottom]</body></methods><methods><class-id>WikiWorks.CompositeWikiRender4ssp</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">requestfromWikis: wikis in: aHandler 	handler := aHandler.	myReplyStream := WriteStream on: String new.	components := SortedCollection sortBlock: [:a :b | a name &lt; b name].	wikis do: 			[:key | 			| each |			each := handler componentNamed: key ifAbsent: [nil].			each notNil: [components add: each]]</body></methods><methods><class-id>WikiWorks.CompositeWikiRender4ssp</class-id> <category>defaults-changes</category><body package="WikiWorks4SSP">numberOfChanges	^components size * super numberOfChanges / 2</body></methods><methods><class-id>WikiWorks.CompositeWikiRender4ssp</class-id> <category>accessing</category><body package="WikiWorks4SSP">components	^components</body></methods><methods><class-id>WikiWorks.CompositeWikiRender4ssp class</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">requestfromWikis: wikis in: aHandler 	^self new requestfromWikis: wikis in: aHandler</body></methods><methods><class-id>WikiWorks.WebResponder</class-id> <category>server load</category><body package="WikiWorks4SSP">canHandleLoad	| loadLevel |	loadLevel := self loadAssessor currentLoad.	^self canHandleLoadAt: loadLevel</body><body package="WikiWorks4SSP">canHandleLoadAt: loadLevel 	"return aBoolean based on the user defined preference for cutting off 	launches"	^loadLevel &lt; self serviceCutOff</body><body package="WikiWorks4SSP">serviceCutOff	"return the server load for which the receiver should stop service"	^5</body></methods><methods><class-id>WikiWorks.WebResponder</class-id> <category>testing</category><body package="WikiWorks4SSP">canAnswer: aWebRequest	"Express whether this object can appropriately answer this WebRequest. Default is no. Subclasses must override."	^false.</body><body package="WikiWorks4SSP">consumesPath	"Return true if this expects to strip off the first element of the path. By default true, since this is standard Wave behavior."	^true.</body><body package="WikiWorks4SSP">isLauncher	^self class isLauncher</body><body package="WikiWorks4SSP">isResolver 	"Can this object be considered something which finds a WebResponder, rather than composes a response itself?"	^false</body></methods><methods><class-id>WikiWorks.WebResponder</class-id> <category>private</category><body package="WikiWorks4SSP">currentLoad	"return the server load level. Should only be executed 	in the absence of ServerMemoryPolicy"	^0</body><body package="WikiWorks4SSP">errorReporter	^VisualWave.WaveDeploymentNotifier.</body><body package="WikiWorks4SSP">getASomething: aStringOrSymbol 	"Error fix: String does not implement fullName and it does not look like that an argument can be aClass"	"SAG altered method so there is a test for strings. You naow can pass a class to this methods as well"	| objects destName matches |	destName := aStringOrSymbol isSymbol				ifTrue: [aStringOrSymbol asString]				ifFalse: [aStringOrSymbol isString ifTrue: [aStringOrSymbol] ifFalse: [aStringOrSymbol fullName] ].	^destName asQualifiedReference		valueOrDo: 			[objects := Root withAllNameSpacesAndAllClassesAndStatics.			matches := objects select: [:mod | destName match: mod name].			(matches == nil or: [matches size = 0])				ifTrue: [nil]				ifFalse: [matches first]]</body><body package="WikiWorks4SSP">loadAssessor	^VisualWave.ServerMemoryPolicy.</body></methods><methods><class-id>WikiWorks.WebResponder</class-id> <category>public interface</category><body package="WikiWorks4SSP">answerFor: aWebRequest	"Returns an object suitable as a web (HTTP) response"	self subclassResponsibility</body><body package="WikiWorks4SSP">newPath: aString	"notification of a new path for finding this responder"</body><body package="WikiWorks4SSP">respondTo: aWebRequest	aWebRequest answerWith: (self answerFor: aWebRequest)</body></methods><methods><class-id>WikiWorks.WebResponder</class-id> <category>accessing</category><body package="WikiWorks4SSP">allSessions^nil</body><body package="WikiWorks4SSP">defaultEditor	^self  class editorClass new</body><body package="WikiWorks4SSP">likelySessionFor: aReq^nil</body></methods><methods><class-id>WikiWorks.WebResponder</class-id> <category>alerts</category><body package="WikiWorks4SSP">answerSource	^VisualWave.SimpleAnswer</body><body package="WikiWorks4SSP">forbiddenAnswerFor: aRequest 	^self answerSource forbiddenAnswerFor: aRequest in: self</body><body package="WikiWorks4SSP">notFoundAnswerFor: aRequest 	^self answerSource notFoundAnswerFor: aRequest in: self</body><body package="WikiWorks4SSP">tooBusyAnswerFor: aRequest 	^self answerSource tooBusyAnswerFor: aRequest in: self</body></methods><methods><class-id>WikiWorks.WebResponder class</class-id> <category>testing</category><body package="WikiWorks4SSP">isLauncher	^false</body></methods><methods><class-id>WikiWorks.WebResponder class</class-id> <category>utility</category><body package="WikiWorks4SSP">editorClass	^nil</body><body package="WikiWorks4SSP">registerClassesForConfigurationIn: aList 	self allSubclassesDo: [:ea | ea registerForConfigurationIn: aList].</body><body package="WikiWorks4SSP">registerForConfigurationIn: aList 	"subclasses should overide this message if they want to appear in the server console's pull down menu of available resolver types"	self editorClass notNil		ifTrue: [aList add: self].</body></methods><methods><class-id>WikiWorks.WebResponder class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">new	^super new initialize</body><body package="WikiWorks4SSP">newMinimum	^self new initialize</body></methods><methods><class-id>WikiWorks.WikiPageRender4ssp</class-id> <category>parsing states</category><body package="WikiWorks4SSP">atLineStart	^(Array with: Character cr) includes: lastChar</body><body package="WikiWorks4SSP">inBullets	^bulletLevel &gt; 0</body><body package="WikiWorks4SSP">inHeading	^headingLevel &gt; 0</body><body package="WikiWorks4SSP">inNumbers	^numberLevel &gt; 0</body><body package="WikiWorks4SSP">inTable	^inTable</body><body package="WikiWorks4SSP">isInTable	inTable := true</body><body package="WikiWorks4SSP">notInTable	inTable := false</body><body package="WikiWorks4SSP">resetBullets	bulletLevel := 0</body><body package="WikiWorks4SSP">resetHeading	headingLevel := 0</body><body package="WikiWorks4SSP">resetNumbers	numberLevel := 0</body><body package="WikiWorks4SSP">resetParsingStates	currentChar := Character cr.	self resetHeading.	self resetBullets.	self resetNumbers.	self notInTable</body></methods><methods><class-id>WikiWorks.WikiPageRender4ssp</class-id> <category>parsing</category><body package="WikiWorks4SSP">addCurrentChar	self ,= (self httpEncode: currentChar)</body><body package="WikiWorks4SSP">closeBullets	self closeListItem.	bulletLevel timesRepeat: [self closeBulletList].	self resetBullets</body><body package="WikiWorks4SSP">closeHeading	self		,= '&lt;/font&gt;&lt;/h';		,= headingLevel printString;		!= '&gt;'.	self resetHeading</body><body package="WikiWorks4SSP">closeNumbers	self closeListItem.	numberLevel timesRepeat: [self closeNumberList].	self resetNumbers</body><body package="WikiWorks4SSP">closeTableRow	self closeTableCell.	self != '&lt;/tr&gt;'.	((contentStream peekForAll: '||') 		or: [(contentStream peekForAll: '|{') or: [contentStream peekForAll: '|}']]) 			ifTrue: 				[contentStream skip: -2.				^self].	self != '&lt;/table&gt;'.	self notInTable</body><body package="WikiWorks4SSP">getNextChar	lastChar := currentChar.	currentChar := contentStream next</body><body package="WikiWorks4SSP">processAsterix	| currentLevel |	self atLineStart ifFalse: [^self addCurrentChar].	self inBullets ifTrue: [self closeListItem].	currentLevel := 1.	[contentStream peekFor: $*] whileTrue: [currentLevel := currentLevel + 1].	bulletLevel - currentLevel timesRepeat: [self closeBulletList].	currentLevel - bulletLevel timesRepeat: [self startBulletList].	self startListItem.	bulletLevel := currentLevel</body><body package="WikiWorks4SSP">processBang	self atLineStart 		ifTrue: [self processHeadingLevel]		ifFalse: [self addCurrentChar]</body><body package="WikiWorks4SSP">processCR	self inHeading ifTrue: [^self closeHeading].	self inTable ifTrue: [^self closeTableRow].	self atLineStart ifFalse: [^self space].	self inBullets ifTrue: [^self closeBullets].	self inNumbers ifTrue: [^self closeNumbers].	"self paragraph"	self ,= '&lt;br/&gt;&lt;br/&gt;'</body><body package="WikiWorks4SSP">processCurrentChar	currentChar ifNil: [^self].	isHTML isNil ifTrue: [isHTML := currentChar = $&lt;].	currentChar == $\ ifTrue: [^self processEscape].	isHTML		ifFalse: 			["in an HTML File, space, tab and cr should not be processed. 			The HTML Editor already handles that and converts that into HTML. 			Processing these characters would only result in a double-processing"			currentChar == Character space ifTrue: [^self processSpace].			currentChar == Character tab ifTrue: [^self processSpace].			currentChar == Character cr ifTrue: [^self processCR]].	currentChar == $[ ifTrue: [^self processLeftBracket].	currentChar == $&lt; ifTrue: [^self processLeftAngle].	currentChar == $* ifTrue: [^self processAsterix].	currentChar == $# ifTrue: [^self processPound].	currentChar == $~ ifTrue: [^self processTilde].	currentChar == $- ifTrue: [^self processDash].	currentChar == $! ifTrue: [^self processBang].	currentChar == $| ifTrue: [^self processPipe].	self addCurrentChar</body><body package="WikiWorks4SSP">processDash	(self atLineStart and: [contentStream peekForAll: '---']) 		ifFalse: [^self addCurrentChar].	contentStream skipThrough: Character cr.	currentChar := Character cr.	self horizontalRule</body><body package="WikiWorks4SSP">processEscape	self getNextChar.	self addCurrentChar</body><body package="WikiWorks4SSP">processExistingPage: link in: targetHandler 	| address |	address := targetHandler currentTitleOf: link address.	self linkTo: 			["targetHandler URLon: myReplyStream."			"self ,= 'wikiaccess1/'."			"self ,= 'page.ssp?wikiname='.			self ,= (handler name)encodedHTTP.			self ,= '&amp;seitenname='.			self ,= address encodedHTTP."			self pageURLfor: address.			link hasFragment 				ifTrue: 					[self ,= $#.					self ,= link fragment encodedHTTP]]		titled: 			[link isAnonymous 				ifTrue: 					[self ,= address.					link hasFragment 						ifTrue: 							[self ,= $#.							self ,= link fragment]]				ifFalse: [self ,= link name]]	"self linkTo: 			[targetHandler URLon: myReplyStream.			self ,= $/.			self ,= address encodedHTTP.			link hasFragment 				ifTrue: 					[self ,= $#.					self ,= link fragment encodedHTTP]]		titled: 			[link isAnonymous 				ifTrue: 					[self ,= address.					link hasFragment 						ifTrue: 							[self ,= $#.							self ,= link fragment]]				ifFalse: [self ,= link name]] "</body><body package="WikiWorks4SSP">processHeadingLevel	headingLevel := headingLevel + 1.	(contentStream peekFor: $!) ifTrue: [^self processHeadingLevel].	self		,= '&lt;h';		,= headingLevel printString;		,= ' &gt;&lt;font face="Arial" &gt;'</body><body package="WikiWorks4SSP">processLeftAngle	self addCurrentChar.	(contentStream insensitivePeekForAll: 'PRE') ifFalse: [^self].	self ,= 'pre'.		[contentStream atEnd or: 			[| closeTag |			closeTag := contentStream through: $&gt;.			self ,= closeTag.			closeTag sameAs: '/PRE&gt;']] 			whileFalse: [self ,= (contentStream through: $&lt;)].	currentChar := $&gt;</body><body package="WikiWorks4SSP">processLeftBracket		| link targetHandler url |	(contentStream peekFor: $[) ifTrue: [^self addCurrentChar].	link := WikiPageLink new contents: (contentStream upTo: $] escaper: $\).	link isMethod ifTrue: [^self processMethod: link].	targetHandler := handler.	link isExternalLink		ifTrue:			[^self				linkTo: [self ,= link address withHTMLEntities]				titled: [self ,= link name]].	(targetHandler hasFilenamed: link address)		ifTrue:			[^self				linkTo:					[url := link pathComponents						inject: String new						into: [:str :each | str , '/' , each encodedHTTP].					self ,= (handler name encodedHTTP , '_dl' , url)]				titled: [self ,= link name]].	self processPage: link in: targetHandler</body><body package="WikiWorks4SSP">processMethod: link 	| class className selector |	className := link name.	class := [Compiler evaluate: className] on: Error				do: [:ex | ex return: nil].	selector := link address.	(class isBehavior and: [class canUnderstand: selector]) 		ifTrue: [^self processMethodSelector: selector ofClass: class].	self italicize: 			[self ,= className.			self ,= '&gt;&gt;#'.			self ,= selector]</body><body package="WikiWorks4SSP">processMethodSelector: selector ofClass: class 	| source realClass |	realClass := (class includesSelector: selector) 				ifTrue: [class]				ifFalse: [class whichClassIncludesSelector: selector].	source := realClass sourceCodeAt: selector.	self precise: 			[self ,= class.			class == realClass 				ifFalse: 					[self ,= $(.					self ,= realClass.					self ,= $)].			self ,= '&gt;&gt;#'.			self ,= source asString]</body><body package="WikiWorks4SSP">processPage: link in: targetHandler 	| fragment |	(targetHandler hasPageTitled: link address) 		ifTrue: [^self processExistingPage: link in: targetHandler].	fragment := link copy fragmentize.	(targetHandler hasPageTitled: fragment address) 		ifTrue: [^self processExistingPage: fragment in: targetHandler].	self linkTo: 			["targetHandler URLon: replyStream."			self ,= 'edit.ssp?wikiname='.			self ,= handler name encodedHTTP withHTMLEntities.			self ,= '&amp;amp;pagename='.			self ,= link address encodedHTTP withHTMLEntities]		titled: [self italicize: [self ,= link name withHTMLEntities]]</body><body package="WikiWorks4SSP">processPipe	| align |	(contentStream peekFor: $|) ifTrue: [align := 'center'].	(contentStream peekFor: ${) ifTrue: [align := 'left'].	(contentStream peekFor: $}) ifTrue: [align := 'right'].	align ifNil: [^self addCurrentChar].	self atLineStart 		ifFalse: 			[^self inTable 				ifTrue: 					[self closeTableCell.					self startTableCell: align]				ifFalse: [self ,= '||']].	self inTable 		ifFalse: [self != '&lt;table border="2" cellpadding="4" cellspacing="0" &gt;'].	self startTableRow: align.	self isInTable</body><body package="WikiWorks4SSP">processPound	| currentLevel |	self atLineStart ifFalse: [^self addCurrentChar].	self inNumbers ifTrue: [self closeListItem].	currentLevel := 1.	[contentStream peekFor: $#] whileTrue: [currentLevel := currentLevel + 1].	numberLevel - currentLevel timesRepeat: [self closeNumberList].	currentLevel - numberLevel timesRepeat: [self startNumberList].	self startListItem.	numberLevel := currentLevel</body><body package="WikiWorks4SSP">processSpace	self atLineStart ifFalse: [^self space].	self getNextChar.	lastChar := Character cr.	self processCurrentChar</body><body package="WikiWorks4SSP">processTilde	self atLineStart ifTrue: [self ,= '&lt;br&gt;'] ifFalse: [self addCurrentChar]</body></methods><methods><class-id>WikiWorks.WikiPageRender4ssp</class-id> <category>accessing</category><body package="WikiWorks4SSP">page	^page</body><body package="WikiWorks4SSP">pageContents	| content |	myReplyStream := WriteStream on: String new.	self resetParsingStates.	content := self buildContents.	contentStream := content readStream.	[contentStream atEnd] whileFalse: 			[self getNextChar.			self processCurrentChar].	lastChar := currentChar := Character cr.	self processCurrentChar.	^myReplyStream</body><body package="WikiWorks4SSP">pageVersion	^page versionNumber</body><body package="WikiWorks4SSP">previousVersionString	^(self pageVersion - 1 max: 0) printString</body></methods><methods><class-id>WikiWorks.WikiPageRender4ssp</class-id> <category>testing</category><body package="WikiWorks4SSP">isLatestPage	^true</body></methods><methods><class-id>WikiWorks.WikiPageRender4ssp</class-id> <category>As yet unclassified</category><body package="WikiWorks4SSP">htmlUnicodeValue: anInteger 	^ '&amp;#', anInteger printString,';'</body><body package="WikiWorks4SSP">httpEncode: aCharacter		^aCharacter asUnicodeEntity</body></methods><methods><class-id>WikiWorks.WikiPageRender4ssp</class-id> <category>4ssp</category><body package="WikiWorks4SSP">request: aPage in: aWiki 	page := aPage.	handler := aWiki.</body></methods><methods><class-id>WikiWorks.WikiPageRender4ssp</class-id> <category>private</category><body package="WikiWorks4SSP">buildContents	^self page contents copyReplaceAll: '&lt;br&gt;' with: '&lt;br/&gt;'</body></methods><methods><class-id>WikiWorks.WikiPageRender4ssp class</class-id> <category>4ssp</category><body package="WikiWorks4SSP">request: aPage in: aWiki 	^self new request: aPage in: aWiki</body></methods><methods><class-id>WikiWorks.DifferenceRender4ssp</class-id> <category>accessing</category><body package="WikiWorks4SSP">colorFor: aSymbol 	^aSymbol == #added ifTrue: ['green'] ifFalse: ['red']</body><body package="WikiWorks4SSP">newPage	^page versionAt: newVersion</body><body package="WikiWorks4SSP">newVersionString	^newVersion printString</body><body package="WikiWorks4SSP">oldPage	^page versionAt: oldVersion</body><body package="WikiWorks4SSP">oldVersionString	^oldVersion printString</body><body package="WikiWorks4SSP">pageVersion	^oldVersion</body><body package="WikiWorks4SSP">titleFor: aSymbol 	^aSymbol == #added ifTrue: ['+ '] ifFalse: ['- ']</body></methods><methods><class-id>WikiWorks.DifferenceRender4ssp</class-id> <category>testing</category><body package="WikiWorks4SSP">isLatestPage	^newVersion = page versionNumber</body></methods><methods><class-id>WikiWorks.DifferenceRender4ssp</class-id> <category>private</category><body package="WikiWorks4SSP">buildContents	| diff |	diff := GHXhtmlDifferences forWordDifferences.	^diff differencesBetween: (self renderPage: self oldPage)		and: (self renderPage: self newPage)</body><body package="WikiWorks4SSP">printDifference: assoc on: aStream 	| isSpecial |	assoc key = #same 		ifTrue: 			[aStream nextPutAll: assoc value.			aStream cr.			^self].	isSpecial := false.	assoc value isEmpty 		ifFalse: 			[isSpecial := '*#!' includes: assoc value first.			isSpecial ifTrue: [aStream nextPut: assoc value first]].	aStream		nextPutAll: '&lt;FONT color=';		nextPutAll: (self colorFor: assoc key);		nextPutAll: ' &gt;';		nextPutAll: (self titleFor: assoc key).	(assoc value isEmpty not and: [isSpecial not])		ifTrue: [aStream nextPut: assoc value first].	assoc value size &gt; 1 		ifTrue: [aStream nextPutAll: (assoc value copyFrom: 2)].	aStream nextPutAll: '&lt;/FONT&gt;'.	aStream cr</body><body package="WikiWorks4SSP">renderPage: aPage	| renderer |	renderer := WikiPageRender4ssp request: aPage in: self handler.	^renderer pageContents contents</body></methods><methods><class-id>WikiWorks.DifferenceRender4ssp</class-id> <category>4ssp</category><body package="WikiWorks4SSP">request: aPage in: aFlatFileWiki oldVersion: oVersion newVersion: nVersion	| version |	page := aPage.	handler := aFlatFileWiki.	newVersion := (nVersion asNumber max: 0) min: page versionNumber.	oldVersion := (oVersion asNumber max: 0) min: page versionNumber.	newVersion &lt; oldVersion ifFalse: [^self].	version := newVersion.	newVersion := oldVersion.	oldVersion := version</body></methods><methods><class-id>WikiWorks.DifferenceRender4ssp class</class-id> <category>4ssp</category><body package="WikiWorks4SSP">request:aPage in: aFlatFileWiki oldVersion: oVersion newVersion: nVersion^ self new request:aPage in: aFlatFileWiki oldVersion: oVersion newVersion: nVersion</body></methods><methods><class-id>WikiWorks.CompositeWiki</class-id> <category>ssp-stuff</category><body package="WikiWorks4SSP">rename_step2: request aResponse: response 	| wikiname pagename action access_level myhandler oldpage author newtitle newpage |	wikiname := request anyFormValueAt: 'wikiname'.	pagename := request anyFormValueAt: 'pagename'.	action := request anyFormValueAt: 'action'.	pagename isNil 		ifTrue: 			[response redirectTo: 'error.html'.			^#nothing].	access_level := self authorizeRequest: request				for: wikiname.	access_level = #write_access 		ifFalse: 			[WikiWorks.FlatFileWiki logMessage: request page: 'rename_step2.ssp'.			response handler login.			^#nothing].	myhandler := self componentNamed: wikiname.	myhandler = #no_such_wiki 		ifTrue: 			[wikiname ifNil: [wikiname := 'nil'].			response redirectTo: 'nosuchwiki.ssp?wikiname=' , wikiname encodedHTTP.			^#nothing].	oldpage := myhandler pageTitled: pagename.	oldpage isNil 		ifTrue: 			[response redirectTo: 'error.html'.			^#nothing].	action = 'Save' 		ifTrue: 			[author := request remoteHost isNil ifTrue: [request remoteAddr].			newtitle := request anyFormValueAt: 'newtitle'.			newtitle size &gt; 0 				ifTrue: 					[((myhandler hasPageTitled: newtitle) 						and: [(myhandler pageTitled: newtitle) ~~ oldpage]) 							ifTrue: 								["Rename Conflict"								response 									redirectTo: 'rename_conflict.ssp?wikiname=' , wikiname encodedHTTP 											, '&amp;pagename=' , pagename encodedHTTP 											, '&amp;newtitle=' , newtitle encodedHTTP]							ifFalse: 								[newpage := oldpage changeTitle: newtitle by: author.								myhandler addPage: newpage.								response 									redirectTo: 'page.ssp?wikiname=' , wikiname encodedHTTP , '&amp;pagename=' 											, newtitle encodedHTTP]]				ifFalse: 					[response 						redirectTo: 'page.ssp?wikiname=' , wikiname encodedHTTP , '&amp;pagename=' 								, pagename encodedHTTP]].	action = 'Abort' 		ifTrue: 			[response 				redirectTo: 'page.ssp?wikiname=' , wikiname encodedHTTP , '&amp;pagename=' 						, pagename encodedHTTP].	(action = 'Save' or: [action = 'Abort']) 		ifFalse: 			["should not happen"			response redirectTo: 'error.html']</body><body package="WikiWorks4SSP">revert_step2: request aResponse: response 	| wikiname pagename version action author access_level myhandler oldPage newPage |	wikiname := request anyFormValueAt: 'wikiname'.	pagename := request anyFormValueAt: 'pagename'.	version := request anyFormValueAt: 'version'.	action := request anyFormValueAt: 'action'.	version isNil 		ifTrue: 			[response redirectTo: 'error.html'.			^#nothing].	author := request remoteHost isNil ifTrue: [request remoteAddr].	action = 'Revert' 		ifTrue: 			[access_level := self authorizeRequest: request for: wikiname.			access_level = #write_access 				ifFalse: 					[WikiWorks.FlatFileWiki logMessage: request page: 'revert_step2.ssp'.					response handler login.					^#nothing].			myhandler := self componentNamed: wikiname.			myhandler = #no_such_wiki 				ifTrue: 					[wikiname ifNil: [wikiname := 'nil'].					response redirectTo: 'nosuchwiki.ssp?wikiname=' , wikiname encodedHTTP.					^#nothing].			pagename ifNil: 					[response redirectTo: 'error.html'.					^#nothing].			oldPage := myhandler pageTitled: pagename.			oldPage ifNil: 					[pagename := 'nil'.					response 						redirectTo: 'nosuchpage.ssp?wikiname=' , wikiname encodedHTTP 								, '&amp;pagename=' , pagename encodedHTTP.					^#nothing].			newPage := oldPage revertVersion: version asNumber by: author.			myhandler addPage: newPage.			response 				redirectTo: 'page.ssp?wikiname=' , wikiname encodedHTTP , '&amp;pagename=' 						, pagename encodedHTTP].	action = 'Abort' 		ifTrue: 			[response 				redirectTo: 'history.ssp?wikiname=' , wikiname encodedHTTP , '&amp;pagename=' 						, pagename encodedHTTP].	(action = 'Revert' or: [action = 'Abort']) 		ifFalse: [response redirectTo: 'error.html']	"should not happen"</body><body package="WikiWorks4SSP">upload_failed: response wikiname: wikiname 	response redirectTo: 'upload_failed.ssp?wikiname=' , wikiname encodedHTTP</body><body package="WikiWorks4SSP">upload_step2: request aResponse: response 	| wikiname_mime data subdir_mime wikiname subdir access_level myhandler input full_filename filename_string portable_subdir subdir_stream dir filename_on_wiki output inputStream |	wikiname_mime := request anyFormValueAt: 'wikiname'.	data := request anyFormValueAt: 'data'.	subdir_mime := request anyFormValueAt: 'subdir'.	(wikiname_mime isNil or: [subdir_mime isNil or: [data isNil]]) 		ifTrue: 			[self writeErrorAnswer: response.			^#nothing].	wikiname := wikiname_mime decodedContents.	subdir := subdir_mime decodedContents.	access_level := self authorizeRequest: request for: wikiname.	access_level = #write_access 		ifFalse: 			[WikiWorks.FlatFileWiki logMessage: request page: 'upload_step2.ssp'.			response handler login.			^#nothing].	myhandler := self componentNamed: wikiname ifAbsent: 			[wikiname ifNil: [wikiname := 'nil'].			response redirectTo: 'nosuchwiki.ssp?wikiname=' , wikiname encodedHTTP.			^#nothing].	myhandler fileServer 		ifFalse: 			["against URL manipulation"			self writeErrorAnswer: response.			^#nothing]		ifTrue: 			[input := data value.			full_filename := data fileName.			filename_string := self fileNameForPath: full_filename.			portable_subdir := subdir asString asPortableFilenameString.			subdir_stream := ReadStream on: portable_subdir.			subdir_stream anti13 				ifTrue: 					["valid subdir"					dir := myhandler fileDirectory construct: portable_subdir.					dir ensureDirectory.					filename_on_wiki := dir construct: filename_string.					filename_on_wiki definitelyExists 						ifTrue: [self upload_failed: response wikiname: wikiname]						ifFalse: 							[output := filename_on_wiki writeStream									binary;									yourself.							[inputStream := input valueAsStream.							inputStream species = EncodedStream 								ifTrue: [inputStream binary.].							output nextPutAll: inputStream contents] ensure: [output close].							"	output flush;	close."							FlatFileWiki 								logUpload: wikiname								subdir: subdir asPortableFilenameString								filename: filename_on_wiki tail asString								size: filename_on_wiki fileSize								from: request remoteAddr.							self 								upload_successfull: response								wikiname: wikiname								dir: filename_on_wiki head								file: filename_on_wiki tail								size: filename_on_wiki fileSize.							^#nothing]]				ifFalse: 					["invalid subdir"					response 						write: '&lt;html&gt;&lt;body&gt;&lt;font color=red&gt;Hey, are you a 13 year old Script Kiddy? This subdir is not allowed!&lt;/font&gt;&lt;/body&gt;&lt;/html&gt;']]</body><body package="WikiWorks4SSP">upload_step2_navbar: response wikiname: wikiname response write: '&lt;table width="100%" cellpadding="0" cellspacing="2" bgcolor="#FF7744"&gt;&lt;tr&gt;&lt;td &gt;&lt;font face="Arial" &gt;&lt;a href="upload.ssp?wikiname=' , wikiname encodedHTTP , '"&gt;Back to Upload&lt;/a&gt;&lt;/font&gt;&lt;/td&gt;&lt;td &gt;&lt;font face="Arial" &gt;&lt;a href="page.ssp?wikiname=', wikiname encodedHTTP , '"&gt;Back to Top&lt;/a&gt;&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;'</body><body package="WikiWorks4SSP">upload_successfull: response wikiname: wikiname dir: dir file: file size: size 	response 		redirectTo: 'upload_finished.ssp?wikiname=' , wikiname encodedHTTP 				, '&amp;dir=' , dir encodedHTTP 				, '&amp;file=' , file encodedHTTP 				, '&amp;size=' , size printString encodedHTTP</body><body package="WikiWorks4SSP">writeErrorAnswer: response 	| filename aStream |	filename := 'ssp' , Filename separator asSymbol, 'error.html'.	aStream := filename asFilename readStream.	[response write: aStream contents] ensure: [aStream close]</body></methods><methods><class-id>WikiWorks.CompositeWiki</class-id> <category>accessing</category><body package="WikiWorks4SSP">addComponent: aFlatFileWiki		components		at: aFlatFileWiki name		put: aFlatFileWiki.	^aFlatFileWiki</body><body package="WikiWorks4SSP">base	^base</body><body package="WikiWorks4SSP">base: anObject	base := anObject</body><body package="WikiWorks4SSP">componentNamed: key 	^self componentNamed: key ifAbsent: [^#no_such_wiki]</body><body package="WikiWorks4SSP">componentNamed: key ifAbsent: aBlock 	^components at: key ifAbsent: aBlock</body><body package="WikiWorks4SSP">components	^components</body><body package="WikiWorks4SSP">configureFileResponder	| r wikisWithFileserver dir fileResponder resolverPath server |	server := self getServer.	wikisWithFileserver := (self components select: [:each | each fileServer]) asSet.	wikisWithFileserver		ifNotNil: 			[wikisWithFileserver do: 					[:aFlatFileWiki |					dir := aFlatFileWiki fileDirectory.					resolverPath := serverType = 'WaveIPRequestBroker'								ifTrue: [(aFlatFileWiki name copy replaceAll: Character space with: $+) , '_dl']								ifFalse: [aFlatFileWiki name , '_dl'].					fileResponder := WikiWorks.FileResponder4ssp new defaultDir: dir.					r := server service resolver.					r atPath: resolverPath put: fileResponder]]</body><body package="WikiWorks4SSP">configureFrom: conf 	self components do:[:each | each release].	self initialize.	self		port: (conf at: 'port' ifAbsent: ['8008']);		serverType: (conf at: 'serverType' ifAbsent: ['WaveHTTPRequestBroker']);		name: (conf at: 'name' ifAbsent: ['my nameless wiki']);		addUser: (conf at: 'write_user' ifAbsent: [nil])			password: (conf at: 'write_user_password' ifAbsent: [nil])			type: 'writeUser';		addUser: (conf at: 'read_user' ifAbsent: [nil])			password: (conf at: 'read_user_password' ifAbsent: [nil])			type: 'readUser';		readableForPublic: (conf at: 'readableForPublic' ifAbsent: ['false']);		cssUrl: (conf at: 'css' ifAbsent: [nil]);		base: (conf at: 'base' ifAbsent: [nil]);		host: (conf at: 'host' ifAbsent: [nil]).	self postInitialize</body><body package="WikiWorks4SSP">configureWikiRedirectors	| r dir redirector resolverPath server |	server := self getServer.	self components do: 			[:aWiki |			dir := aWiki name.			resolverPath := serverType = 'WaveIPRequestBroker' ifTrue: [dir copy replaceAll: Character space with: $+] ifFalse: [dir].			redirector := (WikiWorks.WikiRedirectionAnswer new)						theWikiname: dir;						reasonString: 'redirection because of new syntax in URL';						status: 302.			r := server service resolver.			r atPath: resolverPath put: redirector]</body><body package="WikiWorks4SSP">cssUrl	^cssUrl ifNil: ['css/style.css']</body><body package="WikiWorks4SSP">cssUrl: anObject	cssUrl := anObject</body><body package="WikiWorks4SSP">cssUrlFor: aWikiName 	| wiki |	^(wiki := self componentNamed: aWikiName ifAbsent: [nil]) isNil 		ifTrue: [self cssUrl]		ifFalse: [wiki cssUrl]</body><body package="WikiWorks4SSP">getServer	| serverList |	serverList := VisualWave.WaveHTTPRequestBroker allServers 				select: [:each | self port = each port].	serverList size = 1 		ifTrue: [  ^  serverList first ].	serverList := serverList select: [:server | server isRunning ].	serverList size = 1 		ifTrue: [  ^  serverList first ].	self error: 'No server found'.</body><body package="WikiWorks4SSP">host	^host</body><body package="WikiWorks4SSP">host: anObject	host := anObject</body><body package="WikiWorks4SSP">name	^name</body><body package="WikiWorks4SSP">name: aString 	name := aString</body><body package="WikiWorks4SSP">port	^port</body><body package="WikiWorks4SSP">port: aString 	port := aString asNumber</body><body package="WikiWorks4SSP">readableForPublic	^readableForPublic</body><body package="WikiWorks4SSP">readableForPublic: aString 	readableForPublic := aString isNil 				ifTrue: [false]				ifFalse: [(aString sameAs: 'true') ifTrue: [true] ifFalse: [false]]</body><body package="WikiWorks4SSP">removeComponentNamed: key	| c |	c := self componentNamed: key.	c isNil ifTrue: [^nil].	components removeKey: key.	^c</body><body package="WikiWorks4SSP">serverType	^serverType</body><body package="WikiWorks4SSP">serverType: aString 	serverType := (aString sameAs: 'WaveIPRequestBroker') 				ifTrue: ['WaveIPRequestBroker']				ifFalse: ['WaveHTTPRequestBroker']</body></methods><methods><class-id>WikiWorks.CompositeWiki</class-id> <category>authorization</category><body package="WikiWorks4SSP">authorizeRequest: aRequest for: aWikiName 	| aFileWiki UsernamePasswordArray |	UsernamePasswordArray := self 				extractUsernameAndPasswordFromRequest: aRequest.	aFileWiki := self componentNamed: aWikiName ifAbsent: [nil].	aFileWiki ifNil: [^#no_such_wiki].	^aFileWiki checkOneWiki: UsernamePasswordArray</body><body package="WikiWorks4SSP">checkForValidLogin: aRequest 	| UsernamePasswordArray |	UsernamePasswordArray := self 				extractUsernameAndPasswordFromRequest: aRequest.	(self validLogin: UsernamePasswordArray) ifTrue: [^true].	^self components 		anySatisfy: [:each | each validLogin: UsernamePasswordArray]</body><body package="WikiWorks4SSP">extractUsernameAndPasswordFromRequest: aRequest 	| authorizationHelper authorization user password |	authorizationHelper := VisualWave.WebSiteAuthorizationPolicy new.	authorization := authorizationHelper 				extractAuthorizationFromRequest: aRequest.	user := authorizationHelper extractUserNameFrom: authorization.	password := authorizationHelper extractPasswordFrom: authorization.	^Array with: user with: password</body><body package="WikiWorks4SSP">isValidReadUser: nameString password: passwordString 	readUsers isNil 		ifTrue: [^false]		ifFalse: 			[^(readUsers at: (self concat: nameString password: passwordString)				ifAbsent: [#rien]) = nameString]</body><body package="WikiWorks4SSP">isValidWriteUser: nameString password: passwordString 	writeUsers isNil 		ifTrue: [^false]		ifFalse: 			[^(writeUsers at: (self concat: nameString password: passwordString)				ifAbsent: [#rien]) = nameString]</body><body package="WikiWorks4SSP">listAllWikisWithAccessFor: aRequest 	| accessDict UsernamePasswordArray |	UsernamePasswordArray := self 				extractUsernameAndPasswordFromRequest: aRequest.	accessDict := Dictionary new.	self components do: 			[:each | 			(each checkOneWiki: UsernamePasswordArray) = #write_access 				ifTrue: [accessDict at: each name put: #write_access]				ifFalse: 					[(each checkOneWiki: UsernamePasswordArray) = #read_only 						ifTrue: [accessDict at: each name put: #read_only]]].	^accessDict</body><body package="WikiWorks4SSP">validLogin: UsernamePasswordArray 	| username password |	username := UsernamePasswordArray at: 1.	password := UsernamePasswordArray at: 2.	^(writeUsers isNil not 		and: [self isValidWriteUser: username password: password]) or: 				[readUsers isNil not 					and: [self isValidReadUser: username password: password]]</body></methods><methods><class-id>WikiWorks.CompositeWiki</class-id> <category>userhandling</category><body package="WikiWorks4SSP">addUser: nameString password: passwordString type: aUserType 	nameString isNil | passwordString isNil ifTrue: [^self].	readUsers ifNil: [readUsers := Dictionary new].	writeUsers ifNil: [writeUsers := Dictionary new].	aUserType = 'writeUser' 		ifTrue: 			[writeUsers at: (self concat: nameString password: passwordString)				put: nameString].	aUserType = 'readUser' 		ifTrue: 			[readUsers at: (self concat: nameString password: passwordString)				put: nameString]</body><body package="WikiWorks4SSP">concat: nameString password: passwordString 	(nameString isNil or: [passwordString isNil]) ifTrue: [^nil].	^(nameString , ':' , passwordString) asByteString</body></methods><methods><class-id>WikiWorks.CompositeWiki</class-id> <category>tools</category><body package="WikiWorks4SSP">fileNameForPath: aPathString	"quick and dirty from Alex"	| coll1 coll2 |	^ aPathString isEmpty 		ifTrue: ['']		ifFalse: [			coll1 := aPathString tokensBasedOn: $\.			coll2 := aPathString tokensBasedOn: $/.			coll1 size &gt; coll2 size 					ifTrue: [coll1 last] 				ifFalse: [coll2 last]].</body></methods><methods><class-id>WikiWorks.CompositeWiki</class-id> <category>encoding</category><body package="WikiWorks4SSP">encodeForSave: aString	^ aString</body></methods><methods><class-id>WikiWorks.CompositeWiki</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">initialize	components := Dictionary new.	readUsers := nil.	writeUsers := nil.	base := nil.	host := nil</body><body package="WikiWorks4SSP">postInitialize	| aServer |	[self getServer ifNil: [self error: 'No Server found']] on: Error		do: 			[:ex | 			aServer := self serverType = 'WaveHTTPRequestBroker' 						ifTrue: [VisualWave.WaveHTTPRequestBroker newMinimal: port]						ifFalse: [VisualWave.WaveIPRequestBroker newMinimal: port].			aServer service trapErrors: true.			aServer hostname: host.			base ifNotNil: [aServer virtualDirectories: (base tokensBasedOn: $;)].			aServer start]</body></methods><methods><class-id>WikiWorks.CompositeWiki class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">new	^ super new initialize</body></methods><methods><class-id>WikiWorks.CompositeWiki class</class-id> <category>accessing</category><body package="WikiWorks4SSP">current	current ifNil: [current := self new].	^current</body><body package="WikiWorks4SSP">defaultConfiguration	| configurationFile |	configurationFile := 'wiki.ini'.	configurationFile asFilename definitelyExists ifFalse: [^nil].	^ConfigurationRegistry fromFileNamed: configurationFile</body><body package="WikiWorks4SSP">reset	^current := nil</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>pages</category><body package="WikiWorks4SSP">addPage: aPage 	aPage allTitles do: [:each | pages at: each asUppercase put: aPage].	self idForPage: aPage.	^aPage</body><body package="WikiWorks4SSP">changesFor: aDate 	| sc |	sc := SortedCollection new sortBlock: [:a :b | a timestamp &gt; b timestamp].	self 		latestPages do: [:each | each timestamp asDate = aDate ifTrue: [sc add: each]].	^sc</body><body package="WikiWorks4SSP">editorContentsForPageTitled: aString	| page |	page := self pageTitled: aString.	^EditPageRender4ssp renderPage: page inWiki: self</body><body package="WikiWorks4SSP">formattingPage	formattingPageTitle ifNil: [self formattingPageTitle: 'Wiki Syntax'].	^self pageTitled: formattingPageTitle</body><body package="WikiWorks4SSP">hasPageTitled: aString 	^(pages includesKey: aString asUppercase)</body><body package="WikiWorks4SSP">latestPages	^pages values asSet</body><body package="WikiWorks4SSP">pageTitled: aString 	^self pageTitled: aString ifAbsent: []</body><body package="WikiWorks4SSP">pageTitled: aString ifAbsent: aBlock 	^pages at: aString asUppercase ifAbsent: aBlock</body><body package="WikiWorks4SSP">pages	^pages</body><body package="WikiWorks4SSP">referencesFor: aString 	| matchString referringPages |	referringPages := SortedCollection sortBlock: [:a :b | a title &lt; b title].	matchString := aString.	matchString isEmpty ifFalse: [matchString := '*' , matchString , '*'].	self 		latestPages do: [:each | (each references: matchString) ifTrue: [referringPages add: each]].	^referringPages</body><body package="WikiWorks4SSP">rootPage	rootPageTitle ifNil: [self rootPageTitle: 'Home Page'].	^self pageTitled: rootPageTitle</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>accessing</category><body package="WikiWorks4SSP">cssUrl	^cssUrl ifNil: [CompositeWiki current cssUrl]</body><body package="WikiWorks4SSP">currentTitleOf: aString 	^(self pageTitled: aString) title</body><body package="WikiWorks4SSP">directory	^directory</body><body package="WikiWorks4SSP">directory: directoryName 	directory := directoryName asByteString asPortableFilenameString asFilename</body><body package="WikiWorks4SSP">fileDirectory	^directory construct: 'ATTACHMENT'</body><body package="WikiWorks4SSP">fileServer	^fileServer</body><body package="WikiWorks4SSP">fileServer: aString 	fileServer := aString isNil 				ifTrue: [false]				ifFalse: [(aString sameAs: 'true')]</body><body package="WikiWorks4SSP">formattingPageTitle: aString 	| formattingPage |	formattingPageTitle 		notNil: [pages removeKey: formattingPageTitle asUppercase].	formattingPageTitle := aString.	(self hasPageTitled: aString) ifTrue: [^self].	formattingPage := OriginalWikiPage new.	formattingPage title: formattingPageTitle.	formattingPage := formattingPage newContents: self defaultFormattingPage				by: formattingPage author.	self addPage: formattingPage.	self saveWikiFile</body><body package="WikiWorks4SSP">name: aString 	super name: aString.	self saveWikiFile</body><body package="WikiWorks4SSP">rootPageTitle	^self rootPage title</body><body package="WikiWorks4SSP">rootPageTitle: aString 	| rootPage |	rootPageTitle notNil: [pages removeKey: rootPageTitle asUppercase].	rootPageTitle := aString.	(self hasPageTitled: aString) ifTrue: [^self].	rootPage := OriginalWikiPage new.	rootPage title: rootPageTitle.	self addPage: rootPage.	self saveWikiFile</body><body package="WikiWorks4SSP">startDate	^(self rootPage versionAt: 0) timestamp asDate</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">initialize	pages := Dictionary new</body><body package="WikiWorks4SSP">postInitialize		self recoverWikiFile.	self recoverFiles.	self removeOldPagesContents</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>authorization</category><body package="WikiWorks4SSP">checkOneWiki: UsernamePasswordArray 	| username password |	username := UsernamePasswordArray at: 1.	password := UsernamePasswordArray at: 2.	(readUsers isNil and: [writeUsers isNil]) ifTrue: [^#write_access].	(self isValidWriteUser: username password: password) 		ifTrue: [^#write_access].	(CompositeWiki current isValidWriteUser: username password: password) 		ifTrue: [^#write_access].	(self isValidReadUser: username password: password) ifTrue: [^#read_only].	(CompositeWiki current isValidReadUser: username password: password) 		ifTrue: [^#read_only].	self readableForPublic ifTrue: [^#read_only].	CompositeWiki current readableForPublic ifTrue: [^#read_only].	^#not_allowed</body><body package="WikiWorks4SSP">isValidReadUser: nameString password: passwordString 	readUsers isNil 		ifTrue: [^true]		ifFalse: 			[^(readUsers at: (self concat: nameString password: passwordString)				ifAbsent: [#rien]) = nameString]</body><body package="WikiWorks4SSP">isValidWriteUser: nameString password: passwordString 	(writeUsers isNil and: [readUsers isNil not]) ifTrue: [^false].	^(writeUsers at: (self concat: nameString password: passwordString)		ifAbsent: [#rien]) = nameString</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>private-checking</category><body package="WikiWorks4SSP">checkDuplications: duplicationSet for: aDictionary and: aCollection match: matchBlock map: mapBlock error: errorString 	| map |	map := IdentityDictionary new.	duplicationSet do: 			[:each | 			| all |			all := IdentityDictionary new.			(aCollection 				collect: [:page | CollectionAdapter with: [:aBlock | page versionsDo: aBlock]]) 					do: 						[:page | 						page detect: (matchBlock value: each)							ifPresent: 								[:aPage | 								all at: page anyOne									put: (aDictionary select: (mapBlock value: each value: page))]].			all size &gt; 1 ifTrue: [map at: each put: all]].	map size = 0 ifTrue: [^self].	map inspect.	self error: errorString</body><body package="WikiWorks4SSP">checkTitles: aDictionary latests: aCollection 	| duplications |	duplications := Bag new.	aCollection do: [:each | duplications addAll: each allTitles].	self		checkDuplications: (duplications asSet select: [:each | (duplications occurrencesOf: each)					&gt; 1])		for: aDictionary		and: aCollection		match: [:each | [:v | each = v title]]		map: [:each :page | [:v | page includes: v]]		error: 'Duplicated titles detected!'</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>testing</category><body package="WikiWorks4SSP">hasFilenamed: aString		^[| filename | filename := (self fileDirectory construct: (aString copyReplaceAll: '/' with: (String with: Filename separator))).		filename isDirectory not and: [filename definitelyExists		and: [self fileServer]]]		on: OsInvalidArgumentsError , OsInaccessibleError		do: [:ex | false]</body><body package="WikiWorks4SSP">isNewPage: aWikiPage 	^self pages includes: aWikiPage</body><body package="WikiWorks4SSP">isOldPage: aWikiPage 	^(self isNewPage: aWikiPage) not</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>private-persistance</category><body package="WikiWorks4SSP">idForPage: aPage 	^idMap at: aPage ifAbsentPut: [self savePage: aPage]</body><body package="WikiWorks4SSP">savePage: aPage	"All subclasses have to implement this:"	^self subclassResponsibility</body><body package="WikiWorks4SSP">saveWikiFile	| ws |	ws := (directory construct: 'wiki.cnf') writeStream.		[name ifNil: [^self].	ws nextPutAll: name.	ws cr.	rootPageTitle ifNil: [^self].	ws nextPutAll: rootPageTitle.	ws cr.	formattingPageTitle ifNil: [^self].	ws nextPutAll: formattingPageTitle.	ws cr] 			ensure: [ws close]</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>private-recover</category><body package="WikiWorks4SSP">readContentsOfPage: aWikiPage	^self subclassResponsibility</body><body package="WikiWorks4SSP">readPagesInto: pageMap latests: latests 	^self subclassResponsibility</body><body package="WikiWorks4SSP">recoverFiles	"All subclasses have to implement this:"	^self subclassResponsibility</body><body package="WikiWorks4SSP">recoverWikiFile	| rs aFilename |	aFilename := directory construct: 'wiki.cnf'.	aFilename definitelyExists ifFalse: [^self].	rs := aFilename readStream.		[rs atEnd ifFalse: [name := rs nextLine].	rs atEnd ifFalse: [rootPageTitle := rs nextLine].	rs atEnd ifFalse: [formattingPageTitle := rs nextLine]] 			ensure: [rs close]</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>As yet unclassified</category><body package="WikiWorks4SSP">removeOldPagesContents	idMap keys do: [:page | (page canBeReleased and: [self isOldPage: page])			ifTrue: [page setContents: self]]</body></methods><methods><class-id>WikiWorks.Wiki</class-id> <category>defaults</category><body package="WikiWorks4SSP">defaultFormattingPage	^'The Wiki''s a place where anybody can edit anything. To do so just follow the &lt;U&gt;Edit this page&lt;/U&gt; link at the top or bottom of a page. The formatting rules are pretty simple:* Links are created by placing square brackets around the link name (e.g. [[aPageName]). If you need to create a [[ character, use two of them (e.g. "[[[["). You don''t need to double up the ] character unless you actually want to use it as part of the link name.* If you want to create a link to an "outside" source, just include the full internet protocol name (e.g. [[http://www.somesite.com] or [[mailto:someone@somewhere.com] or [[ftp://somesite.ftp]).* If you want a link (either internal or outside) by another name, then place both the desired name and the actual link target as a pair separated by the &gt; character (e.g. [[The Top &gt; Home Page] or [[me &gt; mailto:myname@myplace.com]).* If you want to create a link to an smb- or windows- share, just include the URL like this [[file.txt &gt; file:///\\\\somewhere\\share\\file.txt].Escape Rules:* escape [[ with: [[[[* escape \\ with: \\\\'</body></methods><methods><class-id>WikiWorks.Wiki class</class-id> <category>configuration</category><body package="WikiWorks4SSP">configurationSectionName	^'wiki'</body><body package="WikiWorks4SSP">configureFrom: conf 	| concreteWiki |	concreteWiki := self named: (conf at: 'name' ifAbsent: [name])				directory: (conf at: 'directory' ifAbsent: [name]).	concreteWiki		addUser: (conf at: 'write_user' ifAbsent: [nil])			password: (conf at: 'write_user_password' ifAbsent: [nil])			type: 'writeUser';		addUser: (conf at: 'read_user' ifAbsent: [nil])			password: (conf at: 'read_user_password' ifAbsent: [nil])			type: 'readUser';		readableForPublic: (conf at: 'readableForPublic' ifAbsent: ['false']);		fileServer: (conf at: 'fileserver' ifAbsent: ['false']);		cssUrl: (conf at: 'css' ifAbsent: [nil]).	(conf at: 'write_user2' ifAbsent: [nil]) ifNotNil: [:wUser2 |		concreteWiki addUser: wUser2			password: (conf at: 'write_user_password2' ifAbsent: [nil])			type: 'writeUser' ].	CompositeWiki current addComponent: concreteWiki.	concreteWiki postInitialize</body><body package="WikiWorks4SSP">installConfigureFrom: conf	"chooses the correct Wiki-type based on the storageType-option, if none given the default is a FlatFileWiki"	| storageType concreteWikiClass |	storageType := (conf at: 'storageType' ifAbsent: [FlatFileWiki storageType]) asSymbol.	concreteWikiClass := self subclasses detect: [:e | e storageType = storageType]				ifNone: [self error: 'Unknown storage type: ' , storageType].	concreteWikiClass configureFrom: conf</body><body package="WikiWorks4SSP">named: nameString directory: directoryName 	| aRequestHandler |	aRequestHandler := self new.	aRequestHandler directory: directoryName.	aRequestHandler fileDirectory ensureDirectory.	aRequestHandler name: nameString.	^aRequestHandler</body></methods><methods><class-id>WikiWorks.Wiki class</class-id> <category>updating</category><body package="WikiWorks4SSP">installSSPFiles	"self installSSPFiles"	| t targz tar |	(Filename defaultDirectory construct: 'ssp') definitelyExists 		ifTrue: [ 			(Dialog confirm: (#FilesExistContinueExtract &lt;&lt; #wikissp &gt;&gt;'Some or all files required by the Wiki already seem to exist.Do you want them to be overwritten?')) ifFalse: [ ^ self ]].	t := TGZArchiver new.	tar := 'wiki_supplementary.tar'.	targz := tar , '.gz'.	targz asFilename exists 		ifTrue: [t unzipFile: targz asFilename to: tar asFilename]		ifFalse: 			[| directory |			directory := PortableFilename 						fromComponents: #('$(VISUALWORKS)' 'contributed' 'Heeg' 'WikiWorks4SSP-Legacy').			t unzipFile: (directory asFilename construct: targz) to: tar asFilename].	t untarArchive: tar asFilename.	'logs' asFilename ensureDirectory.	'wiki' asFilename ensureDirectory.	tar asFilename exists ifTrue: [tar asFilename delete]</body><body package="WikiWorks4SSP">installSSPFilesAndInitialize	"self installSSPFiles"	self installSSPFiles.	self returnFromSnapshot</body><body package="WikiWorks4SSP">installSSPFilesAndInitializeKeepWiki	| fn fnsav |	fn := 'wiki.ini' asFilename.	fnsav := 'wiki.ini.old.' , self nextSavePostFix printString.	fn definitelyExists ifTrue: [fn copyTo: fnsav].	self installSSPFiles.	fnsav asFilename definitelyExists 		ifTrue: [fnsav asFilename copyTo: fn asString].	self returnFromSnapshot</body><body package="WikiWorks4SSP">nextSavePostFix	| s sold c |	s := 0.	sold := 0.	c := Filename defaultDirectory filenamesMatching: 'wiki.ini.old*'.	c isEmpty 		ifTrue: [^0]		ifFalse: 			[c do: 					[:each | 					s := (each asString tokensBasedOn: $.) last asNumber.					s &gt; sold ifTrue: [sold := s]]].	^sold + 1</body><body package="WikiWorks4SSP">returnFromSnapshot	"CompositeWiki reset.	self returnFromSnapshot"	| configuration |	configuration := CompositeWiki defaultConfiguration ifNil: [^self].	CompositeWiki current 		configureFrom: (configuration sectionNamed: 'server').	configuration sectionsNamed: self configurationSectionName		do: [:each | self installConfigureFrom: each].	CompositeWiki current configureFileResponder.	CompositeWiki current configureWikiRedirectors.	VisualWave.WebSiteConfiguration 			configureServer;			clearAndReconfigure.	VisualWave.WebSiteConfiguration globalConfiguration disableConfiguration.	Net.SimpleBody defaultCharsetEncoder: #'utf8'.</body><body package="WikiWorks4SSP">update: aSymbol 	aSymbol == #returnFromSnapshot ifFalse: [^self].	self returnFromSnapshot</body></methods><methods><class-id>WikiWorks.Wiki class</class-id> <category>loging</category><body package="WikiWorks4SSP">logMessage: aRequest page: aPageName 	| separator logfile wikinameEntity wikiname username |	separator := String with: Filename separator.	username := ((CompositeWiki current 				extractUsernameAndPasswordFromRequest: aRequest) at: 1) 				ifNil: ['nil'].	wikinameEntity := (aRequest anyParameterValueAt: 'wikiname').	wikiname := wikinameEntity parameterValueAsString.		logfile := ('logs' , separator , 'access.log') 				asFilename readAppendStream.	logfile		nextPutAll: Date today printString;		space;		nextPutAll: Time now printString;		space;		nextPutAll: wikiname , ': no rights for page: ' , aPageName , ' user: ' 					, username;		nextPutAll: ' FROM: ' , aRequest remoteAddr;		cr;		flush;		close</body><body package="WikiWorks4SSP">logUpload: wikiname subdir: subdir filename: filename size: size from: from	| separator logfile portable |	separator := String with: Filename separator.	logfile := (('logs' , separator , wikiname , '.log')				asFilename withEncoding: #utf8)				readAppendStream.	[logfile		nextPutAll: Date today printString;		space;		nextPutAll: Time now printString;		nextPutAll: ' UPLOAD: ';		nextPutAll: (portable := subdir asPortableFilenameString).	subdir notEmpty		ifTrue: 			[portable last = separator				ifFalse: [logfile nextPutAll: separator]].	logfile		nextPutAll: filename;		nextPutAll: ' SIZE: ' , size printString;		nextPutAll: ' FROM: ' , from;		cr;		flush]			ensure: [logfile close]</body></methods><methods><class-id>WikiWorks.IsamFileWiki</class-id> <category>private-persistance</category><body package="WikiWorks4SSP">isam		^isam		ifNil:			[directory ensureDirectory.			isam := Heeg.Isam.IsamCollection				on: (directory construct: name) asString				records: Heeg.Isam.WikiPageEntry				keys: #('Heeg.Isam.WikiPageKey')]</body><body package="WikiWorks4SSP">nextID	^iD := iD + 1</body><body package="WikiWorks4SSP">pageForId: anId 	^idMap keyAtValue: anId</body><body package="WikiWorks4SSP">savePage: aPage		| id |	id := self nextID.	aPage		storeOnIsam: self isam		under: self		id: id.	^id</body></methods><methods><class-id>WikiWorks.IsamFileWiki</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">activateFrom: aFlatFileWiki		| aCol |	self  deleteIsam.	aCol := SortedCollection sortBlock:[:a :b | a key &lt;= b key].	(aFlatFileWiki basicIdMap) keysAndValuesDo: [:page :id | aCol add: id -&gt; page].	aCol do: [:each | self addPage: each value].</body><body package="WikiWorks4SSP">convertFlatFileWiki: aFlatFileWiki		self initialize.	readUsers := aFlatFileWiki readUsers.	writeUsers := aFlatFileWiki writeUsers.	directory := aFlatFileWiki directory.	components := aFlatFileWiki components.	name := aFlatFileWiki name.	readableForPublic := aFlatFileWiki readableForPublic.	serverType := aFlatFileWiki serverType.	port := aFlatFileWiki port.	cssUrl := aFlatFileWiki basicCssUrl.	base := aFlatFileWiki base.	host := aFlatFileWiki host.	fileServer := aFlatFileWiki fileServer.	self activateFrom: aFlatFileWiki</body><body package="WikiWorks4SSP">initialize	super initialize.	iD := -1.	idMap := IdentityDictionary new.	fileServer := false.	readUsers := nil.	writeUsers := nil</body><body package="WikiWorks4SSP">release	super release.	isam saveTo: (directory construct: name) asString.	self isam close.</body></methods><methods><class-id>WikiWorks.IsamFileWiki</class-id> <category>private-ceanup</category><body package="WikiWorks4SSP">deleteIsam		| file |	file := (directory / (name , '.dat')).	file exists ifTrue:[file delete].</body></methods><methods><class-id>WikiWorks.IsamFileWiki</class-id> <category>printing</category><body package="WikiWorks4SSP">printOn: aStream	aStream nextPutAll: (self class printString).	aStream nextPutAll: (' (',self name,')')</body></methods><methods><class-id>WikiWorks.IsamFileWiki</class-id> <category>private-recover</category><body package="WikiWorks4SSP">readContentsOfPage: aWikiPage	| contents fileNo key |	contents := ''.	fileNo := idMap at: aWikiPage ifAbsent: [^contents].	key := (isam indexKey)				id: fileNo;				recordPosition: nil;				yourself.	contents := (isam recordAt: key) datum.	^contents</body><body package="WikiWorks4SSP">readPagesInto: pageMap latests: latestPages	| page |	self isam recordsDo: [:each |		page := each asWikiPageForWiki: self.		idMap at: page put: each id.		iD:= iD max: each id.		pageMap at: each id put: page.		latestPages add: page. 		latestPages remove: page previousVersion ifAbsent: []].</body><body package="WikiWorks4SSP">recoverFiles	| pageMap latests |	pageMap := IdentityDictionary new.	latests := OrderedCollection new.	idMap := IdentityDictionary new.	self readPagesInto: pageMap latests: latests.	self checkTitles: pageMap latests: latests.	latests do: [:page | super addPage: page]</body></methods><methods><class-id>WikiWorks.IsamFileWiki</class-id> <category>pages</category><body package="WikiWorks4SSP">addPage: aPage 	super addPage: aPage.	self release.	^aPage</body></methods><methods><class-id>WikiWorks.IsamFileWiki class</class-id> <category>import</category><body package="WikiWorks4SSP">convertFlatFileWiki: aFlatFileWiki	^self basicNew convertFlatFileWiki: aFlatFileWiki.</body><body package="WikiWorks4SSP">convertInstallFlatFileWiki: aFlatFileWiki	"Converts the given FlatFileWiki in an IsamFileWiki, removes aFlatFileWiki from the current CompositeWiki and	installs the new one instead.	Converting flat file wiki 'WikiA' to the new storage type is easy:		oldWiki := CompositeWiki current componentNamed: 'WikiA'.		newWiki := self convertInstallFlatFileWiki: oldWiki.	Please remember to manualy change the the configuration of 'WikiA' in the wiki.ini-File accordingly (add a line: storageType=isamFile)	to ensure a correct start-up."	| inst |	inst := self convertFlatFileWiki: aFlatFileWiki.	CompositeWiki current removeComponentNamed: aFlatFileWiki name.	CompositeWiki current addComponent: inst.	aFlatFileWiki release.	^inst</body></methods><methods><class-id>WikiWorks.IsamFileWiki class</class-id> <category>accessing</category><body package="WikiWorks4SSP">storageType	^#isamFile</body></methods><methods><class-id>VisualWave.IM_ApplicationWWWFormUrlEncoded</class-id> <category>testing</category><body package="WikiWorks4SSP">hasKey: aKey	^self nameValueDictionary includesKey: aKey</body></methods><methods><class-id>VisualWave.IM_ApplicationWWWFormUrlEncoded</class-id> <category>accessing</category><body package="WikiWorks4SSP">allValuesAt: aName	"Return all values (an OrderedCollection) associated with a given form data field name"	^(self nameValueDictionary at: aName ifAbsent: [^nil]).</body><body package="WikiWorks4SSP">at: aName ifAbsent: aBlock		^(self nameValueDictionary at: aName ifAbsent: [^aBlock value]) asArray first.</body><body package="WikiWorks4SSP">at: aString put: anObject		orderedNameValues add: (aString-&gt;anObject).	(self nameValueDictionary at: aString ifAbsentPut: [OrderedCollection new]) add: anObject.</body><body package="WikiWorks4SSP">initializeCharsetEncoder	| charset |	charset := headers		ifNil: [nil]		ifNotNil:			[headers				valueAt: 'content-type'				parameterNamed: 'charset'].	(charset isNil and: [request notNil]) ifTrue: [		charset := request encoding ].	charsetEncoder := (StreamEncoder new: (charset ifNil: [self defaultCharset])).</body><body package="WikiWorks4SSP">keys	^self nameValueDictionary keys.</body><body package="WikiWorks4SSP">nameValueDictionary	^nameValueDictionary ifNil: [		self decodeFormDataOver: dataStream. 		nameValueDictionary]</body><body package="WikiWorks4SSP">request	^ request</body><body package="WikiWorks4SSP">request: aHttpRequest	request := aHttpRequest.</body><body package="WikiWorks4SSP">valueAt: aName	"Return just one of the form data field values at the given field name"	^(self nameValueDictionary at: aName ifAbsent: [^nil]) asArray first.</body></methods><methods><class-id>VisualWave.IM_ApplicationWWWFormUrlEncoded</class-id> <category>reading</category><body package="WikiWorks4SSP">dataOver: aStream separator: sepChar	"name values pairs from aStream assuming the data separator is sepChar."	nameValueDictionary := Dictionary new.	orderedNameValues := Dictionary new.	aStream ifNil: [^self].	[aStream atEnd] whileFalse: 			[| nameAndValue name value association |			nameAndValue := (aStream upTo: sepChar) readStream.			name := nameAndValue upTo: $=.			value := nameAndValue upToEnd.			aStream peekFor: Character space.	"eat space if found (e.g., in cookies)"			association := name -&gt; value.			orderedNameValues add: association.			(nameValueDictionary at: name ifAbsentPut: [OrderedCollection new]) add: value]</body><body package="WikiWorks4SSP">queryDataOver: aStream	"Assuming aStream includes x-ww-form-url-encoded style data, from its current position to finish, this method will properly populate this instance with a representation of that form data."	charsetEncoder == #uninitialized ifTrue: [charsetEncoder := StreamEncoder new: #'utf-8'].	self dataOver: aStream separator: $&amp;</body><body package="WikiWorks4SSP">receiveEntityOver: aStream from: aHttpRequest	"Assumed stream is positioned just before entity bytes. Headers are already established; read next 'Content-length' bytes or until end."	self request: aHttpRequest.	^ self receiveEntityOver: aStream</body></methods><methods><class-id>WikiWorks.TokenDifference</class-id> <category>private-process</category><body package="WikiWorks4SSP">added	results add: #added -&gt; (new at: newPos).	^newPos := newPos + 1</body><body package="WikiWorks4SSP">compareTokens	[oldPos &lt;= old size and: [newPos &lt;= new size]] whileTrue: 			[| offset |			(new at: newPos) = (old at: oldPos) 				ifTrue: [self same]				ifFalse: 					[offset := 1.										[offset &gt; 50 or: 							[oldPos &gt;= old size or: 									[newPos + offset &gt;= new size or: 											[(new at: newPos + offset) = (old at: oldPos) 												and: [(new at: newPos + offset + 1) = (old at: oldPos + 1)]]]]] 							whileFalse: [offset := offset + 1].					(offset &gt; 50 or: [newPos + offset &gt;= new size]) 						ifTrue: [self deleted]						ifFalse: [self added]]]</body><body package="WikiWorks4SSP">deleted	results add: #deleted -&gt; (old at: oldPos).	^oldPos := oldPos + 1</body><body package="WikiWorks4SSP">initScan	results := OrderedCollection new: old size.	newPos := 1.	oldPos := 1</body><body package="WikiWorks4SSP">maybeScan	(old isNil or: [new isNil]) ifFalse: [self scan]</body><body package="WikiWorks4SSP">processTails	[newPos &gt; new size] whileFalse: [self added].	[oldPos &gt; old size] whileFalse: [self deleted]</body><body package="WikiWorks4SSP">same	results add: #same -&gt; (new at: newPos).	newPos := newPos + 1.	^oldPos := oldPos + 1</body><body package="WikiWorks4SSP">scan	self initScan.	self compareTokens.	self processTails</body></methods><methods><class-id>WikiWorks.TokenDifference</class-id> <category>accessing</category><body package="WikiWorks4SSP">new: anObject 	new := anObject.	self maybeScan</body><body package="WikiWorks4SSP">old: anObject 	old := anObject.	self maybeScan</body><body package="WikiWorks4SSP">results	^results</body></methods><methods><class-id>WikiWorks.TokenDifference</class-id> <category>accessing-debugging</category><body package="WikiWorks4SSP">emphasisFor: anAssoc 	anAssoc key == #same ifTrue: [^nil].	anAssoc key == #added ifTrue: [^Array with: #bold with: #underline].	anAssoc key == #deleted 		ifTrue: [^Array with: #color -&gt; ColorValue red with: #italic]</body><body package="WikiWorks4SSP">resultsText	| ts |	ts := TextStream on: String new.	results do: 			[:each | 			ts emphasis: (self emphasisFor: each).			ts nextPutAll: each value]		separatedBy: [ts space].	^ts contents</body></methods><methods><class-id>Core.HtmlEncoder</class-id> <category>accessing</category><body package="WikiWorks4SSP">nextFrom: aStream	" *** This method was defined by StreamEncoder as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="WikiWorks4SSP">nextPut: aCharacter on: aStream	" *** This method was defined by StreamEncoder as a subclass responsibility.	Replace its body with a proper implementation. *** "		| value |	(value := aCharacter asInteger) &gt; 127 		ifTrue: [ self nextPutUnicdeValue: value on: aStream ]		ifFalse: [ aStream nextPut: aCharacter ]</body><body package="WikiWorks4SSP">nextPutUnicdeValue: anInteger on: aStream	aStream nextPutAll: '&amp;#', anInteger printString,';'</body></methods><methods><class-id>Core.HtmlEncoder</class-id> <category>querying</category><body package="WikiWorks4SSP">characterSize: char	" *** This method was defined by StreamEncoder as a subclass responsibility.	Replace its body with a proper implementation. *** "	^ 1</body></methods><methods><class-id>Core.HtmlEncoder class</class-id> <category>accessing</category><body package="WikiWorks4SSP">streamEncodingType	^nil</body></methods><methods><class-id>Heeg.Isam.WikiPageEntry</class-id> <category>accessing</category><body package="WikiWorks4SSP">author	"Return the named field"	^ self at: 4</body><body package="WikiWorks4SSP">author: object	"Enter new value for the field if it's valid"	((self class types at: 4) check: object)		ifFalse: [^ self error: 'Invalid field'].	^self at: 4 put: object</body><body package="WikiWorks4SSP">contents	"Return the contents field"	^ self at: 6</body><body package="WikiWorks4SSP">datum	"Return the named field"	^ self at: 6</body><body package="WikiWorks4SSP">datum: object	"Enter new value for the field if it's valid"	((self class types at: 6) check: object)		ifFalse: [^ self error: 'Invalid field'].	^self at: 6 put: object</body><body package="WikiWorks4SSP">id	"Return the named field"	^ self at: 1</body><body package="WikiWorks4SSP">id: object	"Enter new value for the field if it's valid"	((self class types at: 1) check: object)		ifFalse: [^ self error: 'Invalid field'].	^self at: 1 put: object</body><body package="WikiWorks4SSP">pageClass	"Return the named field"	^ self at: 2</body><body package="WikiWorks4SSP">pageClass: object	"Enter new value for the field if it's valid"	((self class types at: 2) check: object)		ifFalse: [^ self error: 'Invalid field'].	^self at: 2 put: object</body><body package="WikiWorks4SSP">previousVersion	"Return the named field"	^ self at: 3</body><body package="WikiWorks4SSP">previousVersion: object	"Enter new value for the field if it's valid"	((self class types at: 3) check: object)		ifFalse: [^ self error: 'Invalid field'].	^self at: 3 put: object</body><body package="WikiWorks4SSP">timestamp	"Return the named field"	^ self at: 5</body><body package="WikiWorks4SSP">timestamp: object	"Enter new value for the field if it's valid"	((self class types at: 5) check: object)		ifFalse: [^ self error: 'Invalid field'].	^self at: 5 put: object</body></methods><methods><class-id>Heeg.Isam.WikiPageEntry</class-id> <category>converting</category><body package="WikiWorks4SSP">asWikiPageForWiki: aWiki	^ WikiWorks.WikiPage fromIsamEntry: self wiki: aWiki</body></methods><methods><class-id>Heeg.Isam.WikiPageEntry</class-id> <category>printing</category><body package="WikiWorks4SSP">printOn: stream	stream nextPutAll: self previousVersion printString.	stream nextPutAll: (' &lt; ',self pageClass,' id ',self id printString); cr.	stream nextPutAll: self timestamp printString; cr.	stream nextPutAll: self datum; cr.	^stream contents</body></methods><methods><class-id>Heeg.Isam.WikiPageKey</class-id> <category>accessing</category><body package="WikiWorks4SSP">author	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">author: ignored	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">datum	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">datum: ignored	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">id	"Return the named field"	^ self at: 1</body><body package="WikiWorks4SSP">id: object	"Enter new value for the field if it's valid"	((self class types at: 1) check: object)		ifFalse: [^ self error: 'Invalid field'].	^self at: 1 put: object</body><body package="WikiWorks4SSP">pageClass	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">pageClass: ignored	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">previousVersion	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">previousVersion: ignored	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">timestamp	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">timestamp: ignored	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">timestring	"This is a superclass field"	^ self shouldNotImplement</body><body package="WikiWorks4SSP">timestring: ignored	"This is a superclass field"	^ self shouldNotImplement</body></methods><methods><class-id>Heeg.Isam.WikiPageKey</class-id> <category>printing</category><body package="WikiWorks4SSP">printOn: stream	stream nextPutAll: 'a '		; nextPutAll: self class printString		; nextPutAll: ' ('		; nextPutAll: self id printString		; nextPut: $)		; cr.	^stream contents</body></methods><methods><class-id>VisualWave.HTTPRequest</class-id> <category>accessing</category><body package="WikiWorks4SSP">commonHTMLCharsets	| os lang |	os := self getOperationSystemFromHeader.	lang := self getLangFromHeader.	^ self class commonEncodingsForOS: os lang: lang.</body><body package="WikiWorks4SSP">encoder	^ encoder</body><body package="WikiWorks4SSP">encoder: anEncoder	encoder := anEncoder.</body><body package="WikiWorks4SSP">encoding	^ self encoder ifNil: [ nil ] ifNotNil: [:enc | encoder encoding ]</body><body package="WikiWorks4SSP">encodingTranslationFor: aCharset	| key |	key := aCharset asLowercase asSymbol.	^ self class encodingTranslations at: key ifAbsent: [ key ]</body><body package="WikiWorks4SSP">getCharsets	"get the charsets from the http header - if not found return all available encodings"	| charSets charsetDescsString charsetDescs descArray |	charSets := OrderedCollection new.	charsetDescsString := self httpHeaders headerAt: 'Accept-charset'.	charsetDescsString ifNil: [		^ self commonHTMLCharsets ].	charsetDescs := charsetDescsString value asArrayOfSubstringsSeparator: $,.	charsetDescs do: [:desc |		descArray := desc asArrayOfSubstringsSeparator: $;.		descArray first = '*' ifTrue: [ 			charSets addAll: StreamEncoder availableEncodings.			^ charSets ].		[ charSets addLast: (StreamEncoder new: (self encodingTranslationFor: descArray first)) encoding] on: Error do: [: ex | ex return ].		].	^ charSets</body><body package="WikiWorks4SSP">getEncodingFrom: aStream	| oldPos contents |	oldPos := aStream position. 	[ aStream reset.	[ contents := aStream next: oldPos. ] on: OsNeedRetryError do: [:ex |		ex resume ]."Only read up to the position - not further	 	or the socket accessor will block"	self encoder: (URLEncoder 		guessEncodingOf: contents readStream 		possibleEncodings: [ self getCharsets ]).	self encoder ifNil: [self encoder: (StreamEncoder new:#'iso-8859-1') ].	] ensure: [ aStream position: oldPos ]</body><body package="WikiWorks4SSP">getLangFromHeader	| agentString |	(agentString :=self httpHeaders headerAt: 'accept-language') 		ifNil: [ ^ #any ].	^ (agentString value asLowercase tokensBasedOn: $_) first asSymbol</body><body package="WikiWorks4SSP">getOperationSystemFromHeader	"http://de.selfhtml.org/diverses/clients.htm"	| agentString agentColl |	(agentString :=self httpHeaders headerAt: 'user-agent') ifNil: [ ^ #any ].	agentColl := agentString value asLowercase tokensBasedOnAnyOf: ' _(),;/'.	(agentColl contains: [:string | 		#('windows' 'win32' 'win16' 'win95' 'winnt' 'win2000' 'windows95' 'windows98' 'windows2000' 'windowsnt') includes: string])  		ifTrue: [ ^ #win32 ].	(agentColl contains: [:string | 		#('unix' 'linux' 'freebsd' 'netbsd' 'bsd' 'sunos') includes: string])  		ifTrue: [ ^ #unix ].	(agentColl contains: [:string | 		#('macintosh' 'mac') includes: string])  		ifTrue: [ ^ #mac ].	^ #any</body></methods><methods><class-id>VisualWave.HTTPRequest</class-id> <category>reading</category><body package="WikiWorks4SSP">readEntityFrom: aStream	entity := self class internetMediaInstantiator receiveOver: aStream withHeaders: entityHeaders from: self</body></methods><methods><class-id>VisualWave.HTTPRequest class</class-id> <category>accessing</category><body package="WikiWorks4SSP">commonEncodingsForOS: os lang: lang	| osDict |	EncodingsDict ifNil: [ self initializedCommonEncodings ].	osDict :=  EncodingsDict at: os asSymbol ifAbsent: [ EncodingsDict at: #any ].	^ (osDict at: lang asSymbol ifAbsent: [		osDict at: #any ]) copyWith: StreamEncoder availableEncodings</body><body package="WikiWorks4SSP">encodingTranslations	^ EncodingTranslations ifNil: [ 		self initializeEncodingTranslations ]</body></methods><methods><class-id>VisualWave.HTTPRequest class</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">initializeEncodingTranslations	^ EncodingTranslations := Dictionary new		at: #'unicode-1-1-utf7' put: #utf7;		at: #'unicode-1-1-utf8' put: #utf8;		yourself</body><body package="WikiWorks4SSP">initializedCommonEncodings 	| osDict |	EncodingsDict := Dictionary new.	"Windows systems"	osDict := Dictionary new.	EncodingsDict at: #win32 put: osDict.	osDict at: #de put: #(ms_cp_1252 utf8 utf16 #'iso8859_1' ansi ascii).	osDict at: #en put: #(ms_cp_1252 #'iso8859_1' ansi ascii utf8 utf16).	osDict at: #ru put: #(ms_cp_1251 #'iso8859_5' utf8 utf16).	osDict at: #any put: #(#'iso8859_1' utf8 utf16).	"unix like systems"	osDict := Dictionary new.	EncodingsDict at: #unix put: osDict.	osDict at: #de put: #(#'iso8859_1' utf8 utf16 ansi ascii).	osDict at: #en put: #(#'iso8859_1' ansi ascii utf8 utf16).	osDict at: #ru put: #(#'iso8859_5' utf8 utf16).	osDict at: #any put: #(#'iso8859_1' utf8 utf16).	"unknown operating system"	osDict := Dictionary new.	EncodingsDict at: #any put: osDict.	osDict at: #de put: #(#'iso8859_1' utf8 utf16 ansi ascii).	osDict at: #en put: #(#'iso8859_1' ansi ascii utf8 utf16).	osDict at: #ru put: #(#'iso8859_5' utf8 utf16).	osDict at: #any put: #(#'iso8859_1' utf8 utf16).</body></methods><methods><class-id>WikiWorks.VersionRender4ssp</class-id> <category>accessing</category><body package="WikiWorks4SSP">page	^page versionAt: version</body><body package="WikiWorks4SSP">pageVersion	^version</body></methods><methods><class-id>WikiWorks.VersionRender4ssp</class-id> <category>testing</category><body package="WikiWorks4SSP">isLatestPage	^version = page versionNumber</body></methods><methods><class-id>WikiWorks.VersionRender4ssp</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">request: aPage version: aVersion in: aFlatFileWiki 	super request: aPage in: aFlatFileWiki.	version := (aVersion asNumber max: 0) min: page versionNumber.	aVersion asNumber = 0 ifTrue: [version := page versionNumber]</body></methods><methods><class-id>WikiWorks.VersionRender4ssp class</class-id> <category>4ssp</category><body package="WikiWorks4SSP">request: aPage version: aVersion in: aFlatFileWiki 	^self new 		request: aPage		version: aVersion		in: aFlatFileWiki</body></methods><methods><class-id>WikiWorks.OriginalWikiPage</class-id> <category>accessing</category><body package="WikiWorks4SSP">allTitlesInto: aCollection 	aCollection add: title</body><body package="WikiWorks4SSP">contents	"Writes a removable title and back link. These can be edited out."	| ws |	ws := (String new: 50) writeStream.	ws		nextPutAll: 'Describe ';		nextPutAll: self title;		nextPutAll: ' here....'.	^ws contents</body><body package="WikiWorks4SSP">firstVersion	^ self</body><body package="WikiWorks4SSP">previousVersion	^ nil</body><body package="WikiWorks4SSP">tabularHistoricalSynopsis	^'Created'</body><body package="WikiWorks4SSP">title	^title ifNil: [title := 'Home Page']</body><body package="WikiWorks4SSP">title: aString 	^title := aString</body><body package="WikiWorks4SSP">type	^  #original</body><body package="WikiWorks4SSP">versionNumber	^0</body><body package="WikiWorks4SSP">versionsDo: aBlock 	aBlock value: self</body><body package="WikiWorks4SSP">versionsReverseDo: aBlock 	aBlock value: self</body></methods><methods><class-id>WikiWorks.OriginalWikiPage</class-id> <category>testing</category><body package="WikiWorks4SSP">isOriginal	^true</body></methods><methods><class-id>WikiWorks.OriginalWikiPage</class-id> <category>flat file</category><body package="WikiWorks4SSP">saveToFile: aFileStream under: aWiki 	super saveToFile: aFileStream under: aWiki.	aFileStream nextPutAll: title</body><body package="WikiWorks4SSP">specificData: aString 	self title: aString</body></methods><methods><class-id>WikiWorks.OriginalWikiPage</class-id> <category>isam</category><body package="WikiWorks4SSP">asIsamEntryId: id wiki: aWiki	^ (super asIsamEntryId: id wiki: aWiki)		previousVersion: 0;		datum: title;		yourself</body><body package="WikiWorks4SSP">fromIsamEntry: isamEntry wiki: wiki		super fromIsamEntry: isamEntry wiki: wiki.	self title: isamEntry datum.</body></methods><methods><class-id>WikiWorks.WikiRedirectionAnswer</class-id> <category>accessing</category><body package="WikiWorks4SSP">theWikiname	^theWikiname</body><body package="WikiWorks4SSP">theWikiname: anObject	theWikiname := anObject</body></methods><methods><class-id>WikiWorks.WikiRedirectionAnswer</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>WikiWorks.WikiRedirectionAnswer</class-id> <category>sending</category><body package="WikiWorks4SSP">sendCGIOver: aStream for: aWebRequest 	"Write self out to stream, with appropriate CGI/1.1 headers"	"translates old syntax in URL to new syntax "	"http://hostname/mywiki/mypage --&gt; http://hostname/page.ssp?wikiname=mywiki&amp;pagename=mypage"	"redirects user to new URL"	| pagename |	aWebRequest unconsumedPath isEmpty 		ifTrue: [self uriString: 'page.ssp?wikiname=' , self theWikiname encodedHTTP]		ifFalse: 			[pagename := aWebRequest unconsumedPath first.			pagename = 'page.ssp' 				ifTrue: 					[self uriString: '../page.ssp?wikiname=' , self theWikiname encodedHTTP]				ifFalse: 					[self 						uriString: '../page.ssp?wikiname=' , self theWikiname encodedHTTP 								, '&amp;pagename=' , pagename]].	aWebRequest shouldWriteHeaders ifTrue: [self sendCGIHeadersOver: aStream].	aStream crlf.	self sendEntityOver: aStream.	aStream commit</body><body package="WikiWorks4SSP">sendHTTPOver: aStream forServer: anHTTPServer forRequest: aWebRequest 	"translates old syntax in URL to new syntax "	"http://hostname/mywiki/mypage --&gt; http://hostname/page.ssp?wikiname=mywiki&amp;pagename=mypage"	"redirects user to new URL"	| pagename |	aWebRequest unconsumedPath isEmpty 		ifTrue: [self uriString: 'page.ssp?wikiname=' , self theWikiname encodedHTTP]		ifFalse: 			[pagename := aWebRequest unconsumedPath first.			pagename = 'page.ssp' 				ifTrue: 					[self uriString: '../page.ssp?wikiname=' , self theWikiname encodedHTTP]				ifFalse: 					[self 						uriString: '../page.ssp?wikiname=' , self theWikiname encodedHTTP 								, '&amp;pagename=' , pagename encodedHTTP]].	aWebRequest shouldWriteHeaders 		ifTrue: 			[self sendHTTPHeadersOver: aStream forServer: anHTTPServer.			self sendHTTPEntityHeadersOver: aStream.			aStream crlf].	self sendEntityOver: aStream.	aStream commit</body></methods><methods><class-id>WikiWorks.WikiWorks4SSPSystem</class-id> <category>default actions</category><body package="WikiWorks4SSP">pauseAction	self tearDown</body><body package="WikiWorks4SSP">resumeAction	self setUp</body><body package="WikiWorks4SSP">setUp	Wiki returnFromSnapshot</body><body package="WikiWorks4SSP">tearDown	CompositeWiki current components do: [:each | each release].	CompositeWiki reset.</body></methods><methods><class-id>WikiWorks.WikiWorks4SSPSystem</class-id> <category>prerequisites</category><body package="WikiWorks4SSP">prerequisiteSystems	^Array with: TimerSystem with: RuntimeSystem</body></methods><methods><class-id>WikiWorks.EditPageRender4ssp</class-id> <category>parsing</category><body package="WikiWorks4SSP">processEscape	self addCurrentChar.	super processEscape.</body><body package="WikiWorks4SSP">processLeftBracket	"left brackets [ are not subtitued for the editor"	self addCurrentChar</body><body package="WikiWorks4SSP">renderPage	myReplyStream := String new writeStream.	self resetParsingStates.	contentStream := self buildContents readStream.	[contentStream atEnd] whileFalse: 			[self getNextChar.			self processCurrentChar].	lastChar := currentChar := Character cr.	self processCurrentChar.	^myReplyStream contents</body></methods><methods><class-id>WikiWorks.EditPageRender4ssp class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">renderPage: aPage inWiki: aWiki	| renderer |	renderer := self request: aPage in: aWiki.	^renderer renderPage</body></methods><methods><class-id>WikiWorks.RenamedWikiPage</class-id> <category>accessing</category><body package="WikiWorks4SSP">allTitlesInto: aCollection 	aCollection add: title.	super allTitlesInto: aCollection</body><body package="WikiWorks4SSP">tabularHistoricalSynopsis	^'Renamed'</body><body package="WikiWorks4SSP">title	^title</body><body package="WikiWorks4SSP">title: titleString 	title := titleString</body><body package="WikiWorks4SSP">type	^  #renamed</body></methods><methods><class-id>WikiWorks.RenamedWikiPage</class-id> <category>flat file</category><body package="WikiWorks4SSP">saveToFile: aFileStream under: aWiki 	super saveToFile: aFileStream under: aWiki.	aFileStream nextPutAll: title</body><body package="WikiWorks4SSP">specificData: titleString 	self title: titleString</body></methods><methods><class-id>WikiWorks.RenamedWikiPage</class-id> <category>isam</category><body package="WikiWorks4SSP">asIsamEntryId: id wiki: aWiki	^ (super asIsamEntryId: id wiki: aWiki)		datum: title;		yourself</body><body package="WikiWorks4SSP">fromIsamEntry: isamEntry wiki: aWiki		super fromIsamEntry: isamEntry wiki: aWiki.	self title: isamEntry datum</body></methods><methods><class-id>WikiWorks.FileResponder</class-id> <category>private</category><body package="WikiWorks4SSP">contentTypeFor: aFileName 	| aColl aString |	aString := aFileName asString.	aColl :=  aString tokensBasedOn: $..	^aColl size == 1		ifTrue: ['text/plain']		ifFalse: [self typesAt: aColl last asLowercase asSymbol ifAbsent: ['text/plain']]</body><body package="WikiWorks4SSP">internetMediaFor: aFileName 	| headers content aStream |	content := self contentTypeFor: aFileName.	headers := VisualWave.MessageHeaders new.	headers headerAt: 'Content-Type' putValue: content.	headers headerAt: 'Content-Length' putValue: aFileName fileSize storeString.	^[aStream := aFileName readStream .	  VisualWave.InternetMedia receiveOver: aStream withHeaders: headers] ensure: 		[aStream notNil ifTrue: 			[aStream close]].	"im headers headerAt: 'Content-Length' putValue: im entityBytes size printString."</body><body package="WikiWorks4SSP">notAuthorizedAnswer	^VisualWave.SimpleAnswer notAuthorizedAnswer</body><body package="WikiWorks4SSP">notFoundAnswer	^VisualWave.SimpleAnswer notFoundAnswer</body><body package="WikiWorks4SSP">types	^self class types</body><body package="WikiWorks4SSP">typesAt: aSymbol ifAbsent: aBlock	^self class types at: aSymbol ifAbsent: aBlock</body><body package="WikiWorks4SSP">wikiNameFrom: aWebRequest	self subclassResponsibility</body></methods><methods><class-id>WikiWorks.FileResponder</class-id> <category>accessing</category><body package="WikiWorks4SSP">defaultDir	^defaultDir</body><body package="WikiWorks4SSP">defaultDir: aValue	defaultDir := aValue</body><body package="WikiWorks4SSP">defaultDirectoryName	^defaultDir asString</body></methods><methods><class-id>WikiWorks.FileResponder</class-id> <category>public interface</category><body package="WikiWorks4SSP">answerFor: aWebRequest	"Returns an object suitable as a web (HTTP) response"	| aColl fn im |	aColl := aWebRequest unconsumedPath.	fn := self pathFrom: aColl.	[im := self authorizeRequest: aWebRequest]		on: NotAuthorizedError		do: [:ex | ^ self notAuthorizedAnswer].	[im := self  internetMediaFor: fn]		on: OsError		do: [:ex | ^ self notFoundAnswer ].	^ VisualWave.InternetMediaAnswer on: im</body></methods><methods><class-id>WikiWorks.FileResponder</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">initialize	super initialize.	defaultDir := Filename defaultDirectory</body></methods><methods><class-id>WikiWorks.FileResponder</class-id> <category>authorization</category><body package="WikiWorks4SSP">authorizeRequest: aWebRequest	self subclassResponsibility</body><body package="WikiWorks4SSP">authorizeRequest: aWebRequest for: aWikiName	self subclassResponsibility</body></methods><methods><class-id>WikiWorks.FileResponder class</class-id> <category>class initialization</category><body package="WikiWorks4SSP">initialize	"self initialize"	Types := IdentityDictionary new.	self initializeDefaultTypes</body><body package="WikiWorks4SSP">initializeDefaultTypes	"text"	self types at: #htm put: 'text/html'.	self types at: #html put: 'text/html'.	self types at: #txt put: 'text/plain'.	self types at: #text put: 'text/plain'.	"apps"	self types at: #js put: 'application/x-javascript'.	self types at: #mocha put: 'application/x-javascript'.	"vrml"	self types at: #wrl put: 'x-world/x-vrml'.	"video"	self types at: #avi put: 'video/x-msvideo'.	self types at: #mov put: 'video/quicktime'.	self types at: #qt put: 'video/quicktime'.	self types at: #moov put: 'video/quicktime'.	self types at: #mpeg put: 'video/mpeg'.	self types at: #mpg put: 'video/mpeg'.	self types at: #mpe put: 'video/mpeg'.	self types at: #mpv put: 'video/mpeg'.	self types at: #vbs put: 'video/mpeg'.	self types at: #mpegv put: 'video/mpeg'.	"audio"	self types at: #wav put: 'audio/x-wav'.	self types at: #au put: 'audio/basic'.	self types at: #snd put: 'audio/basic'.	self types at: #mp2 put: 'audio/x-mpeg'.	self types at: #mpa put: 'audio/x-mpeg'.	self types at: #abs put: 'audio/x-mpeg'.	self types at: #mpega put: 'audio/x-mpeg'.	self types at: #aif put: 'audio/x-aiff'.	self types at: #aiff put: 'audio/x-aiff'.	self types at: #aifc put: 'audio/x-aiff'.		"images"	self types at: #bmp put: 'image/x-MS-bmp'.	self types at: #rgb put: 'image/x-rgb'.	self types at: #gif put: 'image/gif'.	self types at: #ief put: 'image/ief'.	self types at: #png put: 'image/x-png'.	self types at: #pcd put: 'image/x-photo-cd'.	self types at: #ppm put: 'image/x-portable-pixmap'.	self types at: #pgm put: 'image/x-portable-graymap'.	self types at: #pbm put: 'image/x-portable-bitmap'.	self types at: #pnm put: 'image/x-portable-anymap'.	self types at: #xwd put: 'image/x-xwindowdump'.	self types at: #xpm put: 'image/x-xpixmap'.	self types at: #xbm put: 'image/x-xbitmap'.	self types at: #ras put: 'image/x-cmu-raster'.	self types at: #tif put: 'image/tiff'.	self types at: #tiff put: 'image/tiff'.	self types at: #jpeg put: 'image/jpeg'.	self types at: #jpg put: 'image/jpeg'.	self types at: #jpe put: 'image/jpeg'.	self types at: #pip put: 'image/jpeg'.	self types at: #jfif put: 'image/jpeg'.	self types at: #pipeg put: 'image/jpeg'.</body></methods><methods><class-id>WikiWorks.FileResponder class</class-id> <category>utility</category><body package="WikiWorks4SSP">editorClass	^(#{VisualWave.RedirectionAnswerEditor} value)</body><body package="WikiWorks4SSP">types	^Types</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>private-recover</category><body package="WikiWorks4SSP">readContentsOfPage: aWikiPage	| aReadStream contents file fileNo |	contents := ''.	fileNo := idMap at: aWikiPage ifAbsent: [^contents].	file := directory construct: fileNo printString , '.pag'.	file definitelyExists		ifTrue:			[aReadStream := file readStream.			aReadStream lineEndAuto.			[aReadStream nextLine.	"Page class name"			aReadStream nextLine.	"Author's name"			aReadStream nextLine.	"Timestamp"			aReadStream nextLine.	"Previous version"			contents := aReadStream upToEnd]				ensure: [aReadStream close]].	^contents</body><body package="WikiWorks4SSP">readPageFrom: aReadStream into: aDictionary latests: aCollection 	| page className |	className := aReadStream nextLine asSymbol.	page := ((LiteralBindingReference simpleName: className) method: thisContext method) value new.	page author: aReadStream nextLine.	page timestamp: aReadStream nextLine asNumber.	page isOriginal 		ifFalse: 			[page previousVersion: (self 						readPreviousPageFrom: aReadStream						into: aDictionary						latests: aCollection)].	page specificData: ( (page isPromoted or: [page isReverted])				ifTrue: 					[self 						readPreviousPageFrom: aReadStream						into: aDictionary						latests: aCollection]				ifFalse: [aReadStream upToEnd]).	^page</body><body package="WikiWorks4SSP">readPageInFile: aFilename into: aDictionary latests: aCollection 	| index |	index := aFilename stem asNumber.	^aDictionary at: index		ifAbsentPut: 			[| rs page |			rs := aFilename readStream lineEndAuto.			page := 					[self 						readPageFrom: rs						into: aDictionary						latests: aCollection] 							ensure: [rs close].			page ifNil: [self error: 'Failed read page']				notNil: [aCollection add: page]]</body><body package="WikiWorks4SSP">readPagesInto: pageMap latests: latests 	directory filesMatching: '*.pag'		do: 			[:fileName | 			self 				readPageInFile: fileName				into: pageMap				latests: latests].	pageMap keysAndValuesDo: 			[:index :page | 			idMap at: page put: index.			fileCounter := fileCounter max: index]</body><body package="WikiWorks4SSP">readPreviousPageFrom: aReadStream into: aDictionary latests: aCollection 	| previous |	previous := self 				readPageInFile: (directory construct: aReadStream nextLine , '.pag')				into: aDictionary				latests: aCollection.	aCollection remove: previous ifAbsent: [].	^previous</body><body package="WikiWorks4SSP">recoverFiles	| pageMap latests |	pageMap := IdentityDictionary new.	latests := OrderedCollection new.	self readPagesInto: pageMap latests: latests.	self checkHistories: pageMap latests: latests.	latests := pageMap values select: [:page |		(page hastSuccessorIn: pageMap) not ].	self checkTitles: pageMap latests: latests.	self cleanupLatests: latests.	latests do: [:page | super addPage: page]</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">initialize	super initialize.	fileCounter := -1.	idMap := IdentityDictionary new.	fileServer := false.	readUsers := nil.	writeUsers := nil</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>private-persistance</category><body package="WikiWorks4SSP">basicIdMap	^idMap</body><body package="WikiWorks4SSP">nextFileCounter	^fileCounter := fileCounter + 1</body><body package="WikiWorks4SSP">savePage: aPage 	| id ws |	id := idMap at: aPage ifAbsent: [self nextFileCounter].	ws := (directory construct: id printString , '.pag') writeStream.	[aPage saveToFile: ws under: self] ensure: [ws close].	^id</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>private-checking</category><body package="WikiWorks4SSP">checkHistories: aDictionary latests: aCollection 		| latestDict duplicates latest |	[	latest := aDictionary select: [:page |		(page hastSuccessorIn: aDictionary) not ].	latestDict := Dictionary new.	latest keysAndValuesDo: [:file :curr |		(latestDict  at: curr firstVersion ifAbsentPut: [Dictionary new])			at: file put: curr ].	duplicates := latestDict select: [:entry |		entry size &gt; 1].	duplicates isEmpty 		ifFalse: [ self handleDuplicates: duplicates fullMap: aDictionary. false ]		ifTrue: [ true ]	] whileFalse.	[ aCollection isEmpty ] whileFalse: [ aCollection removeLast ].	aCollection addAll: latest.</body><body package="WikiWorks4SSP">cleanupLatests: aCollection 	aCollection copy do: 			[:page | 			(page isOriginal and: [page title ~= rootPageTitle]) 				ifTrue: 					[					[aCollection remove: page.					(directory construct: (idMap removeKey: page) printString , '.pag') delete] 							on: OsError							do: [:ex | ex return]]]</body><body package="WikiWorks4SSP">handleDuplicate: duplicateEntry fullMap: aDictionary	| selectedKey |	selectedKey := (self selectDuplicateFrom: duplicateEntry)		ifNil: [ self error: 'No duplicate selected to use' ].	duplicateEntry keysAndValuesDo: [:key :value |		key = selectedKey 			ifFalse: [  self removePage: value pageIndex: key fullmap: aDictionary ]]</body><body package="WikiWorks4SSP">handleDuplicates: duplicates fullMap: aDictionary	duplicates do: [:duplicateEntry |			self handleDuplicate: duplicateEntry fullMap: aDictionary ].</body><body package="WikiWorks4SSP">removePage: aPage pageIndex: index fullmap: aDictionary	"Remove the page itself and all previous versions of the page up to (excluding)	 the next predecessor which has more than one successor versions (a branch)"	| page key |	self halt: 'Code has not been tested by now ...'.	page := aPage previousVersion.	[ (page notNil and: [ (page hasSeveralSuccessorsIn: aDictionary) not ])	] whileTrue: [		key := aDictionary keyAtValue: page.		self renamePageFile: key.		aDictionary removeKey: key.		page := page previousVersion ].	self renamePageFile: index.	aDictionary removeKey: index.</body><body package="WikiWorks4SSP">renamePageFile: anIndex	| file |	file := directory construct: anIndex printString , '.pag'.	file renameTo: (directory construct: anIndex printString , '.pag.',Date today printString,'.bak').</body><body package="WikiWorks4SSP">selectDuplicateFrom: duplicates	"select an entry from the duplicates dictionary.	 The keys are also the numbers of the file names so we can afterwards remove the	 no selected files"	| array |	HeadlessImage isHeadless ifTrue: [ 		self error: (#CantSelectInHeadless &lt;&lt; #wiki &gt;&gt; 'Can''t select duplicate in headless image'). ].	array := duplicates associations.	^  Dialog choose: 'Which duplicate to use for ...' 				fromList: (array collect: [:entry | entry key printString, ' - ',entry value printString ])				values: (array collect: [:entry  | entry key  ])				lines: 8 				cancel: [ nil ]</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>encoding</category><body package="WikiWorks4SSP">encodeForSave: aString	| string |	string := aString copyReplaceAll: '€' with: 'Euro'.	"possible encoding problem ..."	string := string copyReplaceAll: (String with: (Character value: 128)) with: 'Euro'.	string := string replaceAll: (Character value: 8211) with: $-.	^ string</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>printing</category><body package="WikiWorks4SSP">printOn: aStream	super printOn: aStream.	self name printOn: aStream.</body></methods><methods><class-id>WikiWorks.FlatFileWiki</class-id> <category>accessing</category><body package="WikiWorks4SSP">basicCssUrl	^cssUrl</body><body package="WikiWorks4SSP">basicPages	^pages</body><body package="WikiWorks4SSP">basicRootPageTitle	^rootPageTitle</body><body package="WikiWorks4SSP">fileCounter	^fileCounter</body><body package="WikiWorks4SSP">readUsers	^readUsers</body><body package="WikiWorks4SSP">writeUsers	^writeUsers</body></methods><methods><class-id>WikiWorks.FlatFileWiki class</class-id> <category>accessing</category><body package="WikiWorks4SSP">storageType	^#flatFile</body></methods><methods><class-id>WikiWorks.FileResponder4ssp</class-id> <category>private</category><body package="WikiWorks4SSP">contentTypeFor: aFileName 	| aColl aString |	aString := aFileName asString.	aColl := aString tokensBasedOn: $..	^aColl size == 1 		ifTrue: ['application/octet-stream']		ifFalse: 			[self typesAt: aColl last asLowercase asSymbol ifAbsent: ['application/octet-stream']]</body><body package="WikiWorks4SSP">internetMediaFor: aFileName withRequest: aWebRequest	| headers content aStream headerFeld |	content := self contentTypeFor: aFileName.	headers := VisualWave.MessageHeaders new.	headers headerAt: 'Content-Type' putValue: content.	headers headerAt: 'Content-Length' putValue: aFileName fileSize storeString.	headerFeld := (HTTPUserAgent from: aWebRequest) headerFeld: 'attachment; filename=' , '"' , aFileName tail , '"'.	headerFeld ifNotNil: [headers headerAt: 'Content-Disposition' putValue: headerFeld].	^	[aStream := aFileName readStream.	VisualWave.InternetMedia receiveOver: aStream withHeaders: headers]			ensure: [aStream notNil ifTrue: [aStream close]]</body><body package="WikiWorks4SSP">pathFrom: aColl	"Returns file path"	| aStrm path |	path := self defaultDir.	aStrm := ReadWriteStream with: aColl.	aStrm reset.	[aStrm atEnd] whileFalse: [path := path construct: aStrm next].	^path</body></methods><methods><class-id>WikiWorks.FileResponder4ssp</class-id> <category>As yet unclassified</category><body package="WikiWorks4SSP">authorizeRequest: aWebRequest	| aRequest access |	aRequest := aWebRequest asRequest.	access := CompositeWiki current authorizeRequest: aRequest for: (self wikiNameFrom: aWebRequest).	access = #not_allowed ifTrue: [NotAuthorizedError raise]</body><body package="WikiWorks4SSP">authorizeRequest: aWebRequest for: aWikiName	CompositeWiki current authorizeRequest: aWebRequest for: aWikiName</body><body package="WikiWorks4SSP">wikiNameFrom: aWebRequest	| r |	r := aWebRequest consumedPath first.	^(r tokensBasedOn: $_) at: 1.</body></methods><methods><class-id>WikiWorks.FileResponder4ssp</class-id> <category>public interface</category><body package="WikiWorks4SSP">answerFor: aWebRequest	"Returns an object suitable as a web (HTTP) response"	| aColl fn im |	aColl := aWebRequest unconsumedPath.	fn := self pathFrom: aColl.	[im := self authorizeRequest: aWebRequest]		on: NotAuthorizedError		do: [:ex | ^ self notAuthorizedAnswer].	[im := self  internetMediaFor: fn withRequest: aWebRequest]		on: OsError		do: [:ex | ^ self notFoundAnswer ].	^ VisualWave.InternetMediaAnswer on: im</body></methods><methods><class-id>WikiWorks.FileResponder4ssp class</class-id> <category>class initialization</category><body package="WikiWorks4SSP">initializeDefaultTypes Types := Dictionary new. Types  at: #ai put: 'application/postscript';  at: #aif put: 'audio/x-aiff';  at: #aifc put: 'audio/aiff';  at: #aiff put: 'audio/aiff';  at: #au put: 'audio/basic';  at: #avi put: 'video/x-msvideo';  at: #bmp put: 'image/bmp';  at: #cdf put: 'application/x-cdf';  at: #cer put: 'application/x-x509-ca-cert';  at: #cha put: 'text/plain';  at: #crt put: 'application/x-x509-ca-cert';  at: #css put: 'test/css';  at: #dcr put: 'application/x-director';  at: #der put: 'application/x-x509-ca-cert';  at: #dir put: 'application/x-director';  at: #dll put: 'application/x-msdownload';  at: #doc put: 'application/msword';  at: #dot put: 'application/msword';  at: #dxr put: 'application/x-director';  at: #eml put: 'message/rfc822';  at: #eps put: 'application/postscript';  at: #exe put: 'application/x-msdownload';  at: #fif put: 'application/fractals';  at: #gif put: 'image/gif';  at: #gz put: 'application/x-gzip';  at: #hqx put: 'application/mac-binhex40';  at: #htm put: 'text/html';  at: #html put: 'text/html';  at: #htt put: 'text/webviewhtml';  at: #ins put: 'application/x-internet-signup';  at: #isp put: 'application/x-internet-signup';  at: #ivf put: 'video/x-ivf';  at: #jfif put: 'image/pjpeg';  at: #jpe put: 'image/jpeg';  at: #jpeg put: 'image/jpeg';  at: #jpg put: 'image/jpeg';  at: #latex put: 'application/x-latex';  at: #m1v put: 'video/mpeg';  at: #man put: 'application/x-troff-man';  at: #mht put: 'message/rfc822';  at: #mhtml put: 'message/rfc882';  at: #mid put: 'audio/mid';  at: #mov put: 'video/quicktime';  at: #mp2 put: 'video/mpeg';  at: #mpa put: 'video/mpeg';  at: #mpe put: 'video/mpeg';  at: #mpeg put: 'video/mpeg';  at: #mpg put: 'video/mpeg';  at: #nws put: 'message/rfc822';  at: #p7c put: 'application/pkcs7-mime';  at: #pcl put: 'application/x-visualworks-parcel';  at: #pdf put: 'application/pdf';  at: #pot put: 'application/vnd.ms-powerpoint';  at: #ppa put: 'application/vnd.ms-powerpoint';  at: #pps put: 'application/vnd.ms-powerpoint';  at: #ppt put: 'application/vnd.ms-powerpoint';  at: #ps put: 'application/postscript';  at: #pwz put: 'application/vnd.ms-powerpoint';  at: #qt put: 'video/quicktime';  at: #rmi put: 'audio/mid';  at: #rtf put: 'application/msword';  at: #sit put: 'application/x-stuffit';  at: #snd put: 'audio/basic';  at: #spl put: 'application/futuresplash';  at: #swf put: 'application/x-shockwave-flash';  at: #tar put: 'application/x-tar';  at: #tgz put: 'application/x-compressed';  at: #tif put: 'image/tiff';  at: #tiff put: 'image/tiff';  at: #txt put: 'text/plain';  at: #wav put: 'audio/wav';  at: #wiz put: 'application/msword';  at: #xbm put: 'image/x-xbitmap';  at: #xls put: 'application/vnd.ms-excel';  at: #z put: 'application/x-compress';  at: #zip put: 'application/x-zip-compressed'</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="WikiWorks4SSP">copyFrom: start 	start &gt; self size ifTrue: [^self species new].	^self copyFrom: (start max: 1) to: self size</body><body package="WikiWorks4SSP">copyTo: stop 	stop &gt; self size ifTrue: [^self copy].	^self copyFrom: 1 to: stop</body></methods><methods><class-id>VisualWave.URI</class-id> <category>private</category><body package="WikiWorks4SSP">decode: aValue	| encoder |	encoder := URLEncoder new.	^encoder decode: aValue</body><body package="WikiWorks4SSP">decode: aValue withEncoder: encoder	^aValue ifNotNil: [(URLEncoder newWithEncoder: encoder) decode: aValue]</body></methods><methods><class-id>VisualWave.URI</class-id> <category>accessing</category><body package="WikiWorks4SSP">path: aValue	"overridden to decode it properly"	path := self decode: aValue</body><body package="WikiWorks4SSP">query: aValue	"overridden to decode it properly"	"query := self decode: aValue"	query := aValue</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>As yet unclassified</category><body package="WikiWorks4SSP">changeSet	^Store.XChangeSet new</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="WikiWorks4SSP">ifNil: nilAlternativeBlock notNil: objectAlternativeBlock 	^objectAlternativeBlock value</body><body package="WikiWorks4SSP">notNil: aBlock 	^aBlock value</body><body package="WikiWorks4SSP">notNil: objectAlternativeBlock ifNil: nilAlternativeBlock 	^objectAlternativeBlock value</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="WikiWorks4SSP">parameterValueAsString	^String new</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="WikiWorks4SSP">sendOver: aStream 	self printOn: aStream</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="WikiWorks4SSP">nextLine	"Return the a collection of characters up to the next instance of cr."	^self upTo: Character cr</body><body package="WikiWorks4SSP">upTo: anObject escaper: anotherObject 	"	'test[ a' readStream upTo:$[ escaper:$\.	'test\[ a' readStream upTo:$[ escaper:$\.	'test\[a\]]' readStream upTo:$] escaper:$\.	"	| newStream previous |	newStream := (self contentsSpecies new: 64) writeStream.	previous := nil.	[self atEnd]		whileFalse:			[| element |			element := self next.			previous = anotherObject				ifTrue: [newStream nextPut: element]				ifFalse:					[element = anObject ifTrue: [^newStream contents].					element = anotherObject ifFalse: [newStream nextPut: element]].			previous := element].	^newStream contents</body></methods><methods><class-id>Core.Timestamp</class-id> <category>printing</category><body package="WikiWorks4SSP">sendOver: aStream 	TimestampPrintPolicy 		print: (TimeZone default convertToGMT: self asSeconds				do: [:date :seconds | Timestamp fromDate: date andTime: (Time fromSeconds: seconds)])		on: aStream		using: 'ddd, dd mmm yyyy hh:mm:ss GMT'</body></methods><methods><class-id>VisualWave.WebRequestService</class-id> <category>private - serving requests</category><body package="WikiWorks4SSP">dispatchRequest: aWebRequest	^self privateDispatchRequest: aWebRequest.</body></methods><methods><class-id>VisualWave.SimpleAnswer class</class-id> <category>instance creation-notAuthorized</category><body package="WikiWorks4SSP">logNotAuthorizedFor: aRequest in: anObj 	self		noteReducedServiceIn: anObj		for: aRequest		report: (self notFoundAlertFor: aRequest in: anObj)</body><body package="WikiWorks4SSP">notAuthorizedAnswer 	^self notAuthorizedAnswerWith: self preferredNotAuthorizedString</body><body package="WikiWorks4SSP">notAuthorizedAnswerFor: aRequest in: anObj 	^self		notAuthorizedAnswerFor: aRequest		in: anObj		preferredAnswer: self notAuthorizedAnswer</body><body package="WikiWorks4SSP">notAuthorizedAnswerFor: aRequest in: anObj preferredAnswer: anAnswer		self logNotAuthorizedFor: aRequest in: anObj.	^anAnswer</body><body package="WikiWorks4SSP">notAuthorizedAnswerFor: aRequest in: anObj preferredMessage: aString	^self		notAuthorizedAnswerFor: aRequest		in: anObj		preferredAnswer: (self notAuthorizedAnswerWith: aString)</body><body package="WikiWorks4SSP">notAuthorizedAnswerWith: htmlString 	| inst |	(inst := self new) 		status: 401; 	reasonString: 'Not Authorized'; 	mediaType: 'text/html'.	inst entityBytes: htmlString.	^inst</body></methods><methods><class-id>VisualWave.SimpleAnswer class</class-id> <category>private</category><body package="WikiWorks4SSP">preferredNotAuthorizedString	^WaveServerSettings serviceNotAuthorizedMessage.</body></methods><methods><class-id>VisualWave.WaveServerSettings class</class-id> <category>settings-alerts-accessing</category><body package="WikiWorks4SSP">defaultServiceNotAuthorizedMessage	^#Error401 &lt;&lt; #WaveServerDialogs		&gt;&gt;			'&lt;H2&gt;Error: 401 - Not Authorized Request.&lt;/H2&gt;&lt;HR&gt;'.</body><body package="WikiWorks4SSP">initializeAlertMessagesDictionary	alertMessagesDictionary := Dictionary new.	alertMessagesDictionary		at: #applicationErrorMessage		put: self defaultApplicationErrorMessage;		at: #serviceNotFoundMessage		put: self defaultServiceNotFoundMessage;		at: #sessionExpiredMessage		put: self defaultSessionExpiredMessage;		at: #serviceNotAuthorizedMessage		put:  self defaultServiceNotAuthorizedMessage.</body><body package="WikiWorks4SSP">serviceNotAuthorizedMessage	^self alertMessagesDictionary at: #serviceNotAuthorizedMessage.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="WikiWorks4SSP">encodedHTTP	^ URLEncoder encode: self</body><body package="WikiWorks4SSP">fromHTMLEntities	| xml elements |	xml := '%&lt;?xml version="1.0"?&gt;%&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;%&lt;a&gt;&lt;1s&gt;%&lt;/a&gt;'			expandMacrosWith: self.	elements := ((XML.XMLParser processDocumentString: xml	beforeScanDo: [:p | p validate: false]) root elements).	elements isEmpty		ifTrue: [^'']		 ifFalse: [^elements any text]</body><body package="WikiWorks4SSP">fromHTMLEntities: aCharacterArray	^XML.XMLParser processDocumentString: aCharacterArray	beforeScanDo: [:p | p validate: false]</body><body package="WikiWorks4SSP">trimSeparators	"return a copy of the reciever without any spaces 	on front or back. Protect against all blanks"	| start stop |	start := 1.	stop := self size.		[start &gt; stop ifTrue: [^''].	(self at: start) isSeparator] 			whileTrue: [start := start + 1].	[(self at: stop) isSeparator] whileTrue: [stop := stop - 1].	^self copyFrom: start to: stop</body><body package="WikiWorks4SSP">withHTMLEntities	| stream |	stream := (String new:self size) writeStream.	self do:[:char | char asHTMLEntity sendOver: stream].	^stream contents</body><body package="WikiWorks4SSP">withUnicodeEntities	| stream |	stream := (String new:self size) writeStream.	self do:[:char | char asUnicodeEntity sendOver: stream].	^stream contents</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="WikiWorks4SSP">asTimestamp	^Timestamp fromSeconds: self asInteger</body></methods><methods><class-id>VisualWave.NetBasedFormData</class-id> <category>reading</category><body package="WikiWorks4SSP">decodeFrom: aStream	"This is a horrible hack to fool the net framework into thinking that it's already parsed our headers and can go on to parse the body. In the longer term we probably want to look at using the net framework to parse the entire thing, but for the moment we need to use it just for the body so that it can handle our encodings and such correctly"	| length request charset contentType parser newStream |	length := self headers valueAt: 'Content-Length'.	length notNil ifTrue: [length := length asNumber.].	request := Net.HttpRequest method: 'POST' url: 'http://localhost'. 	contentType := Net.ContentTypeField readFrom: ('content-type: ', (self headers valueAt: 'content-type' )) readStream.	request addField: contentType.	request contentLength: length.	(charset := self headers valueAt: 'content-type' parameterNamed: 'charset') notNil		ifTrue: [ 	contentType charset: charset ].	parser := request newBuilder parser.	parser handler acceptNonAsciiCharacters: true.	parser handler headerOnly: false.	newStream := parser handler prepareStream: aStream.	parser handler lineEndConvention: newStream lineEndConvention.	parser parseMessageBody: request from: newStream.	self postProcess: request.</body><body package="WikiWorks4SSP">receiveEntityOver: aStream	| oldConvention |	oldConvention := aStream lineEndConvention. 	[aStream lineEndCRLF. self decodeFrom: aStream] ensure: [		aStream closed ifFalse: [aStream lineEndConvention: oldConvention]].</body></methods><methods><class-id>VisualWave.WebRequest</class-id> <category>reading</category><body package="WikiWorks4SSP">decodeCookieData	"Decode the query data. If we get an illegal character, which in the case of utf-8 means it wasn't a valid utf-8 encoded string, just put in illegal characters and keep going. We'll figure out the real encoding later"	[self decodeCookieDataWithEncoding: (self encoding ifNil: [#'ISO8859-1'])] on: UnsupportedCharacterError do: [:ex | ex resume: Character illegalCode].</body><body package="WikiWorks4SSP">decodeQueryData	"Decode the query data. If we get an illegal character, which in the case of utf-8 means it wasn't a valid utf-8 encoded string, just put in illegal characters and keep going. We'll figure out the real encoding later"	[self decodeQueryDataWithEncoding: (self encoding ifNil: [#'UTF-8'])] on: UnsupportedCharacterError do: [:ex | ex resume: Character illegalCode].</body></methods><methods><class-id>VisualWave.WebRequest</class-id> <category>encoding</category><body package="WikiWorks4SSP">detectPossibleEncoding	^#'UTF-8'</body></methods><methods><class-id>VisualWave.WebRequest</class-id> <category>accessing</category><body package="WikiWorks4SSP">encoder	^ httpRequest encoder</body><body package="WikiWorks4SSP">encoding	^ self encoder 		ifNil: [ nil ]		ifNotNil: [:enc | enc encoding ]</body></methods><methods><class-id>VisualWave.WebRequest</class-id> <category>reading</category><body package="WikiWorks4SSP">queryDataWithEncoding: anEncodingName	| qString |	(qString := self QUERY_STRING) size &gt; 0		ifTrue: 			[self queryData: ((IM_ApplicationWWWFormUrlEncoded new)						charset: anEncodingName;						queryDataOver: qString readStream)]</body></methods><methods><class-id>VisualWave.WebRequest</class-id> <category>encoding</category><body package="WikiWorks4SSP">withCorrectEncodingFor: aService	| encoding |	encoding := self detectPossibleEncoding.	self setEncoding: encoding</body></methods><methods><class-id>OS.URLEncoder class</class-id> <category>guessing</category><body package="WikiWorks4SSP">guessEncodingOf: aReadStream possibleEncodings: aBlock	^self basicNew guessEncodingOf: aReadStream possibleEncodings: aBlock</body></methods><methods><class-id>OS.URLEncoder class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">newRequestStream: aReadStream possibleEncodings: anArray	^super new 		guessEncodingOf: aReadStream possibleEncodings: anArray;		yourself</body><body package="WikiWorks4SSP">newWithEncoder: aStreamEncoder	^ super new		setEncoder: aStreamEncoder;		yourself</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>scanning</category><body package="WikiWorks4SSP">currentHexNumberFrom: aReadStream	^ (aReadStream peekFor: $%) 		ifTrue: 	[ self decodeHexNumberFrom: aReadStream ]		ifFalse:	[ nil ]</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>guessing</category><body package="WikiWorks4SSP">getEncodedSequencesFrom: aReadStream	| coll seq |	coll := OrderedCollection new.	[ (seq := self nextEncodedSequenceFrom: aReadStream) notNil ] whileTrue: [		coll addLast: seq readStream ].	^ coll</body><body package="WikiWorks4SSP">getEncoderNamed: encName forDecoding: sequences	"get the encoder for decoding the given contents or return nil if none is found"	| encStream anEncoder |	anEncoder := StreamEncoder new: encName ifAbsent: [ ^ nil ].	[ sequences do: 		[:seq |			seq reset.			encStream := EncodedStream on: seq encodedBy: anEncoder.			encStream upToEnd. ].		^ anEncoder	] 	on: Error 		do: [:ex | ^ nil]</body><body package="WikiWorks4SSP">guessEncodingOf: aReadStream possibleEncodings: aBlock 	| possibleEncodings oldPos sequences |	oldPos := aReadStream position.	sequences := self getEncodedSequencesFrom: aReadStream. "get all encoded sequences"	sequences isEmpty ifTrue: [ ^ nil ].	possibleEncodings := aBlock value.	[ possibleEncodings do: [:encName| 		(self getEncoderNamed: encName forDecoding: sequences) ifNotNil: [:enc | ^ enc ].		].		^ nil .	]	ensure: [aReadStream position: oldPos]</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>scanning</category><body package="WikiWorks4SSP">nextEncodedSequenceFrom: aReadStream	| byteStream num |	aReadStream skipUpTo: $%.	aReadStream atEnd ifTrue: [^ nil ].	byteStream := ByteArray new writeStream.	[ (num := self currentHexNumberFrom: aReadStream) isNil ] whileFalse: [		byteStream nextPut: num ].	^ byteStream contents.</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing</category><body package="WikiWorks4SSP">ifNil: nilAlternativeBlock notNil: objectAlternativeBlock 	^nilAlternativeBlock value</body><body package="WikiWorks4SSP">notNil: aBlock 	^nil</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>printing</category><body package="WikiWorks4SSP">sendOver: aStream</body></methods><methods><class-id>Core.Process</class-id> <category>accessing</category><body package="WikiWorks4SSP">adjustPriority: aDelta 	^self priority: self priority + aDelta</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">readFrom: inStream quoteCharacter: quoteCharacter 	"Answer a new String that is determined by reading the stream, inStream.  		Embedded double quotes become the quote Character."	| outStream char |	outStream := (String new: 16) writeStream.	"go to first quote"	inStream skipThrough: quoteCharacter.	[inStream atEnd] whileFalse: 			[char := inStream next.			char = quoteCharacter 				ifTrue: 					[(inStream peekFor: quoteCharacter) 						ifTrue: [outStream nextPut: quoteCharacter]						ifFalse: [^outStream contents]]				ifFalse: [outStream nextPut: char]].	^outStream contents</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="WikiWorks4SSP">asArrayOfSubstringsSeparator: aCharacter	| coll strm |	coll := OrderedCollection new.	strm := self readStream.	[ strm atEnd ] whileFalse: [		coll addLast: (strm upTo: aCharacter) ].	^ coll</body><body package="WikiWorks4SSP">asHTTPFilenameString	^self copy replaceAll: $\ with: $/</body><body package="WikiWorks4SSP">asPortableFilenameString	"replaces all '/' and '\' with platform specific separatorreduces mutilple separators to a single on '///' -&gt;'/' "	| result separator aString tokens tokens2 contents |	result := (String new: self size) writeStream.	separator := Filename separator.	(aString := self copy)		replaceAll: $/ with: separator;		replaceAll: $\ with: separator.	tokens := aString tokensBasedOn: separator.	tokens2 := tokens reject: [:each | each isEmpty].	tokens2 do: 			[:each |			result				nextPutAll: each;				nextPut: separator].	(contents := result contents) isEmpty ifTrue: [^''].	^contents copyFrom: 1 to: contents size - 1</body></methods><methods><class-id>Core.String</class-id> <category>private</category><body package="WikiWorks4SSP">parameterValueAsString	^self</body></methods><methods><class-id>Core.String</class-id> <category>printing</category><body package="WikiWorks4SSP">printInsideOn: aStream quoteCharacter: quoteCharacter 	1 to: self size		do: 			[:i | 			(aStream nextPut: (self at: i)) == quoteCharacter 				ifTrue: [aStream nextPut: quoteCharacter]]	"embedded quotes get doubled"</body><body package="WikiWorks4SSP">printOn: aStream quoteCharacter: quoteCharacter 	aStream nextPut: quoteCharacter.	self printInsideOn: aStream quoteCharacter: quoteCharacter.	aStream nextPut: quoteCharacter</body><body package="WikiWorks4SSP">sendOver: aStream 	aStream nextPutAll: self</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="WikiWorks4SSP">tokensBasedOnAnyOf: anArray	"'abc cde(xyz)+-*/ 234' tokensBasedOnAnyOf: ' ()'"	| strm char str coll |	strm := self readStream.	coll := OrderedCollection new.	[ strm atEnd ] whileFalse: [		str := String new.		[ strm atEnd or: [char := strm next.		anArray includes: char ] ] whileFalse: [			str := str copyWith: char ].		str isEmpty ifFalse: [ coll addLast: str ]. ].	^ coll</body></methods><methods><class-id>Core.Dictionary</class-id> <category>printing</category><body package="WikiWorks4SSP">sendOver: aStream 	"This probably needs to be rewritten, but for now it servers our purpose :)"	self keysDo: [:key | key sendOver: aStream]</body></methods><methods><class-id>VisualWave.InternetMediaAnswer</class-id> <category>sending</category><body package="WikiWorks4SSP">sendCacheDirectiveHeadersOver: aStream 	"Write HTTP response headers - don't send a no-cache header for downloads" 	aStream 		nextPutAll: 'Cache-Control: ';		nextPutAll: "no-cache" 'must-revalidate proxy-revalidate';		crlf.</body></methods><methods><class-id>OS.FileURL</class-id> <category>web content</category><body package="WikiWorks4SSP">resolveIn: anEnvironment relativeTo: directory	"All we need to do is return the file contents.		If it's not an absolute path, make it relative to the directory."	| filename |	"Filename conversion is a hack, because FileURL is currently incomplete -		it cannot manage relative .vs. absolute URLs."	(filename := self asFilename) isAbsolute		ifFalse: [			filename := directory.			(Filename components: (self asFilename asString))				do: [:each | filename := filename construct: each ]].	^ filename exists		ifTrue: [ | strm | strm := (filename withEncoding:#utf8) readStream. [strm lineEndTransparent. strm contents] ensure: [strm close]] 		ifFalse: [ filename errorReporter nonexistentSignal raise ].</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>testing</category><body package="WikiWorks4SSP">anti13	"expects a Stream, which contains a path. Checks whether path leave parent dir.e.g. '../dir1' or 'dir1/../../dir2' used by upload_step2.ssp"	| index myTemp |	self reset.	index := 0.	[self atEnd not] whileTrue: 			[myTemp := self upTo: Filename separator.			(myTemp = '' or: [myTemp = '.']) 				ifFalse: 					[(myTemp sameAs: '..') 						ifTrue: [index &gt; 0 ifTrue: [index := index - 1] ifFalse: [^false]]						ifFalse: [index := index + 1]]].	^true</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>positioning</category><body package="WikiWorks4SSP">insensitivePeekForAll: aCollection 	| orig |	self atEnd ifTrue: [^false].	orig := self position.	((self nextAvailable: aCollection size) sameAs: aCollection) 		ifTrue: [^true].	self position: orig.	^false</body><body package="WikiWorks4SSP">peekForAll: aCollection 	| orig |	self atEnd ifTrue: [^false].	orig := self position.	(self nextAvailable: aCollection size) = aCollection ifTrue: [^true].	self position: orig.	^false</body></methods><methods><class-id>VisualWave.Request</class-id> <category>api</category><body package="WikiWorks4SSP">charset	| charsets |	charsets := self charsets.	^(charsets includes: #'utf-8')		ifTrue: [#'utf-8']		ifFalse: [charsets first]</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="WikiWorks4SSP">backup	self moveTo: self asString , '.orig'</body><body package="WikiWorks4SSP">createdTime	| dates created |	dates := self dates.	(created := dates at: #created ifAbsent: []) isNil		ifTrue: [created := dates detect: [:each | each notNil] ifNone: [Timestamp zero]].	^Timestamp fromArray: created</body><body package="WikiWorks4SSP">ensureDirectory	self directory = self ifFalse: [self directory ensureDirectory].		[self definitelyExists 		ifTrue: 			[self safeIsDirectory ifTrue: [^self].			self backup].	self makeDirectory] 			on: OsError			do: [:ex | ex return]</body></methods><methods><class-id>OS.Filename</class-id> <category>utilities</category><body package="WikiWorks4SSP">filesMatching: pattern do: aBlock 	"Evaluate &lt;block1&gt; on the Filenames of all files in the directory 	named by the receiver whose names are matched by &lt;pattern&gt;."	self directoryContents 		do: [:name | (pattern match: name) ifTrue: [aBlock value: (self construct: name)]]</body></methods><methods><class-id>OS.Filename</class-id> <category>testing</category><body package="WikiWorks4SSP">safeIsDirectory	^[self isDirectory] on: OsError do: [:ex | ex return: false]</body></methods><methods><class-id>OS.Filename</class-id> <category>parsing</category><body package="WikiWorks4SSP">stem	"Answer the filename suffix as a String without its extension."	| tail periodIndex |	tail := self tail.	periodIndex := tail lastIndexOf: $..	^periodIndex &gt; 1		ifTrue: [tail copyFrom: 1 to: periodIndex - 1]		ifFalse: [tail]</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="WikiWorks4SSP">detect: aBlock ifPresent: anOneArgumentBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	answer the evaluation result of anOneArgumentBlock with the first 	element for which aBlock evaluates to true. Answer nil otherwise."	self 		do: [:each | (aBlock value: each) ifTrue: [^anOneArgumentBlock value: each]].	^nil</body><body package="WikiWorks4SSP">reject: rejectBlock collect: projectBlock 	| newCollection |	newCollection := self species new.	self do: 			[:element | 			(rejectBlock value: element) 				ifFalse: [newCollection add: (projectBlock value: element)]].	^newCollection</body></methods><methods><class-id>VisualWave.InternetMedia class</class-id> <category>reading</category><body package="WikiWorks4SSP">receiveOver: aStream withHeaders: messageHeaders from: aHttpRequest	"aStream should be positioned after the headers and the blank line"	| media |	media := (self classForHeaders: messageHeaders) new.	media headers: messageHeaders.	media receiveEntityOver: aStream from: aHttpRequest.	^media.</body></methods><methods><class-id>VisualWave.InternetMedia</class-id> <category>reading</category><body package="WikiWorks4SSP">receiveEntityOver: aStream from: aHttpRequest	"Assumed stream is positioned just before entity bytes. Headers are already established; read next 'Content-length' bytes or until end."	^ self receiveEntityOver: aStream</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="WikiWorks4SSP">asHTMLEntity		| entity |	entity := WikiWorks.SpecialCharactersToUnicode		at: self		ifAbsent: [nil].	entity notNil ifTrue: [^entity].	^self asUnicodeEntity</body><body package="WikiWorks4SSP">asUnicodeEntity		| value |	^(value := self asInteger) &gt; 127		ifTrue: ['&amp;#' , value printString , ';']		ifFalse: [self]</body><body package="WikiWorks4SSP">encodedHTTPOn: aStream 	| urlEncoder encStream |	self isUnreserved ifTrue: [^aStream nextPut: self].	self == $  ifTrue: [^aStream nextPut: $+].	urlEncoder := (URLEncoder newWithEncoder: (StreamEncoder new: #utf8)).	encStream := EncodedStream on: aStream encodedBy: urlEncoder.	encStream nextPut: self.</body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="WikiWorks4SSP">isMark	^'-_.!~*''()' includes: self</body><body package="WikiWorks4SSP">isUnreserved	^self isAlphaNumeric or: [self isMark]</body></methods><methods><class-id>Core.Character</class-id> <category>printing</category><body package="WikiWorks4SSP">sendOver: aStream 	aStream nextPut: self</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>private</category><body package="WikiWorks4SSP">parameterValueAsString	^self contents</body></methods><methods><class-id>VisualWave.WebSite</class-id> <category>accessing</category><body package="WikiWorks4SSP">defaultEncodingName	"Hard-coded for the moment, but put here so that it can fairly easily be made a setting"	"Some people have asked for iso-8859-15, which is the same as -1, but with the Euro symbol. Changing this method (and probably doing some reinitialization, especially of #defaultWebLocale) would change that"	^'ISO8859-15'.</body></methods><methods><class-id>OS.UnixFilename class</class-id> <category>utilities</category><body package="WikiWorks4SSP">encodeFilename: aString	^aString asByteArrayEncoding: #utf8</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="WikiWorks4SSP">niceValue	| result |	Processor activeProcess adjustPriority: -1.	result := self value.	Processor activeProcess adjustPriority: 1.	^result</body></methods><methods><class-id>Core.StreamEncoder class</class-id> <category>instance creation</category><body package="WikiWorks4SSP">new: sym ifAbsent: aBlock 	| streamEncoderSource |	streamEncoderSource := [self lookupEncoderDirectory: sym] 				on: KeyNotFoundError				do: [:ex | ^aBlock value].	^streamEncoderSource isNil 		ifTrue: [aBlock value]		ifFalse: [streamEncoderSource asEncoder]</body></methods><methods><class-id>Net.MimeParserHandler</class-id> <category>private prepare streams</category><body package="WikiWorks4SSP">asEncodedStream: aStream	^(EncodedStream on: aStream		encodedBy: (StreamEncoder new: #'UTF-8'))		lineEndConvention: lineEndConvention.</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="WikiWorks4SSP">anyOne	"return any arbitrary element from the reciever, 	subclasses may reimplement for performance"	self do: [:each | ^each].	^self emptyCollectionError</body></methods><methods><class-id>WikiWorks.WikiPageLink</class-id> <category>initialize-release</category><body package="WikiWorks4SSP">xhtmlDTDLatEnc	&lt;xmlCache: 'http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent'&gt;	^'&lt;!-- Portions (C) International Organization for Standardization 1986     Permission to copy in any form is granted for use with     conforming SGML systems and applications as defined in     ISO 8879, provided this notice is included in all copies.--&gt;&lt;!-- Character entity set. Typical invocation:    &lt;!ENTITY % HTMLlat1 PUBLIC       "-//W3C//ENTITIES Latin 1 for XHTML//EN"       "http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent"&gt;    %HTMLlat1;--&gt;&lt;!ENTITY nbsp   "&amp;#160;"&gt; &lt;!-- no-break space = non-breaking space,                                  U+00A0 ISOnum --&gt;&lt;!ENTITY iexcl  "&amp;#161;"&gt; &lt;!-- inverted exclamation mark, U+00A1 ISOnum --&gt;&lt;!ENTITY cent   "&amp;#162;"&gt; &lt;!-- cent sign, U+00A2 ISOnum --&gt;&lt;!ENTITY pound  "&amp;#163;"&gt; &lt;!-- pound sign, U+00A3 ISOnum --&gt;&lt;!ENTITY curren "&amp;#164;"&gt; &lt;!-- currency sign, U+00A4 ISOnum --&gt;&lt;!ENTITY yen    "&amp;#165;"&gt; &lt;!-- yen sign = yuan sign, U+00A5 ISOnum --&gt;&lt;!ENTITY brvbar "&amp;#166;"&gt; &lt;!-- broken bar = broken vertical bar,                                  U+00A6 ISOnum --&gt;&lt;!ENTITY sect   "&amp;#167;"&gt; &lt;!-- section sign, U+00A7 ISOnum --&gt;&lt;!ENTITY uml    "&amp;#168;"&gt; &lt;!-- diaeresis = spacing diaeresis,                                  U+00A8 ISOdia --&gt;&lt;!ENTITY copy   "&amp;#169;"&gt; &lt;!-- copyright sign, U+00A9 ISOnum --&gt;&lt;!ENTITY ordf   "&amp;#170;"&gt; &lt;!-- feminine ordinal indicator, U+00AA ISOnum --&gt;&lt;!ENTITY laquo  "&amp;#171;"&gt; &lt;!-- left-pointing double angle quotation mark                                  = left pointing guillemet, U+00AB ISOnum --&gt;&lt;!ENTITY not    "&amp;#172;"&gt; &lt;!-- not sign = angled dash,                                  U+00AC ISOnum --&gt;&lt;!ENTITY shy    "&amp;#173;"&gt; &lt;!-- soft hyphen = discretionary hyphen,                                  U+00AD ISOnum --&gt;&lt;!ENTITY reg    "&amp;#174;"&gt; &lt;!-- registered sign = registered trade mark sign,                                  U+00AE ISOnum --&gt;&lt;!ENTITY macr   "&amp;#175;"&gt; &lt;!-- macron = spacing macron = overline                                  = APL overbar, U+00AF ISOdia --&gt;&lt;!ENTITY deg    "&amp;#176;"&gt; &lt;!-- degree sign, U+00B0 ISOnum --&gt;&lt;!ENTITY plusmn "&amp;#177;"&gt; &lt;!-- plus-minus sign = plus-or-minus sign,                                  U+00B1 ISOnum --&gt;&lt;!ENTITY sup2   "&amp;#178;"&gt; &lt;!-- superscript two = superscript digit two                                  = squared, U+00B2 ISOnum --&gt;&lt;!ENTITY sup3   "&amp;#179;"&gt; &lt;!-- superscript three = superscript digit three                                  = cubed, U+00B3 ISOnum --&gt;&lt;!ENTITY acute  "&amp;#180;"&gt; &lt;!-- acute accent = spacing acute,                                  U+00B4 ISOdia --&gt;&lt;!ENTITY micro  "&amp;#181;"&gt; &lt;!-- micro sign, U+00B5 ISOnum --&gt;&lt;!ENTITY para   "&amp;#182;"&gt; &lt;!-- pilcrow sign = paragraph sign,                                  U+00B6 ISOnum --&gt;&lt;!ENTITY middot "&amp;#183;"&gt; &lt;!-- middle dot = Georgian comma                                  = Greek middle dot, U+00B7 ISOnum --&gt;&lt;!ENTITY cedil  "&amp;#184;"&gt; &lt;!-- cedilla = spacing cedilla, U+00B8 ISOdia --&gt;&lt;!ENTITY sup1   "&amp;#185;"&gt; &lt;!-- superscript one = superscript digit one,                                  U+00B9 ISOnum --&gt;&lt;!ENTITY ordm   "&amp;#186;"&gt; &lt;!-- masculine ordinal indicator,                                  U+00BA ISOnum --&gt;&lt;!ENTITY raquo  "&amp;#187;"&gt; &lt;!-- right-pointing double angle quotation mark                                  = right pointing guillemet, U+00BB ISOnum --&gt;&lt;!ENTITY frac14 "&amp;#188;"&gt; &lt;!-- vulgar fraction one quarter                                  = fraction one quarter, U+00BC ISOnum --&gt;&lt;!ENTITY frac12 "&amp;#189;"&gt; &lt;!-- vulgar fraction one half                                  = fraction one half, U+00BD ISOnum --&gt;&lt;!ENTITY frac34 "&amp;#190;"&gt; &lt;!-- vulgar fraction three quarters                                  = fraction three quarters, U+00BE ISOnum --&gt;&lt;!ENTITY iquest "&amp;#191;"&gt; &lt;!-- inverted question mark                                  = turned question mark, U+00BF ISOnum --&gt;&lt;!ENTITY Agrave "&amp;#192;"&gt; &lt;!-- latin capital letter A with grave                                  = latin capital letter A grave,                                  U+00C0 ISOlat1 --&gt;&lt;!ENTITY Aacute "&amp;#193;"&gt; &lt;!-- latin capital letter A with acute,                                  U+00C1 ISOlat1 --&gt;&lt;!ENTITY Acirc  "&amp;#194;"&gt; &lt;!-- latin capital letter A with circumflex,                                  U+00C2 ISOlat1 --&gt;&lt;!ENTITY Atilde "&amp;#195;"&gt; &lt;!-- latin capital letter A with tilde,                                  U+00C3 ISOlat1 --&gt;&lt;!ENTITY Auml   "&amp;#196;"&gt; &lt;!-- latin capital letter A with diaeresis,                                  U+00C4 ISOlat1 --&gt;&lt;!ENTITY Aring  "&amp;#197;"&gt; &lt;!-- latin capital letter A with ring above                                  = latin capital letter A ring,                                  U+00C5 ISOlat1 --&gt;&lt;!ENTITY AElig  "&amp;#198;"&gt; &lt;!-- latin capital letter AE                                  = latin capital ligature AE,                                  U+00C6 ISOlat1 --&gt;&lt;!ENTITY Ccedil "&amp;#199;"&gt; &lt;!-- latin capital letter C with cedilla,                                  U+00C7 ISOlat1 --&gt;&lt;!ENTITY Egrave "&amp;#200;"&gt; &lt;!-- latin capital letter E with grave,                                  U+00C8 ISOlat1 --&gt;&lt;!ENTITY Eacute "&amp;#201;"&gt; &lt;!-- latin capital letter E with acute,                                  U+00C9 ISOlat1 --&gt;&lt;!ENTITY Ecirc  "&amp;#202;"&gt; &lt;!-- latin capital letter E with circumflex,                                  U+00CA ISOlat1 --&gt;&lt;!ENTITY Euml   "&amp;#203;"&gt; &lt;!-- latin capital letter E with diaeresis,                                  U+00CB ISOlat1 --&gt;&lt;!ENTITY Igrave "&amp;#204;"&gt; &lt;!-- latin capital letter I with grave,                                  U+00CC ISOlat1 --&gt;&lt;!ENTITY Iacute "&amp;#205;"&gt; &lt;!-- latin capital letter I with acute,                                  U+00CD ISOlat1 --&gt;&lt;!ENTITY Icirc  "&amp;#206;"&gt; &lt;!-- latin capital letter I with circumflex,                                  U+00CE ISOlat1 --&gt;&lt;!ENTITY Iuml   "&amp;#207;"&gt; &lt;!-- latin capital letter I with diaeresis,                                  U+00CF ISOlat1 --&gt;&lt;!ENTITY ETH    "&amp;#208;"&gt; &lt;!-- latin capital letter ETH, U+00D0 ISOlat1 --&gt;&lt;!ENTITY Ntilde "&amp;#209;"&gt; &lt;!-- latin capital letter N with tilde,                                  U+00D1 ISOlat1 --&gt;&lt;!ENTITY Ograve "&amp;#210;"&gt; &lt;!-- latin capital letter O with grave,                                  U+00D2 ISOlat1 --&gt;&lt;!ENTITY Oacute "&amp;#211;"&gt; &lt;!-- latin capital letter O with acute,                                  U+00D3 ISOlat1 --&gt;&lt;!ENTITY Ocirc  "&amp;#212;"&gt; &lt;!-- latin capital letter O with circumflex,                                  U+00D4 ISOlat1 --&gt;&lt;!ENTITY Otilde "&amp;#213;"&gt; &lt;!-- latin capital letter O with tilde,                                  U+00D5 ISOlat1 --&gt;&lt;!ENTITY Ouml   "&amp;#214;"&gt; &lt;!-- latin capital letter O with diaeresis,                                  U+00D6 ISOlat1 --&gt;&lt;!ENTITY times  "&amp;#215;"&gt; &lt;!-- multiplication sign, U+00D7 ISOnum --&gt;&lt;!ENTITY Oslash "&amp;#216;"&gt; &lt;!-- latin capital letter O with stroke                                  = latin capital letter O slash,                                  U+00D8 ISOlat1 --&gt;&lt;!ENTITY Ugrave "&amp;#217;"&gt; &lt;!-- latin capital letter U with grave,                                  U+00D9 ISOlat1 --&gt;&lt;!ENTITY Uacute "&amp;#218;"&gt; &lt;!-- latin capital letter U with acute,                                  U+00DA ISOlat1 --&gt;&lt;!ENTITY Ucirc  "&amp;#219;"&gt; &lt;!-- latin capital letter U with circumflex,                                  U+00DB ISOlat1 --&gt;&lt;!ENTITY Uuml   "&amp;#220;"&gt; &lt;!-- latin capital letter U with diaeresis,                                  U+00DC ISOlat1 --&gt;&lt;!ENTITY Yacute "&amp;#221;"&gt; &lt;!-- latin capital letter Y with acute,                                  U+00DD ISOlat1 --&gt;&lt;!ENTITY THORN  "&amp;#222;"&gt; &lt;!-- latin capital letter THORN,                                  U+00DE ISOlat1 --&gt;&lt;!ENTITY szlig  "&amp;#223;"&gt; &lt;!-- latin small letter sharp s = ess-zed,                                  U+00DF ISOlat1 --&gt;&lt;!ENTITY agrave "&amp;#224;"&gt; &lt;!-- latin small letter a with grave                                  = latin small letter a grave,                                  U+00E0 ISOlat1 --&gt;&lt;!ENTITY aacute "&amp;#225;"&gt; &lt;!-- latin small letter a with acute,                                  U+00E1 ISOlat1 --&gt;&lt;!ENTITY acirc  "&amp;#226;"&gt; &lt;!-- latin small letter a with circumflex,                                  U+00E2 ISOlat1 --&gt;&lt;!ENTITY atilde "&amp;#227;"&gt; &lt;!-- latin small letter a with tilde,                                  U+00E3 ISOlat1 --&gt;&lt;!ENTITY auml   "&amp;#228;"&gt; &lt;!-- latin small letter a with diaeresis,                                  U+00E4 ISOlat1 --&gt;&lt;!ENTITY aring  "&amp;#229;"&gt; &lt;!-- latin small letter a with ring above                                  = latin small letter a ring,                                  U+00E5 ISOlat1 --&gt;&lt;!ENTITY aelig  "&amp;#230;"&gt; &lt;!-- latin small letter ae                                  = latin small ligature ae, U+00E6 ISOlat1 --&gt;&lt;!ENTITY ccedil "&amp;#231;"&gt; &lt;!-- latin small letter c with cedilla,                                  U+00E7 ISOlat1 --&gt;&lt;!ENTITY egrave "&amp;#232;"&gt; &lt;!-- latin small letter e with grave,                                  U+00E8 ISOlat1 --&gt;&lt;!ENTITY eacute "&amp;#233;"&gt; &lt;!-- latin small letter e with acute,                                  U+00E9 ISOlat1 --&gt;&lt;!ENTITY ecirc  "&amp;#234;"&gt; &lt;!-- latin small letter e with circumflex,                                  U+00EA ISOlat1 --&gt;&lt;!ENTITY euml   "&amp;#235;"&gt; &lt;!-- latin small letter e with diaeresis,                                  U+00EB ISOlat1 --&gt;&lt;!ENTITY igrave "&amp;#236;"&gt; &lt;!-- latin small letter i with grave,                                  U+00EC ISOlat1 --&gt;&lt;!ENTITY iacute "&amp;#237;"&gt; &lt;!-- latin small letter i with acute,                                  U+00ED ISOlat1 --&gt;&lt;!ENTITY icirc  "&amp;#238;"&gt; &lt;!-- latin small letter i with circumflex,                                  U+00EE ISOlat1 --&gt;&lt;!ENTITY iuml   "&amp;#239;"&gt; &lt;!-- latin small letter i with diaeresis,                                  U+00EF ISOlat1 --&gt;&lt;!ENTITY eth    "&amp;#240;"&gt; &lt;!-- latin small letter eth, U+00F0 ISOlat1 --&gt;&lt;!ENTITY ntilde "&amp;#241;"&gt; &lt;!-- latin small letter n with tilde,                                  U+00F1 ISOlat1 --&gt;&lt;!ENTITY ograve "&amp;#242;"&gt; &lt;!-- latin small letter o with grave,                                  U+00F2 ISOlat1 --&gt;&lt;!ENTITY oacute "&amp;#243;"&gt; &lt;!-- latin small letter o with acute,                                  U+00F3 ISOlat1 --&gt;&lt;!ENTITY ocirc  "&amp;#244;"&gt; &lt;!-- latin small letter o with circumflex,                                  U+00F4 ISOlat1 --&gt;&lt;!ENTITY otilde "&amp;#245;"&gt; &lt;!-- latin small letter o with tilde,                                  U+00F5 ISOlat1 --&gt;&lt;!ENTITY ouml   "&amp;#246;"&gt; &lt;!-- latin small letter o with diaeresis,                                  U+00F6 ISOlat1 --&gt;&lt;!ENTITY divide "&amp;#247;"&gt; &lt;!-- division sign, U+00F7 ISOnum --&gt;&lt;!ENTITY oslash "&amp;#248;"&gt; &lt;!-- latin small letter o with stroke,                                  = latin small letter o slash,                                  U+00F8 ISOlat1 --&gt;&lt;!ENTITY ugrave "&amp;#249;"&gt; &lt;!-- latin small letter u with grave,                                  U+00F9 ISOlat1 --&gt;&lt;!ENTITY uacute "&amp;#250;"&gt; &lt;!-- latin small letter u with acute,                                  U+00FA ISOlat1 --&gt;&lt;!ENTITY ucirc  "&amp;#251;"&gt; &lt;!-- latin small letter u with circumflex,                                  U+00FB ISOlat1 --&gt;&lt;!ENTITY uuml   "&amp;#252;"&gt; &lt;!-- latin small letter u with diaeresis,                                  U+00FC ISOlat1 --&gt;&lt;!ENTITY yacute "&amp;#253;"&gt; &lt;!-- latin small letter y with acute,                                  U+00FD ISOlat1 --&gt;&lt;!ENTITY thorn  "&amp;#254;"&gt; &lt;!-- latin small letter thorn,                                  U+00FE ISOlat1 --&gt;&lt;!ENTITY yuml   "&amp;#255;"&gt; &lt;!-- latin small letter y with diaeresis,                                  U+00FF ISOlat1 --&gt;'</body></methods><initialize><class-id>WikiWorks.FileResponder</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>URLEncoder</name><environment>OS</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>urlSpecials </inst-vars><class-inst-vars>urlSpecials </class-inst-vars><imports></imports><category>URISupport</category><attributes><package>URISupport</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Parcel</name><environment>Kernel</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects definedClasses definedBindings classSelectors namedObjects dirty loaded </inst-vars><class-inst-vars>parcels classParcelMap parcelFileInfoCache parcelFileDirectoryCache dependents </class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>RedirectionAnswer</name><environment>VisualWave</environment><super>VisualWave.StatusedAnswer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>uriString optionalMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Support-Web-Framework</category><attributes><package>Wave-Server</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>InternetMediaAnswer</name><environment>VisualWave</environment><super>VisualWave.StatusedAnswer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>media </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Support-Web-Framework</category><attributes><package>Wave-Server</package></attributes></class><class><name>WebRequest</name><environment>VisualWave</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>httpRequest serverEnvironment queryData cookieData responseStream consumedPath unconsumedPath initiator entities webSite session isAnswered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Support-Web-Framework</category><attributes><package>Wave-Server</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>MimeEntity</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>header headerCharset readingOptions writingOptions </inst-vars><class-inst-vars>defaultTextCharset defaultTextType </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>UserApplication</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>InternetMedia</name><environment>VisualWave</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Net</category><attributes><package>Wave-Server</package></attributes></class><class><name>NetBasedFormData</name><environment>VisualWave</environment><super>VisualWave.InternetMedia</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Net</category><attributes><package>Templating</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>WebRequestService</name><environment>VisualWave</environment><super>VisualWave.StreamedService</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resolver server trapErrors logChannels logChannelsMutex loadLogChannel </inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Wave-Server</category><attributes><package>Wave-Server</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>MimeParserHandler</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream lineEndConvention initialEntity parser binaryMode options </inst-vars><class-inst-vars>saveAttachmentsAsFiles defaultAttachmentDirectory </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>Request</name><environment>VisualWave</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>webRequest cookies form query attributes handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Toolkit-ASP</category><attributes><package>ASP</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>URI</name><environment>VisualWave</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Net</category><attributes><package>Wave-Server</package></attributes></class><class><name>FileURL</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>missingSlashes host </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>HTTPMessage</name><environment>VisualWave</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>majorVersion minorVersion httpHeaders entityHeaders entity </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wave-Net</category><attributes><package>Wave-Server</package></attributes></class><class><name>WebSite</name><environment>VisualWave</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name configFileName homeDirectory environment application urlManager eventManager sitePolicy authorizationPolicy cache configurationError parentConfiguration sessionRegistry configParameters responseBuffering </inst-vars><class-inst-vars></class-inst-vars><imports>			OS.URI			</imports><category>Web Toolkit-ASP</category><attributes><package>ASP</package></attributes></class><class><name>Process</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList depth hostThreadKey interruptProtect environment isSystem name debugger locale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>IsamItem</name><environment>Heeg.Isam</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>recordPosition recordLength </inst-vars><class-inst-vars>isamFields isamTypes </class-inst-vars><imports></imports><category>Files-Isam</category><attributes><package>Isam Toolbox</package></attributes></class></st-source>