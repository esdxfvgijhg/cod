<?xml version="1.0"?><st-source><!-- Name: ByteOrderMarkSupport-TestsNotice: © Copyright 2013 - 2017 Georg Heeg e.K.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.(MIT License)Comment: contains tests for the AR61009 package. It tests that BOM (ByteOrderMark) support and BOM-based autodetect is properly implemented.DbIdentifier: magdi.heeg.de.postgresDbTrace: 68774DbUsername: georgDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'ByteOrderMarkSupport' '') #(#any 'SUnit' '') #(#any 'RBSUnitExtensions' ''))PackageName: ByteOrderMarkSupport-TestsParcel: #('ByteOrderMarkSupport-Tests')ParcelDirectory: d:\visworks\vw8.3 jul17.1\image\HeegContributions-vw8.3-2017-07-10\ByteOrderMarkSupport-TestsParcelName: ByteOrderMarkSupport-TestsPrerequisiteDescriptions: #(#(#name 'ByteOrderMarkSupport' #componentType #package) #(#name 'SUnit' #componentType #package) #(#name 'RBSUnitExtensions' #componentType #package))PrerequisiteParcels: #(#('ByteOrderMarkSupport' '') #('SUnit' '') #('RBSUnitExtensions' ''))PrintStringCache: (8.3 - 2,georg)Version: 8.3 - 2Date: 5:01:19 PM July 10, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jul17.1) of 7. Juli 2017 on 10. Juli 2017 at 17:01:19</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BOMTests</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ByteOrderMarkSupport-Tests</package></attributes></class><comment><class-id>BOMTests</class-id><body>BOMTests contains tests for BOM enabled stream creation. BOMs start UTF-Encoded files and help figure out what encoding a file uses. Because BOMs are unique to their encoding they can be used to guess the encoding of a file. To do this in VisualWorks,  the implementation is so that one can use encodings like #UTF8WithBOM or #autoDetect to work with such files.The test has two kinds of tests, new and old tests. The old tests use the API that's typically used to create streams:(ByteArray withEncoding:#UTF8WithBOM) readStream.Due to design changes in the way the actual encoded stream is created, it was possible to call this new api in the tests without actually using it in the system. Instance Variables	testFile 		&lt;Filename&gt; 		the file that's used for creating file-based streams during a test</body></comment><class><name>BOMTestsOld</name><environment>Smalltalk</environment><super>BOMTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ByteOrderMarkSupport-Tests</package></attributes></class><class><name>GeneralBomTests</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ByteOrderMarkSupport-Tests</package></attributes></class><class><name>SourceFileTests</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exampleUTF8File exampleUTF8BOMFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ByteOrderMarkSupport-Tests</package></attributes></class><class><name>BOMTestsNew</name><environment>Smalltalk</environment><super>BOMTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ByteOrderMarkSupport-Tests</package></attributes></class><methods><class-id>BOMTests</class-id> <category>private</category><body package="ByteOrderMarkSupport-Tests">basicNameOfEncoding: encoding	^[(StreamEncoder lookupEncoderDirectory: encoding) name] on: Error		do: [:ex | ex return: encoding]</body><body package="ByteOrderMarkSupport-Tests">createFileReadStreamOn: byteArray withEncoding: readEncoding using: selector	self subclassResponsibility</body><body package="ByteOrderMarkSupport-Tests">createFileWriteStreamOn: filename withEncoding: encoding using: anObject	self subclassResponsibility</body><body package="ByteOrderMarkSupport-Tests">createInMemoryReadStreamOn: bytes withEncoding: encoding using: selector	self subclassResponsibility</body><body package="ByteOrderMarkSupport-Tests">createInMemoryWriteStreamOn: storage withEncoding: encoding using: anObject	self subclassResponsibility</body></methods><methods><class-id>BOMTests</class-id> <category>tests</category><body package="ByteOrderMarkSupport-Tests">assertReadAppendAndReadWriteStreamWithEncoding: encoding	#(#createFileReadStreamOn:withEncoding:using: #createInMemoryReadStreamOn:withEncoding:using:)		do: 			[:each |			self				assertReadThenWrittenStreamWhenCreatedUsing: #readWriteStream				byMethod: each				inEncoding: encoding].	#(#createFileReadStreamOn:withEncoding:using:) do: 			[:each |			"this only works for files. In-Memory readAppendStreams are not supported"			self				assertReadThenWrittenStreamWhenCreatedUsing: #readAppendStream				byMethod: each				inEncoding: encoding]</body><body package="ByteOrderMarkSupport-Tests">assertReadThenWrittenStreamWhenCreatedUsing: creationSymbol byMethod: streamCreation inEncoding: encoding	"&lt;creationSymbol&gt; is either readWriteStream or readAppendStream.	&lt;streamCreation&gt; is a symbol like #ceateFileReadStreamOn:withEncoding:using: so that subclasses can return a proper stream instance.	the test ensures the following:		If a bytearray is created using &lt;encoding&gt; and the stream is a readWriteStream or readAppendStream		then initial reading should force the stream to use the read-encoding and also to not write the BOM again 		when writing for the first time"	| readWriteStream initialString referenceContents streamContents bytes readString encodingRs readEncoding |	encodingRs := encoding readStream.	readEncoding := (encodingRs upTo: $:) asSymbol.	initialString := 'äbcd€'.	"use the &lt;readEncoding&gt; to create the initial bytes, otherwise the readWriteStream cannot reliably decode the first bytes"	bytes := initialString asByteArrayEncoding: readEncoding.	readWriteStream := self				perform: streamCreation				with: bytes				with: encoding				with: creationSymbol.	"first ensure that the readWriteStream can read the initial bytes"	[readString := readWriteStream next: initialString size.	self assert: readString = initialString.	readWriteStream nextPutAll: initialString.	readWriteStream reset.	streamContents := readWriteStream encodedContents copy				changeClassTo: ByteArray]			ensure: [readWriteStream close].	referenceContents := initialString , initialString				asByteArrayEncoding: readEncoding.	^self assert: streamContents = referenceContents</body><body package="ByteOrderMarkSupport-Tests">testAutodetectBOM	"tests if the BOM can be correctly used for autodetect"	self		assertReadEncoding: #dbg_autodetect		decodesBytes: #[116 101 115 116]		toString: 'test'.	self		assertReadEncoding: #dbg_autodetect		decodesBytes: #[239 187 191 116 101 115 116]		toString: 'test'.	self		assertReadEncoding: #dbg_autodetect		decodesBytes: #[254 255 0 116 0 101 0 115 0 116]		toString: 'test'.	self		assertReadEncoding: #dbg_autodetect		decodesBytes: #[255 254 116 0 101 0 115 0 116 0]		toString: 'test'.	self		assertReadEncoding: #dbg_autodetect		decodesBytes: #[0 0 254 255 0 0 0 116 0 0 0 101 0 0 0 115 0 0 0 116]		toString: 'test'.	self		assertReadEncoding: #dbg_autodetect		decodesBytes: #[255 254 0 0 116 0 0 0 101 0 0 0 115 0 0 0 116 0 0 0]		toString: 'test'</body><body package="ByteOrderMarkSupport-Tests">testAutodetectBOMPeek	"tests if the BOM can be correctly used for autodetect"	self		assertPeekEncoding: #dbg_autodetect		decodesBytes: #[239 187 191 116 101 115 116]		toByte: $t		inEncoding: #'UTF-8WithBOM'.	self		assertPeekEncoding: #dbg_autodetect		decodesBytes: #[254 255 0 116 0 101 0 115 0 116]		toByte: $t		inEncoding: #'UTF-16BEWithBOM'.	self		assertPeekEncoding: #dbg_autodetect		decodesBytes: #[255 254 116 0 101 0 115 0 116 0]		toByte: $t		inEncoding: #'UTF-16LEWithBOM'.	self		assertPeekEncoding: #dbg_autodetect		decodesBytes: #[0 0 254 255 0 0 0 116 0 0 0 101 0 0 0 115 0 0 0 116]		toByte: $t		inEncoding: #'UTF-32BEWithBOM'.	self		assertPeekEncoding: #dbg_autodetect		decodesBytes: #[255 254 0 0 116 0 0 0 101 0 0 0 115 0 0 0 116 0 0 0]		toByte: $t		inEncoding: #'UTF-32LEWithBOM'</body><body package="ByteOrderMarkSupport-Tests">testAutodetectNoBOM	"this method tests if the encoding that's suffixed to the #autoDetectOr is properly used. 	It tests both reading and writing. For writing the part after #autoDetectOr is used as encoding."	self		assertReadWriteEncoding: #dbg_autoDetectOrUTF8		encodesString: '€'		toBytes: #[226 130 172].	self		assertReadWriteEncoding: #dbg_autoDetectorUTF16BE		encodesString: 'test'		toBytes: #[0 116 0 101 0 115 0 116].	self		assertReadWriteEncoding: #dbg_autoDetectOrUTF16LE		encodesString: 'test'		toBytes: #[116 0 101 0 115 0 116 0].	self		assertReadWriteEncoding: #dbg_autoDetectOrUTF32BE		encodesString: 'test'		toBytes: #[0 0 0 116 0 0 0 101 0 0 0 115 0 0 0 116].	self		assertReadWriteEncoding: #dbg_autoDetectOrUTF32LE		encodesString: 'test'		toBytes: #[116 0 0 0 101 0 0 0 115 0 0 0 116 0 0 0]</body><body package="ByteOrderMarkSupport-Tests">testAutodetectShortcut	"this method tests the #dbg_text encoding which is registered as autodetect:UTF8WithBOM:"	self		assertWriteEncoding: #dbg_text		encodesString: 'test'		toBytes: #[239 187 191 116 101 115 116].	self		assertReadEncoding: #dbg_text		decodesBytes: #[239 187 191 116 101 115 116]		toString: 'test'.	self		assertReadEncoding: #dbg_text		decodesBytes: #[116 101 115 116]		toString: 'test'</body><body package="ByteOrderMarkSupport-Tests">testAutodetectWrite	"this method tests that the writing encoding is used properly"	self		assertWriteEncoding: #dbg_autoDetect:UTF8:		encodesString: 'test'		toBytes: #[116 101 115 116].	self		assertWriteEncoding: #dbg_autoDetectOrUTF16BE:UTF8:		encodesString: 'test'		toBytes: #[116 101 115 116].	self		assertWriteEncoding: #dbg_autoDetect:UTF8WithBom:		encodesString: 'test'		toBytes: #[239 187 191 116 101 115 116].	self		assertWriteEncoding: #dbg_autoDetect:UTF16LE:		encodesString: 'test'		toBytes: #[116 0 101 0 115 0 116 0].	self		assertWriteEncoding: #dbg_autoDetect:UTF16BEWithBom:		encodesString: 'test'		toBytes: #[254 255 0 116 0 101 0 115 0 116].	self		assertWriteEncoding: #dbg_autoDetect:UTF16LEWithBom:		encodesString: 'test'		toBytes: #[255 254 116 0 101 0 115 0 116 0].	self		assertWriteEncoding: #dbg_autoDetect:UTF32BEWithBom:		encodesString: 'test'		toBytes: #[0 0 254 255 0 0 0 116 0 0 0 101 0 0 0 115 0 0 0 116].	self		assertWriteEncoding: #dbg_autoDetect:UTF32LEWithBom:		encodesString: 'test'		toBytes: #[255 254 0 0 116 0 0 0 101 0 0 0 115 0 0 0 116 0 0 0]</body><body package="ByteOrderMarkSupport-Tests">testNormalReadWrite	"this method tests that reading and writing of the string or the bytes always encodes/decodes to the other"	self		assertReadWriteEncoding: #utf8		encodesString: 'test'		toBytes: #[116 101 115 116].	self		assertReadWriteEncoding: #utf8WithBom		encodesString: 'test'		toBytes: #[239 187 191 116 101 115 116].	self		assertReadWriteEncoding: #utf16le		encodesString: 'test'		toBytes: #[116 0 101 0 115 0 116 0].	self		assertReadWriteEncoding: #utf16BEWithBom		encodesString: 'test'		toBytes: #[254 255 0 116 0 101 0 115 0 116].	self		assertReadWriteEncoding: #utf16LEWithBom		encodesString: 'test'		toBytes: #[255 254 116 0 101 0 115 0 116 0].	self		assertReadWriteEncoding: #utf32		encodesString: 'test'		toBytes: #[116 0 0 0 101 0 0 0 115 0 0 0 116 0 0 0].	self		assertReadWriteEncoding: #utf32BEWithBom		encodesString: 'test'		toBytes: #[0 0 254 255 0 0 0 116 0 0 0 101 0 0 0 115 0 0 0 116].	self		assertReadWriteEncoding: #utf32LEWithBom		encodesString: 'test'		toBytes: #[255 254 0 0 116 0 0 0 101 0 0 0 115 0 0 0 116 0 0 0]</body><body package="ByteOrderMarkSupport-Tests">testPartialReading	"tests if the BOM is correctly handled by #upToAll:, #throughAll: etc"	self		assertReadEncoding: #dbg_autodetect		decodesBytes: ('FooBarBaz' asByteArrayEncoding: #utf8WithBOM)		toString: 'Foo'		using: [:rs | rs upToAll: 'Bar'].	self		assertReadEncoding: #dbg_autodetect		decodesBytes: ('FooBarBaz' asByteArrayEncoding: #utf8WithBOM)		toString: 'BarBaz'		using: 			[:rs |			rs				skipToAll: 'Bar';				upToEnd].	self		assertReadEncoding: #dbg_autodetect		decodesBytes: ('FooBarBaz' asByteArrayEncoding: #utf8WithBOM)		toString: 'Baz'		using: 			[:rs |			rs				skipThroughAll: 'Bar';				upToEnd].	self		assertReadEncoding: #dbg_autodetect		decodesBytes: ('FooBarBaz' asByteArrayEncoding: #utf8WithBOM)		toString: 'FooBar'		using: [:rs | rs throughAll: 'Bar']</body><body package="ByteOrderMarkSupport-Tests">testReadAppendAndReadWriteStream	"this test ensures that the encoding is properly used in a readWriteStream or readAppendStream.	It also ensures that the BOM doesn't end up in the middle of the stream if such a stream was read before it was written"	#(#utf8 #utf8WithBom #utf16le #utf16BEWithBom #utf16LEWithBom #utf32 #utf32BEWithBom #utf32LEWithBom #dbg_autoDetect:UTF8: #dbg_autoDetectOrUTF16BE:UTF8: #dbg_autoDetect:UTF8WithBom: #dbg_autoDetect:UTF16LE: #dbg_autoDetect:UTF16BEWithBom: #dbg_autoDetect:UTF16LEWithBom: #dbg_autoDetect:UTF32BEWithBom: #dbg_autoDetect:UTF32LEWithBom:)		do: [:each | self assertReadAppendAndReadWriteStreamWithEncoding: each]</body><body package="ByteOrderMarkSupport-Tests">testSource	"this method tests the #source encoding. On reading, it's autodetect or UTF8 because there can be source files without BOM. 	On writing it uses UTF8 without BOM."	self		assertReadEncoding: #source		decodesBytes: #[60 63 120 109 108 32 118 101 114 115 105 111 110 61 34 49 46 48 34 63 62]		toString: '&lt;?xml version="1.0"?&gt;'.	self		assertWriteEncoding: #source		encodesString: '&lt;?xml version="1.0"?&gt;'		toBytes: #[60 63 120 109 108 32 118 101 114 115 105 111 110 61 34 49 46 48 34 63 62]</body></methods><methods><class-id>BOMTests</class-id> <category>utility</category><body package="ByteOrderMarkSupport-Tests">assertPeekEncoding: readEncoding decodesBytes: bytes toByte: referenceCharacter inEncoding: byteEncoding	self readStreamSelectors do: 			[:selector |			| firstCharacter encoding basicEncoding basicReferenceEncoding couldPeek encodedStream |			encodedStream := self						createFileReadStreamOn: bytes						withEncoding: readEncoding						using: selector.						[firstCharacter := encodedStream peek.			couldPeek := encodedStream peekFor: referenceCharacter.			encoding := encodedStream encoding]					ensure: [encodedStream close].			self assert: couldPeek.			self assert: firstCharacter = referenceCharacter.			basicEncoding := self basicNameOfEncoding: encoding.			basicReferenceEncoding := self basicNameOfEncoding: byteEncoding.			self assert: basicEncoding = basicReferenceEncoding]</body><body package="ByteOrderMarkSupport-Tests">assertReadEncoding: aSymbol decodesBytes: byteArray toString: aString 	self assertReadEncoding: aSymbol decodesBytes: byteArray toString: aString using: #upToEnd</body><body package="ByteOrderMarkSupport-Tests">assertReadEncoding: aSymbol decodesBytes: byteArray toString: aString using: aBlock	self		readInMemoryWithEncoding: aSymbol		decodesBytes: byteArray		toString: aString		using: aBlock.	self		readFileWithEncoding: aSymbol		decodesBytes: byteArray		toString: aString		using: aBlock</body><body package="ByteOrderMarkSupport-Tests">assertReadWriteEncoding: aSymbol encodesString: aString toBytes: byteArray	self assertWriteEncoding: aSymbol encodesString: aString toBytes: byteArray.	self		assertReadEncoding: aSymbol		decodesBytes: byteArray		toString: aString</body><body package="ByteOrderMarkSupport-Tests">assertWriteEncoding: aSymbol encodesString: aString toBytes: byteArray	self		writeInMemoryWithEncoding: aSymbol		encodesString: aString		toBytes: byteArray.	self		writeFileWithEncoding: aSymbol		encodesString: aString		toBytes: byteArray</body><body package="ByteOrderMarkSupport-Tests">createTextFileWithBytes: byteArray	| binaryWriteStream |	binaryWriteStream := testFile writeStream.		[binaryWriteStream binary.	binaryWriteStream nextPutAll: byteArray]			ensure: [binaryWriteStream close]</body><body package="ByteOrderMarkSupport-Tests">deleteTestFile	testFile delete</body><body package="ByteOrderMarkSupport-Tests">readFileWithEncoding: encoding decodesBytes: bytes toString: referenceString using: aBlock	self readStreamSelectors do: 			[:selector |			| encodedStream decodedString |			encodedStream := self						createFileReadStreamOn: bytes						withEncoding: encoding						using: selector.			decodedString := [aBlock value: encodedStream] ensure: [encodedStream close].			self assert: decodedString = referenceString.			self deleteTestFile]</body><body package="ByteOrderMarkSupport-Tests">readInMemoryWithEncoding: encoding decodesBytes: bytes toString: referenceString using: aBlock	(self selectorsForByteArray: self readStreamSelectors) do: 			[:selector |			| readStream decodedString |			readStream := self						createInMemoryReadStreamOn: bytes						withEncoding: encoding						using: selector.			decodedString := aBlock value: readStream.			self assert: decodedString = referenceString]</body><body package="ByteOrderMarkSupport-Tests">readStreamSelectors	^#(#readStream #readWriteStream #readAppendStream)</body><body package="ByteOrderMarkSupport-Tests">selectorsForByteArray: selectors	^selectors		reject: [:each | #(#appendStream #readAppendStream) includes: each]</body><body package="ByteOrderMarkSupport-Tests">writeFileWithEncoding: encoding encodesString: string toBytes: referenceBytes	| encodedStream bytes |	self writeStreamSelectors do: 			[:each |			encodedStream := self						createFileWriteStreamOn: testFile						withEncoding: encoding						using: each.						[[encodedStream nextPutAll: string] ensure: [encodedStream close].			bytes := testFile contentsOfEntireBinaryFile.			self assert: bytes = referenceBytes]					ensure: [self deleteTestFile]]</body><body package="ByteOrderMarkSupport-Tests">writeInMemoryWithEncoding: encodingName encodesString: aString toBytes: referenceBytes	(self selectorsForByteArray: self writeStreamSelectors) do: 			[:selector |			| writingTarget ws result |			writingTarget := ByteArray new.			ws := self						createInMemoryWriteStreamOn: writingTarget						withEncoding: encodingName						using: selector.			[ws nextPutAll: aString] ensure: [ws close].			result := writingTarget first: ws position.			self assert: result = referenceBytes]</body><body package="ByteOrderMarkSupport-Tests">writeStreamSelectors	^#(#writeStream #appendStream #readWriteStream #readAppendStream)</body></methods><methods><class-id>BOMTests</class-id> <category>running</category><body package="ByteOrderMarkSupport-Tests">setUp	super setUp.	1 milliseconds wait.	testFile := ('test&lt;1p&gt;.txt' expandMacrosWith: Time millisecondClockValue) asFilename</body></methods><methods><class-id>BOMTests class</class-id> <category>testing</category><body package="ByteOrderMarkSupport-Tests">isAbstract	^true</body></methods><methods><class-id>BOMTestsOld</class-id> <category>private</category><body package="ByteOrderMarkSupport-Tests">createFileReadStreamOn: byteArray withEncoding: readEncoding using: selector	self createTextFileWithBytes: byteArray.	^(testFile withEncoding: readEncoding) perform: selector</body><body package="ByteOrderMarkSupport-Tests">createFileWriteStreamOn: aFilename withEncoding: aSymbol using: selector	^(aFilename withEncoding: aSymbol) perform: selector</body><body package="ByteOrderMarkSupport-Tests">createInMemoryReadStreamOn: byteArray withEncoding: aSymbol using: selector	^(byteArray withEncoding: aSymbol) perform: selector</body><body package="ByteOrderMarkSupport-Tests">createInMemoryWriteStreamOn: writingTarget withEncoding: aSymbol using: selector	^(writingTarget withEncoding: aSymbol) perform: selector</body></methods><methods><class-id>BOMTestsOld class</class-id> <category>testing</category><body package="ByteOrderMarkSupport-Tests">isAbstract	^false</body></methods><methods><class-id>GeneralBomTests</class-id> <category>tests</category><body package="ByteOrderMarkSupport-Tests">testUTF8	"this method verifies that the different utf8 names are allowed with BOM.	It also tests that #encodedContents is implemented in ByteOrderMarkedStream"	| bytes |	#('utf8withbom' 'utf-8withbom' 'utf_8withbom') do: 			[:each |			bytes := 'test' asByteArrayEncoding: each asSymbol.			self assert: bytes = #[239 187 191 116 101 115 116]]</body></methods><methods><class-id>SourceFileTests</class-id> <category>initialize-release</category><body package="ByteOrderMarkSupport-Tests">exampleFileInFolder: fileFolder name: aString	^fileFolder		/ (Timestamp now asSeconds printString , '_' , aString , '.st')</body><body package="ByteOrderMarkSupport-Tests">setUp	| fileFolder file |	SourceFileManager default close.	fileFolder := 'sourceFiles' asFilename.	fileFolder ensureDirectory.	fileFolder directoryContents do: 			[:each |			file := fileFolder / each.			file isDirectory ifFalse: [[file delete] on: Error do: [:ex | ex return]]].	exampleUTF8File := self exampleFileInFolder: fileFolder name: 'nobom'.	self		writeChangeFile: self exampleChangeFile		toFile: exampleUTF8File		withEncoding: #utf8.	exampleUTF8BOMFile := self exampleFileInFolder: fileFolder name: 'bom'.	self		writeChangeFile: self exampleChangeFile		toFile: exampleUTF8BOMFile		withEncoding: #utf8WithBOM</body><body package="ByteOrderMarkSupport-Tests">tearDown	SourceFileManager default close</body><body package="ByteOrderMarkSupport-Tests">writeChangeFile: source toFile: file withEncoding: encoding	| ws |	ws := (file withEncoding: encoding) writeStream.	[ws nextPutAll: source] ensure: [ws close]</body></methods><methods><class-id>SourceFileTests</class-id> <category>tests</category><body package="ByteOrderMarkSupport-Tests">exampleChangeFile	^'&lt;?xml version="1.0"?&gt;&lt;st-source&gt;&lt;methods&gt;&lt;class-id&gt;Core.ByteOrderMarkedStream&lt;/class-id&gt; &lt;category&gt;positioning&lt;/category&gt;&lt;body package="Byte Order Mark Support" selector="position:"&gt;position: anInteger	"Set position to anInteger."	stream position: anInteger&lt;/body&gt;&lt;/methods&gt;&lt;/st-source&gt;'</body><body package="ByteOrderMarkSupport-Tests">exampleUTF8BOMFile	^exampleUTF8BOMFile</body><body package="ByteOrderMarkSupport-Tests">exampleUTF8File	^exampleUTF8File</body><body package="ByteOrderMarkSupport-Tests">methodSourceFromChangesIn: source	XML.SourceScannerNodeBuilder new scanFile: source		do: [:change | ^change text asString].	^nil</body><body package="ByteOrderMarkSupport-Tests">testParseSourceFile	"tests that reading the source from a BOM-UTF8 files works just like reading the source from normal UTF8 files."	| referenceSource utf8Source utf8BomSource |	referenceSource := self				methodSourceFromChangesIn: self exampleChangeFile readStream.	utf8Source := self methodSourceFromChangesIn: self exampleUTF8File.	utf8BomSource := self methodSourceFromChangesIn: self exampleUTF8BOMFile.	self assert: referenceSource = utf8Source.	self assert: referenceSource = utf8BomSource</body></methods><methods><class-id>BOMTestsNew</class-id> <category>private</category><body package="ByteOrderMarkSupport-Tests">createFileReadStreamOn: byteArray withEncoding: readEncoding using: selector	| encoder creator readStream |	self createTextFileWithBytes: byteArray.	creator := testFile withEncoding: readEncoding.	encoder := creator findEncoding: readEncoding.	readStream := testFile perform: selector.	readStream binary.	^encoder createEncodedStreamOn: readStream</body><body package="ByteOrderMarkSupport-Tests">createFileWriteStreamOn: filename withEncoding: encoding using: selector	| encoder creator writeStream |	creator := filename withEncoding: encoding.	encoder := creator findEncoding: encoding.	writeStream := filename perform: selector.	writeStream binary.	^encoder createEncodedStreamOn: writeStream</body><body package="ByteOrderMarkSupport-Tests">createInMemoryReadStreamOn: bytes withEncoding: encoding using: selector	| encoder creator readStream |	creator := ByteArray new withEncoding: encoding.	encoder := creator findEncoding: encoding.	readStream := bytes perform: selector.	^encoder createEncodedStreamOn: readStream</body><body package="ByteOrderMarkSupport-Tests">createInMemoryWriteStreamOn: storage withEncoding: encoding using: selector	| encoder creator writeStream |	creator := storage withEncoding: encoding.	encoder := creator findEncoding: encoding.	writeStream := storage perform: selector.	^encoder createEncodedStreamOn: writeStream</body></methods><methods><class-id>BOMTestsNew class</class-id> <category>testing</category><body package="ByteOrderMarkSupport-Tests">isAbstract	^false</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class></st-source>