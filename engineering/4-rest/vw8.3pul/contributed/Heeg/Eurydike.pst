<?xml version="1.0"?><st-source><!-- Name: EurydikeNotice: © Copyright 2013-2016 Georg Heeg eKBundleName: EurydikeBundleStructure: a Store.BundleForParcelComment: Eurydike is a schema-less object-relational mapper designed for easy-to-use. You do not need to write table-descriptors or anything else to describe a mapping between objects and tables. With Eurydike it is possible to store any object on an SQL database and access it through a root object called ObjectSpace. Because of performance reasons primitive objects like strings, symbols, numbers and byteencoded objects like ByteArray or UninterpretedBytes cannot be stored directly as stand-alone object, they can be only stored as variables of another complex object.An ObjectSpace defines the root of the objects you want to persist  in your database. You need to subclass ObjectSpace and implement the class-method #connectionProfile. This method must return an instance of Eurydike.ConnectionProfile and contains the database connection information like environment, user and password. You can then add your needed instance variables or accessor methods to your ObjectSpace. Normally you will speak only with the default instance of your ObjectSpace. This can be retrieved be sending the message #default to your ObjectSpace class. Your changes on the ObjectSpace or any referenced objects will be stored in the database by sending #commit to your ObjectSpace instance. Assume we have an PersonObjectSpace class with instance accessor method #person, an example code could look like this:	| space |	space := PersonObjectSpace default.	space person 		name: 'Winnie'; 		lastName: 'Puuh'; 		yourself.	space commitPlease have a look at class AddressManagementSpace and AddressManagementTestCase for more examples.DevelopmentPrerequisites: #(#(#any 'I18nRuntime' ''))MessageCatalog: eurydikeParcel: nilParcelName: EurydikePrerequisiteDescriptions: #(#(#name 'I18nRuntime' #componentType #package))PrerequisiteParcels: #(#('I18nRuntime' '') #('GlorpVWPort' ''))Version: 8.2 - 128Date: 3:09:11 PM May 31, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (may17.4) of 26. Mai 2017 on 31. Mai 2017 at 15:09:11</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Eurydike</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>Eurydike Namespaces</package></attributes></name-space><class><name>ObjectSpaceError</name><environment>Eurydike</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Error Handling</package></attributes></class><comment><class-id>Eurydike.ObjectSpaceError</class-id><body>ObjectSpaceError is the abstract error class for all Eurydike error classes.Instance Variables	subject	&lt;anObject&gt;		the object that raises the error</body></comment><class><name>FieldError</name><environment>Eurydike</environment><super>Eurydike.ObjectSpaceError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Error Handling</package></attributes></class><comment><class-id>Eurydike.FieldError</class-id><body>FieldError is the abstract class for all field errors. Subclasses are raised when something is wrong with a field.Instance Variables	field		&lt;Field&gt;		the field for that the error is raised</body></comment><class><name>MissingFieldValueType</name><environment>Eurydike</environment><super>Eurydike.FieldError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Error Handling</package></attributes></class><comment><class-id>Eurydike.MissingFieldValueType</class-id><body>FieldValueTypeError is the specialized form of a field type error to describe that the value of the field has an UndefinedFieldType.</body></comment><class><name>ConnectionModificationTracker</name><environment>Eurydike</environment><super>Core.ModificationTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection modifications </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Modifications</package></attributes></class><comment><class-id>Eurydike.ConnectionModificationTracker</class-id><body>ConnectionModificationTracker determines modifications on objects in the cache of the given connection. It does not track or remember the objects itself, instead it ask the connection/cache for trackable objects. The only job of this tracker is to set objects #beMutable, that are hold by the connection cache. This mutability indicates the connection that the object in cache is modified.Instance Variables	connection	&lt;Connection&gt;	an Eurydike connection</body></comment><class><name>FieldRow</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectID fieldID fieldType keyType key valueType value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Fields</package></attributes></class><comment><class-id>Eurydike.FieldRow</class-id><body>FieldRow is the representation of a database row. It contain only strings that maps directly to the database columns. The database interface communicates only with field rows to read/write database content. It is assumed that every object can be expressed as dictionary with key/value pairs. Thus the field row contains a key/value and their corresponding keyType/valueType as full qualified class names. The fieldType represents a basic type of the described field, so one can better distinguish between the different fields (see class Field for more details). Instance Variables	fieldID		&lt;String&gt;	field id (combined with objectID it forms a unique key)	fieldType	&lt;String&gt;	basic type of described field	key			&lt;String&gt;	full qualified class type for #key	keyType	&lt;String&gt;	string representation of key	objectID		&lt;String&gt;	object id (combined with fieldID it forms a unique key)	value		&lt;String&gt;	string representation of value	valueType	&lt;String&gt;	full qualified class type for #value</body></comment><class><name>MigrationObjectClass</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Migration</package></attributes></class><comment><class-id>Eurydike.MigrationObjectClass</class-id><body>MigrationObjectClass represents the class of a migration object. Because the migration object is virtual, its class needs to be virtual too. The migration class is no real class, it contains only a binding reference to express a full reference path. A migration class can be created by:	#'Core.Array' mgClass	#{Core.Array} mgClassOnly fully qualified names are allowed, because Eurydike needs fully qualified names in the database. If a simple name is used an error will be raised.Instance Variables	binding	&lt;BindingReference&gt;		a binding reference that contains a full qualified name for a class</body></comment><class><name>ModificationDictionary</name><environment>Eurydike</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Modifications</package></attributes></class><comment><class-id>Eurydike.ModificationDictionary</class-id><body>ModificationDictionary is a wrapper for a dictionary instance so that changes on the inner dictionary can be notified to an owner object. The owner is informed by calling #notifyAboutModification. This owner is normally a bag. This is needed so that Eurydike can detect changes on a bag. Everytime an element is added/removed to a bag, the bag does not changes itself, only the inner dictionary of the bag changes.Instance Variables	owner	&lt;anObject&gt;		any object that needs to be notified</body></comment><class><name>ConnectionProfile</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>platform policy environment username password schema version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Core</package></attributes></class><comment><class-id>Eurydike.ConnectionProfile</class-id><body>ConnectionProfile contains the basic connection information like user, password, environment. Additionally it contains a platform, that represents the target SQL platform, so that different SQL dialects can be expressed. The &lt;schema&gt; is used as name for the target table, so that one can have multiple Eurydike databases on one SQL database. Or with other words one can have multiple object spaces on one SQL database. The &lt;policy&gt; defines some rules for database communication. The &lt;version&gt; represents the version of object space that should be read from database. If the version on database does not match an error is raised. The default value of version is the special symbol #any, so that any version is accepted. The user can decide if he uses a number or string or any other object as version in the object space, but the symbol #any is reserved and should not be used for other purposes.Instance Variables	environment		&lt;String&gt;				SQL/EXDI compatible environment 	password		&lt;String&gt;				SQL/EXDI compatible password 	platform			&lt;DatabasePlatform&gt;		a database platform to express different SQL dialects like Oracle, Postgre, etc.	policy			&lt;ConnectionPolicy&gt;		connection policy that describes communication rules	schema			&lt;String&gt;				target schema/table	username		&lt;String&gt;				SQL/EXDI compatible user name	version			&lt;String | Integer&gt;		the version of object space that need to be on database, else an error is raised</body></comment><class><name>DatabasePlatform</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Platforms</package></attributes></class><comment><class-id>Eurydike.DatabasePlatform</class-id><body>DatabasePlatform is an abstract class. A database platform implements protocols to read/write database rows with primitive SQL statements. Subclasses implement the specific SQL syntax for the different SQL dialects like Postgres, Oracle, SQLite etc.Subclasses must implement the following messages:	database api		deleteFieldRowsWithID:on:		insertFieldRows:on:		installSchemaOn:		newObjectIDsFor:on:		retrieveFieldRowsWithID:on:</body></comment><class><name>PostgreSQLPlatform</name><environment>Eurydike</environment><super>Eurydike.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Platforms</package></attributes></class><class><name>Connection</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profile cache modificationTracker surrogates nativeConnection triggerImageGC statistics </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Core</package></attributes></class><comment><class-id>Eurydike.Connection</class-id><body>Connection handles the communication for an Eurydike database. It implements protocols to read/write objects/fieldmaps and primitive SQL execution.A connection is opened on a connection profile, which defines all needed destination parameters like platform, environment, username and password. The connection manages also a cache for objects read from database so that multiple reads of the same object are faster. Modified objects are remembered by a modification tracker. When an object is read from database, it is marked as immutable. The modification tracker handles write accesses to such immutable objects and remembers it for next commit. Only modified objects (remembered by modification tracker) and new objects (referenced by modified objects) arw written in the commit phase.The connection remembers statistical values about objects (like number of proxy resolvings, timestamp of read, ...). Based on that statistic the connection proxify and garbage collect unused objects from image. The connection is bound to the garbage collection mechanism of the virtual machine by using an ephemeron, that acts as a trigger. Everytime when this ephemeron is finialized then the connection runs through the statistics and do the image garbage collect. In practice we could see so far, that the ephemeron is triggered in the same frequency where new objects are created. If no objects are created the durations between the ephemeron finalizes are longer than during phases of much object creations.Instance Variables	cache				&lt;Cache&gt;							cache that hold all known objects	modificationTracker	&lt;ConnectionModificationTracker&gt;	a tracker for tracking modifications on the objects in cache	nativeConnection	&lt;ExternalDatabaseConnection&gt;		primitive EXDI connection	profile				&lt;ConnectionProfile&gt;					profile that contains connection informations	statistics			&lt;Dictionary&gt;						statisticical objects keyed by object id	surrogates			&lt;Dictionary&gt;						dictionary that hold all known surrogates as pairs (ID -&gt; Surrogate)	triggerImageGC		&lt;Ephemeron&gt;						an ephemeron that acts as trigger to catch garbage collection events from virtual machine</body></comment><class><name>SQLDumperConnection</name><environment>Eurydike</environment><super>Eurydike.Connection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dumpOutputStream sequenceID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Core</package></attributes></class><class><name>MigrationObject</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mgClass mgInstanceVariables mgIndexedVariables mgGenericVariables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Migration</package></attributes></class><comment><class-id>Eurydike.MigrationObject</class-id><body>MigrationObject is a virtual represention of a database object. A migration object is instantiated by a migration connection. The migration object acts like the real object as far as possible, so that describing migration steps are easier. As it is not easy to distinguish between a normal send/normal method implementation and the virtual one, the migration object implements a special protocol. All things that means the virtual representation are prefixed by "mg". So if one wants to setup the virtual instance variable "person" in a migration object, one needs to send the message #mgPerson. The part behind #mg is automatically de-capitalized, so that the first character is lowercased and the instance variable #person is stored later on database. The migration object has also all the normal stuff like #mgInstVarAt:, #mgAt:, #mgBasicAt:, #mgGenericAt:. Using these methods avoids compiler warnings, but it often more unreadable as sending a message like #mgPerson.If one needs to iterate over instance variables, indexed variables or generic variables one can use the message #mgInstanceVariables, #mgIndexedVariables and #mgGenericVariables.	migrationObject instanceVariables keysAndValuesDo: [:name :variable | ...]	migrationObject indexedVariables doWithIndex: [:each :index | ...]	migrationObject genericVariables keysAndValuesDo: [:key :value | ...]A migration object can be instantiated in the following ways:	#'Core.Association' mgClass new	#{Core.Association} mgClass new	#{Core.Array} mgClass new: 10Instance Variables	mgClass				&lt;MigrationObjectClass&gt;		the migration class for this migration object	mgGenericVariables		&lt;IdentityDictionary&gt;			a dictionary that contains all generic variables where key and value can be abirtrary objects	mgIndexedVariables		&lt;Array&gt;						an array with indexable variables	mgInstanceVariables	&lt;IndentityDictionary&gt;		a dictionary that contains all instance variables where key is a symbol and value is an abirtrary object</body></comment><class><name>MigrationDictionary</name><environment>Eurydike</environment><super>Eurydike.MigrationObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Migration</package></attributes></class><comment><class-id>Eurydike.MigrationDictionary</class-id><body>MigrationDictionary implements a Dictionary MigrationObject</body></comment><class><name>Cache</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyToValue valueToKey valueIsNew </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Core</package></attributes></class><comment><class-id>Eurydike.Cache</class-id><body>Cache implements functionality to hold objects weakly with their database id.Instance Variables	keyToValue	&lt;Dictionary&gt;	description of keyToValue	valueToKey	&lt;Dictionary&gt;	description of valueToKey</body></comment><class><name>ConnectionPolicy</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceCommitSize recursionDepth rowCommitSize imageGCThreshold </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Core</package></attributes></class><comment><class-id>Eurydike.ConnectionPolicy</class-id><body>ConnectionPolicy describes the rules during communication with an Eurydike database. One can define some properties to optimize the database accesses.Memory Usage:	#imageGCThreshold		The eurydike connection reacts dynamically on garbage collection phases in image. At this time it calculates a list of unmodified objects based on statistical values.	 	This list is sorted by internal criterias so that the most uninteresting objects are placed at first in this list. The parameter &lt;imageGCThreshold&gt; is the percent of		objects from the beginning of that list, which will be used for proxifying and reclaiming. If one do not want that something is swapped out from the image memory, then		this parameter should be zero. The parameter is a percent value in range 0 - 1.	#instanceCommitSize		This property controls how many objects are comitted simultanously. The objects are converted to fieldmaps during the commit and they are memory expensive.		With the property you can control that memory usage, so that only a small portion of fieldmaps are created.	#rowCommitSize		This property controls how many database rows are committed simultanously in one single database command. An object is converted to a fieldmap and that one		is converted to a set of fieldrows. The property defines how many fieldrows are grouped together before a database command is executed.		The #rowCommitSize can be overridden by the corresponding database platform (see ConnectionProfile) in case the given user defined #rowCommitSize exceeds		the possible platform limit #rowCommitLimit.Read Performance:	#recursionDepth		This property controls how deep an object is resolved. A recursion depth of 0 means that only the object is resolved and reference objects are surrogates/proxies.		A recursion depth of 3 means, that the object and references up to level 3 are resolved.Instance Variables	imageGCThreshold		&lt;LimitedPrecisionReal&gt;		number of unmodified objects in percents that will be proxified and garbage collected in the next GC phase	instanceCommitSize	&lt;Integer&gt;					number of objects that are comitted simultanously	recursionDepth			&lt;Integer&gt;					depth of object resolving	rowCommitSize			&lt;Integer&gt;					number of rows that are comitted simultanously</body></comment><class><name>FieldMap</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id value targetClass targetSize targetVersion namedFields indexedFields genericFields timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Fields</package></attributes></class><comment><class-id>Eurydike.FieldMap</class-id><body>FieldMap describes the relevant structure and elements of an object that should be written to the database. With a field map one can describe that only a portion of the instance variables/indexed variables etc. of an object are written. It is assumed that every object can be expressed as a dictionary with key/value pairs. Thus a field map looks like a dictionary, where the elements look like associations. The elements of a field map are called fields. The fields are divided into named fields, indexed fields and generic fields for better debugging/understanding purposes. The named fields are descriptions for instance variables. The indexed fields are descriptions for indexable variables (#basicAt:) or sequenceable collection elements. The generic fields are descriptions for generic typed key/value pairs as they occur in dictionaries, where the key could be any object and not only name symbols or integer indices.Instance Variables	genericFields	&lt;OrderedCollection of Field&gt;		contains all generic typed fields (e.g. key/value pairs from dictionaries)	id				&lt;Integer&gt;						object id on database	indexedFields	&lt;OrderedCollection of Field&gt;		contains all indexable fields (e.g. #basicAt: elements, collection elements)	namedFields	&lt;OrderedCollection of Field&gt;		contains all named fields (e.g. instance variables)	targetClass		&lt;Class&gt;						target class of object that is described by this field map	targetSize		&lt;Integer&gt;						target size of object that is described by this field map	targetVersion	&lt;String&gt;						target version of object that is described by this field map	timestamp		&lt;Timestamp&gt;					UTC timestamp when the object was written to database	value			&lt;Object&gt;						the object that is described by this field map</body></comment><class><name>Reference</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Fields</package></attributes></class><comment><class-id>Eurydike.Reference</class-id><body>Reference is something like a database pointer to another object that understood #id. It is used to express object references between field maps and surrogates. Normally a field map or surrogate would be enough to express that reference, but then either the name "FieldMap", "Surrogate" or the real class type of the object behind of the field map would be written on the database. "FieldMap" or "Surrogate" as type on the database is not really nice, because these classes are internals of Eurydike. If one use the last case with generic full qualified types then one cannot identify easily references anymore on the database in a SQL statement. In such a situation one would need to know all primitive types to identify all references.The solution for that problem is to have this extra class Reference, so that the type "Reference" is written to the database type column. We do not need really the real type of a referenced object, because the referenced object contain it itself in its own fields.A Reference can contain any object that implements #id. On the way from the [object &gt;&gt; fieldmap &gt;&gt; database] the Reference is used to hold a field map. On the way back from the [database &gt;&gt; fieldmap &gt;&gt; object] the Reference hold a proxy.Instance Variables	value	&lt;FieldMap | Surrogate&gt;		referenced object that implements #id</body></comment><class><name>MissingFieldKeyType</name><environment>Eurydike</environment><super>Eurydike.FieldError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Error Handling</package></attributes></class><comment><class-id>Eurydike.MissingFieldKeyType</class-id><body>FieldKeyTypeError is the specialized form of a field type error to describe that the key of the field has an UndefinedFieldType.</body></comment><class><name>ObjectSpaceVersionConflict</name><environment>Eurydike</environment><super>Eurydike.ObjectSpaceError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version targetVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Error Handling</package></attributes></class><comment><class-id>Eurydike.ObjectSpaceVersionConflict</class-id><body>ObjectSpaceVersionConflict is raised when the version of objectspace in database does not match the version in connection profile. The ObjectSpaceVersionConflict is raised first if there is any version conflict, because the version is validated before any object is read from database.Instance Variables	targetVersion	&lt;Object&gt;		contains the target version of connection profile	version			&lt;Object&gt;		contains the version of objectspace in database</body></comment><class><name>FieldMapPrimitiveError</name><environment>Eurydike</environment><super>Eurydike.ObjectSpaceError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Error Handling</package></attributes></class><comment><class-id>Eurydike.FieldMapPrimitiveError</class-id><body>FieldMapPrimitiveError is raised when a field map is created for a primitive type. A primitive type is something like a String, Number, ByteArray where calling the method #asFieldMap raises that error.</body></comment><class><name>ModificationArray</name><environment>Eurydike</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Modifications</package></attributes></class><comment><class-id>Eurydike.ModificationArray</class-id><body>ModificationArray is a wrapper for an array instance so that changes on the inner array can be notified to an owner object. The owner is informed by calling #notifyAboutModification. This owner is normally a IdentityDictionary. This is needed so that Eurydike can detect changes on a IdentityDictionary. Everytime an element is added/removed to a IdentityDictionary, the IdentityDictionary does not changes itself, only the inner array of the IdentityDictionary changes.Instance Variables	owner	&lt;IdentityDictionary&gt;	description of owner</body></comment><class><name>IntegerKeyedEphemeralValueDictionary</name><environment>Eurydike</environment><super>Core.EphemeralValueDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Extensions</package></attributes></class><comment><class-id>Eurydike.IntegerKeyedEphemeralValueDictionary</class-id><body>IntegerKeyedEphemeralValueDictionary are special dictionaries that has small integers as keys. These small integer keys needs a special hash handling, else the dictionary performance is very slow. We call here the hash function #hashMultiply instead of #hash.</body></comment><class><name>SQLDumperPlatform</name><environment>Eurydike</environment><super>Eurydike.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Platforms</package></attributes></class><class><name>MigrationConnection</name><environment>Eurydike</environment><super>Eurydike.Connection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Migration</package></attributes></class><comment><class-id>Eurydike.MigrationConnection</class-id><body>MigrationConnection is a special connection that instantiates migration objects and not the real objects. With the migration objects it is possible to instantiate something without having the class in image.</body></comment><class><name>ObjectSpace</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Core</package></attributes></class><comment><class-id>Eurydike.ObjectSpace</class-id><body>ObjectSpace represents the root object of an Eurydike database. The object space can be subclassed and is used like any other Smalltalk object by defining instance variables and accessors. One can instantiate itself such an object space with an own connection profile by using #newForProfile:. But one can also use the method #newForDefaultProfile. In that case one have just to define the class method #connectionProfile in its own subclass.In Eurydike one do not worry about remembering and manually freeing/deleting of referenced objects like in other database frameworks. Eurydike does this job for you. Every object that is directly or indirectly referenced by an object space is not garbage collected. If you replace an object by another one it could be that the old object still exists on the database until the next global garbage collect is executed. If one retrieve objects by using the object space and its accessors, this does not matter. If one retrieve objects by using #allInstancesOf: you need to consider the same as in a standard Smalltalk image, the old objects could be found too until the next garbage collect.Garbage collection for an object space can be triggered by:	#garbageCollect			-	execute just one incremental step	#globalGarbageCollect	-	execute a full garbage collectInstance Variables	connection	&lt;Connection&gt;	connection for database communication</body></comment><class><name>DatabaseConverter</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceConnection targetConnection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Core</package></attributes></class><comment><class-id>Eurydike.DatabaseConverter</class-id><body>DatabaseConverter converts one Eurydike database to another database. One can choose any source and target connection type. The converter works on the primitive field rows and converts the database 1:1 without any changes.Instance Variables	sourceConnection	&lt;Connection&gt;	the source connection where the data is read from	targetConnection	&lt;Connection&gt;	the target connection where the data is written to</body></comment><class><name>Migrator</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceConnection targetConnection keepMigrating </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Migration</package></attributes></class><comment><class-id>Eurydike.Migrator</class-id><body>Migrator is the tool to migrate an Eurydike database. A migrator implements the basic infrastructure for migration. It has a current version, which needs to be implemented on class side. The migrator class has also functionality to make itself dependent from the publish dialog. These dependents must be returned by class side method #validationDependents. Normally only classes are dependents for validation. When one of these class definitions are changed there is an extra notification dialog opened in front of publish dialog to inform the user about needed version updates. This dialog is just for information and can be ignored by the user if he has already updated the version in migrator and implemented new migration methods for the new version.The migrator runs on a special MigrationConnection, which instantiates only migration objects when something is read from database. Only primitives like strings, integers etc. are expressed in real, but no complex object. The migrator initially reads the object space as migration object and then calls the method #migrateObjectSpace: as entry point. This method needs to return either a new MigrationObjectSpace or the same ObjectSpace. The version of this returned ObjectSpace must not be the same as before.The migrator is only responsible for performing a single migration step. If additional migration steps are required, a new instance of the migrator is created. For that the instanceVariable &lt;keepMigrating&gt; needs to be update accordingly.Subclasses must implement the following messages:	migration		migrateObjectSpace:Instance Variables:	sourceConnection	&lt;Connection&gt;	the source Eurydike connection	targetConnection	&lt;Connection&gt;	the target Eurydike connection	keepMigrating		&lt;Boolean&gt; 	if true, the migration is not complete and a next migration step must be performed</body></comment><class><name>UndefinedFieldType</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Fields</package></attributes></class><comment><class-id>Eurydike.UndefinedFieldType</class-id><body>UndefinedFieldType is a placeholder in fields when a qualified reference of a field row cannot be foundInstance Variables	name	&lt;String&gt;	the name of type, this is normally a full qualified class name	value	&lt;String&gt;	the value of the type that comes from the key/value of field row</body></comment><class><name>MissingNamedField</name><environment>Eurydike</environment><super>Eurydike.FieldError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Error Handling</package></attributes></class><comment><class-id>Eurydike.MissingNamedField</class-id><body>NamedFieldError is raised when the object that is read from database has instance variables that do not exist in the current image anymore. Normally this is a migration issue and the object cannot be instantiated carefully.</body></comment><class><name>FieldMapList</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>allMaps rootMaps newMaps </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Fields</package></attributes></class><comment><class-id>Eurydike.FieldMapList</class-id><body>FieldMapList contains sets of fieldmaps classified by a characteristic. When fieldmaps are read by the Connection there are more fieldmaps read by the recursive database access. All maps and objects are stored in cache, but the caller is only interested in the root-maps, which means the top-level maps and not all the recursive loaded child-maps. The old mechanism in Connection &gt;&gt; buildFieldMapsFrom:roots: returned just the root maps. But now we need also all fieldmaps, which objects are really new and was not before in cache. We need the new objects for sending some post-initialize actions to these objects. Instead of just returning an association rootMaps -&gt; newMaps in Connection &gt;&gt; buildFieldMapsFrom:roots: we created this class here, which has better accessor methods. Currently there are the following characteristics available as accessors:		#allMaps		returns all maps from the fieldmap building process	#rootMaps		returns all root maps from the fieldmap building process	#newMaps		returns all new maps from the buildmap building process, where the object was not in cache before</body></comment><class><name>ModificationAssociation</name><environment>Eurydike</environment><super>Core.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Modifications</package></attributes></class><comment><class-id>Eurydike.ModificationAssociation</class-id><body>ModificationAssociation is a wrapper for an association instance so that changes on the inner association can be notified to an owner object. The owner is informed by calling #notifyAboutModification. This owner is normally a dictionary. This is needed so that Eurydike can detect changes on a dictionary for keys that are already in that. In that case a dictionary does not change itself but its inner association changes.Instance Variables	owner	&lt;anObject&gt;		any object that needs to be notified</body></comment><class><name>ConnectionDialog</name><environment>Eurydike</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profileHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike UI</package></attributes></class><comment><class-id>Eurydike.ConnectionDialog</class-id><body>ConnectionDialog is a dialog for graphical selection of properties of an Eurydike ConnectionProfile. The dialog works directly on an instance of ConnectionProfile to read/write the properties. If the dialog is created with #new then a default empty instance of ConnectionProfile is used. One can also use an own connection profile instance by using the dialog´s creation method #on:	| dialog |	dialog := ConnectionDialog new.	dialog open ifTrue: [dialog profile] ifFalse: [nil]	| profile dialog |	profile := ConnectionProfile new.	profile schema: 'CMS'.	dialog := ConnectionDialog on: profile.	dialog open ifTrue: [dialog profile] ifFalse: [nil].Instance Variables	profileHolder		&lt;ValueHolder on a ConnectionProfile&gt;	this a UI value holder on a ConnectionProfile instance</body></comment><class><name>BadObjectGraphError</name><environment>Eurydike</environment><super>Eurydike.ObjectSpaceError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Error Handling</package></attributes></class><class><name>Statistic</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id numberOfCreations lastCreationTimestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Core</package></attributes></class><comment><class-id>Eurydike.Statistic</class-id><body>Statistic remembers some important things about an object. It remembers the number of creations of a specific object and a creation timestamp, so that others can use that statistical informations to make some decisions which objects can be reclaimed by garbage collector.Instance Variables	id						&lt;Integer&gt;			the id of the object	lastCreationTimestamp	&lt;Timestamp&gt;		the last timestamp where the object was created from database	numberOfCreations		&lt;Integer&gt;			the number of creations where the object was created from database</body></comment><class><name>IntegerKeyedDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Extensions</package></attributes></class><comment><class-id>Core.IntegerKeyedDictionary</class-id><body>IntegerKeyedDictionary are special dictionaries that has small integers as keys. These small integer keys needs a special hash handling, else the dictionary performance is very slow. We call here the hash function #hashMultiply instead of #hash.</body></comment><class><name>SQLite3Platform</name><environment>Eurydike</environment><super>Eurydike.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Platforms</package></attributes></class><comment><class-id>Eurydike.SQLite3Platform</class-id><body>SQLite3Platform is a database platform that implements the SQL syntax for SQLite to read/write database rows.</body></comment><class><name>MigrationCollection</name><environment>Eurydike</environment><super>Eurydike.MigrationObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Migration</package></attributes></class><comment><class-id>Eurydike.MigrationCollection</class-id><body>MigrationCollection represents Migration objects which are actually sequenceable collections.</body></comment><class><name>Field</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>map id type key value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Fields</package></attributes></class><comment><class-id>Eurydike.Field</class-id><body>Field is a description of a variable of an object. The type of a field can be 			#named			(instance variables)	#indexed		(indexable variables)	#generic 		(generic typed variables, where the key is any object)or one of the meta fields 	#classAndSize				(key = class, value = size)	#versionAndTimestamp		(key = version, value = timestamp)The meta fields are compressed in key/value pairs to save space.The key/value of a field can be any of the primitive types like Symbol, String, Number, Time etc. or a Reference.Instance Variables	id		&lt;Integer&gt;					field id in database	key		&lt;Primitive | Reference&gt;		primitive or reference object	map	&lt;FieldMap&gt;					field map that contains this field	type	&lt;Symbol&gt;					field type in database	value	&lt;Primitive | Reference&gt;		primitive or reference object</body></comment><class><name>CommitUnit</name><environment>Eurydike</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection pendingObjects processedObjects flushableFieldMaps commitSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Core</package></attributes></class><comment><class-id>Eurydike.CommitUnit</class-id><body>CommitUnit does the real commit job. It gets an initial list of pending objects (the modified objects from modification tracker) and does all the necessary things for traversing these objects down to find new objects, building field maps and commit them in chunks. It also recognizes when proxies/surrogates from other connections come in and resolves them before comitting it to the new connection.Usage:	(CommitUnit newForConnection: yourConnection) commitInstance Variables:	commitSize		&lt;Integer&gt;			the chunk size for committing objects	connection			&lt;Connection&gt;		the connection where we should commit	flushableFieldMaps	&lt;Collection&gt;		the current list of uncommitted fieldmaps	pendingObjects		&lt;OrderedCollection&gt;	the list of pending objects that must be processed	processedObjects	&lt;Collection&gt;		the list of processed objects</body></comment><class><name>Surrogate</name><environment>Eurydike</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars>id connection ownerIDs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Eurydike Core</package></attributes></class><comment><class-id>Eurydike.Surrogate</class-id><body>Surrogate is an object which is not yet resolved from database. A surrogate knows only its connection and the ID of the object that should be resolved. As soon one sends a message to the surrogate it resolves the object automatically and replaces itself with that object in the system.Instance Variables	connection	&lt;Connection&gt;		connection for database communication	id			&lt;Integer&gt;			database id of object</body></comment><shared-variable><name>AccessLock</name><environment>Eurydike.Connection</environment><private>false</private><constant>false</constant><category>access locks</category><initializer>RecursionLock new</initializer><attributes><package>Eurydike Core</package></attributes></shared-variable><methods><class-id>Eurydike.ObjectSpaceError</class-id> <category>accessing</category><body package="Eurydike Error Handling">subject	^subject</body><body package="Eurydike Error Handling">subject: anObject	subject := anObject</body></methods><methods><class-id>Eurydike.ObjectSpaceError class</class-id> <category>instance creation</category><body package="Eurydike Error Handling">subject: anObject	^self new subject: anObject</body></methods><methods><class-id>Eurydike.FieldError</class-id> <category>accessing</category><body package="Eurydike Error Handling">field	^field</body><body package="Eurydike Error Handling">field: aField	field := aField</body></methods><methods><class-id>Eurydike.FieldError class</class-id> <category>instance creation</category><body package="Eurydike Error Handling">newWithField: aField	^self new field: aField</body></methods><methods><class-id>Eurydike.ConnectionModificationTracker</class-id> <category>accessing</category><body package="Eurydike Modifications">connection	^connection key</body><body package="Eurydike Modifications">connection: aConnection	"We need an ephemeron on our connection, because the tracker itself is strong referenced in the Trackers registry.	 The ephemeron causes that the connection can be garbage collectable."	connection := Ephemeron key: aConnection</body></methods><methods><class-id>Eurydike.ConnectionModificationTracker</class-id> <category>initialize-release</category><body package="Eurydike Modifications">flush	self initializeModifications</body><body package="Eurydike Modifications">initialize	modifications := IdentitySet new</body><body package="Eurydike Modifications">initializeModifications	modifications := IdentitySet new</body></methods><methods><class-id>Eurydike.ConnectionModificationTracker</class-id> <category>accessing modifications</category><body package="Eurydike Modifications">isModified: anObject	^self modifications includes: anObject</body><body package="Eurydike Modifications">markAsModified: anObject	self modifications add: anObject.	anObject beMutable</body><body package="Eurydike Modifications">markAsModified: anObject selector: aSelector index: anIndex value: aValue	aSelector = #instVarAt:put:		ifTrue: 			[| instVarName |			instVarName := anObject class allInstVarNames at: anIndex.			(anObject class allFieldVarNames includes: instVarName)				ifTrue: [self markAsModified: anObject]]		ifFalse: [self markAsModified: anObject]</body><body package="Eurydike Modifications">markAsUnmodified: anObject	anObject notifyMarkAsUnmodified.	self modifications remove: anObject ifAbsent: [].	anObject isSurrogate ifTrue: [self halt].	anObject beImmutable</body><body package="Eurydike Modifications">modifications	^modifications</body></methods><methods><class-id>Eurydike.ConnectionModificationTracker</class-id> <category>private</category><body package="Eurydike Modifications">applyModificationTo: anObject selector: selector index: index value: value	self connection accessCritical: 			[self				markAsModified: anObject				selector: selector				index: index				value: value.			super				applyModificationTo: anObject				selector: selector				index: index				value: value]</body><body package="Eurydike Modifications">privateTrack: anObject	^self</body><body package="Eurydike Modifications">privateUntrack: anObject	^self</body></methods><methods><class-id>Eurydike.ConnectionModificationTracker</class-id> <category>api - tracking</category><body package="Eurydike Modifications">isTracking: anObject	^self connection isCached: anObject</body></methods><methods><class-id>Eurydike.ConnectionModificationTracker</class-id> <category>testing</category><body package="Eurydike Modifications">hasModifications	^self modifications notEmpty</body></methods><methods><class-id>Eurydike.ConnectionModificationTracker class</class-id> <category>instance creation</category><body package="Eurydike Modifications">new	^super new initialize</body><body package="Eurydike Modifications">newForConnection: aConnection	^self new connection: aConnection</body></methods><methods><class-id>Eurydike.FieldRow</class-id> <category>accessing</category><body package="Eurydike Fields">asDictionary	^Dictionary		withAll: (#(#objectID #fieldID #fieldType #keyType #key #valueType #value)				collect: [:each | each -&gt; (self perform: each)])</body><body package="Eurydike Fields">fieldID	^fieldID</body><body package="Eurydike Fields">fieldID: aString	fieldID := aString</body><body package="Eurydike Fields">fieldType	^fieldType</body><body package="Eurydike Fields">fieldType: aString	fieldType := aString</body><body package="Eurydike Fields">key	^key</body><body package="Eurydike Fields">key: aString	key := aString</body><body package="Eurydike Fields">keyType	^keyType</body><body package="Eurydike Fields">keyType: aString	keyType := aString</body><body package="Eurydike Fields">objectID	^objectID</body><body package="Eurydike Fields">objectID: aString	objectID := aString</body><body package="Eurydike Fields">value	^value</body><body package="Eurydike Fields">value: aString	value := aString</body><body package="Eurydike Fields">valueType	^valueType</body><body package="Eurydike Fields">valueType: aString	valueType := aString</body></methods><methods><class-id>Eurydike.FieldRow</class-id> <category>converting</category><body package="Eurydike Fields">asField	^Field fromFieldRow: self</body></methods><methods><class-id>Eurydike.MigrationObjectClass</class-id> <category>testing class hierarchy</category><body package="Eurydike Migration">includesBehavior: aClass	^false</body></methods><methods><class-id>Eurydike.MigrationObjectClass</class-id> <category>accessing fields</category><body package="Eurydike Migration">asFieldMap	self		cannotBeExpressedAsFieldRow: (#classes &lt;&lt; #eurydike &gt;&gt; 'classes') asString</body><body package="Eurydike Migration">asFieldProperty	^self</body><body package="Eurydike Migration">asFieldRowProperty	^self fullName</body><body package="Eurydike Migration">asFieldRowType	^'&lt;1s&gt; class' asIs expandMacrosWith: self fullName</body></methods><methods><class-id>Eurydike.MigrationObjectClass</class-id> <category>accessing</category><body package="Eurydike Migration">binding	^binding</body><body package="Eurydike Migration">binding: aBindingReference	binding := aBindingReference</body><body package="Eurydike Migration">environmentName	^self binding environmentName</body><body package="Eurydike Migration">fullName	^self binding fullName</body><body package="Eurydike Migration">name	^self simpleName</body><body package="Eurydike Migration">simpleName	^self binding simpleName</body></methods><methods><class-id>Eurydike.MigrationObjectClass</class-id> <category>instance creation</category><body package="Eurydike Migration">new	^((MigrationObject classFor: self) new)		mgClass: self;		yourself</body><body package="Eurydike Migration">new: aSize	^((MigrationObject classFor: self) new: aSize)		mgClass: self;		yourself</body><body package="Eurydike Migration">newEmptyFromFieldMap: aFieldMap	^self new: aFieldMap targetSize</body></methods><methods><class-id>Eurydike.MigrationObjectClass</class-id> <category>literal array</category><body package="Eurydike Migration">buildFromSlar: anArray</body></methods><methods><class-id>Eurydike.MigrationObjectClass</class-id> <category>printing</category><body package="Eurydike Migration">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self name;		nextPut: $)</body></methods><methods><class-id>Eurydike.MigrationObjectClass</class-id> <category>converting</category><body package="Eurydike Migration">asSystemClass	^self binding valueOrDo: [nil]</body></methods><methods><class-id>Eurydike.MigrationObjectClass</class-id> <category>comparing</category><body package="Eurydike Migration">= anObject	self class = anObject class ifFalse: [^false].	^self binding = anObject binding</body></methods><methods><class-id>Eurydike.MigrationObjectClass class</class-id> <category>instance creation fields</category><body package="Eurydike Migration">fromFieldRowProperty: aString	^self newForBinding: aString asQualifiedReference</body><body package="Eurydike Migration">newForBinding: aBindingReference	^self new binding: aBindingReference</body></methods><methods><class-id>Eurydike.ModificationDictionary</class-id> <category>accessing</category><body package="Eurydike Modifications">at: key put: anObject	self notifyOwnerAboutModification.	^super at: key put: anObject</body><body package="Eurydike Modifications">owner	^owner</body><body package="Eurydike Modifications">owner: anObject	owner := anObject</body></methods><methods><class-id>Eurydike.ModificationDictionary</class-id> <category>dictionary removing</category><body package="Eurydike Modifications">removeKey: key ifAbsent: aBlock 		self notifyOwnerAboutModification.	^super removeKey: key ifAbsent: aBlock</body></methods><methods><class-id>Eurydike.ModificationDictionary</class-id> <category>notifications</category><body package="Eurydike Modifications">notifyOwnerAboutModification	self owner ifNotNil: [self owner notifyAboutModification]</body></methods><methods><class-id>Eurydike.ModificationDictionary</class-id> <category>adding</category><body package="Eurydike Modifications">add: anAssociation 		self notifyOwnerAboutModification.	^super add: anAssociation</body></methods><methods><class-id>Eurydike.ModificationDictionary</class-id> <category>copying</category><body package="Eurydike Modifications">copyEmpty: aSize	^(self class new: aSize)		owner: self owner;		yourself</body></methods><methods><class-id>Eurydike.ConnectionProfile</class-id> <category>accessing</category><body package="Eurydike Core">environment	^environment</body><body package="Eurydike Core">environment: aString	environment := aString</body><body package="Eurydike Core">password	^password</body><body package="Eurydike Core">password: aString	password := aString</body><body package="Eurydike Core">platform	^platform</body><body package="Eurydike Core">platform: aDatabasePlatform	platform := aDatabasePlatform</body><body package="Eurydike Core">platformClass	^self platform class</body><body package="Eurydike Core">platformClass: aDatabasePlatformClass	self platform: aDatabasePlatformClass new</body><body package="Eurydike Core">policy	^policy</body><body package="Eurydike Core">policy: aConnectionPolicy	policy := aConnectionPolicy</body><body package="Eurydike Core">schema	^schema</body><body package="Eurydike Core">schema: aString	schema := aString</body><body package="Eurydike Core">username	^username</body><body package="Eurydike Core">username: aString	username := aString</body><body package="Eurydike Core">version	^version</body><body package="Eurydike Core">version: anObject	version := anObject</body></methods><methods><class-id>Eurydike.ConnectionProfile</class-id> <category>private field rows</category><body package="Eurydike Core">rowCommitSize	^self policy rowCommitSize min: self platform rowCommitLimit</body></methods><methods><class-id>Eurydike.ConnectionProfile</class-id> <category>connect/disconnect</category><body package="Eurydike Core">newNativeConnection	| nativeConnection |	nativeConnection := platform newNativeConnection.	nativeConnection environment: self environment.	nativeConnection username: self username.	nativeConnection password: self password.	^nativeConnection</body></methods><methods><class-id>Eurydike.ConnectionProfile</class-id> <category>initialize-release</category><body package="Eurydike Core">initialize	super initialize.	self policy: ConnectionPolicy new.	self schema: self class defaultSchema.	self version: #any</body></methods><methods><class-id>Eurydike.ConnectionProfile</class-id> <category>printing</category><body package="Eurydike Core">printOn: aStream	super printOn: aStream.	aStream		space;		print: self environment</body></methods><methods><class-id>Eurydike.ConnectionProfile class</class-id> <category>instance creation</category><body package="Eurydike Core">new	^super new initialize</body></methods><methods><class-id>Eurydike.ConnectionProfile class</class-id> <category>accessing</category><body package="Eurydike Core">defaultSchema	^'fields' asIs</body></methods><methods><class-id>Eurydike.DatabasePlatform</class-id> <category>accessing</category><body package="Eurydike Platforms">bindingParameterLimit	^self subclassResponsibility</body><body package="Eurydike Platforms">nativeConnectionClass	^self class nativeConnectionClass</body><body package="Eurydike Platforms">rowCommitLimit	^(self bindingParameterLimit / 7) asInteger</body></methods><methods><class-id>Eurydike.DatabasePlatform</class-id> <category>garbage collecting</category><body package="Eurydike Platforms">garbageCollectOn: aConnection	| expression |	expression := self exprGarbageCollectOn: aConnection.	aConnection executeSQLString: expression</body><body package="Eurydike Platforms">globalGarbageCollectOn: aConnection	| expression |	expression := self exprGlobalGarbageCollectOn: aConnection.	aConnection executeSQLString: expression</body></methods><methods><class-id>Eurydike.DatabasePlatform</class-id> <category>accessing schema</category><body package="Eurydike Platforms">installSchemaOn: aConnection	^self subclassResponsibility</body><body package="Eurydike Platforms">newObjectIDsFor: anArray on: aConnection	^self subclassResponsibility</body><body package="Eurydike Platforms">removeSchemaOn: aConnection	^self subclassResponsibility</body></methods><methods><class-id>Eurydike.DatabasePlatform</class-id> <category>accessing field rows</category><body package="Eurydike Platforms">buildFieldRowsFrom: aRecordArray	^aRecordArray collect: 			[:record |			(FieldRow new)				objectID: record first;				fieldID: (record at: 2);				fieldType: (record at: 3);				keyType: (record at: 4);				key: (record at: 5);				valueType: (record at: 6);				value: (record at: 7);				yourself]</body><body package="Eurydike Platforms">deleteFieldRowsWithID: anArray on: aConnection	| expression |	anArray isEmpty ifTrue: [^self].	expression := self exprDeleteFieldRowsWithIDs: anArray on: aConnection.	aConnection executeSQLString: expression</body><body package="Eurydike Platforms">fieldRowRecordsWithIDs: anArray on: aConnection	| records |	anArray isEmpty ifTrue: [^#()].	records := aConnection				executeSQLString: (self exprFieldRowsWithIDs: anArray on: aConnection).	^records</body><body package="Eurydike Platforms">fieldRowRecordsWithIDs: anArray on: aConnection depth: depth	| records |	anArray isEmpty ifTrue: [^#()].	records := aConnection				executeSQLString: (self exprFieldRowsWithIDs: anArray on: aConnection depth: depth).	^records</body><body package="Eurydike Platforms">fieldRowUpdatesOn: aConnection	| records |	records := aConnection				executeSQLString: (self exprLastFieldRowUpdateOn: aConnection).	^records collect: [:array | Timestamp fromFieldRowProperty: array first]</body><body package="Eurydike Platforms">fieldRowsSinceTimestamp: aTimestamp on: aConnection	| rowIDs |	rowIDs := self rowIDsSinceTimestamp: aTimestamp on: aConnection.	^self fieldRowsWithIDs: rowIDs asSet on: aConnection depth: 0.</body><body package="Eurydike Platforms">fieldRowsWithIDs: anArray on: aConnection	| records |	records := self fieldRowRecordsWithIDs: anArray on: aConnection.	^self buildFieldRowsFrom: records</body><body package="Eurydike Platforms">fieldRowsWithIDs: anArray on: aConnection depth: depth	| records |	records := self fieldRowRecordsWithIDs: anArray on: aConnection depth: depth.	^self buildFieldRowsFrom: records</body><body package="Eurydike Platforms">insertFieldRows: anArray on: aConnection	| bindStream expression |	anArray isEmpty ifTrue: [^self].	bindStream := WriteStream on: (OrderedCollection new: anArray size * 7).	anArray do: 			[:row |			bindStream				nextPut: row objectID;				nextPut: row fieldID;				nextPut: row fieldType;				nextPut: row keyType;				nextPut: row key;				nextPut: row valueType;				nextPut: row value].	expression := self exprInsertFieldRows: anArray on: aConnection.	aConnection executeSQLString: expression bindings: bindStream contents</body><body package="Eurydike Platforms">lastFieldRowUpdateOn: aConnection	| timestamps |	timestamps := self fieldRowUpdatesOn: aConnection.	timestamps isEmpty ifTrue: [^Timestamp new].	^timestamps sorted last</body><body package="Eurydike Platforms">numberOfRowsRecordsSinceTimestamp: aTimestamp on: aConnection	^(self rowIDsSinceTimestamp: aTimestamp on: aConnection) size</body><body package="Eurydike Platforms">rowIDsSinceTimestamp: aTimestamp on: aConnection	| newerTimestamps |	newerTimestamps := (self fieldRowUpdatesOn: aConnection)				reject: [:each | each &lt;= aTimestamp].	^newerTimestamps isEmpty		ifTrue: [#()]		ifFalse: [self rowIDsWithTimestamps: newerTimestamps on: aConnection]</body><body package="Eurydike Platforms">rowIDsWithTimestamps: newerTimestamps on: aConnection	| records |	records := aConnection				executeSQLString: (self exprIDsOfRowsWithTimestampsIn: newerTimestamps						on: aConnection).	^records collect: [:each | each first asNumber]</body></methods><methods><class-id>Eurydike.DatabasePlatform</class-id> <category>connect/disconnect</category><body package="Eurydike Platforms">newNativeConnection	^self nativeConnectionClass new</body></methods><methods><class-id>Eurydike.DatabasePlatform</class-id> <category>accessing expressions</category><body package="Eurydike Platforms">exprDeleteFieldRowsWithIDs: anArray on: aConnection	| stream |	stream := WriteStream on: (String new: 256).	stream		nextPutAll: 'DELETE FROM ' asIs;		nextPutAll: aConnection profile schema;		nextPutAll: ' WHERE objectid IN ' asIs.	self printArray: anArray asSQLOn: stream.	^stream contents</body><body package="Eurydike Platforms">exprFieldRowsWithIDs: anArray on: aConnection	^self		exprFieldRowsWithIDs: anArray		on: aConnection		depth: aConnection profile policy recursionDepth</body><body package="Eurydike Platforms">exprFieldRowsWithIDs: anArray on: aConnection depth: depth	^self		exprFieldRowsWithIDs: anArray		schema: aConnection profile schema		depth: depth</body><body package="Eurydike Platforms">exprFieldRowsWithIDs: anArray schema: aSchema	| stream |	stream := WriteStream on: (String new: 256).	stream		nextPutAll: 'SELECT DISTINCT base.objectid, base.fieldid, base.fieldtype, base.keytype, base.key, base.valuetype, base.value FROM '	asIs;		nextPutAll: aSchema;		nextPutAll: ' "base" WHERE objectid IN ' asIs.	self printArray: anArray asSQLOn: stream.	^stream contents</body><body package="Eurydike Platforms">exprFieldRowsWithIDs: anArray schema: aSchema depth: aDepth	aDepth &lt;= 0		ifTrue: [^self exprFieldRowsWithIDs: anArray schema: aSchema].	^'SELECT DISTINCT current.objectid, current.fieldid, current.fieldtype, current.keytype, current.key, current.valuetype, current.value		FROM			&lt;1s&gt; "current",			(&lt;2s&gt;) "base"		WHERE			base.objectid = current.objectid OR			(base.keytype = &lt;3p&gt; AND base.key = current.objectid) OR			(base.valuetype = &lt;3p&gt; AND base.value = current.objectid)'	asIs		expandMacrosWith: aSchema		with: (self				exprFieldRowsWithIDs: anArray				schema: aSchema				depth: aDepth - 1)		with: Reference asFieldRowProperty</body><body package="Eurydike Platforms">exprGarbageCollectOn: aConnection	"This is an incremental garbage collect. It looks for all rows that has the &lt;Reference&gt; keytype or valuetype. The key or value is then the ID of	  the referenced object. The SQL command deletes then all IDs that are NOT in that found list of IDs. It excludes also the root object space from	  that deletion. After that operation it can be that other objects are not referenced anymore, because they were referenced by objects	  that we have deleted by this operation."	^'DELETE FROM &lt;1s&gt;		WHERE objectid != &lt;2p&gt; 			AND objectid NOT IN (				SELECT DISTINCT base.key FROM &lt;1s&gt; "base" WHERE base.keytype = &lt;3p&gt;					UNION				SELECT DISTINCT base.value FROM &lt;1s&gt; "base" WHERE base.valuetype = &lt;3p&gt;)'	asIs		expandMacrosWith: aConnection profile schema		with: aConnection defaultObjectSpaceID printString		with: Eurydike.Reference asFieldRowProperty</body><body package="Eurydike Platforms">exprGlobalGarbageCollectOn: aConnection	^'DELETE FROM &lt;1s&gt; WHERE objectID NOT IN (			SELECT * FROM				(WITH RECURSIVE refs(id) AS					(SELECT base.objectID FROM test "base" WHERE objectID = &lt;2p&gt;						UNION ALL							SELECT next.key FROM &lt;1s&gt; "next", refs 								WHERE next.keytype = &lt;3p&gt; AND next.objectID = refs.id)				SELECT * FROM refs) keyrefs			UNION ALL			SELECT * FROM				(WITH RECURSIVE refs(id) AS					(SELECT base.objectID FROM test "base" WHERE objectID = &lt;2p&gt;						UNION ALL							SELECT next.value FROM &lt;1s&gt; "next", refs 								WHERE next.valuetype = &lt;3p&gt; AND next.objectID = refs.id)				SELECT * FROM refs) valuerefs)'	asIs		expandMacrosWith: aConnection profile schema		with: aConnection defaultObjectSpaceID printString		with: Eurydike.Reference asFieldRowProperty</body><body package="Eurydike Platforms">exprIDsOfRowsWithTimestampsIn: timestamps on: aConnection	| ws |	ws := String new writeStream.	self printArray: (timestamps collect: #asFieldRowProperty) asSQLOn: ws.	^'select objectID from &lt;1s&gt; where fieldtype = "versionAndTimestamp" and value in &lt;2s&gt;'	asIs		expandMacrosWith: aConnection profile schema		with: ws contents</body><body package="Eurydike Platforms">exprInsertFieldRows: anArray on: aConnection	| stream |	stream := WriteStream on: (String new: 1024).	stream		nextPutAll: 'INSERT INTO ' asIs;		nextPutAll: aConnection profile schema;		nextPutAll: ' (objectid, fieldid, fieldtype, keytype, key, valuetype, value) VALUES '	asIs.	anArray do: 			[:row |			stream				nextPutAll: '(?, ?, ?, ?, ?, ?, ?)' asIs]		separatedBy: 			[stream				nextPut: $,;				cr].	^stream contents</body><body package="Eurydike Platforms">exprLastFieldRowUpdateOn: aConnection	^'select distinct value from &lt;1s&gt; where fieldtype = "versionAndTimestamp"'	asIs		expandMacrosWith: aConnection profile schema</body><body package="Eurydike Platforms">printArray: anArray asSQLOn: stream	| string |	stream nextPut: $(.	anArray do: 			[:each |			string := each isString ifTrue: [each] ifFalse: [each printString].			stream print: string]		separatedBy: 			[stream				nextPut: $,;				space].	stream nextPut: $)</body></methods><methods><class-id>Eurydike.DatabasePlatform</class-id> <category>validation</category><body package="Eurydike Platforms">validateOn: aConnection	^true</body></methods><methods><class-id>Eurydike.DatabasePlatform class</class-id> <category>accessing</category><body package="Eurydike Platforms">nativeConnectionClass	^self subclassResponsibility</body></methods><methods><class-id>Eurydike.PostgreSQLPlatform</class-id> <category>accessing</category><body package="Eurydike Platforms">bindingParameterLimit	^34464</body></methods><methods><class-id>Eurydike.PostgreSQLPlatform</class-id> <category>accessing schema</category><body package="Eurydike Platforms">installSchemaOn: aConnection	aConnection		executeSQLString: ('CREATE TABLE &lt;1s&gt; (  								objectid character varying,  								fieldid character varying,  								fieldtype character varying,  								keytype character varying,  								key character varying,  								valuetype character varying,  								value character varying)'	asIs				expandMacrosWith: aConnection profile schema)		onError: [].	aConnection executeSQLString: ('CREATE SEQUENCE &lt;1s&gt;_seq' asIs				expandMacrosWith: aConnection profile schema)		onError: []</body><body package="Eurydike Platforms">newObjectIDsFor: anArray on: aConnection	| records |	records := aConnection				executeSQLString: ('SELECT nextval(''&lt;1s&gt;_seq'') FROM generate_series(1, &lt;2p&gt;)' asIs						expandMacrosWith: aConnection profile schema						with: anArray size).	^records collect: [:each | each first]</body><body package="Eurydike Platforms">removeSchemaOn: aConnection	aConnection executeSQLString: ('DROP TABLE &lt;1s&gt;' asIs				expandMacrosWith: aConnection profile schema)		onError: [].	aConnection executeSQLString: ('DROP SEQUENCE &lt;1s&gt;_seq' asIs				expandMacrosWith: aConnection profile schema)		onError: []</body></methods><methods><class-id>Eurydike.PostgreSQLPlatform class</class-id> <category>accessing</category><body package="Eurydike Platforms">nativeConnectionClass	^#{PostgreSQLEXDIConnection}		valueOrDo: [#{PostgresSocketConnection} value]</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>accessing</category><body package="Eurydike Core">cache	^cache</body><body package="Eurydike Core">environment	^profile ifNotNil: #environment</body><body package="Eurydike Core">lastFieldRowUpdate	^self profile platform lastFieldRowUpdateOn: self</body><body package="Eurydike Core">modificationTracker	^modificationTracker</body><body package="Eurydike Core">profile	^profile</body><body package="Eurydike Core">profile: anObject	profile := anObject</body><body package="Eurydike Core">surrogates	^surrogates</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>private conflicts</category><body package="Eurydike Core">notifyConflicts: anArray</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>garbage collecting</category><body package="Eurydike Core">garbageCollect	^self profile platform garbageCollectOn: self</body><body package="Eurydike Core">globalGarbageCollect	^self profile platform globalGarbageCollectOn: self</body><body package="Eurydike Core">imageGarbageCollect	"Currently commented out, because it makes to much trouble during drag/drop on SeaBreeze websites when objects are proxified	| objectsForGC |	objectsForGC := self bestObjectsForGarbageCollect.	objectsForGC do: [:each | self proxifyInstance: each]"</body><body package="Eurydike Core">mournKeyOf: anEphemeron	self imageGarbageCollect.	anEphemeron isActiveEphemeron: true</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>private field rows</category><body package="Eurydike Core">deleteFieldRowsWithIDs: anArray	self profile platform deleteFieldRowsWithID: anArray on: self</body><body package="Eurydike Core">fieldRowsSinceTimestamp: aTimestamp	^self profile platform fieldRowsSinceTimestamp: aTimestamp		on: self</body><body package="Eurydike Core">fieldRowsWithIDs: anArray	^self profile platform fieldRowsWithIDs: anArray on: self</body><body package="Eurydike Core">insertFieldRows: anArray	| rowCommitSize stream |	rowCommitSize := profile rowCommitSize.	stream := anArray readStream.	[stream atEnd] whileFalse: 			[| partialRows |			partialRows := stream nextAvailable: rowCommitSize.			self profile platform insertFieldRows: partialRows on: self]</body><body package="Eurydike Core">numberOfRowsSinceTimestamp: aTimestamp	^self profile platform numberOfRowsRecordsSinceTimestamp: aTimestamp		on: self</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>private field maps</category><body package="Eurydike Core">assignEmptyValuesToFieldMaps: anArray	"After merging of fieldmaps and assigning of values to them, there can be a rest of fieldmaps, which have no value yet.	 These fieldmaps are completely new from database and never read before. We need to initialize an empty instance to	 these fieldmaps so that we have one when the cache or the surrogate list is updated. We need to initialize these values	 later (after cache update), because the initialization can trigger other surrogate resolvings. We need to update our cache	 with the current fieldmaps until these new surrogates are triggered. Else we get problems with object identities, because	 some objects can be created twice (cache miss)."	anArray		do: [:map | map value: (map targetClass newEmptyFromFieldMap: map)]</body><body package="Eurydike Core">assignIDsToFieldMaps: anArray	"A fieldmap needs a valid database ID for commit. Either we find the &lt;value&gt; of the fieldmap in our cache and	 use that ID or we let generate the database a new one. The given &lt;anArray&gt; is a collection of fieldmaps	 where we want to assign the IDs to each of them."	| allObjects allObjectsAndIDs newObjects newIDs |	allObjects := IdentitySet new.	anArray do: 			[:map |			allObjects add: map value.			map references do: 					[:reference |					reference value looksLikeSurrogate						ifFalse: [allObjects add: reference value value]]].	allObjectsAndIDs := IdentityDictionary new.	allObjects		do: [:each | allObjectsAndIDs at: each put: (self cache keyAtValue: each)].	newObjects := (allObjectsAndIDs select: #isNil) keys asArray.	newIDs := self profile platform newObjectIDsFor: newObjects on: self.	newObjects with: newIDs do: [:obj :id | allObjectsAndIDs at: obj put: id].	anArray do: 			[:map |			map id: (allObjectsAndIDs at: map value).			map references do: 					[:reference |					reference value looksLikeSurrogate						ifFalse: [reference value id: (allObjectsAndIDs at: reference value value)]]]</body><body package="Eurydike Core">assignTimestampsToFieldMaps: anArray	"A fieldmap is comitted with a current UTC timestamp, so that everybody know on database when the rows	 where comitted. This timestamp can be then used to synchronize the database with cache and find conflicts.	 The given &lt;anArray&gt; is a collection of fieldmaps where we want to assign a timestamp to each of them."	| utc |	utc := Timestamp nowUTC.	anArray do: [:map | map timestamp: utc]</body><body package="Eurydike Core">assignValueToFieldMap: aFieldMap	"When we read back fieldmaps from the database we need to find a valid &lt;value&gt; for them.	 Either we find that &lt;value&gt; in our cache under the given ID, then we assign that &lt;value&gt;.	 Or we look if the given fieldmap will be a surrogate. In that case we lookup in our list of	 registered surrogates to assign that surrogate. This causes that only one surrogate instance	 with one ID lives in the whole system, which makes it possible to do a simple #become: instead	 of #oneWayBecome: for surrogates. If there is no surrogate found the surrogate of the fieldmap	 is registered automatically."	aFieldMap value: (self cache at: aFieldMap id				ifAbsent: 					[aFieldMap looksLikeSurrogate						ifTrue: 							[self surrogates at: aFieldMap id								ifAbsentPut: [(Surrogate withID: aFieldMap id) initializeWithConnection: self]]						ifFalse: [nil]])</body><body package="Eurydike Core">assignValuesToFieldMaps: anArray	"When we have retrieved fieldmaps from the database and merged them we need to assign a valid &lt;value&gt;	 to each of them and to each of their direct references. Indirect references does not matter after merging fieldmaps,	 because all indirect fieldmaps are in &lt;anArray&gt; or the references point to fieldmaps that will be surrogates. If a	 reference will be a surrogate there is no deeper reference anymore. That is the reason why we need to look	 only to all fieldmaps in &lt;anArray&gt; and all direct references."	anArray do: 			[:map |			self assignValueToFieldMap: map.			map references				do: [:reference | self assignValueToFieldMap: reference value]]</body><body package="Eurydike Core">buildFieldMapsFrom: aFieldRowArray roots: aRootBlock	"We create fieldmaps from the given rows and update our internal structures and cache. Please have a look at the comments of the methods that here are called.	 This gives you more detailed information why the given execution order is important and should not be changed."	self accessCritical: 			[| fieldMapList flattenMaps rootMaps unassignedMaps |			fieldMapList := FieldMapList new.			flattenMaps := FieldMap fromMultipleFieldRows: aFieldRowArray.			fieldMapList allMaps: flattenMaps.			self mergeReferencesWithinFieldMaps: flattenMaps.			self validateFieldMaps: flattenMaps.			self assignValuesToFieldMaps: flattenMaps.			unassignedMaps := flattenMaps reject: #hasValue.			fieldMapList newMaps: unassignedMaps.			self assignEmptyValuesToFieldMaps: unassignedMaps.			self updateSurrogatesWithReadFieldMaps: flattenMaps.			self updateCacheWithFieldMaps: flattenMaps.			self initializeEmptyValuesOfFieldMaps: unassignedMaps.			self updateModificationsWithFieldMaps: flattenMaps.			self updateStatisticsWithFieldMaps: flattenMaps.			rootMaps := flattenMaps select: aRootBlock.			fieldMapList rootMaps: rootMaps.			^fieldMapList]</body><body package="Eurydike Core">commitFieldMaps: anArray	self assignIDsToFieldMaps: anArray.	self assignTimestampsToFieldMaps: anArray.	self transact: 			[self deleteFieldMaps: anArray.			self insertFieldMaps: anArray].	self updateCacheWithFieldMaps: anArray.	self updateSurrogatesWithCommittedFieldMaps: anArray.	self updateModificationsWithFieldMaps: anArray.</body><body package="Eurydike Core">conflictsForFieldMaps: anArray	^self error: (#notYetImplementedFully &lt;&lt; #eurydike &gt;&gt; 'not yet implemented fully')	asString"	| conflicts registry |	registry := IdentityDictionary new.	conflicts := OrderedCollection new.	anArray do: 			[:map |			(self cache undoAt: map id)				ifNotNil: 					[:undo |					(undo asFieldMapUsing: registry) = map						ifFalse: 							[| value dbValue |							value := map value.							map value: nil.							dbValue := map value.							conflicts add: ((Conflict new)										value: value;										newValue: dbValue;										undo: undo;										yourself)]]].	^conflicts"</body><body package="Eurydike Core">conflictsForTransientFieldMaps: anArray	"The given fieldmaps are transient. This means the fieldmaps are just now created from its assigned &lt;value&gt;. So there is no difference	 between the fieldmap and its &lt;value&gt;. But when we retrieve the newest things from database as fieldmaps and initialize these	 database fieldmaps with the same &lt;value&gt;, then we can find possible differences."	| valuesByID rows dbMaps |	valuesByID := Dictionary new.	anArray do: [:map | valuesByID at: map id put: map value].	rows := self fieldRowsWithIDs: (anArray collect: #id).	dbMaps := FieldMap fromMultipleFieldRows: rows.	dbMaps do: [:map | map value: (valuesByID at: map id)].	^self conflictsForFieldMaps: dbMaps</body><body package="Eurydike Core">deleteFieldMaps: anArray	self deleteFieldMapsWithIDs: (anArray collect: #id)</body><body package="Eurydike Core">deleteFieldMapsWithIDs: anArray	self deleteFieldRowsWithIDs: anArray</body><body package="Eurydike Core">fieldMapsWithIDs: anArray	| rows |	rows := self fieldRowsWithIDs: anArray.	^self buildFieldMapsFrom: rows roots: [:map | anArray includes: map id]</body><body package="Eurydike Core">initializeEmptyValuesOfFieldMaps: anArray	"We initialize here now all values of fieldmaps, that were read new from the database. We have assigned an empty	 value to these fieldmaps for cache and surrogate list update in an earlier step. Now we need to initialize these values	 fully. This initialization can trigger new surrogate resolvings. So it is really important that this functionality is executed	 after the cache is updated. If not the new surrogate resolving does not find probably the right cache entries and generate	 the same objects twice. This would lead then to object identity problems."	anArray do: [:map | map value initializeFromFieldMap: map]</body><body package="Eurydike Core">insertFieldMaps: anArray	| rows |	rows := OrderedCollection new.	anArray do: [:map | rows addAll: map asFieldRows].	self insertFieldRows: rows</body><body package="Eurydike Core">mergeReferencesWithinFieldMaps: anArray	"After retrieving fieldmaps directly from the database we have many references in it which point to fieldmaps	 that will be surrogates. Some of these referenced fieldmaps represent just fieldmaps from &lt;anArray&gt;. Some	 of them represent the same surrogate as another referenced fieldmap. Here we merge these fieldmaps, so that	 the references point to a fieldmap in &lt;anArray&gt; or join the same surrogate fieldmap. This eliminates all surrogates	 effectively where the outcoming &lt;value&gt; is already in the database answer and it removes also all surrogate copies."	| mapsByID |	mapsByID := Dictionary new.	anArray do: [:map | mapsByID at: map id put: map].	anArray do: 			[:map |			map references do: 					[:reference |					| referenceMap |					referenceMap := reference value.					reference						value: (mapsByID at: referenceMap id ifAbsentPut: [reference value])]]</body><body package="Eurydike Core">shouldRealizeSurrogateOfFieldMap: aFieldMap	^aFieldMap looksLikeSurrogate not		and: [self profile policy shouldRealizeSurrogateOfClass: aFieldMap targetClass]</body><body package="Eurydike Core">updateCacheWithFieldMaps: anArray	"Here we update our cache with the given fieldmaps. Surrogates are not cached, they have an	 extra registry directly in the connection."	anArray do: 			[:map |			map looksLikeSurrogate				ifFalse: 					[self cache at: map id put: map value.					self markAsUnmodified: map value.					map references do: 							[:reference |							| refMap |							refMap := reference value.							refMap looksLikeSurrogate								ifFalse: [self cache newAt: refMap id put: refMap value]]]]</body><body package="Eurydike Core">updateModificationsWithFieldMaps: anArray	"Here we need to update our modification tracker, so that all objects of the field maps are registered as unmodified"	anArray		do: [:map | map looksLikeSurrogate ifFalse: [self markAsUnmodified: map value]]</body><body package="Eurydike Core">updateSurrogatesWithCommittedFieldMaps: anArray	"After committing fieldmaps to the database we can look for all objects that does not realize their	 surrogate (see #shouldRealizeSurrogateOfFieldMap:). These objects can be proxified then"	anArray do: 			[:map |			(self shouldRealizeSurrogateOfFieldMap: map)				ifFalse: 					[self surrogates at: map id						ifAbsent: 							[| instance surrogate |							instance := map value.							instance beMutable.							surrogate := (Surrogate withID: map id) initializeWithConnection: self.							self cache at: map id put: surrogate.							self surrogates at: map id put: instance.							surrogate become: instance.							map value: surrogate]]]</body><body package="Eurydike Core">updateSurrogatesWithReadFieldMaps: anArray	"After reading fieldmaps from the database we can remove all surrogates from our registry and	 replace them in the system with the &lt;value&gt; of our fieldmaps. This should be done before	 the cache is updated, because then we can do a simple #become: to replace that proxy	 in all owner objects and in our fieldmap. All owners of the surrogates are informed about		 that replacement."	| allOwners |	allOwners := IdentitySet new.	anArray do: 			[:map |			(self shouldRealizeSurrogateOfFieldMap: map)				ifTrue: 					[self surrogates at: map id						ifPresent: 							[:surrogate |							surrogate ownerIDs								do: [:id | (self cache at: id) ifNotNil: [:owner | allOwners add: owner]].							surrogate isSurrogate								ifFalse: [self error: 'connection knows a surrogate that is no surrogate'].							surrogate become: map value.							self surrogates removeKey: map id ifAbsent: [].							map value: surrogate]]].	allOwners do: [:owner | owner rehashForSurrogates]</body><body package="Eurydike Core">validateFieldMaps: anArray	anArray do: #validate</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>accessing instances</category><body package="Eurydike Core">checkObjectSpaceVersion	| version |	self profile version = #any ifTrue: [^self].	version := self versionOfObjectSpace.	version = self profile version ifTrue: [^self].	(ObjectSpaceVersionConflict new)		version: version;		targetVersion: self profile version;		raiseSignal</body><body package="Eurydike Core">commit	self		transact: [self accessCritical: [(CommitUnit newForConnection: self) commit]]</body><body package="Eurydike Core">commitUnpreemptively	[self commit] valueUnpreemptively</body><body package="Eurydike Core">instanceOfObjectSpace	^self cache at: self defaultObjectSpaceID		ifAbsent: 			[| space |			self checkObjectSpaceVersion.			space := self instanceWithID: self defaultObjectSpaceID.			space ifNotNil: [space connection: self].			space]</body><body package="Eurydike Core">instanceOfObjectSpaceClass: aClass	^self instanceOfObjectSpace		ifNil: [self newInstanceOfObjectSpaceClass: aClass]</body><body package="Eurydike Core">instanceWithID: anID	| instances |	instances := self instancesWithIDs: (Array with: anID).	instances isEmpty ifTrue: [^nil].	^instances first</body><body package="Eurydike Core">instancesWithIDs: anArray	| allInstances newIDs mapList |	allInstances := OrderedCollection new: anArray size.	newIDs := OrderedCollection new: anArray size.	anArray do: 			[:id |			(self cache at: id)				ifNil: [newIDs add: id]				ifNotNil: [:instance | allInstances add: instance]].	mapList := self fieldMapsWithIDs: newIDs.	allInstances addAll: (self buildInstancesFrom: mapList).	^allInstances</body><body package="Eurydike Core">isCached: anObject	^(self cache keyAtValue: anObject) notNil</body><body package="Eurydike Core">isModified: anObject	^self modificationTracker isModified: anObject</body><body package="Eurydike Core">isNew: anObject	^self cache isNew: anObject</body><body package="Eurydike Core">isNewOrModified: anObject	^(self isNew: anObject) or: [self isModified: anObject]</body><body package="Eurydike Core">markAsModified: anObject	self modificationTracker markAsModified: anObject</body><body package="Eurydike Core">markAsUnmodified: anObject	self modificationTracker markAsUnmodified: anObject</body><body package="Eurydike Core">needsCommit	^self modificationTracker hasModifications</body><body package="Eurydike Core">newInstanceOfObjectSpaceClass: aClass	| space |	space := aClass new.	space connection: self.	space version: self profile version.	self cache at: self defaultObjectSpaceID put: space.	self markAsModified: space.	^space</body><body package="Eurydike Core">proxifyInstance: anObject	^self proxifyInstanceWithID: (self cache keyAtValue: anObject)</body><body package="Eurydike Core">proxifyInstanceWithID: anID	self accessCritical: 			[| instance surrogate |			anID == self defaultObjectSpaceID ifTrue: [^self].			anID = self defaultObjectSpaceID ifTrue: [self halt].			instance := self cache removeKey: anID ifAbsent: [^self].			instance beMutable.			surrogate := (Surrogate withID: anID) initializeWithConnection: self.			self surrogates at: anID put: instance.			surrogate become: instance]</body><body package="Eurydike Core">refreshInstance: anObject	| id |	id := self cache keyAtValue: anObject				ifAbsent: [^self transientObjectFailure].	self refreshInstanceWithID: id</body><body package="Eurydike Core">refreshInstanceWithID: anID	| currentInstance dbInstance |	currentInstance := self cache removeKey: anID				ifAbsent: [^self transientObjectFailure].	dbInstance := self instanceWithID: anID.	currentInstance oneWayBecome: dbInstance</body><body package="Eurydike Core">versionOfObjectSpace	| rows versionRow |	rows := self fieldRowsWithIDs: (Array with: self defaultObjectSpaceID).	versionRow := rows detect: [:each | each key = 'version' asIs] ifNone: [^nil].	^versionRow asField value</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>private accessing</category><body package="Eurydike Core">defaultObjectSpaceID	^0</body><body package="Eurydike Core">nativeConnection	^nativeConnection</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>installing</category><body package="Eurydike Core">installSchema	self profile platform installSchemaOn: self</body><body package="Eurydike Core">removeSchema	self profile platform removeSchemaOn: self</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>primitive execution</category><body package="Eurydike Core">executeSQLString: aString	^self executeSQLString: aString bindings: #()</body><body package="Eurydike Core">executeSQLString: aString bindings: aBindArray	| nativeSession answer |	nativeSession := nativeConnection getSession.		[nativeSession bindInput: aBindArray.	nativeSession prepare: aString.	nativeSession execute.	answer := nativeSession answer.	^answer = #noAnswerStream ifTrue: [nil] ifFalse: [answer upToEnd]]			ensure: [nativeSession disconnect]</body><body package="Eurydike Core">executeSQLString: aString bindings: aBindArray onError: aBlock	^[self executeSQLString: aString bindings: aBindArray] on: Error		do: [:ex | aBlock value]</body><body package="Eurydike Core">executeSQLString: aString onError: aBlock	^self executeSQLString: aString bindings: #() onError: aBlock</body><body package="Eurydike Core">transact: aBlock	| isInTransaction result |	isInTransaction := nativeConnection inTransactionMode.	isInTransaction ifFalse: [nativeConnection begin].	result := nil.	[result := aBlock value.	isInTransaction ifFalse: [nativeConnection commit]]			ifCurtailed: [isInTransaction ifFalse: [nativeConnection rollback]].	^result</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>initialize-release</category><body package="Eurydike Core">flush	self flushCache.	self flushModifications.	self flushSurrogates</body><body package="Eurydike Core">flushCache	self cache flush</body><body package="Eurydike Core">flushModifications	self modificationTracker flush</body><body package="Eurydike Core">flushSurrogates	self initializeSurrogates</body><body package="Eurydike Core">initialize	super initialize.	self initializeCache.	self initializeSurrogates.	self initializeStatistics</body><body package="Eurydike Core">initializeCache		cache := Cache new</body><body package="Eurydike Core">initializeModificationTracker	modificationTracker := ConnectionModificationTracker				newForConnection: self</body><body package="Eurydike Core">initializeStatistics	statistics := IntegerKeyedDictionary new</body><body package="Eurydike Core">initializeSurrogates		surrogates := IntegerKeyedDictionary new</body><body package="Eurydike Core">initializeTrigger	triggerImageGC := Ephemeron key: Object new.	triggerImageGC manager: self</body><body package="Eurydike Core">releaseModificationTracker	self modificationTracker release.	modificationTracker := nil</body><body package="Eurydike Core">releaseTrigger	triggerImageGC manager: nil.	triggerImageGC := nil</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>error handling</category><body package="Eurydike Core">transientObjectFailure	^self error: #ErrorTransientObject &lt;&lt; #eurydike				&gt;&gt; 'the given object is not found in cache - it seems to be a transient object which cannot be updated'</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>statistics</category><body package="Eurydike Core">bestObjectsForGarbageCollect	| sortedStatistics pieceStatistics |	sortedStatistics := self statisticsForCachedObjects values				sorted: #numberOfCreations ascending , #lastCreationTimestamp descending.	pieceStatistics := sortedStatistics				first: (sortedStatistics size * self profile policy imageGCThreshold)						asInteger.	^pieceStatistics collect: [:statistic | self cache at: statistic id]</body><body package="Eurydike Core">statisticFor: anObject	| id |	id := self cache keyAtValue: anObject.	^self statisticWithID: id</body><body package="Eurydike Core">statisticWithID: anID	^self statistics at: anID ifAbsentPut: [Statistic newWithID: anID]</body><body package="Eurydike Core">statistics	^statistics</body><body package="Eurydike Core">statisticsForCachedObjects	^self statistics select: [:each | self cache keys includes: each id]</body><body package="Eurydike Core">unmodifiedObjects	| space cachedObjects modifiedObjects |	space := self instanceOfObjectSpace.	cachedObjects := self cache values.	modifiedObjects := self modificationTracker modifications.	^cachedObjects		reject: [:each | (modifiedObjects includes: each) or: [each == space]]</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>private statistics</category><body package="Eurydike Core">updateStatisticsWithFieldMaps: anArray	anArray do: 			[:map |			(self statisticWithID: map id)				incrementNumberOfCreations;				lastCreationTimestamp: Timestamp now]</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>private instances</category><body package="Eurydike Core">buildInstancesFrom: aFieldMapList	aFieldMapList newMaps do: #postBuildValue.	^aFieldMapList rootMaps collect: #value</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>connect/disconnect</category><body package="Eurydike Core">connect	self isConnected ifTrue: [^self].	self connectExternal.	self initializeModificationTracker.	self initializeTrigger.	self installSchema</body><body package="Eurydike Core">connectExternal	self isConnectedExternal ifTrue: [^self].	nativeConnection := profile newNativeConnection.	nativeConnection connect.</body><body package="Eurydike Core">disconnect	self flush.	self releaseTrigger.	self releaseModificationTracker.	self disconnectExternal</body><body package="Eurydike Core">disconnectExternal	self isConnectedExternal ifFalse: [^self].	nativeConnection disconnect.	nativeConnection := nil</body><body package="Eurydike Core">isConnected	^self isConnectedExternal</body><body package="Eurydike Core">isConnectedExternal	^nativeConnection notNil and: [nativeConnection isConnected]</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>printing</category><body package="Eurydike Core">printOn: aStream	super printOn: aStream.	aStream		space;		print: self environment</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>privileged execution</category><body package="Eurydike Core">accessCritical: aBlock	^AccessLock critical: aBlock</body></methods><methods><class-id>Eurydike.Connection</class-id> <category>validation</category><body package="Eurydike Core">validate	^self profile platform validateOn: self</body></methods><methods><class-id>Eurydike.Connection class</class-id> <category>instance creation</category><body package="Eurydike Core">new	^super new initialize</body><body package="Eurydike Core">newForProfile: aConnectionProfile	^self new profile: aConnectionProfile</body></methods><methods><class-id>Eurydike.SQLDumperConnection</class-id> <category>connect/disconnect</category><body package="Eurydike Core">connect	self isConnected ifTrue: [^self].	dumpOutputStream := self profile environment asFilename appendStream.	self installSchema</body><body package="Eurydike Core">disconnect	self isConnected ifFalse: [^self].	dumpOutputStream close.	dumpOutputStream := nil</body><body package="Eurydike Core">isConnected	^dumpOutputStream notNil</body></methods><methods><class-id>Eurydike.SQLDumperConnection</class-id> <category>primitive execution</category><body package="Eurydike Core">executeSQLString: aString	dumpOutputStream		nextPutAll: aString;		nextPut: $;;		cr</body><body package="Eurydike Core">executeSQLString: aString onError: aBlock	^self executeSQLString: aString</body><body package="Eurydike Core">transact: aBlock	^aBlock value</body></methods><methods><class-id>Eurydike.SQLDumperConnection</class-id> <category>accessing</category><body package="Eurydike Core">sequenceID	^sequenceID</body><body package="Eurydike Core">sequenceID: anObject	sequenceID := anObject</body></methods><methods><class-id>Eurydike.SQLDumperConnection</class-id> <category>accessing instances</category><body package="Eurydike Core">newInstanceOfObjectSpace	^nil</body></methods><methods><class-id>Eurydike.SQLDumperConnection</class-id> <category>initialize-release</category><body package="Eurydike Core">initialize	super initialize.	sequenceID := 0</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>system primitives</category><body package="Eurydike Migration">mgGenericVariables	^mgGenericVariables</body><body package="Eurydike Migration">mgIndexedVariables	^mgIndexedVariables</body><body package="Eurydike Migration">mgInstVarNamed: aString	^self mgInstVarNamed: aString ifAbsent: [nil]</body><body package="Eurydike Migration">mgInstVarNamed: aString ifAbsent: aBlock	^self mgInstanceVariables at: aString asSymbol ifAbsent: aBlock</body><body package="Eurydike Migration">mgInstVarNamed: aString ifAbsentPut: aBlock	^self mgInstVarNamed: aString		ifAbsent: [self mgInstVarNamed: aString put: aBlock value]</body><body package="Eurydike Migration">mgInstVarNamed: aString put: anObject	^self mgInstanceVariables at: aString asSymbol put: anObject</body><body package="Eurydike Migration">mgInstanceVariables	^mgInstanceVariables</body><body package="Eurydike Migration">mgRemoveInstVarNamed: aString 	^self mgInstanceVariables removeKey: aString asSymbol</body><body package="Eurydike Migration">mgRemoveInstVarNamed: aString ifAbsent: aBlock	^self mgInstanceVariables removeKey: aString asSymbol ifAbsent: aBlock</body><body package="Eurydike Migration">mgRenameInstVarNamed: oldName to: newName	| data |	data := self mgRemoveInstVarNamed: oldName ifAbsent: [nil].	self mgInstVarNamed: newName put: data</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>accessing</category><body package="Eurydike Migration">mgAt: anIndex	^self mgBasicAt: anIndex</body><body package="Eurydike Migration">mgAt: anIndex put: anObject	^self mgBasicAt: anIndex put: anObject</body><body package="Eurydike Migration">mgBasicAt: anIndex	^self mgIndexedAt: anIndex</body><body package="Eurydike Migration">mgBasicAt: anIndex put: anObject	^self mgIndexedAt: anIndex put: anObject</body><body package="Eurydike Migration">mgFirst	^self mgIndexedVariables first</body><body package="Eurydike Migration">mgFourth	^self mgIndexedVariables fourth</body><body package="Eurydike Migration">mgGenericAt: aKey	^self mgGenericAt: aKey ifAbsent: [self error: (#genericKeyCannotBeFound &lt;&lt; #eurydike &gt;&gt; 'generic key cannot be found')	asString]</body><body package="Eurydike Migration">mgGenericAt: aKey ifAbsent: aBlock	^self mgGenericVariables at: aKey ifAbsent: aBlock</body><body package="Eurydike Migration">mgGenericAt: aKey ifAbsentPut: aBlock	^self mgGenericAt: aKey		ifAbsent: [self mgGenericAt: aKey put: aBlock value]</body><body package="Eurydike Migration">mgGenericAt: aKey put: aValue	^self mgGenericVariables at: aKey put: aValue</body><body package="Eurydike Migration">mgGenericSize	^self mgGenericVariables size</body><body package="Eurydike Migration">mgIndexedAt: anIndex	^self mgIndexedVariables at: anIndex</body><body package="Eurydike Migration">mgIndexedAt: anIndex put: anObject	^self mgIndexedVariables at: anIndex put: anObject</body><body package="Eurydike Migration">mgIndexedSize	^self mgIndexedVariables size</body><body package="Eurydike Migration">mgInstSize	^self mgInstanceVariables size</body><body package="Eurydike Migration">mgSecond	^self mgIndexedVariables second</body><body package="Eurydike Migration">mgSize	^self mgIndexedSize</body><body package="Eurydike Migration">mgThird	^self mgIndexedVariables third</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>class membership</category><body package="Eurydike Migration">mgClass	^mgClass</body><body package="Eurydike Migration">mgClass: aMigrationObjectClass	mgClass := aMigrationObjectClass</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>testing</category><body package="Eurydike Migration">isMigrationObject	^true</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>printing</category><body package="Eurydike Migration">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self mgClass name;		nextPut: $)</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>error handling</category><body package="Eurydike Migration">doesNotUnderstand: aMessage	^self perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>message handling</category><body package="Eurydike Migration">perform: aSymbol	^self perform: aSymbol withArguments: #()</body><body package="Eurydike Migration">perform: aSymbol with: anArgument	^self perform: aSymbol withArguments: (Array with: anArgument)</body><body package="Eurydike Migration">perform: aSymbol with: aFirstArgument with: aSecondArgument	^self perform: aSymbol		withArguments: (Array with: aFirstArgument with: aSecondArgument)</body><body package="Eurydike Migration">perform: aSymbol with: aFirstArgument with: aSecondArgument with: aThirdArgument	^self perform: aSymbol		withArguments: (Array				with: aFirstArgument				with: aSecondArgument				with: aThirdArgument)</body><body package="Eurydike Migration">perform: aSymbol with: aFirstArgument with: aSecondArgument with: aThirdArgument with: aFourthArgument	^self perform: aSymbol		withArguments: (Array				with: aFirstArgument				with: aSecondArgument				with: aThirdArgument				with: aFourthArgument)</body><body package="Eurydike Migration">perform: aSymbol withArguments: anArray	(aSymbol beginsWith: 'mg' asIs)		ifTrue: 			[(self respondsTo: aSymbol)				ifFalse: 					[aSymbol numArgs = 0						ifTrue: [^self mgInstVarNamed: (aSymbol allButFirst: 2) decapitalized]						ifFalse: 							[(aSymbol isKeyword and: [aSymbol numArgs = 1])								ifTrue: 									[^self mgInstVarNamed: ((aSymbol allButFirst: 2) allButLast: 1) decapitalized										put: anArray first]]]].	(self respondsTo: aSymbol)		ifFalse: 			[super doesNotUnderstand: (Message selector: aSymbol arguments: anArray)].	^super perform: aSymbol withArguments: anArray</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>enumerating</category><body package="Eurydike Migration">mgDetect: aBlock	^self mgDetect: aBlock ifNone: [self error: (#cannotFindElement &lt;&lt; #eurydike &gt;&gt; 'cannot find element') asString]</body><body package="Eurydike Migration">mgDetect: aBlock ifNone: aNoneBlock	^self mgIndexedVariables detect: aBlock ifNone: aNoneBlock</body><body package="Eurydike Migration">mgDo: aBlock	^self mgIndexedVariablesDo: aBlock</body><body package="Eurydike Migration">mgDoWithIndex: aBlock	^self mgIndexedVariablesDoWithIndex: aBlock</body><body package="Eurydike Migration">mgGenericVariablesKeysAndValuesDo: aBlock	^self mgGenericVariables keysAndValuesDo: aBlock</body><body package="Eurydike Migration">mgHasInstVarNamed: aSymbol	^self mgInstanceVariables includesKey: aSymbol</body><body package="Eurydike Migration">mgIndexedVariablesDo: aBlock	^self mgIndexedVariables do: aBlock</body><body package="Eurydike Migration">mgIndexedVariablesDoWithIndex: aBlock	^self mgIndexedVariables doWithIndex: aBlock</body><body package="Eurydike Migration">mgInstanceVariablesDo: aBlock	^self mgInstanceVariables do: aBlock</body><body package="Eurydike Migration">mgInstanceVariablesKeysAndValuesDo: aBlock	^self mgInstanceVariables keysAndValuesDo: aBlock</body><body package="Eurydike Migration">mgKeysAndValuesDo: aBlock	^self mgGenericVariablesKeysAndValuesDo: aBlock</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>accessing fields</category><body package="Eurydike Migration">asFieldMap	| map |	map := FieldMap on: self.	map targetClass: self mgClass.	map targetSize: self mgSize.	map targetVersion: self fieldMapVersion.	self mgInstanceVariables		keysAndValuesDo: [:name :value | map namedAt: name put: value].	self mgIndexedVariables		keysAndValuesDo: [:index :value | map indexedAt: index put: value].	self mgGenericVariables		keysAndValuesDo: [:key :value | map genericAt: key put: value].	^map</body><body package="Eurydike Migration">initializeFromFieldMap: aFieldMap	aFieldMap namedFields do: 			[:namedField |			self mgInstVarNamed: namedField key asString				put: namedField value asFieldMapValue].	aFieldMap indexedFields do: 			[:indexedField |			self mgIndexedAt: indexedField key put: indexedField value asFieldMapValue].	aFieldMap genericFields do: 			[:genericField |			self mgGenericAt: genericField key asFieldMapValue				put: genericField value asFieldMapValue]</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>initialize-release</category><body package="Eurydike Migration">initialize	super initialize.	mgInstanceVariables := IdentityDictionary new.	mgIndexedVariables := OrderedCollection new.	mgGenericVariables := IdentityDictionary new</body><body package="Eurydike Migration">initializeWithSize: anInteger	mgIndexedVariables := OrderedCollection withSize: anInteger</body></methods><methods><class-id>Eurydike.MigrationObject</class-id> <category>adding</category><body package="Eurydike Migration">mgAdd: anObject	^self mgIndexedVariables add: anObject</body><body package="Eurydike Migration">mgAddAll: anArray	^self mgIndexedVariables addAll: anArray</body></methods><methods><class-id>Eurydike.MigrationObject class</class-id> <category>instance creation</category><body package="Eurydike Migration">new	^super new initialize</body><body package="Eurydike Migration">new: anInteger	^self new initializeWithSize: anInteger</body></methods><methods><class-id>Eurydike.MigrationObject class</class-id> <category>testing</category><body package="Eurydike Migration">isResponsibleFor: objectClass	self subclassResponsibility</body></methods><methods><class-id>Eurydike.MigrationObject class</class-id> <category>accessing-classes</category><body package="Eurydike Migration">classFor: objectClass	^self allSubclasses detect: [:each | each isResponsibleFor: objectClass]		ifNone: [self]</body></methods><methods><class-id>Eurydike.MigrationDictionary</class-id> <category>accessing</category><body package="Eurydike Migration">at: key put: value	self mgGenericAt: key put: value</body><body package="Eurydike Migration">removeKey: aKey 		self mgGenericVariables removeKey: aKey</body></methods><methods><class-id>Eurydike.MigrationDictionary</class-id> <category>converting</category><body package="Eurydike Migration">asNormalObject		^ self mgGenericVariables</body></methods><methods><class-id>Eurydike.MigrationDictionary class</class-id> <category>testing</category><body package="Eurydike Migration">isResponsibleFor: objectClass	^#(#Dictionary #IdentityDictionary) includes: objectClass name</body></methods><methods><class-id>Eurydike.Cache</class-id> <category>accessing</category><body package="Eurydike Core">at: aKey	^self at: aKey ifAbsent: [nil]</body><body package="Eurydike Core">at: aKey ifAbsent: aBlock	^keyToValue at: aKey ifAbsent: aBlock</body><body package="Eurydike Core">at: aKey put: aValue	keyToValue at: aKey put: aValue.	valueToKey at: aValue put: aKey.	valueIsNew at: aValue put: false</body><body package="Eurydike Core">isNew: anObject	^valueIsNew at: anObject ifAbsent: [true]</body><body package="Eurydike Core">keyAtValue: aValue	^self keyAtValue: aValue ifAbsent: [nil]</body><body package="Eurydike Core">keyAtValue: aValue ifAbsent: aBlock	^valueToKey at: aValue ifAbsent: aBlock</body><body package="Eurydike Core">keys	^keyToValue keys</body><body package="Eurydike Core">newAt: aKey put: aValue	(self at: aKey)		ifNil: 			[keyToValue at: aKey put: aValue.			valueToKey at: aValue put: aKey.			valueIsNew at: aValue put: true]</body><body package="Eurydike Core">values	^keyToValue values</body></methods><methods><class-id>Eurydike.Cache</class-id> <category>removing</category><body package="Eurydike Core">flush	self initialize</body><body package="Eurydike Core">removeKey: anID	^self removeKey: anID ifAbsent: [nil]</body><body package="Eurydike Core">removeKey: aKey ifAbsent: aBlock	| value |	value := keyToValue removeKey: aKey ifAbsent: [^aBlock value].	valueToKey removeKey: value ifAbsent: [].	^value</body></methods><methods><class-id>Eurydike.Cache</class-id> <category>initialize-release</category><body package="Eurydike Core">initialize	super initialize.	keyToValue := IntegerKeyedEphemeralValueDictionary new.	valueToKey := EphemeronDictionary new.	valueIsNew := EphemeronDictionary new</body></methods><methods><class-id>Eurydike.Cache class</class-id> <category>instance creation</category><body package="Eurydike Core">new	^super new initialize</body></methods><methods><class-id>Eurydike.ConnectionPolicy</class-id> <category>accessing</category><body package="Eurydike Core">imageGCThreshold	^imageGCThreshold</body><body package="Eurydike Core">imageGCThreshold: anInteger	imageGCThreshold := anInteger</body><body package="Eurydike Core">instanceCommitSize	^instanceCommitSize</body><body package="Eurydike Core">instanceCommitSize: anInteger	instanceCommitSize := anInteger</body><body package="Eurydike Core">recursionDepth	^recursionDepth</body><body package="Eurydike Core">recursionDepth: anInteger	recursionDepth := anInteger</body><body package="Eurydike Core">rowCommitSize	^rowCommitSize</body><body package="Eurydike Core">rowCommitSize: anInteger	rowCommitSize := anInteger</body></methods><methods><class-id>Eurydike.ConnectionPolicy</class-id> <category>initialize-release</category><body package="Eurydike Core">initialize	super initialize.	self imageGCThreshold: 0.01.	self instanceCommitSize: 1000.	self recursionDepth: 3.	self rowCommitSize: 1000</body></methods><methods><class-id>Eurydike.ConnectionPolicy</class-id> <category>testing</category><body package="Eurydike Core">shouldRealizeSurrogateOfClass: aClass	^aClass shouldRealizeSurrogateInEurydike</body></methods><methods><class-id>Eurydike.ConnectionPolicy class</class-id> <category>instance creation</category><body package="Eurydike Core">new	^super new initialize</body></methods><methods><class-id>Eurydike.FieldMap</class-id> <category>accessing fields</category><body package="Eurydike Fields">addClassAndSizeField: aField	self targetClass: aField key.	self targetSize: aField value</body><body package="Eurydike Fields">addField: aField	^self perform: (#add , (self capitalize: aField type) , #Field:) asSymbol		with: aField</body><body package="Eurydike Fields">addGenericField: aGenericField	aGenericField map: self.	^self genericFields add: aGenericField</body><body package="Eurydike Fields">addIndexedField: anIndexedField	anIndexedField map: self.	^self indexedFields add: anIndexedField</body><body package="Eurydike Fields">addNamedField: aNamedField	aNamedField map: self.	^self namedFields add: aNamedField</body><body package="Eurydike Fields">addVersionAndTimestampField: aField	self targetVersion: aField key.	self timestamp: aField value</body><body package="Eurydike Fields">allFields	^self metaFields , self dataFields</body><body package="Eurydike Fields">capitalize: aString	^(aString first: 1) asUppercase , (aString allButFirst: 1)</body><body package="Eurydike Fields">classAndSizeField	^(Field fromClass: self targetClass size: self targetSize)		map: self;		yourself</body><body package="Eurydike Fields">dataFields	^self namedFields , self indexedFields , self genericFields</body><body package="Eurydike Fields">genericAt: aKey put: aValue	self addGenericField: (Field				type: #generic				key: aKey asFieldProperty				value: aValue asFieldProperty)</body><body package="Eurydike Fields">genericFields	^genericFields</body><body package="Eurydike Fields">indexedAt: anIndex put: aValue	self addIndexedField: (Field				type: #indexed				key: anIndex asInteger asFieldProperty				value: aValue asFieldProperty)</body><body package="Eurydike Fields">indexedFields	^indexedFields</body><body package="Eurydike Fields">metaFields	^Array with: self classAndSizeField with: self versionAndTimestampField</body><body package="Eurydike Fields">namedAt: aName put: aValue	self addNamedField: (Field				type: #named				key: aName asSymbol asFieldProperty				value: aValue asFieldProperty)</body><body package="Eurydike Fields">namedFields	^namedFields</body><body package="Eurydike Fields">versionAndTimestampField	^(Field fromVersion: self targetVersion timestamp: self timestamp)		map: self;		yourself</body></methods><methods><class-id>Eurydike.FieldMap</class-id> <category>accessing</category><body package="Eurydike Fields">id	^id</body><body package="Eurydike Fields">id: anInteger	id := anInteger</body><body package="Eurydike Fields">references	| references |	references := OrderedCollection new.	self dataFields do: [:field | references addAll: field references].	^references</body><body package="Eurydike Fields">targetClass	^targetClass</body><body package="Eurydike Fields">targetClass: aClass	targetClass := aClass</body><body package="Eurydike Fields">targetSize	^targetSize</body><body package="Eurydike Fields">targetSize: anInteger	targetSize := anInteger</body><body package="Eurydike Fields">targetVersion	^targetVersion</body><body package="Eurydike Fields">targetVersion: aString	targetVersion := aString</body><body package="Eurydike Fields">timestamp	^timestamp</body><body package="Eurydike Fields">timestamp: aTimestamp	timestamp := aTimestamp</body><body package="Eurydike Fields">value	^value</body><body package="Eurydike Fields">value: anObject	value := anObject</body></methods><methods><class-id>Eurydike.FieldMap</class-id> <category>initialize-release</category><body package="Eurydike Fields">fromFieldRows: anArray	anArray do: 			[:row |			self id: row objectID asInteger.			self addField: (Field fromFieldRow: row)]</body><body package="Eurydike Fields">initialize	super initialize.	namedFields := OrderedCollection new.	indexedFields := OrderedCollection new.	genericFields := OrderedCollection new</body><body package="Eurydike Fields">initializeValuesFromConnection: aConnection	self value: (aConnection cache at: self id).	self dataFields		do: [:field | field initializeValuesFromConnection: aConnection]</body><body package="Eurydike Fields">initializeWithSurrogateID: anID	self id: anID.	self targetClass: Surrogate.	self targetSize: 0.	self namedAt: #id put: anID</body><body package="Eurydike Fields">on: anObject	self value: anObject</body></methods><methods><class-id>Eurydike.FieldMap</class-id> <category>converting</category><body package="Eurydike Fields">asFieldMapValue	^self value</body><body package="Eurydike Fields">asFieldRowProperty	^self id asFieldRowProperty</body><body package="Eurydike Fields">asFieldRows	| allFields |	allFields := self allFields.	allFields doWithIndex: [:field :index | field id: index].	^allFields collect: #asFieldRow</body><body package="Eurydike Fields">asReference	^Reference value: self</body></methods><methods><class-id>Eurydike.FieldMap</class-id> <category>testing</category><body package="Eurydike Fields">hasResolvedSurrogate	^self looksLikeSurrogate and: [value isSurrogate not]</body><body package="Eurydike Fields">hasValue	^value notNil</body><body package="Eurydike Fields">looksLikeSurrogate	^self targetClass includesBehavior: Surrogate</body></methods><methods><class-id>Eurydike.FieldMap</class-id> <category>validation</category><body package="Eurydike Fields">validate	self validateMetaFields.	self validateNamedFields.	self validateIndexedFields.	self validateGenericFields</body><body package="Eurydike Fields">validateGenericFields	self genericFields do: #validate</body><body package="Eurydike Fields">validateIndexedFields	self indexedFields do: #validate</body><body package="Eurydike Fields">validateMetaFields	self classAndSizeField validate.	self versionAndTimestampField validate</body><body package="Eurydike Fields">validateNamedFields	self namedFields do: 			[:field |			field validate.			(self targetClass isUndefinedFieldType				or: [field key isUndefinedFieldType])					ifFalse: 						[(self targetClass allInstVarNames includes: field key asString)							ifFalse: [(MissingNamedField newWithField: field) raiseSignal]]]</body></methods><methods><class-id>Eurydike.FieldMap</class-id> <category>building</category><body package="Eurydike Fields">postBuildValue	self value postBuildFromFieldMap: self</body></methods><methods><class-id>Eurydike.FieldMap</class-id> <category>printing</category><body package="Eurydike Fields">printOn: aStream	super printOn: aStream.	aStream		space;		nextPutAll: targetClass name.	aStream space;nextPut:$(.	self dataFields do: 			[:each |			aStream				print: each key] separatedBy: [ aStream space].	aStream nextPut:$).</body></methods><methods><class-id>Eurydike.FieldMap class</class-id> <category>instance creation</category><body package="Eurydike Fields">fromFieldRows: anArray	^self new fromFieldRows: anArray</body><body package="Eurydike Fields">fromMultipleFieldRows: anArray	| allGroupedRows |	allGroupedRows := anArray groupedBy: #objectID.	^allGroupedRows values collect: [:groupedRows | self fromFieldRows: groupedRows]</body><body package="Eurydike Fields">new	^super new initialize</body><body package="Eurydike Fields">newWithSurrogateID: anID	^self new initializeWithSurrogateID: anID</body><body package="Eurydike Fields">on: anObject	^self new on: anObject</body></methods><methods><class-id>Eurydike.Reference</class-id> <category>accessing</category><body package="Eurydike Fields">id	^self value id</body><body package="Eurydike Fields">value	^value</body><body package="Eurydike Fields">value: anObject	value := anObject</body></methods><methods><class-id>Eurydike.Reference</class-id> <category>testing</category><body package="Eurydike Fields">isReference	^true</body></methods><methods><class-id>Eurydike.Reference</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	self		cannotBeExpressedAsFieldRow: (#references &lt;&lt; #eurydike &gt;&gt; 'references')				asString</body><body package="Eurydike Fields">asFieldMapValue	^self value asFieldMapValue</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	^self value asFieldRowProperty</body></methods><methods><class-id>Eurydike.Reference class</class-id> <category>instance creation</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^self value: (FieldMap newWithSurrogateID: aString asInteger)</body><body package="Eurydike Fields">value: anObject	^self new value: anObject</body></methods><methods><class-id>Eurydike.ObjectSpaceVersionConflict</class-id> <category>accessing</category><body package="Eurydike Error Handling">targetVersion	^targetVersion</body><body package="Eurydike Error Handling">targetVersion: anObject	^targetVersion := anObject</body><body package="Eurydike Error Handling">version	^version</body><body package="Eurydike Error Handling">version: anObject	version := anObject</body></methods><methods><class-id>Eurydike.ModificationArray</class-id> <category>accessing</category><body package="Eurydike Modifications">at: anIndex put: anObject	self notifyOwnerAboutModification.	^super at: anIndex put: anObject</body><body package="Eurydike Modifications">owner	^owner</body><body package="Eurydike Modifications">owner: anObject	owner := anObject</body></methods><methods><class-id>Eurydike.ModificationArray</class-id> <category>notifications</category><body package="Eurydike Modifications">notifyOwnerAboutModification	self owner ifNotNil: [self owner notifyAboutModification]</body></methods><methods><class-id>Eurydike.ModificationArray</class-id> <category>copying</category><body package="Eurydike Modifications">copyEmpty: aSize	^(self class new: aSize)		owner: self owner;		yourself</body></methods><methods><class-id>Eurydike.IntegerKeyedEphemeralValueDictionary</class-id> <category>private</category><body package="Eurydike Extensions">findKeyOrNil: key  	"We want an equality dictionary, but ephemeron dictionaries are by identity. Override findKeyOrNil: back again to the super super implementation."	| location length probe pass |	length := self basicSize.	pass := 1.	location := self initialIndexFor: key hashMultiply boundedBy: length.	[(probe := self basicAt: location) == nil or: [probe key = key]]		whileFalse: 			[(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body></methods><methods><class-id>Eurydike.SQLDumperPlatform</class-id> <category>accessing</category><body package="Eurydike Platforms">bindingParameterLimit	^1000</body></methods><methods><class-id>Eurydike.SQLDumperPlatform</class-id> <category>accessing schema</category><body package="Eurydike Platforms">installSchemaOn: aConnection	aConnection		executeSQLString: ('CREATE TABLE &lt;1s&gt; (  								objectid character varying,  								fieldid character varying,  								fieldtype character varying,  								keytype character varying,  								key character varying,  								valuetype character varying,  								value character varying)'	asIs				expandMacrosWith: aConnection profile schema)		onError: [].	aConnection		executeSQLString: ('CREATE TABLE &lt;1s&gt;_seq (id character varying)' asIs				expandMacrosWith: aConnection profile schema)		onError: []</body><body package="Eurydike Platforms">newObjectIDsFor: anArray on: aConnection	^aConnection transact: 			[| records oldMaxID newMaxID |			records := aConnection executeSQLString: ('SELECT id FROM &lt;1s&gt;_seq' asIs								expandMacrosWith: aConnection profile schema).			oldMaxID := aConnection sequenceID.			newMaxID := oldMaxID + anArray size.			aConnection sequenceID: newMaxID.			oldMaxID isZero				ifTrue: 					[aConnection executeSQLString: ('INSERT INTO &lt;1s&gt;_seq (id) VALUES (&lt;2p&gt;)' asIs								expandMacrosWith: aConnection profile schema								with: newMaxID printString)]				ifFalse: 					[aConnection						executeSQLString: ('UPDATE &lt;1s&gt;_seq SET id = &lt;2p&gt; WHERE id = &lt;3p&gt;' asIs								expandMacrosWith: aConnection profile schema								with: newMaxID printString								with: oldMaxID printString)].			oldMaxID + 1 to: newMaxID]</body><body package="Eurydike Platforms">removeSchemaOn: aConnection	aConnection executeSQLString: ('DROP TABLE &lt;1s&gt;' asIs				expandMacrosWith: aConnection profile schema)		onError: [].	aConnection executeSQLString: ('DROP TABLE &lt;1s&gt;_seq ' asIs				expandMacrosWith: aConnection profile schema)		onError: []</body></methods><methods><class-id>Eurydike.SQLDumperPlatform class</class-id> <category>accessing</category><body package="Eurydike Platforms">nativeConnectionClass	^nil</body></methods><methods><class-id>Eurydike.MigrationConnection</class-id> <category>private field maps</category><body package="Eurydike Migration">validateFieldMaps: anArray	^self</body></methods><methods><class-id>Eurydike.MigrationConnection</class-id> <category>accessing instances</category><body package="Eurydike Migration">instanceOfObjectSpace	^self cache at: self defaultObjectSpaceID		ifAbsent: [self instanceWithID: self defaultObjectSpaceID]</body></methods><methods><class-id>Eurydike.MigrationConnection</class-id> <category>private field rows</category><body package="Eurydike Migration">fieldRowsWithIDs: anArray	"We inject in all field rows our migration object as target class, so that no real object is instantiated"	| fieldRows |	fieldRows := super fieldRowsWithIDs: anArray.	fieldRows do: 			[:row |			(row keyType endsWith: ' class' asIs)				ifTrue: [row keyType: MigrationObjectClass asFieldRowProperty].			(row valueType endsWith: ' class' asIs)				ifTrue: [row valueType: MigrationObjectClass asFieldRowProperty]].	^fieldRows</body></methods><methods><class-id>Eurydike.ObjectSpace</class-id> <category>accessing</category><body package="Eurydike Core">connection	^connection</body><body package="Eurydike Core">connection: anObject	connection := anObject</body><body package="Eurydike Core">defaultID	^1</body><body package="Eurydike Core">version	^version</body><body package="Eurydike Core">version: anObject	version := anObject</body><body package="Eurydike Core">versionOrZero	^self version ifNil: [0]</body></methods><methods><class-id>Eurydike.ObjectSpace</class-id> <category>connect/disconnect</category><body package="Eurydike Core">connect	self isConnected ifTrue: [^self].	self connection connect</body><body package="Eurydike Core">disconnect	self isConnected ifFalse: [^self].	self connection disconnect</body><body package="Eurydike Core">isConnected	^self connection isConnected</body></methods><methods><class-id>Eurydike.ObjectSpace</class-id> <category>garbage collecting</category><body package="Eurydike Core">garbageCollect	^self connection garbageCollect</body><body package="Eurydike Core">globalGarbageCollect	^self connection globalGarbageCollect</body></methods><methods><class-id>Eurydike.ObjectSpace</class-id> <category>api</category><body package="Eurydike Core">commit	self connection commit</body><body package="Eurydike Core">commitUnpreemptively	self connection commitUnpreemptively</body><body package="Eurydike Core">commitWithVersion: aVersion	self version: aVersion.	self commit</body><body package="Eurydike Core">refresh	self refresh: self</body><body package="Eurydike Core">refresh: anObject	self connection refreshInstance: anObject</body><body package="Eurydike Core">validate	^self connection validate</body></methods><methods><class-id>Eurydike.ObjectSpace</class-id> <category>testing</category><body package="Eurydike Core">needsCommit	^self connection needsCommit</body></methods><methods><class-id>Eurydike.ObjectSpace class</class-id> <category>accessing</category><body package="Eurydike Core">connectionClass	^Connection</body><body package="Eurydike Core">connectionProfile	^self subclassResponsibility</body></methods><methods><class-id>Eurydike.ObjectSpace class</class-id> <category>instance creation</category><body package="Eurydike Core">newForConnection: aConnection	aConnection connect.	^aConnection newInstanceOfObjectSpaceClass: self</body><body package="Eurydike Core">newForDefaultProfile	^self newForProfile: self connectionProfile</body><body package="Eurydike Core">newForProfile: aProfile	^self newForConnection: (self connectionClass newForProfile: aProfile)</body><body package="Eurydike Core">openForConnection: aConnection	| isConnected |	isConnected := aConnection isConnected.	isConnected ifFalse: [aConnection connect].	^[aConnection instanceOfObjectSpaceClass: self] on: ObjectSpaceError		do: 			[:ex |			isConnected ifFalse: [aConnection disconnect].			ex pass.			nil]</body><body package="Eurydike Core">openForDefaultProfile	^self openForProfile: self connectionProfile</body><body package="Eurydike Core">openForProfile: aProfile	^self openForConnection: (self connectionClass newForProfile: aProfile)</body></methods><methods><class-id>Eurydike.ObjectSpace class</class-id> <category>accessing instances and variables</category><body package="Eurydike Core">fieldVarNames	^self instVarNames reject: [:each | each = 'connection' asIs]</body></methods><methods><class-id>Eurydike.DatabaseConverter</class-id> <category>accessing</category><body package="Eurydike Core">sourceConnection	^sourceConnection</body><body package="Eurydike Core">sourceConnection: aConnection	sourceConnection := aConnection</body><body package="Eurydike Core">targetConnection	^targetConnection</body><body package="Eurydike Core">targetConnection: aConnection	targetConnection := aConnection</body></methods><methods><class-id>Eurydike.DatabaseConverter</class-id> <category>connect/disconnect</category><body package="Eurydike Core">connect	self sourceConnection connect.	self targetConnection connect</body><body package="Eurydike Core">connectWhile: aBlock	self connect.	aBlock ensure: [self disconnect]</body><body package="Eurydike Core">disconnect	self sourceConnection disconnect.	self targetConnection disconnect</body></methods><methods><class-id>Eurydike.DatabaseConverter</class-id> <category>executing</category><body package="Eurydike Core">run	self connectWhile: 			[| currentID fieldRowIDs fieldRows |			currentID := 0.						[fieldRowIDs := currentID to: currentID + 1000.			fieldRows := self sourceConnection fieldRowsWithIDs: fieldRowIDs.			self targetConnection insertFieldRows: fieldRows.			currentID := fieldRowIDs last + 1.			fieldRows isEmpty]					whileFalse]</body></methods><methods><class-id>Eurydike.DatabaseConverter class</class-id> <category>accessing</category><body package="Eurydike Core">connectionClass	^Connection</body><body package="Eurydike Core">sourceConnectionClass	^self connectionClass</body><body package="Eurydike Core">targetConnectionClass	^self connectionClass</body></methods><methods><class-id>Eurydike.DatabaseConverter class</class-id> <category>instance creation</category><body package="Eurydike Core">sourceConnection: aSourceConnection targetConnection: aTargetConnection	^(self new)		sourceConnection: aSourceConnection;		targetConnection: aTargetConnection;		yourself</body><body package="Eurydike Core">sourceProfile: aSourceProfile targetProfile: aTargetProfile	^self		sourceConnection: (self sourceConnectionClass newForProfile: aSourceProfile)		targetConnection: (self targetConnectionClass newForProfile: aTargetProfile)</body></methods><methods><class-id>Eurydike.DatabaseConverter class</class-id> <category>examples</category><body package="Eurydike Core">example01	^(self sourceProfile: ((Eurydike.ConnectionProfile new)				platform: #{Eurydike.ISAMConverterPlatform} value new;				environment: 'Projects\StMaria_V2' asIs;				username: 'isam' asIs;				password: 'isam' asIs;				schema: 'seams' asIs;				version: 2;				yourself)		targetProfile: ((Eurydike.ConnectionProfile new)				platform: #{Eurydike.SQLite3Platform} value new;				environment: 'Projects\StMaria_V2\sqlite3.db' asIs;				username: 'sqlite3' asIs;				password: 'sqlite3' asIs;				schema: 'CMS' asIs;				version: 2;				yourself))			run</body></methods><methods><class-id>Eurydike.Migrator</class-id> <category>accessing</category><body package="Eurydike Migration">sourceConnection	^sourceConnection</body><body package="Eurydike Migration">sourceConnection: aConnection	sourceConnection := aConnection</body><body package="Eurydike Migration">targetConnection	^targetConnection</body><body package="Eurydike Migration">targetConnection: aConnection	targetConnection := aConnection</body><body package="Eurydike Migration">version	^self class version</body></methods><methods><class-id>Eurydike.Migrator</class-id> <category>connect/disconnect</category><body package="Eurydike Migration">connect	self sourceConnection connect.	self targetConnection connect</body><body package="Eurydike Migration">connectWhile: aBlock	| isConnected |	isConnected := self isConnected.	isConnected ifFalse: [self connect].	^aBlock ensure: [isConnected ifFalse: [self disconnect]]</body><body package="Eurydike Migration">disconnect	self sourceConnection disconnect.	self targetConnection disconnect</body><body package="Eurydike Migration">isConnected	^self isSourceConnected and: [self isTargetConnected]</body><body package="Eurydike Migration">isSourceConnected	^self sourceConnection isConnected</body><body package="Eurydike Migration">isTargetConnected	^self targetConnection isConnected</body></methods><methods><class-id>Eurydike.Migrator</class-id> <category>api</category><body package="Eurydike Migration">commitTargetObjectSpace: anObjectSpace	self targetConnection cache at: self targetConnection defaultObjectSpaceID		put: anObjectSpace.	self targetConnection markAsModified: anObjectSpace.	self targetConnection commit</body><body package="Eurydike Migration">readSourceObjectSpace	^self sourceConnection instanceOfObjectSpace</body></methods><methods><class-id>Eurydike.Migrator</class-id> <category>migration</category><body package="Eurydike Migration">migrate	| space |	space := nil.	self connectWhile: 			[| sourceSpace |			sourceSpace := self readSourceObjectSpace.			space := self migrateObjectSpace: sourceSpace.			space notNil ifTrue: [self commitTargetObjectSpace: space]].	^space</body><body package="Eurydike Migration">migrateObjectSpace: aMigrationObjectSpace	"this method is supposed to return the migrated ObjectSpace.	This new ObjectSpace has to have the new mgVersion!"	^self subclassResponsibility</body></methods><methods><class-id>Eurydike.Migrator</class-id> <category>testing</category><body package="Eurydike Migration">keepMigrating	^keepMigrating</body></methods><methods><class-id>Eurydike.Migrator</class-id> <category>initialize-release</category><body package="Eurydike Migration">initialize	super initialize.	keepMigrating := false</body></methods><methods><class-id>Eurydike.Migrator class</class-id> <category>validation</category><body package="Eurydike Migration">validateAllWithAnnouncement: anAnnouncement	| invalidClasses |	invalidClasses := self allSubclasses				reject: [:cls | cls validateWithAnnouncement: anAnnouncement].	invalidClasses isEmpty		ifFalse: 			[| stream |			stream := WriteStream on: (String new: 64).			stream				nextPutAll: (#TheFollowingMigratorCla___rDependentsHaveChanged &lt;&lt; #eurydike	&gt;&gt; 'The following migrator classes need an update, because some of their dependents have changed')		asString;				cr;				cr.			invalidClasses do: [:cls | stream nextPutAll: cls fullName]				separatedBy: [stream cr].			Dialog warn: stream contents]</body><body package="Eurydike Migration">validateWithAnnouncement: anAnnouncement	^self validateWithSpecList: anAnnouncement subject specList</body><body package="Eurydike Migration">validateWithChange: aChange	aChange isDefinitionChanged ifFalse: [^true].	^self validateWithReference: aChange symbol asQualifiedReference</body><body package="Eurydike Migration">validateWithPackage: aPackage	^aPackage changeSet		allSatisfy: [:change | self validateWithChange: change]</body><body package="Eurydike Migration">validateWithReference: aReference	^self validateWithValue: aReference value</body><body package="Eurydike Migration">validateWithSpec: aSpec	aSpec modified ifFalse: [^true].	aSpec pundle isPackage ifFalse: [^true].	^self validateWithPackage: aSpec pundle</body><body package="Eurydike Migration">validateWithSpecList: aSpecList	^aSpecList allSatisfy: [:spec | self validateWithSpec: spec]</body><body package="Eurydike Migration">validateWithValue: aValue	^(self validationDependents includes: aValue) not</body><body package="Eurydike Migration">validationDependents	^self subclassResponsibility</body></methods><methods><class-id>Eurydike.Migrator class</class-id> <category>class initialization</category><body package="Eurydike Migration">initialize	Store.StorePublishDialog.Announcements		unsubscribe: self;		when: Store.StorePublishDialogOpening			send: #validateAllWithAnnouncement:			to: self</body></methods><methods><class-id>Eurydike.Migrator class</class-id> <category>accessing</category><body package="Eurydike Migration">sourceConnectionClass	^MigrationConnection</body><body package="Eurydike Migration">targetConnectionClass	^MigrationConnection</body><body package="Eurydike Migration">version	^self subclassResponsibility</body><body package="Eurydike Migration">versionOrZero	^self version ifNil: [0]</body></methods><methods><class-id>Eurydike.Migrator class</class-id> <category>instance creation</category><body package="Eurydike Migration">new	^super new initialize</body><body package="Eurydike Migration">newForSourceConnection: aSourceConnection targetConnection: aTargetConnection	^(self new)		sourceConnection: aSourceConnection;		targetConnection: aTargetConnection;		yourself</body><body package="Eurydike Migration">newForSourceProfile: aSourceProfile targetProfile: aTargetProfile	^self newForSourceConnection: (self sourceConnectionClass				newForProfile: aSourceProfile)		targetConnection: (self targetConnectionClass newForProfile: aTargetProfile)</body></methods><methods><class-id>Eurydike.UndefinedFieldType</class-id> <category>accessing</category><body package="Eurydike Fields">name	^name</body><body package="Eurydike Fields">name: aString	name := aString</body><body package="Eurydike Fields">value	^value</body><body package="Eurydike Fields">value: anObject	value := anObject</body></methods><methods><class-id>Eurydike.UndefinedFieldType</class-id> <category>testing</category><body package="Eurydike Fields">isUndefinedFieldType	^true</body></methods><methods><class-id>Eurydike.UndefinedFieldType</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^self value: aString</body></methods><methods><class-id>Eurydike.UndefinedFieldType class</class-id> <category>instance creation</category><body package="Eurydike Fields">name: aString	^self new name: aString</body></methods><methods><class-id>Eurydike.FieldMapList</class-id> <category>accessing</category><body package="Eurydike Fields">allMaps	^allMaps</body><body package="Eurydike Fields">allMaps: anArray	allMaps := anArray</body><body package="Eurydike Fields">newMaps	^newMaps</body><body package="Eurydike Fields">newMaps: anArray	newMaps := anArray</body><body package="Eurydike Fields">rootMaps	^rootMaps</body><body package="Eurydike Fields">rootMaps: anArray	rootMaps := anArray</body></methods><methods><class-id>Eurydike.ModificationAssociation</class-id> <category>notifications</category><body package="Eurydike Modifications">notifyOwnerAboutModification	self owner ifNotNil: [self owner notifyAboutModification]</body></methods><methods><class-id>Eurydike.ModificationAssociation</class-id> <category>accessing</category><body package="Eurydike Modifications">key: anObject	self notifyOwnerAboutModification.	^super key: anObject</body><body package="Eurydike Modifications">key: aKey value: anObject	self notifyOwnerAboutModification.	^super key: aKey value: anObject</body><body package="Eurydike Modifications">owner	^owner</body><body package="Eurydike Modifications">owner: anObject	owner := anObject</body><body package="Eurydike Modifications">value: anObject	self notifyOwnerAboutModification.	^super value: anObject</body></methods><methods><class-id>Eurydike.ConnectionDialog</class-id> <category>initialize-release</category><body package="Eurydike UI">initialize	super initialize.	self profile: (ConnectionProfile new				platformClass: self availablePlatformClasses first)</body></methods><methods><class-id>Eurydike.ConnectionDialog</class-id> <category>accessing</category><body package="Eurydike UI">availablePlatformClasses	^DatabasePlatform allSubclasses sorted: #name ascending</body><body package="Eurydike UI">profile	^self profileHolder value</body><body package="Eurydike UI">profile: aConnectionProfile	self profileHolder value: aConnectionProfile</body></methods><methods><class-id>Eurydike.ConnectionDialog</class-id> <category>aspects</category><body package="Eurydike UI">availablePlatformClassesMenu	^Menu labelArray: (self availablePlatformClasses collect: #name)		values: self availablePlatformClasses</body><body package="Eurydike UI">profileHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^profileHolder isNil		ifTrue:			[profileHolder := nil asValue]		ifFalse:			[profileHolder]</body></methods><methods><class-id>Eurydike.ConnectionDialog</class-id> <category>actions</category><body package="Eurydike UI">connect	self accept value: true</body></methods><methods><class-id>Eurydike.ConnectionDialog class</class-id> <category>instance creation</category><body package="Eurydike UI">new	^super new initialize</body><body package="Eurydike UI">on: aConnectionProfile	^self new profile: aConnectionProfile</body></methods><methods><class-id>Eurydike.Statistic</class-id> <category>accessing</category><body package="Eurydike Core">id	^id</body><body package="Eurydike Core">id: anInteger	id := anInteger</body><body package="Eurydike Core">incrementNumberOfCreations	^self numberOfCreations: self numberOfCreations + 1</body><body package="Eurydike Core">lastCreationTimestamp	^lastCreationTimestamp</body><body package="Eurydike Core">lastCreationTimestamp: anObject	lastCreationTimestamp := anObject</body><body package="Eurydike Core">numberOfCreations	^numberOfCreations</body><body package="Eurydike Core">numberOfCreations: anObject	numberOfCreations := anObject</body></methods><methods><class-id>Eurydike.Statistic</class-id> <category>initialize-release</category><body package="Eurydike Core">initialize	super initialize.	numberOfCreations := 0.	lastCreationTimestamp := Timestamp now</body></methods><methods><class-id>Eurydike.Statistic class</class-id> <category>instance creation</category><body package="Eurydike Core">new	^super new initialize</body><body package="Eurydike Core">newWithID: anID	^self new id: anID</body></methods><methods><class-id>Core.IntegerKeyedDictionary</class-id> <category>private</category><body package="Eurydike Extensions">findKeyOrNil: key  	"Look for the key in the receiver.  If it is found, answer	the index of the association containing the key, otherwise	answer the index of the first unused slot."	| location length probe pass |	length := self basicSize.	pass := 1.	location := self initialIndexFor: key hashMultiply boundedBy: length.	[(probe := self basicAt: location) == nil or: [probe key = key]]		whileFalse: 			[(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body></methods><methods><class-id>Eurydike.SQLite3Platform</class-id> <category>accessing</category><body package="Eurydike Platforms">bindingParameterLimit	^999</body></methods><methods><class-id>Eurydike.SQLite3Platform</class-id> <category>testing</category><body package="Eurydike Platforms">checkVersionNumber: numbers greaterThan: referenceNumbers	"numbers looks like #(3 1 5), which would represent a version number 3.1.5. Same goes for referenceNumbers.	returns true if numbers is a version number that's at least as new as referenceNumber"	(1 to: referenceNumbers size) do: 			[:i |			(numbers at: i) &gt; (referenceNumbers at: i)				ifTrue: [^true]				ifFalse: [(numbers at: i) &lt; (referenceNumbers at: i) ifTrue: [^false]]].	"everything is equal, so that's ok"	^true</body></methods><methods><class-id>Eurydike.SQLite3Platform</class-id> <category>accessing schema</category><body package="Eurydike Platforms">installSchemaOn: aConnection	aConnection		executeSQLString: ('CREATE TABLE &lt;1s&gt; (  								objectid character varying,  								fieldid character varying,  								fieldtype character varying,  								keytype character varying,  								key character varying,  								valuetype character varying,  								value character varying)'	asIs				expandMacrosWith: aConnection profile schema)		onError: [].	aConnection		executeSQLString: ('CREATE TABLE &lt;1s&gt;_seq (id character varying)' asIs				expandMacrosWith: aConnection profile schema)		onError: [].	aConnection executeSQLString: ('CREATE INDEX &lt;1s&gt;_idx ON &lt;1s&gt; (objectid)' asIs				expandMacrosWith: aConnection profile schema)		onError: []</body><body package="Eurydike Platforms">newObjectIDsFor: anArray on: aConnection	^aConnection transact: 			[| records oldMaxID newMaxID |			records := aConnection executeSQLString: ('SELECT id FROM &lt;1s&gt;_seq' asIs								expandMacrosWith: aConnection profile schema).			oldMaxID := records isEmpty						ifTrue: [0]						ifFalse: [records first first asInteger].			newMaxID := oldMaxID + anArray size.			oldMaxID isZero				ifTrue: 					[aConnection executeSQLString: ('INSERT INTO &lt;1s&gt;_seq (id) VALUES (&lt;2p&gt;)' asIs								expandMacrosWith: aConnection profile schema								with: newMaxID printString)]				ifFalse: 					[aConnection						executeSQLString: ('UPDATE &lt;1s&gt;_seq SET id = &lt;2p&gt; WHERE id = &lt;3p&gt;' asIs								expandMacrosWith: aConnection profile schema								with: newMaxID printString								with: oldMaxID printString)].			oldMaxID + 1 to: newMaxID]</body><body package="Eurydike Platforms">removeSchemaOn: aConnection	aConnection executeSQLString: ('DROP TABLE &lt;1s&gt;' asIs				expandMacrosWith: aConnection profile schema)		onError: [].	aConnection executeSQLString: ('DROP TABLE &lt;1s&gt;_seq' asIs				expandMacrosWith: aConnection profile schema)		onError: [].	aConnection executeSQLString: ('DROP INDEX &lt;1s&gt;_idx' asIs				expandMacrosWith: aConnection profile schema)		onError: []</body></methods><methods><class-id>Eurydike.SQLite3Platform</class-id> <category>connect/disconnect</category><body package="Eurydike Platforms">newNativeConnection	| connection versionString versionNumbers |	connection := super newNativeConnection.	versionString := connection xif sqlite3_libversion copyCStringFromHeap.	versionNumbers := (versionString tokensBasedOn: $.) collect: #asNumber.	(self checkVersionNumber: versionNumbers greaterThan: #(3 8 3))		ifFalse: 			[self error: #ErrorSQLiteVersion &lt;&lt; #eurydike						&gt;&gt; 'SQLite version is too old. The SQLite3.dll needs to be at least 3.8.3 because Eurydike uses the recursive-statement, which was introduced in SQLite in 3.8.3'].	^connection</body></methods><methods><class-id>Eurydike.SQLite3Platform class</class-id> <category>accessing</category><body package="Eurydike Platforms">nativeConnectionClass	^#{SQLite3Connection} value</body></methods><methods><class-id>Eurydike.MigrationCollection</class-id> <category>enumerating</category><body package="Eurydike Migration">do: aBlockClosure 		mgIndexedVariables do: aBlockClosure.</body></methods><methods><class-id>Eurydike.MigrationCollection</class-id> <category>converting</category><body package="Eurydike Migration">asNormalObject		^self mgClass asSystemClass withAll: self mgIndexedVariables</body></methods><methods><class-id>Eurydike.MigrationCollection class</class-id> <category>testing</category><body package="Eurydike Migration">isResponsibleFor: objectClass	| sysClass |	sysClass := objectClass asSystemClass ifNil: [^false].	^(sysClass includesBehavior: SequenceableCollection)		and: [(sysClass includesBehavior: String) not]</body></methods><methods><class-id>Eurydike.Field</class-id> <category>accessing</category><body package="Eurydike Fields">id	^id</body><body package="Eurydike Fields">id: anInteger	id := anInteger</body><body package="Eurydike Fields">key	^key</body><body package="Eurydike Fields">key: anObject	key := anObject</body><body package="Eurydike Fields">map	^map</body><body package="Eurydike Fields">map: aFieldMap	map := aFieldMap</body><body package="Eurydike Fields">references	| references |	references := OrderedCollection new.	self key isReference ifTrue: [references add: self key].	self value isReference ifTrue: [references add: self value].	^references</body><body package="Eurydike Fields">type	^type</body><body package="Eurydike Fields">type: anObject	type := anObject</body><body package="Eurydike Fields">value	^value</body><body package="Eurydike Fields">value: anObject	value := anObject</body></methods><methods><class-id>Eurydike.Field</class-id> <category>converting</category><body package="Eurydike Fields">asFieldRow	^(FieldRow new)		objectID: self map id printString;		fieldID: self id printString;		fieldType: self type asString;		keyType: self key asFieldRowType;		key: self key asFieldRowProperty;		valueType: self value asFieldRowType;		value: self value asFieldRowProperty;		yourself</body></methods><methods><class-id>Eurydike.Field</class-id> <category>initialize-release</category><body package="Eurydike Fields">fromFieldRow: aFieldRow	self id: aFieldRow fieldID asInteger.	self type: aFieldRow fieldType asSymbol.	self		key: (aFieldRow keyType asFieldKeyType fromFieldRowProperty: aFieldRow key).	self value: (aFieldRow valueType asFieldValueType				fromFieldRowProperty: aFieldRow value)</body></methods><methods><class-id>Eurydike.Field</class-id> <category>validation</category><body package="Eurydike Fields">validate	self key isUndefinedFieldType		ifTrue: [(MissingFieldKeyType newWithField: self) raiseSignal].	self value isUndefinedFieldType		ifTrue: [(MissingFieldValueType newWithField: self) raiseSignal]</body></methods><methods><class-id>Eurydike.Field</class-id> <category>printing</category><body package="Eurydike Fields">printOn: aStream	super printOn: aStream.	(key isSurrogate not and: [key isLiteral])		ifTrue: 			[aStream				space;				print: key]</body></methods><methods><class-id>Eurydike.Field class</class-id> <category>instance creation</category><body package="Eurydike Fields">fromClass: aClass size: aSize	^self type: #classAndSize key: aClass value: aSize</body><body package="Eurydike Fields">fromFieldRow: aFieldRow	^self new fromFieldRow: aFieldRow</body><body package="Eurydike Fields">fromVersion: aVersionString timestamp: aTimestamp	^self type: #versionAndTimestamp key: aVersionString value: aTimestamp</body><body package="Eurydike Fields">type: aSymbol key: aKey value: aValue	^(self new)		type: aSymbol;		key: aKey;		value: aValue;		yourself</body></methods><methods><class-id>Eurydike.CommitUnit</class-id> <category>accessing</category><body package="Eurydike Core">commitSize	^commitSize</body><body package="Eurydike Core">commitSize: anInteger	 commitSize := anInteger</body><body package="Eurydike Core">connection	^connection</body><body package="Eurydike Core">connection: aConnection	connection := aConnection</body><body package="Eurydike Core">flushableFieldMaps	^flushableFieldMaps</body><body package="Eurydike Core">nextPendingObject	| nextObject |	nextObject := self pendingObjects any.	self pendingObjects remove: nextObject.	self addProcessedObject: nextObject.	^nextObject</body><body package="Eurydike Core">pendingObjects	^pendingObjects</body><body package="Eurydike Core">processedObjects	^processedObjects</body></methods><methods><class-id>Eurydike.CommitUnit</class-id> <category>enumerating</category><body package="Eurydike Core">fieldMapsDo: aBlock	self pendingObjectsDo: [:each | aBlock value: each asFieldMap]</body><body package="Eurydike Core">pendingObjectsDo: aBlock	[self hasPendingObjects]		whileTrue: [aBlock value: self nextPendingObject]</body></methods><methods><class-id>Eurydike.CommitUnit</class-id> <category>actions</category><body package="Eurydike Core">commit	self fieldMapsDo: 			[:map |			map references do: [:reference | self addReference: reference].			self addFlushableFieldMap: map].	self flushFieldMaps</body><body package="Eurydike Core">flushFieldMaps	self connection commitFieldMaps: self flushableFieldMaps.	flushableFieldMaps := OrderedCollection new</body></methods><methods><class-id>Eurydike.CommitUnit</class-id> <category>testing</category><body package="Eurydike Core">hasPendingObjects	^self pendingObjects notEmpty</body><body package="Eurydike Core">isNewObject: anObject	^self connection isNew: anObject</body><body package="Eurydike Core">isPendingObject: anObject	^self pendingObjects includes: anObject</body><body package="Eurydike Core">isProcessedObject: anObject	^self processedObjects includes: anObject</body></methods><methods><class-id>Eurydike.CommitUnit</class-id> <category>adding</category><body package="Eurydike Core">addFlushableFieldMap: aFieldMap	self flushableFieldMaps add: aFieldMap.	self flushableFieldMaps size &gt;= self commitSize ifTrue: [self flushFieldMaps].	^aFieldMap</body><body package="Eurydike Core">addPendingObject: anObject	(self isProcessedObject: anObject) ifTrue: [^anObject].	(self isPendingObject: anObject) ifTrue: [^anObject].	self pendingObjects add: anObject.	^anObject</body><body package="Eurydike Core">addPendingObjects: anArray	anArray do: [:each | self addPendingObject: each]</body><body package="Eurydike Core">addProcessedObject: anObject	self processedObjects add: anObject.	^anObject</body><body package="Eurydike Core">addReference: aReference	"A reference can contain a			1) a self-proxy from the current connection (uninteresting, because it is not read from database yet)		2) a non-modified object (uninteresting, because it has no modifications to write here)		3) a modified-object (uninteresting, because it was already in the initial modification tracker list)		3) a new object (important: needs to be added and written)		4) a foreign-proxy from an other connection (important: needs to be resolved and real object needs to be written)			4.1) if the proxy is already resolved, no need to resolve again but the rest still needs to be done			For case 4) we update also the reference with the new resolved object, so that the owner of the reference is written	correctly to database, else the reference points to a wrong fieldmap that contains the old foreign-proxy with foreign-id."	| refMap refObject resolvedReference resolvedRefMap resolvedRefObject |	refMap := aReference value.	refObject := refMap value.	refMap looksLikeSurrogate		ifTrue: 			[resolvedRefObject := refMap hasResolvedSurrogate						ifTrue: 							["see 4.1) above"							refObject]						ifFalse: 							[(refObject isSurrogateForConnection: connection)								ifTrue: 									["see 1) above"									^self]								ifFalse: 									["see 4) above"									refObject resolvedValue]].			resolvedReference := resolvedRefObject asFieldProperty.			resolvedRefMap := resolvedReference value.			aReference value: resolvedRefMap.			self addPendingObject: resolvedRefObject]		ifFalse: 			[(self isNewObject: refObject) ifTrue: [self addPendingObject: refObject]]</body></methods><methods><class-id>Eurydike.CommitUnit</class-id> <category>initialize-release</category><body package="Eurydike Core">initialize	super initialize.	pendingObjects := IdentitySet new.	processedObjects := IdentitySet new.	flushableFieldMaps := OrderedCollection new.	commitSize := 100</body></methods><methods><class-id>Eurydike.CommitUnit class</class-id> <category>instance creation</category><body package="Eurydike Core">new	^super new initialize</body><body package="Eurydike Core">newForConnection: aConnection	^(self new)		connection: aConnection;		commitSize: aConnection profile policy instanceCommitSize;		addPendingObjects: aConnection modificationTracker modifications;		yourself</body></methods><methods><class-id>Eurydike.Surrogate</class-id> <category>accessing</category><body package="Eurydike Core">addOwnerID: anID	self ownerIDs add: anID</body><body package="Eurydike Core">basicSize	^0</body><body package="Eurydike Core">class	^Surrogate</body><body package="Eurydike Core">identityHash	"Answer a SmallInteger that is equal to the identityHash of 	any object that is == to the receiver. 	When two objects are not ==, their identityHash values may or may not 	be the same. The identityHash value does not change across the life	of the object."	"If identityHash is redefined in a subclass, the new implementation must	answer the same identityHash when two objects are ==. Changing the	== method has no effect on the execution machinery -- in effect, you	cannot redefine == to echo a changed implementation of identityHash.	Primitive 75 fails for immediate objects, so immediate subclasses such as	SmallInteger must override this method."	&lt;primitive: 75&gt;	self primitiveFailed</body><body package="Eurydike Core">ownerIDs	^ownerIDs</body></methods><methods><class-id>Eurydike.Surrogate</class-id> <category>intialize-release</category><body package="Eurydike Core">initializeFromFieldMap: aFieldMap	self initializeWithID: aFieldMap id</body><body package="Eurydike Core">initializeOwnerIDs	ownerIDs := Set new</body><body package="Eurydike Core">initializeWithConnection: aConnection	connection := aConnection</body><body package="Eurydike Core">initializeWithID: anID	id := anID</body></methods><methods><class-id>Eurydike.Surrogate</class-id> <category>converting</category><body package="Eurydike Core">asFieldMap	^self resolvedValue asFieldMap</body><body package="Eurydike Core">asFieldMapValue	^self</body><body package="Eurydike Core">asFieldProperty	^(Eurydike.FieldMap on: self)		id: id;		targetClass: Surrogate;		namedAt: #id put: id;		asReference</body></methods><methods><class-id>Eurydike.Surrogate</class-id> <category>printing</category><body package="Eurydike Core">printOn: aStream	aStream		nextPutAll: 'Proxy(ID = ' asIs;		print: id;		nextPut: $)</body><body package="Eurydike Core">printString	| stream |	stream := WriteStream on: (String new: 64).	self printOn: stream.	^stream contents</body></methods><methods><class-id>Eurydike.Surrogate</class-id> <category>error handling</category><body package="Eurydike Core">doesNotUnderstand: aMessage	^self resolvedValue perform: aMessage selector		withArguments: aMessage arguments</body><body package="Eurydike Core">error: aString	^1 error: aString</body><body package="Eurydike Core">primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	self error: (#errPrimitiveFailed &lt;&lt; #eurydike &gt;&gt; 'a primitive has failed')</body></methods><methods><class-id>Eurydike.Surrogate</class-id> <category>testing</category><body package="Eurydike Core">isImmediate	^false</body><body package="Eurydike Core">isSurrogate	^true</body><body package="Eurydike Core">isSurrogateForConnection: aConnection	^connection == aConnection</body></methods><methods><class-id>Eurydike.Surrogate</class-id> <category>system primitives</category><body package="Eurydike Core">beImmutable	"Set the receiver to be immutable"	self isImmutable: true.	^self</body><body package="Eurydike Core">beMutable	"Set the receiver to be mutable"	self isImmutable: false.	^self</body><body package="Eurydike Core">become: otherObject	"Swap the instance data and appropriate header information of the receiver and the	 argument, otherObject. In other words, transform the receiver into the argument and	 vice-versa.  Fail if either object is an immediate or a MethodContext or a	 BlockContext or if there is insufficient memory to perform the become, or if either	 object is immutable. Answer with the argument which is now the semantic equivalent	 of the object that formerly denoted the receiver."	&lt;primitive: 72 errorCode: errCode&gt;	^self error: #ErrorSurrogateBecomeFailed &lt;&lt; #eurydike				&gt;&gt; 'surrogate cannot become another object - primitive failed'</body><body package="Eurydike Core">isImmutable	"Answer if the receiver is immutable.  This is always true of immediates.	 Cannot fail."	&lt;primitive: 1063&gt;	^false</body><body package="Eurydike Core">isImmutable: aBoolean	"Set the receiver's immutability.   Answer if the receiver was	 previously immutable.  Fail if the argument is not a boolean	 or if the receiver is immediate and the argument is false."	&lt;primitive: 1064 errorCode: error&gt;	^self primitiveFailed</body></methods><methods><class-id>Eurydike.Surrogate</class-id> <category>private</category><body package="Eurydike Core">nilFields	^self</body></methods><methods><class-id>Eurydike.Surrogate</class-id> <category>resolving</category><body package="Eurydike Core">resolvedValue	| value |	value := connection instanceWithID: id.	value		ifNil: 			[^self				error: (#ErrorSurrogateResolveFailed &lt;&lt; #eurydike						&gt;&gt; 'could not resolve surrogate with id &lt;1p&gt;' expandMacrosWith: id)].	^value</body></methods><methods><class-id>Eurydike.Surrogate</class-id> <category>trippy</category><body package="Eurydike Core">basicInspectorClass	^Inspector</body><body package="Eurydike Core">inspect	"Create and schedule an Inspector in which the user can examine the	receiver's variables. Use the Trippy inspector if it's available. Return the reciever."		#{Tools.Trippy.Inspector}		ifDefinedDo:			[:trippy | 			trippy useSimpleInspector				ifFalse:					[trippy openOn: self.					^self]].	self inspectorClass openOn: self</body><body package="Eurydike Core">inspectorClass	^Inspector</body><body package="Eurydike Core">inspectorClasses	"Answer a sequence of inspector classes that can represent the receiver in an	inspector. The first page in the array is the one used by default in a new inspector."	^Array with: Tools.Trippy.BasicInspector</body><body package="Eurydike Core">inspectorCollaborators	"Answer a collection of Collaborator instances listing the important other	objects a person looking at this one might want to see. For example,	collaborators of a view would be its model and the controller.	Collaborators are added to the inspector's Go menu."	^#()</body><body package="Eurydike Core">inspectorHierarchies	"Answer a collection of instances of Hierarchy describing the hierarchies	this object is a member of."	^#()</body></methods><methods><class-id>Eurydike.Surrogate class</class-id> <category>instance creation</category><body package="Eurydike Core">new	^self basicNew initializeOwnerIDs</body><body package="Eurydike Core">newEmptyFromFieldMap: aFieldMap	^self new</body><body package="Eurydike Core">withID: anID	^self new initializeWithID: anID</body></methods><methods><class-id>Tools.Trippy.NamedVariable</class-id> <category>accessing</category><body package="Eurydike Fixes">displayText	| text targetClass size |	text := super displayText.	targetClass := Inspector classOfObject: object.	size := targetClass superclass ifNil: [0] ifNotNil: [:sc | sc instSize].	^index &gt; size ifTrue: [text allBold] ifFalse: [text]</body></methods><methods><class-id>Core.Symbol</class-id> <category>converting</category><body package="Eurydike Extensions">capitalized	^(self asString)		at: 1 put: (self at: 1) asUppercase;		asSymbol</body></methods><methods><class-id>Core.Dictionary</class-id> <category>private</category><body package="Eurydike Extensions">rehashForSurrogates	^self rehash</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="Eurydike Extensions">rehashForSurrogates	^self</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Eurydike Extensions">asInteger	^(Number readFrom: self readStream) asInteger</body><body package="Eurydike Extensions">capitalized	^self isEmpty		ifTrue: [self]		ifFalse: 			[(self asString copy)				at: 1 put: self first asUppercase;				yourself]</body></methods><methods><class-id>Core.Object class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^self		error: (#genericObjectsCannotBeC___dFromAFieldRowProperty &lt;&lt; #eurydike				&gt;&gt; 'generic objects cannot be created from a field row property') asString</body><body package="Eurydike Fields">newEmptyFromFieldMap: aFieldMap	^self isVariable		ifTrue: [self new: aFieldMap targetSize]		ifFalse: [self new]</body></methods><methods><class-id>Core.Object</class-id> <category>accessing fields</category><body package="Eurydike Fields">allFieldVarIndices	^1 to: self basicSize</body><body package="Eurydike Fields">asFieldMap	| map |	map := Eurydike.FieldMap on: self.	map targetClass: self class.	map targetSize: self basicSize.	map targetVersion: self fieldMapVersion.	self class allFieldVarNames		do: [:name | map namedAt: name put: (self instVarNamed: name)].	self allFieldVarIndices		do: [:index | map indexedAt: index put: (self basicAt: index)].	^map</body><body package="Eurydike Fields">asFieldMapValue	^self</body><body package="Eurydike Fields">asFieldProperty	^(Eurydike.FieldMap on: self)		targetClass: self class;		asReference</body><body package="Eurydike Fields">asFieldRowProperty	self		cannotBeExpressedAsFieldRowProperty: (#genericObjects &lt;&lt; #eurydike				&gt;&gt; 'generic objects') asString</body><body package="Eurydike Fields">asFieldRowType	^self class asFieldRowProperty</body><body package="Eurydike Fields">cannotBeExpressedAsFieldRow: objectDescription	Eurydike.FieldMapPrimitiveError		raiseErrorString: (#__1sArePrimitiveTypesAn___tBeExpressedAsFieldmap				&lt;&lt; #eurydike					&gt;&gt; '&lt;1s&gt; are primitive types and cannot be expressed as fieldmap'					expandMacrosWith: objectDescription)</body><body package="Eurydike Fields">cannotBeExpressedAsFieldRowProperty: objectDescription	self		error: (#ErrorGenericFieldRowProperty &lt;&lt; #eurydike				&gt;&gt; '&lt;1s&gt; cannot be expressed as field row property'					expandMacrosWith: objectDescription)</body><body package="Eurydike Fields">fieldMapVersion		^nil</body><body package="Eurydike Fields">initializeFromFieldMap: aFieldMap	aFieldMap namedFields do: 			[:namedField |			self instVarNamed: namedField key asString				put: namedField value asFieldMapValue].	aFieldMap indexedFields		do: [:indexedField | self basicAt: indexedField key put: indexedField value asFieldMapValue]</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Eurydike Fields">isReference	^false</body><body package="Eurydike Fields">isUndefinedFieldType	^false</body></methods><methods><class-id>Core.Object</class-id> <category>accessing fields</category><body package="Eurydike Fields">postBuildFromFieldMap: aFieldMap	^self</body></methods><methods><class-id>Core.Message</class-id> <category>accessing fields</category><body package="Eurydike Fields">postBuildFromFieldMap: aFieldMap	"Just resolve the argument array in case it is a surrogate. When somebody uses the message for a #perform:withArguments: it can fail when	 the argument array is not fully resolved"	self arguments yourself</body></methods><methods><class-id>Core.Integer class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^Integer readFrom: aString readStream</body></methods><methods><class-id>Core.Integer</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldRowProperty	^self printString</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^aString asQualifiedReference value</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	| map index |	map := Eurydike.FieldMap on: self.	map targetClass: self class.	map targetSize: self size.	map targetVersion: self fieldMapVersion.	index := 1.	self do: 			[:each |			map indexedAt: index put: each.			index := index + 1].	^map</body><body package="Eurydike Fields">initializeFromFieldMap: aFieldMap	| sortedFields |	sortedFields := aFieldMap indexedFields sorted: #key ascending.	sortedFields		do: [:indexedField | self add: indexedField value asFieldMapValue]</body></methods><methods><class-id>UI.Model class</class-id> <category>accessing fields</category><body package="Eurydike Fields">fieldVarNames	^self instVarNames reject: [:each | each = 'dependents' asIs]</body></methods><methods><class-id>Core.FixedPoint class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	| parts fractionParts numerator denominator scale |	parts := aString tokensBasedOn: $*.	fractionParts := parts first tokensBasedOn: $/.	numerator := Integer readFrom: fractionParts first trimBlanks readStream.	denominator := Integer readFrom: fractionParts last trimBlanks readStream.	scale := Integer readFrom: parts last trimBlanks readStream.	^self numerator: numerator denominator: denominator scale: scale</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldRowProperty	^'&lt;1p&gt; / &lt;2p&gt; * &lt;3p&gt;' asIs		expandMacrosWith: self numerator		with: self denominator		with: self scale</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^self fromPackedString: aString</body></methods><methods><class-id>Core.ByteArray</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	self		cannotBeExpressedAsFieldRow: (#byteArrays &lt;&lt; #eurydike &gt;&gt; 'byte arrays')				asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	^self asPackedString</body></methods><methods><class-id>Core.LimitedPrecisionReal class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	| parts signedMantissa biasedExponent |	parts := aString tokensBasedOn: $*.	signedMantissa := Number readFrom: parts first trimBlanks readStream.	biasedExponent := Number				readFrom: (parts last allButLast: 1) trimBlanks readStream.	^self fromSignedMantissa: signedMantissa		andExponent: biasedExponent + self precision - 1</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldRowProperty	^'&lt;1p&gt; * (2 ** &lt;2p&gt;)' asIs expandMacrosWith: self signedMantissa		with: self exponent - self class precision + 1</body></methods><methods><class-id>Core.Symbol class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^aString asSymbol</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	| map |	map := Eurydike.FieldMap on: self.	map targetClass: self class.	map targetSize: self size.	map targetVersion: self fieldMapVersion.	self doWithIndex: [:each :index | map indexedAt: index put: each].	^map</body><body package="Eurydike Fields">initializeFromFieldMap: aFieldMap	aFieldMap indexedFields		do: [:indexedField | self at: indexedField key put: indexedField value asFieldMapValue]</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	| dateAndTimeProperties date time |	dateAndTimeProperties := aString tokensBasedOn: Character space.	date := Date fromFieldRowProperty: dateAndTimeProperties first.	time := Time fromFieldRowProperty: dateAndTimeProperties last.	^self fromDate: date andTime: time</body></methods><methods><class-id>Core.Timestamp</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	self		cannotBeExpressedAsFieldRow: (#timestamps &lt;&lt; #eurydike &gt;&gt; 'timestamps')				asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	^'&lt;1s&gt; &lt;2s&gt;' asIs expandMacrosWith: self asDate asFieldRowProperty		with: self asTime asFieldRowProperty</body></methods><methods><class-id>Core.Number class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^self subclassResponsibility</body></methods><methods><class-id>Core.Number</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	self		cannotBeExpressedAsFieldRow: (#numbers &lt;&lt; #eurydike &gt;&gt; 'numbers') asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	^self subclassResponsibility</body></methods><methods><class-id>Core.UninterpretedBytes class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^self from: (ByteArray fromFieldRowProperty: aString)</body></methods><methods><class-id>Core.UninterpretedBytes</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	self		cannotBeExpressedAsFieldRow: (#uninterpretedBytes &lt;&lt; #eurydike				&gt;&gt; 'uninterpreted bytes') asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	^self asByteArray asFieldRowProperty</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	^Eurydike.BadObjectGraphError		raiseErrorString: (#ErrorStoreApplicationModel &lt;&lt; #eurydike				&gt;&gt; 'Attempting to store an application model to the database.&lt;n&gt;This indicates potentially a bad object graph design in your application.&lt;n&gt;If you want to really store an application model please remove the current&lt;n&gt;implementation of #asFieldMapUsing: that raises this error.')					expandMacros</body></methods><methods><class-id>Core.UndefinedObject class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^nil</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	self		cannotBeExpressedAsFieldRow: (#undefinedObjects &lt;&lt; #eurydike				&gt;&gt; 'undefined objects') asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	^'nil' asIs</body></methods><methods><class-id>Core.Behavior</class-id> <category>private</category><body package="Eurydike Fields">accumulateFieldVarNames: names	self superclass == nil ifFalse:		[self superclass accumulateFieldVarNames: names].	names addAllLast: self fieldVarNames.</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing fields</category><body package="Eurydike Fields">allFieldVarNames	"Answer an Array of the names of the receiver's field variables."	| names |	names := OrderedCollection new: self instSize.	self accumulateFieldVarNames: names.	^names</body><body package="Eurydike Fields">asFieldMap	self cannotBeExpressedAsFieldRow: (#classes &lt;&lt; #eurydike &gt;&gt; 'classes') asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	^self fullName</body><body package="Eurydike Fields">fieldVarNames	^self instVarNames</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	| tokens |	tokens := aString tokensBasedOn: $:.	^(self new)		hours: tokens first asInteger			minutes: (tokens at: 2) asInteger			seconds: (tokens at: 3) asInteger			milliseconds: (tokens at: 4) asInteger			partialNanosecond: (tokens at: 5) asInteger;		yourself</body></methods><methods><class-id>Core.Time</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	self		cannotBeExpressedAsFieldRow: (#timeObjects &lt;&lt; #eurydike &gt;&gt; 'time objects')				asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	| stream |	stream := WriteStream on: (String new: 64).	stream		print: self hours;		nextPut: $:;		print: self minutes;		nextPut: $:;		print: self seconds;		nextPut: $:;		print: self milliseconds;		nextPut: $:;		print: self partialNanosecond.	^stream contents</body></methods><methods><class-id>Core.Boolean class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^aString = 'true' asIs</body></methods><methods><class-id>Core.Boolean</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	self cannotBeExpressedAsFieldRow: (#booleans &lt;&lt; #eurydike &gt;&gt; 'booleans') asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	^self ifTrue: ['true' asIs] ifFalse: ['false' asIs]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	| map |	map := Eurydike.FieldMap on: self.	map targetClass: self class.	map targetSize: self size.	map targetVersion: self fieldMapVersion.	self keysAndValuesDo: [:key :value | map genericAt: key put: value].	^map</body><body package="Eurydike Fields">initializeFromFieldMap: aFieldMap	aFieldMap genericFields do: 			[:genericField |			self at: genericField key asFieldMapValue				put: genericField value asFieldMapValue]</body></methods><methods><class-id>Kernel.GeneralBindingReference class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^aString asQualifiedReference</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	self		cannotBeExpressedAsFieldRow: (#bindingReferences &lt;&lt; #eurydike				&gt;&gt; 'binding references') asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	^self asString</body></methods><methods><class-id>Core.Bag</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	| map |	map := Eurydike.FieldMap on: self.	map targetClass: self class.	map targetSize: self size.	map targetVersion: self fieldMapVersion.	self valuesAndCountsDo: [:value :count | map genericAt: value put: count].	^map</body><body package="Eurydike Fields">initializeFromFieldMap: aFieldMap	aFieldMap genericFields do: 			[:genericField |			self add: genericField key asFieldMapValue				withOccurrences: genericField value asFieldMapValue]</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	| tokens |	tokens := aString tokensBasedOn: $-.	^self		newDay: (tokens at: 3) asInteger		monthNumber: (tokens at: 2) asInteger		year: tokens first asInteger</body></methods><methods><class-id>Core.Date</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldMap	^self		cannotBeExpressedAsFieldRow: (#dates &lt;&lt; #eurydike &gt;&gt; 'dates') asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	| stream |	stream := WriteStream on: (String new: 10).	stream		print: self year;		nextPut: $-;		print: self monthIndex;		nextPut: $-;		print: self dayOfMonth.	^stream contents</body></methods><methods><class-id>Core.OrderedCollection class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">newEmptyFromFieldMap: aFieldMap	^self withSize: aFieldMap targetSize</body></methods><methods><class-id>Core.CharacterArray class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	^aString</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldKeyType	^self asFieldType</body><body package="Eurydike Fields">asFieldMap	self		cannotBeExpressedAsFieldRow: (#characterArrays &lt;&lt; #eurydike				&gt;&gt; 'character arrays') asString</body><body package="Eurydike Fields">asFieldProperty	^self</body><body package="Eurydike Fields">asFieldRowProperty	^self asString</body><body package="Eurydike Fields">asFieldType	| tokens type |	tokens := self tokensBasedOn: Character space.	type := tokens first asQualifiedReference				valueOrDo: [^Eurydike.UndefinedFieldType name: tokens first].	tokens last = 'class' asIs ifTrue: [type := type classBehavior].	^type</body><body package="Eurydike Fields">asFieldValueType	^self asFieldType</body></methods><methods><class-id>Core.Fraction class</class-id> <category>instance creation fields</category><body package="Eurydike Fields">fromFieldRowProperty: aString	| parts numerator denominator |	parts := aString tokensBasedOn: $/.	numerator := Integer readFrom: parts first trimBlanks readStream.	denominator := Integer readFrom: parts last trimBlanks readStream.	^self numerator: numerator denominator: denominator</body></methods><methods><class-id>Core.Fraction</class-id> <category>accessing fields</category><body package="Eurydike Fields">asFieldRowProperty	^'&lt;1p&gt; / &lt;2p&gt;' asIs expandMacrosWith: self numerator with: self denominator</body></methods><methods><class-id>Core.Dictionary</class-id> <category>notifications</category><body package="Eurydike Modifications">notifyAboutModification	"Here we trigger the immutability handler system, so that Eurydike can track that as modification. We achieve this by simply settings an instance variable."	tally := tally</body><body package="Eurydike Modifications">notifyMarkAsUnmodified	"We convert here all our internal Association elements into ModificationAssociation objects, so we can track modifications on that"	tally == 0 ifTrue: [^self].	1 to: self basicSize		do: 			[:index |			| elem |			(elem := self basicAt: index) == nil				ifFalse: 					[self basicAt: index						put: ((Eurydike.ModificationAssociation key: elem key value: elem value)								owner: self;								yourself)]]</body></methods><methods><class-id>Core.Object</class-id> <category>notifications</category><body package="Eurydike Modifications">notifyMarkAsUnmodified	^self</body></methods><methods><class-id>Core.Bag</class-id> <category>notifications</category><body package="Eurydike Modifications">notifyAboutModification	"Here we trigger the immutability handler system, so that Eurydike can track that as modification. We achieve this by simply settings an instance variable."	contents := contents</body><body package="Eurydike Modifications">notifyMarkAsUnmodified	"We convert here our internal contents Dictionary into a ModificationDictionary, so that we can track modifications on that."	contents := (Eurydike.ModificationDictionary new)				addAll: contents associations;				owner: self;				yourself</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>notifications</category><body package="Eurydike Modifications">notifyAboutModification	"Here we trigger the immutability handler system, so that Eurydike can track that as modification. We achieve this by simply settings an instance variable."	valueArray := valueArray</body><body package="Eurydike Modifications">notifyMarkAsUnmodified	"We convert here our internal valueArray into a ModificationArray, so that we can track modifications on that."	valueArray := (Eurydike.ModificationArray withAll: valueArray)				owner: self;				yourself</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Eurydike Core">isSurrogate	^false</body><body package="Eurydike Core">shouldRealizeSurrogateInEurydike	^true</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>converting</category><body package="Eurydike Migration">mgClass	self isAbsolute		ifFalse: [self error: (#migrationObjectClassesNeedFullQualifiedNames &lt;&lt; #eurydike	&gt;&gt; 'migration object classes need full qualified names') asString].	^Eurydike.MigrationObjectClass newForBinding: self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Eurydike Migration">isMigrationObject	^false</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Eurydike Migration">decapitalized	^(self first: 1) asLowercase, (self allButFirst: 1)</body><body package="Eurydike Migration">mgClass	^self asQualifiedReference mgClass</body></methods><methods><class-id>Eurydike.ConnectionDialog class</class-id> <category>interface specs</category><body package="Eurydike UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ConnectToDatabase 				#defaultString: 'Connect to Database' 				#catalogID: #eurydike ) 			#min: #(#{Core.Point} 449 220 ) 			#max: #(#{Core.Point} 449 220 ) 			#bounds: #(#{Graphics.Rectangle} 1056 590 1505 810 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 45 0 -10 1 70 0 ) 					#name: #enviromentID 					#model: #'profileHolder environment' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 80 0 -10 1 105 0 ) 					#name: #usernameID 					#model: #'profileHolder username' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 115 0 -10 1 140 0 ) 					#name: #passwordID 					#model: #'profileHolder password' 					#type: #password ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 100 0 35 0 ) 					#name: #platformLabelID 					#label: 					#(#{Kernel.UserMessage} 						#key: #Platform 						#defaultString: 'Platform' 						#catalogID: #eurydike ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 45 0 100 0 70 0 ) 					#name: #environmentLabelID 					#label: 					#(#{Kernel.UserMessage} 						#key: #Environment 						#defaultString: 'Environment' 						#catalogID: #eurydike ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 80 0 100 0 105 0 ) 					#name: #usernameLabelID 					#label: 					#(#{Kernel.UserMessage} 						#key: #Username 						#defaultString: 'Username' 						#catalogID: #eurydike ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 115 0 100 0 140 0 ) 					#name: #passwordLabelID 					#label: 					#(#{Kernel.UserMessage} 						#key: #Password 						#defaultString: 'Password' 						#catalogID: #eurydike ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 185 0 -5 0.5 210 0 ) 					#name: #connectID 					#model: #connect 					#label: 					#(#{Kernel.UserMessage} 						#key: #connect 						#defaultString: 'Connect' 						#catalogID: #eurydike ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.5 185 0 -10 1 210 0 ) 					#name: #cancelID 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #cancel 						#defaultString: 'Cancel' 						#catalogID: #eurydike ) 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 10 0 -10 1 35 0 ) 					#name: #platformID 					#model: #'profileHolder platformClass' 					#menu: #availablePlatformClassesMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 150 0 100 0 175 0 ) 					#name: #schemaID 					#label: 					#(#{Kernel.UserMessage} 						#key: #Schema 						#defaultString: 'Schema' 						#catalogID: #eurydike ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 150 0 -10 1 175 0 ) 					#name: #schemaID 					#model: #'profileHolder schema' ) ) ) )</body></methods><initialize><class-id>Eurydike.Migrator</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>NamedVariable</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Part</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name class index protected </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><class><name>Message</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>EphemeralValueDictionary</name><environment>Core</environment><super>Core.EphemeronDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>keepAround </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>GlorpVWPort</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>UninterpretedBytes</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>powersOfTwo </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ModificationTracker</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Bag</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class></st-source>