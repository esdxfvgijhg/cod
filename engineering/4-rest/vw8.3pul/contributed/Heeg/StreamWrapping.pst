<?xml version="1.0"?><st-source><!-- Name: StreamWrappingNotice: © Copyright 2013 Georg Heeg e.K.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.(MIT License)Comment: EncodedStreams are reconstructed in a way that they can be composed on top of each other. The main new class is WrappingStream.These featues have been developped for ByteOrderMark support. It turned out that the concept was very helpful to improve URI Support also.DbIdentifier: magdi.heeg.de.postgresDbTrace: 42847DbUsername: georgDbVersion: 7.10 - 2PackageName: StreamWrappingParcel: #('StreamWrapping')ParcelDirectory: c:\visworks\vw8.0 sep14.2\image\HeegContributions-vw8.0-2014-09-25-2\StreamWrappingPrintStringCache: (7.10 - 2,georg)Version: 7.10 - 2Datum:3:31:07 PM September 25, 2014 --><time-stamp>Von VisualWorks®, 8.0 von 15. September 2014 am 25. September 2014 um 15:31:07</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WrappingStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StreamWrapping</package></attributes></class><comment><class-id>Core.WrappingStream</class-id><body>WrappingStream is a wrapper class which just delegates all messages to the wrapped stream.Its main purpose is to be a superclass of classes which manipulate the stream. WappingStream implements default behavior, formally it is not an abstract class.You can wrap internal stream as well as external ones.Instance Variables	stream				&lt;Stream&gt;			wrapped stream.</body></comment><class><name>EncodedStream</name><environment>Core</environment><super>Core.WrappingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binary encoder policy lineEndConvention lineEndCharacter skipSize </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>StreamWrapping</package></attributes></class><comment><class-id>Core.EncodedStream</class-id><body>EncodedStream is a wrapper class to provide various encoded streams.You can wrap internal stream as well as external ones.Instance Variables:	binary				&lt;Boolean&gt;			switch to indicate it is binary mode now.	stream				&lt;Stream&gt;			wrapped stream.	encoder				&lt;StreamEncoder&gt;	a StreamEncoder to decode/encode stream.	policy				&lt;StreamPolicy&gt;		policy for choosing the print format for various entities, such as Dates, Times, currencies, or other context-sensitive information	lineEndConvention	&lt;SmallInteger&gt;		how to interpret line end in text mode.	lineEndCharacter	&lt;Character&gt;			line end character or nil.	skipSize			&lt;nil | SmallInteger&gt;		number of bytes to skip back one character.</body></comment><methods><class-id>Core.WrappingStream</class-id> <category>accessing</category><body package="StreamWrapping">commit	"Commit any unwritten information to the OS."	^stream commit</body><body package="StreamWrapping">contents	^stream contents</body><body package="StreamWrapping">encodedContents	"return the encoded bytes"	^self subclassResponsibility</body><body package="StreamWrapping">encoder	self subclassResponsibility</body><body package="StreamWrapping">encoder: aStreamEncoder	self subclassResponsibility</body><body package="StreamWrapping">encoding	self subclassResponsibility</body><body package="StreamWrapping">flush	"Forward #flush message to actual stream to write any unwritten information."	^stream flush</body><body package="StreamWrapping">next	^stream next</body><body package="StreamWrapping">nextPut: anObject	^stream nextPut: anObject</body><body package="StreamWrapping">peek	"Answer what would be returned with a self next, without	changing position.  If the receiver is at the end, answer nil."	^stream peek</body><body package="StreamWrapping">peekFor: anObject	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	^stream peekFor: anObject</body><body package="StreamWrapping">size	"Answer the size of stream."	^stream size</body><body package="StreamWrapping">skip: anInteger	stream skip: anInteger</body><body package="StreamWrapping">skipToAll: aCollection	"Skip forward to the next occurrence (if any) of aCollection.	If found, leave the stream positioned before the occurrence,	and answer the receiver; if not found, answer nil,	and leave the stream positioned at the end."	^stream skipToAll: aCollection</body><body package="StreamWrapping">stream	"Answer the actual stream of the receiver."	^stream</body><body package="StreamWrapping">stream: aStream	"Set aStream to be the stream of the receiver."	stream := aStream</body><body package="StreamWrapping">throughAll: aCollection	"Answer a subcollection from the current position	through the occurrence (if any, inclusive) of aCollection,	and leave the stream positioned after the occurrence.	If no occurrence is found, answer the entire remaining	stream contents, and leave the stream positioned at the end. "	^stream throughAll: aCollection</body><body package="StreamWrapping">upToAll: aCollection	" Answer a subcollection from the current position	up to the occurrence (if any, not inclusive) of aCollection,	and leave the stream positioned before the occurrence.	If no occurrence is found, answer the entire remaining	stream contents, and leave the stream positioned at the end. "	^stream upToAll: aCollection</body></methods><methods><class-id>Core.WrappingStream</class-id> <category>testing</category><body package="StreamWrapping">atEnd	"Forward message #atEnd to the actual stream."	^stream atEnd</body><body package="StreamWrapping">isEmpty	"Answer if the receiver contains no elements."	^stream isEmpty</body><body package="StreamWrapping">isExternalStream	"Answer if the receiver is a stream on an external collection. This 	 depends on whether the receiver's underlying stream is an external 	 stream."	^stream isExternalStream</body><body package="StreamWrapping">isReadable	^stream isReadable</body><body package="StreamWrapping">isSegmented	^stream isSegmented</body><body package="StreamWrapping">isWritable	^stream isWritable</body><body package="StreamWrapping">noPendingBufferredData	^stream noPendingBufferredData</body><body package="StreamWrapping">notEmpty	"Answer if the receiver contains any elements."	^stream notEmpty</body></methods><methods><class-id>Core.WrappingStream</class-id> <category>status</category><body package="StreamWrapping">close	^stream close</body></methods><methods><class-id>Core.WrappingStream</class-id> <category>private</category><body package="StreamWrapping">contentsSpecies	^stream contentsSpecies</body><body package="StreamWrapping">setBinary: aBoolean	stream setBinary: aBoolean</body><body package="StreamWrapping">setLineEndCharacter	"Set the end of line convention to be the character associated with aNumber."	stream setLineEndCharacter</body><body package="StreamWrapping">setLineEndConventionFromContents	^stream setLineEndConventionFromContents</body></methods><methods><class-id>Core.WrappingStream</class-id> <category>stream modes</category><body package="StreamWrapping">binary	"Set the receiver's buffer to be binary."	self setBinary: true</body><body package="StreamWrapping">isBinary	"Answer whether the receiver's data is byte or character."	^stream isBinary</body><body package="StreamWrapping">isText	"Answer true if the receiver's data is character."	^self isBinary not</body><body package="StreamWrapping">lineEndConvention	"Answer with the character that is the end of line convention."	^stream lineEndConvention</body><body package="StreamWrapping">lineEndConvention: aNumber	"Set the end of line convention to be the character associated with aNumber."	stream lineEndConvention: aNumber</body><body package="StreamWrapping">text	"Set the receiver's buffer to be character."	self setBinary: false</body></methods><methods><class-id>Core.WrappingStream</class-id> <category>positioning</category><body package="StreamWrapping">position	"Answer the receiver's position."	^stream position</body><body package="StreamWrapping">position: anInteger	"Set position to anInteger."	stream position: anInteger</body><body package="StreamWrapping">readPosition	"Answer the receiver's position where next read will take place."	^stream readPosition</body><body package="StreamWrapping">reset	"Set the receiver's position to 0 and reset the encoder's state if necessary."	stream reset</body><body package="StreamWrapping">setToEnd	"Answer the receiver's position."	stream setToEnd</body><body package="StreamWrapping">withPosition: aPosition do: aBlock	"Save the current positon of the stream, position the stream to aPosition and	 then evaluate aBlock with the current position of the stream as an argument.	 Then reset the position to the original position.	 Answer the value returned by aBlock."	| savedPosition |	savedPosition := self position.	self position: aPosition.	^[aBlock value: savedPosition] ensure: [self position: savedPosition]</body><body package="StreamWrapping">writePosition	"Answer the receiver's write position."	^stream writePosition</body></methods><methods><class-id>Core.WrappingStream</class-id> <category>connection accessing</category><body package="StreamWrapping">fileName	"Answer the Filename of the io connection being streamed over."	^stream fileName</body><body package="StreamWrapping">ioConnection	"Answer the receiver's ioConnection."	^stream ioConnection</body><body package="StreamWrapping">logicalName	"Answer the name of the io connection, without binding any 	variables if the name is computed."	^stream logicalName</body><body package="StreamWrapping">name	"Answer the name of the io connection being streamed over."	^stream name</body></methods><methods><class-id>Core.WrappingStream</class-id> <category>printing</category><body package="StreamWrapping">displayString	^stream displayString</body><body package="StreamWrapping">printOn: aStream	"Append to the argument aStream a sequence of characters that identifies the receiver."	aStream nextPutAll: (#wrappingStreamPrint &lt;&lt; #dialogs &gt;&gt; 'an &lt;1p&gt; on &lt;2p&gt;'			expandMacrosWith: self class			with: stream)</body></methods><methods><class-id>Core.WrappingStream</class-id> <category>nonhomogeneous positioning</category><body package="StreamWrapping">padTo: bsize	^stream padTo: bsize</body><body package="StreamWrapping">padTo: bsize put: aCharacter	^stream padTo: bsize put: aCharacter</body></methods><methods><class-id>Core.WrappingStream class</class-id> <category>instance creation</category><body package="StreamWrapping">on: aStream	self subclassResponsibility</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>accessing</category><body package="StreamWrapping">encodedContents	"Answer with a copy of the receiver's information in	encoded form--i.e., in bytes."	^stream encodedContents</body></methods><methods><class-id>Core.EncodedStream class</class-id> <category>instance creation</category><body package="StreamWrapping">on: aStream	"use (collection withEncoding: anEncoding) readStream to construct an encoded stream"	self shouldNotImplement</body></methods><methods><class-id>Core.InternalEncodedStreamConstructor</class-id> <category>private</category><body package="StreamWrapping">addEncodingTo: aStream	^encoding == #binary		ifTrue: [aStream]		ifFalse: 			["overridden to ask the encoder for the encoded stream."			(self findEncoding: encoding) initializeForMemory				createEncodedStreamOn: aStream]</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="StreamWrapping">encodedContents	"Answer with a copy of the receiver's information in	encoded form--i.e., in bytes."	^self contents</body></methods><methods><class-id>Core.EncodedStreamConstructor</class-id> <category>private</category><body package="StreamWrapping">addEncodingTo: aStream	^encoding == #binary		ifTrue: [aStream binary]		ifFalse:			[| encoder |			encoder := self findEncoding: encoding.			encoder initializeForFiles.			"overridden to ask the encoder for the encoded stream. 			Set the stream to binary because file streams need to know that explicitly"			aStream binary.			encoder createEncodedStreamOn: aStream]</body></methods><methods><class-id>Core.StreamEncoder</class-id> <category>accessing</category><body package="StreamWrapping">createEncodedStreamOn: aStream		^EncodedStream on: aStream encodedBy: self</body><body package="StreamWrapping">streamEncodingType	^self class streamEncodingType</body></methods><methods><class-id>Core.ByteStreamEncoder</class-id> <category>accessing</category><body package="StreamWrapping">createEncodedStreamOn: aStream	^(self encoder definitionClass notNil and:[aStream isExternalStream])		ifTrue: [aStream textOfClass: self encoder definitionClass]		ifFalse: 			[super createEncodedStreamOn: aStream]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>EncodedStreamConstructor</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataRepository encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>PeekableStream</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>InternalEncodedStreamConstructor</name><environment>Core</environment><super>Core.EncodedStreamConstructor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ByteStreamEncoder</name><environment>Core</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>