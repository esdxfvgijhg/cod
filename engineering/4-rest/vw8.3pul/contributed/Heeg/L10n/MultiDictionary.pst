<?xml version="1.0"?><st-source><!-- Name: MultiDictionaryComment: conains MultiDictionary and DiscriminatedMultiDictionaryDbIdentifier: magdi.heeg.de.postgresDbTrace: 48487DbUsername: joergDbVersion: 7.10.1 - 1.0PackageName: MultiDictionaryParcel: #('MultiDictionary')ParcelDirectory: c:\visworks\vw8.0 sep14.2\image\HeegContributions-vw8.0-2014-09-25-2\L10n\MultiDictionaryParcelName: MultiDictionaryPrintStringCache: (7.10.1 - 1.0,joerg)Version: 7.10.1 - 1.0Datum:3:33:43 PM September 25, 2014 --><time-stamp>Von VisualWorksÂ®, 8.0 von 15. September 2014 am 25. September 2014 um 15:33:43</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>KeyDictionary</name><environment>Core</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars>keys </class-inst-vars><imports></imports><category>MultiDictionary</category><attributes><package>MultiDictionary</package></attributes></class><class><name>MultiDictionary</name><environment>Core</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MultiDictionary</category><attributes><package>MultiDictionary</package></attributes></class><comment><class-id>Core.MultiDictionary</class-id><body>MultiDictionary is like a Dictionary with a Dictionary as key.	the diffrence is, if you query the MD with an incomplete Dictionary (not all keys present) then you get an OrderedCollection with all the (Dictionary-&gt;Value) associations		!!!!! WARNING !!!!! 	if you change the values of a dictionary you get from a query then you change it in the MD as well. THIS MAY DAMAGE YOUR DATA!!!!	!!!!! WARNING !!!!!	to query use #at: and you get an OrderedCollection with Associations (Dictionary-&gt;Object)	to query the values use #valuesAt: and you get an OrderedCollection with Objects.	to overwrite many values with one new value use #atAll:put: 	to remove one or more associations use #remove: with an (in)complete Dictionary.	to query for the exact value, and not all that values that match, use #exactAt:ifAbsent:.	to exactly remove one value use removeExactAt:ifAbsent:.Instance Variables:	collection	&lt;(Set of: (Association{Dictionary-&gt;Object}))&gt;	stores all the Data of the MultiDictionary.</body></comment><class><name>DiscriminatedMultiDictionary</name><environment>Core</environment><super>Core.MultiDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discriminator indices </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MultiDictionary</category><attributes><package>MultiDictionary</package></attributes></class><comment><class-id>Core.DiscriminatedMultiDictionary</class-id><body>The DiscriminatedMultiDictionary is a subclass of MultiDictionary that signes one of the key-dictionaries keys as discriminator and stores in an (identity)Dictionary where associations are that include one special key. this makes searching realy fast.Instance Variables:	collection		&lt;(Set of: (Association{Dictionary-&gt;Object}))&gt;					stores all the Data of the MultiDictionary.	discriminator	&lt;anObject&gt;													the key that is used as discriminator	indices			&lt;(Identity)Dictionary{object-&gt;OrderedCollection of integer}		Dictionary that stores all the indices that include the discriminators value in their																				key-dictionary</body></comment><methods><class-id>Core.KeyDictionary</class-id> <category>testing</category><body package="MultiDictionary">isDictionary	^true</body></methods><methods><class-id>Core.KeyDictionary</class-id> <category>accessing</category><body package="MultiDictionary">at: key ifAbsent: aBlock 	| index |	index := self class keys at: key ifAbsent: [^aBlock value].	index &gt; self basicSize ifTrue: [^aBlock value].	^(self basicAt: index) ifNil: [aBlock value]</body><body package="MultiDictionary">at: key put: aValue 	| index |	index := self class keys at: key ifAbsentPut: [self class keys size + 1].	index &gt; self basicSize 		ifTrue: 			[| new |			new := self class new.			1 to: self basicSize do: [:i | new basicAt: i put: (self basicAt: i)].			self become: new].	self basicAt: index put: aValue.	^aValue</body></methods><methods><class-id>Core.KeyDictionary</class-id> <category>removing</category><body package="MultiDictionary">remove: anObject ifAbsent: exceptionBlock 	"Provide an error notification that Dictionaries can not respond to	remove: messages."	self shouldNotImplement</body><body package="MultiDictionary">removeKey: key ifAbsent: aBlock 	"Remove key from the receiver.  If key is not in the receiver, 	answer the result of evaluating aBlock.  Otherwise, answer the value 	associated with key."	| value |	value := self at: key ifAbsent: [^aBlock value].	self at: key put: nil.	^value</body></methods><methods><class-id>Core.KeyDictionary</class-id> <category>initialize-release</category><body package="MultiDictionary">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Core.KeyDictionary</class-id> <category>adding</category><body package="MultiDictionary">add: anAssociation 	"Include anAssociation as one of the receiver's elements. Answer 	anAssociation."	| key |	key := anAssociation key.	key ifNil: 			[^self 				subscriptBoundsErrorFor: #add:				index: key				value: anAssociation].	self at: key put: anAssociation value.	^anAssociation</body></methods><methods><class-id>Core.KeyDictionary</class-id> <category>converting</category><body package="MultiDictionary">asKeyDictionary	^self</body></methods><methods><class-id>Core.KeyDictionary</class-id> <category>enumerating</category><body package="MultiDictionary">keysAndValuesDo: aBlock 	self class keys keysAndValuesDo: 			[:k :i | 			i &lt;= self basicSize 				ifTrue: [(self basicAt: i) ifNotNil: [:v | aBlock value: k value: v]]]</body></methods><methods><class-id>Core.KeyDictionary class</class-id> <category>instance creation</category><body package="MultiDictionary">new	"Answer a newly created and initialized instance."	^self basicNew: self keys size</body><body package="MultiDictionary">new: aNumber	"Answer a newly created and initialized instance."	^self basicNew: aNumber</body></methods><methods><class-id>Core.KeyDictionary class</class-id> <category>accessing</category><body package="MultiDictionary">keys	keys ifNil: [keys := Dictionary new].	^keys</body></methods><methods><class-id>Core.MultiDictionary</class-id> <category>accessing</category><body package="MultiDictionary">add: anAssociation 	"adds an association to the MD"	self at: anAssociation key put: anAssociation value.	^anAssociation</body><body package="MultiDictionary">at: aDict 	"queries the MultiDictionary for aDict. if aDict is not complete then all matching vales are returned.	returns a Collection of associations."	"first is for inspector"	(aDict isKindOf: Association) ifTrue: [^(self valuesAt: aDict key) first].	"now is for the real work"	^self at: aDict ifAbsent: [self keyNotFoundErrorFor: #at: index: aDict]</body><body package="MultiDictionary">at: aDict fastPut: anObject 	"this method just puts anObject at aDict, without checking if there's allready a value associated to aDict."	collection add: (Association key: aDict asKeyDictionary value: anObject).	^anObject</body><body package="MultiDictionary">at: aDict ifAbsent: aBlock 	"takes the collection and selects everything that matches aDict"	| coll |	coll := collection 				select: [:association | self lookUp: aDict for: association].	coll isEmpty ifTrue: [^aBlock value] ifFalse: [^coll]</body><body package="MultiDictionary">at: aDict ifAbsent: aBlock into: aCollection 	"takes the collection and selects everything that matches aDict"	collection do: 			[:association | 			(self lookUp: aDict for: association) 				ifTrue: [aCollection add: association]].	aCollection isEmpty ifTrue: [^aBlock value] ifFalse: [^aCollection]</body><body package="MultiDictionary">at: aDict put: anObject 	"first remove the Object that was at aDict and then put the new. 	(this way anObject overwrites an older object at aDict, if one was there.)"	| oldIndex |	oldIndex := self primExactIndexOf: aDict.	oldIndex = 0 		ifTrue: [collection add: (Association key: aDict asKeyDictionary value: anObject)]		ifFalse: 			[collection at: oldIndex put: (Association key: aDict asKeyDictionary value: anObject)].	^anObject</body><body package="MultiDictionary">atAll: aDict put: anObject 	"overwrite all the values that fit to aDict with anObject"	| coll |	coll := self at: aDict				ifAbsent: [self keyNotFoundErrorFor: #at: index: aDict].	coll do: [:association | self at: association key put: anObject].	^anObject.</body><body package="MultiDictionary">collection	^collection.</body><body package="MultiDictionary">collection:anObject	collection:=anObject.</body><body package="MultiDictionary">exactAt: aDict ifAbsent: aBlock 	"selects the association that fits exactly to aDict.(in size and keys)"	^collection select: [:association | self exactLookUp: aDict for: association]</body><body package="MultiDictionary">keys	"returns all associations (for inspector)"	^collection asOrderedCollection</body><body package="MultiDictionary">primExactIndexOf: aDict	"selects the association that fits exactly to aDict.(in size and keys)"	1 to: collection size		do: [:i | (self exactLookUp: aDict for: (collection at: i)) ifTrue: [^i]].	^0</body><body package="MultiDictionary">valuesAt: aDict 	"Answer only the values, not the associations as an OrderedCollection at aDict.  If key is not found, raise a signal."	| coll |	coll := OrderedCollection new.	(self at: aDict ifAbsent: [OrderedCollection new]) 		do: [:each | coll add: each value].	^coll</body></methods><methods><class-id>Core.MultiDictionary</class-id> <category>enumerating</category><body package="MultiDictionary">collect: aBlock 	"Evaluate aBlock with each of the values of the receiver as the  	argument.  Collect the resulting values into a collection.	 Answer the new collection."	| newCollection |	newCollection := OrderedCollection new: self size.	self do: [:each | newCollection add: (aBlock value: each)].	^newCollection</body><body package="MultiDictionary">do: aBlock 	"evaluates aBlock with each association in collection."	collection do: [:each | aBlock value: each]</body><body package="MultiDictionary">keysAndValuesDo:aBlock	"evaluates aBlock with keys and values of each association in collection."	collection do:[:each|		aBlock value:each key value:each value.]</body><body package="MultiDictionary">select: aBlock 	"Evaluate aBlock with each of the values of the receiver as the 	argument.  Collect into a new MultiDictionary, only those associations 	for which aBlock evaluates to true. "	| newCollection |	newCollection := self species new.	self keysAndValuesDo: [:key :value | 		(aBlock value: value)			ifTrue: [newCollection at: key put: value]].	^newCollection</body></methods><methods><class-id>Core.MultiDictionary</class-id> <category>removing</category><body package="MultiDictionary">remove: aDict 	"removes everything that fits aDict"	^self remove: aDict ifAbsent: [self keyNotFoundErrorFor: #at: index: aDict]</body><body package="MultiDictionary">remove: aDict ifAbsent: aBlock 	"first finds everything that fits to aDict and then removes them one by one."	| res i removes object |	removes := self at: aDict ifAbsent: [nil].	removes ifNil: [^aBlock value].	"create an empty collection with the size of the found objects"	res := OrderedCollection new: removes size.	i := 1.	[i &lt;= collection size and: [removes isEmpty not]] whileTrue: 			["while the index is still inside the collection and removes is not empty"			object := collection at: i.			(removes includes: object) 				ifTrue: 					["if removes includes the object then remove it from collection AND from removes"					collection at: i put: collection last.					collection removeLast.					removes remove: object.					"then add it to res"					res add: object					"i is not incremented here, as the last object is moved to the current position, so this position has to be checked again."]				ifFalse: 					["if the object at i isn't included in removes, look for the next"					i := i + 1]].	^res</body><body package="MultiDictionary">removeExactAt:aDict ifAbsent:aBlock 	"first finds everything that fits exactly to aDict and then removes them one by one."	|res|	res:=self exactAt:aDict ifAbsent:aBlock.	res do:[:each| collection remove:each].	^res.</body></methods><methods><class-id>Core.MultiDictionary</class-id> <category>private</category><body package="MultiDictionary">exactLookUp: aDict for: anAssociation 	"compares aDict and anAssociation. 	if anAssociation doesn't completely match aDict then it returns false."	| key |	key := anAssociation key.	aDict size ~= key size ifTrue: [^false].	aDict keysAndValuesDo: 			[:k :v | 			"can't be inlined, as the implementation of #keysAndValuesDo is diffrent 			in IdentityDictionary and Dictionary"			v = (key at: k ifAbsent: [^false]) ifFalse: [^false]].	^true</body><body package="MultiDictionary">lookUp: aDict for: anAssociation 	"compares aDict and the key-dictionary of anAssociation. 	if aDict misses some keys that anAssociation has, then true is also returned. "	| key |	key := anAssociation key.	aDict keysAndValuesDo: 			[:k :v | 			v isBlock 				ifTrue: [(v value: (key at: k ifAbsent:[nil])) ifFalse: [^false]]				ifFalse: [v = (key at: k ifAbsent: [v]) ifFalse: [^false]]].	^true</body></methods><methods><class-id>Core.MultiDictionary</class-id> <category>initialize-release</category><body package="MultiDictionary">initialize	collection := OrderedCollection new</body></methods><methods><class-id>Core.MultiDictionary</class-id> <category>copying</category><body package="MultiDictionary">copy	"makes a copy of itself and returns it"	|newAMD|	newAMD:=MultiDictionary with:collection copy.	^newAMD.</body></methods><methods><class-id>Core.MultiDictionary</class-id> <category>printing</category><body package="MultiDictionary">printOn: aStream 	"prints itself on aStream"	aStream nextPutAll: 'an MultiDictionary('.	collection printOn: aStream.	aStream nextPutAll: ')'</body></methods><methods><class-id>Core.MultiDictionary class</class-id> <category>initialize-release</category><body package="MultiDictionary">new	^super new initialize</body><body package="MultiDictionary">with: anAssociation 	| newMD |	newMD := self new.	newMD addAll: anAssociation.	^newMD</body><body package="MultiDictionary">withAll: aCollection 	| newMD |	newMD := self new.	newMD collection: aCollection.	^newMD</body></methods><methods><class-id>Core.DiscriminatedMultiDictionary</class-id> <category>As yet unclassified</category><body package="MultiDictionary">at: aDict ifAbsent: aBlock into: aCollection 	"like at:ifAbsent:, but stores the results in aCollection"	| discriminatorValue result myIndices |	discriminatorValue := aDict at: discriminator				ifAbsent: 					[^super 						at: aDict						ifAbsent: aBlock						into: aCollection].	result := aCollection.	discriminatorValue isBlock 		ifTrue: 			[myIndices := OrderedCollection new.			indices 				keysAndValuesDo: [:k :v | (discriminatorValue value: k) ifTrue: [myIndices addAll: v]]]		ifFalse: 			[myIndices := indices at: discriminatorValue ifAbsent: [^aBlock value]].	myIndices do: 			[:index | 			(self lookUp: aDict for: (collection at: index)) 				ifTrue: [result add: (collection at: index)]].	result isEmpty ifTrue: [^aBlock value] ifFalse: [^result]</body></methods><methods><class-id>Core.DiscriminatedMultiDictionary</class-id> <category>copying</category><body package="MultiDictionary">copy	"makes a copy of itself and returns it"	| newAMD |	newAMD := self class 				withAll: collection copy				discriminator: discriminator				identity: (indices isKindOf: IdentityDictionary).	^newAMD</body></methods><methods><class-id>Core.DiscriminatedMultiDictionary</class-id> <category>accessing</category><body package="MultiDictionary">at: aDict ifAbsent: aBlock 	"If an entry does allready exist at aDict then replace its value. If not then add the entry to the collection and add the index of it to the 	indices-Dictionary at the discriminators value."	| discriminatorValue result myIndices |	discriminatorValue := aDict at: discriminator				ifAbsent: [^super at: aDict ifAbsent: aBlock].	result := OrderedCollection new.	discriminatorValue isBlock 		ifTrue: 			[myIndices := OrderedCollection new.			indices 				keysAndValuesDo: [:k :v | (discriminatorValue value: k) ifTrue: [myIndices addAll: v]]]		ifFalse: 			[myIndices := indices at: discriminatorValue ifAbsent: [^aBlock value]].	myIndices do: 			[:index | 			(self lookUp: aDict for: (collection at: index)) 				ifTrue: [result add: (collection at: index)]].	result isEmpty ifTrue: [^aBlock value] ifFalse: [^result]</body><body package="MultiDictionary">at: aDict put: anObject 	"If aDict does not include the discriminator then call the #at:ifAbsent: method of MultiDictionary. If there is a Discriminator then 	lookup the indices of the entries and continue the search of the resulting entries. "	| discriminatorValue indexCollection |	discriminator isNil ifTrue: [self guessDiscriminator].	discriminatorValue := aDict at: discriminator				ifAbsent: [^super at: aDict put: anObject].	"replace existing Values"	indexCollection := indices at: discriminatorValue				ifAbsentPut: [OrderedCollection new].	indexCollection do: 			[:index | 			(self exactLookUp: aDict for: (collection at: index)) 				ifTrue: 					[collection at: index put: (Association key: aDict asKeyDictionary value: anObject).					^anObject]].	"if no values exist yet add it to the collection"	collection add: (Association key: aDict value: anObject).	indexCollection add: collection size.	^anObject</body><body package="MultiDictionary">remove: aDict ifAbsent: aBlock 	"If the discriminator is not included in aDict then call #remove:ifAbsent: from MultiDictionary. If it is included then load the indices 	of the entries that are stored at the discriminators value in the indices-Dictionary and search the resulting Dictionaries if aDict 	matches. Then last entry in collection is copied over the entry that should be removed and the indices are corrected. Returns a 	Collection of all the entrys that got removed."	| discriminatorValue res myIndices removedIndices |	discriminatorValue := aDict at: discriminator				ifAbsent: 					[res := super remove: aDict ifAbsent: aBlock.					self resort.					^res].	res := OrderedCollection new.	removedIndices := OrderedCollection new.	"get the indices where objects could be, that have to be removed"	discriminatorValue isBlock 		ifTrue: 			[myIndices := OrderedCollection new.			indices 				keysAndValuesDo: [:k :v | (discriminatorValue value: k) ifTrue: [myIndices addAll: v]]]		ifFalse: 			[myIndices := indices at: discriminatorValue ifAbsent: [^aBlock value]].	"find all objects to remove and save them in res to return them"	myIndices do: 			[:index | 			(self lookUp: aDict for: (collection at: index)) 				ifTrue: 					[res add: (collection at: index).					removedIndices add: index]].	"now remove the objects"	removedIndices do: 			[:index | 			"put the last Object from the collection in the place where the current object was"			collection at: index put: collection last.			"then correct the indices because there're"			self correctIndexForNewObjectAtIndex: index.			collection removeLast].	"remove indices that are out of bounds and if there're empty collections in indices, remove them"	indices keysAndValuesDo: 			[:eachKey :coll | 			| i |			i := 1.			[i &lt;= coll size] whileTrue: 					[(coll at: i) &gt; collection size 						ifTrue: [coll removeAtIndex: i]						ifFalse: [i := i + 1]].			coll isEmpty ifTrue: [indices removeKey: eachKey]].	^res</body></methods><methods><class-id>Core.DiscriminatedMultiDictionary</class-id> <category>private</category><body package="MultiDictionary">correctIndexForNewObjectAtIndex: index 	"corrects the entry in the indices-dictionary for the object at the last index in collection that got moved to index"	"search discriminator of last object"	| lastDiscriminatorValue |	lastDiscriminatorValue := collection last key at: discriminator				ifAbsent: [nil].	"if there is no discriminator then no need to correct the index"	lastDiscriminatorValue ifNotNil: 			["replace it with the current index"			| lastDiscriminatorValueIndexCollection |			lastDiscriminatorValueIndexCollection := indices 						at: lastDiscriminatorValue.			(lastDiscriminatorValueIndexCollection includes: index) 				ifFalse: 					["take care of same index twice in the collection"					lastDiscriminatorValueIndexCollection add: index].			"remove the last index"			lastDiscriminatorValueIndexCollection remove: collection size				ifAbsent: [nil].			]</body><body package="MultiDictionary">guessDiscriminator	"searches every key for how many diffrent values there are for that key. the key with the most diffrent values is the discriminator.	starts searching only if there're at least 50 entries in collection"	| counter maxVal max |	self size &lt; 50 ifTrue: [^self].	counter := IdentityDictionary new.	self collection do: 			[:entry | 			entry key 				keysAndValuesDo: [:k :v | (counter at: k ifAbsentPut: [Set new]) add: v]].	maxVal := 0.	counter keysAndValuesDo: 			[:k :v | 			v size &gt; maxVal 				ifTrue: 					[maxVal := v size.					max := k]].	discriminator := max.	self resort</body><body package="MultiDictionary">resort	"sorts the indices of each entry in collection into the right place in the indices-dictionary"	| discriminatorValue |	indices := indices class new: indices size.	1 to: collection size		do: 			[:i | 			discriminatorValue := (collection basicAt: i) key at: discriminator						ifAbsent: [nil].			discriminatorValue ifNotNil: 					[(indices at: discriminatorValue ifAbsentPut: [OrderedCollection new]) 						add: i]]</body></methods><methods><class-id>Core.DiscriminatedMultiDictionary</class-id> <category>initialize-release</category><body package="MultiDictionary">discriminator: aSymbol identity: isIdentical 	discriminator := aSymbol.	indices := (isIdentical ifTrue: [IdentityDictionary] ifFalse: [Dictionary]) 				new</body><body package="MultiDictionary">initialize	super initialize.	indices := Dictionary new.</body></methods><methods><class-id>Core.DiscriminatedMultiDictionary class</class-id> <category>instance creation</category><body package="MultiDictionary">discriminator: aSymbol identity: isIdentical 	"Makes a new DiscriminatedMultiDictionary and sets the discriminator to aSymbol and makes the 	indices-Dictionary an IdentityDictionary if isIdentical is true or a Dictionary if it is false."	^super new discriminator: aSymbol identity: isIdentical</body><body package="MultiDictionary">withAll: aCollection 	"Makes a new DiscriminatedMultiDictionary and sets the discriminator to the key with the most diffrent	values. The indices-Dictionary will be a Dictionary."	| newMD |	newMD := super withAll: aCollection.	newMD guessDiscriminator.	^newMD</body><body package="MultiDictionary">withAll: aCollection discriminator: anObject identity: aBoolean 	"Makes a new DiscriminatedMultiDictionary and sets the discriminator to anObject. The indices-Dictionary will 	be an IdentityDictionary or a Dictionary depending on aBool"	| newMD |	newMD := super withAll: aCollection.	newMD discriminator: anObject identity: aBoolean.	newMD resort.	^newMD</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>testing</category><body package="MultiDictionary">isBlock	^true</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="MultiDictionary">isBlock	^false</body><body package="MultiDictionary">isDictionary	^false</body></methods><methods><class-id>Core.Dictionary</class-id> <category>converting</category><body package="MultiDictionary">asKeyDictionary	| new |	new := KeyDictionary new.	self keysAndValuesDo: [:k :v | new at: k put: v].	^new</body></methods><methods><class-id>Core.Dictionary</class-id> <category>testing</category><body package="MultiDictionary">isDictionary	 ^true</body></methods><methods><class-id>Core.KeyedCollection</class-id> <category>converting</category><body package="MultiDictionary">asKeyDictionary	| new |	new := KeyDictionary new.	self keysAndValuesDo: [:k :v | new at: k put: v].	^new</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>KeyedCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class></st-source>