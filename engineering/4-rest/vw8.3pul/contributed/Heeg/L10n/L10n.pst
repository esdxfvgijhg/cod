<?xml version="1.0"?><st-source><!-- Name: L10nNotice: © Copyright 2004-2016 Georg Heeg e.K.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.(MIT License)BundleName: L10nBundleStructure: a Store.BundleForParcelComment: L10n is a tool for translating the UserMessagesA decription is provided in PDF in $(VISUALWORKS)\contributed\Heeg\L10nDevelopmentPrerequisites: #(#(#any 'UIPainter' '') #(#any 'MultiDictionary' '') #(#any 'FormatedSetting' '') #(#any 'GHCsvImportExport' '') #(#any 'RefactoringBrowserInSubcanvas' '') #(#any 'Internationalizer' '') #(#any 'PerProcessCatalogs' '') #(#any 'ByteOrderMarkSupport' '') #(#any 'I18nRuntime' '') #(#any 'DataSetAutoresize' ''))DialectVersion: VisualWorks 7.9Parcel: nilParcelName: L10nPrerequisiteDescriptions: #(#(#name 'UIPainter') #(#name 'MultiDictionary') #(#name 'FormatedSetting') #(#name 'GHCsvImportExport') #(#name 'RefactoringBrowserInSubcanvas' #componentType #package) #(#name 'Internationalizer' #componentType #bundle) #(#name 'PerProcessCatalogs' #componentType #package) #(#name 'ByteOrderMarkSupport' #componentType #package) #(#name 'I18nRuntime' #componentType #package) #(#name 'DataSetAutoresize' #componentType #package))PrerequisiteParcels: #(#('UIPainter' '') #('MultiDictionary' '') #('FormatedSetting' '') #('GHCsvImportExport' '') #('RefactoringBrowserInSubcanvas' '') #('Internationalizer' '') #('PerProcessCatalogs' '') #('ByteOrderMarkSupport' '') #('I18nRuntime' '') #('DataSetAutoresize' ''))Version: 8.1.1 - 18Date: 1:41:42 PM June 13, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.2) of 9. Juni 2017 on 13. Juni 2017 at 13:41:42</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>L10n</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>L10n</category><attributes><package>L10n-Base</package></attributes></name-space><class><name>TextEditorView</name><environment>UI</environment><super>UI.ComposedTextView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state helpText isFromL10n </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>L10n-System-Modifications</package></attributes></class><comment><class-id>UI.TextEditorView</class-id><body>TextEditorView may be configured either as an input box (with an InputBoxController) or as something that allows for more extensive input (with a TextEditorController)Instance Variables:	state	&lt;WidgetState&gt;  A bit vector containing the appearance properties of the widget.  See WidgetState	helpText	&lt;String | Text | nil&gt; A short explanation of the control for the context help system.Object Reference:A TextEditorView is a ComposedTextView that is equipped to fit into a painted interface. It is available on the Palette as a Text Editor. Its model is a value model containing a string or Text or ComposedText. Its default controller is a TextEditorController. Most of its methods are intended to be sent by its controller. While an application typically does not need to access a TextEditorView directly, it can be accessed by: getting the UIBuilder from the application model (via #builder), getting the named component's wrapper from the builder (via #componentAt:) and then getting the TextEditorView from the wrapper (via #widget). TextEditorView has one subclass, InputFieldView, which is designed for a single line of text and is available on the Palette as in Input Field.  </body></comment><class><name>SystemChecker</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base</package></attributes></class><comment><class-id>L10n.SystemChecker</class-id><body>CSVParcelLoaderist has only class-methods, as it is only for testing and loading of the CSV package, which is optional. it can test if it is installed and it can load the package</body></comment><class><name>TerminologyEntry</name><environment>L10n</environment><super>Heeg.CsvLine</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.TerminologyEntry</class-id><body>TerminologyEntry is used to represent one term. this representation is done by capsulating a dictionary. and forwarding methods as at:put: to the dictionary if these methods are valid keys in the dictionary.Instance Variables:	data	&lt;Dictionary&gt;	contains the data of this term</body></comment><class><name>L10nCatalog</name><environment>L10n</environment><super>Kernel.MessageCatalog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>language catalogID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-MessageCatalogs</package></attributes></class><comment><class-id>L10n.L10nCatalog</class-id><body>L10nCatalog is an abstract class that represents a MessageCatalog that takes its translations from somewhere in L10n. Subclasses need to implement the following methods:	accessing		lookUp: 			&lt;- have the translation provider lookup the user message for the catalogs language and catalogID.Class side subclass responsibilities:	private		translationProvider 	&lt;- returns the object that provides the translations. This object is sent the message #allCatalogsLanguagesAndCountriesDo: that takes a block with 3 arguments.						the block is expected to be called for each combination of catalog, language and country. If the country is unspecified it is expected that #none is passed.Instance Variables	catalogID	&lt;Symbol&gt;				language	&lt;Symbol&gt;			the language of the translations provided by this catalog</body></comment><class><name>UserMethodListEntry</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.UserMethodListEntry</class-id><body>UserMethodListEntry displays a method.Instance Variables:	method	&lt;CompiledMethod&gt;	description of method</body></comment><class><name>TemporaryTranslationStore</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.TemporaryTranslationStore</class-id><body>TemporaryTranslationStore is a Class to save UserMessageTranslations until Write to DiskThe Construction is:IdentityDictionary {CatalogID -&gt; IdentityDictionary {UserMessageKey -&gt; Usermessage}}This Data is used for instant preview of accepted translations in the complete VisualWorks environment</body></comment><class><name>L10nNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserNavigatorInSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>l10n </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-BrowserUI</category><attributes><package>L10n-RBSupport</package></attributes></class><class><name>TranslationChecker</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>original translation catalogs keys sourceLanguage targetLanguage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-UI</package></attributes></class><comment><class-id>L10n.TranslationChecker</class-id><body>TranslationChecker eases the browsing through translations for a catalog. It shows the source and the translation side by side so it is easier to compare.Instance Variables	catalogs	&lt;SelectionInList&gt;			description of catalogs	keys		&lt;SelectionInList&gt;			description of keys	original		&lt;ValueHolder on: String&gt;	description of original	translation	&lt;ValueHolder on: String&gt;	description of translation</body></comment><class><name>L10nTBXObject</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>srcLang tarLang category key src tar version original translation synonym source notes valid id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-TMX</category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>L10nTBXObject</class-id><body>L10nTBXWriter is used to write a list of terms into a TBX file</body></comment><class><name>TermListUI</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userMessageList termlist model parent list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>L10n-UI</package></attributes></class><class><name>TermManagerUI</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchField comments source terms valid synonym original translation selectedUserMessage sourceList userMessageList filter orgDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>L10n-UI</package></attributes></class><comment><class-id>L10n.TermManagerUI</class-id><body>TermManagerUI is an ApplicationModel that allows a user to manage the terminology database. It provides a list of terms and shows the definition and usage of this term.Instance Variables:	comments		&lt;ValueModel&gt;		the comment of the selected term	filter			&lt;String&gt;			the filter-string by which the terms are filtered	orgDict		&lt;Dictionary&gt;		the dictionary that contains all the information of the current term as provided by the database	original		&lt;ValueModel&gt;		value model of the "original" input field	searchField	&lt;EntryModule&gt;		the searchField of the term-list	selectedUserMessage	&lt;ValueModel&gt;	the selected object of the DataSetView	source		&lt;ValueModel&gt;		value model of the "Source" combobox's input field	sourceList		&lt;ValueModel&gt;		value model of the choices of the "Source" combobox	synonym		&lt;ValueModel&gt;		value model of the "Synonym" input field	terms		&lt;SelectionInList&gt;	the list of terms	translation		&lt;ValueModel&gt;		value model of the "Translation" input field	userMessageList	&lt;SelectionInListSortAware&gt;	the list of the DataSetView	valid			&lt;ValueModel&gt;		value model of the "valid" checkbox</body></comment><class><name>Exporter</name><environment>L10n</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalog fileFormat date availableCatalogs dateHandling translations translator savePath errorText closeme tmCatalog tmCatalogChoice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Models</category><attributes><package>L10n-Models</package></attributes></class><comment><class-id>L10n.Exporter</class-id><body>Exporter is used for exporting catalogs, or unloading themInstance Variables:	availableCatalogs	&lt;Object&gt;	description of availableCatalogs	catalog	&lt;SequenceableCollection&gt;	description of catalog	closeme	&lt;Object&gt;	description of closeme	date	&lt;Date&gt;	description of date	dateHandling	&lt;Character | CharacterArray | GeneralBindingReference&gt;	description of dateHandling	errorText	&lt;String&gt;	description of errorText	fileFormat	&lt;Object&gt;	description of fileFormat	savePath	&lt;Collection&gt;	description of savePath	tmCatalog	&lt;String&gt;	description of tmCatalog	tmCatalogChoice	&lt;Object&gt;	description of tmCatalogChoice	translations	&lt;ByteSymbol&gt;	description of translations	translator	&lt;Object&gt;	description of translator</body></comment><class><name>L10nMessagesNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ListNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-BaseUI</category><attributes><package>L10n-RBSupport</package></attributes></class><class><name>LangSpecConverter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-TMX</category><attributes><package>L10n-TMX</package></attributes></class><class><name>DataSetAutoresizeWrapper</name><environment>L10n</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resizeSpec numVariants minWidth isChangingBounds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-UI</package></attributes></class><comment><class-id>L10n.DataSetAutoresizeWrapper</class-id><body>DataSetAutoresizeWrapper is a Wrapper that injects itself between the DataSetScrollWrapper and the DataSetView.It detects changes to the bounds, by implementing #bounds:. In that case it adjusts the width of certain columns if that is desired.As the resizeWrapper is injected between the DataSetScrollWrapper and the DataSetView, it has to mimic both implementations to a certain extent. The DataSetScrollWrapper asks the DataSetView for hScrollBounds and vScrollBounds. The ColumnResizeAgent assumes that the DataSetView's container is a DataSetScrollWrapper and that's why the methods #scrollBy:, #scrollOffset and #visibleExtent are implemented and passed on to the scroll wrapper.Usage	"in postBuildWith: call the following code"	DataSetAutoresizeWrapper autoResizeColumnsIn: aDataSetView usingSpec: #(200 0 0)	"the array at the end holds the fixed widths of the various columns. 	If the width is 0 it means auto-resize. The width is then spread equally among the columns that have a 0 width.	In the example the first column has a width of 200 and the remaining two columns spread equally"Instance Variables:	isChangingBounds	&lt;Boolean&gt;	if true, changes to the widthHolder of a column descriptor is ignored.								see #isChangingBoundsWhile: for more information.	minWidth			&lt;Integer&gt;		the sum of the widths of columns that have a fixed width. 								Used to compute the amount of space that can be used by the variable-sized columns.	numVariants		&lt;Integer&gt;		the number of columns that have a variable width. 	resizeSpec			&lt;Array&gt;		Array of numbers. Each number corresponds to the width of the column at that index.								A number with the value 0 means that the size is computed dynamically.</body></comment><class><name>ExportUI</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>BOSS TMX TBX FileFormat FileFormats SelectedCriteria AvailableCriteria catalogName Date DateHandling AvailableDateHandles criteriaList criteriaCount model AvailableCatalogs CatalogChoices Catalog translations translator savePath ShowPath ErrorText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-UI</category><attributes><package>L10n-UI</package></attributes></class><comment><class-id>L10n.ExportUI</class-id><body>UI for the Export Dialog</body></comment><class><name>UnloadCatalogsUI</name><environment>L10n</environment><super>L10n.ExportUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>TMCatalogChoices TMAvailableCatalogs TMCatalog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-UI</category><attributes><package>L10n-UI</package></attributes></class><class><name>XMLExporter</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream objects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>L10n.XMLExporter</class-id><body>XMLExporter is a generic class to write a list of objects to an xml fileSubclasses must implement the following messages:	exporting		headerString 			&lt;- the string that is printed at the beginning of the file		objectClass 			&lt;- a class that responds to #asXMLElement and #from:. It is created from some object in order to print it to xml.		footerString 				&lt;- the string that is printed at the end of the fileInstance Variables	objects	&lt;(Collection of: (objectClass))&gt;	collection of the objects that are written	stream	&lt;WriteStream&gt;					stream on which the xml file is written</body></comment><class><name>TMXWriter</name><environment>L10n</environment><super>L10n.XMLExporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>L10n.TMXWriter</class-id><body>TMXWriter is a class that enables writing of files in the TMX format.TMX meens Translation Memory eXchange and is specified by www.lisa.org</body></comment><class><name>LookUpDictionary</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataMD </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base</package></attributes></class><comment><class-id>L10n.LookUpDictionary</class-id><body>LookUpDictionary is used to get the URLs for online dictionariesInstance Variables:	dataMD	&lt;MultiDictionary&gt; 			this MultiDictionary stores the information of each dictionary in this form: (#from #to #name)-&gt;URL			each url should at least contain &lt;1s&gt; as placeholder for the term to be translated. &lt;2s&gt; is the placeholder for the source language and &lt;3s&gt; is the placeholder for the target language</body></comment><class><name>TerminologyController</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataMD excludeList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base</package></attributes></class><comment><class-id>L10n.TerminologyController</class-id><body>TerminologyController is used to store and manage the terms. terms are stored in the dataMD and words that are not wanted for being terms are stored in the excludeListInstance Variables:	dataMD	&lt;DiscriminatedMultiDictionary&gt;				a discriminatedMD with the following form: (#original #translation #synonym #notes #source #valid)-&gt;Dictionary new. the value of this association is not yet used, but can store additional informations. 			#original is the discriminator.	excludeList	&lt;Collection&gt;	a list of words</body></comment><class><name>UserMessageListEntry</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key defaultString translated </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.UserMessageListEntry</class-id><body>UserMessageListEntry has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	defaultString	&lt;Collection&gt;	defaultString	key	&lt;Symbol&gt; the key of this UserMessage	translated	&lt;Boolean&gt;	indicates wether it's allready translated or not</body></comment><class><name>UserMessageTranslationMatchCollection</name><environment>L10n</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>isOld latest matching </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.UserMessageTranslationMatchCollection</class-id><body>UserMessageTranslationMatchCollection is a collection of UserMessageTranslationMatches that are equal except for the catalog where they've been translated inInstance Variables:	isOld	&lt;Boolean&gt;	if true this translation has been translated again, so this one may not be correct	latest	&lt;SmallInteger&gt;	index of the latest translation inside myself	matching	&lt;ArithmeticValue&gt;	number it matches the searched translation</body></comment><class><name>TranslationMemoryCatalog</name><environment>L10n</environment><super>L10n.L10nCatalog</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-MessageCatalogs</package></attributes></class><comment><class-id>L10n.TranslationMemoryCatalog</class-id><body>TranslationMemoryCatalog is a catalog that performs the lookup with the help of the UserMessageTranslationMemory.</body></comment><class><name>UserMessageFullSpecifier</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>langSpecifier version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.UserMessageFullSpecifier</class-id><body>UserMessageFullSpecifierspecifies an UserMessage full in various versions.Instance Variables:	langSpecifier	&lt;UserMessageLangSpecifier&gt;	description of langSpecifier	version	&lt;UserMessageTranslationVersion&gt;	description of version</body></comment><class><name>L10nEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.SelectorEnvironmentInSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>l10n </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>L10n-RBSupport</package></attributes></class><class><name>TBXLangSet</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>language terms </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>TBXLangSet</class-id><body>TBXLangSet represents &lt;langSpec&gt; Elements in the TBX Files. It is used to read these elements and print their data in a human readable way.Instance Variables:	language	&lt;String&gt;							language of the langSet, like DE-DE	terms 	&lt;OrderedCollection of: TBXTermInformationGroup&gt; 	the Tigs of the langset</body></comment><class><name>AccessKeyFixer</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>labelPreview characterPosition label menu range model ValidKey userMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-UI</category><attributes><package>L10n-UI</package></attributes></class><class><name>L10nTMXSoxDriver</name><environment>Smalltalk</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element key srcLang tarLang segStarted </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-TMX</category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>L10nTMXSoxDriver</class-id><body>L10nTMXSoxDriver the sox driver for TMX files, it reads objects while parsing.</body></comment><class><name>CheckedTranslation</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key valid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-UI</package></attributes></class><comment><class-id>L10n.CheckedTranslation</class-id><body>CheckedTranslation is a translation that is shown by the Translation Checker. It is basically a translation that's valid or invalid.Instance Variables	key		&lt; L10n.ExtentedUserMessageListEntry&gt;	 the key	valid	&lt;Boolean&gt;	</body></comment><class><name>EditTermUI</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>translation original source isValid synonym sources comments model new term refresh lookUp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>L10n-UI</package></attributes></class><class><name>CanvasViewer</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model method codeTool </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>L10n-RBSupport</package></attributes></class><comment><class-id>L10n.CanvasViewer</class-id><body>CanvasViewer get a aMethodDefinition from its Model and show it in a SubCanvasInstance Variables:	method	&lt;aMethodDefinition&gt;	description of method	model	&lt;aModel&gt;	description of model</body></comment><class><name>CatalogImporter</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceDirectory sourceDirectoryString encoding language catalog contents target fileName version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n</category><attributes><package>L10n-UM-Collect</package></attributes></class><comment><class-id>L10n.CatalogImporter</class-id><body>CatalogImporter imports the .lbl and .idx files into the translation memory Instance Variables:	catalog	&lt;AbstractFileItem | AsciiField | CharacterArray | ClassDescriptor | ClassRecord | ComposedText | Filename | GeneralBindingReference | IntegerArray | LogicalFilename | MethodDescriptor | NameSpaceDescriptor | NodeTag | ObjectNameWrapper | PacketValue | ParcelRecord | URI | UserMessage&gt;	description of catalog	contents	&lt;Dictionary&gt;	description of contents		key		value		from *.lbl:			key = value			encoding	&lt;Object&gt;	description of encoding	language	&lt;SequenceableCollection&gt;	description of language	sourceDirectory	&lt;LogicalFilename&gt;	description of sourceDirectory	sourceDirectoryString	&lt;ExceptionSet | GenericException | SequenceableCollection | Signal&gt;	description of sourceDirectoryString	target	&lt;Object&gt;	description of target</body></comment><class><name>C_noneCatalogImporter</name><environment>L10n</environment><super>L10n.CatalogImporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-UM-Collect</category><attributes><package>L10n-UM-Collect</package></attributes></class><class><name>TBXTermInformationGroup</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>term transactGroups attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>TBXTermInformationGroup</class-id><body>TBXTermInformationGroup represents a term in a LangSetInstance Variables:	attributes	&lt;Dictionary key: String value: String&gt;		attributes described by &lt;descrip type="key"&gt;value&lt;/descrip&gt;	term		&lt;String&gt;				the term of the langSet. Currently only one is allowed per langSet	transactGroups	&lt;Collection of: TBXTransacGroup&gt;	used to print the modifiedBy and originator data</body></comment><class><name>TermManager</name><environment>L10n</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Models</category><attributes><package>L10n-Models</package></attributes></class><comment><class-id>L10n.TermManager</class-id><body>TermManager is used to do most of the managing of terms</body></comment><class><name>TBXWriter</name><environment>L10n</environment><super>L10n.XMLExporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>L10n.TBXWriter</class-id><body>TBXWriter is a subclass of TMX writer and implements the storage to a TBX file.TBX files are TermBase eXchange files specified by www.lisa.org</body></comment><class><name>UserMessageSpecifierVersion</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source timeStamp status </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.UserMessageSpecifierVersion</class-id><body>is a Version of a Translation becouse you can have mor then one with the sam UserMassageLangSpecifierInstance Variables:	date	&lt;Object&gt;	description of date	source	&lt;Symbol&gt;	can be #system for read from image, #catalog for read in from catalogfiles or #temp for actual translationwork</body></comment><class><name>L10nSettings</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>settings </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base</package></attributes></class><comment><class-id>L10n.L10nSettings</class-id><body>This class stores all the settings for L10n</body></comment><class><name>ExtentedUserMessageListEntry</name><environment>L10n</environment><super>L10n.UserMessageListEntry</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalog isFiltered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.ExtentedUserMessageListEntry</class-id><body>ExtentedUserMessageListEntry is an UserMessageListEntry which also knows in which catalog it its used and if it is filtered or notInstance Variables:	catalog	&lt;Symbol&gt;	the symbolname of the catalog	isFiltered	&lt;Boolean&gt;	marks the entry filtered or not. filtered entries are displays in a different way.</body></comment><class><name>TargetDefaultStringListEntry</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.TargetDefaultStringListEntry</class-id><body>TargetDefaultStringListEntry displays a translation in the translations list.Instance Variables:	string	&lt;CharacterArray&gt;	the translation	version	&lt;UserMessageSpecifierVersion&gt;	stores the translator, the status and the translationdate</body></comment><class><name>UserMessageLangSpecifier</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specifier language culture </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.UserMessageLangSpecifier</class-id><body>UserMessageLangSpecifier specify an UserMessageSpecifier for a language and a cultureInstance Variables:	culture	&lt;Symbol&gt;	description of specifier ISO 3166-1 and ISO 3166-1-alpha-2	language	&lt;Symbol&gt;	languagesymbol by use of ISO 639-1	specifier	&lt;Object&gt;	UserMessageSpecifier</body></comment><class><name>L10nNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ClassAndMethodTabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-System-Modifications</category><attributes><package>L10n-RBSupport</package></attributes></class><class><name>MenuViewer</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model method selection parent codeModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>L10n-RBSupport</package></attributes></class><class><name>XMLImporter</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TMX</category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>L10n.XMLImporter</class-id><body>the XML Importer simplifies the creation of objects out of xml streams. it starts reading from an xml file and sets the soxdriver. it also tells the parser not to validate the document.</body></comment><class><name>ExistingTranslationsUI</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model parent numberToShow matching existingTranslationsList list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-UI</category><attributes><package>L10n-UI</package></attributes></class><class><name>TemporaryTranslationCatalog</name><environment>L10n</environment><super>L10n.L10nCatalog</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-MessageCatalogs</package></attributes></class><class><name>SystemUserMessages</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n</category><attributes><package>L10n-UM-Collect</package></attributes></class><comment><class-id>L10n.SystemUserMessages</class-id><body>SysUMCollector is the Class for the Collector, witch collect the Usermessges from the System and stores them into the dataMDInstance Variables:	catalogToMessageDict	&lt;Dictionary&gt;	description of catalogToMessageDict	messageToMethodDict	&lt;Dictionary&gt;	description of messageToMethodDict</body></comment><class><name>L10nUI</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodForCurrentMessage translationStatusMenu targetLangSpec translationStatus selectionTab sourceLangSpec targetDefaultString termTab targetLangChoice yourTranslation preview messagesForSelectedMethod sourceLangChoice sourceDefaultString searchField filter catalogsSubUI termsSubUI existingTranslationsSubUI terminologySubUI methodForCurrentMessageList selectedUserMessage menuViewerSubUI canvasViewerSubUI uiForUserMessage rbComponentSubUI </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>L10n-UI</package></attributes></class><class><name>UserMessagesListUI</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userMessagesList systemCatalog systemCatalogs model systemCatalogsMenu systemCatalogsSelectionInList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>L10n-UI</package></attributes></class><class><name>L10nOverviewTool</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeTool textHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-RBSupport</package></attributes></class><class><name>TargetDefaultStringListEntries</name><environment>L10n</environment><super>Core.SortedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.TargetDefaultStringListEntries</class-id><body>TargetDefaultStringListEntries is a SortedCollection that is used to construct a list of TargetDefaultStringListEntry objects.</body></comment><class><name>UserMessageCatalog</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name absolute translated </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.UserMessageCatalog</class-id><body>UserMessageCatalog displays a catalog. this catalog knows how many usermessages it has and how many of them are translated.Instance Variables:	absolute	&lt;SmallInteger&gt;	number of usermessages in this catalog	name	&lt;Symbol&gt;	the name of the catalog	translated	&lt;ArithmeticValue&gt;	number of translated usermessages in this catalog</body></comment><class><name>UserMessageTranslationMemory</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataMD systemCatalogs translationMD settingsDictionary allCatalogs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base</package></attributes></class><comment><class-id>L10n.UserMessageTranslationMemory</class-id><body>UserMessageTranslationMemory has the UserMessages and their translations inside.Instance Variables	dataMD	&lt;Object&gt;	MultiDictionary with these keys in the keyDictionary: culture, country, language, version	dataOrdered &lt;OrderedCollection&gt; contains dataMD at:Dictionary new after the dataMD is created. 			created in #buildDictionaryStructure	systemCatalogs &lt;orderedCollection&gt; all catalogs	messageToMethodDictionary &lt;Dictionary&gt; message -&gt; Set of Methods   \    used to bind messages to methods and vise versa	methodToMessageDictionary &lt;Dictionary&gt; method -&gt; Set of Messages   /	   created on TM creation with #saveMethod:for:	catalogToMessageDictionary &lt;Dictionary&gt; catalog -&gt; Set of Messages created to speed up things in GUI 	created in #buildDictionaryStructure</body></comment><class><name>MenuForList</name><environment>L10n</environment><super>UI.Menu</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.MenuForList</class-id><body>MenuForList is a subclass of Menu but displays itself different. it is created from a collection of objects.the method isFromL10n returns true and thus the menuitems are drawn not in plain text, but as styled text</body></comment><class><name>UserMessageTranslation</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullSpecifier string approved </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.UserMessageTranslation</class-id><body>UserMessageTranslation is a translation for a single version of a UserMessageit contains the following data cascaded:Instance Variables:	fullSpecifier	&lt;UserMessageFullSpecifyer&gt;	description of fullSpecifier		langSpecifier &lt;UserMessageLangSpecifier&gt;			culture &lt;symbol&gt; 	(#DE)			language &lt;symbol&gt;	(#de)			specifier &lt;UserMessageSpecifier&gt;				application				catalog				key		version &lt;UserMessageSpecifierVersion&gt;			source &lt;symbol&gt; (#CatalogFile)			timeStamp &lt;date&gt;	string	&lt;String&gt;	fror UMs of the system the defailtstring or from catalogs the translated string</body></comment><class><name>L10nBrowserDefinitionTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserDefinitionTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-RBSupport</category><attributes><package>L10n-RBSupport</package></attributes></class><class><name>L10nCodeModel</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-RBSupport</category><attributes><package>L10n-RBSupport</package></attributes></class><class><name>L10nTMXObject</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>srcLang tarLang category key src tar version </inst-vars><class-inst-vars>coll </class-inst-vars><imports></imports><category>L10n-TMX</category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>L10nTMXObject</class-id><body>L10nTMXWriter writes a traslationmemory into a TMX file</body></comment><class><name>CatalogExport</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetLanguage exportSourceLanguage exportDirectory sourceLanguage catalogs exportTargetLanguage localizer source target </inst-vars><class-inst-vars>lastDirectory </class-inst-vars><imports></imports><category></category><attributes><package>L10n-UI</package></attributes></class><class><name>MessageFileParserForL10n</name><environment>L10n</environment><super>Kernel.MessageFileParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-UM-Collect</package></attributes></class><class><name>EditExcludeListUI</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>excludelist </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-UI</category><attributes><package>L10n-UI</package></attributes></class><class><name>UserMessageTranslationMatch</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>match source target text catalog key version translated </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.UserMessageTranslationMatch</class-id><body>UserMessageTranslationMatch is an entry in the existing translations list. it contains the percent maching, the catalog, the key and the source and target language of the usermessage it conains in text. text is a bold or italic text depending on if the letter fits into the original word or not.Instance Variables:	catalog	&lt;String&gt;		description of catalog	key		&lt;Symbol&gt;		description of key	match	&lt;SmallInteger&gt;	description of match	source	&lt;String&gt;		description of source	target	&lt;String&gt;		description of target	text		&lt;Test&gt;			description of text</body></comment><class><name>UserMessageSpecifier</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>application catalog key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.UserMessageSpecifier</class-id><body>UserMessageSpecifier specify a UserMessage Instance Variables:	application	&lt;Symbol&gt;	the application uses this UM	catalog	&lt;Symbol&gt;	the catalogID of the UM	key	&lt;Symbol&gt;	the key in the catalog</body></comment><class><name>LookUpHelper</name><environment>L10n</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>ie </class-inst-vars><imports></imports><category>L10n-Base</category><attributes><package>L10n-Base</package></attributes></class><comment><class-id>L10n.LookUpHelper</class-id><body>This class only has class methods, as it only provides functionality to open a new window of internet explorer with a given url to lookup a term</body></comment><class><name>TempCatalogStorage</name><environment>L10n</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Base-Data</category><attributes><package>L10n-Base-Data</package></attributes></class><comment><class-id>L10n.TempCatalogStorage</class-id><body>TempCatalogStorage used to store the data that is written to the catalogfiles</body></comment><class><name>Localisator</name><environment>L10n</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastTerm lastObjects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-Models</category><attributes><package>L10n-Models</package></attributes></class><comment><class-id>L10n.Localisator</class-id><body>Localisator is used for managing and querying the translations</body></comment><class><name>L10nBrowser</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoringBrowserInSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-RBSupport</category><attributes><package>L10n-RBSupport</package></attributes></class><class><name>TerminologyUI</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>terminologyTable termMenuAspect termMenu selectedRow selectedRowNumber parent lastSortingSymbol compareSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-UI</category><attributes><package>L10n-UI</package></attributes></class><comment><class-id>L10n.TerminologyUI</class-id><body>TerminologyUI is an ApplicationModel that's embedded in the L10nUI app. It's responsible for the Terminology Tab in the lower-right corner.Instance Variables:	compareSymbol		&lt;Symbol&gt;		either #&lt; or #&gt;, depending on the sort direction of the table.	lastSortingSymbol	&lt;Symbol&gt;		the aspect by which the table was last sorted	parent			&lt;L10nUI&gt;		the hosting application	selectedRow		&lt;ValueModel&gt;	the selected object in the table	selectedRowNumber	&lt;ValueModel&gt;	the index of the selection	terminologyTable	&lt;SelectionInList&gt;	the model of the DataSetView	termMenu			&lt;ValueHolder&gt;	the menu of the combobox that shows the available terms of the current UserMessage	termMenuAspect		&lt;ValueModel&gt;	the selected term of the current UserMessage</body></comment><class><name>AccessKeyChecker</name><environment>L10n</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>selection </class-inst-vars><imports></imports><category>L10n-Models</category><attributes><package>L10n-Models</package></attributes></class><comment><class-id>L10n.AccessKeyChecker</class-id><body>AccessKeyChecker only got class methods to check a menuitem in many methods. it only checks for the accesskey to not be duplicated</body></comment><class><name>L10nTBXSoxDriver</name><environment>Smalltalk</environment><super>L10nTMXSoxDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrib lang stack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>L10n-TMX</category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>L10nTBXSoxDriver</class-id><body>L10nTBXSoxDriver is the sox driver used for reading TBX files. the objects are saved on the fly while parsing the file, this saves a lot of time and memory, but is probably not the best wayInstance Variables:	attrib	&lt;String&gt;	name of the first attribute of last &lt;descrip&gt; element. Used as key in &lt;element&gt;	stack &lt;OrderedCollection on: XML.Element&gt; the XML.Element objects parsed.	lang 	&lt;String&gt; 	language of the current langSet element.</body></comment><class><name>TBXTransactGroup</name><environment>Smalltalk</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user timestamp transaction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>L10n-TMX</package></attributes></class><comment><class-id>TBXTransactGroup</class-id><body>TBXTransactGroup represents &lt;transacGrp&gt; Elements in the TBX Files. It is used to read these elements and print their data in a human readable way.Instance Variables:	timestamp		&lt;Timestamp&gt;	the time when the change was made	transaction		&lt;String&gt;		the kind of change that was made (like creation or modification)	user			&lt;String&gt;		the user who did this change</body></comment><class><name>RBContainer</name><environment>L10n</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model position adaptor parent dependentRB </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>L10n-UI</package></attributes></class><shared-variable><name>TC</name><environment>L10n.TerminologyController</environment><private>false</private><constant>false</constant><category>singleton</category><initializer>L10n.TerminologyController new</initializer><attributes><package>L10n-Base</package></attributes></shared-variable><shared-variable><name>TTS</name><environment>L10n.TemporaryTranslationStore</environment><private>false</private><constant>false</constant><category>singelton</category><initializer>TemporaryTranslationStore new</initializer><attributes><package>L10n-Base-Data</package></attributes></shared-variable><shared-variable><name>Lud</name><environment>L10n.LookUpDictionary</environment><private>false</private><constant>false</constant><category>singleton</category><initializer>LookUpDictionary new</initializer><attributes><package>L10n-Base</package></attributes></shared-variable><shared-variable><name>TheLocalisator</name><environment>L10n.Localisator</environment><private>false</private><constant>false</constant><category>singleton</category><initializer>Localisator new</initializer><attributes><package>L10n-Models</package></attributes></shared-variable><shared-variable><name>TheTermManager</name><environment>L10n.TermManager</environment><private>false</private><constant>false</constant><category>singleton</category><initializer>TermManager new</initializer><attributes><package>L10n-Models</package></attributes></shared-variable><shared-variable><name>TM</name><environment>L10n.UserMessageTranslationMemory</environment><private>false</private><constant>false</constant><category>Singelton</category><initializer></initializer><attributes><package>L10n-Base</package></attributes></shared-variable><shared-variable><name>StandardKeys</name><environment>L10nTBXSoxDriver</environment><private>false</private><constant>false</constant><category>Configuration</category><initializer>#(#targetString #sourceLanguage #targetCountry #sourceString #sourceCountry #targetLanguage) asSet</initializer><attributes><package>L10n-TMX</package></attributes></shared-variable><methods><class-id>UI.TextEditorView</class-id> <category>accessing</category><body package="L10n-System-Modifications">displaySelection	"Answer whether selections will be shown."	"in L10n this should always be done, so the selection in the sourcecodeviewer is visible without having focus"	self isFromL10n 		ifTrue: [^true]		ifFalse: [^displaySelection and: [self isEnabled]]</body><body package="L10n-System-Modifications">displaySelection: aBoolean 	"Set whether selections will be shown.  Make the visual state consistant."	self isFromL10n 		ifTrue: 			[self selectionShowing: true.			self invalidate]		ifFalse: [super displaySelection: aBoolean]</body><body package="L10n-System-Modifications">isFromL10n	"returns only true if L10n sets it to true"	^isFromL10n ifNil: [isFromL10n := false]</body><body package="L10n-System-Modifications">isFromL10n: anObject 	isFromL10n = anObject ifFalse: [isFromL10n := anObject]</body></methods><methods><class-id>L10n.SystemChecker class</class-id> <category>testing</category><body package="L10n-Base">isCSVAvailable	"GlossaryReaderTabs is a class for reading MSGlossaries. It is a subclass of CSVReader"	^#{Heeg.CsvReader} bindingOrNil ~= nil</body><body package="L10n-Base">isColorFontAvailable	"returns if the class coloredFont is available or not"	^(Smalltalk allClasses select: [:each | each name = #ColoredFont]) isEmpty 		not</body><body package="L10n-Base">isGlossaryImportAvailable	"GlossaryReaderTabs is a class for reading MSGlossaries. It is a subclass of CSVReader"	^#{Heeg.GlossaryReaderTabs} bindingOrNil ~= nil</body></methods><methods><class-id>L10n.SystemChecker class</class-id> <category>loading</category><body package="L10n-Base">loadGlossaryParcels	"loads the microsoft glossary parcel to import CSV files. this parcel is no prerequisit, but is includet into the l10n contribution folder"	self isGlossaryImportAvailable ifTrue: [^true].	(Dialog confirm: #Toimporttheglossariloadthisparcelnow &lt;&lt; #Localizer 				&gt;&gt; 'To import the glossaries, you must first load the MS International Glossaries parcel. Click ''Yes'' to load this parcel now.') 		ifTrue: 			[Notice show: #LoadingParcelMicrosernationalGlossaries &lt;&lt; #Localizer 						&gt;&gt; 'Loading Parcel: Microsoft International Glossaries'				while: 					[Kernel.Parcel withFileCachesDo: 							[Kernel.Parcel 								ensureLoadedParcel: 'Microsoft International Glossaries'								withVersion: ''								for: nil.							Kernel.Parcel broadcastParcels]].			^true]		ifFalse: [^false]</body></methods><methods><class-id>L10n.TerminologyEntry</class-id> <category>converting</category><body package="L10n-Base-Data">asDictionary	"simply returns the data"	^self data</body></methods><methods><class-id>L10n.TerminologyEntry</class-id> <category>accessing</category><body package="L10n-Base-Data">data	^data ifNil: [data := Dictionary new]</body><body package="L10n-Base-Data">data: aDicionary 	data := aDicionary</body><body package="L10n-Base-Data">doesNotUnderstand: aMessage 	"messages that are not understood maybe keys for the dictionary, so pass them along, if they're not keys then return the super implementation"	| aSymbol |	aMessage arguments size &lt; 2 ifFalse: [^super doesNotUnderstand: aMessage].	aSymbol := aMessage selector.	(self data includesKey: aSymbol) ifTrue: [^self data at: aSymbol].	aSymbol last = $: 		ifTrue: [^self perform: aSymbol with: aMessage arguments first].	^nil</body><body package="L10n-Base-Data">keys	^data keys</body><body package="L10n-Base-Data">perform: aSymbol_ with: anObject 	"try to set anObject at aSymbol_ in self data, if not call the super implementation"	| aSymbol |	aSymbol := (aSymbol_ copyFrom: 1 to: aSymbol_ size - 1) asSymbol.	(self respondsTo: aSymbol) 		ifTrue: [^super perform: aSymbol with: anObject]		ifFalse: [^self data at: aSymbol put: anObject]</body></methods><methods><class-id>L10n.TerminologyEntry</class-id> <category>displaying</category><body package="L10n-Base-Data">displayString	^self printString</body><body package="L10n-Base-Data">printOn: aStream 	super printOn: aStream.	aStream		nextPut: $:;		tab.	self data keys asSortedCollection do: 			[:k | 			aStream				nextPutAll: k;				space;				nextPutAll: (self data at: k);				nextPut: $;;				cr]</body></methods><methods><class-id>L10n.TerminologyEntry</class-id> <category>comparing</category><body package="L10n-Base-Data">= anObject 	"comparing is done by comparing the data dictionaries"	self class = anObject class ifFalse: [^false].	self data 		keysAndValuesDo: [:k :v | (anObject data at: k) = v ifFalse: [^false]].	^true</body><body package="L10n-Base-Data">hash	"hash is taken from the data"	^self data hash</body></methods><methods><class-id>L10n.TerminologyEntry class</class-id> <category>instance creation</category><body package="L10n-Base-Data">fromDictionary: aDict 	"initializes with aDict as data"	| a |	aDict isDictionary ifFalse: [^nil].	a := super new.	a data: aDict.	^a</body><body package="L10n-Base-Data">new	^self fromDictionary: Dictionary new.</body></methods><methods><class-id>L10n.TerminologyEntry class</class-id> <category>file description</category><body package="L10n-Base-Data">headlines	"as a subclas of CsvLine this method has to return an array of headers"	^#('EN' 'DE' 'Synonym' 'Remark' 'Source' 'State') asIs</body><body package="L10n-Base-Data">properties	"returns the setter selectors for each key of tableheaders"	^TerminologyController default tableHeaders 		collect: [:each | (each , ':') asSymbol]</body></methods><methods><class-id>L10n.L10nCatalog</class-id> <category>accessing</category><body package="L10n-MessageCatalogs">catalogID	^catalogID</body><body package="L10n-MessageCatalogs">catalogID: anObject	catalogID := anObject</body><body package="L10n-MessageCatalogs">language	^language</body><body package="L10n-MessageCatalogs">language: anObject	language := anObject</body><body package="L10n-MessageCatalogs">lookUp: aMessage	self subclassResponsibility</body></methods><methods><class-id>L10n.L10nCatalog</class-id> <category>initialize-release</category><body package="L10n-MessageCatalogs">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	language := #C.	^self</body></methods><methods><class-id>L10n.L10nCatalog class</class-id> <category>private</category><body package="L10n-MessageCatalogs">addToMessageCatalogManager	self = L10nCatalog ifTrue: [^self].	self allLanguagesPerCatalog keysAndValuesDo: 			[:catalog :languages |			languages do: 					[:each |					(MessageCatalogManager new: each asString)						add: (self forLanguage: each catalog: catalog)]]</body><body package="L10n-MessageCatalogs">allLanguagesPerCatalog	| languagesByCatalog id |	languagesByCatalog := Dictionary new.	self translationProvider allCatalogsLanguagesAndCountriesDo: 			[:catalog :language :country |			id := country = #none						ifTrue: [language]						ifFalse: [language , '_' , country].			(languagesByCatalog at: catalog ifAbsentPut: [Set new]) add: id].	^languagesByCatalog</body><body package="L10n-MessageCatalogs">forLanguage: aString	^(self new)		language: aString;		yourself</body><body package="L10n-MessageCatalogs">forLanguage: aString catalog: catalogID	^(self new)		language: aString;		catalogID: catalogID;		yourself</body><body package="L10n-MessageCatalogs">translationProvider	^TemporaryTranslationStore default</body></methods><methods><class-id>L10n.L10nCatalog class</class-id> <category>instance creation</category><body package="L10n-MessageCatalogs">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>L10n.UserMethodListEntry</class-id> <category>accessing</category><body package="L10n-Base-Data">= anEntry 	(anEntry class == UserMethodListEntry) 		ifFalse: [^false]		ifTrue: [^method = anEntry method]</body><body package="L10n-Base-Data">hash	^method hash</body><body package="L10n-Base-Data">isEmpty	^self method isNil.</body><body package="L10n-Base-Data">method	^method.</body><body package="L10n-Base-Data">method: aMethod	method:=aMethod.</body></methods><methods><class-id>L10n.UserMethodListEntry</class-id> <category>printing</category><body package="L10n-Base-Data">asString	^self displayString asString</body><body package="L10n-Base-Data">asText	^self displayString</body><body package="L10n-Base-Data">displayString	| newStream |	newStream := TextStream on: String new.	"Quick fix - compiled initializers do not have a selector"	method isNil ifTrue: [^String new].	method isMethod 		ifTrue: 			[newStream				nextPutAllText: method selector asText allBold;				nextPutAll: (#spaceInSpace &lt;&lt; #Localizer &gt;&gt; ' in ') asString;				nextPutAll: method mclass fullName]		ifFalse: [method definition printOn: newStream].	^newStream contents</body><body package="L10n-Base-Data">fromString: aString</body><body package="L10n-Base-Data">printOn: aStream 	aStream		nextPutAll: 'ListEntry for:';		nextPutAll: method printString</body></methods><methods><class-id>L10n.UserMethodListEntry class</class-id> <category>instance creation</category><body package="L10n-Base-Data">fromMethod: aMethod 	| entry |		entry := UserMethodListEntry new.	entry method: aMethod.	^entry</body><body package="L10n-Base-Data">fromString: aString	^nil.</body></methods><methods><class-id>L10n.TemporaryTranslationStore</class-id> <category>accesing</category><body package="L10n-Base-Data">allCatalogsLanguagesAndCountriesDo: aBlock	self data keysAndValuesDo: 			[:catalog :byCatalog |			byCatalog do: 					[:byLanguage |					byLanguage keysAndValuesDo: 							[:language :byCountry |							byCountry keys								do: [:country | aBlock value: catalog value: language value: country]]]]</body><body package="L10n-Base-Data">allLanguages	| allLanguages |	allLanguages := Set new.	self allCatalogsLanguagesAndCountriesDo: 			[:catalog :language :country |			country = #none				ifTrue: [allLanguages add: language]				ifFalse: [allLanguages add: language , '_' , country]].	^allLanguages</body><body package="L10n-Base-Data">data	data isNil ifTrue:[data:=IdentityDictionary new.].	^data.</body><body package="L10n-Base-Data">data: anObject 	data := anObject</body><body package="L10n-Base-Data">getDefaultStringFor: aUserMessage in: aCatalog forLang: aLanguage forCountry: aCountry	"search for the defaultString of an UserMessage in a Catalog. If the Catalog dos not exist, or includes not the Usermessage, returns an empty String."	| catalogDict langs countries |	catalogDict := self data at: aCatalog ifAbsent: [^nil].	langs := catalogDict at: aUserMessage key ifAbsent: [^nil].	countries := langs at: aLanguage ifAbsent: [^nil].	countries at: aCountry ifPresent:[:translation | ^translation].	^countries at: #none ifAbsent:[nil]</body><body package="L10n-Base-Data">lookUp: aUserMessage	^self lookUp: aUserMessage forLocale: Locale current</body><body package="L10n-Base-Data">lookUp: aUserMessage forLanguageAndTerritory: languageAndTeretory	| tCult cat defString tLang tSpec |	tSpec := languageAndTeretory tokensBasedOn: $_.	cat := aUserMessage catalogID.	tLang := tSpec at: 1.	tLang isEmpty ifTrue: [^nil].	tSpec size &gt; 1 ifTrue: [tCult := tSpec at: 2] ifFalse: [tCult := #none].	defString := self				getDefaultStringFor: aUserMessage				in: cat				forLang: tLang asSymbol				forCountry: tCult asSymbol.	^defString isNil ifTrue: [^nil] ifFalse: [^defString defaultString]</body><body package="L10n-Base-Data">lookUp: aUserMessage forLocale: locale	^self lookUp: aUserMessage		forLanguageAndTerritory: locale languageAndTerritory</body><body package="L10n-Base-Data">save: aUserMessage with: aKeySymbol in: aCatalogSymbol forLang: aLanguage forCountry: aCountry	| byCatalogs oldLanguages newLanguages |	oldLanguages := self allLanguages.	byCatalogs := self data at: aCatalogSymbol				ifAbsentPut: [IdentityDictionary new].	((byCatalogs at: aKeySymbol ifAbsentPut: [IdentityDictionary new])		at: aLanguage asSymbol		ifAbsentPut: [IdentityDictionary new]) at: aCountry asSymbol			put: aUserMessage.	newLanguages := self allLanguages.	oldLanguages ~= newLanguages		ifTrue: 			["if new languages were added, we need to refresh the message catalogs so that the translations can be provided by the TemporaryTranslationStore"			MessageCatalogManager initialize]</body></methods><methods><class-id>L10n.TemporaryTranslationStore class</class-id> <category>accessing</category><body package="L10n-Base-Data">default	TTS ifNil:[TTS:=self new].	^TTS.</body><body package="L10n-Base-Data">lookUp: anObject	^self default lookUp: anObject</body></methods><methods><class-id>L10n.TemporaryTranslationStore class</class-id> <category>initialize-release</category><body package="L10n-Base-Data">new	| tts |	tts := super new.	tts data: IdentityDictionary new.	^tts</body></methods><methods><class-id>L10n.TemporaryTranslationStore class</class-id> <category>private</category><body package="L10n-Base-Data">addToMessageCatalogManager	"do nothing"</body></methods><methods><class-id>Refactory.Browser.L10nNavigator</class-id> <category>changing</category><body package="L10n-RBSupport">changed	super changed.	l10n navigatorChanged</body><body package="L10n-RBSupport">updateWindowLabel	"do nothing"</body></methods><methods><class-id>Refactory.Browser.L10nNavigator</class-id> <category>accessing</category><body package="L10n-RBSupport">l10n	^l10n</body><body package="L10n-RBSupport">l10n: anObject	l10n := anObject</body></methods><methods><class-id>Refactory.Browser.L10nNavigator</class-id> <category>private</category><body package="L10n-RBSupport">canAddEditMenu	^false</body></methods><methods><class-id>Refactory.Browser.L10nNavigator</class-id> <category>aspects</category><body package="L10n-RBSupport">L10nNavigatorPart	^partsDictionary at: #L10nNavigatorPart		ifAbsentPut: [parts add: (L10nNavigatorPart onNavigator: self)]</body></methods><methods><class-id>Refactory.Browser.L10nNavigator class</class-id> <category>instance creation</category><body package="L10n-RBSupport">forEnvironment: aBrowserEnvironment dispatcher: aRBActionDispatcher 	| nav |	nav := super forEnvironment: aBrowserEnvironment dispatcher: aRBActionDispatcher.	nav l10n: aBrowserEnvironment l10n.	^nav.</body></methods><methods><class-id>L10n.TranslationChecker</class-id> <category>changing</category><body package="L10n-UI">catalogChanged	| sLangSpec tLangSpec list |	self catalogs selection		ifNil: 			[self keys list: Array new.			^self].	sLangSpec := self sourceLanguage value.	tLangSpec := self targetLanguage value.	list := (Localisator default				getUserMessagesForCatalog: self catalogs selection				sourceLangSpec: sLangSpec				targetLangSpec: tLangSpec) sorted.	self keys list: (self asCheckedTranslations: list)</body><body package="L10n-UI">keyChanged	| key |	self keys selection isNil		ifTrue: 			[self original value: ''.			self translation value: ''.			^self].	key := self keys selection key.	self original value: (self originalForKey: key).	self translation value: (self translationForKey: key)</body><body package="L10n-UI">originalForKey: key	^Localisator default		sourceDefaultStringForUserMessage: key		from: self sourceLanguage value		to: self targetLanguage value</body><body package="L10n-UI">targetLanguageChanged	self catalogs list: UserMessageTranslationMemory default getCatalogs</body><body package="L10n-UI">toggleSelectedKey	self keys selection ifNotNil: [:key | key valid: key valid not]</body><body package="L10n-UI">translationForKey: key	^((Localisator default		getExistingTranslationsForUserMessage: key		from: self sourceLanguage value		to: self targetLanguage value) detect: [:each | true] ifNone: [nil])		ifNotNil: [:translationCollection | translationCollection latestTranslation translated]</body></methods><methods><class-id>L10n.TranslationChecker</class-id> <category>aspects</category><body package="L10n-UI">catalogs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	catalogs isNil		ifTrue: 			[catalogs := SelectionInList new.			catalogs selectionHolder onChangeSend: #catalogChanged to: self].	^catalogs</body><body package="L10n-UI">keys	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	keys isNil		ifTrue: 			[keys := SelectionInList new.			keys selectionHolder onChangeSend: #keyChanged to: self].	^keys</body><body package="L10n-UI">original	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^original isNil		ifTrue:			[original := String new asValue]		ifFalse:			[original]</body><body package="L10n-UI">sourceLanguage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	sourceLanguage isNil ifTrue: [sourceLanguage := #C_none asValue].	^sourceLanguage</body><body package="L10n-UI">sourceLanguages	^Menu labelArray: #('C') values: #(#C_none)</body><body package="L10n-UI">targetLanguage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	targetLanguage isNil		ifTrue: 			[targetLanguage := nil asValue.			targetLanguage onChangeSend: #targetLanguageChanged to: self].	^targetLanguage</body><body package="L10n-UI">targetLanguages	| languages |	languages := Localisator default targetLangChoice.	^Menu labelArray: languages values: languages</body><body package="L10n-UI">translation	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^translation isNil		ifTrue:			[translation := String new asValue]		ifFalse:			[translation]</body></methods><methods><class-id>L10n.TranslationChecker</class-id> <category>actions</category><body package="L10n-UI">showReport	| ws |	ws := String new writeStream.	(self keys list reject: #valid) do: 			[:each |			ws nextPutAll: ('&lt;1s&gt; - &lt;2s&gt;'						expandMacrosWith: (self originalForKey: each key)						with: (self translationForKey: each key))]		separatedBy: [ws cr].	Dialog confirmReport: ws contents</body></methods><methods><class-id>L10n.TranslationChecker</class-id> <category>accessing</category><body package="L10n-UI">asCheckedTranslations: anArray	^anArray collect: 			[:each |			(CheckedTranslation new)				key: each;				yourself]</body></methods><methods><class-id>L10nTBXObject</class-id> <category>accessing</category><body package="L10n-TMX">category	^category</body><body package="L10n-TMX">category: anObject	category := anObject</body><body package="L10n-TMX">id	^id</body><body package="L10n-TMX">id: anObject	id := anObject</body><body package="L10n-TMX">key	^key</body><body package="L10n-TMX">key: anObject	key := anObject</body><body package="L10n-TMX">notes	^notes</body><body package="L10n-TMX">notes: nts 	notes := nts</body><body package="L10n-TMX">original	^original</body><body package="L10n-TMX">original: org	original := org.</body><body package="L10n-TMX">source	^source</body><body package="L10n-TMX">source: aSource	source := aSource.</body><body package="L10n-TMX">src	^src</body><body package="L10n-TMX">src: anObject	src := anObject</body><body package="L10n-TMX">srcLang	^srcLang</body><body package="L10n-TMX">srcLang: anObject	srcLang := anObject</body><body package="L10n-TMX">synonym	^synonym</body><body package="L10n-TMX">synonym: syn 	synonym := syn</body><body package="L10n-TMX">tar	^tar</body><body package="L10n-TMX">tar: anObject	tar := anObject</body><body package="L10n-TMX">tarLang	^tarLang</body><body package="L10n-TMX">tarLang: anObject	tarLang := anObject</body><body package="L10n-TMX">translation	^translation</body><body package="L10n-TMX">translation: trans	translation := trans.</body><body package="L10n-TMX">valid	^valid</body><body package="L10n-TMX">valid: status 	valid := status</body><body package="L10n-TMX">version	^version</body><body package="L10n-TMX">version: anObject	version := anObject</body></methods><methods><class-id>L10nTBXObject</class-id> <category>xml</category><body package="L10n-TMX">asXMLElement	^XML.Element		tag: #termEntry		attributes: (Array with: (XML.Attribute name: #id value: self id))		elements: (Array				with: (self xmlDescriptionNamed: #definition value: self notes)				with: (self xmlDescriptionNamed: #source value: self source)) , (Array							with: (self xmlDescriptionNamed: #valid value: self valid)							with: (self langSetForLanguage: self srcLang text: self original)							with: (self langSetForLanguage: self tarLang									texts: (Array with: self translation with: self synonym)))</body><body package="L10n-TMX">langSetForLanguage: lang text: text	^self langSetForLanguage: lang texts: (Array with: text)</body><body package="L10n-TMX">langSetForLanguage: lang texts: strings	^XML.Element		tag: #langSet		attributes: (Array with: (XML.Attribute name: 'xml:lang' value: lang))		elements: ((strings select: #notEmpty) collect: [:each | self tigForText: each])</body><body package="L10n-TMX">tigForText: text	^XML.Element		tag: #tig		attributes: #()		elements: (Array with: (XML.Element						tag: #term						attributes: #()						elements: (Array with: (XML.Text text: text))))</body><body package="L10n-TMX">xmlDescriptionNamed: type value: text	^XML.Element		tag: #descrip		attributes: (Array with: (XML.Attribute name: #type value: type))		elements: (Array with: (XML.Text text: text))</body></methods><methods><class-id>L10nTBXObject</class-id> <category>testing</category><body package="L10n-TMX">isExportable	^true</body></methods><methods><class-id>L10nTBXObject class</class-id> <category>instance creation</category><body package="L10n-TMX">from: aDictionary using: aWriter	"creates an instance of itself from an entry of the translation memory.	The source and target language are not set in L10n, thus we need to default to en/de_DE here."	^(self new)		srcLang: 'en';		tarLang: 'de_DE';		original: (aDictionary at: #original);		id: (aWriter keyIDFor: (aDictionary at: #original));		translation: (aDictionary at: #translation);		synonym: (aDictionary at: #synonym);		source: (aDictionary at: #source);		notes: (aDictionary at: #notes);		valid: (aDictionary at: #valid);		yourself</body></methods><methods><class-id>L10n.TermListUI</class-id> <category>initialize-release</category><body package="L10n-UI">initialize	self termlistSelectionIndex onChangeSend: #termSelectionChanged to: self.	self userMessageListSelectionIndex 		onChangeSend: #userMessageChanged		to: self</body><body package="L10n-UI">initializeAspectAdaptor: aspect 	| adaptor |	adaptor := AspectAdaptor subject: model.	adaptor forAspect: aspect.	adaptor subjectSendsUpdates: true.	self perform: (aspect , ':') asSymbol with: adaptor</body><body package="L10n-UI">initializeAspectAdaptors	| |	#(#termlist userMessageList) do: 			[:aspect | 			self initializeAspectAdaptor: aspect.			self 				initializeAspectAdaptor: (aspect asString , 'SelectionIndex') asSymbol]</body></methods><methods><class-id>L10n.TermListUI</class-id> <category>aspects</category><body package="L10n-UI">termlist	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^termlist isNil		ifTrue:			[termlist := SelectionInList new]		ifFalse:			[termlist]</body><body package="L10n-UI">termlist: anObject 	self termlist listHolder: anObject</body><body package="L10n-UI">termlistSelectionIndex	^self termlist selectionIndexHolder</body><body package="L10n-UI">termlistSelectionIndex: anObject 	self termlist selectionIndexHolder: anObject</body><body package="L10n-UI">userMessageList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userMessageList isNil		ifTrue:			[userMessageList := SelectionInList new]		ifFalse:			[userMessageList]</body><body package="L10n-UI">userMessageList: anObject	self userMessageList listHolder: anObject.</body><body package="L10n-UI">userMessageListSelectionIndex	^self userMessageList selectionIndexHolder</body><body package="L10n-UI">userMessageListSelectionIndex: anObject	self userMessageList selectionIndexHolder: anObject.</body></methods><methods><class-id>L10n.TermListUI</class-id> <category>changing</category><body package="L10n-UI">filterChanged	"the filter changed, so update the list"	| filter sel |	"sel := self termlist selection."	filter := '*' , self parent filter , '*'.	sel := self termlist selection.	self termlist setList: (self list select: [:each | filter match: each]) selecting:sel.</body><body package="L10n-UI">termSelectionChanged	"selection in Termlist changed, update userMessages"	self setUserMessages.	self selectFirstMessage.</body><body package="L10n-UI">userMessageChanged	self parent userMessageChangedWith: self userMessageList selection		from: self</body></methods><methods><class-id>L10n.TermListUI</class-id> <category>userMessageSelection</category><body package="L10n-UI">deselectUserMessage	"do nothing, is allready selected"	^self.</body><body package="L10n-UI">selectFirstMessage	"selects the first userMessage, if there's one available."	| aList userMessage |	self userMessageList list size &gt; 0 		ifFalse: 			["if there're no messages, return nil"			^nil].	self userMessageList selectionIndex = 1 		ifTrue: 			["if there's allready something selected, no need to select it again."			^nil].	L10nSettings default removeTranslatedEntries 		ifFalse: 			["select the first translated message"			aList := self userMessageList list.			1 to: aList size				do: 					[:i | 					userMessage := aList at: i.					userMessage translated 						ifFalse: 							[self userMessageList selection: userMessage.							^userMessage]]].	"if no message is selected yet, select the first and return the selection"	self userMessageList selectionIndex: 1.	^self userMessageList selection</body><body package="L10n-UI">selectNextUserMessage	"selects the first userMessage, if there's one available."	| |	self userMessageList list size &gt; 0 		ifFalse: 			["if there're no messages, return nil"			^nil].	self userMessageList 		selectionIndex: (self userMessageList selectionIndex + 1 				min: self userMessageList list size).	^self userMessageList selection</body><body package="L10n-UI">selectPreviousUserMessage	"selects the userMessage at selectionIndex-1"	self userMessageList list size &gt; 0 ifFalse: [^nil].	self userMessageList 		selectionIndex: (self userMessageList selectionIndex - 1 max: 1).	^self userMessageList selection</body><body package="L10n-UI">selectUserMessage	"do nothing, is allready selected"	^self.</body></methods><methods><class-id>L10n.TermListUI</class-id> <category>private</category><body package="L10n-UI">list	^list ifNil:[list := Array new].</body><body package="L10n-UI">selectedTerm	"returns the termlist's selection"	^self termlist selectionIndex &lt; self termlist list size 		ifTrue: [self termlist selection]		ifFalse: [nil]</body><body package="L10n-UI">setList: aList	list := aList.</body><body package="L10n-UI">setTerms	"sets the termList and displays it filtered"	self setList: Localisator default newTermList.	self filterChanged</body><body package="L10n-UI">setUserMessages	self userMessageList list: (Localisator default 				getUserMessagesContainingTerm: (self termlist selection ifNil: [String new])				source: self parent sourceLangSpec value				target: self parent targetLangSpec value)</body></methods><methods><class-id>L10n.TermListUI</class-id> <category>accessing</category><body package="L10n-UI">model	^model</body><body package="L10n-UI">model: anObject	model := anObject</body><body package="L10n-UI">parent	^parent</body><body package="L10n-UI">parent: anObject	parent := anObject</body></methods><methods><class-id>L10n.TermListUI</class-id> <category>interface opening</category><body package="L10n-UI">postBuildWith: aBuilder 	self parent uiForUserMessage: self.</body></methods><methods><class-id>L10n.TermListUI class</class-id> <category>instance creation</category><body package="L10n-UI">inParent: aModel 	| viewer |	viewer := self new.	viewer parent: aModel.	^viewer</body></methods><methods><class-id>L10n.TermManagerUI</class-id> <category>actions</category><body package="L10n-UI">addTerms	"requests a file and loads all terms into the terminology without deleting all the terms before"	(TerminologyController default importTBXandDeleteOld: false) 		ifTrue: 			[TerminologyController default triggerEvent: #terminologyChanged.			self updateTerms]</body><body package="L10n-UI">cancel	"This stub method was generated by UIDefiner"	^self termSelectionChanged</body><body package="L10n-UI">doubleClickedMessage	| extendedUserMessageListEntry |	extendedUserMessageListEntry := self selectedUserMessage value.	self openUserMessage: extendedUserMessageListEntry key				&lt;&lt; extendedUserMessageListEntry catalog</body><body package="L10n-UI">editExcludelist	"opens the EditExcludeListUI window"	EditExcludeListUI open</body><body package="L10n-UI">find	"select the filterfield"	^(self widgetAt: #searchField) components first takeKeyboardFocus</body><body package="L10n-UI">newTerm	"create a new Term"	Localisator default 		when: #editFinished		send: #updateTerms		to: self .	^Localisator default newTerm: String new</body><body package="L10n-UI">ok	"This stub method was generated by UIDefiner"	^self saveCurrent</body><body package="L10n-UI">openTerminology	"opens a filerequest and replaces the terminology with the data from file"	(TerminologyController default importTBXandDeleteOld: true) 		ifTrue: 			[TerminologyController default triggerEvent: #terminologyChanged.			self updateTerms]</body><body package="L10n-UI">openUserMessage: message	| window |	window := L10nUI raiseSingleInstance				ifNil: 					[(L10nUI new)						open;						mainWindow].	window model selectKey: message key inCatalog: message catalogID</body><body package="L10n-UI">saveTerminology	"saves the current Terminology to a textfile"	TerminologyController default exportTBX</body></methods><methods><class-id>L10n.TermManagerUI</class-id> <category>aspects</category><body package="L10n-UI">comments	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^comments isNil		ifTrue:			[comments := String new asValue]		ifFalse:			[comments]</body><body package="L10n-UI">currentTranslation	^(PluggableAdaptor on: nil asValue)		getBlock: [:m | self translationForRow: m]		putBlock: [:m :v | ]		updateBlock: [:m :v :a | false]</body><body package="L10n-UI">original	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^original isNil		ifTrue:			[original := String new asValue]		ifFalse:			[original]</body><body package="L10n-UI">selectedUserMessage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectedUserMessage isNil		ifTrue:			[selectedUserMessage := nil asValue]		ifFalse:			[selectedUserMessage]</body><body package="L10n-UI">source	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^source isNil		ifTrue:			[source := String new asValue]		ifFalse:			[source]</body><body package="L10n-UI">sourceList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sourceList isNil		ifTrue:			[sourceList := Array new asValue]		ifFalse:			[sourceList]</body><body package="L10n-UI">synonym	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^synonym isNil		ifTrue:			[synonym := String new asValue]		ifFalse:			[synonym]</body><body package="L10n-UI">terms	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^terms isNil		ifTrue:			[terms := SelectionInList new]		ifFalse:			[terms]</body><body package="L10n-UI">translation	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^translation isNil		ifTrue:			[translation := String new asValue]		ifFalse:			[translation]</body><body package="L10n-UI">translationForRow: userMessageListEntry	^TermManager default getTranslationForUserMessage: userMessageListEntry</body><body package="L10n-UI">userMessageList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userMessageList isNil		ifTrue:			[userMessageList :=  SelectionInListSortAware new.			userMessageList selectionIndexHolder compute:				[:v |				self selectedUserMessage value: userMessageList selection].			userMessageList]		ifFalse:			[userMessageList]</body><body package="L10n-UI">valid	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^valid isNil		ifTrue:			[valid := false asValue]		ifFalse:			[valid]</body></methods><methods><class-id>L10n.TermManagerUI</class-id> <category>accessing</category><body package="L10n-UI">filter	^filter ifNil:[filter := String new.]</body><body package="L10n-UI">filter: anObject	filter := anObject.	self setTerms.	self termSelectionChanged.</body><body package="L10n-UI">searchField	^searchField</body><body package="L10n-UI">searchField: anObject	searchField := anObject</body></methods><methods><class-id>L10n.TermManagerUI</class-id> <category>private</category><body package="L10n-UI">deleteCurrentTerm	| i |	i := self terms selectionIndex.	i &gt; 0 		ifTrue: 			[TermManager default 				removeTerm: self original value				withTranslation: self translation value				synonym: self synonym value				notes: self comments value				source: self source value				valid: self valid value.			self setTerms.			self terms selectionIndex: (i min: self terms list size).			self termSelectionChanged]</body><body package="L10n-UI">loadFromDictionary: aDictionary	| aList |	self original value: (aDictionary at: #original ifAbsent: [nil]).	self translation value: (aDictionary at: #translation ifAbsent: [nil]).	self synonym value: (aDictionary at: #synonym ifAbsent: [nil]).	self comments value: (aDictionary at: #notes ifAbsent: [nil]).	self source value: (aDictionary at: #source ifAbsent: [nil]).	self valid value: (aDictionary at: #valid ifAbsent: [nil]) == #Ok.	aList := TermManager default userMessagesForTerm: self original value.	self userMessageList list: (aList sorted: #key ascending, #catalog ascending).	orgDict := aDictionary</body><body package="L10n-UI">saveCurrent	TermManager default 		saveTerm: self terms selection		withOriginal: self original value		translation: self translation value		synonym: self synonym value		notes: self comments value		source: self source value		valid: (self valid value ifTrue: ['Ok'] ifFalse: [String new])		intoDict: orgDict.	self updateSourceMenu</body><body package="L10n-UI">setTerms	self terms list: (TermManager default termsForFilter: self filter)</body><body package="L10n-UI">sortUserMessagesUsing: sortSelector 	| sortBlock ascSortBlock dscSortBlock |	ascSortBlock := 			[:x :y | 			(x perform: sortSelector) displayString 				&lt;= (y perform: sortSelector) displayString].	dscSortBlock := 			[:x :y | 			(x perform: sortSelector) displayString 				&gt;= (y perform: sortSelector) displayString].	sortBlock := self userMessageList sortAspect == #userMessagesEdit 				ifTrue: 					[self userMessageList sortDirection == #asc 						ifTrue: 							[self userMessageList sortDirection: #dsc.							ascSortBlock]						ifFalse: 							[self userMessageList sortDirection: #asc.							dscSortBlock]]				ifFalse: 					[self userMessageList sortAspect: #userMessagesEdit.					self userMessageList sortDirection: #dsc.					ascSortBlock].	self userMessageList 		refreshList: (SortedCollection withAll: self userMessageList list				sortBlock: sortBlock) asList</body><body package="L10n-UI">updateSourceMenu	"collect all sources and set the sourcemenu to it"	self sourceList value: TermManager default getSourceList</body><body package="L10n-UI">updateTerms	"update terms, they have changed"	self setTerms</body></methods><methods><class-id>L10n.TermManagerUI</class-id> <category>interface closing</category><body package="L10n-UI">noticeOfWindowClose: aWindow 	TerminologyController default triggerEvent: #terminologyChanged</body></methods><methods><class-id>L10n.TermManagerUI</class-id> <category>searchField</category><body package="L10n-UI">acceptSearchResults: aResult	^self filter: aResult</body><body package="L10n-UI">keyPress: aKeyboardEvent inEntryController: aController 	"Catch a down arrow in the input field and do the right thing in the list box."	aKeyboardEvent keyValue = #Down 		ifTrue: 			["increase selection in Term list "			self terms 				selectionIndex: (self terms selectionIndex + 1 min: self terms list size).			^nil].	aKeyboardEvent keyValue = #Up 		ifTrue: 			["decrease selection in Term list "			self terms 				selectionIndex: (self terms selectionIndex - 1 max: 1).			^nil].	^aKeyboardEvent</body></methods><methods><class-id>L10n.TermManagerUI</class-id> <category>events</category><body package="L10n-UI">currentTranslationLabelPressed	| sortSelector |	sortSelector := #currentTranslation.	self sortUserMessagesUsing: sortSelector</body><body package="L10n-UI">doShortCuts: event 	"pass event to the toolbar and see if it can handle the event"	self class mainMenu menuItems do: 			[:each | 			each shortcutKeyValue = event keyValue 				ifTrue: 					[each shortcutModifierSymbols = event shortcutModifierSymbols 						ifTrue: 							[self perform: each value.							^nil]]].	event keyValue = Graphics.TextConstants.ESC 		ifTrue: [self closeAndUnschedule].	^event</body><body package="L10n-UI">keyPressed: event 	"key was pressed in the termlist"	(event keyValue = Character backspace or: [event keyValue = Character del]) 		ifTrue: 			[self deleteCurrentTerm.			^nil].	^event</body><body package="L10n-UI">selectedUserMessageCatalogLabelPressed	| sortSelector |	sortSelector := #catalog.	self sortUserMessagesUsing: sortSelector</body><body package="L10n-UI">selectedUserMessageKeyLabelPressed	| sortSelector |	sortSelector := #key.	self sortUserMessagesUsing: sortSelector</body><body package="L10n-UI">selectedUserMessageSourceStringLabelPressed	| sortSelector |	sortSelector := #sourceString.	self sortUserMessagesUsing: sortSelector</body></methods><methods><class-id>L10n.TermManagerUI</class-id> <category>changing</category><body package="L10n-UI">termSelectionChanged	"term selection changed, so load data for the term and select the right one depending on how many termns with the same name there are, and which is selected"	| resList sel anIndex |	sel := self terms selection.	resList := TerminologyController default allDatesForTerm: sel.	anIndex := 1.	self terms selectionIndex &gt; 1 		ifTrue: 			["get the number of terms with the same name above the selection"						[self terms selectionIndex &gt; anIndex 				and: [(self terms list at: self terms selectionIndex - anIndex) = sel]] 					whileTrue: [anIndex := anIndex + 1]].	self terms selectionIndex = 0 		ifTrue: [self loadFromDictionary: Dictionary new].	resList isEmpty 		ifTrue: [self loadFromDictionary: Dictionary new]		ifFalse: 			["use this number to get the apropriate dictionary"			self loadFromDictionary: (resList at:(resList size min: anIndex)) key]</body></methods><methods><class-id>L10n.TermManagerUI</class-id> <category>initialize-release</category><body package="L10n-UI">initialize	self searchField: EntryModule new.	self setTerms.	self updateSourceMenu.</body></methods><methods><class-id>L10n.TermManagerUI</class-id> <category>interface opening</category><body package="L10n-UI">postBuildWith: aBuilder	"set up the search field and add a keyboardHook to the termlist to handle delete and backspace keyboard events"	| messageListWidget searchDriver |	super postBuildWith: aBuilder.	(self widgetAt: #searchField)		client: searchField		spec: searchField preferredWindowSpec		builder: aBuilder newSubBuilder.	searchField continuouslyAccept.	searchDriver := BackgroundSearchDriver new				patternHolder: searchField entryHolder				searchBlock: [:search | search]				resultHolder: [:results | self acceptSearchResults: results].	searchField entryWidget controller		prependKeyboardHook: [:event :controller | self keyPress: event inEntryController: controller].	searchDriver search.	self builder window controller keyboardProcessor		keyboardHook: [:ev :c | self doShortCuts: ev].	(self widgetAt: #termlist) controller		keyboardHook: [:ev :c | self keyPressed: ev].	messageListWidget := self widgetAt: #userMessageDataset.	DataSetAutoresizeWrapper autoResizeColumnsIn: messageListWidget		usingSpec: #(200 150 0 0)</body></methods><methods><class-id>L10n.Exporter</class-id> <category>accessing</category><body package="L10n-Models">availablecatalogs	| cats |	cats := self catalog tokensBasedOn: Character space.	^(UserMessageTranslationMemory default getCatalogs 		collect: [:each | each name]) select: [:each | (cats includes: each asString) not]</body><body package="L10n-Models">availablecatalogs: anObject 	^availableCatalogs := anObject</body><body package="L10n-Models">availabledatehandles	^ #(#before #at #after)</body><body package="L10n-Models">availabledatehandles: anObject	^ #(#before #at #after)</body><body package="L10n-Models">catalog	catalog isNil ifTrue: [catalog := String new].	^catalog</body><body package="L10n-Models">catalog: anObject 	| stream catalogs selectedCatalogs |	stream := String new writeStream.	catalogs := UserMessageTranslationMemory default getCatalogs collect: [:each | each name].	selectedCatalogs := anObject tokensBasedOn: Character space.	selectedCatalogs do: [:each | (catalogs includes: each asSymbol)			ifTrue: [stream nextPutAll: each; space]			ifFalse: [each isEmpty ifFalse: [Dialog warn: ((#Catalog1sDoesNotExist &lt;&lt; #Localizer &gt;&gt; 'Catalog &lt;1s&gt; does not exist and therefor is removed from the list') expandMacrosWith: each)]]].	catalog := stream contents.	self changed: #catalog</body><body package="L10n-Models">catalogchoices	^(#ChooseOne &lt;&lt; #Localizer &gt;&gt; 'Choose one') asString.</body><body package="L10n-Models">catalogchoices: anObject 	self catalog: self catalog , anObject , ' '.	self changed: #catalogchoices.	self changed: #catalog.	self changed: #availablecatalogs.</body><body package="L10n-Models">closeme	^closeme</body><body package="L10n-Models">closeme: anObject	closeme := anObject</body><body package="L10n-Models">date	date isNil ifTrue: [date := Date today printFormat: #( 1 2 3 $. 2 1)].	^date</body><body package="L10n-Models">date: anObject 	| aDate |	aDate := [ Date readFrom: anObject readStream] on: Error		do: 			[:exc | 			"just reload the old content"			self changed: #date.			^self].	date := aDate printFormat: #(1 2 3 $. 2 1).	self changed: #date</body><body package="L10n-Models">datehandling	dateHandling isNil 		ifTrue: [dateHandling := self availabledatehandles first].	^dateHandling</body><body package="L10n-Models">datehandling: anObject 	^dateHandling := anObject</body><body package="L10n-Models">errortext	errorText isNil ifTrue: [errorText := String new].	^errorText</body><body package="L10n-Models">	errortext: anObject 	errorText := anObject.	self changed: #errortext.</body><body package="L10n-Models">fileformat	fileFormat isNil ifTrue: [fileFormat := self fileformats first].	^fileFormat</body><body package="L10n-Models">fileformat: anObject	fileFormat := anObject asSymbol</body><body package="L10n-Models">fileformats	^#(#TMX)</body><body package="L10n-Models">fileformats: anObject	^#(#TMX #TBX #Boss)</body><body package="L10n-Models">savepath	savePath isNil ifTrue: [savePath := String new].	^savePath</body><body package="L10n-Models">savepath: anObject 	savePath := anObject.	self changed: #savepath.</body><body package="L10n-Models">translations	translations isNil ifTrue:[translations := #Translator].	^translations</body><body package="L10n-Models">translations: anObject 	translations := anObject.	self changed: #translations</body></methods><methods><class-id>L10n.Exporter</class-id> <category>methodsForUnloading</category><body package="L10n-Models">tmAllCatalogs	"sets all catalogs to be removed"	self tmcatalog: self tmcatalog , ' ' 				, (self writeAllCatalogsFrom: self tmavailablecatalogs)</body><body package="L10n-Models">tmavailablecatalogs	"returns the catalogs that are not yet in the field but that are available"	| coll |	coll := self tmcatalog tokensBasedOn: Character space.	^UserMessageTranslationMemory default allCatalogs 		select: [:each | (coll includes: each asString) not]</body><body package="L10n-Models">tmcatalog	"returns the current catalog"	^tmCatalog ifNil: [tmCatalog := String new]</body><body package="L10n-Models">tmcatalog: aString 	"sets tmCatalog to aString, but check if everything is allright"	| s catalogs |	aString ifNil: [^nil].	catalogs := UserMessageTranslationMemory default allCatalogs.	s := String new writeStream.	(aString tokensBasedOn: Character space) asSet asSortedCollection do: 			[:each | 			(catalogs includes: each asSymbol) 				ifTrue: 					[s nextPutAll: each.					s space]].	tmCatalog := s contents.	self changed:#tmcatalog.</body><body package="L10n-Models">tmcatalogchoices	^(#ChooseOne &lt;&lt; #Localizer &gt;&gt; 'Choose one') asString</body><body package="L10n-Models">tmcatalogchoices: aCatalogSymbol 	"sets the catalogSymbol"	self tmcatalog: self tmcatalog , aCatalogSymbol , ' '.	self changed:#tmcatalogchoices.</body></methods><methods><class-id>L10n.Exporter</class-id> <category>initialize-release</category><body package="L10n-Models">initialize	"Initialize a newly created instance. This method must answer the receiver."</body></methods><methods><class-id>L10n.Exporter</class-id> <category>actions</category><body package="L10n-Models">allCatalogs	self catalog: self catalog , ' ' 				, (self writeAllCatalogsFrom: self availablecatalogs)</body><body package="L10n-Models">browsePath	self		savepath: (Dialog requestNewFileName: #Wheredoyouwanttosave &lt;&lt; #Localizer						&gt;&gt; 'Where do you want to save?'				default: 'Translations.' , self fileformat)</body><body package="L10n-Models">descriptionDictionary	| catalogs timeStamp selector d |	d := Dictionary new.	catalogs := self catalog tokensBasedOn: Character space.	d at: #catalog put: [:each | catalogs includes: each asString].	timeStamp := (Date readFrom: self date readStream) asTimestamp.	selector := self datehandling asSymbol = #before				ifTrue: [#&lt;=]				ifFalse: [self datehandling asSymbol = #at ifTrue: [#=] ifFalse: [#&gt;=]].	self translations = #Translator		ifFalse: 			[d at: #version				put: [:each | each timeStamp asDate perform: selector with: timeStamp asDate]]		ifTrue: 			[d at: #version				put: 					[:each |					each source = L10nSettings default translator						and: [each timeStamp asDate perform: selector with: timeStamp asDate]]].	^d</body><body package="L10n-Models">messageCollectionDescribedBy: d	| coll |	Notice show: #searchingForTranslations &lt;&lt; #Localizer				&gt;&gt; 'Searching for Translations'		while: 			[coll := L10n.UserMessageTranslationMemory default translationMD at: d						ifAbsent: [OrderedCollection new]].	^coll</body><body package="L10n-Models">startExport	| description messages |	self catalog isEmpty		ifTrue: 			[self				errortext: #NoCatalogsspecified &lt;&lt; #Localizer &gt;&gt; 'No Catalogs specified'.			^nil].	self browsePath.	self savepath isEmpty		ifTrue: 			[self errortext: #NoFilespecifiedforsaving &lt;&lt; #Localizer						&gt;&gt; 'No File specified for saving'.			^nil].	description := self descriptionDictionary.	messages := self messageCollectionDescribedBy: description.	self fileformat = #TMX ifTrue: [self writeTMX: messages].	self fileformat = #TBX ifTrue: [self writeTBX: messages].	self triggerEvent: #CloseMe</body><body package="L10n-Models">startUnload	"starts to unload the messages that are in the catalogs that are selected"	| catalogs d removed |	catalogs := ((self tmcatalog tokensBasedOn: Character space) 				collect: [:each | each asSymbol]) asSet.	d := Dictionary new.	d at: #catalog put: [:aCatalog | catalogs includes: aCatalog].	Notice show: #removingTranslations &lt;&lt; #Localizer 				&gt;&gt; 'removing translations, please wait'		while: 			[removed := UserMessageTranslationMemory default translationMD remove: d						ifAbsent: [nil]].	Notice show: #recalculatingTranslationRates &lt;&lt; #Localizer 				&gt;&gt; 'Recalculating Translationrates, please wait'		while: 			[UserMessageTranslationMemory default 				recalculateTranslationRatesFrom: L10nSettings default lastSource				to: L10nSettings default lastTarget].	Notice show: #loadingData &lt;&lt; #Localizer &gt;&gt; 'loading data'		while: 			[UserMessageTranslationMemory default triggerEvent: #SystemMessagesRead].	Dialog 		warn: (#removed1pTranslations &lt;&lt; #Localizer &gt;&gt; 'removed: &lt;1p&gt; translations' 				expandMacrosWith: removed size)</body><body package="L10n-Models">writeAllCatalogsFrom: aList 	| s |	s := String new writeStream.	aList do: 			[:each | 			s				nextPutAll: each;				space].	^s contents</body><body package="L10n-Models">writeTBX: messages	Notice		show: (#Exporting1pEntries &lt;&lt; #Localizer &gt;&gt; 'Exporting &lt;1p&gt; Entries'				expandMacrosWith: messages size)		while: [TBXWriter store: messages toFile: self savepath]</body><body package="L10n-Models">writeTMX: messages	Notice		show: (#Exporting1pEntries &lt;&lt; #Localizer &gt;&gt; 'Exporting &lt;1p&gt; Entries'				expandMacrosWith: messages size)		while: [TMXWriter store: messages toFile: self savepath]</body></methods><methods><class-id>L10n.Exporter class</class-id> <category>instance creation</category><body package="L10n-Models">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Refactory.Browser.L10nMessagesNavigatorPart</class-id> <category>private</category><body package="L10n-RBSupport">selectDefinitions: aNavigatorState 	self select: Array new</body><body package="L10n-RBSupport">selectFirst	"select the previous userMessage"	| oldIndices newIndices |	oldIndices := #(2).	newIndices := (oldIndices collect: [:each | each - 1]) 				select: [:each | each between: 1 and: self list size].	self objectList selectionIndex: newIndices</body><body package="L10n-RBSupport">selectNext	"select the next userMessage"	| oldIndices newIndices |	oldIndices := self objectList selectionIndex asSortedCollection.	newIndices := (oldIndices collect: [:each | each + 1]) 				select: [:each | each between: 1 and: self list size].	newIndices isEmpty 		ifTrue: [self objectList selectionIndex: oldIndices]		ifFalse: 			[self objectList selectionIndex: newIndices.			self changed]</body><body package="L10n-RBSupport">selectPrevious	"select the previous userMessage"	| oldIndices newIndices |	oldIndices := self objectList selectionIndex asSortedCollection.	newIndices := (oldIndices collect: [:each | each - 1]) 				select: [:each | each between: 1 and: self list size].	newIndices isEmpty 		ifTrue: [self objectList selectionIndex: oldIndices]		ifFalse: 			[self objectList selectionIndex: newIndices.			self changed]</body><body package="L10n-RBSupport">updateWithState: aNavigatorState	self fillInListWith: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.L10nMessagesNavigatorPart</class-id> <category>updating widgets</category><body package="L10n-RBSupport">fillInListWith: aNavigatorState 	| newList |	newList := self fillInListFor: aNavigatorState.	self list == newList ifFalse: [self updateListWith: newList]</body><body package="L10n-RBSupport">fillInStateBasedOnSelection: aNavigatorState 	^self.</body><body package="L10n-RBSupport">selectState: aNavigatorState 	self fillInListWith: aNavigatorState.	self selectDefinitions: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.L10nMessagesNavigatorPart</class-id> <category>menus</category><body package="L10n-RBSupport">defaultMenu	^Menu new.</body></methods><methods><class-id>Refactory.Browser.L10nMessagesNavigatorPart</class-id> <category>accessing-navigator</category><body package="L10n-RBSupport">fillInListFor: aNavigatorState 	| defs messages |	aNavigatorState selector ifNil:[^Array new].	messages := L10n.Localisator default 				getMessagesForMethod: aNavigatorState definition method				catalog: nil				sourceLang: L10n.L10nSettings default lastSource				targetLang: L10n.L10nSettings default lastTarget.	defs := messages.	(defs size = self list size and: [defs size &gt; 100]) ifTrue: [^self list].	"Optimization hack -- sorting the defs is really slow."	^defs</body><body package="L10n-RBSupport">fillInState: aNavigatorState 	^self.</body></methods><methods><class-id>Refactory.Browser.L10nMessagesNavigatorPart</class-id> <category>changing</category><body package="L10n-RBSupport">changed	self navigator l10n userMessageChangedWith: self selection.</body></methods><methods><class-id>Refactory.Browser.L10nMessagesNavigatorPart class</class-id> <category>private</category><body package="L10n-RBSupport">showIcons	^false</body></methods><methods><class-id>LangSpecConverter class</class-id> <category>converting</category><body package="L10n-TMX">convertFromRfc3066: aLangSpec 	"	self convertFromRfc3066:'EN-US'	"	| stream rStream |	aLangSpec = 'EN-US' ifTrue: [^'C'].	stream := String new writeStream.	rStream := aLangSpec readStream.	stream nextPutAll: (rStream upTo: $-) asLowercase. 	rStream atEnd 		ifFalse: 			[stream				nextPut: $_;				nextPutAll: rStream upToEnd].	^stream contents</body><body package="L10n-TMX">convertToRfc3066: aLangSpec	"	self convertToRfc3066:'de_DE'	self convertToRfc3066:'de'	"	| string |	string := aLangSpec asUppercase.	string = 'C' ifTrue: [^'EN-US'].	string countryCode asUppercase = 'NONE'		ifTrue: 			[^string languageCode , '-' , (self defaultCountryFor: string languageCode)].	^string languageCode , '-' , string countryCode</body><body package="L10n-TMX">defaultCountryFor: aString	aString = 'EN' ifTrue: [^'US'].	^aString</body></methods><methods><class-id>L10n.DataSetAutoresizeWrapper</class-id> <category>updating</category><body package="L10n-UI">isChangingBoundsWhile: aBlock	"i am a dependent on the widthHolders of the ColumnDescriptors.	The reason is that i need to be informed when the columns are manually resized.	In that case the size of a column is set to a fixed amount.	To not be confused with value-changes that are initiated by myself, the instVar &lt;isChangingBounds&gt; was introduced.	While this variable is true, the changes to the width-Holders are ignored, because they are initiated by myself"		isChangingBounds := true.	aBlock ensure: [isChangingBounds := false]</body><body package="L10n-UI">update: aspect with: parameter from: sender	| index newSpec |	index := component columnDescriptors				findFirst: [:each | each widthHolder == sender].	(isChangingBounds or: [index = 0])		ifTrue: [^super update: aspect with: parameter from: sender].	newSpec := resizeSpec copy.	newSpec at: index put: sender value.	self resizeSpec: newSpec.	self adjustColumnsToBounds: self bounds</body></methods><methods><class-id>L10n.DataSetAutoresizeWrapper</class-id> <category>ScrollWrapper-interface</category><body package="L10n-UI">scrollBy: anObject	^container scrollBy: anObject</body><body package="L10n-UI">scrollOffset	^container scrollOffset</body><body package="L10n-UI">visibleExtent	^container visibleExtent</body></methods><methods><class-id>L10n.DataSetAutoresizeWrapper</class-id> <category>accessing</category><body package="L10n-UI">sizeSpecAt: columnIndex for: columnDescription	(columnIndex between: 1 and: resizeSpec size)		ifFalse: [^columnDescription width].	^resizeSpec at: columnIndex</body></methods><methods><class-id>L10n.DataSetAutoresizeWrapper</class-id> <category>initialize-release</category><body package="L10n-UI">resizeSpec: anArray	resizeSpec := anArray.	numVariants := (anArray select: #isZero) size.	minWidth := anArray inject: 0 into: [:all :each | all + each]</body></methods><methods><class-id>L10n.DataSetAutoresizeWrapper</class-id> <category>private</category><body package="L10n-UI">setComponent: aVisualComponent	"Set aVisualComponent to be the the receiver's component.	Set aVisualComponent's container to be the receiver."	component notNil		ifTrue: 			[component columnDescriptors				do: [:each | each widthHolder removeDependent: self]].	super setComponent: aVisualComponent.	component notNil		ifTrue: 			[component columnDescriptors				do: [:each | each widthHolder addDependent: self]]</body></methods><methods><class-id>L10n.DataSetAutoresizeWrapper</class-id> <category>DataSetView-interface</category><body package="L10n-UI">hScrollBounds	"this method is necessary because it is sent by the DataSetScrollWrapper, which assumes a DataSet as its component"	^component hScrollBounds</body><body package="L10n-UI">vScrollBounds	"this method is necessary because it is sent by the DataSetScrollWrapper, which assumes a DataSet as its component"	^component vScrollBounds</body></methods><methods><class-id>L10n.DataSetAutoresizeWrapper</class-id> <category>bounds accessing</category><body package="L10n-UI">adjustColumnsToBounds: newBounds	| newWidth variantWidth |	self isChangingBoundsWhile: 			[variantWidth := newBounds width - minWidth.			component columnDescriptors doWithIndex: 					[:each :index |					newWidth := self sizeSpecAt: index for: each.					newWidth = 0 ifTrue: [newWidth := (variantWidth / numVariants) rounded].					each width: newWidth].			component computeStarts]</body><body package="L10n-UI">bounds: newBounds	"Set the components bounds based on newBounds extent."	super bounds: newBounds.	self adjustColumnsToBounds: newBounds</body></methods><methods><class-id>L10n.DataSetAutoresizeWrapper class</class-id> <category>instance creation</category><body package="L10n-UI">autoResizeColumnsIn: widget usingSpec: anArray	| scrollWrapper resizeWrapper |	scrollWrapper := widget parent.	resizeWrapper := self on: widget.	resizeWrapper resizeSpec: anArray.	scrollWrapper setComponent: resizeWrapper</body><body package="L10n-UI">wrap: widget	| scrollWrapper resizeWrapper |	scrollWrapper := widget parent.	resizeWrapper := self on: widget.	scrollWrapper setComponent: resizeWrapper</body></methods><methods><class-id>L10n.ExportUI</class-id> <category>aspects</category><body package="L10n-UI">AvailableCatalogs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AvailableCatalogs isNil 		ifTrue: [AvailableCatalogs := List new asValue]		ifFalse: [AvailableCatalogs]</body><body package="L10n-UI">AvailableCatalogs: anObject 	^AvailableCatalogs := anObject</body><body package="L10n-UI">AvailableDateHandles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^AvailableDateHandles isNil 		ifTrue: [AvailableDateHandles :=List new asValue]		ifFalse: [AvailableDateHandles]</body><body package="L10n-UI">AvailableDateHandles: anObject 	^AvailableDateHandles := anObject</body><body package="L10n-UI">Catalog	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Catalog isNil		ifTrue:			[Catalog := String new asValue]		ifFalse:			[Catalog]</body><body package="L10n-UI">Catalog: anObject 	Catalog := anObject</body><body package="L10n-UI">CatalogChoices	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^CatalogChoices isNil		ifTrue:			[CatalogChoices := String new asValue]		ifFalse:			[CatalogChoices]</body><body package="L10n-UI">CatalogChoices: anObject 	^CatalogChoices := anObject</body><body package="L10n-UI">Date	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^Date isNil		ifTrue:			[Date := String new asValue]		ifFalse:			[Date]</body><body package="L10n-UI">Date: anObject 	Date := anObject</body><body package="L10n-UI">DateHandling	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^DateHandling isNil		ifTrue:			[DateHandling := String new asValue]		ifFalse:			[DateHandling]</body><body package="L10n-UI">DateHandling: anObject 	^DateHandling := anObject</body><body package="L10n-UI">ErrorText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^ErrorText isNil		ifTrue:			[ErrorText := String new asValue]		ifFalse:			[ErrorText]</body><body package="L10n-UI">ErrorText: anObject 	^ErrorText := anObject</body><body package="L10n-UI">FileFormats	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^FileFormats isNil		ifTrue:			[FileFormats := #(#TMX #TBX) asValue]		ifFalse:			[FileFormats]</body><body package="L10n-UI">FileFormats: anObject	^FileFormats := anObject</body><body package="L10n-UI">SavePath	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^savePath isNil 		ifTrue: [savePath := String new asValue]		ifFalse: [savePath]</body><body package="L10n-UI">SavePath: anObject	^savePath := anObject</body><body package="L10n-UI">ShowPath	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^ShowPath isNil		ifTrue:			[ShowPath := String new asValue]		ifFalse:			[ShowPath]</body><body package="L10n-UI">fileFormat	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^FileFormat isNil 		ifTrue: [FileFormat := self FileFormats value first asValue]		ifFalse: [FileFormat]</body><body package="L10n-UI">fileFormat: anObject	FileFormat:= anObject.</body><body package="L10n-UI">translations	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^translations isNil		ifTrue:			[translations := nil asValue]		ifFalse:			[translations]</body><body package="L10n-UI">translations: anObject 	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^translations := anObject</body></methods><methods><class-id>L10n.ExportUI</class-id> <category>private</category><body package="L10n-UI">initializeAspectAdaptor: aspect 	| adaptor |	adaptor := AspectAdaptor subject: model.	adaptor forAspect: aspect asLowercase asSymbol.	adaptor subjectSendsUpdates: true.	self perform: (aspect , ':') asSymbol with: adaptor</body><body package="L10n-UI">initializeAspectAdaptors	#(#fileFormat #FileFormats #Catalog #CatalogChoices #Date #DateHandling #AvailableCatalogs #AvailableDateHandles #translations #SavePath #ErrorText #CloseMe) 		do: [:aspect | self initializeAspectAdaptor: aspect]</body></methods><methods><class-id>L10n.ExportUI</class-id> <category>accessing</category><body package="L10n-UI">model	^model</body><body package="L10n-UI">model: anObject	model := anObject</body></methods><methods><class-id>L10n.ExportUI</class-id> <category>actions</category><body package="L10n-UI">BrowsePath	"This stub method was generated by UIDefiner"	^self model browsePath.</body><body package="L10n-UI">Close	self model removeAllActionsWithReceiver: self.	self closeAndUnschedule</body><body package="L10n-UI">CloseMe	^nil</body><body package="L10n-UI">CloseMe: anObject	^nil</body><body package="L10n-UI">StartExport	"This stub method was generated by UIDefiner"	^self model startExport</body><body package="L10n-UI">allCatalogs	self model allCatalogs</body></methods><methods><class-id>L10n.ExportUI</class-id> <category>initialize-release</category><body package="L10n-UI">initialize	self model: Exporter new.	self model when: #CloseMe send: #Close to: self.	self initializeAspectAdaptors</body><body package="L10n-UI">postOpenWith: aBuilder 	super postOpenWith: aBuilder.</body></methods><methods><class-id>L10n.UnloadCatalogsUI</class-id> <category>actions</category><body package="L10n-UI">AllCatalogs	"This stub method was generated by UIDefiner"	^self model tmAllCatalogs</body><body package="L10n-UI">Cancel	"This stub method was generated by UIDefiner"	^self Close</body><body package="L10n-UI">StartUnload	"This stub method was generated by UIDefiner"	self model startUnload.	self Cancel</body></methods><methods><class-id>L10n.UnloadCatalogsUI</class-id> <category>aspects</category><body package="L10n-UI">TMAvailableCatalogs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^TMAvailableCatalogs isNil		ifTrue:			[TMAvailableCatalogs := List new asValue]		ifFalse:			[TMAvailableCatalogs]</body><body package="L10n-UI">TMAvailableCatalogs: anObject 	TMAvailableCatalogs := anObject</body><body package="L10n-UI">TMCatalog	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^TMCatalog isNil		ifTrue:			[TMCatalog := String new asValue]		ifFalse:			[TMCatalog]</body><body package="L10n-UI">TMCatalog: anObject 	TMCatalog := anObject</body><body package="L10n-UI">TMCatalogChoices	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^TMCatalogChoices isNil		ifTrue:			[TMCatalogChoices := String new asValue]		ifFalse:			[TMCatalogChoices]</body><body package="L10n-UI">TMCatalogChoices: anObject 	TMCatalogChoices := anObject</body></methods><methods><class-id>L10n.UnloadCatalogsUI</class-id> <category>initialize-release</category><body package="L10n-UI">initializeAspectAdaptors	#(#TMCatalog #TMCatalogChoices #TMAvailableCatalogs) 		do: [:aspect | self initializeAspectAdaptor: aspect]</body></methods><methods><class-id>L10n.UnloadCatalogsUI class</class-id> <category>interface specs</category><body package="L10n-UI">open	UserMessageTranslationMemory default resetAllCatalogs.	UserMessageTranslationMemory default allCatalogs isEmpty 		ifFalse: [super open]		ifTrue: [Dialog warn: (#Therearenocatalogstounload &lt;&lt; #Localizer &gt;&gt; 'There are no catalogs to unload')]</body></methods><methods><class-id>L10n.XMLExporter</class-id> <category>exporting</category><body package="L10n-TMX">asXML7bit: aString 	"removes all standard ascii characters from aString as well as non XML characters (e.g: Character 	value: 11)"	| aStream high7 |	aString isNil ifTrue: [^nil].	aStream := WriteStream on: (String new: self size * 2).	high7 := Character value: 127.	aString do: 			[:c | 			(c &gt; high7 or: ['&lt;&gt;&amp;' includes: c]) 				ifTrue: 					[aStream						nextPutAll: '&amp;#';						print: c asInteger;						nextPut: $;]				ifFalse: 					[(XML.CharacterClasses at: c asInteger + 1) &gt; 0 ifTrue: [aStream nextPut: c]]].	^aStream contents</body><body package="L10n-TMX">close	self stream close</body><body package="L10n-TMX">convertObject: each	^self objectClass from: each</body><body package="L10n-TMX">convertObjects: aCollection	^(aCollection collect: [:each | self convertObject: each]) select: [:each | each isExportable]</body><body package="L10n-TMX">footerString	self subclassResponsibility</body><body package="L10n-TMX">headerString	self subclassResponsibility</body><body package="L10n-TMX">objectClass	self subclassResponsibility</body><body package="L10n-TMX">storeBody	ResetIncrementNotification raiseSignal: self objects size.	self objects do: 			[:each |			self storeObject: each.			IncrementNotification raiseSignal]</body><body package="L10n-TMX">storeFooter	self stream nextPutAll: self footerString</body><body package="L10n-TMX">storeHeader	self stream nextPutAll: self headerString</body><body package="L10n-TMX">storeObject: anObject	anObject asXMLElement printOn: self stream</body><body package="L10n-TMX">storeObjects: aCollection	self objects: (self convertObjects: aCollection).	self storeHeader.	self storeBody.	self storeFooter</body></methods><methods><class-id>L10n.XMLExporter</class-id> <category>accessing</category><body package="L10n-TMX">objects	^objects</body><body package="L10n-TMX">objects: anObject	objects := anObject</body><body package="L10n-TMX">stream	^stream</body><body package="L10n-TMX">stream: anObject	stream := anObject</body></methods><methods><class-id>L10n.XMLExporter</class-id> <category>initialize-release</category><body package="L10n-TMX">initialize	stream := String new writeStream.	objects := #()</body></methods><methods><class-id>L10n.XMLExporter class</class-id> <category>tmx</category><body package="L10n-TMX">storeAllEntriesOn:aStream	self subclassResponsibility</body><body package="L10n-TMX">storeBodyOn: out	self subclassResponsibility</body><body package="L10n-TMX">storeFooterOn: out	self subclassResponsibility</body><body package="L10n-TMX">storeHeaderOn: aStream	self subclassResponsibility</body><body package="L10n-TMX">storeToFile: aFilename 	"creates a XML file and writes everything to it."	| out |	out := (aFilename asFilename withEncoding: #utf8WithBOM) writeStream.		[self storeHeaderOn: out.	self storeBodyOn: out.	self storeFooterOn: out] 			ensure: [out close]</body></methods><methods><class-id>L10n.XMLExporter class</class-id> <category>private</category><body package="L10n-TMX">langAttribute	self subclassResponsibility</body></methods><methods><class-id>L10n.XMLExporter class</class-id> <category>utility</category><body package="L10n-TMX">asXML7bit: aString 	"removes all standard ascii characters from aString as well as non XML characters (e.g: Character 	value: 11)"	| stream high7 |	aString isNil ifTrue: [^nil].	stream := WriteStream on: (String new: self size * 2).	high7 := Character value: 127.	aString do: 			[:c | 			(c &gt; high7 or: ['&lt;&gt;&amp;' includes: c]) 				ifTrue: 					[stream						nextPutAll: '&amp;#';						print: c asInteger;						nextPut: $;]				ifFalse: 					[(XML.CharacterClasses at: c asInteger + 1) &gt; 0 ifTrue: [stream nextPut: c]]].	^stream contents</body><body package="L10n-TMX">on: aStream	^(self new)		stream: aStream;		yourself</body><body package="L10n-TMX">store: objects toFile: aFilename	| exporter |		[exporter := self on: (aFilename asFilename withEncoding: #utf8WithBOM) writeStream.	exporter storeObjects: objects]			ensure: [exporter close]</body></methods><methods><class-id>L10n.TMXWriter</class-id> <category>accessing</category><body package="L10n-TMX">footerString	^'	&lt;/body&gt;&lt;/tmx&gt;'</body><body package="L10n-TMX">headerString	^'%&lt;?xml version="1.0"?&gt;	%&lt;tmx version="1.4"&gt;   		%&lt;header creationtool="L10n" creationtoolversion="0.101" datatype="HTML" o-tmf="L10n" segtype="sentence" adminlang="EN-US" srclang="&lt;2s&gt;" o-encoding="utf-8"&gt;			%&lt;prop type="x-tmx-size"&gt;&lt;1p&gt;%&lt;/prop&gt;   		%&lt;/header&gt;		%&lt;body&gt;' expandMacrosWith: self objects size with: self sourceLanguage</body><body package="L10n-TMX">objectClass	^L10nTMXObject</body><body package="L10n-TMX">sourceLanguage	| default languages sourceLanguage |	default := 'EN-US'.	languages := (self objects collect: #srcLang) asBag contents associations				sort: [:a :b | a value &lt; b value].	languages isEmpty ifTrue: [^default].	sourceLanguage := languages first key.	sourceLanguage asSymbol = #C ifTrue: [^default].	^sourceLanguage</body></methods><methods><class-id>L10n.LookUpDictionary</class-id> <category>accessing</category><body package="L10n-Base">addEntryFrom: fromArray to: toArray using: anUrlString withName: aName 	"this method adds a new dictionary to the dataMD. the new dictionary is discribed by an array of languages it can translate from (fromArray)	an array of languages it can translate to (toArray), a basic url with placeholders for at least the term to translate and a name which is displayed to represent the dictionary"	| d |	(fromArray isNil or: [fromArray isEmpty]) ifTrue: [^nil].	(toArray isNil or: [toArray isEmpty]) ifTrue: [^nil].	(anUrlString isNil or: [anUrlString isEmpty]) ifTrue: [^nil].	(aName isNil or: [aName isEmpty]) ifTrue: [^nil].	d := Dictionary new.	d at: #from put: (fromArray collect: [:each | each asSymbol]).	d at: #to put: (toArray collect: [:each | each asSymbol]).	d at: #name put: aName.	self data at: d put: anUrlString</body><body package="L10n-Base">dictionariesForCurrentLanguages	"	returns the names of the dictionaries that support the current language	LookUpDictionary default dictionariesForCurrentLanguages	"	^self 		dictionariesForTranslationsFrom: (L10nSettings default lastSource 				languageCode = 'C' 				ifTrue: ['en']				ifFalse: [L10nSettings default lastSource languageCode])		into: L10nSettings default lastTarget languageCode</body><body package="L10n-Base">dictionariesForTranslationsFrom: sLang into: tLang 	"	returns the names of each dictionary that can translate from sLang into tLang	"	| d |	d := Dictionary new.	d at: #from put: [:each | each includes: sLang asSymbol].	d at: #to put: [:each | each includes: tLang asSymbol].	^(self data at: d ifAbsent: [Array new]) 		collect: [:each | each key at: #name]</body><body package="L10n-Base">urlForTerm: aTerm inDictionary: aName 	"returns the url for the dictionary named aName for the current language settings and for translating aTerm"	^self 		urlForTerm: aTerm		inDictionary: aName		from: (L10nSettings default lastSource languageCode = 'C' 				ifTrue: ['en']				ifFalse: [L10nSettings default lastSource languageCode])		to: L10nSettings default lastTarget languageCode</body><body package="L10n-Base">urlForTerm: aTerm inDictionary: aName from: sLang to: tLang 	"returns the url for translating aTerm with a dictionary named aName from language sLang into tLang"	| d |	d := Dictionary new.	d at: #name put: aName.	^(self data at: d ifAbsent: [^String new]) first value 		expandMacrosWith: aTerm		with: sLang		with: tLang</body></methods><methods><class-id>L10n.LookUpDictionary</class-id> <category>initialize-release</category><body package="L10n-Base">initialize	"this method adds dictionaries to the self"	self 		addEntryFrom: #(#en)		to: #(#de)		using: 'http://dict.tu-chemnitz.de/dings.cgi?noframes=0&amp;query=&lt;1s&gt;'		withName: 'TU-Chemnitz'.	self 		addEntryFrom: #(#en)		to: #(#de)		using: 'http://dict.leo.org/&lt;2s&gt;&lt;3s&gt;?search=&lt;1s&gt;'		withName: 'Leo'.	self 		addEntryFrom: #(#en)		to: #('sq' 'ar' 'bg' 'cs' 'nl' 'et' 'fr' 'de' 'el' 'hu' 'it' 'ko' 'lv' 'fa' 'pl' 'pt' 'ro' 'ru' 'sh' 'sk' 'es' 'sv' 'tr' 'ji')		using: 'http://www.ectaco.com/main.jsp;?do=e-services-dictionaries-word_translate1&amp;status=translate&amp;lang1=23&amp;source=&lt;1s&gt;&amp;lang2=&lt;3s&gt;'		withName: 'Ectaco'</body></methods><methods><class-id>L10n.LookUpDictionary</class-id> <category>private</category><body package="L10n-Base">data	^dataMD ifNil: [dataMD := Heeg.MultiDictionary new]</body></methods><methods><class-id>L10n.LookUpDictionary class</class-id> <category>singleton</category><body package="L10n-Base">default	^Lud ifNil: [Lud := self new]</body></methods><methods><class-id>L10n.LookUpDictionary class</class-id> <category>instance creation</category><body package="L10n-Base">new	^super new initialize</body></methods><methods><class-id>L10n.TerminologyController</class-id> <category>accessing</category><body package="L10n-Base">allDatesForTerm: aString 	"returns all terms that have an original value of aString"	| d entry |	d := Dictionary new.	d at: #original put: [:s | s = aString].	entry := self data at: d				ifAbsent: 					[OrderedCollection 						with: (Dictionary withAll: (Array with: #original -&gt; aString)) 								-&gt; Dictionary new].	^entry</body><body package="L10n-Base">allTerms	"returns all original values of the terms"	^self data collection collect: [:each | each key at: #original]</body><body package="L10n-Base">allTermsContaining: aString 	"returns all original values that contain aString"	| d queryString |	self checkMultiDictionaryVersion.	d := Dictionary new.	queryString := '*' , aString , '*'.	d at: #original put: [:aSource | queryString match: aSource].	^(self data at: d ifAbsent: [OrderedCollection new]) 		collect: [:each | each key at: #original]</body><body package="L10n-Base">checkMultiDictionaryVersion	"	this is a test for the MultiDictionary version installed, as there's a bug in the MultiDictionary prior to version 2.10 where discriminator keys could not be queried as blocks.	TerminologyController default checkMultiDictionaryVersion	"	| m d q worked |	m := Heeg.DiscriminatedMultiDictionary discriminator: #disc identity: true.	d := Dictionary new.	q := Dictionary new.	d at: #disc put: 4.	m at: d put: 1.	worked := false.	q at: #disc		put: 			[:anItem | 			worked := true.			anItem = 4].	m at: q ifAbsent: [nil].	worked 		ifFalse: 			[Dialog warn: #multiDictionaryPackageToOld &lt;&lt; #Localizer 						&gt;&gt; 'You use an older version of MultiDictionary, please load the new package (at least version 2.10)!'].	^worked</body><body package="L10n-Base">data	"returns the dataMD"	^dataMD ifNil: 			[dataMD := Heeg.DiscriminatedMultiDictionary discriminator: #original						identity: false]</body><body package="L10n-Base">excludeList	"returns the excludeList"	^excludeList ifNil: [excludeList := Set new]</body><body package="L10n-Base">excludeList: aList 	"sets the excludelist"	excludeList := Set withAll: aList</body><body package="L10n-Base">excludeTerm: aString 	"adds aString to the excludeList"	aString isEmpty ifFalse: [excludeList add: aString].	^aString</body><body package="L10n-Base">removeDictionary: aDict 	"removes all terms that match aDict"	^self data remove: aDict ifAbsent: [nil]</body><body package="L10n-Base">tableRowForTerm: aString 	"returns the term with aString as original value as an OrderedCollection sorted by the values of tableheaders"	| d entry res |	d := Dictionary new.	d at: #original put: aString.	entry := (self data at: d) first.	res := OrderedCollection new.	1 to: self tableHeaders size		do: [:i | res add: (entry key at: (self tableHeaders at: i))].	^res</body></methods><methods><class-id>L10n.TerminologyController</class-id> <category>importing</category><body package="L10n-Base">addDataFromEntry: aTerminologyEntry 	"adds aTerminologyEntry to the current dataMD"	^self data at: aTerminologyEntry asDictionary put: Dictionary new</body><body package="L10n-Base">expandDuplicateSources	"TBX files can have multiple source strings in the entries. This is not supported by this version of Terminilogymanager.	Thus these entries must be copied."	self data collection copy do: 			[:each |			| sourceCollection |			sourceCollection := each key at: #original.			sourceCollection isSymbol				ifFalse: 					[each key at: #original put: sourceCollection first.					2 to: sourceCollection size						do: 							[:i |							| copy |							copy := each key copy.							copy at: #original put: (sourceCollection at: i).							self data collection add: copy -&gt; each value copy]]].	self data resort</body><body package="L10n-Base">exportExcludeListToTXT	"	saves the excludelist as a textfile	TerminologyController default exportExcludeListToTXT	"	| path stream |	path := Dialog 				requestNewFileName: #PleaseSelectACommaSeparatedFile &lt;&lt; #Localizer 						&gt;&gt; 'Please select a comma or Tab-seperated Text-File'				default: 'ExcludedTerms.txt'.	path isEmpty 		ifFalse: 			[stream := (path asFilename withEncoding: #UTF8) writeStream.						[self excludeList asSortedCollection do: 					[:each | 					stream						nextPutAll: each;						cr]] 					ensure: [stream close]]</body><body package="L10n-Base">exportTBX	"	exports the terms as tbx file	TerminologyController default exportTBX	"	| path |	path := Dialog				requestNewFileName: #PleaseSelectACommaSeparatedFile &lt;&lt; #Localizer						&gt;&gt; 'Please select a comma or Tab-seperated Text-File'				default: 'terms.tbx'.	(path isNil or: [path isEmpty])		ifFalse: 			[TBXWriter store: (self data collect: [:each | each key]) toFile: path]</body><body package="L10n-Base">exportTXT	"	This method should export the terms as csv file, but csv is not working atm.	TerminologyController default exportTXT	"	| path |	path := Dialog 				requestNewFileName: #PleaseSelectACommaSeparatedFile &lt;&lt; #Localizer 						&gt;&gt; 'Please select a comma or Tab-seperated Text-File'				default: 'terms.txt'.	path isNil 		ifFalse: 			[self 				exportToTXT: path				data: (self data collect: [:each | each key])				types: ((Array new: self tableHeaders size) atAllPut: String)				writeBlock: 					[:aRow :aWriter | 					self tableHeaders 						do: [:aKey | aWriter nextPut: (String withAll: (aRow at: aKey))]]				headers: self tableHeaders]</body><body package="L10n-Base">exportToTXT: aFileName data: anOrderedCollection types: types writeBlock: writeLineBlock headers: headers 	"this method exports anOrderedCollection into a textfile named aFileName. it uses the CSVwriter and types are the types of each column. headers are the headers of each column. To write each line the 	writeLineBlock is used which gets the arguments: eachRow (an element form anOrderedCollection and writer (the CSVWriter to write on)	this method may not work, as CSV is currently not working correctly	"	| file outStream writer |	SystemChecker isCSVAvailable 		ifFalse: [SystemChecker loadGlossaryParcels ifFalse: [^nil]].	aFileName isEmpty ifTrue: [^nil].	file := LogicalFilename named: aFileName.	outStream := (file withEncoding: #UTF8) writeStream.		[writer := Heeg.CsvWriter new on: outStream.	writer separators: ';,.' types: types.	writer nextPutHeadings: headers.	Notice show: (#adding1pObjects &lt;&lt; #Localizer &gt;&gt; 'adding &lt;1p&gt; objects' 				expandMacrosWith: anOrderedCollection size printString)		while: 			[anOrderedCollection do: 					[:eachRow | 					writeLineBlock value: eachRow value: writer.					writer nextLine]]] 			ensure: [outStream close]</body><body package="L10n-Base">importExcludeListFromTXT	"	loads the excludelist from a file.	TerminologyController default importExcludeListFromTXT	"	| path stream |	path := Dialog 				requestFileNameWithMessage: #open &lt;&lt; #Localizer &gt;&gt; 'Open'				default: '*.txt'				version: #mustBeOld				ifFail: ['']				for: nil.	path isEmpty 		ifFalse: 			[stream := (path asFilename withEncoding: #UTF8) readStream.			[[stream atEnd] whileFalse: [self excludeTerm: stream upToSeparator]] 				ensure: [stream close].			^true].	^false</body><body package="L10n-Base">importFromTXT: aFileName using: aBlock class: aClass 	"this method reads a CSV file named aFilename. it uses aBlock to read each line and creates entries as instances of aClass"	| file anOrderedCollection reader |	SystemChecker isCSVAvailable 		ifFalse: [SystemChecker loadGlossaryParcels ifFalse: [^nil]].	aFileName isEmpty ifTrue: [^nil].	file := LogicalFilename named: aFileName.	file exists 		ifTrue: 			[anOrderedCollection := OrderedCollection new.			reader := Heeg.CsvFileReader new.			reader fileEntryClass: aClass.			reader importFrom: aFileName.			anOrderedCollection := reader entries.			Notice show: (#adding1pObjects &lt;&lt; #Localizer &gt;&gt; 'adding &lt;1p&gt; objects' 						expandMacrosWith: anOrderedCollection size)				while: [aBlock value: anOrderedCollection]]		ifFalse: 			[Dialog warn: #FileNotFound &lt;&lt; #Localizer &gt;&gt; 'File not found: ' , aFileName]</body><body package="L10n-Base">importTBXandDeleteOld: deleteOld	"	this loads a tbx file with terms and deletes the old terms depending on deleteOld	TerminologyController default importTBX	"	| path |	path := Dialog				requestFileNameWithMessage: #open &lt;&lt; #Localizer &gt;&gt; 'Open'				default: '*.tbx'				version: #mustBeOld				ifFail: ['']				for: nil.	path isEmpty		ifFalse: 			[deleteOld ifTrue: [self privEmptyTerminology].			XMLImporter				fromFile: path				using: L10nTBXSoxDriver				notice: #importingTBX &lt;&lt; #Localizer &gt;&gt; 'importing TBX'.			self expandDuplicateSources.				^true].	^false</body><body package="L10n-Base">importTXT	"	this method should import a CSV file with terms. this is currently not working as CSV does not work	TerminologyController default importTXT	"	| path |	path := Dialog 				requestFileNameWithMessage: #open &lt;&lt; #Localizer &gt;&gt; 'Open'				default: '*.txt'				version: #mustBeOld				ifFail: ['']				for: nil.	path isNil 		ifFalse: 			[self 				importFromTXT: path				using: [:aCollection | aCollection do: [:eachRow | self addDataFromEntry: eachRow]]				class: TerminologyEntry]</body><body package="L10n-Base">tableHeaders	"when importing a CSV file, this file must have this header!!"	^#(#original #translation #synonym #notes #source #valid)</body></methods><methods><class-id>L10n.TerminologyController</class-id> <category>private</category><body package="L10n-Base">emptyTerminology	"empties the dataMD"	(Dialog confirm: (#confirmEmptyTerminology &lt;&lt; #Localizer &gt;&gt; 'Are you sure you want to empty the Terminology?')) 		ifFalse: [^nil].	^self privEmptyTerminology</body><body package="L10n-Base">privEmptyTerminology	"removes all terms from the dataMD"	^self removeDictionary: Dictionary new</body><body package="L10n-Base">rebuildData	"when an edit is performed, the indices of the discriminated multidictionary may not be correct anymore, so rebuild it"	^dataMD resort.</body><body package="L10n-Base">removeTermEntry: aTermEntry 	"removes aTermEntry from the DataMD"	^self removeDictionary: aTermEntry asDictionary</body></methods><methods><class-id>L10n.TerminologyController</class-id> <category>testing</category><body package="L10n-Base">isATerm: aString 	"returns if there's a term with aString as original value"	| d |	d := Dictionary new.	d at: #original put: [:anOriginal | anOriginal = aString].	^(self data at: d ifAbsent: [OrderedCollection new]) isEmpty not</body></methods><methods><class-id>L10n.TerminologyController class</class-id> <category>initialize-release</category><body package="L10n-Base">new	^super new</body></methods><methods><class-id>L10n.TerminologyController class</class-id> <category>accessing</category><body package="L10n-Base">default	^TC ifNil: [TC := self new]</body></methods><methods><class-id>L10n.UserMessageListEntry</class-id> <category>accessing</category><body package="L10n-Base-Data">defaultString	^defaultString</body><body package="L10n-Base-Data">defaultString: anObject 	"filter diffrent methods"	defaultString := anObject</body><body package="L10n-Base-Data">key	^key</body><body package="L10n-Base-Data">key: anObject	key := anObject</body><body package="L10n-Base-Data">translated	^translated</body><body package="L10n-Base-Data">translated: anObject	translated := anObject</body></methods><methods><class-id>L10n.UserMessageListEntry</class-id> <category>printing</category><body package="L10n-Base-Data">asString	^self displayString asString.</body><body package="L10n-Base-Data">asText	^self displayString.</body><body package="L10n-Base-Data">displayString	| t |	t := TextStream on: String new.	self translated not		ifTrue: [t nextPutAllText: self key asText allBold]		ifFalse: [t nextPutAllText: self key asText allItalic].	t nextPutAll: ': '.	t nextPutAll: self nonNilDefaultString.	^t contents</body><body package="L10n-Base-Data">nonNilDefaultString	self defaultString do:[:each | each value notNil ifTrue:[^each value]].	^String new.</body><body package="L10n-Base-Data">printOn: aStream 	aStream		nextPutAll: self key;		nextPutAll: ': (';		nextPutAll: self defaultString size printString;		nextPutAll: ') ';		nextPutAll: self defaultString printString.</body></methods><methods><class-id>L10n.UserMessageListEntry</class-id> <category>comparing</category><body package="L10n-Base-Data">= anObject 	anObject class == self class 		ifFalse: [^false]		ifTrue: 			[^self key = anObject key and: 					[self translated = anObject translated]]</body><body package="L10n-Base-Data">hash	^self key hash + self translated hash</body></methods><methods><class-id>L10n.UserMessageTranslationMatchCollection</class-id> <category>accessing</category><body package="L10n-Base-Data">isOld	"if this translation is translated again then this translation is old and maybe wrong"	^isOld ifNil: 			["this is the default, unless it is set"			isOld := true]</body><body package="L10n-Base-Data">isOld: aBool	"if aBool is true, then this translation was translated again and is maybe not correct"	isOld := aBool.</body><body package="L10n-Base-Data">latest	| sorted |	latest isNil		ifTrue: 			[sorted := (1 to: self size)						sorted: [:each | (self at: each) version timeStamp] descending.			latest := sorted first].	^latest</body><body package="L10n-Base-Data">latestTranslation	"returns the latest tranxlation"	^self at: self latest</body><body package="L10n-Base-Data">matching	matching ifNil: [matching := self latestTranslation match].	^self isOld ifTrue: [matching - (L10nSettings default panaltyTargetOtherCountry*100) ] ifFalse: [matching]</body><body package="L10n-Base-Data">matching: anObject	matching := anObject</body><body package="L10n-Base-Data">timestamp	"returns the latest timestamp"	^self latestTranslation version timeStamp</body></methods><methods><class-id>L10n.UserMessageTranslationMatchCollection</class-id> <category>printing</category><body package="L10n-Base-Data">displayString	| t emphasis |	emphasis := nil.	self isOld		ifTrue: 			[emphasis := SystemChecker isColorFontAvailable						ifTrue: [#red]						ifFalse: [#bold]].	L10nSettings default showCatalogs		ifFalse: 			[^(self latestTranslation displayStringWithStyle: emphasis matching: self matching)				, ')' asIs].	t := TextStream on: String new.	t nextPutAllText: (self latestTranslation displayStringWithStyle: emphasis				matching: self matching).	self size = 1		ifTrue: [t nextPut: $)]		ifFalse: 			[self size = 2				ifTrue: 					[t						nextPutAll: (#andOneOtherCatalog &lt;&lt; #Localizer &gt;&gt; ' and one other catalog)')								asString]				ifFalse: 					[t						nextPutAll: (#andOtherCatalogs &lt;&lt; #Localizer &gt;&gt; ' and &lt;1p&gt; other catalogs)'								expandMacrosWith: self size - 1) asString]].	^t contents</body><body package="L10n-Base-Data">printOn: aStream 	aStream		print: self class;		space;		print: self size;		space;		nextPutAll: self first key;		space;		print: self matching;		nextPut: $%.	^aStream</body></methods><methods><class-id>L10n.UserMessageTranslationMatchCollection</class-id> <category>copying</category><body package="L10n-Base-Data">copyEmpty	^(super copyEmpty)		resetLatest;		yourself</body><body package="L10n-Base-Data">copyEmpty: size	^(super copyEmpty: size)		resetLatest;		yourself</body><body package="L10n-Base-Data">resetLatest	latest := nil</body></methods><methods><class-id>L10n.TranslationMemoryCatalog</class-id> <category>accessing</category><body package="L10n-MessageCatalogs">lookUp: aMessage	"	(self forLanguage: #de catalog: #browser) lookUp: #Accept &lt;&lt; #browser	"	| translationAssociations |	translationAssociations := self class translationProvider				getValuesForTranslationFromSource: #C country: #none toTarget: language languageCode country: language countryCode atKey: aMessage key atCatalog: catalogID version: nil.	translationAssociations do: [:association | ^association value].	^nil</body><body package="L10n-MessageCatalogs">priority	^50</body></methods><methods><class-id>L10n.TranslationMemoryCatalog class</class-id> <category>private</category><body package="L10n-MessageCatalogs">translationProvider	^UserMessageTranslationMemory default</body></methods><methods><class-id>L10n.UserMessageFullSpecifier</class-id> <category>accessing</category><body package="L10n-Base-Data">application	^langSpecifier application</body><body package="L10n-Base-Data">application: anApplicationSymbol 	^langSpecifier application: anApplicationSymbol</body><body package="L10n-Base-Data">catalog	^langSpecifier catalog</body><body package="L10n-Base-Data">catalog: aCatalogSymbol 	^langSpecifier catalog: aCatalogSymbol</body><body package="L10n-Base-Data">country	^langSpecifier culture</body><body package="L10n-Base-Data">country: aCountrySymbol 	^langSpecifier culture: aCountrySymbol</body><body package="L10n-Base-Data">key	^langSpecifier key</body><body package="L10n-Base-Data">key: aKeySymbol 	^langSpecifier key: aKeySymbol</body><body package="L10n-Base-Data">langSpecifier	^langSpecifier</body><body package="L10n-Base-Data">langSpecifier: anUserMessageLangSpecifier	langSpecifier := anUserMessageLangSpecifier</body><body package="L10n-Base-Data">language	^langSpecifier language</body><body package="L10n-Base-Data">language: aLanguageSymbol 	^langSpecifier language: aLanguageSymbol</body><body package="L10n-Base-Data">source	^version source</body><body package="L10n-Base-Data">source: aSourceSymbol 	^version source: aSourceSymbol</body><body package="L10n-Base-Data">specifier	^langSpecifier specifier</body><body package="L10n-Base-Data">specifier: anUserMessageSpecifier 	langSpecifier specifier: anUserMessageSpecifier</body><body package="L10n-Base-Data">timeStamp	^version timeStamp</body><body package="L10n-Base-Data">timeStamp: aTimeStamp 	^version timeStamp: aTimeStamp</body><body package="L10n-Base-Data">version	^version</body><body package="L10n-Base-Data">version: anUserMessageTranslationVersion	version := anUserMessageTranslationVersion</body></methods><methods><class-id>L10n.UserMessageFullSpecifier</class-id> <category>comparing</category><body package="L10n-Base-Data">= anUserMessagFullSpecifier 	^self langSpecifier = anUserMessagFullSpecifier langSpecifier 		and: [self version = anUserMessagFullSpecifier version]</body><body package="L10n-Base-Data">hash	^self langSpecifier hash + self version hash</body></methods><methods><class-id>L10n.UserMessageFullSpecifier</class-id> <category>printing</category><body package="L10n-Base-Data">printOn: aStream 	aStream nextPutAll: self langSpecifier printString.	aStream nextPut: $:.	aStream nextPutAll: self version printString.</body></methods><methods><class-id>L10n.UserMessageFullSpecifier</class-id> <category>initialize-release</category><body package="L10n-Base-Data">initialize	"Initialize a newly created instance. This method must answer the receiver."	langSpecifier := UserMessageLangSpecifier new.	version := UserMessageSpecifierVersion new.	^self</body></methods><methods><class-id>L10n.UserMessageFullSpecifier class</class-id> <category>instance creation</category><body package="L10n-Base-Data">new	^super new initialize</body></methods><methods><class-id>Refactory.Browser.L10nEnvironment</class-id> <category>accessing</category><body package="L10n-RBSupport">l10n	^l10n</body><body package="L10n-RBSupport">l10n: anObject 	l10n := anObject</body><body package="L10n-RBSupport">navigatorClass	^L10nNavigator</body></methods><methods><class-id>Refactory.Browser.L10nEnvironment class</class-id> <category>instance creation</category><body package="L10n-RBSupport">onMethods: methods from: aSender	| env |	env := super onMethods: methods.	env l10n: aSender.	^env.</body></methods><methods><class-id>TBXLangSet</class-id> <category>printing</category><body package="L10n-TMX">language	^language</body><body package="L10n-TMX">printOn: aStream	aStream		nextPutAll: 'Language: ';		nextPutAll: language;		cr.	terms do: 			[:each |			each printOn: aStream.			aStream cr]</body></methods><methods><class-id>TBXLangSet</class-id> <category>initialize-release</category><body package="L10n-TMX">setLanguage: languageName terms: tigs	language := languageName.	terms := tigs</body></methods><methods><class-id>TBXLangSet class</class-id> <category>instance creation</category><body package="L10n-TMX">fromXMLElement: anXMLElement	"initializes the group from the following XML:	&lt;langSet&gt;		&lt;tig&gt;			&lt;term&gt;Stylesheet&lt;/term&gt;			&lt;transacGroup&gt;				&lt;transac&gt;..&lt;/transac&gt;			&lt;/transacGroup&gt;		&lt;tig&gt;		&lt;tig&gt;			...		&lt;/tig&gt;	&lt;/langSet&gt;	"	| language tigElements tigs |	language := ''.	OrderedCollection new.	Dictionary new.	anXMLElement attributes		do: [:each | each tag asString = 'xml:lang' ifTrue: [language := each value]].	tigElements := anXMLElement realElements				select: [:each | each tag asString = 'tig'].	tigs := tigElements				collect: [:tig | TBXTermInformationGroup fromXMLElement: tig].	^self new setLanguage: language terms: tigs</body><body package="L10n-TMX">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>L10n.AccessKeyFixer</class-id> <category>checking</category><body package="L10n-UI">isValidAccessKey: aChar 	"Checks if aChar is a valid accessKey in all Menus"	self menus do: 			[:aMenu | 			(AccessKeyChecker 				checkMenu: aMenu				forLabel: self label asString				atChat: aChar				forUserMessage: self userMessage) ifFalse: [^false]].	^true</body></methods><methods><class-id>L10n.AccessKeyFixer</class-id> <category>utility</category><body package="L10n-UI">underlineString: aString atPosition: aPos 	"	underlines aString at aPos and returns this as Text	"	| s |	s := TextStream on: String new.	aPos &gt; 1 ifTrue: [s nextPutAll: (aString copyFrom: 1 to: aPos - 1)].	s nextPutAllText: ((aString at: aPos) asSymbol asText emphasizeAllWith: #underline).	aString size &gt; aPos 		ifTrue: [s nextPutAll: (aString copyFrom: aPos + 1 to: aString size)].	^s contents</body></methods><methods><class-id>L10n.AccessKeyFixer</class-id> <category>accessing</category><body package="L10n-UI">changeSliderRange: aNumber 	range ifNotNil: [range rangeStop: aNumber]</body><body package="L10n-UI">characterPosition: anObject	^characterPosition := anObject asValue</body><body package="L10n-UI">label	^label</body><body package="L10n-UI">label: anObject	label := anObject.	self labelPreview value: anObject.	self changeSliderRange: anObject size.</body><body package="L10n-UI">menus	^menu</body><body package="L10n-UI">menus: anObject	menu := anObject</body><body package="L10n-UI">model	^model</body><body package="L10n-UI">model: anObject	model := anObject</body><body package="L10n-UI">userMessage	^userMessage</body><body package="L10n-UI">userMessage: anObject	userMessage := anObject</body></methods><methods><class-id>L10n.AccessKeyFixer</class-id> <category>interface opening</category><body package="L10n-UI">postBuildWith: aBuilder 	(self widgetAt: #characterPosSlider) rangeMap 		rangeStop: self labelPreview value size.</body></methods><methods><class-id>L10n.AccessKeyFixer</class-id> <category>actions</category><body package="L10n-UI">characterPosChanged	| newPos |	newPos := self characterPosition value min: self label size.	self		label: (self underlineString: (MenuItem labeled: self label asString) label				atPosition: newPos).	self ValidKey		value: ((self isValidAccessKey: (self label asString at: newPos))				ifTrue: [String new]				ifFalse: [(#InvalidKey &lt;&lt; #Localizer &gt;&gt; 'Invalid Key') asString])</body><body package="L10n-UI">close	"This stub method was generated by UIDefiner"	self characterPosition: 0.	^	self closeAndUnschedule.</body><body package="L10n-UI">nextValidAccessKeyFor: anInteger 	"returns the next valid position for the access key.	if there's none return 0"	| s i bool |	s := self label asString.	i := anInteger.	bool := false.	[i &gt; s size or: [bool := self isValidAccessKey: (s at: i)]] 		whileFalse: [i := i + 1].	bool ifTrue: [^i].	i := anInteger.	[(bool := self isValidAccessKey: (s at: i)) or: [i &lt; 1]] 		whileFalse: [i := i - 1].	bool ifTrue: [^i] ifFalse: [^0]</body><body package="L10n-UI">ok	"This stub method was generated by UIDefiner"	^	self closeAndUnschedule</body></methods><methods><class-id>L10n.AccessKeyFixer</class-id> <category>interface closing</category><body package="L10n-UI">noticeOfWindowClose: aWindow 	| s pos |	pos := self characterPosition value.	pos = 0 		ifFalse: 			[s := String new writeStream.			1 to: self label size				do: 					[:i | 					pos = i ifTrue: [s nextPut: $&amp;].					s nextPut: (self label at: i)].			self 				triggerEvent: #finished				with: s contents				with: true]		ifTrue: 			[self 				triggerEvent: #finished				with: self label asString				with: true].	self removeActionsForEvent: #finished</body></methods><methods><class-id>L10n.AccessKeyFixer</class-id> <category>aspects</category><body package="L10n-UI">ValidKey	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^ValidKey isNil		ifTrue:			[ValidKey := String new asValue]		ifFalse:			[ValidKey]</body><body package="L10n-UI">characterPosition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^characterPosition isNil		ifTrue:			[characterPosition := 1 asValue]		ifFalse:			[characterPosition]</body><body package="L10n-UI">labelPreview	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^labelPreview isNil		ifTrue:			[labelPreview := String new asValue]		ifFalse:			[labelPreview]</body></methods><methods><class-id>L10n.AccessKeyFixer class</class-id> <category>instance creation</category><body package="L10n-UI">onModel: aModel withLabel: aLabel forMenus: menusToSearch startPos: anInteger userMessage: aUserMessage 	| a |	a := super new initialize.	a model: aModel.	a when:#finished send:#accessKeyFixed:accept: to: aModel.		a label: (MenuItem labeled: aLabel) label.	a menus: menusToSearch.	a userMessage: aUserMessage.	a characterPosition: anInteger.	a characterPosChanged.	self openOn: a.	^a</body><body package="L10n-UI">onModel: aModel withLabel: aLabel forMethods: methods startPos: anInteger userMessage: aUserMessage 	^self 		onModel: aModel		withLabel: aLabel		forMenus: (AccessKeyChecker compileMenusFromMethods: methods)		startPos: anInteger		userMessage: aUserMessage.</body></methods><methods><class-id>L10nTMXSoxDriver</class-id> <category>content handler</category><body package="L10n-TMX">atCurrentElementPut: aString	"take the current element and add some values to it. if everything is put into it then the element is stored."	"aString = 'SUCCESS,' ifTrue:[self halt.]."	(srcLang isNil not and: [tarLang isNil and: [segStarted]])		ifTrue: 			[self splitSourceLang.			element at: #sourceString put: aString asSymbol].	(tarLang isNil not and: [segStarted])		ifTrue: 			[self splitTargetLang.			element at: #targetString put: aString asSymbol.			(element includesKey: #sourceString)				ifFalse: 					[self splitSourceLang.					element at: #sourceString put: '' asSymbol].			element at: #version				ifAbsentPut: [L10n.UserMessageSpecifierVersion fromString: aString].			self storeElement.			tarLang := nil.			srcLang := nil].	key = nil ifTrue: [^nil].	key = #version		ifTrue: 			[element at: #version				put: (L10n.UserMessageSpecifierVersion fromString: aString).			^nil].	key = #tmxSize		ifTrue: 			["increase size of progressbar"			ResetIncrementNotification signalWith: aString asNumber.			^nil].	element at: key put: aString asSymbol</body><body package="L10n-TMX">characters: aString 	^self atCurrentElementPut: aString</body><body package="L10n-TMX">endElement: namespaceURI localName: localName qName: name	"a closing tag was found"	name = 'seg' ifTrue: [segStarted := false].	name = 'tu'		ifTrue: 			[element := nil.			key := nil.			srcLang := nil.			tarLang := nil.			segStarted := false].	key := nil</body><body package="L10n-TMX">languageAndCountryFrom: aString	| result |	result := (LangSpecConverter convertFromRfc3066: aString)				tokensBasedOn: $_.	result := result collect: #asSymbol.	^result size = 2 ifTrue: [result] ifFalse: [result , #(#none)]</body><body package="L10n-TMX">splitSourceLang	"this splits the sourceLanguage like 'de_DE' into de and DE and puts that into element"	| src |	src := self languageAndCountryFrom: srcLang.	element at: #sourceLanguage put: src first.	element at: #sourceCountry put: src last</body><body package="L10n-TMX">splitTargetLang	"this splits the targetLanguage like 'de_DE' into de and DE and puts that into element"	| tar |	tar := self languageAndCountryFrom: tarLang.	element at: #targetLanguage put: tar first.	element at: #targetCountry put: tar last</body><body package="L10n-TMX">startElement: namespaceURI localName: localName qName: name attributes: attributes	"a start tag was found and depending on its name the values of element are set."	| property |	segStarted ifNil: [segStarted := false].	name = 'tu'		ifTrue: 			[element := Dictionary new.			IncrementNotification raiseSignal].	name = 'prop'		ifTrue: 			[property := attributes first value.			property = 'x-version' ifTrue: [key := #version].			property = 'catalog' ifTrue: [key := #catalog].			property = 'x-tmx-size' ifTrue: [key := #tmxSize].			property = 'x-key' ifTrue: [key := #key]].	name = 'tuv'		ifTrue: 			[attributes first tag type = 'lang'				ifTrue: 					[srcLang						ifNil: [srcLang := attributes first value]						ifNotNil: [tarLang := attributes first value]]].	name = 'seg' ifTrue: [segStarted := true].	name = 'header'		ifTrue: 			[(attributes select: [:each | each tag type = 'creationtool']) first value				= 'L10n'					ifFalse: 						[self error: #OnlyImportTmxFilesExportedByL10n &lt;&lt; #Localizer									&gt;&gt; 'please only import tmx files exported by L10n']]</body><body package="L10n-TMX">storeElement	"this method stores the element int the translation memory"	| d |	d := element copy.	d removeKey: #targetString.	L10n.UserMessageTranslationMemory default translationMD 		add: d asKeyDictionary -&gt; (element at: #targetString) asString</body></methods><methods><class-id>L10nTMXSoxDriver</class-id> <category>accessing</category><body package="L10n-TMX">srcLang	^srcLang</body><body package="L10n-TMX">srcLang: anObject	^srcLang := anObject</body></methods><methods><class-id>L10n.CheckedTranslation</class-id> <category>printing</category><body package="L10n-UI">displayString	| text |	text := key displayString asText.	^self valid ifTrue: [text] ifFalse: [text allBold]</body></methods><methods><class-id>L10n.CheckedTranslation</class-id> <category>accessing</category><body package="L10n-UI">key	^key</body><body package="L10n-UI">key: anObject	key := anObject</body><body package="L10n-UI">valid	^valid</body><body package="L10n-UI">valid: anObject	valid := anObject</body></methods><methods><class-id>L10n.CheckedTranslation</class-id> <category>initialize-release</category><body package="L10n-UI">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	key := nil.	valid := true.	^self</body></methods><methods><class-id>L10n.CheckedTranslation class</class-id> <category>instance creation</category><body package="L10n-UI">new	^super new initialize</body></methods><methods><class-id>L10n.EditTermUI</class-id> <category>accessing</category><body package="L10n-UI">createNew	(self class organization listAtCategoryNamed: #aspects) 		do: [:sel | (self perform: sel) value: String new].	self original value: self model termMenuAspect.	self loadFromTerm: TerminologyEntry new</body><body package="L10n-UI">loadFromTerm: aTerm 	aTerm keys 		do: [:aKey | (self perform: aKey asSymbol) value: (aTerm perform: aKey asSymbol)].	self valid value isString		ifTrue: [self valid value: self valid value asLowercase asSymbol = #ok]</body><body package="L10n-UI">model	^model</body><body package="L10n-UI">model: anObject 	| |	model := anObject.</body><body package="L10n-UI">new	^new</body><body package="L10n-UI">new: anObject	new := anObject.</body><body package="L10n-UI">saveInto: aTermEntry 	| d |	d := Dictionary new.	(self class organization listAtCategoryNamed: #aspectsForSaving) 		do: [:sel | d at: sel put: (self perform: sel) value].	d at: #valid put: (self valid value ifTrue: [#Ok] ifFalse: [String new]).	self model editFinishedForTerm: aTermEntry withData: d</body><body package="L10n-UI">setOriginal: aString	self original value: aString.</body><body package="L10n-UI">term	^term</body><body package="L10n-UI">term: anObject 	term := anObject.	self loadFromTerm: anObject</body></methods><methods><class-id>L10n.EditTermUI</class-id> <category>aspects_</category><body package="L10n-UI">comments	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^comments isNil		ifTrue:			[comments := String new asValue]		ifFalse:			[comments]</body><body package="L10n-UI">isValid	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^isValid isNil		ifTrue:			[isValid := false asValue]		ifFalse:			[isValid]</body><body package="L10n-UI">sources	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sources isNil		ifTrue:			[sources := self model availableSources asValue]		ifFalse:			[sources]</body></methods><methods><class-id>L10n.EditTermUI</class-id> <category>actions</category><body package="L10n-UI">cancel	"This stub method was generated by UIDefiner"	refresh := false.	^self closeAndUnschedule</body><body package="L10n-UI">lookUpAction	"open a window of the internet explorer that shows the translations for this term"	(LookUpHelper openBrowserOn: self original value inDict: self lookUp value) 		ifFalse: 			["retry once"			LookUpHelper openBrowserOn: self original value inDict: self lookUp value]</body><body package="L10n-UI">ok	"This stub method was generated by UIDefiner"	self new ifTrue: [self saveInto: nil] ifFalse: [self saveInto: self term].	refresh := true.	^self closeAndUnschedule</body></methods><methods><class-id>L10n.EditTermUI</class-id> <category>aspects</category><body package="L10n-UI">lookUp	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lookUp isNil		ifTrue:			[lookUp := nil asValue]		ifFalse:			[lookUp]</body><body package="L10n-UI">lookUpMenu	"returns a menu with the dictionary names from LookUpDictionary"	| names |	names := LookUpDictionary default dictionariesForCurrentLanguages.	^Menu labelArray: names values: names</body></methods><methods><class-id>L10n.EditTermUI</class-id> <category>interface opening</category><body package="L10n-UI">postOpenWith: aBuilder 	"activate the right originalField"	self builder window windowType: #imageModalDialog.	(self widgetAt: #Eingabefeld1) isVisible: true.	"don't activate the readOnly field"	(self widgetAt: #Eingabefeld1RO) isVisible: false.	(self widgetAt: #lookupMenu) isVisible: LookUpHelper canUseLookUp.	(self widgetAt: #lookUpLabel) isVisible: LookUpHelper canUseLookUp.	self builder keyboardProcessor 		keyboardHook: [:ev :c | self keyPressed: ev]</body></methods><methods><class-id>L10n.EditTermUI</class-id> <category>interface closing</category><body package="L10n-UI">noticeOfWindowClose: aWindow 	"the window is closing, so tell the model we finished"		^self model termEditFinished: refresh = true</body></methods><methods><class-id>L10n.EditTermUI</class-id> <category>events</category><body package="L10n-UI">keyPressed: ev 	ev keyValue = Character esc 		ifTrue: 			["esc was pressed so close the window"			self cancel.			^nil].	^ev</body></methods><methods><class-id>L10n.EditTermUI</class-id> <category>aspectsForSaving</category><body package="L10n-UI">notes	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^comments isNil		ifTrue:			[comments := String new asValue]		ifFalse:			[comments]</body><body package="L10n-UI">original	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^original isNil		ifTrue:			[original := String new asValue]		ifFalse:			[original]</body><body package="L10n-UI">source	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^source isNil		ifTrue:			[source := String new asValue]		ifFalse:			[source]</body><body package="L10n-UI">synonym	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^synonym isNil		ifTrue:			[synonym := String new asValue]		ifFalse:			[synonym]</body><body package="L10n-UI">translation	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^translation isNil		ifTrue:			[translation := String new asValue]		ifFalse:			[translation]</body><body package="L10n-UI">valid	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^isValid isNil		ifTrue:			[isValid := false asValue]		ifFalse:			[isValid]</body></methods><methods><class-id>L10n.EditTermUI class</class-id> <category>instance creation</category><body package="L10n-UI">edit: aTermEntry forModel: aModel 	"opens a new EditTermUI and sets the model and the TermEntry that is edited"	| e |	aTermEntry ifNil: [^nil].	e := self new.	e model: aModel.	e term: aTermEntry.	e new: false.	e open.	^e</body><body package="L10n-UI">newForModel: aModel name: aName	"opens a new EditTermUI and sets the model and the TermEntry that is edited"	| e |	e := self new.	e model: aModel.	e new: true.	e original value: aName.	e open.	^e</body><body package="L10n-UI">onModel: aModel 	^self onModel: aModel new: false</body><body package="L10n-UI">onModel: aModel new: new 	| a |	a := self new initialize.	"new ifTrue:[aModel createNewTerm]."	a model: aModel.	new 		ifTrue: 			[a loadFromTerm: TerminologyEntry new.			a setOriginal: aModel termMenuAspect]		ifFalse: [a loadFromTerm: aModel selectedRow].	a new: new.	self openOn: a.	^a</body></methods><methods><class-id>L10n.CanvasViewer</class-id> <category>actions</category><body package="L10n-RBSupport">editSpec	| editorClass aMethod |	aMethod := self method.	aMethod isNil ifTrue: [^self].	editorClass := self editorClass.	editorClass isNil ifTrue: [^self].	editorClass new 		openOnClass: aMethod definition implementingClass soleInstance		andSelector: aMethod selector</body><body package="L10n-RBSupport">openSpec		[self method definition implementingClass soleInstance 		openWithSpec: self method definition selector] 			on: Error			do: 				[:ex | 				(Dialog 					choose: 'Can''t open this window.'					labels: (Array with: 'Debug' with: 'Good to know')					values: #(#debug #goOn)					default: #goOn) == #debug 					ifTrue: 						["debug the exception"						ex outer]]</body></methods><methods><class-id>L10n.CanvasViewer</class-id> <category>tabAPI</category><body package="L10n-RBSupport">isActive	^false</body><body package="L10n-RBSupport">isActiveInL10n	| aMethod |	codeTool selector ifNil: [^false].	aMethod := codeTool methodClass		compiledMethodAt: codeTool selector		ifAbsent: [^false].	^aMethod resourceType = #canvas</body><body package="L10n-RBSupport">isDefaultSelectionCandidate	^true</body><body package="L10n-RBSupport">tabGraphic	| row text |	row := VisualRow new.	text := Label		with: self tabName		attributes: self tabStyle.	text		offset:			(row components isEmpty				ifTrue: [4]				ifFalse: [2]) @ 0.	row add: text.	^row</body><body package="L10n-RBSupport">tabName	^'Preview'</body><body package="L10n-RBSupport">tabStyle	"This is an undesirable hack. We'd like to not set any style at all on these, and be able to have them 'inherit' the style of the tab control as it walk down the display tree, but we're not there yet, so we do this ugly reach out and infer it thing."	^Screen default defaultWidgetPolicy lookPolicyClass systemWidgetTextStyle</body></methods><methods><class-id>L10n.CanvasViewer</class-id> <category>private</category><body package="L10n-RBSupport">editorClass	| class |	class := #{UIPainter} valueOrDo: [nil].	class isNil 		ifTrue: 			[Dialog warn: (#UIPainternotloaded &lt;&lt; #Localizer &gt;&gt; 'UIPainter not loaded.').			^nil].	^class</body><body package="L10n-RBSupport">initializeAspectAdaptor: aspect 	| adaptor |	adaptor := AspectAdaptor subject: model.	adaptor forAspect: aspect.	adaptor subjectSendsUpdates: true.	self perform: (aspect , ':') asSymbol with: adaptor</body></methods><methods><class-id>L10n.CanvasViewer</class-id> <category>utilities</category><body package="L10n-RBSupport">disableSpec: aFullSpec 	"Disable all components of a Spec"	aFullSpec collection do: 			[:each | 			(each isKindOf: SpecCollection) ifTrue: [self disableSpec: each].			(each isKindOf: NamedSpec) ifTrue: [each initiallyDisabled: true]]</body><body package="L10n-RBSupport">spec	"Returns the spec for the VisualTab of the TranslationTabControl (TabControl2) for a preview of the selected Method in MethodList1. All components are disabled"	| class selector spec |	class := self method definition implementingClass soleInstance.	selector := self method definition selector.	spec := (class perform: selector) decodeAsLiteralArray.	self disableSpec: spec component.	^spec</body></methods><methods><class-id>L10n.CanvasViewer</class-id> <category>RBcompatibility</category><body package="L10n-RBSupport">isEditing		^false</body><body package="L10n-RBSupport">menu	^Menu new</body><body package="L10n-RBSupport">resetBuilder	self builder: nil.</body><body package="L10n-RBSupport">saveState	""</body><body package="L10n-RBSupport">updateContents	"donno what to do....maybe ask the superview for a method"	self method: self codeTool definition method.	self updateDisplay.</body><body package="L10n-RBSupport">windowSpecMethod	"return the name of our windowSpec"	^#windowSpec</body></methods><methods><class-id>L10n.CanvasViewer</class-id> <category>accessing</category><body package="L10n-RBSupport">codeTool	^codeTool</body><body package="L10n-RBSupport">codeTool: anObject	codeTool := anObject</body><body package="L10n-RBSupport">method	^self codeTool definition method</body><body package="L10n-RBSupport">method: anObject	method := anObject</body><body package="L10n-RBSupport">model	^model</body><body package="L10n-RBSupport">model: anObject	model := anObject</body></methods><methods><class-id>L10n.CanvasViewer</class-id> <category>updating</category><body package="L10n-RBSupport">updateDisplay	"Update the subcanvas with the current spec. Use a builder that is editing so that the canvas can be 	built properly."	builder notNil		ifTrue: 			[(builder componentAt: #visualisationSubcanvas) widget				client: ApplicationModel new				spec: self spec				builder: ((UIBuilder new)						isEditing: true;						window: builder window;											yourself)]</body></methods><methods><class-id>L10n.CanvasViewer class</class-id> <category>As yet unclassified</category><body package="L10n-RBSupport">codeModel: codeModel 	"gets a codeModel from the RB-codeModel"	^(self new)		codeTool: codeModel;		yourself</body><body package="L10n-RBSupport">inParent: aModel	"Dummy method template.  This was installed by the debugger	define method command."	| viewer |	viewer := self new.	viewer parent: aModel.	^viewer</body><body package="L10n-RBSupport">windowSpecMethod	"return the name of my windowSpec"	^#windowSpec</body></methods><methods><class-id>L10n.CatalogImporter</class-id> <category>file utilities</category><body package="L10n-UM-Collect">fromFilename: filename 	| stream scan |		language := sourceDirectory componentStrings last.	stream := (filename withEncoding: #autoDetectOrUtf8) readStream.	[scan := L10n.MessageFileParserForL10n new scan: stream.	scan parseSourceOntoFile: self.	self write] 			ensure: 				[self initialize.				stream close]</body><body package="L10n-UM-Collect">getCatalognameFor: aFilename 	| extensionSize filenameString |	filenameString := aFilename asString.	extensionSize := aFilename extension size.	^filenameString copyFrom: sourceDirectoryString size + 2		to: filenameString size - extensionSize</body><body package="L10n-UM-Collect">importDirectory: source to: aSharedVariable 	target := aSharedVariable.	sourceDirectory := PortableFilename named: source asString.	sourceDirectoryString := sourceDirectory asString.	self processAllFiles.</body><body package="L10n-UM-Collect">importFile: aSource to: aSharedVariable 	| source |	target := aSharedVariable.	source := aSource asFilename head.	sourceDirectory := PortableFilename named: source asString.	sourceDirectoryString := sourceDirectory asString.	self fromFilename: aSource.</body><body package="L10n-UM-Collect">processAllFiles	sourceDirectory asFilename isDirectory not		ifTrue: 			[| filename |			filename := sourceDirectory.			sourceDirectoryString := sourceDirectory head.			sourceDirectory := PortableFilename named: sourceDirectory head.			self fromFilename: filename]		ifFalse: 			[sourceDirectory asFilename directoryContents do: 					[:filenameString |					fileName := PortableFilename								named: sourceDirectoryString , (String with: Filename separator)										, filenameString.					(#('.lbl') includes: fileName extension)						ifTrue: 							[Notice show: (#ImportingCatalog_ &lt;&lt; #Localizer &gt;&gt; 'Importing Catalog: &lt;1s&gt;'										expandMacrosWith: filenameString)								while: [self fromFilename: fileName]]]]</body></methods><methods><class-id>L10n.CatalogImporter</class-id> <category>accessing</category><body package="L10n-UM-Collect">addCatalogID: aCatalog 	catalog := aCatalog</body><body package="L10n-UM-Collect">at: aKey put: aString 	"only used by the messageFileParserForL10n"	contents at: aKey put: aString</body><body package="L10n-UM-Collect">recordCacheLimit: aLimit 	"only needet for Compatibility"</body><body package="L10n-UM-Collect">recordEncoding: aEncoding 	encoding := aEncoding</body><body package="L10n-UM-Collect">version	^version</body><body package="L10n-UM-Collect">version: anObject	version := anObject</body></methods><methods><class-id>L10n.CatalogImporter</class-id> <category>utilities</category><body package="L10n-UM-Collect">saveTM: umt 	^target saveTranslationInTM: umt</body><body package="L10n-UM-Collect">write	"writes from a catalog into a userMessageTranslation (umt)"	| version_ umt |	version_ := UserMessageSpecifierVersion new.	version_		source: #Catalog;		timeStamp: Timestamp now.	contents keysAndValuesDo: 			[:key :str | 			umt := UserMessageTranslation new.			umt catalog: catalog.			umt key: key asSymbol.			umt language: language languageCode asSymbol.			umt country: language countryCode asSymbol.			umt version: version_.			umt string: str.			"umt wird im userTranslationMemory (target) gespeichert"			self saveTM: umt]</body></methods><methods><class-id>L10n.CatalogImporter</class-id> <category>initialize release</category><body package="L10n-UM-Collect">initialize	contents := Dictionary new</body></methods><methods><class-id>L10n.CatalogImporter class</class-id> <category>instance creation</category><body package="L10n-UM-Collect">importFile: aFilepath into: aSharedVariable 	^self new importFile: aFilepath to: aSharedVariable</body><body package="L10n-UM-Collect">new	^super new initialize</body></methods><methods><class-id>L10n.C_noneCatalogImporter</class-id> <category>utilities</category><body package="L10n-UM-Collect">saveTM: umt 	^target saveUserMessage: umt</body></methods><methods><class-id>TBXTermInformationGroup</class-id> <category>initialize-release</category><body package="L10n-TMX">setTerm: termString transactGroups: groups attributes: attrs	term := termString.	transactGroups := groups.	attributes := attrs</body></methods><methods><class-id>TBXTermInformationGroup</class-id> <category>accessing</category><body package="L10n-TMX">attributes	^attributes</body><body package="L10n-TMX">attributes: anObject	attributes := anObject</body><body package="L10n-TMX">term	^term</body><body package="L10n-TMX">term: anObject	term := anObject</body></methods><methods><class-id>TBXTermInformationGroup</class-id> <category>printing</category><body package="L10n-TMX">printOn: aStream	aStream		tab;		nextPutAll: 'Term: ';		nextPutAll: term;		cr.	attributes keys sorted do: 			[:each |			aStream				tab;				tab;				nextPutAll: each;				nextPutAll: ': ';				nextPutAll: (attributes at: each);				cr].	transactGroups do: 			[:each |			aStream				tab;				tab.			aStream				print: each;				cr]</body></methods><methods><class-id>TBXTermInformationGroup class</class-id> <category>instance creation</category><body package="L10n-TMX">fromXMLElement: anXMLElement	"initializes the group from the following XML:		&lt;tig&gt;			&lt;term&gt;Stylesheet&lt;/term&gt;			&lt;transacGroup&gt;				&lt;transac&gt;..&lt;/transac&gt;			&lt;/transacGroup&gt;		&lt;tig&gt;	"	| term transactGroups attributes title |	term := ''.	transactGroups := OrderedCollection new.	attributes := Dictionary new.	anXMLElement realElements do: 			[:each |			each tag asString = 'descripGrp'				ifTrue: 					[each realElements do: 							[:element |							element tag asString = 'descrip'								ifTrue: 									[title := ''.									element attributes detect: [:attr | attr tag asString = 'type']										ifFound: [:attr | title := attr value].									attributes at: title put: element characterData]]].			each tag asString = 'transacGrp'				ifTrue: [transactGroups add: (TBXTransactGroup fromXMLElement: each)].			each tag asString = 'term' ifTrue: [term := each characterData]].	^self new		setTerm: term		transactGroups: transactGroups		attributes: attributes</body></methods><methods><class-id>L10n.TermManager</class-id> <category>utility</category><body package="L10n-Models">getSourceList	"get all sources from the TerminologyController and make a list of it"	^(TerminologyController default data collection 		collect: [:each | each key at: #source]) asSet 		asSortedCollection</body><body package="L10n-Models">getTranslationForUserMessage: aUserMessageListEntry 	"returns the translation for the first occurance of aUserMessageListEntry "	^self getTranslationForUserMessage: aUserMessageListEntry at: 1</body><body package="L10n-Models">getTranslationForUserMessage: aUserMessageListEntry at: i 	"returns the translation of the i'th occurance of aUserMessage "	| list |	list := Localisator default 				getTargetDefaultStringForMessage: aUserMessageListEntry				from: L10nSettings default lastSource				to: L10nSettings default lastTarget.	list size &lt; i ifTrue: [^String new] ifFalse: [^(list at: i) string]</body><body package="L10n-Models">removeTerm: original withTranslation: translation synonym: synonym notes: notes source: source valid: valid 	"removes a term from the Terminology specified by these arguments"	| d |	d := Dictionary new.	d at: #original put: original.	d at: #translation put: translation.	d at: #synonym put: synonym.	d at: #notes put: notes.	d at: #source put: source.	d at: #valid put: (valid ifTrue: [#Ok] ifFalse: [String new]).	TerminologyController default data remove: d ifAbsent: []</body><body package="L10n-Models">saveTerm: org withOriginal: comm translation: val synonym: src notes: syn source: sel valid: trans intoDict: d 	"stores all the arguments into the dictionary d as this allready exists in the terminology"	d ifNil: [^nil].	d at: #original put: org.	d at: #translation put: trans.	d at: #synonym put: syn.	d at: #notes put: comm.	d at: #source put: src.	d at: #valid put: val.	"resort the discriminated MD to keep indices intact"	TerminologyController default data resort</body><body package="L10n-Models">termsForFilter: termsens 	"returns a list of terms containing termsens"	^(TerminologyController default allTermsContaining: termsens) 		asSortedCollection</body><body package="L10n-Models">userMessagesForTerm: aTerm	"returns all usermessages that contain aTerm"	^Localisator default		getUserMessagesContainingTerm: aTerm		source: L10nSettings default lastSource		target: L10nSettings default lastTarget</body></methods><methods><class-id>L10n.TermManager class</class-id> <category>singleton</category><body package="L10n-Models">default	^TheTermManager ifNil: [TheTermManager := self new]</body></methods><methods><class-id>L10n.TBXWriter</class-id> <category>accessing</category><body package="L10n-TMX">footerString 	^'&lt;/body&gt;&lt;/text&gt;&lt;/martif&gt;'</body><body package="L10n-TMX">headerString 	^'%&lt;?xml version=''1.0''?&gt;     %&lt;martif type="TBX" xml:lang="en" size="&lt;1p&gt;"&gt; 	%&lt;martifHeader&gt;	  	%&lt;fileDesc&gt;%&lt;sourceDesc&gt;from an L10n termBase%&lt;/sourceDesc&gt;%&lt;/fileDesc&gt; 	%&lt;/martifHeader&gt;	%&lt;text&gt;%&lt;body&gt;' expandMacrosWith: self objects size</body><body package="L10n-TMX">keyIDFor: aSymbol	self keys add: aSymbol.	^('&lt;1s&gt;&lt;2p&gt;' expandMacrosWith: aSymbol with: (self keys occurrencesOf: aSymbol))		asSymbol</body><body package="L10n-TMX">keys	^keys</body><body package="L10n-TMX">keys: anObject	keys := anObject</body><body package="L10n-TMX">objectClass	^L10nTBXObject</body></methods><methods><class-id>L10n.TBXWriter</class-id> <category>exporting</category><body package="L10n-TMX">convertObject: anObject	"convert anObject to something that understands #asXMLElement"	^self objectClass from: anObject using: self</body></methods><methods><class-id>L10n.TBXWriter</class-id> <category>initialize-release</category><body package="L10n-TMX">initialize	super initialize.	keys := Bag new</body></methods><methods><class-id>L10n.TBXWriter class</class-id> <category>instance creation</category><body package="L10n-TMX">new	^super new initialize</body></methods><methods><class-id>L10n.UserMessageSpecifierVersion</class-id> <category>comparing</category><body package="L10n-Base-Data">= anUserMessageVersion 	^self source = anUserMessageVersion source 		and: [self timeStamp = anUserMessageVersion timeStamp]</body><body package="L10n-Base-Data">hash	^self source hash + self timeStamp hash</body></methods><methods><class-id>L10n.UserMessageSpecifierVersion</class-id> <category>printing</category><body package="L10n-Base-Data">asString	"		(self source: 'theTranslator' timestamp: Timestamp now status:'approved') asString.	"	| s |	s := String new writeStream.	s		nextPutAll: self source;		space;		nextPut: $[;		space;		nextPutAll: ((Locale named: #C) printAsTime: self timeStamp					policyNamed: #editing) asString;		space;		nextPut: $];		space;		nextPutAll: self status.	^s contents</body><body package="L10n-Base-Data">displayString	| aStream |	aStream := TextStream on: String new.	self status isEmpty 		ifFalse: 			[aStream nextPutAll: self status.			].	aStream padTo: 10.	self source isEmpty 		ifFalse: 			[aStream nextPutAll: self source asString.		].	aStream padTo: 21.	aStream nextPutAll: self timeStamp printString.	aStream padTo: 35.	^aStream contents</body><body package="L10n-Base-Data">printOn: aStream 	self status isEmpty 		ifFalse: 			[aStream nextPutAll: self status.			aStream nextPutAll: ' - '].	self source isEmpty 		ifFalse: 			[aStream nextPutAll: self source asString.			aStream nextPutAll: ' - '].	aStream nextPutAll: self timeStamp printString</body></methods><methods><class-id>L10n.UserMessageSpecifierVersion</class-id> <category>initialize-release</category><body package="L10n-Base-Data">initialize	"Initialize a newly created instance. This method must answer the receiver."	source := nil.	timeStamp := nil.	^self</body></methods><methods><class-id>L10n.UserMessageSpecifierVersion</class-id> <category>accessing</category><body package="L10n-Base-Data">source	^source</body><body package="L10n-Base-Data">source: aSourceSymbol	source := aSourceSymbol</body><body package="L10n-Base-Data">status	^status ifNil: [status := String new]</body><body package="L10n-Base-Data">status: anObject	status := anObject</body><body package="L10n-Base-Data">timeStamp	^timeStamp</body><body package="L10n-Base-Data">timeStamp: aTimeStamp 	timeStamp := aTimeStamp</body></methods><methods><class-id>L10n.UserMessageSpecifierVersion class</class-id> <category>instance creation</category><body package="L10n-Base-Data">empty	^self source: '' timestamp: (Timestamp zero)</body><body package="L10n-Base-Data">fromString: aString 	"	self fromString: 'theTranslator [ 10/06/2006 4:40:05.101 ] approved'.	"	| s timestamp status newName |	s := aString readStream.	newName := s upTo: $[.	timestamp := s upTo: $].	s next.	status := s upToEnd.	^self 		source: (newName copyFrom: 1 to: newName size - 1)		timestamp: (timestamp isEmpty 				ifTrue: [Timestamp now]				ifFalse: [Timestamp readFrom: timestamp readStream])		status: status</body><body package="L10n-Base-Data">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="L10n-Base-Data">source: aSymbol timestamp: aTimestamp 	"Answer a newly created and initialized instance."	^self source: aSymbol timestamp: aTimestamp status: String new.</body><body package="L10n-Base-Data">source: aSymbol timestamp: aTimestamp status: aString	"Answer a newly created and initialized instance."	| u |	u := self new.	u source: aSymbol.	u timeStamp: aTimestamp.	u status: aString.	^u</body></methods><methods><class-id>L10n.L10nSettings</class-id> <category>settings</category><body package="L10n-Base">caseSensitiveness	"accessor for preferences"	^self settings at: #caseSensitiveness ifAbsent:[true]</body><body package="L10n-Base">caseSensitiveness: anObject 	"accessor for preferences"	self settings at: #caseSensitiveness put: anObject</body><body package="L10n-Base">customDirectoryOrDefaultAt: key	^self directoryForSetting: key ifAbsentUse: [self defaultMessagesFolder]</body><body package="L10n-Base">defaultMessagesFolder	"first convert to #asFilename in order to resolve environment variables"	^(UI.UISettings preferenceFor: #messagesList) first asFilename asString</body><body package="L10n-Base">directoryForSetting: key ifAbsentUse: defaultBlock	| dir |	dir := self settings at: key ifAbsentPut: defaultBlock.	^(dir isEmpty or: [dir asFilename exists])		ifTrue: [dir]		ifFalse: [defaultBlock value]</body><body package="L10n-Base">includeCnone	"accessor for preferences"	^self settings at: #includeCnone ifAbsent: [true]</body><body package="L10n-Base">includeCnone: anObject 	"accessor for preferences"	self settings at: #includeCnone put: anObject</body><body package="L10n-Base">lastSource	^self settings at: #lastSource ifAbsentPut: [#C]</body><body package="L10n-Base">lastSource: anObject 	self settings at: #lastSource put: anObject</body><body package="L10n-Base">lastSourceFolder	"returns the lastSource, but if that is C_none, then return only C"	| lastSource |	lastSource := self lastSource.	lastSource = #C_none ifTrue: [^#C] ifFalse: [^lastSource]</body><body package="L10n-Base">lastTarget	"C_none can't be a target, so remove it from the list"	| t |	^self settings at: #lastTarget		ifAbsentPut: 			[t := self targetDirectory asFilename directoryContents 						select: [:each | ('C*' match: each) not].			t isEmpty ifTrue: [String new] ifFalse: [t first]]</body><body package="L10n-Base">lastTarget: anObject	self settings at:#lastTarget put: anObject</body><body package="L10n-Base">matching	^self settings at: #matching ifAbsent:[80]</body><body package="L10n-Base">matching: anObject 	^self settings at: #matching put: anObject</body><body package="L10n-Base">numbersToShow	"returns the number of matches that should be shown in existingTranslationList.	accessor for the preferences"	^self settings at: #numbersToShow ifAbsent:[0]</body><body package="L10n-Base">numbersToShow: aNumber 	"accessor for preferences"	self settings at: #numbersToShow put: aNumber</body><body package="L10n-Base">ownTranslations	"accessor for preferences"	^self settings at: #ownTranslations ifAbsent:[true]</body><body package="L10n-Base">ownTranslations: anObject 	"accessor for preferences"	self settings at: #ownTranslations put: anObject</body><body package="L10n-Base">panaltySourceNeutralCountry	"accessor for preferences"	true ifTrue:[^0].	^(self settings at:#panaltySourceNeutralCountry ifAbsent:[0])/100</body><body package="L10n-Base">panaltySourceNeutralCountry: anObject	"accessor for preferences"	self settings at:#panaltySourceNeutralCountry put: anObject*100</body><body package="L10n-Base">panaltySourceOtherCountry	"accessor for preferences"	^(self settings at: #panaltySourceOtherCountry ifAbsent: [0]) / 100</body><body package="L10n-Base">panaltySourceOtherCountry: anObject	"accessor for preferences"	self settings at:#panaltySourceOtherCountry put: anObject*100</body><body package="L10n-Base">panaltyTargetNeutralCountry	"accessor for preferences"	^(self settings at: #panaltyTargetNeutralCountry ifAbsent:[0]) / 100</body><body package="L10n-Base">panaltyTargetNeutralCountry: anObject 	"accessor for preferences"	self settings at: #panaltyTargetNeutralCountry put: anObject * 100</body><body package="L10n-Base">panaltyTargetOtherCountry	"accessor for preferences"	^(self settings at: #panaltyTargetOtherCountry ifAbsent: [0]) / 100</body><body package="L10n-Base">panaltyTargetOtherCountry: anObject 	"accessor for preferences"	self settings at: #panaltyTargetOtherCountry put: anObject * 100</body><body package="L10n-Base">removeTranslatedEntries	"accessor for preferences"	^self settings at: #removeTranslatedEntries ifAbsent:[false]</body><body package="L10n-Base">removeTranslatedEntries: anObject 	"accessor for preferences"	self settings at: #removeTranslatedEntries put: anObject.	self triggerEvent:#settingsChanged.</body><body package="L10n-Base">selectionBackground	^ColorValue 				red: 183 / 255				green: 231 / 255				blue: 255 / 255</body><body package="L10n-Base">showAll	"accessor for preferences"	^self settings at: #showAll ifAbsent:[true]</body><body package="L10n-Base">showAll: anObject 	"accessor for preferences"	self settings at: #showAll put: anObject</body><body package="L10n-Base">showAmountOfExistingTranslations	(self settings at: #showAll ifAbsent: [true])		ifTrue: [^#Showall &lt;&lt; #Localizer &gt;&gt; 'Show all']		ifFalse: [^self numbersToShow printString asSymbol]</body><body package="L10n-Base">showAmountOfExistingTranslations: anObject 	self showAll: anObject = #showAll.	self numbersToShow: anObject asString asNumber</body><body package="L10n-Base">showCatalogs	"accessor for preferences"	^self settings at: #showCatalogs ifAbsent: [false]</body><body package="L10n-Base">showCatalogs: anObject	"accessor for preferences"	self settings at: #showCatalogs put: (true = anObject).	self triggerEvent:#settingsChanged.	^self showCatalogs.</body><body package="L10n-Base">showSource	"accessor for preferences"	^self settings at:#showSource</body><body package="L10n-Base">showSource: anObject 	"accessor for preferences"	self settings at: #showSource put: anObject</body><body package="L10n-Base">showSysLang	"accessor for preferences"	^self settings at: #showSysLang ifAbsent: [true]</body><body package="L10n-Base">showSysLang: anObject	"accessor for preferences"	^self settings at: #showSysLang put:(anObject = true)</body><body package="L10n-Base">skipTranslatedEntries	^self settings at: #skipTranslatedEntries ifAbsent:[true]</body><body package="L10n-Base">skipTranslatedEntries: anObject 	"accessor for preferences"	self settings at: #skipTranslatedEntries put: anObject</body><body package="L10n-Base">sourceDirectory	"sourceDirectory is used from the UISettings of messagesList, where the folders for messages are listed"	^self customDirectoryOrDefaultAt: #sourceDirectory</body><body package="L10n-Base">sourceDirectory: anObject 	self settings at: #sourceDirectory put: anObject asSymbol</body><body package="L10n-Base">sourcePath	^self directoryForSetting: #sourcePath		ifAbsentUse: 			[(self sourceDirectory asFilename / self lastSourceFolder) asString]</body><body package="L10n-Base">sourcePath: anObject 	^self settings at: #sourcePath put: anObject</body><body package="L10n-Base">targetDirectory	"targetDirectory is used from the UISettings of messagesList, where the folders for messages are listed"	^self customDirectoryOrDefaultAt: #targetDirectory</body><body package="L10n-Base">targetDirectory: anObject 	self settings at: #targetDirectory put: anObject asSymbol</body><body package="L10n-Base">targetPath	| |	self lastTarget isEmpty ifTrue: [^nil].	^(self targetDirectory asFilename / self lastTarget) asString asSymbol</body><body package="L10n-Base">translator	"accessor for preferences"	| aName |	^self settings at: #translator		ifAbsentPut: 			[aName := Dialog 						request: #enterTranslatorName &lt;&lt; #Localizer &gt;&gt; 'Enter your name, please'						initialAnswer: (SystemUtils getEnvironmentVariable: 'USERNAME').			aName isEmpty ifFalse: [self translator: aName].			"ask as long as there's no name entered"			^self translator]</body><body package="L10n-Base">translator: anObject 	"accessor for preferences"	self settings at: #translator put: anObject</body></methods><methods><class-id>L10n.L10nSettings</class-id> <category>actions</category><body package="L10n-Base">showSettings	VisualWorksSettings openManagerPage:#(#tools #l10n)</body></methods><methods><class-id>L10n.L10nSettings</class-id> <category>testing</category><body package="L10n-Base">startupChecks	(Filename		expandEnvironmentIn: ('$(VISUALWORKS)' asFilename construct: 'messages')				asString)			asFilename exists		ifFalse: 			[^(#MessagefolderdoesnoomtheVisualWorksCD &lt;&lt; #Localizer				&gt;&gt; 'Message folder does not exist. Please install the Internationalization Support from the VisualWorks CD')					asString].	self sourceDirectory asFilename exists		ifFalse: 			[self showSettings.			^(#SetTheSourceDirectory &lt;&lt; #Localizer				&gt;&gt; 'Please set the SourceDirectory. You can do this in the Settings Window')					asString].	self targetDirectory asFilename exists		ifFalse: 			[self showSettings.			^(#SetTheTargetDirectory &lt;&lt; #Localizer				&gt;&gt; 'Please set the TargetDirectory. You can do this in the Settings Window')					asString].	^#OK</body></methods><methods><class-id>L10n.L10nSettings</class-id> <category>initialize-release</category><body package="L10n-Base">initialize	super initialize.	settings := Dictionary new.	self numbersToShow: 20.	self showAll: true.	self includeCnone: true.	self panaltySourceNeutralCountry: 0.01.	self panaltySourceOtherCountry: 0.02.	self panaltyTargetNeutralCountry: 0.02.	self panaltyTargetOtherCountry: 0.04</body></methods><methods><class-id>L10n.L10nSettings</class-id> <category>private</category><body package="L10n-Base">settings	"returns self, as we're a dictionary ourselfs and don't need a seperate one"	^settings</body></methods><methods><class-id>L10n.L10nSettings class</class-id> <category>instance creation</category><body package="L10n-Base">new	"Eine kürzlich erstellte und initialisierte Instanz erwidern."	^super new initialize</body></methods><methods><class-id>L10n.L10nSettings class</class-id> <category>accessing</category><body package="L10n-Base">default	^default ifNil: [default := self new]</body></methods><methods><class-id>L10n.L10nSettings class</class-id> <category>class initialization</category><body package="L10n-Base">initialize	default := nil</body></methods><methods><class-id>L10n.ExtentedUserMessageListEntry</class-id> <category>As yet unclassified</category><body package="L10n-Base-Data">fullDisplayText	"return the displayString, is for RB compatibility"	^self displayString</body><body package="L10n-Base-Data">isForSharedVariable	"return true"	^false</body></methods><methods><class-id>L10n.ExtentedUserMessageListEntry</class-id> <category>accessing</category><body package="L10n-Base-Data">catalog	"returns the catalog symbol"	^catalog ifNil: [catalog := Symbol new]</body><body package="L10n-Base-Data">catalog: anObject	catalog := anObject</body><body package="L10n-Base-Data">evaluate	"returns the UserMessage that this entry represents"	^UserMessage 		defaultString: self defaultString first value		key: self key		catalogID: self catalog</body><body package="L10n-Base-Data">filterNum	"returns 1 or 0 depending on the isFiltered bool"	^self isFiltered ifTrue: [1] ifFalse: [0]</body><body package="L10n-Base-Data">isFiltered	^isFiltered ifNil:[isFiltered := false].</body><body package="L10n-Base-Data">isFiltered: aBool 	^isFiltered := aBool</body></methods><methods><class-id>L10n.ExtentedUserMessageListEntry</class-id> <category>comparing</category><body package="L10n-Base-Data">&lt; anObject 	"to compare 2 entries first compare the filter number (0 or 1) then the key"	^self filterNum == anObject filterNum 		ifTrue: [self key &lt; anObject key]		ifFalse: [self filterNum &lt; anObject filterNum]</body><body package="L10n-Base-Data">&lt;= anObject 	"to compare 2 entries first compare the filter number (0 or 1) then the key"	^self filterNum = anObject filterNum 		ifTrue: [self key &lt; anObject key]		ifFalse: [self filterNum &lt; anObject filterNum]</body></methods><methods><class-id>L10n.ExtentedUserMessageListEntry</class-id> <category>printing</category><body package="L10n-Base-Data">displayString	"if color fonts are available draw filtered entries light gray, if not, draw them italic and small"	| t emphasis |	emphasis := SystemChecker isColorFontAvailable 				ifTrue: [#(#lightGray)]				ifFalse: [#(#italic #small)].	t := TextStream on: (String new: 15).	t nextPutAll: (#in1s &lt;&lt; #Localizer &gt;&gt; 'in &lt;1s&gt;: ' 				expandMacrosWith: self catalog).	t nextPutAllText: super displayString.	^t contents 		addEmphasis: (self isFiltered ifTrue: [emphasis] ifFalse: [#()])		removeEmphasis: nil		allowDuplicates: false</body><body package="L10n-Base-Data">displayStringWithoutCatalog	"the superclass doesn't store the catalog, so use that displayString method for drawing"	^super displayString</body><body package="L10n-Base-Data">printOn: aStream	| message |	message := self isFiltered				ifTrue: [#Filtered &lt;&lt; #Localizer &gt;&gt; 'Filtered ']				ifFalse: [#notFiltered &lt;&lt; #Localizer &gt;&gt; 'not filtered '].	aStream nextPutAll: message asString.	super printOn: aStream</body><body package="L10n-Base-Data">sourceString	"returns the source default string of this userMessage"	^self defaultString first value</body></methods><methods><class-id>L10n.ExtentedUserMessageListEntry</class-id> <category>initialize-release</category><body package="L10n-Base-Data">initialize	"Eine kürzlich erstellte Instanz initialisieren. Diese Methode muss dem Empfänger entsprechen."	catalog := nil.	^self</body></methods><methods><class-id>L10n.ExtentedUserMessageListEntry</class-id> <category>aspects</category><body package="L10n-Base-Data">currentTranslation	^TermManager default getTranslationForUserMessage: self</body></methods><methods><class-id>L10n.ExtentedUserMessageListEntry class</class-id> <category>instance creation</category><body package="L10n-Base-Data">new	"Eine kürzlich erstellte und initialisierte Instanz erwidern."	^super new initialize</body></methods><methods><class-id>L10n.TargetDefaultStringListEntry</class-id> <category>accessing</category><body package="L10n-Base-Data">string	^string</body><body package="L10n-Base-Data">string: anObject	string := anObject</body><body package="L10n-Base-Data">version	^version ifNil: [UserMessageSpecifierVersion empty] ifNotNil: [:x | x]</body><body package="L10n-Base-Data">version: anObject	version := anObject</body></methods><methods><class-id>L10n.TargetDefaultStringListEntry</class-id> <category>printing</category><body package="L10n-Base-Data">displayString	"first displays the version, than the string itself"	| aStream |	aStream := String new writeStream.	version isString 		ifTrue: [version isEmpty ifFalse: [aStream nextPutAll: version]]		ifFalse: [aStream nextPutAll: version displayString].	aStream padTo: 50.	aStream nextPutAll: string.	^aStream contents</body><body package="L10n-Base-Data">printOn: aStream 	version isString 		ifTrue: [version isEmpty ifFalse: [aStream nextPutAll: version]]		ifFalse: [aStream nextPutAll: version printString].	aStream		nextPutAll: ': ';		nextPutAll: string withEscapeSequences</body></methods><methods><class-id>L10n.TargetDefaultStringListEntry</class-id> <category>comparing</category><body package="L10n-Base-Data">&lt;= anObject 	"compares only the versions"	anObject class = self class ifFalse: [^false].	^self version &lt;= anObject version</body></methods><methods><class-id>L10n.TargetDefaultStringListEntry</class-id> <category>initialize-release</category><body package="L10n-Base-Data">fromEntry: association 	"initializes with the values of the association, which is an element of a MultiDictionary"	version := association key at: #date				ifAbsent: [association key at: #version ifAbsent: [nil]].	"	version isString ifFalse:[version:=version printString]."	string := association value</body></methods><methods><class-id>L10n.TargetDefaultStringListEntry class</class-id> <category>instance creation</category><body package="L10n-Base-Data">fromEntry:anEntry		^self new fromEntry: anEntry.</body></methods><methods><class-id>L10n.UserMessageLangSpecifier</class-id> <category>comparing</category><body package="L10n-Base-Data">= anUserMessageLangSpecifier 	^self language = anUserMessageLangSpecifier language and: 			[self culture = anUserMessageLangSpecifier culture 				and: [self specifier = anUserMessageLangSpecifier specifier]]</body><body package="L10n-Base-Data">hash 	^self language hash + self culture hash + self specifier hash</body></methods><methods><class-id>L10n.UserMessageLangSpecifier</class-id> <category>accessing</category><body package="L10n-Base-Data">application	^specifier application</body><body package="L10n-Base-Data">application: anApplicationSymbol 	^specifier application: anApplicationSymbol</body><body package="L10n-Base-Data">catalog	^specifier catalog</body><body package="L10n-Base-Data">catalog: aCatalogSymbol 	^specifier catalog: aCatalogSymbol</body><body package="L10n-Base-Data">culture	^culture</body><body package="L10n-Base-Data">culture: aCultureSymbol	culture := aCultureSymbol</body><body package="L10n-Base-Data">key	^specifier key</body><body package="L10n-Base-Data">key: aKeySymbol 	^specifier key: aKeySymbol</body><body package="L10n-Base-Data">language	^language</body><body package="L10n-Base-Data">language: aLanguageSymbol	language := aLanguageSymbol</body><body package="L10n-Base-Data">specifier	^specifier</body><body package="L10n-Base-Data">specifier: anUserMessageSpecifier	specifier := anUserMessageSpecifier</body></methods><methods><class-id>L10n.UserMessageLangSpecifier</class-id> <category>printing</category><body package="L10n-Base-Data">printOn: aStream 	aStream nextPutAll: self specifier printString.	aStream nextPut: $:.	aStream nextPutAll: self language printString.	aStream nextPut: $:.	aStream nextPutAll: self culture printString</body></methods><methods><class-id>L10n.UserMessageLangSpecifier</class-id> <category>initialize-release</category><body package="L10n-Base-Data">initialize	"Initialize a newly created instance. This method must answer the receiver."	specifier := UserMessageSpecifier new.	language := #none.	culture := #none.	^self</body></methods><methods><class-id>L10n.UserMessageLangSpecifier class</class-id> <category>instance creation</category><body package="L10n-Base-Data">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Refactory.Browser.L10nNavigatorPart</class-id> <category>accessing</category><body package="L10n-RBSupport">messages	messages ifNil: 			[messages := L10nMessagesNavigatorPart new.			navigator notNil ifTrue: [messages navigator: navigator]].	(self componentNamed: #messages) isNil 		ifTrue: [self componentNamed: #messages put: messages].	^messages</body></methods><methods><class-id>Refactory.Browser.L10nNavigatorPart</class-id> <category>private</category><body package="L10n-RBSupport">buildMethodsSubcanvas	| state |	true ifTrue:[^nil].	state := navigator getState.	self methods resetBuilder.	self installSubcanvas: #windowSpec using: self.	self resize: false.	self selectStateForComponents: state</body><body package="L10n-RBSupport">resize: fullSizeBoolean 	| splitter widget |	self halt.	fullSizeBoolean 		ifTrue: [self hideAll: self nonPrimaryWidgets]		ifFalse: [self showAll: self nonPrimaryWidgets].	widget := self builder componentAt: #subcanvas.	splitter := self builder componentAt: #splitter.		[(widget component layout)		rightOffset: (fullSizeBoolean 					ifTrue: [0]					ifFalse: [splitter component layout leftOffset]);		rightFraction: (fullSizeBoolean 					ifTrue: [1]					ifFalse: [splitter component layout leftFraction]).	splitter widget repairAfterMove] 			on: Error			do: [:ex | ex return]</body></methods><methods><class-id>Refactory.Browser.L10nNavigatorPart class</class-id> <category>accessing</category><body package="L10n-RBSupport">defaultTabDescriptions	| descriptions |	descriptions := OrderedCollection new.	descriptions add: (TabPartDescription 				named: #Methods &lt;&lt; #Localizer &gt;&gt; 'Methods'				buildWith: #buildMethodsSubcanvas				match: #alwaysEnabled:				enabled: #alwaysEnabled:).	^descriptions</body></methods><methods><class-id>L10n.MenuViewer</class-id> <category>RBcompatibility</category><body package="L10n-RBSupport">codeModel	^codeModel</body><body package="L10n-RBSupport">codeModel: aCodeModel 	codeModel := aCodeModel</body><body package="L10n-RBSupport">isEditing	^false</body><body package="L10n-RBSupport">menu	^Menu new</body><body package="L10n-RBSupport">resetBuilder	self builder: nil.</body><body package="L10n-RBSupport">saveState	""</body><body package="L10n-RBSupport">updateContents		self		menuPath:			(self menuResource				findPathToUserMessage:					self codeModel navigator l10n parent selectedUserMessage).	(self widgetAt: #previewMenuButton) menu: self menuResource.</body><body package="L10n-RBSupport">windowSpecMethod	"return the name of our windowSpec"	^#windowSpec</body></methods><methods><class-id>L10n.MenuViewer</class-id> <category>tabAPI</category><body package="L10n-RBSupport">isActive	^false</body><body package="L10n-RBSupport">isActiveInL10n	| aMethod |	codeModel selector ifNil: [^false].	aMethod := codeModel methodClass		compiledMethodAt: codeModel selector		ifAbsent: [^false].	^aMethod resourceType = #menu</body><body package="L10n-RBSupport">isDefaultSelectionCandidate	^true</body><body package="L10n-RBSupport">tabGraphic	| row text |	row := VisualRow new.	text := Label		with: self tabName		attributes: self tabStyle.	text		offset:			(row components isEmpty				ifTrue: [4]				ifFalse: [2]) @ 0.	row add: text.	^row</body><body package="L10n-RBSupport">tabName	^'Preview'</body><body package="L10n-RBSupport">tabStyle	"This is an undesirable hack. We'd like to not set any style at all on these, and be able to have them 'inherit' the style of the tab control as it walk down the display tree, but we're not there yet, so we do this ugly reach out and infer it thing."	^Screen default defaultWidgetPolicy lookPolicyClass systemWidgetTextStyle</body></methods><methods><class-id>L10n.MenuViewer</class-id> <category>accessing</category><body package="L10n-RBSupport">menuPath: anObject 	| s st menuPath |	anObject ifNil:[^nil].	anObject isString 		ifFalse: 			[st := String new writeStream.			anObject do: 					[:each | 					st nextPutAll: each label.					st nextPutAll: ' -&gt; '].			s := st contents.			s size &gt; 4 ifTrue: [s := s copyFrom: 1 to: s size - 4]]		ifTrue: [s := anObject].	menuPath := s. 	menuPath isEmpty ifTrue:[menuPath := 'nix da'].	(self widgetAt: #Path) labelString: menuPath</body><body package="L10n-RBSupport">method	^self codeModel navigator definition method</body><body package="L10n-RBSupport">method: anObject	method := anObject</body><body package="L10n-RBSupport">model	^model</body><body package="L10n-RBSupport">model: anObject	model := anObject</body><body package="L10n-RBSupport">parent	"Dummy method template.  This was installed by the debugger	define method command."	^parent.</body><body package="L10n-RBSupport">parent: aModel	"Dummy method template.  This was installed by the debugger	define method command."	^parent := aModel</body></methods><methods><class-id>L10n.MenuViewer</class-id> <category>actions</category><body package="L10n-RBSupport">editSpec	| editorClass aMethod |	aMethod := self method.	aMethod isNil ifTrue: [^self].	editorClass := self editorClass.	editorClass isNil ifTrue: [^self].	editorClass new openOnClass: aMethod mclass soleInstance		andSelector: aMethod selector	"implementingClass"</body></methods><methods><class-id>L10n.MenuViewer</class-id> <category>interface opening</category><body package="L10n-RBSupport">postBuildWith: aBuilder 	self menuPath: (self menuResource 				findPathToUserMessage: self codeModel navigator l10n parent selectedUserMessage)</body></methods><methods><class-id>L10n.MenuViewer</class-id> <category>utilities</category><body package="L10n-RBSupport">initializeMenu: aMenu 		aMenu 		values: (aMenu values collect: [:each | [self selection value: each]]).	aMenu menuItems do: 			[:each | 			each submenu notNil 				ifTrue: [each submenu: (self initializeMenu: each submenu)]].	^aMenu</body><body package="L10n-RBSupport">menuResource	| aMenu |	aMenu := 			[self initializeMenu: (Localisator default 						menuFromMethod: self codeModel definition method)] 					on: Error					do: [:ex | ex return: Menu new].	^aMenu</body></methods><methods><class-id>L10n.MenuViewer</class-id> <category>updating</category><body package="L10n-RBSupport">updateDisplay	"Update all parts of the model (subcanvases). This is sent by #postOpenWith: and when a tool is switched to the foreground."</body></methods><methods><class-id>L10n.MenuViewer</class-id> <category>private</category><body package="L10n-RBSupport">editorClass	| class |	class := #{MenuEditor} valueOrDo: [nil].	class isNil 		ifTrue: 			[Dialog warn: (#UIPainternotloaded &lt;&lt; #Localizer &gt;&gt; 'UIPainter not loaded.').			^nil].	^class</body></methods><methods><class-id>L10n.MenuViewer</class-id> <category>aspects</category><body package="L10n-RBSupport">selection	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selection isNil		ifTrue:			[selection := nil asValue]		ifFalse:			[selection]</body></methods><methods><class-id>L10n.MenuViewer class</class-id> <category>As yet unclassified</category><body package="L10n-RBSupport">codeModel: aCodeModel 	^(self new)		codeModel: aCodeModel;		yourself</body></methods><methods><class-id>L10n.MenuViewer class</class-id> <category>instance creation</category><body package="L10n-RBSupport">inParent: aParent 	"Dummy method template.  This was installed by the debugger	define method command."	| viewer |	viewer := self new.	viewer parent: aParent.	^viewer</body></methods><methods><class-id>L10n.XMLImporter class</class-id> <category>instance creation</category><body package="L10n-TMX">fromFile: aFilename using: aXMLReaderClass notice: aNotice	| stream x |	stream := (aFilename asFilename withEncoding: #autodetectOrUtf8) readStream.	stream lineEndAuto.	x := XML.XMLParser on: stream.	x handlers: aXMLReaderClass new.	x validate: false.	Notice		showNotice: aNotice		complete: 1		while: [x scanDocument]	"notifications in: TMXSoxDriver startElement: namespaceURI localName: localName qName: name attributes: attributes "</body></methods><methods><class-id>L10n.ExistingTranslationsUI</class-id> <category>aspects</category><body package="L10n-UI">existingTranslations	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^existingTranslationsList isNil 		ifTrue: [existingTranslationsList := SelectionInList new]		ifFalse: [existingTranslationsList]</body><body package="L10n-UI">matching	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^matching isNil ifTrue: [matching := 0 asValue] ifFalse: [matching]</body><body package="L10n-UI">numberToShow	^numberToShow isNil 		ifTrue: [numberToShow := String new asValue]		ifFalse: [numberToShow]</body></methods><methods><class-id>L10n.ExistingTranslationsUI</class-id> <category>accessing</category><body package="L10n-UI">acceptTranslation	"This stub method was generated by UIDefiner"	^self parent acceptTranslation: (self existingTranslations selection first translated)</body><body package="L10n-UI">doubleClickOnExistingTranslation	self acceptTranslation</body><body package="L10n-UI">parent	"returns the parent"	^parent</body><body package="L10n-UI">parent: aModel	"sets parent to aModel"	^parent := aModel</body></methods><methods><class-id>L10n.ExistingTranslationsUI</class-id> <category>events</category><body package="L10n-UI">checkForMatchingEnter: event inController: controller	"if enter was pressed in the matching spinBox, then send matching changed"	(event keyValue = Core.Character cr and: [event metaState = 0])		ifTrue: 			[controller accept.			^nil].	^event</body><body package="L10n-UI">singleClickOnExistingTranslation	"tells the parent that another existing translation is selected"	^self parent existingTranslationsChangedTo: self existingTranslations selection</body></methods><methods><class-id>L10n.ExistingTranslationsUI</class-id> <category>private</category><body package="L10n-UI">selectFirstTranslation	self existingTranslations list size &gt; 0 		ifTrue: [self existingTranslations selectionIndex: 1].	^self existingTranslations selection</body><body package="L10n-UI">selectNextTranslation	"selects the next translation in the list"	self existingTranslations 		selectionIndex: (self existingTranslations selectionIndex + 1				min: self existingTranslations list size).	^self existingTranslations selection</body><body package="L10n-UI">selectPreviousTranslation	"select the previous translation"	self existingTranslations 		selectionIndex: (self existingTranslations selectionIndex - 1 max: 1).	^self existingTranslations selection</body><body package="L10n-UI">setList: aList 	"sets the list to aList and displays them as settings require"	list := aList.	self updateList</body><body package="L10n-UI">updateList	"sets the number of items to show to the list of existing translations, if the number is 0 then show all"	L10nSettings default numbersToShow = 0 		ifTrue: [self existingTranslations list: list]		ifFalse: 			[self existingTranslations list: (list copyFrom: 1						to: (L10nSettings default numbersToShow min: list size))]</body></methods><methods><class-id>L10n.ExistingTranslationsUI</class-id> <category>changing</category><body package="L10n-UI">matchingChanged	"saves the new Matching value and updates the list of existing translations"	| newMatch oldMatch |	newMatch := self matching value.	oldMatch := L10nSettings default matching.	newMatch = oldMatch ifTrue: [^nil].	L10nSettings default matching: newMatch.	newMatch &gt; oldMatch 		ifTrue: 			["use the current list and just drop the ones which don't match anymore"			self setList: (list select: [:each | each first match &gt;= newMatch])]		ifFalse: 			["request a new list"			self triggerEvent: #updateExistingTranslations]</body><body package="L10n-UI">numberToShowChanged	"the number of items in the list of existing translations have changed and the list has to be updated"	| selectionIndex choices |	choices := self numbersToShow value.	selectionIndex := ((choices collect: #asString)				indexOf: self numberToShow value asString) max: 1.	L10nSettings default		showAmountOfExistingTranslations: (#(#showAll #'1' #'3' #'10' #'25' #'50' #'100')				at: selectionIndex).	"#numberToShow can contain a UserMessage or a String. 	If the user selected something from the menu, it's set to a String.	the following code ensures that a UserMessage is set again.	The UserMessage is necessary to have the label updated when the language is changed"	(self numberToShow value = (choices at: selectionIndex))		ifFalse: [self numberToShow value: (choices at: selectionIndex)].	self updateList</body></methods><methods><class-id>L10n.ExistingTranslationsUI</class-id> <category>initialize-release</category><body package="L10n-UI">updateDisplay	"updates the widgets"	self numberToShow 		value: L10nSettings default showAmountOfExistingTranslations.	self matching value: L10nSettings default matching.	self triggerEvent: #updateExistingTranslations.	^self</body></methods><methods><class-id>L10n.ExistingTranslationsUI</class-id> <category>interface opening</category><body package="L10n-UI">postBuildWith: aBuilder	(self widgetAt: #Listenfeld2) editor controller		keyboardHook: [:event :controller | self checkForMatchingEnter: event inController: controller].	self updateDisplay</body></methods><methods><class-id>L10n.ExistingTranslationsUI</class-id> <category>choices</category><body package="L10n-UI">numbersToShow	^((Array with: #Showall &lt;&lt; #Localizer &gt;&gt; 'Show all')		, #('1' '3' '10' '25' '50' '100')) asValue</body></methods><methods><class-id>L10n.ExistingTranslationsUI class</class-id> <category>instance creation</category><body package="L10n-UI">inParent: aModel 	"returns a new instance and set's the parent to aModel."	| viewer |	viewer := self new.	viewer parent: aModel.	^viewer</body></methods><methods><class-id>L10n.TemporaryTranslationCatalog</class-id> <category>accessing</category><body package="L10n-MessageCatalogs">lookUp: aUserMessage	^self class translationProvider lookUp: aUserMessage forLanguageAndTerritory: language</body><body package="L10n-MessageCatalogs">priority	^100</body></methods><methods><class-id>L10n.TemporaryTranslationCatalog class</class-id> <category>private</category><body package="L10n-MessageCatalogs">translationProvider	^TemporaryTranslationStore default</body></methods><methods><class-id>L10n.SystemUserMessages</class-id> <category>utility</category><body package="L10n-UM-Collect">ableToCreateUserMessageWith: anArray 	"get an Array from the Argument of a Message and check for ability to create a Usermessage"	(anArray isKindOf: Array) ifFalse: [^false].	anArray size = 3 ifFalse: [^false].	(anArray contains: [:i | i isString not]) ifTrue: [^false].	(1 to: 3) do: [:i | i &lt; 3 = (anArray at: i) isSymbol ifFalse: [^false]].	^true</body></methods><methods><class-id>L10n.SystemUserMessages</class-id> <category>actions</category><body package="L10n-UM-Collect">collectAllUserMessages	"start the several Collectionmethodes for several Sources"	| version |	version := UserMessageSpecifierVersion new.	version source: #System.	version timeStamp: Timestamp zero.	self collectUserMessagesInVersion: version.	UserMessageTranslationMemory default recalculateTranslationRatesFrom: nil		to: nil</body><body package="L10n-UM-Collect">collectUserMessagesInVersion: aVersion	| allCatalogs |	allCatalogs := I18nCore.I18nFinder findAllCatalogs.	allCatalogs do: 			[:catalog |			catalog validMessages do: 					[:userMessage |					| umt |					umt := UserMessageTranslation new.					umt catalog: catalog name.					umt key: userMessage key.					umt language: #C.					umt version: aVersion.					umt string: userMessage defaultString.					(catalog methodsForMessage: userMessage)						do: [:meth | UserMessageTranslationMemory default saveMethod: meth for: umt]]]</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>private</category><body package="L10n-UI">acceptFinished	self selectedUserMessage translated:true.	self uiForUserMessage selectNextUserMessage.	self setTargetDefaultStringForMessage: self selectedUserMessageOrNil.	self builder window display.	self setTranslationStatusMenu</body><body package="L10n-UI">acceptPreCheck	^Localisator default 		checkBeforeAccepting: self yourTranslation value		forVisualisation: self posibleVisualisation		ofMessage: self selectedUserMessage		inMethods: self methodForCurrentMessageList value values</body><body package="L10n-UI">enableDebugMenu	#{Heeg.L10nDebugging} bindingOrNil ~= nil 		ifTrue: [((self builder menuAt: #menuBar) menuItemLabeled: 'debug') hidden: false. self windowMenuBar updateMenu. self builder window display]</body><body package="L10n-UI">getCurrentMenu		^Localisator default menuFromMethod: self methodForCurrentMessage value method.</body><body package="L10n-UI">getCurrentMethod		^self methodForCurrentMessage value ifNil: [nil] ifNotNil: [:x | x method]</body><body package="L10n-UI">getCurrentSourceCode	self methodForCurrentMessage value ifNil: [^String new].	^Localisator default 		getSourceCodeForMethod: self methodForCurrentMessage value method</body><body package="L10n-UI">getMessagesForSelectedMethod	self methodForCurrentMessage value ifNil: [^Array new].	self methodForCurrentMessage value method ifNil: [^Array new].	self selectedUserMessage ifNil: [^Array new].	^Localisator default 		getMessagesForMethod: self methodForCurrentMessage value method		catalog: self selectedUserMessage catalog		sourceLang: self sourceLangSpec value		targetLang: self targetLangSpec value</body><body package="L10n-UI">getTermMenu	^Localisator default getTermMenuForSourceDefaultString: self sourceDefaultString value</body><body package="L10n-UI">labelString	^(#localizer &lt;&lt; #Localizer &gt;&gt; 'Localizer') asString</body><body package="L10n-UI">methodListForUserMessage: aUserMessageListEntry 	^Localisator default 		methodForMessage: aUserMessageListEntry		from: self sourceLangSpec value</body><body package="L10n-UI">posibleVisualisation	"checks if there is a method that either supplies a menu, or a canvas."	self methodForCurrentMessage value ifNil: [^nil].	self methodForCurrentMessage value method ifNil: [^nil].	^Localisator default 		visualizationForMethod: self methodForCurrentMessage value method</body><body package="L10n-UI">refreshUI	"systemMessages have been read, now update the UI, but only if there's an UI to update"	builder ifNil: [^nil].	self setCatalogsAndTerms.	self builder window display.</body><body package="L10n-UI">selectedTerm	"return the termsSubUI's selected term, if there's one selected"	^self termsSubUI selectedTerm</body><body package="L10n-UI">selectedUserMessage	"returns the selectedUserMessage, if none is selected, select one"	^selectedUserMessage 		ifNil: [self uiForUserMessage selectFirstMessage]</body><body package="L10n-UI">selectedUserMessageOrNil	"returns the selectedUserMessage, if it is nil, then don't select one"	^selectedUserMessage</body><body package="L10n-UI">setCatalogsAndTerms	Cursor wait showWhile: 			[self termsSubUI setTerms.			"self termsSubUI setUserMessages."			self catalogsSubUI setCatalogs]</body><body package="L10n-UI">setExistingTranslations	"sets the existingTranslations with no selectedUserMessage"	Cursor wait showWhile: 			[self setExistingTranslationsForMessage: self selectedUserMessageOrNil]</body><body package="L10n-UI">setExistingTranslationsForMessage: aUserMessageListEntry 	"Sets the existingTranslationsList and maybe yourTranslation"	aUserMessageListEntry ifNil: 			[self yourTranslation value: String new.			^self existingTranslationsSubUI setList: Array new].	self existingTranslationsSubUI setList: (Localisator default 				getExistingTranslationsForUserMessage: aUserMessageListEntry				from: self sourceLangSpec value				to: self targetLangSpec value).	self targetDefaultString list size = 0 		ifTrue: 			["if no translation is present yet, set it to the first existing translation"			(self existingTranslationsChangedTo: self existingTranslationsSubUI 						selectFirstTranslation) 				ifNil: 					["if existingTranslationslist is empty then show nothing in yourTranslation"					self yourTranslation value: String new]]</body><body package="L10n-UI">setMessagesForSelectedMethod	"the method changed so update the messages that are contained in this method"	self messagesForSelectedMethod list: self getMessagesForSelectedMethod</body><body package="L10n-UI">setMethods: aList 	self methodForCurrentMessageList value: (MenuForList fromObjects: aList).	(aList isEmpty or: [true]) 		ifTrue: 			[self rbContainerSubUI dependentRB 				environment: (Refactory.Browser.L10nEnvironment onMethods: aList from: self)]		ifFalse: 			[self rbContainerSubUI dependentRB 				environment: ((Refactory.Browser.L10nEnvironment onMethods: aList from: self)						addSearchString: nil;						yourself)].	"self halt."	self rbContainerSubUI dependentRB navigator refreshLists.	aList isEmpty 		ifFalse: 			[self rbContainerSubUI dependentRB navigator 				setState: (self rbContainerSubUI dependentRB navigator state 						definition: aList first).			self rbContainerSubUI dependentRB codeTool update].	self rbContainerSubUI navigatorChanged</body><body package="L10n-UI">setMethodsToList: aList_ 	"self halt."	"self methodListChanged."	| aList |	aList := OrderedCollection new.	aList_ do: [:each | each method ifNotNil: [:x | aList add: x definition]].	self rbContainerSubUI setMethods: aList.	^self methodForCurrentMessageList</body><body package="L10n-UI">setSourceDefaultStringForMessage: aUserMessageListEntry 	self sourceDefaultString value: ((Localisator default 				sourceDefaultStringForUserMessage: aUserMessageListEntry				from: self sourceLangSpec value				to: self targetLangSpec value) asText allBold)</body><body package="L10n-UI">setStatus	"sets the statusfield to the value in the current targetDefaultStrings selection."	self targetDefaultString selectionIndex &gt; 0 		ifTrue: 			[self translationStatus 				value: self targetDefaultString selection version status]		ifFalse: [self translationStatus value: String new]</body><body package="L10n-UI">setTargetDefaultStringForMessage: aUserMessageListEntry 	self targetDefaultString list: (Localisator default 				getTargetDefaultStringForMessage: aUserMessageListEntry				from: self sourceLangSpec value				to: self targetLangSpec value).	self targetDefaultString list size &gt; 0 		ifTrue: [self targetDefaultString selectionIndex: 1].	self targetDefaultStringChanged</body><body package="L10n-UI">setTerminology	"sets the termMenu and the termTable"	self terminologySubUI setTermMenu: self selectedTerm.	self terminologySubUI updateUI.</body><body package="L10n-UI">setTranslationStatusMenu	self translationStatusMenu 		value: UserMessageTranslationMemory default translationStatusMenu</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>menu</category><body package="L10n-UI">acceptWithNewKey	"calls addWithNewKey"	^self AddWithNewKey</body><body package="L10n-UI">activateWriteButton	^Localisator default activateWriteButton</body><body package="L10n-UI">canAddWithNewKey	^(self widgetAt:#addWithNewKey) isEnabled</body><body package="L10n-UI">editExcludelist	"opens the EditExcludeListUI to edit these terms that should not be displayed in the terms menu"	EditExcludeListUI open</body><body package="L10n-UI">emptyTM	"empty the Translation Memory"	UserMessageTranslationMemory default emptyTM ifTrue: [self importFinished]</body><body package="L10n-UI">emptyTerminology		TerminologyController default emptyTerminology.	self refreshUI.</body><body package="L10n-UI">export	"Opens the Export window"	ExportUI open.</body><body package="L10n-UI">exportCatalogs	CatalogExport		exportCatalogs: UserMessageTranslationMemory default getCatalogs		inModel: Localisator default		from: self sourceLangSpec value		to: self targetLangSpec value</body><body package="L10n-UI">exportTerminology	"open the export panel"	TerminologyController default exportTBX</body><body package="L10n-UI">import	"starts the import process"	UserMessageTranslationMemory default import ifTrue: [self importFinished]</body><body package="L10n-UI">importFinished	"import is finished, recalculate translation rates and refresh the UI"	Notice show: #UpdatingSystem &lt;&lt; #Localizer &gt;&gt; 'Updating System'		while: 			[MessageCatalogManager initialize.			self recalculateTranslationrates.			self refreshUI]</body><body package="L10n-UI">importFolder	"Imports a folder of files"	UserMessageTranslationMemory default importFolder 		ifTrue: [self importFinished]</body><body package="L10n-UI">importTerminology	"Imports a terminology textfile"	(TerminologyController default importTBXandDeleteOld: true) 		ifTrue: [self refreshUI]</body><body package="L10n-UI">isMenuItemEnabled: aMenuItem	^true</body><body package="L10n-UI">nextExistingTranslation	"tell the existing translations ui to select the next existing translation"	self existingTranslationsChangedTo: self existingTranslationsSubUI 				selectNextTranslation</body><body package="L10n-UI">nextUserMessage	"tells the subui that provided the current UserMessage to select the nextUserMessage"	self uiForUserMessage selectNextUserMessage</body><body package="L10n-UI">previousExistingTranslation	"tells the existingTranslationUI to select the previous translation"	self existingTranslationsChangedTo: self existingTranslationsSubUI 				selectPreviousTranslation</body><body package="L10n-UI">previousUserMessage	"tells the current subui that supplied the last userMessage to select the previous userMessage"	self uiForUserMessage selectPreviousUserMessage</body><body package="L10n-UI">readSystem	"reads the systems usermessages into the translation memory"	^UserMessageTranslationMemory default readSystemUserMessages</body><body package="L10n-UI">recalculateTranslationrates	UserMessageTranslationMemory default 		recalculateTranslationRatesFrom: self sourceLangSpec value		to: self targetLangSpec value</body><body package="L10n-UI">selectCatalogs	"selects the CatalogsTab"	self selectionTab selectionIndex = 1 		ifFalse: 			[self selectionTab selectionIndex: 1.			self selectionTabChanged]</body><body package="L10n-UI">selectExistingTranslations	"selects tab 1 from termTabs to show the existing translations"	self termTab selectionIndex = 1 		ifFalse: 			[self termTab selectionIndex: 1.			self changedTermTabs]</body><body package="L10n-UI">selectFilter	"give focus to the filter field"	(self widgetAt: #searchField) components first takeKeyboardFocus</body><body package="L10n-UI">selectTerminology	"selects the TerminologyTab"	self termTab selectionIndex = 2 		ifFalse: 			[self termTab selectionIndex: 2.			self changedTermTabs]</body><body package="L10n-UI">selectTerms	"selects the CatalogsTab"	self selectionTab selectionIndex = 2 		ifFalse: 			[self selectionTab selectionIndex: 2.			self selectionTabChanged]</body><body package="L10n-UI">showOptions	"opens the VisualWorks settings with the L10n-Page"	^VisualWorksSettings openManagerPage: #(#tools #l10n)</body><body package="L10n-UI">systemLanguage	"switches between translated and nontranslated system."	Localisator default setLocaleToSystemLanguage: self systemLanguageOn.</body><body package="L10n-UI">systemLanguageOn	^Locale.CurrentLocale languageID = 'C'</body><body package="L10n-UI">termManager	"open the TermManagerUI"	TermManagerUI open.</body><body package="L10n-UI">tmStats	"Opens a window with some statistics about the Translation Memory"	Localisator default tmStats</body><body package="L10n-UI">unloadCatalogs	"open the unload catalogs window"	UnloadCatalogsUI open</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>subUI</category><body package="L10n-UI">canvasViewerSubUI	^canvasViewerSubUI ifNil: [canvasViewerSubUI := CanvasViewer inParent: self]</body><body package="L10n-UI">catalogsSubUI	^catalogsSubUI ifNil: [catalogsSubUI := UserMessagesListUI inParent: self]</body><body package="L10n-UI">existingTranslationsSubUI	^existingTranslationsSubUI ifNil: 			[existingTranslationsSubUI := ExistingTranslationsUI inParent: self.			existingTranslationsSubUI				when: #updateExistingTranslations					send: #setExistingTranslations					to: self;				yourself]</body><body package="L10n-UI">menuViewerSubUI	^menuViewerSubUI ifNil:[menuViewerSubUI := MenuViewer inParent: self]</body><body package="L10n-UI">rbContainerSubUI	^rbComponentSubUI ifNil: [rbComponentSubUI := RBContainer inParent: self]</body><body package="L10n-UI">terminologySubUI	^terminologySubUI 		ifNil: [terminologySubUI := TerminologyUI inParent: self]</body><body package="L10n-UI">termsSubUI	^termsSubUI ifNil: [termsSubUI := TermListUI inParent: self]</body><body package="L10n-UI">uiForUserMessage	"returns the UI that currently has the selectedUserMessage"	^uiForUserMessage ifNil:[uiForUserMessage := self catalogsSubUI]</body><body package="L10n-UI">uiForUserMessage: aUI	"sets the UI that currently has the selectedUserMessage"	^uiForUserMessage := aUI</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>aspects</category><body package="L10n-UI">messagesForSelectedMethod	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^messagesForSelectedMethod isNil		ifTrue:			[messagesForSelectedMethod := SelectionInList new]		ifFalse:			[messagesForSelectedMethod]</body><body package="L10n-UI">methodForCurrentMessage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^methodForCurrentMessage isNil		ifTrue:			[methodForCurrentMessage := nil asValue]		ifFalse:			[methodForCurrentMessage]</body><body package="L10n-UI">methodForCurrentMessageList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^methodForCurrentMessageList 		ifNil: [methodForCurrentMessageList := Menu new asValue]</body><body package="L10n-UI">preview	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^preview isNil		ifTrue:			[preview := SelectionInList new]		ifFalse:			[preview]</body><body package="L10n-UI">selectionTab	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectionTab isNil		ifTrue:			[selectionTab := SelectionInList new]		ifFalse:			[selectionTab]</body><body package="L10n-UI">sourceDefaultString	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sourceDefaultString isNil		ifTrue:			[sourceDefaultString := String new asValue]		ifFalse:			[sourceDefaultString]</body><body package="L10n-UI">sourceLangChoice	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sourceLangChoice isNil		ifTrue:			[sourceLangChoice := List new asValue]		ifFalse:			[sourceLangChoice]</body><body package="L10n-UI">sourceLangSpec	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sourceLangSpec isNil		ifTrue:			[sourceLangSpec := String new asValue]		ifFalse:			[sourceLangSpec]</body><body package="L10n-UI">targetDefaultString	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^targetDefaultString isNil		ifTrue:			[targetDefaultString := SelectionInList new]		ifFalse:			[targetDefaultString]</body><body package="L10n-UI">targetLangChoice	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^targetLangChoice isNil		ifTrue:			[targetLangChoice := List new asValue]		ifFalse:			[targetLangChoice]</body><body package="L10n-UI">targetLangSpec	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^targetLangSpec isNil		ifTrue:			[targetLangSpec := String new asValue]		ifFalse:			[targetLangSpec]</body><body package="L10n-UI">termTab	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^termTab isNil		ifTrue:			[termTab := SelectionInList new]		ifFalse:			[termTab]</body><body package="L10n-UI">translationStatus	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^translationStatus isNil		ifTrue:			[translationStatus := String new asValue]		ifFalse:			[translationStatus]</body><body package="L10n-UI">translationStatusMenu	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^translationStatusMenu isNil		ifTrue:			[translationStatusMenu := List new asValue]		ifFalse:			[translationStatusMenu]</body><body package="L10n-UI">yourTranslation	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^yourTranslation isNil		ifTrue:			[yourTranslation := String new asValue]		ifFalse:			[yourTranslation]</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>actions</category><body package="L10n-UI">AddWithNewKey	"add with new key button was clicked"	| newKey |	self acceptPreCheck ifFalse: [^nil].	newKey := Localisator default 		addWithNewKeyATranslation: self yourTranslation value		ofUserMessage: self selectedUserMessage		inMethod: self getSelectedMethodFromSubRB method		from: self sourceLangSpec value		to: self targetLangSpec value		withStatus: self translationStatus value.	newKey ifNil:[^nil].	"recalculate translationrates, because there's one new message in the current catalog"	self recalculateTranslationrates.	catalogsSubUI refreshSelectedCatalog.	catalogsSubUI refreshSelectedUserMessages:newKey.	self acceptFinished</body><body package="L10n-UI">acceptSearchResults: results 	self filter: results</body><body package="L10n-UI">acceptTranslation	"accept translation button was clicked"	self acceptPreCheck ifFalse: [^nil].	Localisator default 		acceptTranslation: self yourTranslation value asString		ofUserMessage: self selectedUserMessage		from: self sourceLangSpec value		to: self targetLangSpec value		withStatus: self translationStatus value.	catalogsSubUI refreshSelectedCatalog.	self acceptFinished</body><body package="L10n-UI">acceptTranslation: aTranslation 	"sets yourTranslation and accepts the translation"	self yourTranslation value: aTranslation.	self acceptTranslation</body><body package="L10n-UI">checkAccessKey	"opens the AccessKeyFixer window"	AccessKeyFixer 		onModel: self		withLabel: self yourTranslation value		forMethods: (self methodForCurrentMessageList value values 				collect: [:each | each method])		startPos: (MenuItem labeled: self yourTranslation value) 				accessCharacterPosition		userMessage: self selectedUserMessage</body><body package="L10n-UI">checkTranslations	TranslationChecker open</body><body package="L10n-UI">openClass	"opens the selected method in a RefactoringBrowser"	| aMethod |	aMethod := self getCurrentMethod.	aMethod ifNil: [^nil].	Localisator default openClassForMethod: aMethod</body><body package="L10n-UI">selectKey: key inCatalog: catalog	catalogsSubUI selectKey: key inCatalog: catalog</body><body package="L10n-UI">showAll	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>tabChanging</category><body package="L10n-UI">showCatalogs	"shows the catalog subview in the left tabview"		(self widgetAt: #SelectionTab) client: self catalogsSubUI spec: #windowSpec builder: (self catalogsSubUI builder ifNil:[UIBuilder new]).	self catalogsSubUI updateDisplay.</body><body package="L10n-UI">showExistingTranslations	"shows the exisiting translations in the tab under the preview"	self terminologySubUI isVisible:false.	(self widgetAt: #termTab) 		client: self existingTranslationsSubUI		spec: #windowSpec		builder: (self existingTranslationsSubUI builder ifNil: [UIBuilder new])</body><body package="L10n-UI">showRBComponent	"shows the sourcecode in the preview tab"	(self widgetAt: #preview) 		client: self rbContainerSubUI		spec: #windowSpec		builder: (self rbContainerSubUI builder ifNil: [UIBuilder new]).</body><body package="L10n-UI">showTerminology	"shows the terminology in the existing translations tab"	(self widgetAt: #termTab) 		client: self terminologySubUI		spec: #windowSpec		builder: (self terminologySubUI builder ifNil: [UIBuilder new]).	self terminologySubUI isVisible:true.</body><body package="L10n-UI">showTerms	"shows the terms in the left tab"	(self widgetAt: #SelectionTab) 		client: self termsSubUI		spec: #windowSpec		builder: (self termsSubUI builder ifNil: [UIBuilder new])</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>events</category><body package="L10n-UI">accessKeyFixed: aTranslation accept: acceptTranslation 	"aTranslation is the result of the accessKeyFixer and acceptTranslation is a bool that indicates wether to accept translation or not."	self yourTranslation value: aTranslation.	acceptTranslation ifTrue: [self acceptTranslation]</body><body package="L10n-UI">applyTerm: aTerm 	"at selectionStart insert aTerm"	"get the beginning of the selection"	| start stop string yourTranslationWidget wrapper endOfText |	yourTranslationWidget := self widgetAt: #yourTranslation.	start := yourTranslationWidget startBlock stringIndex - 1.	"get the end of the selection"	stop := yourTranslationWidget stopBlock stringIndex.	"get the whole string"	string := self yourTranslation value.	"set the new string with the replacement"	self yourTranslation value: (string 				insertString: aTerm				from: start				to: stop).	endOfText := start + aTerm size + 1.	wrapper := self wrapperAt: #yourTranslation.	wrapper widget controller selectAndScrollFrom: endOfText to: endOfText - 1</body><body package="L10n-UI">keyPress: aKeyboardEvent inEntryController: aController 	"Catch a down arrow in the input field and do the right thing in the list box."	aKeyboardEvent keyValue = #Down 		ifTrue: 			[self uiForUserMessage selectNextUserMessage.			^nil].	aKeyboardEvent keyValue = #Up 		ifTrue: 			[self uiForUserMessage selectPreviousUserMessage.			^nil].	aKeyboardEvent keyValue = Character cr 		ifTrue: 			[searchField 				value: (searchField builder componentAt: #entryField) widget editValue.			^nil].	^aKeyboardEvent</body><body package="L10n-UI">updateTerms	"terms have been changed (edit,new,remove)	 set the TermList and the TermTable new"	self selectionTab selectionIndex = 1 ifFalse: [self termsSubUI setTerms].	self terminologySubUI setTable</body><body package="L10n-UI">updatedSettings	"settings changed, rebuild the UI"	^self refreshUI</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>changing</category><body package="L10n-UI">changedTermTabs	"sets the tab in the lower right corner"	^self termTab selectionIndex = 1 		ifTrue: [self showExistingTranslations]		ifFalse: [self showTerminology]</body><body package="L10n-UI">existingTranslationsChangedTo: aUserMessageTranslation 	"sets yourTranslation to the new value"	aUserMessageTranslation isNil 		ifFalse: 			[self yourTranslation value: aUserMessageTranslation first translated].	^aUserMessageTranslation</body><body package="L10n-UI">messagesForSelectedMethodChanged	"a message in the list on the right side of the methods was clicked"	^self 		userMessageChangedWith: self messagesForSelectedMethod selection		updateMethods: false		from: self</body><body package="L10n-UI">methodListChanged	"method list changed, select the first or a nil entry"	| values |	(values := self methodForCurrentMessageList value values) isEmpty 		ifTrue: 			[^self methodForCurrentMessage value: (UserMethodListEntry fromMethod: nil)]		ifFalse: [^self methodForCurrentMessage value: values first]</body><body package="L10n-UI">selectionTabChanged	self selectionTab selectionIndex = 1 		ifTrue: [self showCatalogs]		ifFalse: [self showTerms].	(self widgetAt:#searchField) components first widget controller model value:String new."	self acceptSearchResults: String new"</body><body package="L10n-UI">sourceChanged	"sourceLangSpec changed, update the catalogs"	self sourceLangSpec value isSymbol 		ifFalse: [self sourceLangSpec value: self sourceLangSpec value asSymbol].	UserMessageTranslationMemory default 		recalculateTranslationRatesFrom: self sourceLangSpec value		to: self targetLangSpec value.	^self setCatalogsAndTerms</body><body package="L10n-UI">targetChanged	"targetLangSpec changed, update the catalogs"	self targetLangSpec value isSymbol 		ifFalse: [self targetLangSpec value: self targetLangSpec value asSymbol].	L10nSettings default lastTarget: self targetLangSpec value.	^self setCatalogsAndTerms</body><body package="L10n-UI">targetDefaultStringChanged	"Targetdefaultstring changed so update the yourTranslationfield and the status of the current message"	self setStatus.	self targetDefaultString selection isNil 		ifFalse: 			[^self yourTranslation value: self targetDefaultString selection string]</body><body package="L10n-UI">userMessageChangedWith: aUserMessageListEntry from: aUI 	"updates when a userMessage was selected"	self 		userMessageChangedWith: aUserMessageListEntry		updateMethods: true		from: aUI</body><body package="L10n-UI">userMessageChangedWith: aUserMessageListEntry updateMethods: aBool from: aUI 	"updates when a userMessage was selected"	Cursor wait showWhile: 			["saves the new userMessage and then updates the methods and also selects the first"			selectedUserMessage := aUserMessageListEntry.			self uiForUserMessage: aUI.			"change the methods"			aBool 				ifTrue: 					[aUserMessageListEntry isNil 						ifTrue: [self setMethodsToList: Array new]						ifFalse: 							[self 								setMethodsToList: (self methodListForUserMessage: aUserMessageListEntry)]].			"highlight the selected userMessage"			aUserMessageListEntry isNil 				ifTrue: [self rbContainerSubUI deselectUserMessage]				ifFalse: [self rbContainerSubUI selectUserMessage].			"set sourceDefaultString"			self setSourceDefaultStringForMessage: aUserMessageListEntry.			"set targetDefaultString"			self setTargetDefaultStringForMessage: aUserMessageListEntry.			"set existingtranslations"			self setExistingTranslationsForMessage: aUserMessageListEntry.			"set terms in the ExistingTranslations term tab"			self setTerminology.			"change the AddWithNewKey Button's enablement"			(self widgetAt: #addWithNewKey) isEnabled: selectedUserMessage isNil not]</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>accessing</category><body package="L10n-UI">filter	^filter</body><body package="L10n-UI">filter: anObject 	filter := anObject.	Cursor wait showWhile: 			[uiForUserMessage ifNil: [^filter].			(self selectionTabSubUI)				filterChanged;				selectFirstMessage]</body><body package="L10n-UI">searchField	^searchField</body><body package="L10n-UI">searchField: anObject	searchField := anObject</body><body package="L10n-UI">selectionTabSubUI	self selectionTab selectionIndex = 1 		ifTrue: [^self catalogsSubUI]		ifFalse: [^self termsSubUI]</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>userMessageSelection</category><body package="L10n-UI">selectFirstMessage	"select the first UserMessage"	self messagesForSelectedMethod list size &gt; 0 		ifTrue: 			[self messagesForSelectedMethod selectionIndex: 1.			self messagesForSelectedMethodChanged].	^self messagesForSelectedMethod selection</body><body package="L10n-UI">selectNextUserMessage	"select the next UserMessage"	self messagesForSelectedMethod 		selectionIndex: (self messagesForSelectedMethod selectionIndex + 1 				min: self messagesForSelectedMethod list size).	self messagesForSelectedMethodChanged.	^self messagesForSelectedMethod selection</body><body package="L10n-UI">selectPreviousUserMessage	"select the previous UserMessage"	self messagesForSelectedMethod 		selectionIndex: (self messagesForSelectedMethod selectionIndex - 1 max: 1).	self messagesForSelectedMethodChanged.	^self messagesForSelectedMethod selection</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>interface closing</category><body package="L10n-UI">noticeOfWindowClose: aWindow 	"unregistering my events"	UserMessageTranslationMemory default 		removeActionsForEvent: #SystemMessagesRead.	L10nSettings default removeActionsForEvent: #settingsChanged.	Localisator default removeActionsForEvent: #checkAccessKey.	TerminologyController default removeActionsForEvent: #terminologyChanged.</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>As yet unclassified</category><body package="L10n-UI">getSelectedMethodFromSubRB	^self rbContainerSubUI navigator state definition</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>interface opening</category><body package="L10n-UI">postBuildWith: aBuilder 	| searchDriver |	super postBuildWith: aBuilder.	self builder window label: self builder window label asString.	(self widgetAt: #searchField) 		client: searchField		spec: searchField preferredWindowSpec		builder: aBuilder newSubBuilder.	"	searchField continuouslyAccept."	searchDriver := BackgroundSearchDriver new 				patternHolder: searchField entryHolder				searchBlock: [:search | search]				resultHolder: [:results | self acceptSearchResults: results].	searchField entryWidget controller 		prependKeyboardHook: [:event :controller | self keyPress: event inEntryController: controller].	searchDriver search.		"(self widgetAt: #sourceDefaultString) isFromL10n: true."</body><body package="L10n-UI">postOpenWith: aBuilder 	"initializes the interface"	"set the language specs with their choices"	Notice show: #initializing &lt;&lt; #Localizer &gt;&gt; 'initializing'		while: 			[self sourceLangSpec value: L10nSettings default lastSource.			self targetLangSpec value: L10nSettings default lastTarget.			self sourceLangChoice value: Localisator default sourceLangChoice.			self targetLangChoice value: Localisator default targetLangChoice.			"set the tabs on the left"			self selectionTabChanged.			"set the tabs on the lower right"			self changedTermTabs.			self showRBComponent].	Notice show: #loadingData &lt;&lt; #Localizer &gt;&gt; 'loading data'		while: 			["set the catalogs and terms"			self setCatalogsAndTerms.			"set the translation status menu to the states that are allready used somewhere in the translation memory"			self setTranslationStatusMenu.			"enable the debug menu"			self enableDebugMenu.			TerminologyController default 				when: #terminologyChanged				send: #refreshUI				to: self]</body></methods><methods><class-id>L10n.L10nUI</class-id> <category>initialize-release</category><body package="L10n-UI">initialize	super initialize.	searchField := EntryModule new.	self methodForCurrentMessage onChangeSend: #methodChanged to: self.	UserMessageTranslationMemory default		when: #SystemMessagesRead		send: #refreshUI		to: self.	L10nSettings default when: #settingsChanged send: #updatedSettings to: self.	Localisator default when: #checkAccessKey send: #checkAccessKey to: self.	UserMessageTranslationMemory default needsToImportSystem		ifTrue: 			[(Dialog confirm: #Thesystemsusermessagwanttodothisnow &lt;&lt; #Localizer						&gt;&gt; 'The systems usermessages are not imported yet. Do you want to do this now?')				ifTrue: [self readSystem]]</body></methods><methods><class-id>L10n.L10nUI class</class-id> <category>interface opening</category><body package="L10n-UI">open	"Create a running instance of the application and open its user 	interface."	| check |	check := L10nSettings default startupChecks.	check == #OK 		ifTrue: [^self openOn: self new]		ifFalse: 			[Dialog 				warn: (#Thereisaproblemwithyourpathsettings &lt;&lt; #Localizer 						&gt;&gt; 'There is a problem with your path-settings: ') asString 						, check asString.			^nil]</body></methods><methods><class-id>L10n.UserMessagesListUI</class-id> <category>userMessageSelection</category><body package="L10n-UI">deselectUserMessage	"do nothing, is allready selected"	^self.</body><body package="L10n-UI">nextIndexFrom: start to: end direction: dir 	| offset |	offset := dir.		[(start + offset between: 1 and: end) 		and: [(self userMessages list at: start + offset) translated]] 			whileTrue: [offset := offset + dir].	^offset</body><body package="L10n-UI">selectFirstMessage	"selects the first element of the list and returns this"	| aList userMessage |	self userMessages list size &gt; 0 ifFalse: [^nil].	L10nSettings default removeTranslatedEntries 		ifFalse: 			[aList := self userMessages list.			1 to: aList size				do: 					[:i | 					userMessage := aList at: i.					userMessage translated 						ifFalse: 							[self userMessages selection: userMessage.							^userMessage]]].	self userMessages selectionIndex: 1.	^self userMessages selection</body><body package="L10n-UI">selectNextUntranslatedUserMessageInDirection: dir 	| start end offset |	start := self userMessages selectionIndex.	L10nSettings default skipTranslatedEntries 		ifTrue: 			[end := self userMessages list size.			offset := self 						nextIndexFrom: start						to: end						direction: dir.			((start + offset between:1 and: end) 				and: [(self userMessages list at: start + offset) translated not]) 					ifTrue: [self userMessages selectionIndex: start + offset]].	^start</body><body package="L10n-UI">selectNextUserMessage	"selects the first element of the list and returns this"	"if no message was found or translated entries should not be skipped, just select the next"	| start dir |	self userMessages list size &gt; 0 ifFalse: [^nil].	dir := 1.	start := self userMessages selectionIndex.	self selectNextUntranslatedUserMessageInDirection: dir.	start = self userMessages selectionIndex 		ifTrue: 			[self userMessages selectionIndex: (self userMessages selectionIndex + 1 						min: self userMessages list size)].	^self userMessages selection</body><body package="L10n-UI">selectPreviousUserMessage	"selects the userMessage at selectionIndex-1"	| dir start |	self userMessages list size &gt; 0 ifFalse: [^nil].	dir := -1.	start := self userMessages selectionIndex.	self selectNextUntranslatedUserMessageInDirection: dir.	start = self userMessages selectionIndex 		ifTrue: 			[self userMessages 				selectionIndex: (self userMessages selectionIndex - 1 max: 1)].	^self userMessages selection</body><body package="L10n-UI">selectUserMessage	"do nothing, is allready selected"	^self.</body></methods><methods><class-id>L10n.UserMessagesListUI</class-id> <category>private</category><body package="L10n-UI">filterChanged	"filter changed, update userMessages"	self getUserMessages."	self builder window display"</body><body package="L10n-UI">getFilteredList	| list displayedList filter sLangSpec tLangSpec |	sLangSpec := self parent sourceLangSpec value.	tLangSpec := self parent targetLangSpec value.	sLangSpec isEmpty ifTrue: [sLangSpec := L10nSettings default lastSource].	tLangSpec isEmpty ifTrue: [tLangSpec := L10nSettings default lastTarget].	list := SortedCollection withAll: (Localisator default 						getUserMessagesForCatalog: self systemCatalog value						sourceLangSpec: sLangSpec						targetLangSpec: tLangSpec)				sortBlock: [:a :b | a &lt; b].	filter := '*' , self parent filter , '*'.	displayedList := L10nSettings default removeTranslatedEntries 				ifFalse: 					[list do: 							[:each | 							each 								isFiltered: (filter match: each displayStringWithoutCatalog asString) not]]				ifTrue: 					[list do: 							[:each | 							each 								isFiltered: ((filter match: each displayStringWithoutCatalog asString) 										and: [each translated not]) not]].	displayedList reSort.	^displayedList</body><body package="L10n-UI">getUserMessages	"loads all available userMessages and sets them into the list, but taking care of the filter"	| displayedList |	displayedList := self getFilteredList.	self userMessages setList: displayedList		selecting: nil."(displayedList size &gt; 0 ifTrue: [displayedList first] ifFalse: [])"</body><body package="L10n-UI">refreshSelectedCatalog	"sets the translated value of the selected catalog to the value in the translationMemory"	(self widgetAt: #systemCatalogsList) ifNotNil: #invalidate</body><body package="L10n-UI">refreshSelectedUserMessages	"loads the list without notifying all dependencies"	self userMessages refreshList: self getFilteredList</body><body package="L10n-UI">refreshSelectedUserMessages: aNewKey	"loads the list without notifying all dependencies"	self userMessages selection key: aNewKey.	self userMessages refreshList: self getFilteredList</body><body package="L10n-UI">selectFirstCatalog	self systemCatalogsMenu value values do: 			[:each |			each translated &lt; each absolute ifTrue: [^self systemCatalog value: each]].	self systemCatalogs value notEmpty		ifTrue: 			[self systemCatalog value: self systemCatalogs value first]</body><body package="L10n-UI">setCatalogs	"sets the catalogsmenu and selects the first with untranslated messages"	self systemCatalogs		value: (Localisator default systemCatalogs).	self systemCatalogs value notEmpty 		ifTrue: 			[self selectFirstCatalog.			self systemCatalogChanged]</body><body package="L10n-UI">updateDisplay	"we moved to a subcanvas and need to update"</body></methods><methods><class-id>L10n.UserMessagesListUI</class-id> <category>changing</category><body package="L10n-UI">systemCatalogChanged	"catalog changed, load the userMessages"	self getUserMessages.	self selectFirstMessage</body><body package="L10n-UI">userMessageChanged	self parent userMessageChangedWith: self userMessages selection from: self</body></methods><methods><class-id>L10n.UserMessagesListUI</class-id> <category>accessing</category><body package="L10n-UI">parent	^model</body><body package="L10n-UI">parent: anObject	model := anObject</body></methods><methods><class-id>L10n.UserMessagesListUI</class-id> <category>interface opening</category><body package="L10n-UI">postBuildWith: aBuilder 		self parent uiForUserMessage: self</body></methods><methods><class-id>L10n.UserMessagesListUI</class-id> <category>aspects</category><body package="L10n-UI">systemCatalog	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^systemCatalog isNil		ifTrue:			[systemCatalog := self systemCatalogsSelectionInList selectionHolder]		ifFalse:			[systemCatalog]</body><body package="L10n-UI">systemCatalogs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^systemCatalogs isNil		ifTrue:			[systemCatalogs := #() asValue]		ifFalse:			[systemCatalogs]</body><body package="L10n-UI">systemCatalogsMenu	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^systemCatalogsMenu isNil		ifTrue:			[systemCatalogsMenu := Menu new asValue]		ifFalse:			[systemCatalogsMenu]</body><body package="L10n-UI">systemCatalogsSelectionInList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^systemCatalogsSelectionInList isNil		ifTrue: 			[systemCatalogsSelectionInList := (SelectionInList new)						listHolder: self systemCatalogs;						yourself]		ifFalse: [systemCatalogsSelectionInList]</body><body package="L10n-UI">userMessages	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userMessagesList isNil		ifTrue:			[userMessagesList := SelectionInList new]		ifFalse:			[userMessagesList]</body><body package="L10n-UI">userMessages: anObject	self userMessages listHolder: anObject</body><body package="L10n-UI">userMessagesSelectionIndex	^self userMessages selectionIndexHolder.</body><body package="L10n-UI">userMessagesSelectionIndex: anObject	self userMessages selectionIndexHolder: anObject.</body></methods><methods><class-id>L10n.UserMessagesListUI</class-id> <category>interface closing</category><body package="L10n-UI">noticeOfWindowClose: aWindow 	^self userMessagesSelectionIndex retractInterestsFor: #userMessageChanged</body></methods><methods><class-id>L10n.UserMessagesListUI</class-id> <category>initialize-release</category><body package="L10n-UI">initialize	self userMessagesSelectionIndex 		onChangeSend: #userMessageChanged		to: self.	self systemCatalog onChangeSend: #systemCatalogChanged to: self</body></methods><methods><class-id>L10n.UserMessagesListUI</class-id> <category>actions</category><body package="L10n-UI">selectKey: key inCatalog: catalog	self systemCatalog		value: (self systemCatalogs value detect: [:each | each name = catalog]				ifNone: [^self]).	self userMessages		selection: (self userMessages list detect: [:each | each key = key]				ifNone: [^self])</body></methods><methods><class-id>L10n.UserMessagesListUI class</class-id> <category>instance creation</category><body package="L10n-UI">inParent: aModel 	| viewer |	viewer := self new.	viewer parent: aModel.	^viewer</body></methods><methods><class-id>L10n.L10nOverviewTool</class-id> <category>accessing</category><body package="L10n-RBSupport">codeTool	^codeTool</body><body package="L10n-RBSupport">codeTool: anObject	codeTool := anObject</body><body package="L10n-RBSupport">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textHolder isNil		ifTrue: 			[textHolder := (#ThisUserMessageIsNotDByAnyLoadedMethod &lt;&lt; #Localizer						&gt;&gt; 'This UserMessage is not used by any loaded method') asString asValue]		ifFalse: [textHolder]</body></methods><methods><class-id>L10n.L10nOverviewTool</class-id> <category>As yet unclassified</category><body package="L10n-RBSupport">isEditing	^false</body><body package="L10n-RBSupport">updateContents</body><body package="L10n-RBSupport">updateDisplay</body></methods><methods><class-id>L10n.L10nOverviewTool</class-id> <category>tabAPI</category><body package="L10n-RBSupport">isActive	^false</body><body package="L10n-RBSupport">isActiveInL10n	codeTool selector ifNil: [^true].	codeTool methodClass compiledMethodAt: codeTool selector ifAbsent: [^true].	^false</body><body package="L10n-RBSupport">isDefaultSelectionCandidate	^false</body><body package="L10n-RBSupport">tabGraphic	| row text |	row := VisualRow new.	text := Label		with: self tabName		attributes: self tabStyle.	text		offset:			(row components isEmpty				ifTrue: [4]				ifFalse: [2]) @ 0.	row add: text.	^row</body><body package="L10n-RBSupport">tabName	^'Preview'</body><body package="L10n-RBSupport">tabStyle	"This is an undesirable hack. We'd like to not set any style at all on these, and be able to have them 'inherit' the style of the tab control as it walk down the display tree, but we're not there yet, so we do this ugly reach out and infer it thing."	^Screen default defaultWidgetPolicy lookPolicyClass systemWidgetTextStyle</body></methods><methods><class-id>L10n.L10nOverviewTool</class-id> <category>initialize-release</category><body package="L10n-RBSupport">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>L10n.L10nOverviewTool class</class-id> <category>As yet unclassified</category><body package="L10n-RBSupport">codeModel: codeModel 	"gets a codeModel from the RB-codeModel"	^(self new)		codeTool: codeModel;		yourself</body></methods><methods><class-id>L10n.TargetDefaultStringListEntries</class-id> <category>initialize-release</category><body package="L10n-Base-Data">fromList: aList 	"add a list of objects as TargetDefaultStringListEntry objects to myself"	aList 		do: [:each | self add: (TargetDefaultStringListEntry fromEntry: each)]</body><body package="L10n-Base-Data">initialize		"set the sortblock"	sortBlock:= [:a :b | a version timeStamp &gt;= b version timeStamp]</body></methods><methods><class-id>L10n.TargetDefaultStringListEntries class</class-id> <category>instance creation</category><body package="L10n-Base-Data">fromList:aList		^self new fromList: aList.</body></methods><methods><class-id>L10n.UserMessageCatalog</class-id> <category>printing</category><body package="L10n-Base-Data">asString	^self displayString asString</body><body package="L10n-Base-Data">asText	^self displayString</body><body package="L10n-Base-Data">printOn: aStream 	"prints itself on aStream"	super printOn: aStream.	aStream		space;		nextPutAll: name printString</body></methods><methods><class-id>L10n.UserMessageCatalog</class-id> <category>initialize-release</category><body package="L10n-Base-Data">initialize	"Initialize a newly created instance. This method must answer the receiver."	name := nil.	absolute := 1.	translated := 0</body></methods><methods><class-id>L10n.UserMessageCatalog</class-id> <category>accessing</category><body package="L10n-Base-Data">absolute	"returns the amount of messages in the catalog"	^absolute</body><body package="L10n-Base-Data">absolute: anObject	"sets the amount of messages in a catalog"		absolute := anObject</body><body package="L10n-Base-Data">displayString	"displays the catalog in a list"	"partial translated catalogs appear bold	completly translated catalogs appear italic	untranslated catalogs appear normal"	| stream percents catalogName translationRate |	name isNil ifTrue: [^String new].	translationRate := self translationRate.	stream := TextStream on: String new.	catalogName := name asText.	translationRate = 100		ifTrue: [catalogName allItalic]		ifFalse: [translationRate = 0 ifFalse: [catalogName allBold]].	stream nextPutAllText: catalogName.	stream space.	percents := self translationRate printString asText.	translationRate = 100		ifTrue: [percents allItalic]		ifFalse: [translationRate = 0 ifFalse: [percents allBold]].	stream nextPutAllText: percents.	stream nextPut: $%.	stream space.	stream nextPutAll: '('.	stream nextPutAll: self translated printString.	stream nextPutAll: '/'.	stream nextPutAll: self absolute printString.	stream nextPutAll: ') '.	^stream contents</body><body package="L10n-Base-Data">name	"returns the name of a catalog"	^name</body><body package="L10n-Base-Data">name: aCatalogSymbol 	"sets the name of a catalog"	name := aCatalogSymbol</body><body package="L10n-Base-Data">translated	"returns the amount of translated messages in a catalog"	^translated</body><body package="L10n-Base-Data">translated: anObject 	"sets the amount of translated messages in a catalog"	translated := anObject</body><body package="L10n-Base-Data">translationRate	"returns the translation rate of the messages in a catalog"	absolute = 0 		ifFalse: [^(translated * 100 / absolute) asFloat truncateTo: 0.1]		ifTrue: [^0.0]</body></methods><methods><class-id>L10n.UserMessageCatalog</class-id> <category>comparing</category><body package="L10n-Base-Data">= aCatalog 	aCatalog class == UserMessageCatalog 		ifTrue: [self name = aCatalog name ifFalse: [^false]]		ifFalse: [^false].	^true</body><body package="L10n-Base-Data">hash	^self name hash</body></methods><methods><class-id>L10n.UserMessageCatalog class</class-id> <category>instance creation</category><body package="L10n-Base-Data">named: aName 	"Answer a newly created and initialized instance."	| umc |	umc := UserMessageCatalog new.	umc name: aName.	^umc</body><body package="L10n-Base-Data">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>L10n.UserMessageTranslationMemory</class-id> <category>import/export</category><body package="L10n-Base">exportMD	L10nSettings default ownTranslations 		ifTrue: 			[| d |			d := Dictionary new.			d at: #version put: [:aVersion | aVersion source = #Translator].			^translationMD at: d]		ifFalse: [^translationMD]</body><body package="L10n-Base">import	"This imports into the TranslationMemory	UserMessageTranslationMemory default import	"	| pathString |	pathString := Dialog 				requestFileNameWithMessage: #open &lt;&lt; #Localizer 						&gt;&gt; 'Open'				default: 'translations.tmx'				version: #mustBeOld				ifFail: ['']				for: nil.	pathString isEmpty ifTrue: [^false].	self import: pathString.	^true</body><body package="L10n-Base">import: aPath	"This imports into the TranslationMemory 			UserMessageTranslationMemory default import 	"	| path pathString extension progressMessage |	pathString := aPath asString.	pathString isEmpty ifTrue: [^nil].	path := PortableFilename named: pathString.	path isDirectory ifTrue: [^self importFolder: pathString].	progressMessage := #Importing1s &lt;&lt; #Localizer &gt;&gt; 'Importing: &lt;1s&gt;'				expandMacrosWith: path componentStrings last.	extension := path extension ifNotNil: #asUppercase.	extension = '.TMX'		ifTrue: 			[Notice show: progressMessage				while: 					[XMLImporter						fromFile: path asFilename						using: L10nTMXSoxDriver						notice: progressMessage]].	extension = '.CSV'		ifTrue: 			[Notice show: progressMessage				while: 					[SystemChecker isGlossaryImportAvailable						ifFalse: 							[SystemChecker loadGlossaryParcels								ifTrue: [self importCSVCatalogFromFile: path]]						ifTrue: [self importCSVCatalogFromFile: path]]].	extension = '.LBL'		ifTrue: 			[Notice show: progressMessage				while: [CatalogImporter importFile: path into: self]]</body><body package="L10n-Base">importCSVCatalogFromFile: eachFile 	| coll targetLanguage i fileName targetCountry catalog version |	fileName := eachFile tail copyFrom: 1 to: eachFile tail size - 4.	^eachFile extension = '.csv' 		ifTrue: 			[targetLanguage := (Heeg.IsoLanguageCodeConverter default 						shortFor: (fileName copyFrom: 1 to: 3)) asSymbol.			targetCountry := (Heeg.IsoCountryCodeConverter default 						shortFor: (fileName copyFrom: 5 to: 7)) asSymbol.			coll := Heeg.GlossaryReaderTabs read: eachFile.			catalog := (fileName copyFrom: 9 to: fileName size) asSymbol.			i := 0.			version := UserMessageSpecifierVersion source: #Catalog timestamp: Timestamp now.			coll do: 					[:each | 					i := i + 1.					self 						addTranslation: each translated						sourceLanguage: #C						sourceCountry: #none						targetLanguage: targetLanguage						targetCountry: targetCountry						atKey: i printString asSymbol						andCatalog: catalog						forSourceString: each english						version: version].			coll := nil.			ObjectMemory globalGarbageCollect]</body><body package="L10n-Base">importFolder	"This imports into the TranslationMemory	UserMessageTranslationMemory default importFolder	"	| pathString |	pathString := Dialog requestDirectoryName: #ChooseaDirectory &lt;&lt; #Localizer						&gt;&gt; 'Choose a Directory'.	pathString isEmpty ifTrue: [^false].	self importFolder: pathString.	^true</body><body package="L10n-Base">importFolder: pathString	| path |	path := PortableFilename named: pathString.	path directoryContents		do: [:each | self import: (pathString asFilename construct: each)]</body><body package="L10n-Base">loadCnoneCatalog: pathString 	C_noneCatalogImporter importFile: pathString asFilename		into: self.</body><body package="L10n-Base">loadCnoneCatalogs	"loads the folder of the c_none catalogs"	| folder |	folder := L10nSettings default sourceDirectory asFilename construct: 'C'.	folder exists 		ifTrue: 			[folder directoryContents do: 					[:each | 					each asFilename extension = '.lbl' 						ifTrue: [self loadCnoneCatalog: (folder construct: each)]]]</body></methods><methods><class-id>L10n.UserMessageTranslationMemory</class-id> <category>forListAccess</category><body package="L10n-Base">allCatalogs	"returns all catalogs of the TranslationMemory (even loaded catalogs from glossaries)	UserMessageTranslationMemory default allCatalogs	"	| aKey |	allCatalogs isNil 		ifTrue: 			[allCatalogs := SortedCollection new.			(translationMD collection) do: 					[:each | 					aKey := each key at: #catalog.					(allCatalogs privateIncludes: aKey) ifFalse: [allCatalogs add: aKey]]].	^allCatalogs</body><body package="L10n-Base">createCatalogs	"collects all the userMessages in dataMD and sorts them into the catalogs, and counts how many are in each.	UserMessageTranslationMemory default createCatalogs	"	| res bag |	bag := Bag new.	systemCatalogs := SortedCollection sortBlock: [:a :b | a name &lt;= b name].	res := dataMD at: Dictionary new ifAbsent:[OrderedCollection new].	res isEmpty ifTrue: [res := translationMD at: Dictionary new ifAbsent:[OrderedCollection new]].	res do: [:association | bag add: (association key at: #catalog)].	bag valuesAndCountsDo: 			[:v :c | 			| umc |			umc := UserMessageCatalog new.			umc name: v.			umc absolute: c.			systemCatalogs add: umc].	^systemCatalogs</body><body package="L10n-Base">getCatalogs	"returns the catalogs of the system"	^(systemCatalogs select: [:catalog | catalog absolute &gt; 0]) 		asOrderedCollection</body><body package="L10n-Base">messagesAtCatalog: aCatalog from: aSourceLanguage toTarget: aTargetLanguage 	"returns a list of userMessages that are in a catalog from aSourceLanguage and should be translated to aTargetLanguage"	^self 		messagesAtCatalog: aCatalog		method: nil		from: aSourceLanguage		toTarget: aTargetLanguage		dataMD: false		collectionBlock: 			[:association :translated :tempRes | 			| coll |			coll := OrderedCollection new.			tempRes do: 					[:tempValuex | 					| key |					key := association key at: #key.					(key isNil or: [tempValuex isNil]) 						ifFalse: 							[| entry |							entry := ExtentedUserMessageListEntry new.							entry key: key.							entry defaultString: tempValuex.							entry translated: translated.							coll add: entry]].			coll]</body><body package="L10n-Base">messagesAtCatalog: aCatalog method: aMethod from: aSourceLanguage toTarget: aTargetLanguage dataMD: aBool collectionBlock: collBlock 	"returns a list of userMessages that are in a catalog from aSourceLanguage and should be translated to aTargetLanguage"	| aDict res coll tempDict tLang tCult queryDict keys result tempMD sLang sCult tempTM |	queryDict := Dictionary new.	coll := OrderedCollection new.	keys := Set new.	result := Set new.	aDict := Dictionary new.	tempDict := Dictionary new.	"get messages with aCatalog"	aCatalog isNil ifFalse: [aDict at: #catalog put: aCatalog].	aMethod isNil ifFalse: [aDict at: #method put: aMethod].	res := (aBool ifTrue: [dataMD] ifFalse: [translationMD]) at: aDict				ifAbsent: [OrderedCollection new].	"get a new MD containing the translations allready made"	aSourceLanguage isNil 		ifFalse: 			[sLang := aSourceLanguage languageCode.			sCult := aSourceLanguage countryCode.			tempDict at: #sourceLanguage put: sLang asSymbol.			tempDict at: #sourceCountry put: sCult asSymbol].	tLang := aTargetLanguage languageCode.	tCult := aTargetLanguage countryCode.	tempDict at: #catalog put: aCatalog.	tempDict at: #targetLanguage put: tLang asSymbol.	tempDict at: #targetCountry put: tCult asSymbol.	tempTM := translationMD.	"get the translations where aSourceLanguage is the Target"	tempMD := Heeg.DiscriminatedMultiDictionary discriminator: #key identity: true.	tempMD 		addAll: (self getTranslationsToTarget: aSourceLanguage atCatalog: aCatalog).	aCatalog isNil ifFalse: [queryDict at: #catalog put: aCatalog].	res do: 			[:association | 			| translated key tempRes |			key := association key at: #key.			queryDict at: #key put: key.			tempRes := tempMD at: queryDict ifAbsent: [OrderedCollection new].			translated := (tempTM at: queryDict ifAbsent: [OrderedCollection new]) 						isEmpty not.			key isNil ifFalse: [keys add: key].			coll addAll: (collBlock 						value: association						value: translated						value: tempRes)].	keys do: 			[:eachKey | 			"find all entries that have the same key"			| entries entry |			entries := coll select: [:each | each key = eachKey].			"use the first entry"			entries isEmpty 				ifFalse: 					[entry := entries detect: [:each | each = each]								ifNone: [ExtentedUserMessageListEntry new].					"load all entries' defaultString into the current entry"					entry 						defaultString: (entries collect: [:each | each defaultString]) asSet 								asOrderedCollection.					"store the results"					result add: entry]].	^result asSortedCollection: [:a :b | a key &lt;= b key]</body><body package="L10n-Base">messagesAtCatalog: aCatalog method: aMethod toTarget: aTargetLanguage 	"makes a list of the userMessages for one catalog or one method, depending on aCatalog, which has to be #catalog or #method.	the lists entries are either bold or italic, depending on if they're translated yet or not."	^self 		messagesAtCatalog: aCatalog		method: (aMethod ifNotNil: [:x | x definition])		from: nil		toTarget: aTargetLanguage		dataMD: true		collectionBlock: 			[:association :translated :tempRes | 			| key coll |			coll := OrderedCollection new.			key := association key at: #key.			key isNil 				ifFalse: 					["store keys in set"					| entry |					entry := ExtentedUserMessageListEntry new.					entry key: key.					entry defaultString: association.					entry catalog: (association key at: #catalog).					entry translated: translated.					coll add: entry].			coll]</body><body package="L10n-Base">messagesAtMethod: aName fromSource: aSourceLanguage toTarget: aTargetLanguage 	"aKey is either #method or #catalog named aName"	"first get dataMD entries with method and catalogs we need"	| dataMDqueryDict dataMDqueryResults translationForKeysMD aDict sLang sCult tLang tCult queryDict defString coll defStringColl anOtherDict translated translationStateMD |	dataMDqueryDict := Dictionary new.	dataMDqueryDict at: #method put: aName definition.	dataMDqueryResults := OrderedCollection new.	dataMDqueryResults 		addAll: (dataMD at: dataMDqueryDict ifAbsent: [OrderedCollection new]).	"then get subMD's for querying"	sLang := aSourceLanguage languageCode.	sCult := aSourceLanguage countryCode.	tLang := aTargetLanguage languageCode.	tCult := aTargetLanguage countryCode.	"get the subMD for the translated defaultStrings"	aDict := Dictionary new.	aDict at: #targetLanguage put: sLang asSymbol.	aDict at: #targetCountry put: sCult asSymbol.	translationForKeysMD := Heeg.DiscriminatedMultiDictionary 				withAll: (translationMD at: aDict ifAbsent: [OrderedCollection new])				discriminator: #key				identity: true.	"get the subMD for the translation status"	anOtherDict := Dictionary new.	"	anOtherDict at: #sourceLanguage put: sLang value asSymbol.	anOtherDict at: #sourceCountry put: sCult value asSymbol."	anOtherDict at: #targetLanguage put: tLang asSymbol.	anOtherDict at: #targetCountry put: tCult asSymbol.	translationStateMD := Heeg.DiscriminatedMultiDictionary 				withAll: (translationMD at: anOtherDict ifAbsent: [OrderedCollection new])				discriminator: #key				identity: true.	"build the list from the keys"	queryDict := Dictionary new.	coll := Set new.	dataMDqueryResults do: 			[:association | 			| key catalog entry |			key := association key at: #key.			catalog := association key at: #catalog.			"if the catalog is in the current systemCatalog then proceed"			(systemCatalogs includes: (UserMessageCatalog named: catalog)) 				ifTrue: 					["get the translation from the current key"					queryDict at: #key put: key.					queryDict at: #catalog put: catalog.					defStringColl := translationForKeysMD at: queryDict								ifAbsent: [OrderedCollection new].					translated := (translationStateMD at: queryDict								ifAbsent: [OrderedCollection new]) isEmpty 								not.					defString := defStringColl isEmpty 								ifTrue: [nil]								ifFalse: [defStringColl first value].					defString isNil 						ifFalse: 							["add the entry to the collection"							entry := ExtentedUserMessageListEntry new.							entry key: key.							entry defaultString: defString.							entry translated: translated.							coll add: entry]]].	^coll asSortedCollection: [:a :b | a key &lt; b key]</body><body package="L10n-Base">methodForMessage: aMessageListEntry fromC: fromC atCatalog: aCatalog 	"returns the methods that contain aMessage"	| aDict res coll message |	coll := SortedCollection new.	coll sortBlock: [:a :b | a method printString &lt;= b method printString].	aDict := Dictionary new.	aDict at: #key put: aMessageListEntry key.	aDict at: #catalog put: aCatalog asSymbol.	res := dataMD at: aDict ifAbsent: [OrderedCollection new].	fromC 		ifTrue: [message := aMessageListEntry defaultString first value]		ifFalse: 			[message := self sourceStringForKey: aMessageListEntry key						translatedTo: aMessageListEntry defaultString].	res do: 			[:association | 			| keyDict |			association value = message 				ifTrue: 					[keyDict := association key.					(keyDict keys includes: #method) 						ifTrue: 							[| entry |							entry := UserMethodListEntry fromMethod: (keyDict at: #method) method.							entry ifNotNil: [(coll includes: entry) ifFalse: [coll add: entry]]]]].	^coll</body><body package="L10n-Base">resetAllCatalogs	allCatalogs := nil</body></methods><methods><class-id>L10n.UserMessageTranslationMemory</class-id> <category>actions</category><body package="L10n-Base">emptyTM	(Dialog confirm: #AreYouCertainToEmptyTM &lt;&lt; #Localizer 				&gt;&gt; 'Are you certain to empty the TranslationMemory? All translations will be lost') 		ifTrue: 			[translationMD := Heeg.DiscriminatedMultiDictionary discriminator: #key						identity: true.			ObjectMemory garbageCollect.			^true]		ifFalse: [^false]</body><body package="L10n-Base">readSystemUserMessages	"scans the system for all userMessages"	Notice show: #ReadingSystemCatalogs &lt;&lt; #Localizer 				&gt;&gt; 'Reading Systemcatalogs, please be patient'		while: 			[| messages |			self clearDataMD.			ObjectMemory compactMemory.			messages := SystemUserMessages new.			messages collectAllUserMessages.			self loadCnoneCatalogs.			self recalculateTranslationRatesFrom: L10nSettings default lastSource				to: L10nSettings default lastTarget.			self triggerEvent: #SystemMessagesRead]</body><body package="L10n-Base">saveMethod: aMethod for: anUserMessageTranslation 	"saves UserMessages searched in the System into the dataMD"	self addUserMessageTranslation:anUserMessageTranslation withMethod:aMethod.</body></methods><methods><class-id>L10n.UserMessageTranslationMemory</class-id> <category>accessing</category><body package="L10n-Base">addUserMessageTranslation: aUMT withMethod: aMethod 	"adds a UserMessageTranslation together with a method to the dataMD"	self 		atCatalog: aUMT catalog		key: aUMT key		application: aUMT application		culture: aUMT culture		language: aUMT language		source: aUMT source		date: aUMT timeStamp		approved: aUMT approved		method: aMethod		put: aUMT string.	^aUMT</body><body package="L10n-Base">associationsAtCatalog: aCatalog key: aKey application: anApplication culture: aCulture language: aLanguage source: aSource date: aDate approved: aBool method: aMethod 	"returns the associations from dataMD that match the arguments."	| d |	d := IdentityDictionary new.	aCatalog isNil ifFalse: [d at: #catalog put: aCatalog].	aKey isNil ifFalse: [d at: #key put: aKey].	anApplication isNil ifFalse: [d at: #application put: anApplication].	aCulture isNil ifFalse: [d at: #targetCountry put: aCulture].	aLanguage isNil ifFalse: [d at: #targetLanguage put: aLanguage].	aSource isNil ifFalse: [d at: #source put: aSource].	aDate isNil ifFalse: [d at: #date put: aDate].	aBool isNil ifFalse: [d at: #approved put: aBool].	aMethod isNil ifFalse: [d at: #method put: aMethod definition].	^dataMD at: d ifAbsent:[OrderedCollection new].</body><body package="L10n-Base">atCatalog: aCatalog key: aKey application: anApplication culture: aCulture language: aLanguage source: aSource date: aDate approved: aBool method: aMethod put: anObject 	"puts anObject into the dataMD where the arguments specifie"	| d |	d := Heeg.KeyDictionary new.	d at: #catalog put: aCatalog.	d at: #key put: aKey.	d at: #application put: anApplication.	d at: #targetCountry put: aCulture.	d at: #targetLanguage put: aLanguage.	d at: #source put: aSource.	d at: #date put: aDate.	d at: #approved put: aBool.	aMethod definition isNil 		ifFalse: 			[d at: #method put: aMethod definition.			dataMD at: d put: anObject].	^anObject</body><body package="L10n-Base">clearDataMD	dataMD := Heeg.DiscriminatedMultiDictionary discriminator: #key identity: true</body><body package="L10n-Base">messagesForCatalog: aCatalogSymbol	"returns all Messages that are included in aCatalogSymbols catalog"	| |	^self associationsAtCatalog: aCatalogSymbol key: nil application: nil culture: nil language: nil source: nil date: nil approved: nil method: nil.</body><body package="L10n-Base">messagesForKey: aKey 	"returns the message that aKey is associated to in the dataMD"	| d |	d := Dictionary new.	d at: #key put: aKey.	^(self 		associationsAtCatalog: nil		key: aKey		application: nil		culture: nil		language: nil		source: nil		date: nil		approved: nil		method: nil) addAll: (translationMD at: d ifAbsent:[OrderedCollection new])</body><body package="L10n-Base">messagesForKey: aKey inCatalog: aCatalog 	"returns the message that aKey is associated to in the dataMD"	| d res |	d := Dictionary new.	d at: #key put: aKey.	d at: #catalog put: aCatalog.	res:=(self 		associationsAtCatalog: aCatalog		key: aKey		application: nil		culture: nil		language: nil		source: nil		date: nil		approved: nil		method: nil) 			addAll: (translationMD at: d ifAbsent: [OrderedCollection new]);yourself.	res isEmpty ifTrue:[res:=self messagesForKey:aKey].	^res</body><body package="L10n-Base">needsToImportSystem	^dataMD isEmpty</body><body package="L10n-Base">removeAtCatalog: aCatalog key: aKey application: anApplication culture: aCulture language: aLanguage source: aSource date: aDate approved: aBool method: aMethod 	"puts anObject into the dataMD where the arguments specifie"	| d |	d := Heeg.KeyDictionary new.	d at: #catalog put: aCatalog.	d at: #key put: aKey.	d at: #application put: anApplication.	d at: #targetCountry put: aCulture.	d at: #targetLanguage put: aLanguage.	d at: #source put: aSource.	d at: #date put: aDate.	d at: #approved put: aBool.	aMethod isNil ifFalse:[aMethod definition isNil ifFalse: [d at: #method put: aMethod definition]].	^dataMD remove: d ifAbsent:[nil].</body><body package="L10n-Base">translationMD	^translationMD</body></methods><methods><class-id>L10n.UserMessageTranslationMemory</class-id> <category>private</category><body package="L10n-Base">concatLanguage: aLanguage withCountry: aCountry 	"concats aLanguage with aCountry, and if one is empty then the default C and none 	are passed"	| aStream |	aStream := WriteStream on: (String new:5).	aStream nextPutAll: ((aLanguage isNil not and: [aLanguage isEmpty not])			ifFalse: ['C']			ifTrue: [aLanguage]).	aStream nextPutAll: ((aCountry isNil not and: [aCountry isEmpty not])			ifFalse: ['_none']			ifTrue: ['_' , aCountry]).	^aStream contents</body><body package="L10n-Base">recalculateTranslationRatesFrom: aFirstLanguage_ to: anOtherLanguage_ 	"UserMessageTranslationMemory default recalculateTranslationRatesFrom:nil to:nil"	| aFirstLanguage anOtherLanguage keys result |	aFirstLanguage := aFirstLanguage_ ifNil: [''] ifNotNil: [:x | x].	anOtherLanguage := anOtherLanguage_ ifNil: [''] ifNotNil: [:x | x].	self createCatalogs.	self getCatalogs do: 			[:each | 			(L10nSettings default lastSource = #C_none 				or: [L10nSettings default lastSource = #C]) 					ifTrue: 						[result := UserMessageTranslationMemory default 									messagesAtCatalog: each name									method: nil									toTarget: anOtherLanguage]					ifFalse: 						[result := UserMessageTranslationMemory default 									messagesAtCatalog: each name									from: aFirstLanguage									toTarget: anOtherLanguage].			keys := result.			each translated: (keys select: [:eachKey | eachKey translated]) size.			each absolute: keys size]</body><body package="L10n-Base">saveTranslationInTM: anUserMessageTranslation 	"adds aUserMessageTranslation to the translationMemory"	| sources |	sources := (self messagesForKey: anUserMessageTranslation key				inCatalog: anUserMessageTranslation catalog) asSet.	sources isEmpty ifTrue: [sources add: Association new].	sources do: 			[:each | 			| sLang sCult |			each key isNil 				ifTrue: 					[sLang := #C.					sCult := #none]				ifFalse: 					[sLang := (each key at: #targetLanguage ifAbsent: [#C]) ifNil: [#C]								ifNotNil: [:x | x isEmpty ifTrue: [#C] ifFalse: [x asSymbol]].					sCult := (each key at: #targetCountry ifAbsent: [#none]) ifNil: [#none]								ifNotNil: [:x | x isEmpty ifTrue: [#none] ifFalse: [x asSymbol]]].			self 				addTranslation: anUserMessageTranslation string				sourceLanguage: sLang				sourceCountry: sCult				targetLanguage: anUserMessageTranslation language asSymbol				targetCountry: anUserMessageTranslation culture asSymbol				atKey: anUserMessageTranslation key				andCatalog: anUserMessageTranslation catalog				forSourceString: (each value ifNil: [''] ifNotNil: [:x | x])				version: anUserMessageTranslation version]</body><body package="L10n-Base">saveUserMessage: aUMT 	"save aUMT, but this UMT has no method, because it's from a catalogfile"	| d |	d := Dictionary new.	d at: #catalog put: aUMT catalog.	d at: #key put: aUMT key.	d at: #application put: aUMT application.	d at: #targetCountry put: aUMT culture.	d at: #targetLanguage put: aUMT language.	d at: #source put: aUMT source.	d at: #date put: aUMT timeStamp.	d at: #approved put: aUMT approved.	(dataMD at: d ifAbsent: [nil]) ifNil: 			[d at: #method put: (MethodDefinition class: nil selector: nil).			dataMD at: d put: aUMT string]</body><body package="L10n-Base">statistics	"returns a String with statistics about the TM"	| s |	s := String new writeStream.	s		nextPutAll: (#messagesFromSystem &lt;&lt; #Localizer &gt;&gt; 'Messages from system: ') 					asString;		print: dataMD size;		cr.	s		nextPutAll: (#translations &lt;&lt; #Localizer &gt;&gt; 'Translations: ') asString;		print: translationMD size;		cr.	s		nextPutAll: (#TranslationsfromtheTranslator &lt;&lt; #Localizer 					&gt;&gt; 'Translations from the Translator') asString;		nextPut: $:;		space;		print: (translationMD collection 					select: [:each | (each key at: #version) source = #Translator]) size;		cr.	^s contents</body></methods><methods><class-id>L10n.UserMessageTranslationMemory</class-id> <category>TM-access</category><body package="L10n-Base">addTranslation: aString sourceLanguage: aSourceLanguage sourceCountry: aSourceCounty targetLanguage: aTargetLanguage targetCountry: aTargetCountry atKey: aKey andCatalog: aCatalog forSourceString: aSourceString version: aVersion 	^self 		addTranslation: aString		sourceLanguage: aSourceLanguage		sourceCountry: aSourceCounty		targetLanguage: aTargetLanguage		targetCountry: aTargetCountry		atKey: aKey		andCatalog: aCatalog		forSourceString: aSourceString		version: aVersion		status: String new</body><body package="L10n-Base">addTranslation: aString sourceLanguage: aSourceLanguage sourceCountry: aSourceCounty targetLanguage: aTargetLanguage targetCountry: aTargetCountry atKey: aKey andCatalog: aCatalog forSourceString: aSourceString version: aVersion status: aTranslationStatus 	"adds a Translation to the TranslationMemory"	| d version |	aVersion isString 		ifTrue: 			[version := UserMessageSpecifierVersion 						source: aVersion						timestamp: Timestamp now						status: aTranslationStatus]		ifFalse: 			[aVersion isNil 				ifTrue: [version := UserMessageSpecifierVersion empty]				ifFalse: 					[version := UserMessageSpecifierVersion 								source: aVersion source								timestamp: aVersion timeStamp								status: aVersion status]].	aSourceString ifNil: [^self].	d := Heeg.KeyDictionary new.	d at: #sourceString put: aSourceString trimNonUnicode asSymbol.	d at: #sourceLanguage put: aSourceLanguage asSymbol.	d at: #sourceCountry put: aSourceCounty asSymbol.	d at: #targetLanguage put: aTargetLanguage asSymbol.	d at: #targetCountry put: aTargetCountry asSymbol.	d at: #key put: aKey trimNonUnicode asSymbol.	d at: #catalog put: aCatalog trimNonUnicode asSymbol.	d at: #version put: version.	translationMD at: d put: aString trimNonUnicode.	self resetAllCatalogs</body><body package="L10n-Base">allCatalogsLanguagesAndCountriesDo: aBlock	| catalog country language |	translationMD do: 			[:each |			catalog := each key at: #catalog.			language := each key at: #targetLanguage.			country := each key at: #targetCountry.			aBlock value: catalog value: language value: country]</body><body package="L10n-Base">checkForOldOnesIn: sortedRes 	| translationTime keyDict latestTranslation translation aKey aCatalog |	keyDict := Dictionary new.	"for all keys in sortedRes save all indices for each key"	1 to: sortedRes size		do: 			[:i | 			aKey := (sortedRes at: i) first key.			aCatalog := (sortedRes at: i) first catalog.			(keyDict at: aKey -&gt; aCatalog ifAbsentPut: [OrderedCollection new]) add: i].	"for each key tell the translation that it is probably allready translated. do so by telling the latest version, that it hasn't been translated again"	keyDict keysAndValuesDo: 			[:k :indices | 			translationTime := Timestamp new.			latestTranslation := 0.			indices do: 					[:i | 					translation := sortedRes at: i.					translation isOld: true.					translationTime &lt; translation timestamp 						ifTrue: 							[latestTranslation := i.							translationTime := translation timestamp]].			"the latest translation is not old"			(sortedRes at: latestTranslation) isOld: false]</body><body package="L10n-Base">formatTranslationObject: aMessage withResult: anOtherKey from: aSourceLanguage to: aTargetLanguage fromCatalog: aCatalog matching: aNumber atKey: aKey version: version	"puts all the info into a UserMessageTranslationMemory and formats the message aMessage so it shows what characters fit and what characters don't"	| tempArray text res |	res := UserMessageTranslationMatch new.	res match: aNumber.	res catalog: aCatalog.	res source: aSourceLanguage.	res target: aTargetLanguage.	res key: aKey.	res version: version.	res translated: aMessage.	"display the translation in bold and italic letters"	tempArray := aMessage asString				spellingDifferencesWithWord: anOtherKey asString				caseSensitive: L10nSettings default caseSensitiveness.	text := TextStream on: (String new: anOtherKey size).	1 to: tempArray size		do: 			[:i |			| aChar |			aChar := anOtherKey at: i.			(tempArray at: i)				ifTrue: [text emphasis: #bold]				ifFalse: [text emphasis: nil].			text nextPut: aChar].	res text: text contents.	^res</body><body package="L10n-Base">fromAssociation: association getTranslationsForObject: aMessage matchingValue: matchingValue doubles: doubles srcCountry: sCult tarCountry: tCult	"gets an association (key-&gt;message) and puts this as an UserMessageTranslationMatch object into the set "	| match resultString offset aSourceLanguage aTargetLanguage |	offset := 0.	resultString := (association key at: #sourceString) asString.	(association key includesKey: #key) ifFalse: [^nil].	(association key includesKey: #catalog) ifFalse: [^nil].	"do panelty calculations"	((association key at: #targetCountry) = #none		and: [tCult asSymbol ~= #none])			ifTrue: 				[offset := offset							+ (L10nSettings default panaltyTargetNeutralCountry * 100)].	(association key at: #targetCountry) = tCult asSymbol		ifFalse: 			[offset := offset + (L10nSettings default panaltyTargetOtherCountry * 100)].	(association key at: #sourceCountry) = sCult asSymbol		ifFalse: 			[(association key at: #sourceCountry) = #none				ifTrue: 					[offset := offset								+ (L10nSettings default panaltySourceNeutralCountry * 100)]				ifFalse: 					[offset := offset + (L10nSettings default panaltySourceOtherCountry * 100)]].	"calculate the matching"	match := (aMessage				compareWithWord: resultString				caseSensitive: L10nSettings default caseSensitiveness				wordWise: true) - offset.	match &gt;= matchingValue		ifTrue: 			["add the resulting translationMatch to the collection at association into doubles"			aSourceLanguage := self						concatLanguage: (association key at: #sourceLanguage)						withCountry: (association key at: #sourceCountry).			aTargetLanguage := self						concatLanguage: (association key at: #targetLanguage)						withCountry: (association key at: #targetCountry).			(doubles at: association value				ifAbsentPut: [UserMessageTranslationMatchCollection new: 10]) add: (self							formatTranslationObject: aMessage							withResult: resultString							from: aSourceLanguage							to: aTargetLanguage							fromCatalog: (association key at: #catalog)							matching: match							atKey: (association key at: #key)							version: (association key at: #version ifAbsent: [nil]))]</body><body package="L10n-Base">getOriginalsFromSourceAtCatalog: aCatalog 	"returns the originals that are in the catalog aCatalog"	^self 		associationsAtCatalog: aCatalog		key: nil		application: nil		culture: nil		language: nil		source: nil		date: nil		approved: nil		method: nil</body><body package="L10n-Base">getTranslationsForSource: aSourceLanguage toTarget: aTargetLanguage atMessage: aMessage matching: aNumber	"returns all the translations that could translate aMessage. the results have been 	spelled against aNumber	this is for the existing translations"	"for each key tell the translation that it is probably allready translated"	"the latest translation is not old"	| allStrings matches res sourceLang sString sortedRes caseSensitivity |	matches := IdentitySet new.	"to prevent double matches (set is only small and matches are symbols)"	"get translations"	sourceLang := aSourceLanguage languageCode.	allStrings := OrderedCollection new: translationMD size.	self		getTranslationsFromSource: sourceLang		toTarget: aTargetLanguage languageCode		into: allStrings.	"get translations from C if source is en"	(L10nSettings default includeCnone and: [sourceLang = 'en'])		ifTrue: 			[self				getTranslationsFromSource: 'C'				toTarget: aTargetLanguage languageCode				into: allStrings].	"get translations from en if source is C"	(L10nSettings default includeCnone and: [sourceLang = 'C'])		ifTrue: 			[self				getTranslationsFromSource: 'en'				toTarget: aTargetLanguage languageCode				into: allStrings].	"filter those that are not matching good enough"	caseSensitivity := L10nSettings default caseSensitiveness.	allStrings do: 			[:association |			sString := association key at: #sourceString.			(sString isEmpty and: [(association key at: #sourceLanguage) = #C]) not				ifTrue: 					[(sString matchSizeWith: aMessage) &gt;= aNumber						ifTrue: 							[(sString								compareWithWord: aMessage								caseSensitive: caseSensitivity								wordWise: true) &gt;= aNumber								ifTrue: [matches add: association]]]].	"get associations for strings that match"	"get list from the keys"	res := self				translationsSource: aSourceLanguage				target: aTargetLanguage				matches: matches				atMessage: aMessage				matching: aNumber.	"put everything into a sortedCollection"	sortedRes := SortedCollection new: res size.	sortedRes sortBlock: 			[:a :b |			a matching = b matching				ifFalse: [a matching &gt;= b matching]				ifTrue: 					[a size = b size						ifFalse: [a size &gt; b size]						ifTrue: [a latestTranslation catalog &lt;= b latestTranslation catalog]]].	"add all keys to the sorted collection but store the indices for each key"	res do: [:each | each matching &gt; 30 ifTrue: [sortedRes add: each]].	"check the old translations, so that these are drawn red"	self checkForOldOnesIn: sortedRes.	sortedRes reSort.	^sortedRes</body><body package="L10n-Base">getTranslationsFromSource: aSourceLanguage toTarget: aTargetLanguage 	"returns the translations from aSourceLanguage to aTargetLanguage as associations"	| d |	d := Dictionary new.	d at: #sourceLanguage put: aSourceLanguage asSymbol.	d at: #targetLanguage put: aTargetLanguage asSymbol.	^translationMD at: d ifAbsent:[OrderedCollection new]</body><body package="L10n-Base">getTranslationsFromSource: aSourceLanguage toTarget: aTargetLanguage into: aCollection 	"returns the translations from aSourceLanguage to aTargetLanguage as associations"	| d |	d := Dictionary new.	d at: #sourceLanguage put: aSourceLanguage asSymbol.	d at: #targetLanguage put: aTargetLanguage asSymbol.	^translationMD 		at: d		ifAbsent: [OrderedCollection new]		into: aCollection</body><body package="L10n-Base">getTranslationsToTarget: aTargetLanguage atCatalog: aCatalog 	"returns the translations that translate into aTargetLanguage and are from the catalog aCatalog"	aTargetLanguage isNil ifTrue: [^OrderedCollection new].	^self 		getValuesForTranslationFromSource: nil		country: nil		toTarget: aTargetLanguage languageCode		country: aTargetLanguage countryCodeSymbolOrNil		atKey: nil		atCatalog: aCatalog		version: nil</body><body package="L10n-Base">getValuesForTranslationFromSource: aSourceLanguage country: aSourceCountry toTarget: aTargetLanguage country: aTargetCountry atKey: aKey atCatalog: aCatalog version: aVersion 	"queries the translation memory for translations from aSourceLanguage to aTargetLanguage that match aKey"	| d |	d := Dictionary new:7.	aSourceLanguage ifNotNil: [:x | d at: #sourceLanguage put: x asSymbol].	aSourceCountry ifNotNil: [:x | d at: #sourceCountry put: x asSymbol].	aTargetLanguage ifNotNil: [:x | d at: #targetLanguage put: x asSymbol].	aTargetCountry ifNotNil: [:x | d at: #targetCountry put: x asSymbol].	aKey ifNotNil: [d at: #key put: aKey asSymbol].	aCatalog ifNotNil: [d at: #catalog put: aCatalog asSymbol].	aVersion ifNotNil: [d at: #version put: aVersion].	^translationMD at: d ifAbsent: [OrderedCollection new]</body><body package="L10n-Base">pattern: queryString in: string	^string ifNil: [false] ifNotNil: [queryString match: string]</body><body package="L10n-Base">sourceStringForKey: aKey translatedTo: aTranslationString 	"returns the sourceString of a translation where aKey and aTranslationString fit"	| aDict |	aDict := Dictionary new.	aDict at: #key put: aKey.	(translationMD at: aDict ifAbsent: [OrderedCollection new]) do: 			[:association | 			association value = aTranslationString 				ifTrue: 					[(association key at: #sourceLanguage) = #C 						ifTrue: [^(association key at: #sourceString) asString]]].	^String new</body><body package="L10n-Base">translationStatusMenu	| res status |	res := SortedCollection new: 100.	translationMD collection do: 			[:each | 			status := (each key at: #version) status.			(res includes: status) ifFalse: [res add: status]].	^res</body><body package="L10n-Base">translationsSource: aSourceLanguage target: aTargetLanguage matches: matches atMessage: aMessage matching: matchingValue 	"builds a set of List-Entries. res has to be a set. matching is recalculated with the penalties set in the options."	| doubles sCult tCult |	doubles := Dictionary new.	sCult := aSourceLanguage countryCode.	tCult := aTargetLanguage countryCode.	matches do: 			[:association | 			association value ifNotNil: 					["processing the match variation depending of the source and target culture"					self 						fromAssociation: association						getTranslationsForObject: aMessage						matchingValue: matchingValue						doubles: doubles						srcCountry: sCult						tarCountry: tCult]].	^doubles	"dann für diese matches die übersetzungen laden"</body><body package="L10n-Base">userMessagesContainingTerm: aTermString source: source target: target	"returns a list of ExtentedUserMessageListEntries that match aTermString and are maybe translated from source to target"	| d queryString u tLang tCult sLang sCult data q tempMD aDict aKey res tempColl |	aTermString ifNil: [^Array new].	d := Dictionary new.	queryString := '*' , aTermString , '*'.	tLang := target languageCode asSymbol.	tCult := target countryCodeSymbolOrNil.	sLang := source languageCode asSymbol.	sCult := source countryCodeSymbolOrNil.	"get all messages that match the querystring"	data := (source = #C_none or: [source = #C])				ifTrue: 					["if source is C_none look in dataMD"					dataMD collection						select: [:each | self pattern: queryString in: each value]]				ifFalse: 					["if source is not C_none look in translationMD"					d at: #targetLanguage put: tLang.					d at: #targetCountry put: tCult.					d at: #sourceLanguage put: sLang.					d at: #sourceCountry put: sCult.					d at: #sourceString put: [:aString | self pattern: queryString in: aString].					translationMD at: d ifAbsent: [Array new]].	"get all translations that match the languages, to check if the messages are translated or not"	q := Dictionary new.	q at: #targetLanguage put: tLang.	q at: #targetCountry put: tCult.	q at: #sourceLanguage put: sLang.	q at: #sourceCountry put: sCult.	tempMD := translationMD.	aDict := q.	"create ListEntries from the data and return them sorted"	res := SortedCollection new: data size.	tempColl := Set new: data size.	res sortBlock: [:a :b | a key &lt; b key].	data do: 			[:association |			u := ExtentedUserMessageListEntry new.			aKey := association key at: #key.			u key: aKey.			u defaultString: (OrderedCollection with: association).			u catalog: (association key at: #catalog).			aDict at: #key put: aKey.			u translated: (tempMD at: aDict ifAbsent: [Array new]) isEmpty not.			(tempColl includes: u) ifFalse: [tempColl add: u]].	res addAll: tempColl.	^res</body></methods><methods><class-id>L10n.UserMessageTranslationMemory</class-id> <category>initialize-release</category><body package="L10n-Base">initialize	"initializes the MultiDictionaries and the systemCatalogs as well as the preferences to default."	dataMD := Heeg.DiscriminatedMultiDictionary discriminator: #key identity: true.	translationMD := Heeg.DiscriminatedMultiDictionary discriminator: #key				identity: true.	systemCatalogs := Set new.</body></methods><methods><class-id>L10n.UserMessageTranslationMemory class</class-id> <category>initialize-release</category><body package="L10n-Base">new	^super new initialize</body></methods><methods><class-id>L10n.UserMessageTranslationMemory class</class-id> <category>accessing</category><body package="L10n-Base">default	^TM ifNil: [TM := self new]</body></methods><methods><class-id>L10n.UserMessageTranslationMemory class</class-id> <category>class initialization</category><body package="L10n-Base">initialize	TM := nil</body></methods><methods><class-id>L10n.MenuForList</class-id> <category>testing</category><body package="L10n-Base-Data">isFromL10n	"we're in the l10nPackage, so return true"	^true</body></methods><methods><class-id>L10n.MenuForList</class-id> <category>enumerating</category><body package="L10n-Base-Data">select: aBlock	"forwards the selectblock to its values" 	^self values select:aBlock</body></methods><methods><class-id>L10n.MenuForList</class-id> <category>accessing</category><body package="L10n-Base-Data">size	^self numberOfItems</body></methods><methods><class-id>L10n.MenuForList class</class-id> <category>instance creation</category><body package="L10n-Base-Data">fromObjects: aList 	"creates a new MenuForList with aList as labels and values, where labels are taken from the objects displayString"	| m |	m := self 				labelArray: (aList collect: [:each | each displayString])				lines: Array new				values: aList.	1 to: aList size		do: [:i | (m menuItems at: i) labelText: (aList at: i) displayString].	^m</body></methods><methods><class-id>L10n.UserMessageTranslation</class-id> <category>accessing</category><body package="L10n-Base-Data">application	^fullSpecifier application</body><body package="L10n-Base-Data">application: anApplicationSymbol 	^fullSpecifier application: anApplicationSymbol</body><body package="L10n-Base-Data">approved	^approved</body><body package="L10n-Base-Data">approved: anObject	approved := anObject</body><body package="L10n-Base-Data">catalog	^fullSpecifier catalog</body><body package="L10n-Base-Data">catalog: aCatalogSymbol 	^fullSpecifier catalog: aCatalogSymbol</body><body package="L10n-Base-Data">country	^fullSpecifier country</body><body package="L10n-Base-Data">country: aCountrySymbol 	^fullSpecifier country: aCountrySymbol</body><body package="L10n-Base-Data">culture	^fullSpecifier country</body><body package="L10n-Base-Data">culture: aCountrySymbol 	^fullSpecifier country: aCountrySymbol</body><body package="L10n-Base-Data">fullSpecifier	^fullSpecifier</body><body package="L10n-Base-Data">fullSpecifier: anObject	fullSpecifier := anObject</body><body package="L10n-Base-Data">key	^fullSpecifier key</body><body package="L10n-Base-Data">key: aKeySymbol 	^fullSpecifier key: aKeySymbol</body><body package="L10n-Base-Data">langSpecifier	^fullSpecifier langSpecifier</body><body package="L10n-Base-Data">language	^fullSpecifier language</body><body package="L10n-Base-Data">language: aLanguageSymbol 	^fullSpecifier language: aLanguageSymbol</body><body package="L10n-Base-Data">source	^fullSpecifier source</body><body package="L10n-Base-Data">source: aSourceSymbol 	^fullSpecifier source: aSourceSymbol</body><body package="L10n-Base-Data">specifier	^fullSpecifier specifier</body><body package="L10n-Base-Data">string	^string</body><body package="L10n-Base-Data">string: anObject	string := anObject</body><body package="L10n-Base-Data">timeStamp	^fullSpecifier timeStamp</body><body package="L10n-Base-Data">timeStamp: aTimeStamp 	^fullSpecifier timeStamp: aTimeStamp</body><body package="L10n-Base-Data">version	^fullSpecifier version</body><body package="L10n-Base-Data">version: aUserMessageSpecifierVersion 	^fullSpecifier version: aUserMessageSpecifierVersion</body></methods><methods><class-id>L10n.UserMessageTranslation</class-id> <category>comparing</category><body package="L10n-Base-Data">= anUserMessageTranslation 	^self string = anUserMessageTranslation string		and: [self fullSpecifier = anUserMessageTranslation fullSpecifier]</body><body package="L10n-Base-Data">hash	^self string hash + self fullSpecifier hash</body></methods><methods><class-id>L10n.UserMessageTranslation</class-id> <category>printing</category><body package="L10n-Base-Data">printOn: aStream 	aStream nextPutAll: self fullSpecifier printString.	aStream nextPut: $:.	aStream nextPutAll: self string printString.	aStream nextPut: Character cr</body></methods><methods><class-id>L10n.UserMessageTranslation</class-id> <category>initialize-release</category><body package="L10n-Base-Data">initialize	"Initialize a newly created instance. This method must answer the receiver."	fullSpecifier := UserMessageFullSpecifier new.	string := ''.	approved := true.	^self</body></methods><methods><class-id>L10n.UserMessageTranslation class</class-id> <category>instance creation</category><body package="L10n-Base-Data">application: app approved: appr catalog: cata country: count culture: cult fullSpecifier: fullSpec key: key language: lang source: source string: string timeStamp: time version: vers 	| a |	a := self new.	a		application: app;		approved: appr;		catalog: cata;		country: count;		culture: cult;		fullSpecifier: fullSpec;		key: key;		language: lang;		source: source;		string: string;		timeStamp: time;		version: vers.	^a</body><body package="L10n-Base-Data">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Refactory.Browser.L10nBrowserDefinitionTool</class-id> <category>updating</category><body package="L10n-RBSupport">defaultTemplate	^String new</body></methods><methods><class-id>Refactory.Browser.L10nCodeModel</class-id> <category>accessing</category><body package="L10n-RBSupport">activeTools		^tools select: [:each | each isActiveInL10n]</body></methods><methods><class-id>Refactory.Browser.L10nCodeModel class</class-id> <category>accessing</category><body package="L10n-RBSupport">defaultSelectionPolicies	"return the superclasses implementation, as our class lacks some policies"	^self superclass defaultSelectionPolicies</body></methods><methods><class-id>Refactory.Browser.L10nCodeModel class</class-id> <category>tool registration</category><body package="L10n-RBSupport">toolClasses	^self superclass toolClasses</body></methods><methods><class-id>L10nTMXObject</class-id> <category>accessing</category><body package="L10n-TMX">category	^category</body><body package="L10n-TMX">category: anObject	category := anObject</body><body package="L10n-TMX">key	^key</body><body package="L10n-TMX">key: anObject	key := anObject</body><body package="L10n-TMX">src	^src</body><body package="L10n-TMX">src: anObject	src := anObject</body><body package="L10n-TMX">srcLang	^srcLang</body><body package="L10n-TMX">srcLang: anObject	srcLang := anObject</body><body package="L10n-TMX">tar	^tar</body><body package="L10n-TMX">tar: anObject	tar := anObject</body><body package="L10n-TMX">tarLang	^tarLang</body><body package="L10n-TMX">tarLang: anObject	tarLang := anObject</body><body package="L10n-TMX">version	^version</body><body package="L10n-TMX">version: anObject	version := anObject</body></methods><methods><class-id>L10nTMXObject</class-id> <category>xml</category><body package="L10n-TMX">asXMLElement	^XML.Element		tag: #tu		attributes: #()		elements: (Array				with: (self propertyElementNamed: #catalog value: self category)				with: (self propertyElementNamed: #'x-key' value: self key)				with: (self propertyElementNamed: #'x-version' value: self version asString))					, (Array with: (self tuvElementLanguage: self srcLang string: self src)							with: (self tuvElementLanguage: self tarLang string: self tar))</body><body package="L10n-TMX">propertyElementNamed: aName value: aString	^XML.Element		tag: #prop		attributes: (Array with: (XML.Attribute name: #type value: aName))		elements: (Array with: (XML.Text text: aString))</body><body package="L10n-TMX">tuvElementLanguage: language string: aString	^XML.Element		tag: #tuv		attributes: (Array with: (XML.Attribute name: 'xml:lang'						value: (LangSpecConverter convertToRfc3066: language)))		elements: (Array with: (XML.Element						tag: #seg						attributes: #()						elements: (Array with: (XML.Text text: aString))))</body></methods><methods><class-id>L10nTMXObject</class-id> <category>testing</category><body package="L10n-TMX">isExportable	"If the source string is empty, importers cannot handle the translation unit. This can happen if there is a translation imported, but no source"	^src notEmpty</body></methods><methods><class-id>L10nTMXObject class</class-id> <category>utility</category><body package="L10n-TMX">stringForLanguage: languageCode country: countryCode	^languageCode		, (countryCode ~= #none ifTrue: ['_' , countryCode] ifFalse: [''])</body></methods><methods><class-id>L10nTMXObject class</class-id> <category>instance creation</category><body package="L10n-TMX">from: aTM 	^self		srcLang: (self stringForLanguage: (aTM key at: #sourceLanguage) country: (aTM key at: #sourceCountry))		tarLang: (self stringForLanguage: (aTM key at: #targetLanguage) country: (aTM key at: #targetCountry))		category: (aTM key at: #catalog)		key: (aTM key at: #key)		src: (aTM key at: #sourceString)		tar: aTM value		version: (aTM key at: #version ifAbsent: [L10n.UserMessageSpecifierVersion empty])</body></methods><methods><class-id>L10nTMXObject class</class-id> <category>private</category><body package="L10n-TMX">srcLang: aSourceLanguage tarLang: aTargetLanguage category: aCategory key: aKey src: aSourceString tar: aTargetString version: aVersion 	"L10nTMXEntry srcLang: #C_none tarLang: #de category: #test key:#first src: 'the first' tar:'das erste' "	^(self new)		srcLang: aSourceLanguage asString;		tarLang: aTargetLanguage asString;		category: aCategory asString;		key: aKey asString;		src: aSourceString asString;		tar: aTargetString asString;		version: aVersion asString;		yourself</body></methods><methods><class-id>L10n.CatalogExport</class-id> <category>aspects</category><body package="L10n-UI">catalogs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^catalogs isNil		ifTrue:			[catalogs := MultiSelectionInList new]		ifFalse:			[catalogs]</body><body package="L10n-UI">exportDirectory	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^exportDirectory isNil		ifTrue:			[exportDirectory := String new asValue]		ifFalse:			[exportDirectory]</body><body package="L10n-UI">exportSourceLanguage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^exportSourceLanguage isNil		ifTrue:			[exportSourceLanguage := false asValue]		ifFalse:			[exportSourceLanguage]</body><body package="L10n-UI">exportTargetLanguage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^exportTargetLanguage isNil		ifTrue:			[exportTargetLanguage := false asValue]		ifFalse:			[exportTargetLanguage]</body><body package="L10n-UI">sourceLanguage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sourceLanguage isNil		ifTrue: 			[sourceLanguage := ('(&lt;1s&gt;)' asIs expandMacrosWith: self source) asValue]		ifFalse: [sourceLanguage]</body><body package="L10n-UI">targetLanguage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^targetLanguage isNil		ifTrue: 			[targetLanguage := ('(&lt;1s&gt;)' asIs expandMacrosWith: self target) asValue]		ifFalse: [targetLanguage]</body></methods><methods><class-id>L10n.CatalogExport</class-id> <category>actions</category><body package="L10n-UI">export	| baseFolder catalogsToExport |	catalogsToExport := self catalogs selections.	Notice		showProgress: #ExportingCatalogs &lt;&lt; #Localizer &gt;&gt; 'Exporting Catalogs'		complete: catalogsToExport size		while: 			[baseFolder := self exportDirectory value asFilename.			catalogsToExport do: 					[:catalog |					IncrementNotification raiseSignal.					self exportSourceLanguage value						ifTrue: 							[self								exportMessages: (self localizer prepareSourceFileWritingFor: catalog name)								inCatalog: catalog								toFolder: baseFolder / self source].					self exportTargetLanguage value						ifTrue: 							[self								exportMessages: (self localizer prepareTargetFileWritingFor: catalog name)								inCatalog: catalog								toFolder: baseFolder / self target]]].	self closeRequest</body><body package="L10n-UI">exportForAllLanguages	| baseFolder catalogsToExport allMessages messagesPerCatalog messagesPerLanguage language |	allMessages := UserMessageTranslationMemory default translationMD collection.	catalogsToExport := self catalogs selections.	Notice		showProgress: #ExportingCatalogs &lt;&lt; #Localizer &gt;&gt; 'Exporting Catalogs'		complete: catalogsToExport size		while: 			[baseFolder := self exportDirectory value asFilename.			catalogsToExport do: 					[:catalog |					messagesPerCatalog := allMessages select: [:each | (each key at: #catalog) = catalog name].					messagesPerLanguage := messagesPerCatalog								groupedBy: [:each | (each key at: #targetLanguage) -&gt; (each key at: #targetCountry)].					messagesPerLanguage keysAndValuesDo: 							[:lang :messagesAssociations |							language := lang value = #none ifTrue:[lang key] ifFalse:[lang key ,'_',lang value].							language = 'C' ifTrue:[language := 'en'].							self								exportMessages: (self localizer										prepareFileWritingForData: (messagesAssociations))								inCatalog: catalog								toFolder: baseFolder / language].					IncrementNotification raiseSignal]].	self closeRequest</body><body package="L10n-UI">exportMessages: messages inCatalog: catalog toFolder: folder	folder ensureDirectory.	self localizer writeCatalog: catalog intoFolder: folder withData: messages.	messages notEmpty		ifTrue: [MC_FileBTree createNewMapFor: folder / catalog name]</body><body package="L10n-UI">selectDirectory	| path |	path := Dialog requestDirectoryName:'Where do you want to export to?'.	path isEmpty ifTrue:[^self].	self exportDirectory value: path.	self class lastDirectory: path.</body></methods><methods><class-id>L10n.CatalogExport</class-id> <category>accessing</category><body package="L10n-UI">localizer	^localizer</body><body package="L10n-UI">localizer: anObject	localizer := anObject</body><body package="L10n-UI">source	^source</body><body package="L10n-UI">source: anObject	source := anObject</body><body package="L10n-UI">target	^target</body><body package="L10n-UI">target: anObject	target := anObject</body></methods><methods><class-id>L10n.CatalogExport</class-id> <category>initialize-release</category><body package="L10n-UI">initialize	self exportDirectory value: self class lastDirectory.	self exportSourceLanguage value: true.	self exportTargetLanguage value: true.	self source: ''.	self target: ''</body></methods><methods><class-id>L10n.CatalogExport class</class-id> <category>interface specs</category><body package="L10n-UI">exportCatalogs: catalogs inModel: localizer from: sourceLanguage to: targetLanguage	| inst |	inst := self new.	inst catalogs list: catalogs.	inst catalogs selectAll.	inst localizer: localizer.	inst source: sourceLanguage.	inst target: targetLanguage.	^inst open</body><body package="L10n-UI">lastDirectory	^lastDirectory ifNil: ['.' asFilename asAbsoluteFilename asString]</body><body package="L10n-UI">lastDirectory: aString	lastDirectory := aString</body></methods><methods><class-id>L10n.MessageFileParserForL10n</class-id> <category>parsing</category><body package="L10n-UM-Collect">parseMessage: output	| key string |	key := token.	self scanToken.	token = #= ifFalse: [self reportError: ((#errExpectedEquals &lt;&lt; #dialogs &gt;&gt; 'Expected a = after &lt;1s&gt;') expandMacrosWith: key storeString)].	self scanToken.	tokenType = #string ifFalse: [self reportError: ((#errExpectedLiteralString &lt;&lt; #dialogs &gt;&gt; 'Expected a String literal for &lt;1s&gt;') expandMacrosWith: key storeString)].	string := token.	self scanToken.	output at: key put: string</body></methods><methods><class-id>L10n.EditExcludeListUI</class-id> <category>actions</category><body package="L10n-UI">accept	"This stub method was generated by UIDefiner"	TerminologyController default excludeList: self excludelist list.	self closeAndUnschedule</body><body package="L10n-UI">add	"This stub method was generated by UIDefiner"	| entry exList |	entry := Dialog 				request: #pleaseEnterNewTerm &lt;&lt; #Localizer &gt;&gt; 'Please enter a new term'.	entry isEmpty 		ifFalse: 			[exList := self excludelist list.			(exList includes: entry) 				ifFalse: 					[exList add: entry.					self excludelist list: exList]]</body><body package="L10n-UI">cancel	"This stub method was generated by UIDefiner"	^self closeAndUnschedule</body><body package="L10n-UI">openFile	TerminologyController default importExcludeListFromTXT 		ifTrue: [self reloadExcludeList]</body><body package="L10n-UI">remove	"This stub method was generated by UIDefiner"	| exlist |	exlist := self excludelist list.	self excludelist selections do: [:entry | exlist remove: entry].	self excludelist list: exlist</body><body package="L10n-UI">save	TerminologyController default exportExcludeListToTXT</body><body package="L10n-UI">selectAll	"select all entries in the list"	self excludelist selections: self excludelist list.</body></methods><methods><class-id>L10n.EditExcludeListUI</class-id> <category>interface opening</category><body package="L10n-UI">postBuildWith: aBuilder 	self reloadExcludeList.	self builder window controller keyboardProcessor 		keyboardHook: [:ev :c | self doShortCuts: ev]</body><body package="L10n-UI">reloadExcludeList	self excludelist 		list: TerminologyController default excludeList asSortedCollection</body></methods><methods><class-id>L10n.EditExcludeListUI</class-id> <category>events</category><body package="L10n-UI">doShortCuts: event 	"pass event to the toolbar and see if it can handle the event"	self class toolbar menuItems do: 			[:each | 			each shortcutKeyValue = event keyValue 				ifTrue: 					[each shortcutModifierSymbols = event shortcutModifierSymbols 						ifTrue: 							[self perform: each value.							^nil]]].	(event keyValue = Character del or: [event keyValue = Character backspace]) 		ifTrue: 			[self remove.			^nil].	event keyValue = Graphics.TextConstants.Ctrla 		ifTrue: 			[self selectAll.			^nil].	event keyValue = Graphics.TextConstants.ESC ifTrue: [self cancel].	^event</body></methods><methods><class-id>L10n.EditExcludeListUI</class-id> <category>aspects</category><body package="L10n-UI">excludelist	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^excludelist isNil		ifTrue:			[excludelist := MultiSelectionInList new]		ifFalse:			[excludelist]</body></methods><methods><class-id>L10n.EditExcludeListUI</class-id> <category>initialize-release</category><body package="L10n-UI">initialize	"Eine kürzlich erstellte Instanz initialisieren. Diese Methode muss dem Empfänger entsprechen."	super initialize.	" *** Diesen Kommentar mit dem entsprechenden Initialisierungscode ersetzen ***"	^self</body></methods><methods><class-id>L10n.UserMessageTranslationMatch</class-id> <category>accessing</category><body package="L10n-Base-Data">catalog	^catalog</body><body package="L10n-Base-Data">catalog:anObject	catalog:=anObject.</body><body package="L10n-Base-Data">key	^key</body><body package="L10n-Base-Data">key: anObject	key := anObject</body><body package="L10n-Base-Data">match	^match</body><body package="L10n-Base-Data">match: anObject	match := anObject</body><body package="L10n-Base-Data">source	^source</body><body package="L10n-Base-Data">source: anUserMessageTranslationObject	source := anUserMessageTranslationObject</body><body package="L10n-Base-Data">target	^target</body><body package="L10n-Base-Data">target: anUserMessageTranslationObject	target := anUserMessageTranslationObject</body><body package="L10n-Base-Data">text	^text</body><body package="L10n-Base-Data">text:aText	text:=aText</body><body package="L10n-Base-Data">translated	^translated</body><body package="L10n-Base-Data">translated: anObject 	translated := (UserMessageTranslationMemory default 				getValuesForTranslationFromSource: self source languageCode				country: self source countryCodeSymbolOrNil				toTarget: self target languageCode				country: self target countryCodeSymbolOrNil				atKey: self key				atCatalog: self catalog				version: self version) first value				string</body><body package="L10n-Base-Data">version	^version</body><body package="L10n-Base-Data">version: anObject	version := anObject</body></methods><methods><class-id>L10n.UserMessageTranslationMatch</class-id> <category>printing</category><body package="L10n-Base-Data">displayString	"displays the entry in a list"	^self displayString: nil</body><body package="L10n-Base-Data">displayString: anEmphasis 	"displays the entry in a list"	^self displayStringWithStyle: anEmphasis matching: self match</body><body package="L10n-Base-Data">displayStringWithStyle: anEmphasis matching: aNumber	"displays the entry in a list"	| t pos res end |	t := TextStream on: String new.	t emphasis: anEmphasis.	t print: aNumber rounded.	t nextPutAll: '% ' asIs.	t emphasis: nil.	t padTo: 6.	t nextPutAll: self translated.	t nextPutAll: ((String new: (55 - t position max: 1)) 				atAllPut: Character space).	t padTo: 40.	t nextPutAll: ' (' asIs.	pos := t position.	t nextPutAllText: self text.	self text isEmpty ifFalse: [pos := pos + 1].	end := t position.	L10nSettings default showCatalogs 		ifTrue: 			[t nextPutAll: (#translatedIin &lt;&lt; #Localizer &gt;&gt; ' translated in ') asString.			t nextPutAllText: self catalog asText allBold].	res := t contents.	res 		addEmphasis: #(#blue)		removeEmphasis: nil		allowDuplicates: false		from: pos		to: end.	^res</body><body package="L10n-Base-Data">printString	"returns itself as string"	^self displayString asString,')'</body></methods><methods><class-id>L10n.UserMessageTranslationMatch</class-id> <category>initialize-release</category><body package="L10n-Base-Data">initialize	"Initialize a newly created instance. This method must answer the receiver."	match := 0.	source := String new.	target := String new.	catalog:=String new.	^self</body></methods><methods><class-id>L10n.UserMessageTranslationMatch</class-id> <category>comparing</category><body package="L10n-Base-Data">= aUserMessageTranslationMatch 	"compares two userMessageTranslationMatches"	aUserMessageTranslationMatch class == UserMessageTranslationMatch 		ifFalse: [^false].	^self translated = aUserMessageTranslationMatch translated and: 			[self match = aUserMessageTranslationMatch match and: 					[self source = aUserMessageTranslationMatch source and: 							[self target = aUserMessageTranslationMatch target and: 									[self text asString = aUserMessageTranslationMatch text asString 										and: [self catalog = aUserMessageTranslationMatch catalog]]]]]</body><body package="L10n-Base-Data">hash	"hashes the UserMessageTranslationMatch"	^self match hash + self source hash + self target hash + self text hash 		+ self catalog hash</body></methods><methods><class-id>L10n.UserMessageTranslationMatch class</class-id> <category>instance creation</category><body package="L10n-Base-Data">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>L10n.UserMessageSpecifier</class-id> <category>accessing</category><body package="L10n-Base-Data">application	^application</body><body package="L10n-Base-Data">application: anAplicationSymbol	application := anAplicationSymbol</body><body package="L10n-Base-Data">catalog	^catalog</body><body package="L10n-Base-Data">catalog: aCatalogSymbol	catalog := aCatalogSymbol</body><body package="L10n-Base-Data">key	^key</body><body package="L10n-Base-Data">key: aKeySymbol	key := aKeySymbol</body></methods><methods><class-id>L10n.UserMessageSpecifier</class-id> <category>comparing</category><body package="L10n-Base-Data">= aUserMessageSpecifier 	^self application = aUserMessageSpecifier application and: 			[self catalog = aUserMessageSpecifier catalog 				and: [self key = aUserMessageSpecifier key]]</body><body package="L10n-Base-Data">hash	^self application hash + self catalog hash + self key hash</body></methods><methods><class-id>L10n.UserMessageSpecifier</class-id> <category>initialize-release</category><body package="L10n-Base-Data">initialize	"Initialize a newly created instance. This method must answer the receiver."	application := #none.	catalog := #none.	key := #none.	^self</body></methods><methods><class-id>L10n.UserMessageSpecifier</class-id> <category>printing</category><body package="L10n-Base-Data">printOn: aStream 	aStream nextPutAll: application printString.	aStream nextPutAll: ':'.	aStream nextPutAll: catalog printString.	aStream nextPutAll: ':'.	aStream nextPutAll: key printString</body></methods><methods><class-id>L10n.UserMessageSpecifier class</class-id> <category>instance creation</category><body package="L10n-Base-Data">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>L10n.LookUpHelper class</class-id> <category>accessing</category><body package="L10n-Base">openBrowserOn: aTerm inDict: aName 	^self 		navigateTo: (LookUpDictionary default urlForTerm: aTerm inDictionary: aName)</body></methods><methods><class-id>L10n.LookUpHelper class</class-id> <category>testing</category><body package="L10n-Base">canUseLookUp	"lookup is only available when this class is defined"	^true</body></methods><methods><class-id>L10n.LookUpHelper class</class-id> <category>private</category><body package="L10n-Base">navigateTo: aUrl 	"this will open a new window of internet explorer and navigates it to aUrl"	ExternalWebBrowser open: aUrl.	^true.</body></methods><methods><class-id>L10n.TempCatalogStorage</class-id> <category>accessing</category><body package="L10n-Base-Data">saveTranslationInTM: aUMT 	"add an association to myself with the key and the version associated to the UMTstring"	| d |	d := Dictionary new.	d at: #key put: aUMT key.	d at: #version put: UserMessageSpecifierVersion empty.	self add: d -&gt; aUMT string</body></methods><methods><class-id>L10n.TempCatalogStorage class</class-id> <category>instance creation</category><body package="L10n-Base-Data">fromCatalog: aCatalog inFolder: aFolder 	"imports a catalog into a new instance of myself"	| res filename |	res := self new.	filename := aFolder asFilename construct: aCatalog , '.lbl'.	filename exists ifTrue: [CatalogImporter importFile: filename into: res].	^res</body></methods><methods><class-id>L10n.Localisator</class-id> <category>initialize release</category><body package="L10n-Models">initialize</body><body package="L10n-Models">release	super release.	UserMessageTranslationMemory default removeAllActionsWithReceiver: self</body></methods><methods><class-id>L10n.Localisator</class-id> <category>private</category><body package="L10n-Models">activateWriteButton	"returns if the catalogs can be written or not"	^self tempTranslationStore data isEmpty not</body><body package="L10n-Models">folderNamesInside: folderPath	| folder |	folder := folderPath asFilename.	^folder directoryContents select: [:each | (folder / each) isDirectory]</body><body package="L10n-Models">getExistingTranslationsForUserMessage: aUserMessage from: aSourceLangSpec to: aTargetLangSpec 	"returns the existing translations for aUserMessage"	^UserMessageTranslationMemory default 		getTranslationsForSource: aSourceLangSpec		toTarget: aTargetLangSpec		atMessage: aUserMessage sourceString		matching: L10nSettings default matching</body><body package="L10n-Models">getMessagesForMethod: aMethod catalog: aCatalog sourceLang: aSourceLangSpec targetLang: aTargetLangSpec 	"returns the messages for a Method and aCatalog when the given languages are selected"	| sLangSymb |	^((sLangSymb := aSourceLangSpec asSymbol) = #C or: [sLangSymb = #C_none]) 		ifTrue: 			[UserMessageTranslationMemory default 				messagesAtCatalog: aCatalog				method: aMethod				toTarget: aTargetLangSpec]		ifFalse: 			[UserMessageTranslationMemory default 				messagesAtMethod: aMethod				fromSource: aSourceLangSpec				toTarget: aTargetLangSpec]</body><body package="L10n-Models">getTargetDefaultStringForMessage: aUserMessageListEntry from: sourceLangSpec to: targetLangSpec 	"returns the targetDefaultStringListEntries for the requested userMessageListEntry "	aUserMessageListEntry ifNil: [^Array new].	^TargetDefaultStringListEntries 		fromList: (UserMessageTranslationMemory default 				getValuesForTranslationFromSource: sourceLangSpec languageCode				country: sourceLangSpec countryCode				toTarget: targetLangSpec languageCode				country: targetLangSpec countryCode				atKey: aUserMessageListEntry key				atCatalog: aUserMessageListEntry catalog				version: nil)</body><body package="L10n-Models">getUserMessagesContainingTerm: term source: source target: target 	"just pass it through to the tm"	(target isNil or: [target isEmpty]) ifTrue: [^Array new].	(source isNil or: [source isEmpty]) ifTrue: [^Array new].	(term isNil or: [term isEmpty]) ifTrue: [^Array new].	^UserMessageTranslationMemory default 		userMessagesContainingTerm: term		source: source		target: target</body><body package="L10n-Models">getUserMessagesForCatalog: aUserMessageCatalog sourceLangSpec: aSourceLangSpec targetLangSpec: aTargetLangSpec 	"returns the userMessages for aUserMessagesCatalog when the given languages are selected"	aUserMessageCatalog isNil ifTrue:[^#()].	aSourceLangSpec first = $C 		ifTrue: 			[^UserMessageTranslationMemory default 				messagesAtCatalog: aUserMessageCatalog name				method: nil				toTarget: aTargetLangSpec]		ifFalse: 			[^UserMessageTranslationMemory default 				messagesAtCatalog: aUserMessageCatalog name				from: aSourceLangSpec				toTarget: aTargetLangSpec]</body><body package="L10n-Models">menuFromMethod: theMethod 	"creates a menu for theMethod and disables all menuitems"	| class selector tempMethod |	theMethod ifNil: [nil]		ifNotNil: 			[:x | 			x selector = #unboundMethod 				ifFalse: 					[class := theMethod definition implementingClass.					selector := theMethod definition selector.					selector notNil 						ifTrue: 							[tempMethod := class compiledMethodAt: selector ifAbsent: [nil].							(tempMethod notNil and: [tempMethod resourceType == #menu]) 								ifTrue: 									[^[class soleInstance perform: selector] on: Error										do: [:ex | ex return: Menu new]]								ifFalse: [Menu new]]						ifFalse: [Menu new]]].	^Menu new</body><body package="L10n-Models">methodForMessage: aUserMessageListEntry from: sourceLangSpec 	^UserMessageTranslationMemory default 		methodForMessage: aUserMessageListEntry		fromC: (sourceLangSpec = #C or: [sourceLangSpec = #C_none])		atCatalog: aUserMessageListEntry catalog</body><body package="L10n-Models">newTermList	"return a list with all terms but don't have them doubled inside"	| terms sortedTerms |	terms := TerminologyController default allTerms.	sortedTerms := SortedCollection new: terms size.	terms 		do: [:each | (sortedTerms privateIncludes: each) ifFalse: [sortedTerms add: each]].	^sortedTerms</body><body package="L10n-Models">setLocaleToSystemLanguage: systemLanguage	"changes the systems locale settings"	| localeName |	localeName := systemLanguage				ifTrue: [ Locale preferredLocaleName asSymbol]				ifFalse: [#C].	Locale setSystemLocaleTo: localeName.	Dialog		warn: (#LocaleIsSetTo &lt;&lt; #Localizer &gt;&gt; 'Locale is set to: ') asString				, Locale.CurrentLocale languageAndTerritory.	IndexedFileMessageCatalog updateDirectories</body><body package="L10n-Models">sourceDefaultStringForUserMessage: aUserMessageListEntry from: sourceLangSpec to: targetLangSpec 	aUserMessageListEntry ifNil: [^String new].	(sourceLangSpec = #C or: [sourceLangSpec = #C_none]) 		ifTrue: [^aUserMessageListEntry defaultString first value]		ifFalse: 			[| messages |			messages := (UserMessageTranslationMemory default 						messagesAtCatalog: aUserMessageListEntry catalog						from: sourceLangSpec						toTarget: targetLangSpec) 							select: [:each | each key = aUserMessageListEntry key].			messages isEmpty 				ifTrue: [^String new]				ifFalse: [^messages first defaultString first value]]	"set sourceDefaultString"</body><body package="L10n-Models">sourceLangChoice	"returns the directory contents of the sourceDirectory"	^self folderNamesInside: L10nSettings default sourceDirectory</body><body package="L10n-Models">systemCatalogs	"return catalogs"	"if no targetLang is specified, return an empty collection"	L10nSettings default lastTarget isEmpty ifTrue: [^Array new].	^UserMessageTranslationMemory default getCatalogs</body><body package="L10n-Models">systemCatalogsForSource: sourceSpec target: targetSpec	"returns the catalogs for the given languages"	^UserMessageTranslationMemory default createCatalogs</body><body package="L10n-Models">targetLangChoice	"returns the folder content of the targetDirectory without the 'C' folder"	| folders |	folders := self folderNamesInside: L10nSettings default targetDirectory.	^folders copyWithout: 'C' asIs</body><body package="L10n-Models">tmStats	"Shows a Dialog with Statistics about the Translation Memory"	Dialog warn: UserMessageTranslationMemory default statistics</body></methods><methods><class-id>L10n.Localisator</class-id> <category>terminology</category><body package="L10n-Models">availableSources	^(TerminologyController default data collect:[:each | each key at:#source ifAbsent:[nil]]) asSet asSortedCollection</body><body package="L10n-Models">getCurrentTermDictionariesForTerm: aTerm 	"returns the TermEntries that match aTerm, but buffers them"	| tableObjects |	tableObjects := OrderedCollection new.	lastTerm = aTerm ifTrue: [^lastObjects] ifFalse: [lastTerm := aTerm].	(aTerm isNil or: [aTerm isEmpty]) 		ifFalse: 			[(TerminologyController default allTermsContaining: aTerm) do: 					[:each | 					(TerminologyController default excludeList includes: each) 						ifFalse: 							[(TerminologyController default allDatesForTerm: each) 								do: [:anObject | (tableObjects includes: anObject) ifFalse: [tableObjects add: anObject]]]]].	^lastObjects := (tableObjects 				collect: [:each | TerminologyEntry fromDictionary: each key]) 					select: [:each | each isNil not]</body><body package="L10n-Models">getTermMenuForSourceDefaultString: aString	| terms |	terms := aString words reject: 					[:each |					each isExcluded						or: [each isEmpty or: [each allSatisfy: [:c | c isAlphaNumeric not]]]].	^terms asSet sorted: [:each | terms indexOf: each] ascending</body><body package="L10n-Models">removeTerm: aTerm 	"this adds aTerm to the excludeList"	^TerminologyController default excludeTerm: aTerm</body></methods><methods><class-id>L10n.Localisator</class-id> <category>actions</category><body package="L10n-Models">editFinishedForTerm: aTermEntry withData: aDictionary 	"store the data from aDictionary into aTermEntry. if aTermEntry is nil, then add a new term to the TerminologyController."	aTermEntry 		ifNil: [TerminologyController default data add: aDictionary -&gt; Dictionary new]		ifNotNil: 			[aDictionary keys 				do: [:sel | aTermEntry perform: (sel , ':') asSymbol with: (aDictionary at: sel)]].	TerminologyController default rebuildData</body><body package="L10n-Models">editTerm: aTermEntry 	"open the EditTermUI with TermEntry for editing"	^EditTermUI edit: aTermEntry forModel: self</body><body package="L10n-Models">newTerm: aName	"open EditTermUI to create a new Term, name it: aName"	^EditTermUI newForModel: self name: aName.</body><body package="L10n-Models">removeTermEntry: aTermEntry 	"removes a termEntry from the TerminologyController and makes sure the cache is empty, so terminology is reloaded"	aTermEntry isNil ifTrue: [^false].	(Dialog confirm: #DoYouRealyWantToRemoveTheSelectedTerm &lt;&lt; #Localizer 				&gt;&gt; 'Do you realy want to remove the selected term?') 		ifTrue: 			[TerminologyController default removeTermEntry: aTermEntry.			self resetTerminologyTable.			^true].	^false</body><body package="L10n-Models">resetTerminologyTable	lastTerm := nil.	lastObjects := nil</body></methods><methods><class-id>L10n.Localisator</class-id> <category>utilities</category><body package="L10n-Models">nextKeyFor: aKey 	| rKey i aNumberStream n newKey |	"reverse the key, then take each character while they are digits to extract the number, 	add one to the number and put it together again	nextKeyFor: #back34 would be #back35"	rKey := aKey reverse.	i := 1.	aNumberStream := String new writeStream.	[(rKey at: i) isDigit] whileTrue: 			[aNumberStream nextPut: (rKey at: i).			i := i + 1].	"reverse the number string again to convert it into a number"	n := aNumberStream contents reverse asNumber.	"build a new key from the old one plus the new number"	newKey := (aKey copyFrom:1 to: aKey size - i + 1),(n+1) printString.	"return it as symbol"		^newKey asSymbol</body><body package="L10n-Models">openClassForMethod: aMethod 	| aClass browser state |	aClass := aMethod mclass.	browser := Refactory.Browser.RefactoringBrowser open navigator.	browser selectClass: aClass.	state := browser state.	state selector: aMethod selector.	browser		setState: state;		changed;		beHierarchy</body><body package="L10n-Models">prepareFileWritingForData: data	"first &lt;data&gt; is brought into order of timestamps so that old versions appear before new versions. 	Then write everything into a dictionary so that to each key the latest translation is stored.	Returns a Dictionary with the UserMessage-Key to the default-String"	| res userMessageKey defaultString sortedData |	res := Dictionary new.	sortedData := data				sorted: 					[:each |					(each key at: #version ifAbsent: [UserMessageSpecifierVersion empty])						timeStamp]							ascending.	sortedData do: 			[:each |			userMessageKey := each key at: #key.			defaultString := (each value ifNil: [userMessageKey]) asSymbol.			res at: userMessageKey put: defaultString].	^res</body><body package="L10n-Models">prepareSourceFileWritingFor: aCatalog 	"returns a Dictionary of Usermessages for a Catalog."	"add associations to res like: key -&gt; (timestamp -&gt; String)"	| data |	data := UserMessageTranslationMemory default 				getOriginalsFromSourceAtCatalog: aCatalog.	data addAll:(TempCatalogStorage fromCatalog: aCatalog inFolder:L10nSettings default sourcePath).	^self prepareFileWritingForData: data</body><body package="L10n-Models">prepareTargetFileWritingFor: aCatalog 	"returns a Dictionary of Usermessages for a Catalog."	"add associations to res like: key -&gt; (timestamp -&gt; String)"	| data |	data := UserMessageTranslationMemory default 				getTranslationsToTarget: L10nSettings default lastTarget				atCatalog: aCatalog.	data addAll:(TempCatalogStorage fromCatalog: aCatalog inFolder:L10nSettings default targetPath).	^self prepareFileWritingForData: data</body><body package="L10n-Models">visualizationForMethod: listMethod 	"returns #canvas or #menu or nil depending on if it's a resource or not."	| resource |	listMethod class = AnnotatedMethod 		ifTrue: 			[(listMethod attributes keys includes: #resource) 				ifTrue: 					[resource := listMethod attributes at: #resource.					(resource == #canvas or: [resource == #menu]) ifTrue: [^resource]]].	^nil</body><body package="L10n-Models">writeCatalog: cat intoFolder: basePath withData: umDict	| fileName aStream |	cat name isEmpty ifTrue: [^self].	umDict isEmpty ifTrue: [^self].	aStream := nil.	basePath definitelyExists ifFalse: [basePath makeDirectory].	fileName := basePath construct: cat name asString , '.lbl'.	aStream := (fileName withEncoding: #UTF_8) writeStream.		[aStream lineEndCR.	aStream		nextPutAll: 'encoding: #UTF_8';		nextPut: Character cr.	aStream		nextPutAll: 'catalog: ' , cat name;		cr;		cr;		cr.	umDict keys asSortedCollection do: 			[:k |			| translation |			translation := umDict at: k.			(Scanner isLiteralSymbol: k)				ifTrue: 					["should allways be true"					aStream						nextPutAll: k;						nextPutAll: ' = ';						print: translation asString;						cr]]]			ensure: [aStream close]</body></methods><methods><class-id>L10n.Localisator</class-id> <category>acceptingTranslations</category><body package="L10n-Models">acceptTranslation: aTranslation ofUserMessage: _aUserMessage from: aSourceLangSpec to: aTargetLangSpec withStatus: aStatus 	"this accepts your translation and stores it into the tempTranslationStore and the translationMemorie"	| version theCatalog aUserMessageEntry |	aUserMessageEntry := _aUserMessage.	version := UserMessageSpecifierVersion 				source: L10nSettings default translator				timestamp: Timestamp now				status: aStatus.	Notice show: #AddingTranslation &lt;&lt; #Localizer &gt;&gt; 'Adding Translation'		while: 			["get a catalog that maches the catalog symbol in aUserMessageEntry"			| aCatalogSymbol aKeySymbol aUserMessage1 |			theCatalog := UserMessageTranslationMemory default getCatalogs 						detect: [:each | each name = aUserMessageEntry catalog]						ifNone: [nil].			aKeySymbol := aUserMessageEntry key asSymbol.			aCatalogSymbol := theCatalog name asSymbol.			aUserMessage1 := UserMessage 						defaultString: aTranslation						key: aKeySymbol						catalogID: aCatalogSymbol.					"save translation in tempTranslationStore, this is where messages are saved before writing them to disc, and where messages are also looked up first"			self tempTranslationStore 				save: aUserMessage1				with: aKeySymbol				in: aCatalogSymbol				forLang: aTargetLangSpec languageCode				forCountry: aTargetLangSpec countryCode.			"save translation in translation memory"			UserMessageTranslationMemory default 				addTranslation: aTranslation				sourceLanguage: aSourceLangSpec languageCode				sourceCountry: aSourceLangSpec countryCode				targetLanguage: aTargetLangSpec languageCode				targetCountry: aTargetLangSpec countryCode				atKey: aKeySymbol				andCatalog: aCatalogSymbol				forSourceString: aUserMessageEntry sourceString				version: version				status: version status.			"if the message was not translated yet, then the catalog got one more translates message"			aUserMessageEntry translated 				ifFalse: [theCatalog translated: theCatalog translated + 1].			"and ensure that the selected userMessage is now translated"			aUserMessageEntry translated: true]</body><body package="L10n-Models">addWithNewKeyATranslation: aTranslation ofUserMessage: _aUserMessage inMethod: aMethod from: aSourceLangSpec to: aTargetLangSpec withStatus: aStatus 	"creates an overwrite for the selected Method (aMethod) and changes every occurance of the UserMessages key to a new key, so that this message gets a diffrent translation than the "	| key class packageName package aAddMethodChange change oldKey methChange oldTranslations aCatalog newMethod aNewUserMessage classSymbol |	aCatalog := self systemCatalogs 				detect: [:each | each name = _aUserMessage catalog]				ifNone: [UserMessageCatalog new].	oldKey := _aUserMessage key.	"create the next key from the current one (increment the number)"	key := (Dialog 				request: #askForNewKey &lt;&lt; #Localizer &gt;&gt; 'Please enter a new Key'				initialAnswer: (self nextKeyFor: _aUserMessage key inCatalog: aCatalog)) 					asSymbol.	key isEmpty ifTrue: [^nil].	((UserMessageTranslationMemory default messagesForCatalog: aCatalog name) 		detect: [:each | (each key at: #key) = key]		ifNone: [nil]) ifNotNil: 				[(Dialog confirm: (#keyAllreadyExisting &lt;&lt; #Localizer 							&gt;&gt; 'the Key "&lt;1s&gt;" is allready existing in this catalog. Do you want to proceed?'					expandMacrosWith: key)) ifFalse: [^nil]].	"create new sourcecode for the current method"	newMethod := self 				createNewMethodFrom: aMethod methodSources source				withOldKey: oldKey				newKey: key.	"set packagename, translation, keys and this stuff"	packageName := 'L10n-ModifiedMethods'.	class := aMethod mclass.	"create new Package if not there yet"	package := (Store.Registry isPackageLoaded: packageName) 				ifTrue: [Store.Registry packageNamed: packageName]				ifFalse: [Store.PackageModel named: packageName].	"add overwrite"	class isMeta 		ifTrue: [classSymbol := class soleInstance absoluteSymbol]		ifFalse: [classSymbol := class absoluteSymbol].	package modelAtFullSymbol: classSymbol hasDefinition: false.	aAddMethodChange := Refactory.Browser.AddMethodChange 				compile: newMethod				in: class				classified: (class whichCategoryIncludesSelector: aMethod selector).	aAddMethodChange package: package.	change := (Refactory.Browser.CompositeRefactoryChange 				named: aAddMethodChange name 						, (#overwriting &lt;&lt; #Localizer &gt;&gt; ' overwriting') asString)				addChange: (Refactory.Browser.MoveMethodToPackageChange 							class: class							selector: aAddMethodChange selector							package: package);				addChange: (Refactory.Browser.AddOverrideChange 							for: (Override forSelector: aAddMethodChange selector									class: aAddMethodChange changeObject)).	Refactory.Browser.RefactoryChangeManager instance performChange: change.	"add method change"	methChange := (Refactory.Browser.CompositeRefactoryChange 				named: aAddMethodChange name) addChange: aAddMethodChange.	Refactory.Browser.RefactoryChangeManager instance 		performChange: methChange.	"this can open the class, but it's more annoying than usefull"	"	(Refactory.Browser.RefactoringBrowser open navigator)		selectPundle: package;		changed."	"remove the old translations and add them with new method and key"	oldTranslations := UserMessageTranslationMemory default 				removeAtCatalog: aCatalog name				key: oldKey				application: nil				culture: nil				language: nil				source: nil				date: nil				approved: nil				method: (MethodDefinition class: class selector: aAddMethodChange selector) 						method.	oldTranslations do: 			[:each | 			UserMessageTranslationMemory default 				atCatalog: (each key at: #catalog ifAbsent: [nil])				key: key				application: (each key at: #application ifAbsent: [nil])				culture: (each key at: #culture ifAbsent: [nil])				language: (each key at: #language ifAbsent: [nil])				source: (each key at: #source ifAbsent: [nil])				date: (each key at: #date ifAbsent: [nil])				approved: (each key at: #approved ifAbsent: [nil])				method: (MethodDefinition class: aAddMethodChange changeObject						selector: aAddMethodChange selector) method				put: each value].	"add translation to TM"	aNewUserMessage := _aUserMessage copy.	aNewUserMessage key: key.	self 		acceptTranslation: aTranslation		ofUserMessage: aNewUserMessage		from: aSourceLangSpec		to: aTargetLangSpec		withStatus: aStatus.	"ask to open the newly created method in a refactorybrowser window"	(Dialog confirm: #DoYouWantToSeeTheNewMethod &lt;&lt; #Localizer 				&gt;&gt; 'Do you want to see the new method?') 		ifTrue: 			[self 				openClassForMethod: (MethodDefinition class: aAddMethodChange changeObject						selector: aAddMethodChange selector) method].	^key</body><body package="L10n-Models">checkBeforeAccepting: aTranslation forVisualisation: aSymbol ofMessage: aUserMessage inMethods: aMethodList	"checks acceptkeys and if translation is empty"	| item methods userMessage |	aSymbol = #menu		ifTrue: 			["check the accessKeys from windows"			userMessage := aUserMessage.			methods := aMethodList collect: [:each | each method].			item := MenuItem labeled: aTranslation.			(AccessKeyChecker				checkMenuItem: item				withMethods: methods				forUserMessage: userMessage)					ifFalse: 						[self triggerEvent: #checkAccessKey.						^false]].	"check wether translations are entered or not"	aTranslation isEmpty		ifTrue: 			[^Dialog confirm: #NoTranslationEnteredAcceptAnyway &lt;&lt; #Localizer						&gt;&gt; 'No translation entered. Accept empty translation?'].	^true</body><body package="L10n-Models">createNewMethodFrom: source withOldKey: oldKey newKey: key 	"searches all oldKey's and replaces them with key's"	"Localisator default createNewMethodFrom: 'aTestMethodFor: aSymbol	^aSymbol = #test ifTrue:[''test''] ifFalse:[#test &lt;&lt; #test &gt;&gt; ''test'']	'  withOldKey: #test newKey: #myTest	"	| result start oldSize indices |	result := String new writeStream.	start := 1.	"remember the old size"	oldSize := oldKey printString size.	"find all indices, starting at oldSize, as a method can't start with a symbol"	indices := source 				findAllSymbols: oldKey printString				startingAt: oldSize				ifAbsent: 					["if the old key can't be found, return the old source code"					^source copy].	indices do: 			[:index | 			"write the source up to the first occurance of the old Key"			result nextPutAll: (source copyFrom: start to: index - 1).			result nextPutAll: key printString.			start := index + oldSize].	result nextPutAll: (source copyFrom: start to: source size).	^result contents</body><body package="L10n-Models">getSourceCodeForMethod: listMethod 	"returns the sourceCode of a Method"	| source |	listMethod ifNil: [^nil].	(listMethod isKindOf: CompiledInitializer) 		ifTrue: [source := listMethod getSource]		ifFalse: 			[source := listMethod getSourceForUserIfNone: 							[(listMethod mclass decompilerClass new 								decompile: listMethod selector								in: listMethod mclass								method: listMethod) decompiledCodeWithExplanation: nil]].	^source asString</body><body package="L10n-Models">nextKeyFor: aKey inCatalog: aCatalog 	"generate the nextKey for aKey and see if that is allready used in aCatalog, if so create another key until we find a free one"	| newKey keys |	newKey := aKey.	keys := (UserMessageTranslationMemory default 				messagesForCatalog: aCatalog name) collect: [:each | each key at: #key].	[keys includes: (newKey := self nextKeyFor: newKey)] whileTrue.	^newKey</body></methods><methods><class-id>L10n.Localisator</class-id> <category>events</category><body package="L10n-Models">termEditFinished: refresh	"fire the event, that the termEdit is finished."	refresh		ifTrue: 			[self resetTerminologyTable.			self triggerEvent: #editFinished].	self removeActionsForEvent: #editFinished</body></methods><methods><class-id>L10n.Localisator</class-id> <category>accessing</category><body package="L10n-Models">tempTranslationStore	^TemporaryTranslationStore default</body></methods><methods><class-id>L10n.Localisator class</class-id> <category>instance creation</category><body package="L10n-Models">new	^super new initialize</body></methods><methods><class-id>L10n.Localisator class</class-id> <category>accessing instances and variables</category><body package="L10n-Models">default	^TheLocalisator ifNil: [TheLocalisator := self new]</body></methods><methods><class-id>Refactory.Browser.L10nBrowser</class-id> <category>initialize-release</category><body package="L10n-RBSupport">codeModelClass	^L10nCodeModel</body></methods><methods><class-id>L10n.TerminologyUI</class-id> <category>aspects</category><body package="L10n-UI">selectedRow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectedRow 		ifNil: [selectedRow := self terminologyTable selectionIndexHolder]</body><body package="L10n-UI">selectedRow: anObject 	selectedRow:=anObject.</body><body package="L10n-UI">selectedRowIndex: anObject 	self terminologyTable selectionIndexHolder:anObject.</body><body package="L10n-UI">selectedRowNumber	^selectedRowNumber ifNil:[selectedRowNumber := self terminologyTable selectionIndex]</body><body package="L10n-UI">termMenuAspect	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^termMenuAspect isNil 		ifTrue: [termMenuAspect := String new asValue]		ifFalse: 			[termMenuAspect]</body><body package="L10n-UI">termMenuAspect: anAspect 	termMenuAspect = anAspect 		ifFalse: 			[termMenuAspect := anAspect.			]</body><body package="L10n-UI">terminologyTable	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^terminologyTable isNil 		ifTrue: [terminologyTable := SelectionInList new]		ifFalse: [terminologyTable]</body><body package="L10n-UI">terminologyTable: anObject 	self terminologyTable listHolder: anObject</body></methods><methods><class-id>L10n.TerminologyUI</class-id> <category>private</category><body package="L10n-UI">selectTerm: aTerm	| m searchString |	m := self termMenu value.	m size &gt; 0		ifTrue: 			[aTerm isNil				ifTrue: [^self termMenuAspect value: m first]				ifFalse: 					[searchString := '*&lt;1s&gt;*' asIs expandMacrosWith: aTerm.					^self termMenuAspect						value: (m detect: [:each | searchString match: each] ifNone: [m first])]].	self termMenuAspect value: String new</body><body package="L10n-UI">setTable	"sets the table to the terms that fit the selected term"	self terminologyTable list: (Localisator default 				getCurrentTermDictionariesForTerm: self termMenuAspect value).	self sortTableWith:#original.</body><body package="L10n-UI">setTermMenu	"initializes the menu of terms and selects the first"	^self setTermMenu: nil</body><body package="L10n-UI">setTermMenu: aTerm	"initializes the menu of terms and selects aTerm if present"	| m |	m := self parent getTermMenu.	self termMenu value: m.	self selectTerm: aTerm</body><body package="L10n-UI">sortTableWith: aSymbol 	"sorts the Table with aSymbol being the symbol of the row which should be sorted"	lastSortingSymbol = aSymbol 		ifTrue: 			[compareSymbol = #&lt; 				ifTrue: [compareSymbol := #&gt;]				ifFalse: [compareSymbol := #&lt;]]		ifFalse: [compareSymbol := #&lt;].	self terminologyTable 		list: (self terminologyTable list asSortedCollection: 					[:a :b | 					(a perform: aSymbol) perform: compareSymbol with: (b perform: aSymbol)]).	lastSortingSymbol := aSymbol</body><body package="L10n-UI">updateUI	self setTable.	self builder ifNil:[^nil].</body></methods><methods><class-id>L10n.TerminologyUI</class-id> <category>initialize-release</category><body package="L10n-UI">initialize	"Eine kürzlich erstellte Instanz initialisieren. Diese Methode muss dem Empfänger entsprechen."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>L10n.TerminologyUI</class-id> <category>actions</category><body package="L10n-UI">RemoveSeletedTerm	"This stub method was generated by UIDefiner"	Localisator default removeTerm: self termMenuAspect value.	self setTermMenu.	self setTable.</body><body package="L10n-UI">editTerm	"This stub method was generated by UIDefiner"	Localisator default 		when: #editFinished		send: #updateTerms		to: self parent.	^Localisator default editTerm: self terminologyTable selection</body><body package="L10n-UI">newTerm	"This stub method was generated by UIDefiner"	Localisator default 		when: #editFinished		send: #updateTerms		to: self parent.	^Localisator default newTerm: self termMenuAspect value</body><body package="L10n-UI">openTermManager	"opens the Terminology Manager"	TermManagerUI open</body><body package="L10n-UI">removeTerm	"This stub method was generated by UIDefiner"	(Localisator default removeTermEntry: self terminologyTable selection) 		ifTrue: 			[self parent updateTerms.			^true].	^false</body><body package="L10n-UI">selectedRowNotesLabelPressed	"sort the table with Notes being the key"	^self sortTableWith: #notes</body><body package="L10n-UI">selectedRowOriginalLabelPressed	"sort the table with original being the key"	self sortTableWith: #original</body><body package="L10n-UI">selectedRowSourceLabelPressed	self sortTableWith: #source</body><body package="L10n-UI">selectedRowSynonymLabelPressed	self sortTableWith: #synonym</body><body package="L10n-UI">selectedRowTranslationLabelPressed	self sortTableWith:#translation</body><body package="L10n-UI">selectedRowValidLabelPressed	self sortTableWith: #valid</body><body package="L10n-UI">terminologyDoubleClick	| |	self parent applyTerm: self terminologyTable selection translation.</body></methods><methods><class-id>L10n.TerminologyUI</class-id> <category>accessing</category><body package="L10n-UI">labelFor: aSymbol 	"returns the table headers"	^aSymbol asString</body><body package="L10n-UI">parent	^parent</body><body package="L10n-UI">parent: aModel 	parent := aModel</body></methods><methods><class-id>L10n.TerminologyUI</class-id> <category>events</category><body package="L10n-UI">keyPressed: event 	"a key was pressed, if ctrln was pressed, open the editTermUI"	event keyValue = Graphics.TextConstants.Ctrln 		ifTrue: 			["ctrl-n was pressed"			self newTerm.			^nil].	(event keyValue = Character lf and: [event metaState = 2]) 		ifTrue: 			["ctrl enter was pressed"			self editTerm.			^nil].	(event keyValue = Character backspace and: [event metaState = 2]) 		ifTrue: 			[self removeTerm.			^nil].	^event</body></methods><methods><class-id>L10n.TerminologyUI</class-id> <category>changing</category><body package="L10n-UI">termMenuAspectChanged	"the selection of the termMenu changed"	self setTable</body></methods><methods><class-id>L10n.TerminologyUI</class-id> <category>As yet unclassified</category><body package="L10n-UI">isVisible: aBool 	(self builder ifNil: [^nil]) keyboardProcessor 		keyboardHook: (aBool ifTrue: [[:ev :c | self keyPressed: ev]] ifFalse: [nil])</body></methods><methods><class-id>L10n.TerminologyUI</class-id> <category>menu</category><body package="L10n-UI">termMenu	^termMenu ifNil: [termMenu := #() asValue]</body><body package="L10n-UI">termMenu: anObject 	termMenu := anObject</body></methods><methods><class-id>L10n.TerminologyUI</class-id> <category>interface opening</category><body package="L10n-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setTermMenu.	self setTable.	self reconfigureTableWidget</body><body package="L10n-UI">reconfigureTableWidget	| aWidget columnDescriptors columnWidths newColumnWidths |	aWidget := self widgetAt: #Datensatz1.	columnDescriptors := aWidget columnDescriptors.	columnWidths := (columnDescriptors collect: #width) asOrderedCollection.	newColumnWidths := ((columnWidths allButLast: 1) collect: [:each | 0])				, (columnWidths last: 1).	UI.DataSetAutoresizeWrapper autoResizeColumnsIn: aWidget		usingSpec: newColumnWidths</body></methods><methods><class-id>L10n.TerminologyUI class</class-id> <category>instance creation</category><body package="L10n-UI">inParent: aModel 	"creates a new instance and sets parent to aModel"	| viewer |	viewer := self new.	viewer parent: aModel.	^viewer</body></methods><methods><class-id>L10n.AccessKeyChecker class</class-id> <category>check</category><body package="L10n-Models">checkMenu: menu forLabel: label atChat: aChar forUserMessage: aUserMessage 	| menuToSearch i array |	array := menu findPathToUserMessage: aUserMessage.	"find the path"	array ifNil: [^true].	array size &gt; 1 		ifTrue: 			["there must be a submenu, so let's search this for existing accesskeys"			menuToSearch := (array at: array size - 1) submenu]		ifFalse: [menuToSearch := menu].	"search in the menu where the menuItem was found, if the accesskey is correct"	menuToSearch menuItems do: 			[:eachItem | 			eachItem label = label 				ifFalse: 					[i := eachItem accessCharacterPosition.					i isNil 						ifFalse: 							[(eachItem label at: i) asLowercase = aChar asLowercase ifTrue: [^false]]]].	^true</body><body package="L10n-Models">checkMenuItem: aMenuItem withMenu: menu forUserMessage: aUserMessage 	"find the menuItem in the Menu"	"there must be a submenu, so let's search this for existing accesskeys"	"search in the menu where the menuItem was found, if the accesskey is correct"	| aChar label pos |	pos := aMenuItem accessCharacterPosition.	pos ifNil: [^true].	aChar := aMenuItem label at: pos.	label := aMenuItem label.	"find the path"	^self 		checkMenu: menu		forLabel: label		atChat: aChar		forUserMessage: aUserMessage</body><body package="L10n-Models">checkMenuItem: aMenuItem withMethods: methods forUserMessage: aUserMessage 	| menus |	menus := self compileMenusFromMethods: methods.	menus do: 			[:aMenu | 			(self 				checkMenuItem: aMenuItem				withMenu: aMenu				forUserMessage: aUserMessage) ifFalse: [^false]].	^true</body><body package="L10n-Models">compileMenuFromMethod: theMethod	| tempMethod selector class |	^theMethod selector = #unboundMethod		ifFalse: 			[class := theMethod definition implementingClass.			selector := theMethod definition selector.			selector notNil				ifTrue: 					[tempMethod := class compiledMethodAt: selector ifAbsent: [nil].					(tempMethod notNil and: [tempMethod resourceType == #menu])						ifTrue: 							[[self initializeMenu: (class soleInstance perform: selector)] on: Error								do: [:ex | ex return: Menu new]]						ifFalse: [Menu new]]				ifFalse: [Menu new]]		ifTrue: [nil]</body><body package="L10n-Models">compileMenusFromMethods: methods	| menus |	menus := OrderedCollection new.	methods do: 			[:theMethod |			theMethod				ifNil: [nil]				ifNotNil: 					[(self compileMenuFromMethod: theMethod) ifNotNil: [:m | menus add: m]]].	^menus</body><body package="L10n-Models">initializeMenu: aMenu 		aMenu 		values: (aMenu values collect: [:each | [self selection value: each]]).	aMenu menuItems do: 			[:each | 			each submenu notNil 				ifTrue: [each submenu: (self initializeMenu: each submenu)]].	^aMenu</body><body package="L10n-Models">selection	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selection isNil		ifTrue:			[selection := nil asValue]		ifFalse:			[selection]</body></methods><methods><class-id>L10nTBXSoxDriver</class-id> <category>private</category><body package="L10n-TMX">elementCommentKeysDo: aBlock separatedBy: separatorBlock	(element keys reject: [:k | StandardKeys includes: k]) asSortedCollection		do: aBlock		separatedBy: separatorBlock</body><body package="L10n-TMX">elementsNamed: tagName in: xmlElement	^xmlElement realElements select: [:each | each tag asString = tagName]</body><body package="L10n-TMX">getNotes	| stream langSets |	stream := String new writeStream.	self printCreatorAndModifierOf: self xmlElement on: stream.	stream cr.	langSets := self elementsNamed: 'langSet' in: self xmlElement.	self printLangSets: langSets on: stream.	^stream contents</body><body package="L10n-TMX">numberOfTerms: attributes	"look for size attribute, if it is omittet return guess 100"	^(attributes detect: [:each | each tag type = 'size'] ifNone: [^100])		value asNumber</body><body package="L10n-TMX">printCreatorAndModifierOf: xmlElement on: aStream	| groupElements groups |	groupElements := self elementsNamed: 'transacGrp' in: xmlElement.	groups := groupElements				collect: [:each | TBXTransactGroup fromXMLElement: each].	groups sorted do: 			[:each |			aStream crtab.			aStream print: each].	aStream cr</body><body package="L10n-TMX">printLangSets: languageSetElements on: stream	| langSets |	langSets := languageSetElements				collect: [:langSet | TBXLangSet fromXMLElement: langSet].	(langSets sorted: #language ascending) do: 			[:each |			each printOn: stream.			stream cr]</body></methods><methods><class-id>L10nTBXSoxDriver</class-id> <category>content handler</category><body package="L10n-TMX">atCurrentElementPut: aString	"take the current element and add some values to it. if everything is put into it then the element is stored."	key = nil ifTrue: [^nil].	key = #term ifTrue: [^self newString: aString].	key = #version ifTrue: [^self newVersion: aString].	element at: attrib put: aString asSymbol</body><body package="L10n-TMX">characters: aString	self xmlElement addNode: (XML.Text text: aString).	super characters: aString</body><body package="L10n-TMX">endElement: namespaceURI localName: localName qName: name	"a closing tag was found"	key := nil.	name = 'termEntry'		ifTrue: 			[self storeElement.			element := nil.			lang := nil.			segStarted := nil].	stack removeLast</body><body package="L10n-TMX">handleDescrip: attributes	key := #catalog.	attrib := attributes first value</body><body package="L10n-TMX">handleLangSet: attributes	attributes first tag type = 'lang'		ifTrue: 			[lang := attributes first value]</body><body package="L10n-TMX">handleMartif: attributes	| size |	size := self numberOfTerms: attributes.	ResetIncrementNotification signalWith: size</body><body package="L10n-TMX">handleMartifHeader: attributes	"Do nothing. An old implementation was"	"(attributes select: [:each | each tag type = 'creationtool']) first value		= 'L10n'			ifFalse: [self error: 'please only import tmx files exported by L10n']"</body><body package="L10n-TMX">handleTerm: attributes	key := #term</body><body package="L10n-TMX">handleTermEntry: attributes	element := Dictionary new.	attributes notEmpty		ifTrue: [element at: #key put: attributes first value asSymbol].	IncrementNotification raiseSignal</body><body package="L10n-TMX">newString: aString	| locale |	locale := self languageAndCountryFrom: lang.	(#(#en #C) includes: locale first)		ifTrue: 			[element at: #sourceLanguage put: locale first.			element at: #sourceCountry put: locale last.			(element at: #sourceString ifAbsentPut: [OrderedCollection new])				add: aString asSymbol]		ifFalse: 			[element at: #targetLanguage put: locale first.			element at: #targetCountry put: locale last.			(element at: #targetString ifAbsentPut: [OrderedCollection new])				add: aString asSymbol]</body><body package="L10n-TMX">newVersion: aString	element at: #version		put: (L10n.UserMessageSpecifierVersion source: aString asSymbol				timestamp: Timestamp now)</body><body package="L10n-TMX">startElement: namespaceURI localName: localName qName: name attributes: attributes	"a start tag was found and depending on its name the values of element are set."	| newElement |	newElement := XML.Element				tag: localName				attributes: attributes				elements: nil.	self xmlElement addNode: newElement.	stack add: newElement.	name = 'termEntry' ifTrue: [^self handleTermEntry: attributes].	name = 'descrip' ifTrue: [^self handleDescrip: attributes].	name = 'martif' ifTrue: [^self handleMartif: attributes].	name = 'langSet' ifTrue: [^self handleLangSet: attributes].	name = 'term' ifTrue: [^self handleTerm: attributes].	name = 'martifHeader' ifTrue: [^self handleMartifHeader: attributes]	"Other elements are ignored"</body><body package="L10n-TMX">storeElement	| translations aTermEntry |	translations := element at: #targetString ifAbsent: [^nil].	aTermEntry := L10n.TerminologyEntry new.	aTermEntry		original: (element at: #sourceString ifAbsent: [^nil]);		translation: translations first;		synonym: (translations size &gt; 1					ifTrue: [translations at: 2]					ifFalse: [String new]);		notes: self getNotes;		source: (element at: 'source' ifAbsent: [String new]);		valid: (element at: 'valid' ifAbsent: [String new]).	L10n.TerminologyController default addDataFromEntry: aTermEntry</body><body package="L10n-TMX">xmlElement	^stack last</body></methods><methods><class-id>L10nTBXSoxDriver</class-id> <category>initialize-release</category><body package="L10n-TMX">initialize	super initialize.	stack := OrderedCollection with: (XML.Element tag: 'tbx')</body></methods><methods><class-id>L10nTBXSoxDriver class</class-id> <category>instance creation</category><body package="L10n-TMX">new	^super new initialize</body></methods><methods><class-id>TBXTransactGroup</class-id> <category>comparing</category><body package="L10n-TMX">&lt; aMagnitude 	"Answer whether the receiver is less than the argument."	^timestamp &lt; aMagnitude timestamp</body><body package="L10n-TMX">= aGroup	^self class = aGroup class and: 			[self timestamp = aGroup timestamp				and: [self transaction = aGroup transaction and: [self user = aGroup user]]]</body><body package="L10n-TMX">hash	^timestamp hash</body></methods><methods><class-id>TBXTransactGroup</class-id> <category>accessing</category><body package="L10n-TMX">timestamp	^timestamp</body><body package="L10n-TMX">transaction	^transaction</body><body package="L10n-TMX">user	^user</body></methods><methods><class-id>TBXTransactGroup</class-id> <category>printing</category><body package="L10n-TMX">printOn: aStream	aStream		nextPutAll: user;		nextPutAll: ' - ';		nextPutAll: transaction;		nextPutAll: ' (';		print: timestamp;		nextPut: $)</body></methods><methods><class-id>TBXTransactGroup</class-id> <category>initialize-release</category><body package="L10n-TMX">setDate: aTimestamp user: aUserName transaction: aTransaction	timestamp := aTimestamp.	user := aUserName.	transaction := aTransaction</body></methods><methods><class-id>TBXTransactGroup class</class-id> <category>instance creation</category><body package="L10n-TMX">fromXMLElement: anXMLElement	"initializes the group from the following XML:	&lt;transacGrp&gt;		&lt;transac type='terminologyManagementTransactions'&gt;origination&lt;/transac&gt;		&lt;date&gt;2016-04-27T13:50:54&lt;/date&gt;		&lt;transacNote type='responsibility'&gt;INF-DOMAIN\stmamoch&lt;/transacNote&gt;	&lt;/transacGrp&gt;	the &lt;date&gt;, responsibility and terminologyManagementTransaction are put in &lt;date&gt;, &lt;user&gt; and &lt;transaction&gt; instvars	"	| date user transaction |	date := Date new.	user := 'unknown'.	transaction := 'unknown'.	anXMLElement realElements do: 			[:each |			each tag asString = 'transac' ifTrue: [user := each characterData].			each tag asString = 'date'				ifTrue: [date := self timestampFrom: each characterData].			each tag asString = 'transacNote'				ifTrue: [transaction := each characterData]].	^self new setDate: date user: user transaction: transaction</body><body package="L10n-TMX">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="L10n-TMX">timestampFrom: aString	| rs year month day time |	rs := aString readStream.	year := Integer readFrom: rs.	rs next.	month := Integer readFrom: rs.	rs next.	day := Integer readFrom: rs.	rs next.	time := Time readFrom: rs.	^Timestamp fromDate: (Date newDay: day monthNumber: month year: year ) andTime: time</body></methods><methods><class-id>L10n.RBContainer</class-id> <category>changing</category><body package="L10n-UI">codeToolChanged	"codeTool changed...select the userMessage in it"	^self selectUserMessage.</body><body package="L10n-UI">isRB4xx		^Refactory.Browser.RefactoringBrowser canUnderstand: #currentToolset</body><body package="L10n-UI">navigatorChanged	"navigator changed, we have been notified."		self navigator ifNil: [^nil].	self navigator state selector ifNil: [^nil].	(Localisator default		visualizationForMethod: self navigator state definition method)		ifNotNil:			["select the sourcecode tab"			self visibleCodeTools				do:					[:each | 					(each isKindOf: Refactory.Browser.VisualViewer)						ifTrue:							[self selectCodeTool: each.							^self]]]</body><body package="L10n-UI">selectCodeTool: codeTool		self isRB4xx		ifTrue: [self codeTool selectTool: codeTool]		ifFalse: [self codeTool selectPolicyNamed: codeTool name]</body><body package="L10n-UI">userMessageChangedWith: aUserMessageListEntry 	"userMessage selection changed"	self dependentRB codeTool tool updateContents.	self parent 		userMessageChangedWith: aUserMessageListEntry		updateMethods: false		from: self.</body><body package="L10n-UI">visibleCodeTools		self isRB4xx		ifTrue:			["7.6"			^self codeTool activeTools]		ifFalse:			["&lt;= 7.5"			^self codeTool selectionPolicies]</body></methods><methods><class-id>L10n.RBContainer</class-id> <category>accessing</category><body package="L10n-UI">codeTool	^self dependentRB codeTool</body><body package="L10n-UI">createBrowser	| browserEnvironment |	browserEnvironment := Refactory.Browser.L10nEnvironment onMethods: Array new				from: self.	browserEnvironment label: String new.	dependentRB := Refactory.Browser.L10nBrowser				onEnvironment: browserEnvironment</body><body package="L10n-UI">initialize	self createBrowser</body><body package="L10n-UI">model	^model</body><body package="L10n-UI">model: anObject	model := anObject</body><body package="L10n-UI">navigator	^(self dependentRB ifNil: [^nil]) navigator</body><body package="L10n-UI">parent	"Dummy method template.  This was installed by the debugger	define method command."	^parent</body><body package="L10n-UI">parent: aModel	"Dummy method template.  This was installed by the debugger	define method command."	^parent := aModel</body></methods><methods><class-id>L10n.RBContainer</class-id> <category>aspects</category><body package="L10n-UI">dependentRB	^dependentRB</body></methods><methods><class-id>L10n.RBContainer</class-id> <category>private</category><body package="L10n-UI">highlightUserMessage: aUsermessage inController: controller withSource: source onWrapper: aWrapper 	| highlightning start end wrapper |	aUsermessage isNil 		ifTrue: [highlightning := String new]		ifFalse: [highlightning := aUsermessage key printString].	position := controller selectionStopIndex.	start := source indexOfSubCollection: highlightning startingAt: position.	end := start + highlightning asString size.	"if no start was found search at the beginning"	start &gt; 0 		ifFalse: 			[start := source indexOfSubCollection: highlightning startingAt: 1.			end := start + highlightning asString size].	"if still none found give error"	start &gt; 0 		ifTrue: 			[wrapper := aWrapper.			wrapper widget controller selectAndScrollFrom: start to: end - 1			"wrapper takeKeyboardFocus"]		ifFalse: 			[wrapper := aWrapper.			wrapper widget controller selectAndScrollFrom: position to: position - 1]</body><body package="L10n-UI">setMethods: aList 	self dependentRB 		environment: (Refactory.Browser.L10nEnvironment onMethods: aList from: self).	"self halt."	aList isEmpty 		ifFalse: 			[self dependentRB navigator 				setState: (self dependentRB navigator state definition: aList first)]		ifTrue: [self dependentRB navigator 				setState: (Refactory.Browser.NavigatorState new)].	self dependentRB codeTool update.	self dependentRB navigator refreshLists.	self navigator changed</body><body package="L10n-UI">toggleStatusBarInRefactoringBrowser: rb to: aBool	"show the statusbar or hide it"		rb codeTool builder ifNil: [^nil].	#(#label #parcelLabel #packageLabel)		do:			[:each | 			| widget |			widget := rb codeTool builder componentAt: each.			widget isNil				ifFalse:					[widget component layout						topOffset:							[aBool								ifTrue: [-25]								ifFalse: [0]]]].	(rb codeTool builder componentAt: #subcanvas)		ifNotNil:			[:widget | 			widget component layout				bottomOffset:					[aBool						ifTrue: [-27]						ifFalse: [0]]]</body></methods><methods><class-id>L10n.RBContainer</class-id> <category>userMessageSelection</category><body package="L10n-UI">deselectUserMessage	"do nothing, is allready selected"	| controller aWrapper source |	controller := (self codeTool tool controllerAt:#textEditor).	controller ifNil:[^self].	aWrapper := (self codeTool tool wrapperAt:#textEditor).	source := controller text.	aWrapper widget isFromL10n: source isEmpty not.	^self highlightUserMessage: nil inController: controller withSource: source onWrapper: aWrapper</body><body package="L10n-UI">selectFirstMessage	"selects the first userMessage, if there's one available."	| aNavigator |	aNavigator := ((self navigator parts collect: [:each | each messages]) 				do: [:each | each selectFirst]) detect: [:each | each list isEmpty not]					ifNone: [nil].	aNavigator ifNil:[^nil].	aNavigator list isEmpty ifTrue: [^nil].	^aNavigator list first</body><body package="L10n-UI">selectNextUserMessage	"selects the first userMessage, if there's one available."	(self navigator parts collect:[:each | each messages]) do:[:each | each selectNext].</body><body package="L10n-UI">selectPreviousUserMessage	"selects the userMessage at selectionIndex-1"	(self navigator parts collect: [:each | each messages]) 		do: [:each | each selectPrevious]</body><body package="L10n-UI">selectUserMessage	"do nothing, is allready selected"	| controller aWrapper source |	controller := self codeTool tool controllerAt: #textEditor.	controller		ifNil: 			["sourceCode view seems not be selected right now"			^nil].	aWrapper := self codeTool tool wrapperAt: #textEditor.	self codeTool tool isTextTool		ifTrue: 			[source := self codeTool tool text.			aWrapper widget isFromL10n: source notEmpty.			self				highlightUserMessage: self parent selectedUserMessage				inController: controller				withSource: source				onWrapper: aWrapper]		ifFalse: 			[self codeTool tool textHolder				value: #TheSelectedMessageIsAMethodInTheSystem &lt;&lt; #Localizer						&gt;&gt; 'The selected message is not used by a method in the system']</body></methods><methods><class-id>L10n.RBContainer</class-id> <category>interface opening</category><body package="L10n-UI">postBuildWith: aBuilder 	self showSelection: false.	self toggleStatusBarInRefactoringBrowser: dependentRB to: false.</body><body package="L10n-UI">showSelection: aBool 	"show the selection even if widget does not have keyboard focus, depending on aBool"	"(self widgetAt: #sourceCodeTextEditor) isFromL10n: aBool."</body></methods><methods><class-id>L10n.RBContainer class</class-id> <category>instance creation</category><body package="L10n-UI">inParent: aModel	"sets the parent and returns a new instance"	| viewer |	viewer := self new.	viewer parent: aModel.	^viewer</body></methods><methods><class-id>Tools.GeneralMethodDefinition</class-id> <category>accessing</category><body package="L10n-Base">definition	^self</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="L10n-System-Modifications">countryCode	"	'test_string' countryCode	#test_symbol countryCode 	#test countryCode	"	| result |	result := self species withAll: (self readStream upTo: $_;upToEnd).	result size = 0 ifTrue:[^'none'].	^result.</body><body package="L10n-System-Modifications">countryCodeSymbolOrNil	"	'test_string' countryCodeSymbolOrNil	#test_symbol countryCodeSymbolOrNil 	#test countryCodeSymbolOrNil	"	| result |	result := self species withAll: ((self readStream)						skipThrough: $_;						upToEnd).	result size = 0 ifTrue: [^nil].	^result asSymbol</body><body package="L10n-System-Modifications">languageCode	"	'test_string' languageCode	#test_symbol languageCode 		"	^self species withAll: (self readStream upTo: $_)</body></methods><methods><class-id>UI.Menu</class-id> <category>menu items</category><body package="L10n-System-Modifications">findPathToUserMessage: message 	"returns an array of MenuItems where the last MenuItem is labeled with 'message' "	| res |	res := self privateFindPathToUserMessage: message.	res isEmpty ifTrue: [^nil] ifFalse: [^res]</body></methods><methods><class-id>UI.Menu</class-id> <category>testing</category><body package="L10n-System-Modifications">isFromL10n	"normal Menus are not from L10n"	^false</body></methods><methods><class-id>UI.Menu</class-id> <category>menu items</category><body package="L10n-System-Modifications">privateFindPathToUserMessage: message 	| res array |	self menuItems do: 			[:each | 			(MenuItem labeled: each rawLabel evaluate asString) label 				= (MenuItem labeled: message evaluate asString) label 					ifTrue: [^Array with: each].			each hasSubmenu 				ifTrue: 					[res := each submenu privateFindPathToUserMessage: message.					(res isNil or: [res isEmpty]) 						ifFalse: 							[array := OrderedCollection withAll: res.							array addFirst: each.							^array]]].	^Array new</body></methods><methods><class-id>Kernel.MessageCatalog</class-id> <category>accessing</category><body package="L10n-System-Modifications">priority	^0</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>testing</category><body package="L10n-System-Modifications">privateIncludes: anObject 	"	#(1 2 3 4 5 6 7 8 9) asSortedCollection privateIncludes:5	"	^anObject = (self basicAt: (((self indexForInserting: anObject) - 1 max:1) min:self basicSize))</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>testing</category><body package="L10n-System-Modifications">isMethod ^ false</body></methods><methods><class-id>Core.PeekableStream</class-id> <category>accessing</category><body package="L10n-System-Modifications">nextWord	"Answers the next word or separator from the stream. 	If the next character begins a word, this word is returned. 	If the next character begins a separator, the whole seperator up to the next word is returned"	| newStream testBlock c |	newStream := (self contentsSpecies new: 64) writeStream.	c := self peek.	testBlock := (c = $&amp; or: [c isAlphaNumeric])				ifTrue: 					[					[:each |					each = $&amp;						or: [each isAlphaNumeric and: [each isLowercase or: [each isDigit]]]]]				ifFalse: [[:each | each isAlphaNumeric not]].	self atEnd ifFalse: [newStream nextPut: self next].	[self atEnd not and: [testBlock value: self peek]]		whileTrue: [newStream nextPut: self next].	^newStream contents</body></methods><methods><class-id>Kernel.MessageCatalogManager class</class-id> <category>instance creation</category><body package="L10n-System-Modifications">updateCatalogs	"Let's set up a manager for those MessageCatalog subclasses that implement lookup by searching a list of catalog objects."	"self updateCatalogs"	#{Managers} initialize.	MessageCatalog allSubclasses		do: [:class | class addToMessageCatalogManager].	"overridden to sort the catalogs by priority so that TemporaryTranslationStore is first,	 then TranslationMemory, then IndexedFiles"	Managers do: #sortByPriority</body></methods><methods><class-id>Kernel.MessageCatalogManager</class-id> <category>accessing</category><body package="L10n-System-Modifications">addFirst: aCatalog	(catalogs at: aCatalog catalogID ifAbsentPut: [OrderedCollection new]) addFirst: aCatalog.	^aCatalog</body><body package="L10n-System-Modifications">sortByPriority	catalogs do: [:each | each sort: #priority descending]</body></methods><methods><class-id>Core.WriteStream</class-id> <category>character writing</category><body package="L10n-System-Modifications">padTo: anIndex 	"fills itself up with Spaces until anIndex is reached"	| rem |	rem := anIndex - position.	1 to: rem do: [:i | self nextPut: Character space].	^rem</body></methods><methods><class-id>Kernel.UserMessage</class-id> <category>comparing</category><body package="L10n-System-Modifications">&lt; t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an incorrect position in 	the file. The file may have been modified after this method was updated."	self catalogID &lt; t1 catalogID ifFalse: [^false].	self key &lt; t1 key ifFalse: [^false].	^self defaultString &lt; t1 defaultString</body><body package="L10n-System-Modifications">&lt;= t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an incorrect position in 	the file. The file may have been modified after this method was updated."	self catalogID &lt;= t1 catalogID ifFalse: [^false].	self key &lt;= t1 key ifFalse: [^false].	^self defaultString &lt;= t1 defaultString</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>generated resources</category><body package="L10n-System-Modifications">launcherIcon	^ToolbarIconLibrary visualFor: #noteBookWidget</body></methods><methods><class-id>Core.Array</class-id> <category>l10n</category><body package="L10n-System-Modifications">createsUserMessage	(self size = 5 or: [self size = 7]) ifFalse: [^false].	self first isSymbol		ifTrue: 			[self first == #UserMessage				ifFalse: 					[self first == #slar						ifTrue: [^self slarCreatesUserMessage]						ifFalse: [^false]]]		ifFalse: 			[self first isBindingReference				ifTrue: [self first name == #UserMessage ifFalse: [^false]]				ifFalse: [^false]].	(self indexOf: #catalogID:) = 0 ifTrue: [^false].	^true</body><body package="L10n-System-Modifications">slarCreatesUserMessage	(self at: 2) = 'Kernel.UserMessage' ifFalse: [^false].	3 to: self size do: [:each | (self at: each) first = #catalogID ifTrue: [^true]].	^false</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>comparing</category><body package="L10n-System-Modifications">caseInsensitiveSpellAgainst: aString 	^self asLowercase spellAgainst: aString asLowercase</body><body package="L10n-System-Modifications">caseInsensitiveSpellingDifferences: aString 	^self asLowercase spellingDifferences: aString asLowercase	" 'smalltalk' caseInsensitiveSpellingDifferences: 'Smalltlak' "</body><body package="L10n-System-Modifications">compareWithWord: aString caseSensitive: caseSensitive wordWise: wordWise	"	'this is a testSentence' compareWordWise: 'This is a Test Sentence' caseSensitive: true	"	wordWise		ifTrue: [^self compareWordWise: aString caseSensitive: caseSensitive]		ifFalse: 			[^caseSensitive				ifTrue: [self spellAgainst: aString]				ifFalse: [self caseInsensitiveSpellAgainst: aString]]</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private</category><body package="L10n-System-Modifications">compareWords: wordsA with: wordsB caseSensitive: caseSensitive	"	'This is a test sentence' compareWordWise: 'These are Test Sentences' caseSensitive: true 	"	| matchesPercent wordsBStream wordB matchRate referencePercent importance matchPercent |	wordsA size &lt; wordsB size		ifTrue: 			["the algorithm assumes that wordsA is longer or as long as wordsB.			   Ensuring that this is always true, will produce the same results for 				'a-b-c' compareWordWise: 'a-b' caseSensitive: true			   and:				'a-b' compareWordWise: 'a-b-c' caseSensitive: true 			   "			^self compareWords: wordsB with: wordsA caseSensitive: caseSensitive].	matchesPercent := 0.	referencePercent := 0.	wordsBStream := wordsB readStream.	wordsA do: 			[:aWord |			"the importance of separatory is less high than normal words, hence the 0.5 multiplicator.			Consider				 'a test' compareWordWise: 'a test...' caseSensitive: true			which produces a 83% match with less important separators 			as compared to a 75% match with equally important separatory"			importance := (aWord allSatisfy: #isAlphaNumeric)						ifTrue: [1]						ifFalse: [0.5].			matchPercent := wordsBStream atEnd						ifTrue: [0]						ifFalse: 							[wordB := wordsBStream next.							caseSensitive								ifTrue: [wordB spellAgainst: aWord]								ifFalse: [wordB caseInsensitiveSpellAgainst: aWord]].			referencePercent := referencePercent + (100 * importance).			matchesPercent := matchesPercent + (matchPercent * importance)].	matchRate := referencePercent &gt; 0				ifTrue: [matchesPercent / referencePercent]				ifFalse: [wordsA = wordsB ifTrue: [1] ifFalse: [0]].	^(matchRate * 100) asInteger</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>comparing</category><body package="L10n-System-Modifications">compareWordWise: aString caseSensitive: caseSensitive	"	'This is a test sentence' compareWordWise: 'This is a testSentence' caseSensitive: false	"	^self		compareWords: self words		with: aString words		caseSensitive: caseSensitive</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="L10n-System-Modifications">findAllSymbols: subString startingAt: start ifAbsent: aBlock 	"Answer the index of subString within the receiver, starting at start.	If no such match is found, answer the result of evaluating	exceptionBlock. 	'testMe or not, this test is a testMethod with a lot of symbols for test' findAllSymbols: 'test' startingAt:1 ifAbsent:[nil].	'testtest or not, this test is a testMethod with a lot of symbols for test' findAllSymbols: 'test' startingAt:1 ifAbsent:[nil].	'test is a test' findAllSymbols: 'test' startingAt:1 ifAbsent:[nil].	'theTest is a Testingtest' findAllSymbols: 'test' startingAt: 1 ifAbsent:[nil].	"	| res i |	res := OrderedCollection new.	i := start.		[i := self 				findSymbol: subString				startingAt: i				ifAbsent: [nil].	i ifNil: 			["no more are found, return res or if empty evaluage aBlock"			res isEmpty ifTrue: [^aBlock value] ifFalse: [^res]].	"if i is not empty, add it to res"	res add: i.	"go on for next search"	i := i + subString size] 			repeat</body><body package="L10n-System-Modifications">findSymbol: subString startingAt: start ifAbsent: exceptionBlock 	"Answer the index of subString within the receiver, starting at start.	If no such match is found, answer the result of evaluating	exceptionBlock. 	'testMe or not, this test is a testMethod with a lot of symbols for test' findSymbol: 'test' startingAt:1 ifAbsent:[nil].	'testMe or not, this test is a testMethod with a lot of symbols for test' findSymbol: 'test' startingAt:25 ifAbsent:[nil].	'testtest or not, this test is a testMethod with a lot of symbols for test' findSymbol: 'test' startingAt:1 ifAbsent:[nil].	'test is a test' findSymbol: 'test' startingAt:1 ifAbsent:[nil].	'theTest is a Testingtest' findAllSymbols: 'test' startingAt: 1 ifAbsent:[nil].	"	| i end |	i := self 				indexOfSubCollection: subString				startingAt: start				ifAbsent: exceptionBlock.	i isInteger ifFalse: [^i].	end := i + subString size.	(i &gt; 1 ifTrue: [(self at: i - 1) isAlphaNumeric] ifFalse: [false]) 		ifTrue: 			["if there's an alphaNumeric before the current character then this is not the right symbol...go on searching"			^self 				findSymbol: subString				startingAt: end				ifAbsent: exceptionBlock].	end &gt; self size 		ifFalse: 			["we are not at the end, so lets see if the next character is alphanumeric, if so this is not the right symbol and let's continue searching"			(self at: end) isAlphaNumeric 				ifTrue: 					["find next non alphaNumeric, to start next search from there. this should prevent"					^self 						findSymbol: subString						startingAt: end						ifAbsent: exceptionBlock]].	^i</body><body package="L10n-System-Modifications">insertString: replacement from: start to: stop 	"	'thisIsATest' insertString:'ROFL' from:1 to:12	'thisIsATest' insertString:'ROFL' from:5 to:4 	'thisIsATest' insertString:'ROFL' from:6 to:7 	"	| s |	s := self species new writeStream.	start &gt;= 1 ifTrue: [s nextPutAll: (self copyFrom: 1 to: start)].	s nextPutAll: replacement.	stop &lt;= self size 		ifTrue: [s nextPutAll: (self copyFrom: stop to: self size)].	^s contents</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>testing</category><body package="L10n-System-Modifications">isATerm	^L10n.TerminologyController default isATerm: self asString.</body><body package="L10n-System-Modifications">isExcluded	^L10n.TerminologyController default excludeList 		includes: self.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>comparing</category><body package="L10n-System-Modifications">matchSizeWith: aString 	"	'test' matchSizeWith:'testing'	"	| s1 s2 |	s1 := self size.	s2 := aString size.	s1 = s2 ifTrue:[^100].	s1 &gt; s2 ifTrue: [^s2 * 100 // s1] ifFalse: [^s1 * 100 // s2]</body><body package="L10n-System-Modifications">spellingDifferences: aString 	" 'Smalltalk' spellingDifferences: 'Smalltlak' "	| i1 i2 size1 size2 startSame endSame result |	size1 := self size.	size2 := aString size.	result := Array new: size1 withAll: false.	startSame := 1.	[startSame &lt;= size1	 and: [startSame &lt;= size2	 and: [(self at: startSame) = (aString at: startSame)]]] whileTrue:		[result at: startSame put: true. startSame := startSame + 1].	startSame := startSame - 1.	endSame := 0.	(startSame &lt; size1	 and: [startSame &lt; size2]) ifTrue:		[[(i1 := size1 - endSame) &gt; 0		 and: [(i2 := size2 - endSame) &gt; 0		 and: [(self at: i1) = (aString at: i2)]]] whileTrue:			[result at: size1-endSame put: true. endSame := endSame + 1]].	i1 := i2 := startSame + 1.	[i1 &lt;= (size1-endSame) and: [i2 &lt;= (size2-endSame)]] whileTrue:		[(self at: i1) = (aString at: i2)			ifTrue: [result at: i1 put: true. 		"match"					i1 := i1+1. 				"advance both"					i2 := i2+1]			ifFalse: [(i2 &lt; size2 and: [(self at: i1) = (aString at: i2+1)])						ifTrue: [i2 := i2+1] 	"skip in other"			ifFalse: [(i1 &lt; size1 and: [(self at: i1+1) = (aString at: i2)])						ifTrue: [result at: i1 put: false. i1 := i1+1] 	"skip in self"			ifFalse: [result at: i1 put: false. i1 := i1+1. 				"miss - advance both"					i2 := i2+1] ] ] ].	^result</body><body package="L10n-System-Modifications">spellingDifferencesWithWord: aString caseSensitive: caseSensitive	"	'Hallo wir testen hier ob test denn funktionieren' compareWordWise: 'Hallo wir testen hier ob Test denn Funktioniert'	"	^caseSensitive		ifTrue: [aString spellingDifferences: self]		ifFalse: [aString caseInsensitiveSpellingDifferences: self]</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="L10n-System-Modifications">trimNonUnicode	| o high127 |	o := WriteStream on: String new.	high127 := Character value: 127.	self do: 			[:c | 			(c &gt; high127 or: [(XML.CharacterClasses at: c asInteger + 1) &gt; 0]) 				ifTrue: [o nextPut: c]].	^o contents</body><body package="L10n-System-Modifications">withEscapeSequences	"	Shows special characters as escape sequence	'this is a 	test	with tabs and newLines' withEscapeSequences	"	| s |	s := self species new writeStream.	self do: 			[:each | 			each = Character cr 				ifTrue: [s nextPutAll:'\r']				ifFalse: 					[each = Character lf 						ifTrue: [s nextPutAll: '\n']						ifFalse: 							[each = Character tab 								ifTrue: [s nextPutAll: '\t']								ifFalse: [s nextPut: each]]]].	^s contents</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="L10n-System-Modifications">words	"	'I''m a big sentence test, with lots of funny words' words	"	| words r |	words := OrderedCollection new.	r := self readStream.	[r atEnd] whileFalse: 			[words add: r nextWord.			].	^words reject:#isEmpty</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="L10n-System-Modifications">isMethod ^ true</body></methods><methods><class-id>Refactory.Browser.BrowserSourceCodeTool</class-id> <category>tab APIs</category><body package="L10n-RBSupport">isActiveInL10n	^self isActive</body></methods><methods><class-id>Refactory.Browser.CodeModel class</class-id> <category>instance creation</category><body package="L10n-RBSupport">navigator: aNavigator		^(aNavigator dispatcher browser codeModelClass new)		navigator: aNavigator;		yourself</body></methods><methods><class-id>Refactory.Browser.RefactoringBrowser</class-id> <category>initialize-release</category><body package="L10n-RBSupport">codeModelClass		^CodeModel</body></methods><methods><class-id>Refactory.Browser.CodeTool</class-id> <category>tab APIs</category><body package="L10n-RBSupport">isActiveInL10n	^false</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>tab APIs</category><body package="L10n-RBSupport">isActiveInL10n		^self isActive</body></methods><methods><class-id>Refactory.Browser.L10nNavigator class</class-id> <category>interface specs</category><body package="L10n-RBSupport">methodWindowSpec	"UIPainter new openOnClass: self andSelector: #methodWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 800 600 1440 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #methodPart 					#flags: 0 					#majorKey: #{Refactory.Browser.L10nNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #L10nNavigatorPart ) ) ) )</body></methods><methods><class-id>L10n.TranslationChecker class</class-id> <category>resources</category><body package="L10n-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Edit 					#defaultString: 'Edit' 					#catalogID: #Localizer ) 				#nameKey: #edit 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #InvalidTranslation 								#defaultString: 'Invalid Translation' 								#catalogID: #Localizer ) 							#nameKey: #invalidate 							#value: #toggleSelectedKey 							#shortcutKeyCharacter: $s 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowReport 								#defaultString: 'Show Report' 								#catalogID: #Localizer ) 							#nameKey: #showReport 							#value: #showReport ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>L10n.TranslationChecker class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #TranslationChecker 				#defaultString: 'Translation Checker' 				#catalogID: #Localizer ) 			#bounds: #(#{Graphics.Rectangle} 653 324 1268 709 ) 			#flags: 4 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 6 ) 					#name: #LsourceLanguage 					#label: 					#(#{Kernel.UserMessage} 						#key: #SourceLanguage 						#defaultString: 'Source Language' 						#catalogID: #Localizer ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 100 5 200 28 ) 					#name: #sourceLanguage 					#model: #sourceLanguage 					#menu: #sourceLanguages ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 208 7 ) 					#name: #LtranslationLanguage 					#label: 'Translation Language' ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 320 5 420 28 ) 					#name: #targetLanguage 					#model: #targetLanguage 					#menu: #targetLanguages ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 30 0 -5 1 93 0 ) 					#name: #catalogs 					#model: #catalogs 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 95 0 -5 1 -150 1 ) 					#name: #keys 					#model: #keys 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #toggleSelectedKey ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -150 1 -5 1 -145 1 ) 					#name: #listTextSplitter 					#horizontal: true 					#minAboveSize: 130 					#minBelowSize: 140 					#aboveWidgets: ' keys' 					#belowWidgets: 'Ltranslation translation original Loriginal textSplitter' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0 -150 1 ) 					#name: #Loriginal 					#label: 					#(#{Kernel.UserMessage} 						#key: #Original 						#defaultString: 'Original' 						#catalogID: #Localizer ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -130 1 -5 0.4 -5 1 ) 					#name: #original 					#model: #original 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.4 -150 1 2 0.4 -5 1 ) 					#name: #textSplitter 					#horizontal: false 					#minAboveSize: 130 					#minBelowSize: 130 					#aboveWidgets: 'original ' 					#belowWidgets: 'translation Ltranslation' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0.4 -150 1 ) 					#name: #Ltranslation 					#label: 					#(#{Kernel.UserMessage} 						#key: #Translation 						#defaultString: 'Translation' 						#catalogID: #Localizer ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.4 -130 1 -100 1 -5 1 ) 					#name: #translation 					#model: #translation 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -28 1 -5 1 -5 1 ) 					#name: #showReport 					#model: #showReport 					#label: 					#(#{Kernel.UserMessage} 						#key: #ShowReport 						#defaultString: 'Show Report' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -60 1 -5 1 -37 1 ) 					#name: #incorrect 					#model: #toggleSelectedKey 					#label: 					#(#{Kernel.UserMessage} 						#key: #Incorrect 						#defaultString: 'Incorrect' 						#catalogID: #Localizer ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>L10n.TermListUI class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #TermListUI #catalogID: #Localizer #defaultString: 'TermListUI') 			#bounds: #(#{Graphics.Rectangle} 640 512 927 944 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -2 0.75 ) 					#name: #TermListe 					#model: #termlist 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 3 0.75 -5 1 -5 1 ) 					#name: #userMessageList 					#model: #userMessageList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -2 0.75 -5 1 2 0.75 ) 					#name: #GrößenänderungTeiler1 					#horizontal: true 					#minAboveSize: 50 					#minBelowSize: 50 					#aboveWidgets: 'TermListe' 					#belowWidgets: 'userMessageList' ) ) ) )</body></methods><methods><class-id>L10n.TermManagerUI class</class-id> <category>resources</category><body package="L10n-UI">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #NewTerm 					#defaultString: 'New Term' 					#catalogID: #Localizer ) 				#nameKey: #NewTerm 				#value: #newTerm 				#shortcutKeyCharacter: $n 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #fileNew ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #addNewTerm 					#defaultString: 'add a new term' 					#catalogID: #Localizer ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #addTerms 					#defaultString: 'Add Terms' 					#catalogID: #Localizer ) 				#nameKey: #addTerms 				#value: #addTerms 				#shortcutKeyCharacter: $o 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #loadParcel ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #addTermsFromAFileToTheCurrentTerms 					#defaultString: 'Add terms from a file to the current terms' 					#catalogID: #Localizer ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #openTerminology 					#defaultString: 'Open Terminology' 					#catalogID: #Localizer ) 				#nameKey: #openTerminology 				#value: #openTerminology 				#shortcutKeyCharacter: $o 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #fileOpen ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #replaceExistingTermsWithTermsFromFile 					#defaultString: 'Replace the existing terms with terms from a file' 					#catalogID: #Localizer ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #saveTerminology 					#defaultString: 'Save Terminology' 					#catalogID: #Localizer ) 				#nameKey: #saveTerminology 				#value: #saveTerminology 				#shortcutKeyCharacter: $s 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #fileSave ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #writeAllTermsToAFile 					#defaultString: 'Write all terms to a file' 					#catalogID: #Localizer ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #editExcludelist 					#defaultString: 'Edit Excludelist' 					#catalogID: #Localizer ) 				#nameKey: #editExcludelist 				#value: #editExcludelist 				#shortcutKeyCharacter: $l 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #properties ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #editExcludeListHint 					#defaultString: 'Edit the excludelist with all terms that shall not show up in the terms list of the Localizer' 					#catalogID: #Localizer ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #close 					#defaultString: 'Close' 					#catalogID: #Localizer ) 				#nameKey: #close 				#value: #closeAndUnschedule 				#shortcutKeyCharacter: $w 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #abort ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #find 					#defaultString: 'Find' 					#catalogID: #Localizer ) 				#nameKey: #find 				#value: #find 				#shortcutKeyCharacter: $f 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #find ) ) ) #(4 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>L10n.TermManagerUI class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #TerminologyManager 				#defaultString: 'Terminology Manager' 				#catalogID: #Localizer ) 			#min: #(#{Core.Point} 668 318 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 2305 129 3281 758 ) 			#menu: #testMenu 			#toolBar: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 12 0 -1 0 ) 					#name: #Bezeichner6 					#label: 					#(#{Kernel.UserMessage} 						#key: #Terms 						#defaultString: 'Terms' 						#catalogID: #Localizer ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 15 0 215 0 -40 1 ) 					#name: #termlist 					#model: #terms 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #termSelectionChanged ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 -38 1 215 0 -15 1 ) 					#name: #searchField 					#clientKey: #searchField ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 219 0 10 0 220 0 -10 1 ) 					#name: #GrößenänderungTeiler1 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#horizontal: false 					#minAboveSize: 60 					#minBelowSize: 150 					#aboveWidgets: '#searchField #termlist' 					#belowWidgets: '#userMessageDataset #original #originalField #translation #translationField #synonym #synonymField' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 227 0 5 0 ) 					#name: #original 					#label: 					#(#{Kernel.UserMessage} 						#key: #Original 						#defaultString: 'Original' 						#catalogID: #Localizer ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 227 0 25 0 434 0 48 0 ) 					#name: #originalField 					#model: #original ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 227 0 46 0 ) 					#name: #translation 					#label: 					#(#{Kernel.UserMessage} 						#key: #Translation 						#defaultString: 'Translation' 						#catalogID: #Localizer ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 227 0 65 0 434 0 88 0 ) 					#name: #translationField 					#model: #translation ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 226 0 88 0 ) 					#name: #synonym 					#label: 					#(#{Kernel.UserMessage} 						#key: #Synonym 						#defaultString: 'Synonym' 						#catalogID: #Localizer ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 227 0 109 0 434 0 130 0 ) 					#name: #synonymField 					#model: #synonym ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 228 0 133 0 ) 					#name: #Bezeichner5 					#label: 					#(#{Kernel.UserMessage} 						#key: #Source 						#defaultString: 'Source' 						#catalogID: #Localizer ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 227 0 153 0 434 0 174 0 ) 					#name: #source 					#model: #source 					#isReadOnly: false 					#comboList: #sourceList ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 227 0 182 0 ) 					#name: #Kontrollkästchen1 					#model: #valid 					#label: 					#(#{Kernel.UserMessage} 						#key: #Valid 						#defaultString: 'Valid' 						#catalogID: #Localizer ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 458 0 5 0 ) 					#name: #Bezeichner3 					#label: 					#(#{Kernel.UserMessage} 						#key: #Comments 						#defaultString: 'Comments' 						#catalogID: #Localizer ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 459 0 25 0 -16 1 288 0 ) 					#name: #comments 					#model: #comments 					#style: #system 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 227 0 288 0 -10 1 292 0 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 200 					#minBelowSize: 50 					#aboveWidgets: 'comments' 					#belowWidgets: '#userMessageDataset' ) 				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 228 0 296 0 -15 1 -43 1 ) 					#name: #userMessageDataset 					#flags: 13 					#model: #userMessageList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #doubleClickedMessage ) 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedUserMessage key' 							#label: 							#(#{Kernel.UserMessage} 								#key: #UserMessage 								#defaultString: 'UserMessage' 								#catalogID: #Localizer ) 							#labelIsImage: false 							#width: 234 							#rendererType: #Text 							#editorType: #None 							#noScroll: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedUserMessage catalog' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Catalog 								#defaultString: 'Catalog' 								#catalogID: #Localizer ) 							#labelIsImage: false 							#width: 150 							#rendererType: #Text 							#editorType: #None 							#noScroll: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedUserMessage sourceString' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Source 								#defaultString: 'Source' 								#catalogID: #Localizer ) 							#labelIsImage: false 							#width: 264 							#rendererType: #Text 							#editorType: #None 							#noScroll: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #currentTranslation 							#label: 							#(#{Kernel.UserMessage} 								#key: #Translation 								#defaultString: 'Translation' 								#catalogID: #Localizer ) 							#labelIsImage: false 							#width: 214 							#rendererType: #Text 							#editorType: #None 							#noScroll: true ) ) 					#labelsAsButtons: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -215 1 -35 1 -120 1 -15 1 ) 					#name: #Aktionsknopf2 					#model: #ok 					#label: 					#(#{Kernel.UserMessage} 						#key: #Apply 						#defaultString: 'Apply' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -110 1 -35 1 -15 1 -15 1 ) 					#name: #Aktionsknopf1 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Reset 						#defaultString: 'Reset' 						#catalogID: #Localizer ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Refactory.Browser.L10nMessagesNavigatorPart class</class-id> <category>interface specs</category><body package="L10n-RBSupport">basicWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #basicWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #browser ) 			#bounds: #(#{Graphics.Rectangle} 640 512 840 712 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dropSelector 						#drop: #dragStartSelector 						#doDrag: #dragOverSelector 						#dragOver: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #objectList 					#model: #objectList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changed 						#doubleClickSelector: #doubleClickItem 						#requestValueChangeSelector: #changeRequest ) 					#menu: #menu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>L10n.ExportUI class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ExportTranslationMemory 				#defaultString: 'Export Translation Memory' 				#catalogID: #Localizer ) 			#min: #(#{Core.Point} 447 209 ) 			#max: #(#{Core.Point} 447 209 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1087 721 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 212 22 433 44 ) 					#name: #Catalog 					#model: #Catalog ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 114 22 208 46 ) 					#name: #CatalogChoices 					#model: #CatalogChoices 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #AvailableCatalogs ) 					#comboList: #AvailableCatalogs ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 212 58 433 82 ) 					#name: #Date 					#model: #Date 					#type: #string ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 114 58 208 82 ) 					#name: #DateHandling 					#model: #DateHandling 					#comboList: #AvailableDateHandles ) 				#(#{UI.RadioButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Core.Point} 25 113 ) 					#name: #RadioButton1 					#model: #translations 					#label: 					#(#{Kernel.UserMessage} 						#key: #AllTranslationsInTranslationMemory 						#defaultString: 'All Translations in Translation Memory' 						#catalogID: #Localizer ) 					#select: #Alles ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 25 141 ) 					#name: #RadioButton2 					#model: #translations 					#label: 					#(#{Kernel.UserMessage} 						#key: #TranslationsfromtheTranslator 						#defaultString: 'Translations from the Translator' 						#catalogID: #Localizer ) 					#select: #Translator ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 19 22 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Catalogs 						#defaultString: 'Catalog(s)' 						#catalogID: #Localizer ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 19 58 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #Date 						#defaultString: 'Date' 						#catalogID: #Localizer ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 18 90 433 165 ) 					#name: #GroupBox1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Translations 						#defaultString: 'Translations' 						#catalogID: #Localizer ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 19 207 341 230 ) 					#name: #InputField1 					#flags: 0 					#model: #ErrorText 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 81 22 111 46 ) 					#name: #Aktionsknopf1 					#model: #allCatalogs 					#label: 					#(#{Kernel.UserMessage} 						#key: #All 						#defaultString: 'All' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} -93 1.0 -35 1.0 81 23 ) 					#name: #ExportButton 					#model: #StartExport 					#label: 					#(#{Kernel.UserMessage} 						#key: #Export 						#defaultString: 'Export' 						#catalogID: #Localizer ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>L10n.UnloadCatalogsUI class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnloadCatalogsfromTranslationMemory 				#defaultString: 'Unload Catalogs from Translation Memory' 				#catalogID: #Localizer ) 			#min: #(#{Core.Point} 447 93 ) 			#max: #(#{Core.Point} 447 93 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1087 605 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 212 22 433 44 ) 					#name: #Catalog 					#model: #TMCatalog ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 114 22 208 46 ) 					#name: #CatalogChoices 					#model: #TMCatalogChoices 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #AvailableCatalogs ) 					#comboList: #TMAvailableCatalogs ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 352 53 433 76 ) 					#name: #UnloadButton 					#model: #StartUnload 					#label: 					#(#{Kernel.UserMessage} 						#key: #Unload 						#defaultString: 'Unload' 						#catalogID: #Localizer ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 19 22 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Catalogs 						#defaultString: 'Catalog(s)' 						#catalogID: #Localizer ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 114 53 340 75 ) 					#name: #InputField1 					#flags: 0 					#model: #ErrorText 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 19 53 100 76 ) 					#name: #CancelButton 					#model: #Cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 87 22 109 46 ) 					#name: #AllCatalogs 					#model: #AllCatalogs 					#label: 					#(#{Kernel.UserMessage} 						#key: #All 						#defaultString: 'All' 						#catalogID: #Localizer ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>L10n.AccessKeyFixer class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #AccessKeyFixer 				#defaultString: 'AccessKey Fixer' 				#catalogID: #Localizer ) 			#min: #(#{Core.Point} 449 153 ) 			#max: #(#{Core.Point} 449 153 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1089 665 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 14 0 85 0 -13 1 100 0 ) 					#name: #characterPosSlider 					#model: #characterPosition 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #characterPosChanged ) 					#orientation: #horizontal 					#start: 1 					#stop: 20 					#step: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 7 ) 					#name: #Bezeichner1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Label 						#defaultString: 'Label:' 						#catalogID: #Localizer ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -243 1 -36 1 -133 1 -13 1 ) 					#name: #Aktionsknopf1 					#model: #ok 					#label: 					#(#{Kernel.UserMessage} 						#key: #UsethisAccessKey 						#defaultString: 'Use this Access Key' 						#catalogID: #Localizer ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -123 1 -36 1 -13 1 -13 1 ) 					#name: #Aktionsknopf2 					#model: #close 					#label: 					#(#{Kernel.UserMessage} 						#key: #UsenoAccessKey 						#defaultString: 'Use no Access Key' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 13 0 26 0 -13 1 69 0 ) 					#name: #'Text-Editor1' 					#flags: 4 					#model: #labelPreview 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 14 0 -36 1 114 0 -13 1 ) 					#name: #Eingabefeld1 					#flags: 0 					#model: #ValidKey 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>L10n.EditTermUI class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #screenCenter #openType #advanced ) 			#label: 			#(#{Kernel.UserMessage} 				#key: #EditTerm 				#defaultString: 'Edit Term' 				#catalogID: #Localizer ) 			#min: #(#{Core.Point} 450 184 ) 			#max: #(#{Core.Point} 450 184 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1090 696 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 17 0 25 0 -220 1 48 0 ) 					#name: #Eingabefeld1RO 					#model: #original 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 17 0 25 0 -220 1 48 0 ) 					#name: #Eingabefeld1 					#model: #original ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 3 ) 					#name: #Bezeichner1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Original 						#defaultString: 'Original' 						#catalogID: #Localizer ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 17 0 70 0 -220 1 93 0 ) 					#name: #Eingabefeld2 					#model: #translation ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 49 ) 					#name: #Bezeichner2 					#label: 					#(#{Kernel.UserMessage} 						#key: #Translation 						#defaultString: 'Translation' 						#catalogID: #Localizer ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -200 1 1 0 ) 					#name: #Bezeichner3 					#label: 					#(#{Kernel.UserMessage} 						#key: #Comments 						#defaultString: 'Comments' 						#catalogID: #Localizer ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 17 0 115 0 -220 1 138 0 ) 					#name: #Eingabefeld4 					#model: #synonym ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 95 ) 					#name: #Bezeichner4 					#label: 					#(#{Kernel.UserMessage} 						#key: #Synonym 						#defaultString: 'Synonym' 						#catalogID: #Localizer ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -200 1 -90 1 ) 					#name: #Bezeichner5 					#label: 					#(#{Kernel.UserMessage} 						#key: #Source 						#defaultString: 'Source' 						#catalogID: #Localizer ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} -200 1 24 0 -15 1 -90 1 ) 					#name: #'Text-Editor1' 					#model: #comments 					#tabRequiresControl: true ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} -200 1 -70 1 -105 1 -45 1 ) 					#name: #Kombinationsfeld1 					#model: #source 					#isReadOnly: false 					#comboList: #sources ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} -95 1 -65 1 ) 					#name: #Kontrollkästchen1 					#model: #isValid 					#label: 					#(#{Kernel.UserMessage} 						#key: #valid 						#defaultString: 'valid' 						#catalogID: #Localizer ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -185 1 -40 1 -105 1 -15 1 ) 					#name: #Aktionsknopf1 					#model: #ok 					#label: 					#(#{Kernel.UserMessage} 						#key: #Ok 						#defaultString: 'Ok' 						#catalogID: #Localizer ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -95 1 -40 1 -15 1 -15 1 ) 					#name: #Aktionsknopf2 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 130 146 230 169 ) 					#name: #lookupMenu 					#model: #lookUp 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #lookUpAction ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #dictionary 						#defaultString: 'Dictionary' 						#catalogID: #Localizer ) 					#menu: #lookUpMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 146 ) 					#name: #lookUpLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #lookupOnlineUsing 						#defaultString: 'Lookup online using' 						#catalogID: #Localizer ) ) ) ) )</body></methods><methods><class-id>L10n.CanvasViewer class</class-id> <category>interface specs</category><body package="L10n-RBSupport">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #labels ) 			#bounds: #(#{Graphics.Rectangle} 512 384 699 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 31 0 0 1 0 1 ) 					#name: #visualisationSubcanvas ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 3 3 78 28 ) 					#name: #editButton 					#model: #editSpec 					#label: 					#(#{Kernel.UserMessage} 						#key: #edit 						#defaultString: 'Edit' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 81 3 156 28 ) 					#name: #ActionButton1 					#model: #openSpec 					#label: 					#(#{Kernel.UserMessage} 						#key: #open 						#defaultString: 'Open' 						#catalogID: #Localizer ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Refactory.Browser.L10nNavigatorPart class</class-id> <category>interface specs</category><body package="L10n-RBSupport">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #browser ) 			#bounds: #(#{Graphics.Rectangle} 640 512 840 712 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 15 0 0 0.5 0 1 ) 					#name: #subcanvas 					#flags: 0 					#majorKey: #{Refactory.Browser.MethodNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #methods ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 15 0 0 1 0 1 ) 					#name: #messages 					#flags: 0 					#majorKey: #{Refactory.Browser.L10nMessagesNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #messages ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #splitter 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'subcanvas methodsLabel' 					#belowWidgets: 'messages messageLabel' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 2 0.5 -4 0 ) 					#name: #messageLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #UserMessagesInThisMethod 						#defaultString: 'UserMessages in this method' 						#catalogID: #Localizer ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -4 0 0 0.5 17 0 ) 					#name: #methodsLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #methodUserMessages 						#defaultString: 'methods' 						#catalogID: #Localizer ) ) ) ) )</body></methods><methods><class-id>L10n.MenuViewer class</class-id> <category>interface specs</category><body package="L10n-RBSupport">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #labels ) 			#bounds: #(#{Graphics.Rectangle} 640 512 840 712 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 134 18 234 43 ) 					#name: #previewMenuButton 					#label: 					#(#{Kernel.UserMessage} 						#key: #Menu 						#defaultString: 'Menu' 						#catalogID: #menus ) 					#menu: #menuResource ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 15 18 96 43 ) 					#name: #editButton 					#model: #editSpec 					#label: 					#(#{Kernel.UserMessage} 						#key: #edit 						#defaultString: 'Edit' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 245 0 18 0 -15 1 50 0 ) 					#name: #Path ) ) ) )</body></methods><methods><class-id>L10n.ExistingTranslationsUI class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #Localizer ) 			#bounds: #(#{Graphics.Rectangle} 616 325 1304 707 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 1 4 0 -20 1 23 0 ) 					#name: #Listenfeld2 					#model: #matching 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#focusOutSelector: #matchingChanged 						#valueChangeSelector: #matchingChanged ) 					#isReadOnly: false 					#type: #number 					#formatString: '0' 					#low: 30 					#high: 100 					#interval: 1 ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 25 0 -3 1 -3 1 ) 					#name: #Liste2 					#flags: 15 					#model: #existingTranslations 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #singleClickOnExistingTranslation 						#doubleClickSelector: #doubleClickOnExistingTranslation ) 					#style: #fixed 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} -150 1 3 0 -85 1 26 0 ) 					#name: #Bezeichner1 					#label: 					#(#{Kernel.UserMessage} 						#key: #matching 						#defaultString: 'Matching:' 						#catalogID: #Localizer ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} -18 1 1 0 -5 1 23 0 ) 					#name: #Bezeichner2 					#label: '%' ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} -248 1 3 0 -158 1 23 0 ) 					#name: #Kombinationsfeld2 					#model: #numberToShow 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #numberToShowChanged ) 					#comboList: #numbersToShow ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} -350 1 2 0 -255 1 25 0 ) 					#name: #Bezeichner3 					#label: 					#(#{Kernel.UserMessage} 						#key: #numberToShow 						#defaultString: 'Number to show:' 						#catalogID: #Localizer ) ) ) ) )</body></methods><methods><class-id>L10n.L10nUI class</class-id> <category>resources</category><body package="L10n-UI">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #system 					#defaultString: 'System' 					#catalogID: #Localizer ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #readSystem 								#defaultString: 'Read System' 								#catalogID: #Localizer ) 							#nameKey: #readSystem 							#value: #readSystem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExportCatalogs 								#defaultString: 'Export Catalogs' 								#catalogID: #Localizer ) 							#nameKey: #exportCatalogs 							#value: #exportCatalogs ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SystemLanguage 								#defaultString: 'Use System Language' 								#catalogID: #Localizer ) 							#nameKey: #systemLanguage 							#value: #systemLanguage 							#indication: true 							#indicationSelector: #systemLanguageOn 							#helpText: 							#(#{Kernel.UserMessage} 								#key: #SystemLanguageHelp 								#defaultString: 'Show VisualWorks in System Language, or in C_none' 								#catalogID: #Localizer ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #options 								#defaultString: 'Options' 								#catalogID: #Localizer ) 							#nameKey: #optionsMenu 							#value: #showOptions ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #closeLocalizer 								#defaultString: 'Close Localizer' 								#catalogID: #Localizer ) 							#nameKey: #closeLocalizer 							#value: #closeAndUnschedule 							#shortcutKeyCharacter: $w 							#shortcutModifiers: 2 ) ) #(2 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #edit 					#defaultString: 'Edit' 					#catalogID: #Localizer ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #acceptTranslation 								#defaultString: 'Accept Translation' 								#catalogID: #Localizer ) 							#nameKey: #acceptTranslation 							#value: #acceptTranslation 							#shortcutKeyCharacter: $s 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddWithNewKey 								#defaultString: 'Add with new Key' 								#catalogID: #Localizer ) 							#enabled: false 							#nameKey: #acceptWithNewKey 							#value: #acceptWithNewKey 							#enablementSelector: #canAddWithNewKey 							#shortcutKeyCharacter: $s 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #find 								#defaultString: 'Find' 								#catalogID: #Localizer ) 							#nameKey: #find 							#value: #selectFilter 							#shortcutKeyCharacter: $f 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #showTerminology 								#defaultString: 'Show Terminology' 								#catalogID: #Localizer ) 							#nameKey: #showTerminology 							#value: #selectTerminology 							#shortcutKeyCharacter: $t 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #showExistingTrasnaltions 								#defaultString: 'Show Existing Translations' 								#catalogID: #Localizer ) 							#nameKey: #showExistingTranslations 							#value: #selectExistingTranslations 							#shortcutKeyCharacter: $t 							#shortcutModifiers: 3 ) ) #(2 1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #translationMemory 					#defaultString: 'Translation Memory' 					#catalogID: #Localizer ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #unloadCatalogs 								#defaultString: 'Unload Catalogs' 								#catalogID: #Localizer ) 							#nameKey: #unloadCatalogs 							#value: #unloadCatalogs ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #emptyTM 								#defaultString: 'Empty TM' 								#catalogID: #Localizer ) 							#nameKey: #emptyTM 							#value: #emptyTM ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #tmStats 								#defaultString: 'TM Stats' 								#catalogID: #Localizer ) 							#nameKey: #tmStats 							#value: #tmStats ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Import 								#defaultString: 'Import' 								#catalogID: #Localizer ) 							#nameKey: #import 							#value: #import ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #importFolder 								#defaultString: 'Import Folder' 								#catalogID: #Localizer ) 							#nameKey: #importFolder 							#value: #importFolder ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Export 								#defaultString: 'Export' 								#catalogID: #Localizer ) 							#nameKey: #export 							#value: #export ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #checkTranslations 								#defaultString: 'Check Translations' 								#catalogID: #Localizer ) 							#nameKey: #checkTranslations 							#value: #checkTranslations ) ) #(3 2 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Terminology 					#defaultString: 'Terminology' 					#catalogID: #Localizer ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #TerminologyManager 								#defaultString: 'Terminology Manager' 								#catalogID: #Localizer ) 							#nameKey: #termManager 							#value: #termManager 							#shortcutKeyCharacter: $m 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #editExcludelist 								#defaultString: 'Edit Excludelist' 								#catalogID: #Localizer ) 							#nameKey: #editExcludelist 							#value: #editExcludelist 							#shortcutKeyCharacter: $l 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #emptyTerminology 								#defaultString: 'Empty Terminology' 								#catalogID: #Localizer ) 							#nameKey: #emptyTerminology 							#value: #emptyTerminology ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ImportTerminology 								#defaultString: 'Import Terminology' 								#catalogID: #Localizer ) 							#nameKey: #ImportTerminology 							#value: #importTerminology ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #exportTerminology 								#defaultString: 'Export Terminology' 								#catalogID: #Localizer ) 							#nameKey: #exportTerminology 							#value: #exportTerminology ) ) #(3 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'debug' 				#hidden: true 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'refreshUI' 							#value: #refreshUI ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #importFinished 								#defaultString: 'importFinished' 								#catalogID: #Localizer ) 							#value: #importFinished ) ) #(2 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>L10n.L10nUI class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #localizer 				#defaultString: 'Localizer' 				#catalogID: #Localizer ) 			#min: #(#{Core.Point} 822 700 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 448 145 1472 895 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 346 0 25 0.845052 -15 1 -40 1 ) 					#name: #yourTranslation 					#model: #yourTranslation 					#tabable: true 					#tabRequiresControl: false ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 61 0 326 0 -40 1 ) 					#name: #SelectionTab 					#model: #selectionTab 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #selectionTabChanged ) 					#labels: #(						#(#{Kernel.UserMessage} 							#key: #Catalog 							#defaultString: 'Catalog' 							#catalogID: #Localizer ) 						#(#{Kernel.UserMessage} 							#key: #Terms 							#defaultString: 'Terms' 							#catalogID: #Localizer ) ) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 -35 1 325 0 -15 1 ) 					#name: #searchField 					#clientKey: #searchField ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 0 0.971354 0 0.0839844 0 0.99349 ) 					#name: #showAll 					#flags: 56 					#model: #showAll 					#label: 					#(#{Kernel.UserMessage} 						#key: #showAll 						#defaultString: 'Show All' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 334 0 0 0.0182292 338 0 0 0.983073 ) 					#name: #Divider1 					#orientation: #vertical ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0 31 0 ) 					#name: #Label8 					#label: 					#(#{Kernel.UserMessage} 						#key: #targetLangSpecs 						#defaultString: 'Target Language Specification:' 						#catalogID: #Localizer ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0 2 0 ) 					#name: #Label9 					#label: 					#(#{Kernel.UserMessage} 						#key: #sourceLangSpecs 						#defaultString: 'Source Language Specification:' 						#catalogID: #Localizer ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 225 0 4 0 325 0 27 0 ) 					#name: #sourceLangSpec 					#model: #sourceLangSpec 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #sourceChanged ) 					#numChars: 1 					#type: #string 					#comboList: #sourceLangChoice ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 225 0 33 0 325 0 56 0 ) 					#name: #targetLangSpec 					#model: #targetLangSpec 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #targetChanged ) 					#isReadOnly: false 					#type: #string 					#comboList: #targetLangChoice ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -135 1 -35 1 -15 1 -15 1 ) 					#name: #acceptTranslation 					#model: #acceptTranslation 					#label: 					#(#{Kernel.UserMessage} 						#key: #acceptTranslation 						#defaultString: 'Accept Translation' 						#catalogID: #Localizer ) 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -255 1 -35 1 -145 1 -15 1 ) 					#name: #addWithNewKey 					#flags: 40 					#model: #AddWithNewKey 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddWithNewKey 						#defaultString: 'Add with new Key' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 346 0 0 0.845052 460 0 20 0.845052 ) 					#name: #Label5 					#label: 					#(#{Kernel.UserMessage} 						#key: #yourTranslation 						#defaultString: 'Your Translation' 						#catalogID: #Localizer ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -300 1 0 0.845052 ) 					#name: #TranslationStatusLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #translationStatus 						#defaultString: 'Translation Status' 						#catalogID: #Localizer ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} -200 1 0 0.845052 185 21 ) 					#name: #translationStatus 					#model: #translationStatus 					#isReadOnly: false 					#comboList: #translationStatusMenu ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 345 0 297 0 -15 1 301 0 ) 					#name: #GrößenänderungTeiler2 					#horizontal: true 					#minAboveSize: 200 					#minBelowSize: 200 					#aboveWidgets: 'preview' 					#belowWidgets: 'unterVorschau' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 346 0 4 0 -15 1 204 0 ) 					#name: #preview 					#flags: 0 					#clientKey: #preview ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.TabControlSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 143 0 0 1 0 0.987097 ) 							#name: #termTab 							#model: #termTab 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #changedTermTabs ) 							#labels: #(								#(#{Kernel.UserMessage} 									#key: #ExistingTranslations 									#defaultString: 'Existing Translations' 									#catalogID: #Localizer ) 								#(#{Kernel.UserMessage} 									#key: #Terminology 									#defaultString: 'Terminology' 									#catalogID: #Localizer ) ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#name: #defaultStringLab 							#label: 							#(#{Kernel.UserMessage} 								#key: #sourcedefaultString 								#defaultString: 'Default-String' 								#catalogID: #Localizer ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 67 0 87 0 82 0 ) 							#name: #translationLab 							#label: 							#(#{Kernel.UserMessage} 								#key: #translation 								#defaultString: 'Translations:' 								#catalogID: #Localizer ) ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 83 0 0 0 0 0.996992 63 0 ) 							#name: #sourceDefaultString 							#colors: 							#(#{UI.LookPreferences} 								#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 							#model: #sourceDefaultString 							#isReadOnly: true ) 						#(#{UI.SequenceViewSpec} 							#layout: #(#{Graphics.LayoutFrame} 83 0 65 0 0 0.996992 138 0 ) 							#name: #targetDefaultStringsList 							#flags: 15 							#model: #targetDefaultString 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #targetDefaultStringChanged ) 							#style: #fixed 							#useModifierKeys: true 							#selectionType: #highlight ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 346 0 212 0 -13 1 0 0.84478 ) 						#name: #unterVorschau ) ) ) ) )</body></methods><methods><class-id>L10n.UserMessagesListUI class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UserMessagesListUI 				#defaultString: 'UserMessagesListUI' 				#catalogID: #Localizer ) 			#bounds: #(#{Graphics.Rectangle} 834 288 1086 753 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 145 0 -5 1 -5 1 ) 					#name: #userMessagesList 					#model: #userMessages 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 30 0 -5 1 120 0 ) 					#name: #systemCatalogsList 					#model: #systemCatalogsSelectionInList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0 6 0 ) 					#name: #Bezeichner1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Catalog 						#defaultString: 'Catalog' 						#catalogID: #Localizer ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0 125 0 ) 					#name: #Bezeichner2 					#label: 					#(#{Kernel.UserMessage} 						#key: #UserMessages 						#defaultString: 'UserMessages' 						#catalogID: #Localizer ) ) ) ) )</body></methods><methods><class-id>L10n.L10nOverviewTool class</class-id> <category>interface specs</category><body package="L10n-RBSupport">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #labels ) 			#bounds: #(#{Graphics.Rectangle} 640 512 827 712 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #InputField1 					#model: #textHolder 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>L10n.CatalogExport class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ExportCatalogs 				#defaultString: 'Export Catalogs' 				#catalogID: #Localizer ) 			#bounds: #(#{Graphics.Rectangle} 632 345 1049 666 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 10 0 ) 					#name: #Ldirectory 					#label: 					#(#{Kernel.UserMessage} 						#key: #directory_ 						#defaultString: 'Directory:' 						#catalogID: #Localizer ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 30 0 -55 1 51 0 ) 					#name: #exportDirectory 					#model: #exportDirectory ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -50 1 30 0 -10 1 51 0 ) 					#name: #selectDirectoy 					#model: #selectDirectory 					#label: 					#(#{Kernel.UserMessage} 						#key: #threeDots 						#defaultString: '...' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 60 0 ) 					#name: #Lcatalogs 					#label: 					#(#{Kernel.UserMessage} 						#key: #Catalogs_ 						#defaultString: 'Catalogs:' 						#catalogID: #Localizer ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 80 0 -10 1 -80 1 ) 					#name: #catalogs 					#model: #catalogs 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #checkMark ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 -75 1 ) 					#name: #exportSourceLanguage 					#model: #exportSourceLanguage 					#label: 					#(#{Kernel.UserMessage} 						#key: #ExportSourceLanguage 						#defaultString: 'Export Source Language' 						#catalogID: #Localizer ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 221 0 -75 1 271 0 -60 1 ) 					#name: #sourceLanguage 					#flags: 0 					#model: #sourceLanguage 					#isReadOnly: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 -55 1 ) 					#name: #exportTargetLanguage 					#model: #exportTargetLanguage 					#label: 					#(#{Kernel.UserMessage} 						#key: #ExportTargetLanguage 						#defaultString: 'Export Target Language' 						#catalogID: #Localizer ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 221 0 -55 1 271 0 -40 1 ) 					#name: #targetLanguage 					#flags: 0 					#model: #targetLanguage 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -100 1 -33 1 -10 1 -10 1 ) 					#name: #export 					#model: #export 					#label: 					#(#{Kernel.UserMessage} 						#key: #Export 						#defaultString: 'Export' 						#catalogID: #Localizer ) 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -280 1 -30 1 -120 1 -10 1 ) 					#name: #exportForAllLanguages 					#model: #exportForAllLanguages 					#label: 					#(#{Kernel.UserMessage} 						#key: #exportForAllLanguages 						#defaultString: 'Export for all Languages' 						#catalogID: #L10n ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>L10n.EditExcludeListUI class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #editExcludelist 				#defaultString: 'Edit Excludelist' 				#catalogID: #Localizer ) 			#min: #(#{Core.Point} 289 372 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 929 884 ) 			#toolBar: #toolbar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 14 0 17 0 -14 1 -55 1 ) 					#name: #excludelist 					#model: #excludelist 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 15 0 -50 1.0 16 16 ) 					#name: #Aktionsknopf3 					#model: #add 					#label: '+' 					#style: #small 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 34 0 -50 1 16 16 ) 					#name: #Aktionsknopf4 					#model: #remove 					#label: '-' 					#style: #large 					#isDefault: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 15 0 -30 1.0 81 23 ) 					#name: #Aktionsknopf2 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} -95 1.0 -30 1 81 23 ) 					#name: #Aktionsknopf1 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #accept 						#defaultString: 'Accept' 						#catalogID: #Localizer ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>L10n.EditExcludeListUI class</class-id> <category>resources</category><body package="L10n-UI">toolbar	"Tools.MenuEditor new openOnClass: self andSelector: #toolbar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #new 					#defaultString: 'New' 					#catalogID: #Localizer ) 				#nameKey: #add 				#value: #add 				#shortcutKeyCharacter: $n 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #fileNew ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #open 					#defaultString: 'Open' 					#catalogID: #Localizer ) 				#nameKey: #open 				#value: #openFile 				#shortcutKeyCharacter: $o 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #fileOpen ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #save 					#defaultString: 'Save' 					#catalogID: #Localizer ) 				#nameKey: #save 				#value: #save 				#shortcutKeyCharacter: $s 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #fileSave ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Remove 					#defaultString: 'Remove' 					#catalogID: #Localizer ) 				#nameKey: #remove 				#value: #remove 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #delete ) ) ) #(4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>L10n.TerminologyUI class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Terminology 				#defaultString: 'Terminology' 				#catalogID: #Localizer ) 			#bounds: #(#{Graphics.Rectangle} 740 391 1180 650 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 191 0 11 0 260 0 35 0 ) 					#name: #RemoveTermButton 					#model: #RemoveSeletedTerm 					#label: 					#(#{Kernel.UserMessage} 						#key: #remove 						#defaultString: 'remove' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 -23 1 100 0 -3 1 ) 					#name: #newButton 					#model: #newTerm 					#label: 					#(#{Kernel.UserMessage} 						#key: #NewTerm 						#defaultString: 'New Term' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 222 0 -23 1 334 0 -3 1 ) 					#name: #removeButton 					#model: #removeTerm 					#label: 					#(#{Kernel.UserMessage} 						#key: #RemoveTerm 						#defaultString: 'Remove Term' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 11 0 186 0 35 0 ) 					#name: #TermMenu 					#model: #termMenuAspect 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #termMenuAspectChanged ) 					#comboList: #termMenu ) 				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #allowColumnReordering false #rowLabelsAsButtons true ) 					#layout: #(#{Graphics.LayoutFrame} 7 0 40 0 -7 1 -27 1 ) 					#name: #Datensatz1 					#model: #terminologyTable 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #terminologyDoubleClick ) 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true #allowSorting true #allowResizing true ) 							#model: #'selectedRow original' 							#label: #Original 							#labelIsImage: false 							#width: 79 							#rendererType: #Text 							#editorType: #None 							#noScroll: true 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting true #allowResizing true ) 							#model: #'selectedRow translation' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Translation 								#defaultString: 'Translation' 								#catalogID: #Localizer ) 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: true 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting true #allowResizing true ) 							#model: #'selectedRow synonym' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Synonym 								#defaultString: 'Synonym' 								#catalogID: #Localizer ) 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: true 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting true #allowResizing true ) 							#model: #'selectedRow notes' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Comment 								#defaultString: 'Comment' 								#catalogID: #Localizer ) 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: true 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting true #allowResizing true ) 							#model: #'selectedRow source' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Source 								#defaultString: 'Source' 								#catalogID: #Localizer ) 							#labelIsImage: false 							#width: 82 							#rendererType: #Text 							#editorType: #None 							#noScroll: true 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting true #allowResizing true ) 							#model: #'selectedRow valid' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Valid 								#defaultString: 'Valid' 								#catalogID: #Localizer ) 							#labelIsImage: false 							#width: 33 							#rendererType: #Text 							#editorType: #None 							#noScroll: true 							#labelsAsButtons: true ) ) 					#labelsAsButtons: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 105 0 -23 1 219 0 -3 1 ) 					#name: #editButton 					#model: #editTerm 					#label: 					#(#{Kernel.UserMessage} 						#key: #EditTerm 						#defaultString: 'Edit Term' 						#catalogID: #Localizer ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -147 1 -24 1 -10 1 -4 1 ) 					#name: #Aktionsknopf1 					#model: #openTermManager 					#label: 					#(#{Kernel.UserMessage} 						#key: #TermManager 						#defaultString: 'Term Manager' 						#catalogID: #Localizer ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>L10n.RBContainer class</class-id> <category>interface specs</category><body package="L10n-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #labels ) 			#bounds: #(#{Graphics.Rectangle} 640 512 840 712 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #Unterleinwand1 					#flags: 0 					#majorKey: #{Refactory.Browser.RefactoringBrowser} 					#minorKey: #windowSpec 					#clientKey: #dependentRB ) ) ) )</body></methods><methods><class-id>L10n.RBContainer class</class-id> <category>resources</category><body package="L10n-UI">stepMenu	"Tools.MenuEditor new openOnClass: self andSelector: #stepMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #next 					#defaultString: 'next' 					#catalogID: #Localizer ) 				#nameKey: #nextUserMessageMenuButton 				#value: #nextUserMessage ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="L10n-System-Modifications">noteBookWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #noteBookWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue blue; at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4914 scaledBlue: 8191); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 7098); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3D@@@@@@@@@L0@@L1@3L3L3L3L@L0@@L1@@@@@@@@@0L0@@L1@#H2L#H2@0L0@@L1@2L#H2L#@3L0@@L1@#@@@@@2ADL0@@L1@2@3L3@#@0L0@@L1@#@@@@@2@0L0@@L1@2L#H2L#@3L0@@L1@#H2L#H2ADL0@@L1@2L#H2L#@0L0@@L1@#H2L#H2@0L0@@L1@2L#H2L#@0L0@@L1@#H2L#H2@3L0@@L1@2L#H2L#ADL0@@L1@#H2L#H2@0L0@@L1@2L#H2L#@0L0@@L1@@@@@@@@@3L0@@L3L3L3L3L3L3L0@@'))</body><body package="L10n-System-Modifications">noteBookWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #noteBookWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 31 255 192 0 48 0 192 0 63 255 64 0 58 171 64 0 53 85 0 0 59 251 192 0 54 13 64 0 59 251 64 0 53 85 0 0 58 171 192 0 53 85 64 0 58 171 64 0 53 85 64 0 58 171 0 0 53 85 192 0 58 171 64 0 53 85 64 0 63 255 0 0 0 0 0 0])</body><body package="L10n-System-Modifications">noteBookWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #noteBookWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 31 255 192 0 63 255 192 0 63 255 64 0 63 255 64 0 63 255 0 0 63 255 192 0 63 255 64 0 63 255 64 0 63 255 0 0 63 255 192 0 63 255 64 0 63 255 64 0 63 255 64 0 63 255 0 0 63 255 192 0 63 255 64 0 63 255 64 0 63 255 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="L10n-System-Modifications">l10nOptionPage	&lt;settingsPage: #(#tools #l10n)&gt;	| remove skip |	remove := BooleanSettingModule 				on: (self settingWithId: #(#l10n #removeTranslatedEntries)).	skip := BooleanSettingModule 				on: (self settingWithId: #(#l10n #skipTranslatedEntries)).	^(ModularSettingsPage new)		label: #l10n &lt;&lt; #Localizer &gt;&gt; 'l10n';		icon: (ListIconLibrary visualFor: #openBook);		addModule: (StringSettingModule 					on: (self settingWithId: #(#l10n #translatorName)));		addModule: remove;		addModule: skip;		when: remove valueHolder			valueSatisfies: [:v | v = false]			enable: skip;		addAllSettings: (self settingsWithPrefix: #(#l10n)					except: #(#removeTranslatedEntries #skipTranslatedEntries #translatorName))</body><body package="L10n-System-Modifications">l10nOptionPenaltyPage	&lt;settingsPage: #(#tools #l10n #penalties)&gt;	^(ModularSettingsPage new)		label: #Penalties &lt;&lt; #Localizer &gt;&gt; 'Penalties';		icon: (ListIconLibrary visualFor: #upDownArrow);		settings: (self settingsWithPrefix: #(#l10n #penalty) except: #(#penaltysnc))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-localizer</category><body package="L10n-System-Modifications">l10nOptions10removeTranslatedEntries	&lt;setting: #(#l10n #removeTranslatedEntries)&gt;	^(BooleanSetting on: L10n.L10nSettings default		aspect: #removeTranslatedEntries)		default: true;		label: #removeTranslatedEntriesFromUserMessageList &lt;&lt; #Localizer					&gt;&gt; 'remove translated entries from the UserMessage list';		helpText: #removeHelp &lt;&lt; #Localizer					&gt;&gt; 'Remove allready translated entries from the UserMessageList.'</body><body package="L10n-System-Modifications">l10nOptions10Translatorname	&lt;setting: #(#l10n #translatorName)&gt;	^(StringSetting on: L10n.L10nSettings default aspect: #translator)		label: #TranslatorName &lt;&lt; #Localizer &gt;&gt; 'Translator Name:';		helpText: #TranslatorNameHelp &lt;&lt; #Localizer					&gt;&gt; 'This name is saved with each translation, please enter one that is unique with the people you share your translations with, to avoid confusion.'</body><body package="L10n-System-Modifications">l10nOptions11skipTranslatedEntries	&lt;setting: #(#l10n #skipTranslatedEntries)&gt;	^(BooleanSetting on: L10n.L10nSettings default		aspect: #skipTranslatedEntries)		default: true;		label: #skiptranslatedentrietheUserMessagelist &lt;&lt; #Localizer					&gt;&gt; 'skip translated entries in the UserMessage list';		helpText: #Skipallreadytranslatticlybeingselected &lt;&lt; #Localizer					&gt;&gt; 'Skip allready translated entries in the UserMessageList after an entry is translated and the next is automaticly being selected.'</body><body package="L10n-System-Modifications">l10nOptions15includeCnone	&lt;setting: #(#l10n #includeCnone)&gt;	^(BooleanSetting on: L10n.L10nSettings default aspect: #includeCnone)		default: true;		label: #Includetranslationsfsthesourcelanguage &lt;&lt; #Localizer					&gt;&gt; 'Include translations from C_none when ''en'' is the source language';		helpText: #Includetranslationsfguageandviseversa &lt;&lt; #Localizer					&gt;&gt; 'Include translations from C_none when ''en'' is the source language and vise versa?'</body><body package="L10n-System-Modifications">l10nOptions16caseSensitiveness	&lt;setting: #(#l10n #caseSensitiveness)&gt;	^(BooleanSetting on: L10n.L10nSettings default aspect: #caseSensitiveness)		default: true;		label: #useCaseSensitivecompexistingtranslations &lt;&lt; #Localizer					&gt;&gt; 'use CaseSensitive comparison for existing translations';		helpText: #useCaseSensitivecompomparedatlowercase &lt;&lt; #Localizer					&gt;&gt; 'use CaseSensitive comparison for existing translations? this may result in more exact translations, as every string is compared at lowercase.'</body><body package="L10n-System-Modifications">l10nOptions17showCatalogs	&lt;setting: #(#l10n #showCatalogs)&gt;	^(BooleanSetting on: L10n.L10nSettings default aspect: #showCatalogs)		default: false;		label: #showCatalogsinTMList &lt;&lt; #Localizer &gt;&gt; 'show Catalogs in TM-List';		helpText: #ShowsCatalogsofthetranslationsornot &lt;&lt; #Localizer					&gt;&gt; 'Shows Catalogs of the results in the list of existing translations, or not'</body><body package="L10n-System-Modifications">l10nOptions19numShown	&lt;setting: #(#l10n #numbersShown)&gt;	^((EnumerationSetting		choices: #(#showAll #'1' #'3' #'10' #'25' #'50' #'100')		labels: (Array with: (#Showall &lt;&lt; #Localizer &gt;&gt; 'Show all') asString)				, #('1' '3' '10' '25' '50' '100'))			on: L10n.L10nSettings default			aspect: #showAmountOfExistingTranslations)		default: 20;		label: #NumberOfMatchesShown &lt;&lt; #Localizer &gt;&gt; 'Number of matches shown';		helpText: #Howmanymatchesshallgtranslationstable &lt;&lt; #Localizer					&gt;&gt; 'How many matches shall be shown in the existing translations table?'</body><body package="L10n-System-Modifications">l10nOptions20sourceDirectory	&lt;setting: #(#l10n #sourceDirectory)&gt;	^((EnumerationSetting		choices: (((UI.UISettings preferenceFor: #messagesList)				collect: [:each | each asResolvedString])					collect: [:each | each asString asSymbol])		labels: (((UI.UISettings preferenceFor: #messagesList)				collect: [:each | each asResolvedString]) collect: [:each | each asString]))			on: L10n.L10nSettings default			aspect: #sourceDirectory)		label: #Sourcedirectory &lt;&lt; #Localizer &gt;&gt; 'Source directory';		helpText: #SelectSourceDirectoryHelp &lt;&lt; #Localizer					&gt;&gt; 'Select the Directory where your Source catalogs are'</body><body package="L10n-System-Modifications">l10nOptions20targetDirectory	&lt;setting: #(#l10n #targetDirectory)&gt;	^((EnumerationSetting		choices: (((UI.UISettings preferenceFor: #messagesList)				collect: [:each | each asResolvedString])					collect: [:each | each asString asSymbol])		labels: (((UI.UISettings preferenceFor: #messagesList)				collect: [:each | each asResolvedString]) collect: [:each | each asString]))			on: L10n.L10nSettings default			aspect: #targetDirectory)		label: #Targetdirectory &lt;&lt; #Localizer &gt;&gt; 'Target directory';		helpText: #SelectTargetDirectoryHelp &lt;&lt; #Localizer					&gt;&gt; 'Select the Directory where your target catalogs are'</body><body package="L10n-System-Modifications">l10nOptions30importSystem	&lt;setting: #(#l10n #importSystem)&gt;	^(ExternalSetting new)		label: #ReadSystemCatalogs &lt;&lt; #Localizer &gt;&gt; 'Read System Catalogs';		editorBlock: 				[L10n.UserMessageTranslationMemory default readSystemUserMessages];		helpText: #findUserMessagesHelp &lt;&lt; #Localizer					&gt;&gt; 'Click this button to scan through your VisualWorks system for all UserMessages'</body><body package="L10n-System-Modifications">l10nOptionsPenalty20penaltysnc	&lt;setting: #(#l10n #penalty #penaltysnc)&gt;	^((Heeg.FormatedSetting formatString: '0%' min: 0 max: 1)		on: L10n.L10nSettings default		aspect: #panaltySourceNeutralCountry)		default: 1;		label: #SourceLanguageneutralcountry &lt;&lt; #Localizer					&gt;&gt; 'Source Language neutral country';		helpText: #PenaltyForEqualSoureButNeutralCountry &lt;&lt; #Localizer					&gt;&gt; 'Penalty for equal source language but neutral country'</body><body package="L10n-System-Modifications">l10nOptionsPenalty25penaltysoc	&lt;setting: #(#l10n #penalty #penaltysoc)&gt;	^((Heeg.FormatedSetting formatString: '0%' min: 0 max: 1)		on: L10n.L10nSettings default		aspect: #panaltySourceOtherCountry)		default: 2;		label: #SourceLanguageothercountry &lt;&lt; #Localizer					&gt;&gt; 'Source Language other country';		helpText: #PenaltyForSameSourcageButOtherCountry &lt;&lt; #Localizer					&gt;&gt; 'Penalty for same Source language but Other country'</body><body package="L10n-System-Modifications">l10nOptionsPenalty30penaltytnc	&lt;setting: #(#l10n #penalty #penaltytnc)&gt;	^((Heeg.FormatedSetting formatString: '0%' min: 0 max: 1)		on: L10n.L10nSettings default		aspect: #panaltyTargetNeutralCountry)		default: 2;		label: #Targetlanguageneutralcountry &lt;&lt; #Localizer					&gt;&gt; 'Target language neutral country';		helpText: #PenaltyForEqualTargeButNeutralCountry &lt;&lt; #Localizer					&gt;&gt; 'Penalty for equal target language but neutral country'</body><body package="L10n-System-Modifications">l10nOptionsPenalty35penaltytoc	&lt;setting: #(#l10n #penalty #penaltytoc)&gt;	^((Heeg.FormatedSetting formatString: '0%' min: 0 max: 1)		on: L10n.L10nSettings default		aspect: #panaltyTargetOtherCountry)		default: 4;		label: #Targetlanguageothercountry &lt;&lt; #Localizer					&gt;&gt; 'Target language other country';		helpText: #PenaltyForEqualTargetButOtherCountry &lt;&lt; #Localizer					&gt;&gt; 'Penalty for equal target language but Other country'</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>localisation</category><body package="L10n-System-Modifications">export	&lt;menuItem: #(#export #Localizer 'export') icon: nil nameKey: #export enablement: nil indication: nil menu: #(#menuBar #Localisation) position: 4.1&gt;	L10n.ExportUI open.	^self</body><body package="L10n-System-Modifications">importFile	&lt;menuItem: #(#ImportFile #Localizer 'Import a file')		icon: nil		nameKey: #importCatalog		enablement: nil		indication: nil		menu: #(#menuBar #Localisation)		position: 2.0&gt;	L10n.UserMessageTranslationMemory default import</body><body package="L10n-System-Modifications">importFolder	&lt;menuItem: #(#importFolder #Localizer 'Import Folder')		icon: nil		nameKey: #import		enablement: nil		indication: nil		menu: #(#menuBar #Localisation)		position: 4.0&gt;	L10n.UserMessageTranslationMemory default importFolder</body><body package="L10n-System-Modifications">Localiser_Menu		&lt;submenu: #(#Localisation #Localizer '&amp;Localisation') nameKey: #Localisation menu: #(#menuBar #tools) position: 25.3&gt;	^self</body><body package="L10n-System-Modifications">localiser_opener	&lt;menuItem: #(#localizer #Localizer 'Localizer')		icon: #launcherIcon		nameKey: nil		menu: #(#launcherToolBar)		position: 31		helpText: #(#Localiserhelpslocalimalltalkapplications #Localizer 'Localiser helps localising Smalltalk applications')&gt;	&lt;menuItem: #(#localizer #Localizer 'Localizer')		icon: nil		nameKey: #localiser		enablement: nil		indication: nil		menu: #(#menuBar #Localisation)		position: 1.0&gt;	L10n.L10nUI open</body></methods><methods><class-id>Refactory.Browser.CodeModel class</class-id> <category>instance creation</category><body package="L10n-RBSupport">l10nCanvasTool	&lt;tool:1&gt;	^L10n.CanvasViewer</body><body package="L10n-RBSupport">l10nMenuTool	&lt;tool:1&gt;	^L10n.MenuViewer</body><body package="L10n-RBSupport">l10nOverviewTool	&lt;tool:1&gt;	^L10n.L10nOverviewTool</body></methods><initialize><class-id>L10n.L10nSettings</class-id></initialize><initialize><class-id>L10n.UserMessageTranslationMemory</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>CodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeModel menu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>BrowserCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modified initialLookPrefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>GeneralMethodDefinition</name><environment>Tools</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>PeekableStream</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MessageCatalogManager</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalogs languageAndTerritory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class><class><name>CodeModel</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractCodeModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>RefactoringBrowser</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractRefactoringBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policyClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-RB UI</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>RefactoringBrowserInSubcanvas</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoringBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RefactoringBrowserInSubcanvas</category><attributes><package>RefactoringBrowserInSubcanvas</package></attributes></class><class><name>SAXDriver</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>locator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><class><name>ListNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.NavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menu visualBlock objectList </inst-vars><class-inst-vars>defaultVisualBlock </class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>BrowserDefinitionTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>BrowserSourceCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserDocumentTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>probes hasOpenedSearch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-SourceCodeUI</package></attributes></class><class><name>ClassAndMethodTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors methods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>CsvLine</name><environment>Heeg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpecImport</category><attributes><package>GHCsvImportExport</package></attributes></class><class><name>SortedCollection</name><environment>Core</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>SelectorEnvironmentInSubcanvas</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodDefinitionEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RefactoringBrowserInSubcanvas</category><attributes><package>RefactoringBrowserInSubcanvas</package></attributes></class><class><name>Menu</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items groupSizes adornment selectionMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>UserMessage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultString key catalogID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class><class><name>ComposedTextView</name><environment>UI</environment><super>UI.AutoScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>artist textStyle displayContents startBlock stopBlock selectionShowing displaySelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MessageCatalog</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class><class><name>Wrapper</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>BrowserNavigatorInSubcanvas</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RefactoringBrowserInSubcanvas</category><attributes><package>RefactoringBrowserInSubcanvas</package></attributes></class><class><name>MessageFileParser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastToken startsHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class></st-source>