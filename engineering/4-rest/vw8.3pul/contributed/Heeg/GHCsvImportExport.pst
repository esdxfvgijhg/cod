<?xml version="1.0"?><st-source><!-- Name: GHCsvImportExportNotice: © Copyright 2003-2015 Georg Heeg e.K.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.(MIT License)Comment: Support of reading and writing the CSV (Comma Separated Value) text file format. Simple viewing utility included.This package provides two ways of using CSV files:1. Each row represents an Array. Use CsvReader and CsvWriter.2. Each row represents an object, instance of a subclass of CsvLine. Use CsvFileReader or CsvReaderWriter.Holger Guhl (mailto:Holger.Guhl@heeg.de)Copyright © 2015 Georg Heeg eK.  All Rights Reserved.Version history:===========================================================8.1 - 4 (05-OCT-2015)- using Locales for reading an writing of Numbers and Dates. #sepThousand:decimal: can still be used to override the locale's separators- renamed CsvFileReader to CsvObjectReader because much of the implementation changed. CsvObjectReader now doesn't know the file's objects anymore and can also write objects to a Csv file. See CsvLine's class comment and CsvObjectReader's class comment for more information- changed the implementation of CsvReader and CsvWriter in regards to how they encode/decode values. The new system is extensible via <encoder:> or <decoder:> pragma. The new system also allows for using custom classes as types.- removed CsvLine.Status class instance variable.- renamed #importRowInto: to #importRowsInto: (added plural) because it did in fact read all rows.- added ByteOrderMarkSupport as prerequisite to get rid of the encoding-guessing in the CsvReader. The default-encoding is now #autodetectOrDefault===========================================================8.1 - 3 (02-JUN-2015) (runs fine in VW 7.10, too)Fix CsvReader - #importRowInto: replaces all nil values with empty Strings, now it follows the noValue settingFix CsvFileReader- to preserve semantics, the CsvFileReader explicitly uses a noValue of an empty string.Updated Copyright notice===========================================================8.1 - 2 (02-JUN-2015) (runs fine in VW 7.10, too)Better and configurable no-value handling- add CsvReader>>noValue: to configure the result if an empty cell is read- quoted data is always used as is; empty strings are no longer interpreted as nil- add CsvWriter #quotePolicy to configure conditions to enforce quoting===========================================================8.1 - 1 (28-MAY-2015) (runs fine in VW 7.10, too)Enhance CsvReader- Add support for the 'real' comma separated format which uses ','.Fix CsvReader- #nextInColumn:, #stringFrom: (no longer skip trailing blanks)Fix CsvWriter- #nextPutString: (handle LF (line feed) like CR, i.e. protect it with double quotes)- #nextPutHeadings: (#nextPutAll: on the stream is bad, use own protocol to handle strings that need quoting)===========================================================7.10 - 1 (31-JAN-2014)Fix CsvWriter: quotes in strings must be doubled, the result must be quoted like strings with CR or CSV separator.===========================================================7.9 - 5 (16-FEB-2012)Added 'CSV Viewer' menu item to the VisualLauncher Tools menu.Enlarged size of selected colum display.Column widths based on data size.===========================================================7.8 - 1 (13-JAN-2011)Refurbish CsvFileViewer: Add a button to select the file to be read via FileDialog. Satisfy various Code Critics.Testing/Documentation: Added CsvWriter class>>exampleUpdated Copyright notice and package comment===========================================================1.12 - 08-JUN-2010Updated Copyright notice===========================================================1.11 - 30-NOV-2008Fix PeekableStream>>nextBOM (must restore text mode if it was text)===========================================================1.10 - 15-DEC-2006- Verify for VisualWorks 7.5===========================================================1.9 - 11-DEC-2006- Verify for VisualWorks 7.5- Add class comment for CsvWriter and CsvFileViewer- Refine method comment of PeekableStream>>nextBOM===========================================================1.8 - 26-JUN-2006Fix handling of embedded (quoted) CR- CsvReader nextLine (handle quoted CR which is NOT end-of-line)- CsvWriter nextPut: (quote embedded CR)Fix unintended modification of NumberPrintPolicy defaultInstance- CsvWriter separators:types: (use a copy)Review handling of BOM (Byte Order Mark)- add reusable BOM scanning methods to PeekableStream- CsvFileViewer openFile (reuse CsvReader>>onFileNamed: with BOM handling)- CsvFileReader readEntries   - reuse CsvReader>>onFileNamed: with BOM handling  - discard #detectLineEndConvention (added to CsvReader>>on:)  - ensure file closureREMOVED (no more senders, use #lineEndAuto)- BufferedExternalStream detectLineEndConvention (add)REVIEW- replace "== 0" with "isZero" in CsvFileViewer methods- replace old message send of #valueNowOrOnUnwindDo: with #ensure:- replace "== nil" with "isNil" in CsvFileViewer and CsvReader methods===========================================================1.7 - 26-JUN-2006Reorganization: Move from all classes from namespace Heeg.Utilities to HeegFix message expansion in - CsvWriter>>nextPutHeadings:, #nextPutRows:, #nextPutColumns:- CsvFileViewer>>openFileReplace old #withArgs: with VisualWorks #expandMacrosWith:[with:]===========================================================1.6 - 10-NOV-2005Recognize utf-16 encoded text files===========================================================1.5 - 07-NOV-2005Recognize utf-8 encoded text files===========================================================1.4 - 22-JUN-2004Renamed CsvImport as CsvFileReader===========================================================1.3 - 27-FEB-2004Added classes for mapped import (CsvImport + CsvLine)===========================================================1.2 - 17-JUN-2003Fix prerequisites (add HeegUtilities-Namespace)===========================================================1.1 - 17-JUN-2003added OS.BufferedExternalStream>>detectLineEndConvention===========================================================1.0 - 17-JUN-2003 (first version published on james@heeg.deDbIdentifier: magdi.heeg.de.postgresDbTrace: 54868DbUsername: georgDbVersion: 8.1 - 4DevelopmentPrerequisites: #(#(#any 'GHNamespaces' '') #(#any 'ByteOrderMarkSupport' ''))DialectVersion: VisualWorks 7.9HideSource: falsePackageName: GHCsvImportExportParcel: #('GHCsvImportExport')ParcelDirectory: c:\visworks\vw8.1.1 feb16.2\image\Contributor\HeegContributions-vw8.1.1-2016-03-10\GHCsvImportExportParcelName: GHCsvImportExportPrerequisiteDescriptions: #(#(#name 'GHNamespaces') #(#name 'ByteOrderMarkSupport' #componentType #package))PrerequisiteParcels: #(#('GHNamespaces' '') #('ByteOrderMarkSupport' ''))PrintStringCache: (8.1 - 4,georg)SaveSource: trueVersion: 8.1 - 4Date: 9:09:46 AM March 10, 2016 --><time-stamp>From VisualWorks®, 8.1.1 of 25. Februar 2016 on 10. März 2016 at 09:09:46</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CsvStream</name><environment>Heeg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream column rowSize separator sep10 sep1000 locale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tables-Support</category><attributes><package>GHCsvImportExport</package></attributes></class><comment><class-id>Heeg.CsvStream</class-id><body>CsvStream supports reading and writing of Comma-Separated-Value files which are commonly used to transfer table data in a textual way. In order to do more than the stupid business of passing text to and from, instances must be able to convert 'arbitrary' table data to text (when writing) and text into objects (when reading). This is done by Methods that have a &lt;decoder: String&gt; or &lt;encoder: String&gt; Pragma. These methods are expected to return a Block with at least one argument and they either encode or decode the objects. The parameter of the pragma is a Symbol that specifies the class for which this decoder applies. Of cause a method can have multiple pragmas. The &lt;decoder:&gt; Pragma is used by the CsvReader and the &lt;encoder:&gt; Pragma is used by the CsvWriter.Instance Variables:	column	&lt;SmallInteger&gt;		'position' of the instance, the next column to read or write	locale	&lt;Locale&gt;			locale used for reading or writing the dates and numbers	rowSize	&lt;SmallInteger&gt;		length of each row, number of columns	sep10	&lt;nil | Character&gt;	Decimal separator, if different than the locale	sep1000	&lt;nil | Character&gt;	Thousands separator, if different than the locale	separator	&lt;Character&gt;		character which separates columns from each other (tab, semicolon, comma)	stream	&lt;ReadStream | WriteStream&gt;	</body></comment><class><name>CsvColumnDescription</name><environment>Heeg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>heading aspect type position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GHCsvImportExport</package></attributes></class><comment><class-id>Heeg.CsvColumnDescription</class-id><body>CsvColumnDescription describes a column in a CSV file. These objects are used by CsvLine subclasses to describe how the columns are mapped to instance variables. For the mapping the aspect and type need to be specified.CsvLine subclasses need to specifiy CsvColumnDescription objects on class side using methods that have a &lt;column&gt; pragma. Instance Variables:	aspect	&lt;Symbol&gt;			the symbol to use for reading or writing 	heading	&lt;String&gt;			the heading of the column. Use to sort the description based on the file that's being read	position	&lt;Number&gt;			the position of the column, used to sort the column for writing	type		&lt;nil, Symbol, Class&gt;	used to encode/decode the object to a string and back</body></comment><class><name>CsvFileViewer</name><environment>Heeg</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename columns lines table selectionHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tables-Support</category><attributes><package>GHCsvImportExport</package></attributes></class><comment><class-id>Heeg.CsvFileViewer</class-id><body>CsvFileViewer is a simple GUI for viewing contents of text files with CSV and tab separated format. You can specify a text file and view its contents with the economic and fast TableInterface.Instance Variables:	filename	&lt;ValueHolder on: String&gt;	name of file to view	columns	&lt;ValueHolder on: Integer&gt;	number of columns in specified file	lines	&lt;ValueHolder on: Integer&gt;	number of lines in specified file	selectionHolder	&lt;ValueHolder on: SelectionInTable&gt;	manages the user selection in the table	table	&lt;TableInterface&gt;	table model holding file data after scanning with CsvReader</body></comment><class><name>CsvLine</name><environment>Heeg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpecImport</category><attributes><package>GHCsvImportExport</package></attributes></class><comment><class-id>Heeg.CsvLine</class-id><body>CsvLine is an abstract superclass for csv line instances read from a csv file with CsvFileReader or CsvReaderWriter.Subclasses have to specify how columns are mapped to instance-variables. For that mapping the following information is required:	- how is the column called (heading)	- name of the instance variable	- type of the instance variable	- possibly the position of the column so that the columns are not written in alphabetical orderThere are two ways of specifying that information:	- The preferred way is to implement methods that have a &lt;column&gt; pragma and that return an instance of CsvColumnDescription- The legacy way is to implement #headlines, #properties and #types. See further below on more details of that implementation.In addition to that column-based information, subclasses can implement #locale.This method returns the locale to be used to encode/decode Dates and Numbers (for figuring out separators etc).UsageCsvLine works in conjunction with CsvObjectReader. See the object reader for in-depth examples.Convenience Methods (Instead of CsvLine, use a proper subclass):	"read all instances of CsvLine"	CsvLine readAllFrom: aReadStream.	CsvLine readAllFromFile: 'test.csv'.	"write a list of CsvLine instances"	CsvLine writeEntries: objects on: aWriteStream.	CsvLine writeEntries: objects to: 'test.csv'.Legacy support:#headlines, properties and types all return an Array. Each Array has to have the same size!headlines	returns an array of strings with headlines in the first row of the csv file. 			e.g. #('Name' 'Phone' Zip code')properties	returns the matching setter selector symbols to fill the line with row data.			e.g.	 #(#name: #phone: #zipCode: )All properties elements must be implemented as setter methods in the subclass. If the subclass shall be used with CsvReaderWriter getter methods must also be implemented (same names without $:).types		returns an Array of type symbols or nil - nil means String aka no conversion			default: Array with nil for each 			other example (not fitting to abouve examples): #(nil nil nil nil nil nil nil #Integer #Integer #Integer nil #Integer)</body></comment><class><name>CsvWriter</name><environment>Heeg</environment><super>Heeg.CsvStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>quotePolicy encoders </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tables-Support</category><attributes><package>GHCsvImportExport</package></attributes></class><comment><class-id>Heeg.CsvWriter</class-id><body>CsvWriter is a stream-oriented implementation for writing data to text files in CSV and tab separated format. Instances can be configured to render common Smalltalk data types (String, Float, Integer, Number) to text. Table value separator as well as decimal point and thousands separator can be configured. See #separators:types: for details. It is however easier to just set the locale and let the locale handle decimal separators.Special consideration deals with writing data for nil or an empty string. Early implementations made no difference for the export result: Both values create no output. This is problematic for an importing application which may want to distinguish whether the source was nil or an empty string. There is no kind of standard to deal with that, but we can help our CsvReader by simply quoting an empty string. There is also no standard about quoting. The default behavior is to not quote, but quoting should do no harm. So we add options to configure the export behavior for enforcing quotes in certain conditions. Calling #writeEmptyStringQuoted will quote empty strings.In general encoding is done using methods that have the &lt;encoder: #String&gt; Pragma. These methods return a Block with a single argument. That argument is the object that needs to be encoded. The parameter #String of the Pragma defines for which type this encoder is to be used. The blocks don't need to return the result-string, they have to write directly to the stream. If no encoder was found for a type, the objects of that column will simply be printed on the stream using #printOn:Instance Variables:	encoders 		&lt;Array of: BlockClosure&gt; 		the blocks that are used to encode each cell's Object to the file.									The blocks don't need to return the result, they can write directly to the stream.	quotePolicy 	&lt;Array of: Symbol&gt; 	configures whether a value to be exported should be quoted; 								each element of the quotePolicy is a test selector which is sent to the strings of a cell</body></comment><class><name>CsvObjectReader</name><environment>Heeg</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileEntryClass stream sep1000 sep10 locale columns </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpecImport</category><attributes><package>GHCsvImportExport</package></attributes></class><comment><class-id>Heeg.CsvObjectReader</class-id><body>CsvObjectReader reads CSV files into objects. Each row is converted into a CsvLine subclass instance. The CsvObjectReader can also be used to write objects back to a Csv file.Usage	"the stream is either a ReadStream or a WriteStream, depending on the use-case."	reader := CsvObjectReader withFileEntryClass: CsvLine on: readStream.	reader readEntries.	writer := CsvObjectWriter withFileEntryClass: CsvLine on: writeStream.	writer writeEntries: entries.	"to customize the separators or the locale, configure before reading or writing"	reader := CsvObjectReader withFileEntryClass: CsvLine on: readStream.	reader locale: (Locale named:'zh').	reader readEntries.	Instance Variables:	columns 		&lt;Collection of: CsvColumnDescriptor&gt;		descriptions of the columns either how they are in the Csv File 												or how they are to be written to the Csv file.									When objects are read from a file, the columns are set after the first row was read.									With the first row, the columns are sorted according to the headings and missing									columns are ignored.									When objects are written, the columns are taken from the fileEntryClass 									and their order is not changed.	fileEntryClass	&lt;CsvLine subclass&gt;		class of all instances	locale	&lt;Locale&gt;					locale used for reading or writing the data (esp. Numbers and Dates)	sep10	&lt;nil | Character&gt;			Decimal separator if different from the locale	sep1000	&lt;nil | Character&gt;			Thousands separator if different from the locale</body></comment><class><name>CsvReader</name><environment>Heeg</environment><super>Heeg.CsvStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>line linesRead noValue decoders </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tables-Support</category><attributes><package>GHCsvImportExport</package></attributes></class><comment><class-id>Heeg.CsvReader</class-id><body>A utility class for reading table data from files which have been created with the comma-separated-value format.We have special handling when reading empty cells. Early implementations always interpreted 'no data' as nil. This may be inconvenient for applications that prefer an empty string in that case, because that is also in-line with CSV concepts and saves from checking for nil results. Furthermore, a general policy to return nil makes it impossible to distinguish no data from a really exported empty string.The new implementation helps both cases:(1) The result for 'no data' can be configured. With #noValue: one can assign an arbitrary object to be returned if a cell is empty. The usual value should be an empty string.(2) If a cell value is quoted, then the result is the data string as is; we will no longer return nil (nor the configured #noValue) if the string is empty. Clearly, this helps only if the export was written with CsvWriter which can be configured to quote empty strings. Every other export will most probably write empty strings without quotes, because that's the default.DecodingTo decode cells, methods with a &lt;decoder: #String&gt; Pragma can be implemented. The methods are expected to return a Block that converts its first parameter into an object. The parameter of the pragma (#String in the example) is a class-name and it is used to identify for which types the convertion block is to be used. The blocks can use a second argument "wasQuoted" to know if the string that was passed to the block was initially quoted in the Csv file.If no method with &lt;decoder:&gt; Pragma was found for a given type, the type is converted to a Class and it receives the message #readFrom:. Instance Variables:	decoders	&lt;Array of: BlockClosure&gt;	the blocks that are used to decode the cells.	line		&lt;ReadStream&gt;		buffer for the currently scanned line	linesRead	&lt;SmallInteger&gt;		number of lines read up to now	noValue 	&lt;String&gt; 			configurable result value when reading an empty cell (typically nil or the empty string)	</body></comment><methods><class-id>Heeg.CsvStream</class-id> <category>initialize-release</category><body package="GHCsvImportExport">close	stream close</body><body package="GHCsvImportExport">conversionBlockWithPragma: pragmaName forType: classOrSymbol defaultBlock: defaultBlock	"finds all methods that are marked with a certain pragma. The argument of that pragma is a class-name. 	If that class-name matches classOrSymbol, this method is executed and the result is returned. 	If no such pragma is found, defaultBlock is returned.	The methods with that pragma are expected to return a block with a single argument."	| classNameToFind pragmas pragma |	classNameToFind := classOrSymbol isBehavior				ifTrue: [classOrSymbol name]				ifFalse: [classOrSymbol asSymbol].	pragmas := Pragma allNamed: pragmaName in: self class.	pragma := pragmas detect: 					[:each |					| className |					className := (each argumentAt: 1) asSymbol.					classNameToFind = className]				ifNone: [^defaultBlock].	^self perform: pragma selector</body><body package="GHCsvImportExport">initialize	super initialize.	column := 0.	locale := Locale named: #C</body><body package="GHCsvImportExport">on: aStream	stream := aStream</body><body package="GHCsvImportExport">sepThousand: char1 decimal: char2 	"set characters for thousand/decimal separators"	sep1000 := char1.	sep10 := char2</body></methods><methods><class-id>Heeg.CsvStream</class-id> <category>accessing</category><body package="GHCsvImportExport">locale	^locale</body><body package="GHCsvImportExport">locale: anObject	locale := anObject</body><body package="GHCsvImportExport">rowSize	"length of each row, number of columns"	^rowSize</body></methods><methods><class-id>Heeg.CsvStream</class-id> <category>private</category><body package="GHCsvImportExport">numberPolicy	| numPolicy |	numPolicy := locale numberPolicy copy.	sep1000 ifNotNil: [numPolicy thousandsSeparator: sep1000].	sep10 ifNotNil: [numPolicy decimalPoint: sep10].	^numPolicy</body></methods><methods><class-id>Heeg.CsvStream class</class-id> <category>instance creation</category><body package="GHCsvImportExport">new	^super new initialize</body><body package="GHCsvImportExport">on: aStream 	"create a new reader scanning file named filename"	^self new on: ((aStream isKindOf: Stream)			ifTrue: [aStream]			ifFalse: [aStream readStream])</body></methods><methods><class-id>Heeg.CsvColumnDescription</class-id> <category>accessing</category><body package="GHCsvImportExport">aspect	^aspect</body><body package="GHCsvImportExport">aspect: anObject	aspect := anObject</body><body package="GHCsvImportExport">getter	^aspect</body><body package="GHCsvImportExport">heading	^heading</body><body package="GHCsvImportExport">heading: anObject	heading := anObject</body><body package="GHCsvImportExport">position	^position</body><body package="GHCsvImportExport">position: anObject	position := anObject</body><body package="GHCsvImportExport">setter	^(aspect , ':') asSymbol</body><body package="GHCsvImportExport">type	^type</body><body package="GHCsvImportExport">type: anObject	type := anObject</body></methods><methods><class-id>Heeg.CsvColumnDescription</class-id> <category>initialize-release</category><body package="GHCsvImportExport">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	heading := ''.	aspect := #yourself.	type := String.	position := 0.</body></methods><methods><class-id>Heeg.CsvColumnDescription class</class-id> <category>instance creation</category><body package="GHCsvImportExport">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Heeg.CsvFileViewer</class-id> <category>actions</category><body package="GHCsvImportExport">copyColumn	"write text data of current column to global clipboard"	self copyToClipboard: self getColumn</body><body package="GHCsvImportExport">copyRow	"write text data of current row to global clipboard"	self copyToClipboard: self getRow</body><body package="GHCsvImportExport">findString	"search currently selected column for next occurrence of a string given from 	user (wildcards supported) and select the cell found (if any)"	| index start pattern next |	index := self table selectionInTable selectionIndexHolder.	(start := index value) x = 0 ifTrue: [^self].	pattern := Dialog request: 'Search column for what?' initialAnswer: ParagraphEditor currentSelection onCancel: [^self].	pattern isEmpty ifTrue: [^self].	next := self				findString: pattern				start: 0 @ 1 + start				stop: start x @ self tableData size				vertically: true.	next isNil ifTrue: 		[(Dialog confirm: 'String not found.\Retry from the beginning?' withCRs)			ifFalse: [^self].		next := self					findString: pattern					start: start x @ 1					stop: start					vertically: true.		next isNil ifTrue: [Dialog warn: 'String not found'. ^self]].	index value: next</body><body package="GHCsvImportExport">inspectColumn	"inspect the column of the currently selected cell"	| col |	(col := self getColumn) isNil ifFalse: [col inspect]</body><body package="GHCsvImportExport">inspectColumnSet	"inspect the set of values in currently selected column"	| col |	(col := self getColumnSet) isNil ifFalse: [col inspect]</body><body package="GHCsvImportExport">inspectRow	"inspect the row of the currently selected cell"	| row |	(row := self getRow) isNil ifFalse: [row inspect]</body><body package="GHCsvImportExport">inspectTable	self tableData inspect</body><body package="GHCsvImportExport">openFile	| filenameFromUser aFilename reader rows |	(filenameFromUser := self filename value) isEmpty ifTrue: [^nil].	(aFilename := filenameFromUser asFilename) exists 		ifFalse: 			[^Dialog warn: ('File ''&lt;1s&gt;''&lt;n&gt;does not exist.' 						expandMacrosWith: aFilename asString)].		rows := OrderedCollection new: 256.	reader := CsvReader onFileNamed: aFilename.	[Cursor read showWhile: [self importFrom: reader to: rows]] 			ensure: [reader close].	self columns value: reader rowSize.	self lines value: reader linesRead.	self setBaseTable: rows</body><body package="GHCsvImportExport">selectAndReadFile	"Open a file dialog to select the file to be read, then read the file and show its contents in the table."	| aString |	aString := Dialog				requestFileNameWithMessage: 'Select the file to read'				default: '*.txt'				version: #mustBeOld				ifFail: [^self]				for: self mainWindow.	self filename value: aString.	self openFile</body></methods><methods><class-id>Heeg.CsvFileViewer</class-id> <category>private</category><body package="GHCsvImportExport">copyToClipboard: aCollection 	| stream |	(aCollection isNil or: [aCollection isEmpty]) ifTrue: [^self].	stream := (String new: 500) writeStream.	aCollection do: [:string | stream nextPutAll: string; cr].	ParagraphEditor currentSelection: stream contents</body><body package="GHCsvImportExport">findString: pattern start: start stop: stop vertically: aBoolean 	| match rows |	match := (pattern includes: $*) | (pattern includes: $#)		ifTrue: [[:string | pattern match: string]]		ifFalse: [[:string | string = pattern]].	rows := self tableData.	aBoolean		ifTrue: [start x to: stop x do: [:x | start y to: stop y do: [:y |				(match value: ((rows at: y) at: x))						ifTrue: [^x @ y]]]]		ifFalse: [start y to: stop y do:				[:y | | row |				row := rows at: y.				start x to: stop x do:					[:x | (match value: (row at: x))						ifTrue: [^x @ y]]]].	^nil</body><body package="GHCsvImportExport">getColumn	"Answer all values of the currently selected column.	Return: SequenceableCollection of: (String | Number | etc.)"	| col |	^(col := table selectionIndex x) isZero 		ifTrue: []		ifFalse: [self tableData collect: [:row | row at: col]]</body><body package="GHCsvImportExport">getColumnSet	"Answer all distinct values of the currently selected column.	Return: Set of: (String | Number | etc.)"	| col |	^(col := table selectionIndex x) isZero 		ifTrue: []		ifFalse: 			[| set |			set := Set new.			self tableData do: [:row | set add: (row at: col)].			set remove: '' ifAbsent: [].			set]</body><body package="GHCsvImportExport">getRow	"Answer the currently selected row.	Return: SequenceableCollection of: (String | Number | etc.)"	| row |	^(row := table selectionIndex y) isZero 		ifTrue: []		ifFalse: [self tableData at: row]</body><body package="GHCsvImportExport">importFrom: importStream to: rows 		[[importStream atEnd]		whileFalse: 			[| anArray |			anArray := importStream nextRow.			anArray replaceAll: nil with: ''.			rows add: anArray]] 	ensure: [importStream close]</body><body package="GHCsvImportExport">setBaseTable: aCollection	"Create the TableAdaptor and fill in the data from aCollection."	| adapt |	adapt := RowAdaptor adaptForIndexes: (1 to: self columns value).	adapt := TableAdaptor on: aCollection adaptors: adapt.	self setColumnLabelsAndWidthFrom: aCollection.	self table table: adapt</body><body package="GHCsvImportExport">setColumnLabelsAndWidthFrom: aCollection	"Compute column width using the labels and contents of the first 10 rows of data.	The first row always contains the labels."	| widths |	aCollection isEmpty ifTrue: [^self].	widths := Array new: aCollection first size withAll: 0.	1 to: (aCollection size min: 11)		do: 			[:rowIndex |			| currentRow |			currentRow := aCollection at: rowIndex.			1 to: widths size				do: 					[:colIndex |					| currentWidth |					currentWidth := widths at: colIndex.					widths at: colIndex						put: (currentWidth								max: ((currentRow at: colIndex) asComposedText width + 5 max: 60))]].	(self table)		columnWidths: widths;		columnLabelsArray: aCollection removeFirst</body><body package="GHCsvImportExport">tableData	"return the table data matrix"	^table table baseCollection</body></methods><methods><class-id>Heeg.CsvFileViewer</class-id> <category>aspects</category><body package="GHCsvImportExport">columns	^columns isNil		ifTrue: [columns := 0 asValue]		ifFalse: [columns]</body><body package="GHCsvImportExport">filename	^filename isNil		ifTrue: [filename := String new asValue]		ifFalse: [filename]</body><body package="GHCsvImportExport">lines	^lines isNil		ifTrue: [lines := 0 asValue]		ifFalse: [lines]</body><body package="GHCsvImportExport">selectionHolder	"this one is for the selection info subcanvas (value holder on table selection 	allows easy access on its data via aspect paths)"	^selectionHolder isNil		ifTrue: [selectionHolder := ValueHolder with: table selectionInTable]		ifFalse: [selectionHolder]</body><body package="GHCsvImportExport">table	^table isNil		ifTrue: [table := TableInterface new selectionInTable: SelectionInTable new]		ifFalse: [table]</body></methods><methods><class-id>Heeg.CsvFileViewer</class-id> <category>interface opening</category><body package="GHCsvImportExport">postBuildWith: aBuilder 	"update selection position and value on each select"	super postBuildWith: aBuilder.	self table selectionInTable selectionIndexHolder		onChangeSend: #resetValue to: (aBuilder componentAt: #selectionIndex) widget;		onChangeSend: #resetValue to: (aBuilder componentAt: #selection) widget</body></methods><methods><class-id>Heeg.CsvFileViewer class</class-id> <category>interface opening</category><body package="GHCsvImportExport">openFileNamed: stringOrFilename 	| inst |	(inst := self new) filename value: stringOrFilename asString.	inst openFile.	^self openOn: inst</body></methods><methods><class-id>Heeg.CsvFileViewer class</class-id> <category>resources</category><body package="GHCsvImportExport">iconForOpenFile	"Answer the icon to be shown on the button to open a file."	^ToolbarIconLibrary visualFor: #fileOpen</body></methods><methods><class-id>Heeg.CsvLine</class-id> <category>api</category><body package="GHCsvImportExport">postImportAction	"Will be sent after filling the values."</body></methods><methods><class-id>Heeg.CsvLine class</class-id> <category>writing</category><body package="GHCsvImportExport">writeEntries: entries on: writeStream	(CsvObjectReader withFileEntryClass: self on: writeStream)		writeEntries: entries</body><body package="GHCsvImportExport">writeEntries: entries to: file	self writeEntries: entries to: file withEncoding: #utf8WithBOM</body><body package="GHCsvImportExport">writeEntries: entries to: file withEncoding: encoding	| writeStream |	writeStream := (file asFilename withEncoding: encoding) writeStream.	[self writeEntries: entries on: writeStream] ensure: [writeStream close]</body></methods><methods><class-id>Heeg.CsvLine class</class-id> <category>file description</category><body package="GHCsvImportExport">columnDescriptors	"returns all CsvColumnDescription objects that are stored in methods that are maked by the &lt;column&gt; pragma"	| pragmas descriptions |	pragmas := Pragma				allNamed: #column				from: self classBehavior				to: CsvLine classBehavior.	pragmas isEmpty ifTrue: [^self descriptorsFromLegacyMethods].	descriptions := pragmas collect: [:each | self perform: each selector].	^descriptions sorted: #position ascending , #heading ascending</body><body package="GHCsvImportExport">descriptorsFromLegacyMethods	| headlines properties types |	headlines := self headlines.	properties := self properties.	types := self types.	^(1 to: headlines size) collect: 			[:index |			(CsvColumnDescription new)				heading: (headlines at: index);				aspect: ((properties at: index) allButLast: 1) asSymbol;				type: (types at: index);				position: index;				yourself]</body><body package="GHCsvImportExport">headlines	"Returns an Array with Strings.		 ^#('Name' 'Phone' Zip code').		This method is left for Legacy support. Please consider using &lt;column&gt; marked methods 	(see Class comment for more information) "	^self subclassResponsibility</body><body package="GHCsvImportExport">locale	"return the locale in which the file is stored"	^Locale named: #C</body><body package="GHCsvImportExport">properties	"Returns setter symbols like:		^#(#name: #phone: #zipCode: )	This method is left for Legacy support. Please consider using &lt;column&gt; marked methods 	(see Class comment for more information)"	^self subclassResponsibility</body><body package="GHCsvImportExport">types	"Each entry defines the properties type at the same index. nil means String.	This method shall be overridden for automatic type conversion.		This method is left for Legacy support. Please consider using &lt;column&gt; marked methods 	(see Class comment for more information)"	^Array new: self properties size</body></methods><methods><class-id>Heeg.CsvLine class</class-id> <category>reading</category><body package="GHCsvImportExport">readAllFrom: aStream	| reader |	reader := CsvObjectReader withFileEntryClass: self on: aStream.	^reader readEntries</body><body package="GHCsvImportExport">readAllFromFile: aFilename 	^self readAllFromFile: aFilename encoding: #autodetectOrDefault.</body><body package="GHCsvImportExport">readAllFromFile: aFilename encoding: encoding	| rs |	rs := (aFilename asFilename withEncoding: encoding) readStream.	^[self readAllFrom: rs] ensure: [rs close]</body></methods><methods><class-id>Heeg.CsvWriter</class-id> <category>accessing</category><body package="GHCsvImportExport">finishCurrentLine	"Write empty cells (separators) for yet unwritten columns in this line.	Continue on next text line, column 1."	column isZero ifTrue: [^self].	rowSize - column - 1 timesRepeat: [stream nextPut: separator].	stream cr.	column := 0</body><body package="GHCsvImportExport">nextPut: aValue	"Print text for argument (number, string, nil), followed by proper separator.	Arguments with separator or CR are quoted."	column := column + 1.	aValue notNil ifTrue: [(encoders at: column) value: aValue].	stream nextPut: (column = rowSize				ifTrue: 					[column := 0.					Character cr]				ifFalse: [separator])</body><body package="GHCsvImportExport">nextPutAll: aCollection 	"print elements of argument, each followed by proper separator"	aCollection do: [:v | self nextPut: v]</body><body package="GHCsvImportExport">nextPutColumns: aCollection	"print each element (column, must be collection) of argument	to export columns number 1 to argument size"	| numberOfColumns numberOfRows |	(numberOfColumns := aCollection size) isZero ifTrue: [^self].	numberOfColumns &gt; rowSize		ifTrue: 			[self error: ('too much elements(&lt;1p&gt;) for &lt;2p&gt; columns'						expandMacrosWith: numberOfColumns						with: rowSize)].	self finishCurrentLine.	numberOfRows := aCollection first size.	1 to: numberOfRows		do: 			[:rowIndex |			1 to: numberOfColumns				do: [:ci | self nextPut: ((aCollection at: ci) at: rowIndex)].			self finishCurrentLine]</body><body package="GHCsvImportExport">nextPutHeadings: arrayOfString	"print elements of argument, each followed by proper separator"	| msg |	arrayOfString size &gt; rowSize		ifTrue: 			[msg := 'too many headings(&lt;1p&gt;) for &lt;2p&gt; columns'						expandMacrosWith: arrayOfString size						with: rowSize.			self error: msg].	self		useStringEncodersWhile: [self nextPutRows: (Array with: arrayOfString)]</body><body package="GHCsvImportExport">nextPutRows: aCollection 	"print each element (row, must be collection) of argument; ensure that each 	row is terminated and next write operation writes to column 1 in next row"	aCollection do: 		[:row | 		row size &gt; rowSize			ifTrue: [self error: ('too many elements(&lt;1p&gt;) for &lt;2p&gt; columns'						expandMacrosWith: row size with: rowSize)].		self nextPutAll: row; finishCurrentLine]</body><body package="GHCsvImportExport">useStringEncodersWhile: aBlock	"set the types to nil, which means all types are Strings"	| backup |	backup := encoders.	self types: (Array new: encoders size withAll: nil).	aBlock ensure: [encoders := backup]</body></methods><methods><class-id>Heeg.CsvWriter</class-id> <category>initialize-release</category><body package="GHCsvImportExport">encoderBlockFor: clsNilOrSymbol	clsNilOrSymbol isNil ifTrue: [^self stringEncoder].	^self		conversionBlockWithPragma: #encoder:		forType: clsNilOrSymbol		defaultBlock: [:each | each printOn: stream]</body><body package="GHCsvImportExport">initialize	super initialize.	separator := Character tab.</body><body package="GHCsvImportExport">on: aStream	super on: aStream.	quotePolicy := #()</body><body package="GHCsvImportExport">separators: aThreeCharacterCollection types: anArray	"assign separators from aString (1=column, 2=decimal, 3=thousand, e.g. ';,.') 	and column types; each type will be printed with its default policy;	possible types are nil=String, Float, Integer, Number"	separator := aThreeCharacterCollection first.	sep10 := aThreeCharacterCollection at: 2.	sep1000 := aThreeCharacterCollection at: 3.	self types: anArray</body><body package="GHCsvImportExport">types: anArray	rowSize := anArray size.	encoders := anArray collect: [:each | self encoderBlockFor: each]</body><body package="GHCsvImportExport">writeEmptyStringQuoted	"Writing data for nil or an empty string makes no difference for the export result: Both create no output.	This method configures the export to write an empty string as quoted string (which is always imported as string).	This helps an importing application to distinguish whether the source was nil or an empty string."	quotePolicy := #(#isEmpty)</body></methods><methods><class-id>Heeg.CsvWriter</class-id> <category>testing</category><body package="GHCsvImportExport">mustQuoteDueSpecialCharactersIn: aString	"Answer true if the given string contains characters that demand for quoting. This is true for	- the configured value separator	- embedded line break	Note: Line breaks in Excel cells are exported by Excel as line feed (LF)"	^(aString includes: separator)		or: [(aString includes: Character cr) or: [aString includes: Character lf]]</body><body package="GHCsvImportExport">mustQuotePerLocalPolicy: aString	"Answer true if the configured quoting policy demands that the given string must be quoted."	^quotePolicy anySatisfy: [:test | aString perform: test]</body></methods><methods><class-id>Heeg.CsvWriter</class-id> <category>private</category><body package="GHCsvImportExport">nextPutString: aString	"Print text for &lt;aString&gt;	- contained quotes are doubled	- strings with column separator or CR or quote are quoted"	| toBeWritten hasQuote mustQuote |	(hasQuote := (toBeWritten := aString) includes: $")		ifTrue: [toBeWritten := aString copyReplaceAll: '"' with: '""'].	mustQuote := hasQuote		or: [(self mustQuoteDueSpecialCharactersIn: aString)		or: [self mustQuotePerLocalPolicy: aString]].	mustQuote ifTrue: [stream nextPut: $"].	stream nextPutAll: toBeWritten.	mustQuote ifTrue: [stream nextPut: $"]</body></methods><methods><class-id>Heeg.CsvObjectReader</class-id> <category>private</category><body package="GHCsvImportExport">csvStreamOfClass: class	"instantiate the CsvReader or CsvWriter and also set locale and separators"	| reader |	reader := class on: stream.	reader locale: locale.	reader sepThousand: sep1000 decimal: sep10.	^reader</body><body package="GHCsvImportExport">objectsAsRows: lines	^lines		collect: [:object | columns collect: [:column | object perform: column getter]]</body><body package="GHCsvImportExport">readWithReader: reader	| rows |	self setColumnsAccordingToHeadline: reader nextRow.	reader types: (columns collect: #type).	rows := OrderedCollection new.	reader importRowsInto: rows.	^self rowsToObjects: rows</body><body package="GHCsvImportExport">rowsToObjects: rows	^rows collect: 			[:eachRow |			| inst |			inst := fileEntryClass new.			columns				doWithIndex: [:column :idx | inst perform: column setter with: (eachRow at: idx)].			inst postImportAction.			inst]</body><body package="GHCsvImportExport">setColumnsAccordingToHeadline: headline	| sortedColumns |	sortedColumns := fileEntryClass columnDescriptors				sorted: [:each | headline indexOf: each heading] ascending.	columns := sortedColumns select: [:each | headline includes: each heading]</body><body package="GHCsvImportExport">writeEntries: entries withWriter: writer	| rows |	writer types: (columns collect: #type).	writer nextPutHeadings: (columns collect: #heading).	rows := self objectsAsRows: entries.	writer nextPutRows: rows</body></methods><methods><class-id>Heeg.CsvObjectReader</class-id> <category>accessing</category><body package="GHCsvImportExport">fileEntryClass	^fileEntryClass</body><body package="GHCsvImportExport">fileEntryClass: aClass	fileEntryClass := aClass.	locale := fileEntryClass locale</body><body package="GHCsvImportExport">locale	^locale</body><body package="GHCsvImportExport">locale: anObject	locale := anObject</body><body package="GHCsvImportExport">on: readStream	stream := readStream.</body><body package="GHCsvImportExport">sepThousand: char1 decimal: char2 	"set characters for thousand/decimal separators"	sep1000 := char1.	sep10 := char2</body><body package="GHCsvImportExport">stream	^stream</body></methods><methods><class-id>Heeg.CsvObjectReader</class-id> <category>initialize-release</category><body package="GHCsvImportExport">initialize	super initialize.	locale := Locale named: #C.	self sepThousand: nil decimal: nil</body></methods><methods><class-id>Heeg.CsvObjectReader</class-id> <category>api</category><body package="GHCsvImportExport">readEntries	| reader |	reader := self csvStreamOfClass: CsvReader.	reader noValue: String new.	^self readWithReader: reader</body><body package="GHCsvImportExport">writeEntries: entries 	| writer |	writer := self csvStreamOfClass: CsvWriter.	columns := fileEntryClass columnDescriptors.	self writeEntries: entries withWriter: writer</body></methods><methods><class-id>Heeg.CsvObjectReader class</class-id> <category>instance creation</category><body package="GHCsvImportExport">new	^super new initialize</body><body package="GHCsvImportExport">withFileEntryClass: aCsvLineSubclass on: readStream	| newObject |	newObject := self new.	newObject fileEntryClass: aCsvLineSubclass.	newObject on: readStream.	^newObject</body></methods><methods><class-id>Heeg.CsvReader</class-id> <category>accessing</category><body package="GHCsvImportExport">csvSeparator	"Answer the character which separates CSV columns from each other (comma, tab, semicolon).	Return: Character"	^separator</body><body package="GHCsvImportExport">linesRead	^linesRead</body><body package="GHCsvImportExport">next	"Advance column index to next column and read the next cell value."	| lastColumn |	line isNil | (lastColumn := column = rowSize)		ifTrue: [line := self nextLine readStream].	^self nextInColumn: (lastColumn ifTrue: [1] ifFalse: [column + 1])</body><body package="GHCsvImportExport">nextRow	"Read next #rowSize cell values from next row.	Return: Array[rowSize]"	line := self nextLine readStream.	^(1 to: rowSize) collect: [:idx | self nextInColumn: idx]</body></methods><methods><class-id>Heeg.CsvReader</class-id> <category>private</category><body package="GHCsvImportExport">decodeString: cellString wasQuoted: wasQuoted using: aDecoderBlock	^aDecoderBlock cullWithArguments: (Array with: cellString with: wasQuoted)</body><body package="GHCsvImportExport">decoderBlockFor: classOrSymbolOrNil	"if the type is nil, use stringDecoder, otherwise try to find a method that implements a decoder for that class"	| class |	classOrSymbolOrNil isNil ifTrue: [^self stringDecoder].	^self		conversionBlockWithPragma: #decoder:		forType: classOrSymbolOrNil		defaultBlock: 			[:aString |			class := classOrSymbolOrNil isBehavior						ifTrue: [classOrSymbolOrNil]						ifFalse: [classOrSymbolOrNil asQualifiedReference value].			class readFrom: aString readStream]</body><body package="GHCsvImportExport">nextInColumn: anInteger	"Read the next value from the input stream:	- return the configured #noValue if the cell has no data (i.e. separator follows immediately)	- use quoted data string as is, do not interpret as #noValue if empty	- use type info for column 'anInteger' to instantiate the corresponding data type	Return: String | Number | Date | etc"	| isQuoted st |	(column := anInteger) = rowSize		ifTrue: [line atEnd ifTrue: [^noValue]]		ifFalse: [(line peekFor: separator) ifTrue: [^noValue]].	(isQuoted := line peekFor: $")		ifTrue: 			[st := self quotedStringFrom: line.			"consume separator"			line peekFor: separator			"use quoted string as is, possibly overriding a setting #noValue=nil"]		ifFalse: [(st := line upTo: separator) isEmpty ifTrue: [^noValue]].	^self		decodeString: st		wasQuoted: isQuoted		using: (decoders at: column)</body><body package="GHCsvImportExport">nextLine	"Read next characters from stream up to next CR. Account for quoted strings with embedded CRs.	Return: String"	| lineBuffer cr quote |	linesRead := linesRead + 1.	lineBuffer := (String new: 256) writeStream.	cr := Character cr.	quote := $".		[| ch |	(ch := stream next) == cr | ch isNil ifTrue: [^lineBuffer contents].	lineBuffer nextPut: ch.	ch == quote 		ifTrue: 			[[(ch := stream next) == quote] whileFalse: 					[ch isNil ifTrue: [self error: 'Quote expexted'].					lineBuffer nextPut: ch].			lineBuffer nextPut: quote]] 			repeat</body><body package="GHCsvImportExport">quotedStringFrom: aStream	"A doublequote character has been read. Read next characters up to end doublequote, account for embedded qoutes.	Return: String"	| quote st |	st := aStream upTo: (quote := $").	[aStream peekFor: quote]		whileTrue: [st := (st copyWith: quote) , (aStream upTo: quote)].	^st</body><body package="GHCsvImportExport">skipLeadingSpace	"The default handling for spaces is to accept as data. For non-default exports this method skips spaces."	[line peekFor: Character space] whileTrue</body><body package="GHCsvImportExport">trimmedStringFrom: aString	"Return aString without trailing spaces, configured #noValue if result is empty."	| sz idx |	idx := sz := aString size.	[idx isZero ifTrue: [^noValue].	(aString at: idx) = Character space]			whileTrue: [idx := idx - 1].	^idx = sz ifTrue: [aString] ifFalse: [aString copyFrom: 1 to: idx]</body></methods><methods><class-id>Heeg.CsvReader</class-id> <category>initialize-release</category><body package="GHCsvImportExport">detectSeparatorIn: aStream	"&lt;aStream&gt; holds a row of data in CSV format (character separated values). 	Scan it to detect the column separator used for the entire stream, count columns.	Store the found separator character in inst.var. #separator, assign #rowSize with the found number of columns."	| countQuoted ch max characters sortedSeparators |	countQuoted := 0.	characters := Bag new.	[aStream atEnd] whileFalse: 			[ch := aStream next.			ch = $"				ifTrue: 					[countQuoted := countQuoted + 1.					self quotedStringFrom: aStream.					ch := aStream next].			characters add: ch].	"sort tab, semicolon or comma according to their occurances in the text-line. 	The one with the most occurances is most likely the column-separator"	sortedSeparators := (Array withAll: '	;,')				sorted: [:each | characters occurrencesOf: each] descending.	max := characters occurrencesOf: sortedSeparators first.	separator := max = 0				ifTrue: [countQuoted = 1 ifTrue: [$,] ifFalse: [$;]]				ifFalse: [sortedSeparators first].	rowSize := max + 1</body><body package="GHCsvImportExport">noValue: stringOrNil	"Assign the result value when reading an empty cell."	noValue := stringOrNil</body><body package="GHCsvImportExport">on: aStream	"Assign the input stream. Find out column separator and number of columns."	| firstLine |	super on: aStream.	"general streams may raise an exception because #lineEndConvention: calls #shouldNotImplement"	[aStream lineEndAuto] on: Error do: [:ex | ex return].	firstLine := stream withPosition: stream position				do: [:ignoredSavedPosition | stream upTo: Character cr].	firstLine isEmpty ifTrue: [self error: 'Cannot import this table'].	self detectSeparatorIn: firstLine readStream.	self types: ((Array new: rowSize) atAllPut: nil).	linesRead := 0</body><body package="GHCsvImportExport">types: arrayOfClasses	"Assign value data types for each column. Accepted data types are	- nil: equivalent to String	- Class or Class-Name (String or Symbol)	For each Class a decoder is used, either the standard decoder (aClass readFrom: aStream) 	or predefined decoders that are returned by Methods that have a &lt;decoder: #ClassName&gt; pragma.	Predefined decoders exist for String, Numbers and Date/Time classes."	decoders := arrayOfClasses collect: [:each | self decoderBlockFor: each]</body></methods><methods><class-id>Heeg.CsvReader</class-id> <category>import</category><body package="GHCsvImportExport">importRowInto: anOrderedCollection	"for some reason this method did not have a plural 'rows' in its name, even though it did read all rows until the end of the file.	Leaving here for backward compatibility"		self importRowsInto: anOrderedCollection</body><body package="GHCsvImportExport">importRowsInto: anOrderedCollection	"Load all rows in the input stream, add them to &lt;anOrderedCollection&gt;."		[[stream atEnd] whileFalse: 			[| anArray |			anArray := self nextRow.			anOrderedCollection add: anArray]]			ensure: [self close]</body></methods><methods><class-id>Heeg.CsvReader</class-id> <category>testing</category><body package="GHCsvImportExport">atEnd	"considering a line like: ';;' it is possible to send #next 3 times. 	Only asking the internal stream if it's already at the end is not sufficient because it 	is possible to read a third column in that row even though the stream is already at the end of the file."	^stream atEnd and: [column = rowSize]</body></methods><methods><class-id>Heeg.CsvReader class</class-id> <category>instance creation</category><body package="GHCsvImportExport">onFileNamed: stringOrFilename	"Create a new instance for reading contents of the specified file."	| aFilename stream |	aFilename := stringOrFilename asFilename.	stream := (aFilename withEncoding: #autodetectOrDefault) readStream.	^self on: stream</body></methods><methods><class-id>Heeg.CsvFileViewer class</class-id> <category>resources</category><body package="GHCsvImportExport">menu	"Tools.MenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Open...' 							#value: #selectAndReadFile ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Quit' 							#value: #closeRequest ) ) #(1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Edit' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Copy &amp;row' 							#value: #copyRow ) 						#(#{UI.MenuItem} 							#rawLabel: 'Copy &amp;column' 							#value: #copyColumn ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Find...' 							#value: #findString ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Inspect' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Row' 							#value: #inspectRow ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Column' 							#value: #inspectColumn ) 						#(#{UI.MenuItem} 							#rawLabel: 'Column &amp;set' 							#value: #inspectColumnSet ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Table' 							#value: #inspectTable ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Model' 							#value: #inspect ) ) #(5 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Heeg.CsvFileViewer class</class-id> <category>interface specs</category><body package="GHCsvImportExport">selectionInfoSpec	"Tools.UIPainter new openOnClass: self andSelector: #selectionInfoSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Table Selection Info' 			#bounds: #(#{Graphics.Rectangle} 755 578 1166 623 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 0 0 120 25 ) 					#name: #selectionIndex 					#model: #'selectionHolder selectionIndex' 					#tabable: false 					#isReadOnly: false 					#type: #object ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 124 0 0 0 0 1 25 0 ) 					#name: #selection 					#model: #'selectionHolder selection' 					#tabable: false 					#isReadOnly: false ) ) ) )</body><body package="GHCsvImportExport">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'CSV File Viewer' 			#bounds: #(#{Graphics.Rectangle} 411 352 870 642 ) 			#flags: 4 			#menu: #menu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 2 2 ) 					#name: #lblFilename 					#label: 'Filename' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 22 0 -126 1 47 0 ) 					#name: #txtFilename 					#model: #filename 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #openFile ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -95 1 0 0 ) 					#name: #lblNumberOfLines 					#label: 'cols' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -95 1 22 0 -50 1 47 0 ) 					#name: #txtNumberOfColumns 					#model: #columns 					#isReadOnly: true 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -47 1 0 0 ) 					#name: #lblNumberOfLines 					#label: 'lines' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -47 1 22 0 -2 1 47 0 ) 					#name: #txtNumberOfLines 					#model: #lines 					#isReadOnly: true 					#type: #number ) 				#(#{UI.TableViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 50 0 0 1 -30 1 ) 					#model: #table 					#showHGrid: true 					#showVGrid: true ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.LayoutFrame} -125 1 22 0 -100 1 47 0 ) 					#name: #btnSelectAndReadFile 					#model: #selectAndReadFile 					#label: #iconForOpenFile 					#hasCharacterOrientedLabel: false 					#isDefault: false ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 -27 1 -2 1 -2 1 ) 					#name: #selectionInfo 					#flags: 0 					#minorKey: #selectionInfoSpec ) ) ) )</body></methods><methods><class-id>Heeg.CsvLine class</class-id> <category>file description</category><body package="GHCsvImportExport">columnPragma	&lt;pragmas: #class&gt;	^#(#column)</body></methods><methods><class-id>Heeg.CsvWriter</class-id> <category>encoders</category><body package="GHCsvImportExport">dateTimeEncoder	&lt;encoder: #Date&gt;	&lt;encoder: #Time&gt;	&lt;encoder: #Timestamp&gt;	^[:anObject | self locale timePolicy print: anObject on: stream]</body><body package="GHCsvImportExport">numberEncoder	&lt;encoder: #Number&gt;	&lt;encoder: #Integer&gt;	&lt;encoder: #Float&gt;	&lt;encoder: #Double&gt;	^[:anObject | self numberPolicy print: anObject on: stream]</body><body package="GHCsvImportExport">stringEncoder	&lt;encoder: #String&gt;	^[:string | self nextPutString: string]</body></methods><methods><class-id>Heeg.CsvWriter class</class-id> <category>instance creation</category><body package="GHCsvImportExport">encoderPragma	&lt;pragmas: #instance&gt;	^#(#encoder:)</body></methods><methods><class-id>Heeg.CsvReader</class-id> <category>private-reading</category><body package="GHCsvImportExport">dateDecoder	&lt;decoder: #Date&gt;	^[:aString | locale readDateFrom: aString readStream]</body><body package="GHCsvImportExport">doubleDecoder	&lt;decoder: #Double&gt;	&lt;decoder: #Float&gt;	^[:aString | self numberPolicy reader readFrom: aString readStream type: Double]</body><body package="GHCsvImportExport">integerDecoder	&lt;decoder:#Integer&gt;		^[:aString | self numberPolicy reader readFrom: aString readStream type: Integer]</body><body package="GHCsvImportExport">numberDecoder	&lt;decoder:#Number&gt;		^[:aString | self numberPolicy reader readFrom: aString readStream type: Number]</body><body package="GHCsvImportExport">stringDecoder	"Return aString without modification. Use #trimmedStringFrom: if trailing spaces should be removed."	&lt;decoder: #String&gt;	^[:aString | aString]</body><body package="GHCsvImportExport">timeDecoder	&lt;decoder: #Time&gt;	^[:aString | locale readTimeFrom: aString readStream]</body><body package="GHCsvImportExport">timestampDecoder	&lt;decoder: #Timestamp&gt;	^[:aString | locale readTimestampFrom: aString readStream]</body></methods><methods><class-id>Heeg.CsvReader class</class-id> <category>instance creation</category><body package="GHCsvImportExport">decoderPragmas	&lt;pragmas: #instance&gt;	^#(#decoder:)</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="GHCsvImportExport">openCsvViewer	"Open the CsvViewer."	&lt;	menuItem: 'CSV Viewer'	nameKey: nil	menu: #(#menuBar #tools)	position: 28.7&gt;	Heeg.CsvFileViewer open</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>