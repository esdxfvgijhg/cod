<?xml version="1.0"?><st-source><!-- Name: PetitParserNotice: Copyright (c) 2010 Lukas RenggliPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.[edit]BundleName: PetitParserBundleStructure: a Store.BundleForParcelComment: This packages version is based on "SCG 0.16". It also includes fixes which are required to successfully load it. Comment from Version 'SCG 0.16':After the *announcement>http://www.iam.unibe.ch/pipermail/moose-dev/2010-February/003956.html* in the Moose mailing list and after *various>http://damiencassou.seasidehosting.st/* *people>http://stephane.ducasse.free.fr/* *have>http://www.tudorgirba.com/* asked me to provide some introduction to PetitParser I decided to write short tutorial.Originally I have written PetitParser as part of my work on the *Helvetia>http://scg.unibe.ch/research/helvetia* system. PetitParser is a parsing framework different to many other popular parser generators. For example, it is not table based such as *SmaCC>http://www.refactory.com/Software/SmaCC/index.html* or *ANTLR>http://www.antlr.org/*. Instead it uses a unique combination of four alternative parser methodologies: scannerless parsers, parser combinators, parsing expression grammars and packrat parsers. As such PetitParser is more powerful in what it can parse and it arguably fits better the dynamic nature of Smalltalk. Let's have a quick look at these four parser methodologies:# ''Scannerless Parsers'' combine what is usually done by two independent tools (scanner and parser) into one. This makes writing a grammar much simpler and avoids common problems when grammars are composed.# ''Parser Combinators'' are building blocks for parsers modeled as a graph of composable objects; they are modular and maintainable, and can be changed, recomposed, transformed and reflected upon.# ''Parsing Expression Grammars'' (PEGs) provide ordered choice. Unlike in parser combinators, the ordered choice of PEGs always follows the first matching alternative and ignores other alternatives. Valid input always results in exactly one parse-tree, the result of a parse is never ambiguous. # ''Packrat Parsers'' give linear parse time guarantees and avoid common problems with left-recursion in PEGs.!! Loading PetitParserEnough theory, let's get started. PetitParser is developed in *Pharo>http://www.pharo-project.com*, but is also available on other Smalltalk platforms. A ready made image can be downloaded *here>http://hudson.lukas-renggli.ch/job/PetitParser/lastSuccessfulBuild/artifact/petitparser/%2Azip%2A/petitparser.zip*. To load PetitParser into an existing image evaluate the following Gofer expression:==Gofer new==    renggli: 'petit'; ==    package: 'PetitParser';==    load.There are other packages in the same repository that provide additional features, for example ==PetitSmalltalk== is a Smalltalk grammar, ==PetitXml== is an XML grammar, ==PetitAnalizer== can perform analysis on grammars, and ==PetitGui== is a Glamour IDE for writing complex grammars. We are not going to use any of these packages for now.More information on how to get PetitParser can be found on the *website>http://scg.unibe.ch/research/helvetia/petitparser* of the project.!! Writing a Simple GrammarWriting grammars with PetitParser is simple as writing Smalltalk code. For example to write a grammar that can parse identifiers that start with a letter followed by zero or more letter or digits is defined as follows. In a workspace we evaluate:== identifier := #letter asParser , #word asParser star.If you inspect the object ==identifier== you'll notice that it is an instance of a ==PPSequenceParser==. This is because the ==#,== operator created a sequence of ''a letter'' and ''a zero or more word character'' parser. If you dive further into the object you notice the following simple composition of different parser objects:= PPSequenceParser (this parser accepts a sequence of parsers)=     PPPredicateObjectParser (this parser accepts a single letter)=     PPRepeatingParser (this parser accepts zero or more instances of another parser)=         PPPredicateObjectParser (this parser accepts a single word character)!! Parsing Some InputTo actually parse a string (or stream) we can use the method ==#parse:==:== identifier parse: 'yeah'.          " - > #($y #($e $a $h)) "== identifier parse: 'f12'.           " - > #($f #($1 $2)) "While it seems odd to get these nested arrays with characters as a return value, this is the default decomposition of the input into a parse tree. We'll see in a while how that can be customized.If we try to parse something invalid we get an instance of ==PPFailure== as an answer:== identifier parse: '123'.           " - > letter expected at 0 "Instances of ==PPFailure== are the only objects in the system that answer with ==true== when you send the message ==#isPetitFailure==. Alternatively you can also use ==#parse:onError:== to throw an exception in case of an error:== identifier==     parse: '123'==     onError: [ :msg :pos | self error: msg ].If you are only interested if a given string (or stream) matches or not you can use the following constructs:== identifier matches: 'foo'.         " - > true "== identifier matches: '123'.         " - > false "Furthermore to find all matches in a given input string (or stream) you can use:== identifier matchesIn: 'foo 123 bar12'.!! Different Kinds of ParsersPetitParser provide a large set of ready-made parser that you can compose to consume and transform arbitrarily complex languages. The terminal parsers are the most simple ones. We've already seen a few of those: |! Terminal Parsers |! Description| ==$a asParser== | Parses the character ==$a==.| =='abc' asParser== | Parses the string =='abc'==.| ==#any asParser== | Parses any character.| ==#digit asParser== | Parses the digits 0..9.| ==#letter asParser== | Parses the letters a..z and A..Z.The class side of ==PPPredicateObjectParser== provides a lot of other factory methods that can be used to build more complex terminal parsers. The next set of parsers are used to combine other parsers together:|! Parser Combinators |! Description| ==p1 , p2== | Parses ==p1== followed by ==p2== (sequence).| ==p1 / p2== | Parses ==p1==, if that doesn't work parses ==p2== (ordered choice).| ==p star== | Parses zero or more ==p==.| ==p plus== | Parses one or more ==p==.| ==p optional== | Parses ==p== if possible.| ==p and== | Parses ==p== but does not consume its input. | ==p not== | Parses ==p== and succeed when ==p== fails, but does not consume its input.| ==p end== | Parses ==p== and succeed at the end of the input.So instead of using the ==#word== predicated we could have written our identifier parser like this:== identifier := #letter asParser , (#letter asParser / #digit asParser) star.To attach an action or transformation to a parser we can use the following methods:|! Action Parsers |! Description| ==p \==> aBlock== | Performs the transformation given in ==aBlock==.| ==p flatten== | Creates a string from the result of ==p==.| ==p token== | Creates a token from the result of ==p==.| ==p trim== | Trims whitespaces before and after ==p==.To return a string of the parsed identifier, we can modify our parser like this:== identifier := (#letter asParser , (#letter asParser / #digit asParser) star) flatten.These are the basic elements to build parsers. There are a few more well documented and tested factory methods in the ==operations== protocol of ==PPParser==. If you want browse that protocol.!! Writing a More Complicated GrammarNow we are able to write a more complicated grammar for evaluating simple arithmetic expressions. Within a workspace we start with the grammar for a number (actually an integer):== number :=  #digit asParser plus token trim ==> [ :token | token value asNumber ].Then we define the productions for addition and multiplication in order of precedence. Note that we instantiate the productions as ==PPUnresolvedParser== upfront, because they recursively refer to each other. The method ==#def:== resolves this recursion using the reflective facilities of the host language:== term := PPUnresolvedParser new.== prod := PPUnresolvedParser new.== prim := PPUnresolvedParser new.== == term def: (prod , $+ asParser token trim , term ==> [ :nodes | nodes first + nodes last ])==     / prod.== prod def: (prim , $* asParser token trim , prod ==> [ :nodes | nodes first * nodes last ])==     / prim.== prim def: ($( asParser token trim , term , $) asParser token trim ==> [ :nodes | nodes second ])==     / number.To make sure that our parser consumes all input we wrap it with the ''end'' parser into the start production:== start := term end.That's it, now we can test our parser and evaluator:== start parse: '1 + 2 * 3'.       " - > 7 "== start parse: '(1 + 2) * 3'.     " - > 9 "As an exercise we could extend the parser to also accept negative numbers and floating point numbers, not only integers. Furthermore it would be useful to add support subtraction and division as well. All these features can be added with a few lines of PetitParser code.DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'SUnit' ''))MessageCatalog: petitParserParcel: nilParcelName: PetitParserPrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'SUnit' #componentType #package))PrerequisiteParcels: #(#('Base VisualWorks' '') #('SUnit' '') #('Base VisualWorks' ''))Version: 8.3 - 1Date: 1:41:33 PM June 13, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.2) of 9. Juni 2017 on 13. Juni 2017 at 13:41:33</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>PetitParser</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private XProgramming.SUnit.*			</imports><category></category><attributes><package>PetitParser-Preload</package></attributes></name-space><class><name>PPParser</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPParser</class-id><body>An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.Instance Variables:	properties	&lt;Dictionary&gt;	Stores additional state in the parser object.</body></comment><class><name>PPDelegateParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPDelegateParser</class-id><body>A parser that delegates to another parser.Instance Variables:	parser	&lt;PPParser&gt;	The parser to delegate to.</body></comment><class><name>PPFlattenParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPFlattenParser</class-id><body>A parser that answers a flat copy of the range my delegate parses.</body></comment><class><name>PPAbstractParserTest</name><environment>PetitParser</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Core</category><attributes><package>PetitTests</package></attributes></class><class><name>PPTokenTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPFailingParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPFailingParser</class-id><body>A parser that consumes nothing and always fails.Instance Variables:	message &lt;String&gt;	The failure message.</body></comment><class><name>PPTrimmingParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trimmer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPTrimmingParser</class-id><body>A parser that silently consumes spaces before and after the delegate parser.</body></comment><class><name>PPStream</name><environment>PetitParser</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPStream</class-id><body>A positional stream implementation used for parsing. It overrides some methods for optimization reasons.</body></comment><class><name>PPRewriterTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rewriter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Tests</category><attributes><package>PetitAnalyzer</package></attributes></class><class><name>PPRepeatingParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>min max </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPRepeatingParser</class-id><body>An abstract parser that repeatedly parses between 'min' and 'max' instances of its delegate. The default configuration parses an infinite number of elements, as 'min' is set to 0 and 'max' to infinity (SmallInteger maxVal).Instance Variables:	min	&lt;Integer&gt;	The minimum number of repetitions.	max	&lt;Integer&gt;	The maximum number of repetitions.</body></comment><class><name>PPLimitedRepeatingParser</name><environment>PetitParser</environment><super>PetitParser.PPRepeatingParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>limit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLimitedRepeatingParser</class-id><body>An abstract parser that repeatedly parses between 'min' and 'max' instances of my delegate and that requires the input to be completed with a specified parser 'limit'. Subclasses provide repeating behavior as typically seen in regular expression implementations (non-blind).Instance Variables:	limit	&lt;PPParser&gt;	The parser to complete the input with.</body></comment><class><name>PPAndParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPAndParser</class-id><body>The and-predicate, a parser that succeeds whenever its delegate does, but does not consume the input stream [Parr 1994, 1995].</body></comment><class><name>PPFailure</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPFailure</class-id><body>The failure object in PetitParser. It is the only class that responds to #isPetitFailure with true. It contains an error message and a position of the occurrence of the failure.Instance Variables:	message	&lt;String&gt;	The error message of this failure.	position	&lt;Integer&gt;	The position of this failure in the input stream.</body></comment><class><name>PPListParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parsers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPListParser</class-id><body>Abstract parser that parses a list of things in some way (to be specified by the subclasses).Instance Variables:	parsers	&lt;SequenceableCollection of: PPParser&gt;	A sequence of other parsers to delegate to.</body></comment><class><name>PPChoiceParser</name><environment>PetitParser</environment><super>PetitParser.PPListParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPChoiceParser</class-id><body>A parser that uses the first parser that succeeds.</body></comment><class><name>PPAnalyzerTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Tests</category><attributes><package>PetitAnalyzer</package></attributes></class><class><name>PPTokenParser</name><environment>PetitParser</environment><super>PetitParser.PPFlattenParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tokenClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPTokenParser</class-id><body>A parser that answers a token of the range my delegate parses.Instance Variables:	tokenClass	&lt;PPToken class&gt;	The token sub-class to be used.</body></comment><class><name>PPUnresolvedParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPUnresolvedParser</class-id><body>This is a temporary placeholder or forward reference to a parser that has not been defined yet. If everything goes well it will eventually be replaced with the real parser instance.</body></comment><class><name>PPParserResource</name><environment>PetitParser</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parsers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Core</category><attributes><package>PetitTests</package></attributes></class><class><name>PPCompositeParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPCompositeParser</class-id><body>A PPCompositeParser is composed parser built from various primitive parsers. Every production in the receiver is specified as a method that returns its parser. Note that every production requires an instance variable of the same name, otherwise the production is not cached and cannot be used in recursive grammars. Productions should refer to each other by reading the respective inst-var. Note: these inst-vars are typically not written, as the assignment happens in the initialize method using reflection.The start production is defined in the method start. It is aliased to the inst-var parser defined in the superclass of PPCompositeParser.</body></comment><class><name>PPLambdaParser</name><environment>PetitParser</environment><super>PetitParser.PPCompositeParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expression abstraction application variable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Examples</category><attributes><package>PetitTests</package></attributes></class><class><name>PPExtensionTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPPredicateParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>predicate predicateMessage negated negatedMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPPredicateParser</class-id><body>An abstract parser that accepts if a given predicate holds.Instance Variables:	predicate	&lt;BlockClosure&gt;	The block testing for the predicate.	predicateMessage	&lt;String&gt;	The error message of the predicate.	negated	&lt;BlockClosure&gt;	The block testing for the negation of the predicate.	negatedMessage	&lt;String&gt;	The error message of the negated predicate.</body></comment><class><name>PPPredicateObjectParser</name><environment>PetitParser</environment><super>PetitParser.PPPredicateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPPredicateObjectParser</class-id><body>A parser that accepts if a given predicate on one element of the input sequence holds.</body></comment><class><name>PPExpressionParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operators </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPExpressionParser</class-id><body>A PPExpressionParser is a parser to conveniently define an expression grammar with prefix, postfix, and left- and right-associative infix operators.The following code initializes a parser for arithmetic expressions. First we instantiate an expression parser, a simple parser for expressions in parenthesis and a simple parser for integer numbers.	expression := PPExpressionParser new.	parens := $( asParser token trim , expression , $) asParser token trim 		==&gt; [ :nodes | nodes second ].	integer := #digit asParser plus token trim		==&gt; [ :token | token value asInteger ].	Then we define on what term the expression grammar is built on:	expression term: parens / integer.	Finally we define the operator-groups in descending precedence. Note, that the action blocks receive both, the terms and the parsed operator in the order they appear in the parsed input. 		expression		group: [ :g |			g prefix: $- asParser token trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser token trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser token trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser token trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser token trim do: [ :a :op :b | a * b ].			g left: $/ asParser token trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser token trim do: [ :a :op :b | a + b ].			g left: $- asParser token trim do: [ :a :op :b | a - b ] ].		After evaluating the above code the 'expression' is an efficient parser that evaluates examples like:	expression parse: '-8++'.	expression parse: '1+2*3'.	expression parse: '1*2+3'.	expression parse: '(1+2)*3'.	expression parse: '8/4/2'.	expression parse: '8/(4/2)'.	expression parse: '2^2^3'.	expression parse: '(2^2)^3'.	Instance Variables:	operators	&lt;Dictionary&gt;	The operators defined in the current group.</body></comment><class><name>PPRule</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner search </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><comment><class-id>PetitParser.PPRule</class-id><body>PPRule is the abstract superclass of all of the grammar search rules. A rule is the first class representation of a particular pattern to search for. The owner of the rule is the algorithms that actually executes the search. This arrangement allows multiple searches to be conducted by a single processor.Instance Variables:	owner	&lt;PPProcessor&gt;	The processor that is actually performing the search.	search	&lt;PPParser&gt;	The parse pattern to be searched.</body></comment><class><name>PPReplaceRule</name><environment>PetitParser</environment><super>PetitParser.PPRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>verificationBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><comment><class-id>PetitParser.PPReplaceRule</class-id><body>PPReplaceRule is the abstract superclass of all of the transforming rules. The rules change the grammar by replacing the node that matches the rule. Subclasses implement different strategies for this replacement.Instance Variables:	verificationBlock	&lt;BlockClosure&gt;	Is evaluated with the matching parser and allows for further verification of a match.</body></comment><class><name>PPObjectTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPCompositeParserTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Core</category><attributes><package>PetitTests</package></attributes></class><class><name>PPLambdaParserTest</name><environment>PetitParser</environment><super>PetitParser.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPSearcherTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Tests</category><attributes><package>PetitAnalyzer</package></attributes></class><class><name>PPArithmeticParserTest</name><environment>PetitParser</environment><super>PetitParser.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPExpressionParserTest</name><environment>PetitParser</environment><super>PetitParser.PPArithmeticParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPParserReplaceRule</name><environment>PetitParser</environment><super>PetitParser.PPReplaceRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>replaceParser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><comment><class-id>PetitParser.PPParserReplaceRule</class-id><body>PPParserReplaceRule replaces a matched grammar with another grammar, which may include patterns from the matching grammar.Instance Variables:	replaceParser	&lt;PPParser&gt;	The parser to replace the matched parser with.</body></comment><class><name>PPMemento</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>result count position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPMemento</class-id><body>PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.Instance Variables:	result	&lt;Object&gt;	The cached result.	count	&lt;Integer&gt;	The number of recursive cycles followed.	position	&lt;Integer&gt;	The position of the cached result in the input stream.</body></comment><class><name>PPProcessor</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searches context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><comment><class-id>PetitParser.PPProcessor</class-id><body>PPProcessor is an abstract superclass to PPRewriter and PPSearcher. It implements common functionality to search and transform grammars.The implementation of these matching algorithms is inspired from the refactoring engine by Don Roberts and John Brant. Contrary to the original implementation that worked on syntax trees, this implementation was generalized and works on possibly cyclic search patterns and grammar graphs.Instance Variables:	searches	&lt;Collection of: PPRule&gt;	The rules to be processed.	context	&lt;Dictionary&gt;	The current search context.</body></comment><class><name>PPSearcher</name><environment>PetitParser</environment><super>PetitParser.PPProcessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>answer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><comment><class-id>PetitParser.PPSearcher</class-id><body>PPSearcher walks over a grammar specification and matches its parsers against the patterns using #match:inContext:.Instance Variables:	answer &lt;Object&gt;	The answer propagated between matches.</body></comment><class><name>PPLazyRepeatingParser</name><environment>PetitParser</environment><super>PetitParser.PPLimitedRepeatingParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLazyRepeatingParser</class-id><body>A lazy repeating parser, commonly seen in regular expression implementations. It limits its consumption to meet the 'limit' condition as early as possible.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (limit and ==&gt; [ :each | OrderedCollection new ])		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])).	^ parser ==&gt; [ :rest | rest asArray ]</body></comment><class><name>PPBlockReplaceRule</name><environment>PetitParser</environment><super>PetitParser.PPReplaceRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>replaceBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><comment><class-id>PetitParser.PPBlockReplaceRule</class-id><body>PPBlockReplaceRule replaces the matching node by the result of evaluating replaceBlock. This allows arbitrary computation to come up with a replacement.Instance Variables:	replaceBlock &lt;BlockClosure&gt;	The block that returns the parer to replace to matching parser with.</body></comment><class><name>PPLiteralParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>literal message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLiteralParser</class-id><body>Abstract literal parser that parses some kind of literal type (to be specified by subclasses).Instance Variables:	literal	&lt;Object&gt;	The literal object to be parsed.	message	&lt;String&gt;	The error message to be generated.</body></comment><class><name>PPMemoizedParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream buffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPMemoizedParser</class-id><body>A memoized parser, for refraining redundant computations.Instance Variables:	stream	&lt;PositionableStream&gt;	The stream of the associated memento objects.	buffer	&lt;Array of: PPMemento&gt;	The buffer of memento objects.</body></comment><class><name>PPLiteralSequenceParser</name><environment>PetitParser</environment><super>PetitParser.PPLiteralParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLiteralSequenceParser</class-id><body>A parser accepts a sequence of literal objects, such as a String. This is an optimization to avoid having to compose longer sequences from PPSequenceParser.</body></comment><class><name>PPPredicateTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPEpsilonParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPEpsilonParser</class-id><body>A parser that consumes nothing and always succeeds.</body></comment><class><name>PPOptionalParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPOptionalParser</class-id><body>A parser that optionally parsers its delegate, or answers nil.</body></comment><class><name>PPToken</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection start stop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPToken</class-id><body>PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection and its start and stop position.Instance Variables:	collection	&lt;SequenceableCollection&gt;	The collection this token comes from.	start	&lt;Integer&gt;	The start position in the collection.	stop	&lt;Integer&gt;	The stop position in the collection.</body></comment><class><name>PPParserTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPActionParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPActionParser</class-id><body>A parser that performs an action block with the successful parse result of the delegate.Instance Variables:	block	&lt;BlockClosure&gt;	The action block to be executed.</body></comment><class><name>PPWrappingParser</name><environment>PetitParser</environment><super>PetitParser.PPActionParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPWrappingParser</class-id><body>A parser that performs an action block upon activation with the stream and a continuation block.</body></comment><class><name>PPNotParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPNotParser</class-id><body>The not-predicate, a parser that succeeds whenever its delegate does not, but consumes no input [Parr 1994, 1995].</body></comment><class><name>PPCharSetPredicate</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block classification </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><class><name>PPSequenceParser</name><environment>PetitParser</environment><super>PetitParser.PPListParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPSequenceParser</class-id><body>A parser that parses a sequence of parsers.</body></comment><class><name>PPPattern</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>verificationBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><comment><class-id>PetitParser.PPPattern</class-id><body>PPPattern is meta-parser that is solely used to match other types of parsers. It cannot be used for actually parsing something. The constructor method determines what can be matched.</body></comment><class><name>PPPossessiveRepeatingParser</name><environment>PetitParser</environment><super>PetitParser.PPRepeatingParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPPossessiveRepeatingParser</class-id><body>The default repeating parser with standard PEG semantics (i.e. possessive, blind, eager).</body></comment><class><name>PPArithmeticParser</name><environment>PetitParser</environment><super>PetitParser.PPCompositeParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>terms addition factors multiplication power primary parentheses number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Examples</category><attributes><package>PetitTests</package></attributes></class><class><name>PPPluggableParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPPluggableParser</class-id><body>A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.Instance Variables:	block	&lt;BlockClosure&gt;	The pluggable one-argument block.</body></comment><class><name>PPEndOfInputParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPEndOfInputParser</class-id><body>A parser that succeeds only at the end of the input stream.</body></comment><class><name>PPComposedTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPPredicateSequenceParser</name><environment>PetitParser</environment><super>PetitParser.PPPredicateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPPredicateSequenceParser</class-id><body>A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.Instance Variables:	size	&lt;Integer&gt;	The number of elements to consume.</body></comment><class><name>PPSearchRule</name><environment>PetitParser</environment><super>PetitParser.PPRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>answerBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><comment><class-id>PetitParser.PPSearchRule</class-id><body>PPSearchRule is a rule that simply searches for matches to the rule. Every time a match is found, answerBlock is evaluated with the parser that matches and the current answer. This two-argument approach allows a collection to be formed from all of the matches, like with #inject:into:.Instance Variables:	answerBlock	&lt;BlockClosure&gt;	Block to evaluate with the matching node and the current answer.</body></comment><class><name>PPListPattern</name><environment>PetitParser</environment><super>PetitParser.PPPattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><comment><class-id>PetitParser.PPListPattern</class-id><body>PPListPattern that is used to match any number of parsers. As its superclass, it cannot be used for actually parsing something.</body></comment><class><name>PPRewriter</name><environment>PetitParser</environment><super>PetitParser.PPProcessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><comment><class-id>PetitParser.PPRewriter</class-id><body>PPRewriter walks over a grammar graph and transforms its parsers. If the grammar is modified, #hasChanged returns true.Instance Variables:	changed	&lt;Boolean&gt;	Indicates if the last operation has changed anything.</body></comment><class><name>PPGreedyRepeatingParser</name><environment>PetitParser</environment><super>PetitParser.PPLimitedRepeatingParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPGreedyRepeatingParser</class-id><body>A greedy repeating parser, commonly seen in regular expression implementations. It aggressively consumes as much input as possible and then backtracks to meet the 'limit' condition.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])		with: (limit and ==&gt; [ :each | OrderedCollection new ])).	^ parser ==&gt; [ :rest | rest asArray ]</body></comment><class><name>PPSentinel</name><environment>PetitParser</environment><super>PetitParser.PPEpsilonParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current instance </class-inst-vars><imports></imports><category>PetitAnalyzer-Core</category><attributes><package>PetitAnalyzer</package></attributes></class><class><name>PPLiteralObjectParser</name><environment>PetitParser</environment><super>PetitParser.PPLiteralParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLiteralObjectParser</class-id><body>A parser that accepts a single literal object, such as a character. This is the same as the predicate parser 'PPPredicateParser expect: literal' but slightly more efficient.</body></comment><class><name>PPScriptingTest</name><environment>PetitParser</environment><super>PetitParser.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><comment><class-id>PetitParser.PPScriptingTest</class-id><body>These are some simple demo-scripts of parser combinators for the compiler construction course.http://www.iam.unibe.ch/~scg/Teaching/CC/index.html</body></comment><shared-variable><name>NewLineParser</name><environment>PetitParser.PPToken</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>PetitParser</package></attributes></shared-variable><methods><class-id>PetitParser.PPParser</class-id> <category>accessing-properties</category><body package="PetitParser">hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]</body><body package="PetitParser">propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]</body><body package="PetitParser">propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]</body><body package="PetitParser">propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]</body><body package="PetitParser">propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject</body><body package="PetitParser">removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]</body><body package="PetitParser">removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>parsing</category><body package="PetitParser">matches: anObject	"Answer if anObject can be parsed by the receiver."		^ (self parse: anObject) isPetitFailure not</body><body package="PetitParser">matchesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answered an OrderedCollection of the matched parse-trees."	| result |	result := OrderedCollection new.	self 		matchesIn: anObject		do: [ :each | result addLast: each ].	^ result</body><body package="PetitParser">matchesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Make sure to always consume exactly one character with each step, to not miss any match."	((self and ==&gt; aBlock , #any asParser) / #any asParser) star parse: anObject</body><body package="PetitParser">matchesSkipIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of the matched parse-trees. Skip over matches."	| result |	result := OrderedCollection new.	self 		matchesSkipIn: anObject		do: [ :each | result addLast: each ].	^ result</body><body package="PetitParser">matchesSkipIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Skip over matches."	(self ==&gt; aBlock / #any asParser) star parse: anObject</body><body package="PetitParser">matchingRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingRangesIn: anObject		do: [ :value | result addLast: value ].	^ result</body><body package="PetitParser">matchingRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock with the range of each match (index of first character to: index of last character)."		[ :stream | stream position + 1 ] asParser , self , [ :stream | stream position ] asParser		matchesIn: anObject		do: [ :value | aBlock value: (value first to: value last) ]</body><body package="PetitParser">matchingSkipRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingSkipRangesIn: anObject		do: [ :value | result addLast: value ].	^ result</body><body package="PetitParser">matchingSkipRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Evaluate aBlock with the range of each match (index of first character to: index of last character)."		[ :stream | stream position + 1 ] asParser , self , [ :stream | stream position ] asParser		matchesSkipIn: anObject		do: [ :value | aBlock value: (value first to: value last) ]</body><body package="PetitParser">parse: anObject	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."		^ self parseOn: anObject asPetitStream</body><body package="PetitParser">parse: anObject onError: aBlock	"Parse anObject with the receiving parser and answer the parse-result or answer the result of evaluating aBlock. Depending on the number of arguments of the block it is simply evaluated, evaluated with the failure object, or evaluated with the error message and position."		| result |	result := self parse: anObject.	result isPetitFailure		ifFalse: [ ^ result ].	aBlock numArgs = 0		ifTrue: [ ^ aBlock value ].	aBlock numArgs = 1		ifTrue: [ ^ aBlock value: result ].	^ aBlock value: result message value: result position</body><body package="PetitParser">parseOn: aStream	"Parse aStream with the receiving parser and answer the parse-result or an instance of PPFailure. Override this method in subclasses to specify custom parse behavior. Do not call this method from outside, instead use #parse:."		self subclassResponsibility</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>accessing</category><body package="PetitParser">children	"Answer a set of child parsers that could follow the receiver."	^ #()</body><body package="PetitParser">name	"Answer the production name of the receiver."		^ self propertyAt: #name ifAbsent: [ nil ]</body><body package="PetitParser">name: aString	self propertyAt: #name put: aString</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>initialization</category><body package="PetitParser">initialize</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>testing</category><body package="PetitParser">isPetitParser	^ true</body><body package="PetitParser">isUnresolved	^ false</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>printing</category><body package="PetitParser">printNameOn: aStream	self name isNil		ifTrue: [ aStream print: self hash ]		ifFalse: [ aStream nextPutAll: self name ]</body><body package="PetitParser">printOn: aStream	| title |	title := self class printString.	aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).      aStream nextPutAll: title.	aStream nextPut: $(.	self printNameOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>copying</category><body package="PetitParser">postCopy	super postCopy.	properties := properties copy</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>operators</category><body package="PetitParser">, aParser 	"Answer a new parser that parses the receiver followed by aParser."	^ PPSequenceParser with: self with: aParser</body><body package="PetitParser">/ aParser 	"Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice)."		^ PPChoiceParser with: self with: aParser</body><body package="PetitParser">and	"Answer a new parser (logical and-predicate) that succeeds whenever the receiver does, but never consumes input."	^ PPAndParser on: self</body><body package="PetitParser">def: aParser	"Redefine the receiver as the argument aParser. This method is useful when defining recursive parsers: instantiate a PPUnresolvedParser and later redefine it with another one."	^ self becomeForward: (aParser name: self name)</body><body package="PetitParser">end	"Answer a new parser that succeeds at the end of the input and return the result of the receiver."	^ PPEndOfInputParser on: self</body><body package="PetitParser">memoized	"Answer a new memoized parser, for refraining redundant computations. This ensures polynomial time O(n^4) for left-recursive grammars and O(n^3) for non left-recursive grammars in the worst case. Not necessary for most grammars that are carefully written and in O(n) anyway."		^ PPMemoizedParser on: self</body><body package="PetitParser">negate	"Answer a new parser consumes any input token but the receiver."		^ self not , #any asParser ==&gt; #second</body><body package="PetitParser">not	"Answer a new parser (logical not-predicate) that succeeds whenever the receiver fails, but never consumes input."	^ PPNotParser on: self</body><body package="PetitParser">optional	"Answer a new parser that parses the receiver, if possible."	^ PPOptionalParser on: self</body><body package="PetitParser">wrapped	"Answer a new parser that is simply wrapped."		^ PPDelegateParser on: self</body><body package="PetitParser">| aParser	"Answer a new parser that either parses the receiver or aParser. Fail if both pass or fail (exclusive choice, unordered choice)."	^ (self not , aParser) / (aParser not , self) ==&gt; #second</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>operators-mapping</category><body package="PetitParser">==&gt; aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PPActionParser on: self block: aBlock</body><body package="PetitParser">&gt;=&gt; aBlock	"Answer a new parser that wraps the receiving parser with a two argument block. The first argument is the parsed stream, the second argument a continuation block on the delegate parser."	^ PPWrappingParser on: self block: aBlock</body><body package="PetitParser">answer: anObject	"Answer a new parser that always returns anObject from a successful parse."	^ self ==&gt; [ :nodes | anObject ]</body><body package="PetitParser">flatten	"Answer a new parser that flattens the underlying collection."		^ PPFlattenParser on: self</body><body package="PetitParser">foldLeft: aBlock	"Answer a new parser that that folds the result of the receiver from left-to-right into aBlock. The argument aBlock must take two or more arguments."		| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==&gt; [ :nodes |		args at: 1 put: nodes first.		2 to: nodes size by: size - 1 do: [ :index |			args				replaceFrom: 2 to: size with: nodes startingAt: index;				at: 1 put: (aBlock valueWithArguments: args) ].		args first ]</body><body package="PetitParser">foldRight: aBlock	"Answer a new parser that that folds the result of the receiver from right-to-left into aBlock. The argument aBlock must take two or more arguments."	| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==&gt; [ :nodes |		args at: size put: nodes last.		nodes size - size + 1 to: 1 by: 1 - size do: [ :index |			args				replaceFrom: 1 to: size - 1 with: nodes startingAt: index;				at: size put: (aBlock valueWithArguments: args) ].		args at: size ]</body><body package="PetitParser">map: aBlock	"Answer a new parser that works on the receiving sequence an passes in each element as a block argument."		^ aBlock numArgs = 1		ifTrue: [ self ==&gt; aBlock ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]</body><body package="PetitParser">token	"Answer a new parser that transforms the input to a token."		^ PPTokenParser on: self</body><body package="PetitParser">token: aTokenClass	"Answer a new parser that transforms the input to a token of class aTokenClass."		^ self token tokenClass: aTokenClass</body><body package="PetitParser">trim	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpaces</body><body package="PetitParser">trim: aParser	"Answer a new parser that consumes and ignores aParser repeatedly before and after the receiving parser."		^ PPTrimmingParser on: self trimmer: aParser</body><body package="PetitParser">trimBlanks	"Answer a new parser that consumes blanks before and after the receiving parser."		^ self trim: #blank asParser</body><body package="PetitParser">trimSpaces	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trim: #space asParser</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>operators-repeating</category><body package="PetitParser">max: anInteger	"Answer a new parser that parses the receiver at most anInteger times."		^ self star setMax: anInteger</body><body package="PetitParser">max: anInteger greedy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMax: anInteger</body><body package="PetitParser">max: anInteger lazy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMax: anInteger</body><body package="PetitParser">min: anInteger	"Answer a new parser that parses the receiver at least anInteger times."		^ self star setMin: anInteger</body><body package="PetitParser">min: anInteger greedy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: anInteger</body><body package="PetitParser">min: anInteger lazy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: anInteger</body><body package="PetitParser">min: aMinInteger max: aMaxInteger	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times."		^ self star setMin: aMinInteger; setMax: aMaxInteger</body><body package="PetitParser">min: aMinInteger max: aMaxInteger greedy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: aMinInteger; setMax: aMaxInteger</body><body package="PetitParser">min: aMinInteger max: aMaxInteger lazy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: aMinInteger; setMax: aMaxInteger</body><body package="PetitParser">plus	"Answer a new parser that parses the receiver one or more times."	^ self star setMin: 1</body><body package="PetitParser">plusGreedy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ (self starGreedy: aParser) setMin: 1</body><body package="PetitParser">plusLazy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ (self starLazy: aParser) setMin: 1</body><body package="PetitParser">star	"Answer a new parser that parses the receiver zero or more times. This is a greedy and blind implementation that tries to consume as much input as possible and it does not consider what comes afterwards."	^ PPPossessiveRepeatingParser on: self</body><body package="PetitParser">starGreedy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ PPGreedyRepeatingParser on: self limit: aParser</body><body package="PetitParser">starLazy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ PPLazyRepeatingParser on: self limit: aParser</body><body package="PetitParser">times: anInteger	"Answer a new parser that parses the receiver exactly anInteger times."		^ self min: anInteger max: anInteger</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>operators-convenience</category><body package="PetitParser">delimitedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated and possibly ended by aParser."		^ (self separatedBy: aParser) , (aParser optional) ==&gt; [ :node |		node second isNil			ifTrue: [ node first ]			ifFalse: [ node first copyWith: node second ] ]</body><body package="PetitParser">separatedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated by aParser."		^ (PPSequenceParser with: self with: (PPSequenceParser with: aParser with: self) star) ==&gt; [ :nodes |		| result |		result := Array new: 2 * nodes second size + 1.		result at: 1 put: nodes first.		nodes second 			keysAndValuesDo: [ :index :pair | result replaceFrom: 2 * index to: 2 * index + 1 with: pair startingAt: 1 ].		result ]</body><body package="PetitParser">withoutSeparators	"Filters out the separators from a parse result produced by one of the productions #delimitedBy: or #separatedBy:."		^ self ==&gt; [ :items |		| result |		result := Array new: items size + 1 // 2.		1 to: result size do: [ :index | result at: index put: (items at: 2 * index - 1) ].		result ]</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>converting</category><body package="PetitParser">asParser	"Answer the receiving parser."		^ self</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>*petitanalyzer-matching</category><body package="PetitAnalyzer">copyInContext: aDictionary	^ self copyInContext: aDictionary seen: IdentityDictionary new</body><body package="PetitAnalyzer">copyInContext: aDictionary seen: aSeenDictionary	| copy |	aSeenDictionary 		at: self 		ifPresent: [ :value | ^ value ].	copy := aSeenDictionary		at: self		put: self copy.	copy children do: [ :each |		copy			replace: each			with: (each copyInContext: aDictionary seen: aSeenDictionary) ].	^ copy</body><body package="PetitAnalyzer">match: aParser inContext: aDictionary	^ self match: aParser inContext: aDictionary seen: IdentitySet new</body><body package="PetitAnalyzer">match: aParser inContext: aDictionary seen: anIdentitySet	"This is the default implementation to match two parsers. This code can properly handle recursion. This is code is supposed to be overridden in subclasses that add new state."	(self == aParser or: [ anIdentitySet includes: self ])		ifTrue: [ ^ true ].	anIdentitySet add: self.	^ self class = aParser class and: [ self matchList: self children against: aParser children inContext: aDictionary seen: anIdentitySet ]</body><body package="PetitAnalyzer">matchList: matchList against: parserList inContext: aDictionary seen: aSet	^ self matchList: matchList index: 1 against: parserList index: 1 inContext: aDictionary seen: aSet</body><body package="PetitAnalyzer">matchList: matchList index: matchIndex against: parserList index: parserIndex inContext: aDictionary seen: aSet	| parser currentIndex currentDictionary currentSeen parsers |	matchList size &lt; matchIndex		ifTrue: [ ^ parserList size &lt; parserIndex ].	parser := matchList at: matchIndex.	parser class = PPListPattern ifTrue: [		currentIndex := parserIndex - 1.		[ currentDictionary := aDictionary copy.		currentSeen := aSet copy.		parserList size &lt; currentIndex or: [ 			parsers := parserList copyFrom: parserIndex to: currentIndex.			(currentDictionary at: parser ifAbsentPut: [ parsers ]) = parsers and: [ 				(self					matchList: matchList					index: matchIndex + 1					against: parserList					index: currentIndex + 1					inContext: currentDictionary					seen: currentSeen)					ifTrue: [ 						currentDictionary keysAndValuesDo: [ :key :value | aDictionary at: key put: value ].						^ true ].				false ] ] ] whileFalse: [ currentIndex := currentIndex + 1 ].		^ false ].	parserList size &lt; parserIndex		ifTrue: [ ^ false ].	(parser match: (parserList at: parserIndex) inContext: aDictionary seen: aSet)		ifFalse: [ ^ false ].	^ self		matchList: matchList		index: matchIndex + 1		against: parserList		index: parserIndex + 1		inContext: aDictionary		seen: aSet</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>*petitanalyzer-private</category><body package="PetitAnalyzer">cycleSet: aDictionary	"PRIVATE: Answer the children that could be part of a cycle-set with the receiver, subclasses might restrict the number of children returned. aDictionary is pre-calcualted first-sets."	^ self children</body><body package="PetitAnalyzer">cycleSet: aStack firstSets: aDictionary into: aSet	"PRIVATE: Try to find a cycle, where aStack contains the previously visited parsers. The method returns quickly when the receiver is a terminal, terminals cannot be part of a cycle. If aStack already contains the receiver, then we are in a cycle. In this case we don't process the children further and add the nodes to aSet."	| index |	self isTerminal		ifTrue: [ ^ self ].		(index := aStack indexOf: self) &gt; 0		ifTrue: [ ^ aSet addAll: (aStack copyFrom: index to: aStack size) ].	aStack addLast: self.	(self cycleSet: aDictionary)		do: [ :each | each cycleSet: aStack firstSets: aDictionary into: aSet ].	aStack removeLast</body><body package="PetitAnalyzer">firstSets: aFirstDictionary into: aSet	"PRIVATE: Try to add additional elements to the first-set aSet of the receiver, use the incomplete aFirstDictionary."	self children do: [ :parser | aSet addAll: (aFirstDictionary at: parser) ]</body><body package="PetitAnalyzer">followSets: aFollowDictionary firstSets: aFirstDictionary into: aSet	"PRIVATE: Try to add additional elements to the follow-set aSet of the receiver, use the incomplete aFollowDictionary and the complete aFirstDictionary."		self children do: [ :parser | (aFollowDictionary at: parser) addAll: aSet ]</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>*petitanalyzer-testing</category><body package="PetitAnalyzer">isNullable	"Answer true if the receiver is a nullable parser, e.g. it can successfully parse nothing."		^ false</body><body package="PetitAnalyzer">isTerminal	"Answer true if the receiver is a terminal or leaf parser, that means it does not delegate to any other parser."	^ self children isEmpty</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>*petitanalyzer-querying</category><body package="PetitAnalyzer">cycleSet	"Answer a set of all nodes that are within one or more cycles of left-recursion. This is generally not a problem if at least one of the nodes is memoized, but it might make the grammar very inefficient and should be avoided if possible."		| cycles |	cycles := IdentitySet new.	self cycleSet: OrderedCollection new firstSets: self firstSets into: cycles.	^ cycles</body><body package="PetitAnalyzer">firstSet	"Answer the first-set of the receiver. Note, this implementation is inefficient when called on different receivers of the same grammar, instead use #firstSets to calculate the first-sets at once."		^ self firstSets at: self</body><body package="PetitAnalyzer">firstSets	"Answer a dictionary with all the parsers reachable from the receiver as key and their first-set as value. The first-set of a parser is the list of terminal parsers that begin the parser derivable from that parser."		| firstSets |	firstSets := IdentityDictionary new.	self allParsersDo: [ :each |		firstSets at: each put: (each isTerminal			ifTrue: [ IdentitySet with: each ]			ifFalse: [ IdentitySet new ]).		each isNullable			ifTrue: [ (firstSets at: each) add: PPSentinel instance ] ].	[	| changed tally |		changed := false.		firstSets keysAndValuesDo: [ :parser :first |			tally := first size.			parser firstSets: firstSets into: first.			changed := changed or: [ tally ~= first size ] ].		changed ] whileTrue.	^ firstSets</body><body package="PetitAnalyzer">followSet	"Answer the follow-set of the receiver starting at the receiver. Note, this implementation is inefficient when called on different receivers of the same grammar, instead use #followSets to calculate the follow-sets at once."	^ self followSets at: self</body><body package="PetitAnalyzer">followSets	"Answer a dictionary with all the parsers reachable from the receiver as key and their follow-set as value. The follow-set of a parser is the list of terminal parsers that can appear immediately to the right of that parser."		| current previous continue firstSets followSets |	current := previous := 0.	firstSets := self firstSets.	followSets := IdentityDictionary new.	self allParsersDo: [ :each | followSets at: each put: IdentitySet new ].	(followSets at: self) add: PPSentinel instance.	[	followSets keysAndValuesDo: [ :parser :follow |			parser 				followSets: followSets				firstSets: firstSets				into: follow ].		current := followSets			inject: 0			into: [ :result :each | result + each size ].		continue := previous &lt; current.		previous := current.		continue ] whileTrue.	^ followSets</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>*petitanalyzer-enumerating</category><body package="PetitAnalyzer">allParsers	"Answer all the parse nodes of the receiver."	| result |	result := OrderedCollection new.	self allParsersDo: [ :parser | result addLast: parser ].	^ result</body><body package="PetitAnalyzer">allParsersDo: aBlock	"Iterate over all the parse nodes of the receiver."	self allParsersDo: aBlock seen: IdentitySet new</body><body package="PetitAnalyzer">allParsersDo: aBlock seen: aSet	"Iterate over all the parse nodes of the receiver, do not visit and follow the ones contained in aSet."	(aSet includes: self)		ifTrue: [ ^ self ].	aSet add: self.	aBlock value: self.	self children		do: [ :each | each allParsersDo: aBlock seen: aSet ]</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>*petitanalyzer-transforming</category><body package="PetitAnalyzer">replace: aParser with: anotherParser	"Replace the references of the receiver pointing to aParser with anotherParser."</body><body package="PetitAnalyzer">transform: aBlock	"Answer a copy of all parsers reachable from the receiver transformed using aBlock."	| mapping root |	mapping := IdentityDictionary new.	self allParsersDo: [ :each |		mapping			at: each			put: (aBlock value: each copy) ].	root := mapping at: self.	[	| changed |		changed := false.		root allParsersDo: [ :each |			each children do: [ :old |				mapping at: old ifPresent: [ :new |					each replace: old with: new.					changed := true ] ] ].		changed ] whileTrue.	^ root</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>*petitanalyzer-named</category><body package="PetitAnalyzer">allNamedParsers	"Answer all the named parse nodes of the receiver."	| result |	result := OrderedCollection new.	self allNamedParsersDo: [ :parser | result addLast: parser ].	^ result</body><body package="PetitAnalyzer">allNamedParsersDo: aBlock	"Iterate over all the named parse nodes of the receiver."	self allParsersDo: [ :each | 		each name notNil			ifTrue: [ aBlock value: each ] ]</body><body package="PetitAnalyzer">innerChildren	"Answer the inner children of the receiver."	| result |	result := OrderedCollection new.	self innerChildrenDo: [ :parser | result addLast: parser ].	^ result</body><body package="PetitAnalyzer">innerChildrenDo: aBlock	"Iterate over the inner children of the receiver."	self innerChildrenDo: aBlock seen: IdentitySet new</body><body package="PetitAnalyzer">innerChildrenDo: aBlock seen: aSet	"Iterate over the inner children of the receiver."		self children do: [ :each |		(aSet includes: each)			ifTrue: [ ^ self ].		aSet add: each.		each name isNil ifTrue: [			aBlock value: each.			each innerChildrenDo: aBlock seen: aSet ] ]</body><body package="PetitAnalyzer">namedChildren	"Answer the named children of the receiver."	| result |	result := OrderedCollection new.	self namedChildrenDo: [ :parser | result addLast: parser ].	^ result</body><body package="PetitAnalyzer">namedChildrenDo: aBlock	"Iterate over the named children of the receiver."	self namedChildrenDo: aBlock seen: IdentitySet new</body><body package="PetitAnalyzer">namedChildrenDo: aBlock seen: aSet	"Iterate over the named children of the receiver."		self children do: [ :each |		(aSet includes: each)			ifTrue: [ ^ self ].		aSet add: each.		each name isNil			ifTrue: [ each namedChildrenDo: aBlock seen: aSet ]			ifFalse: [ aBlock value: each ] ]</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>private</category><body package="PetitParser-Postload">becomeForward: anObject	^ self oneWayBecome: anObject</body></methods><methods><class-id>PetitParser.PPParser class</class-id> <category>instance creation</category><body package="PetitParser">named: aString	^ self new name: aString</body><body package="PetitParser">new	^ self basicNew initialize</body></methods><methods><class-id>PetitParser.PPDelegateParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	^ parser parseOn: aStream</body></methods><methods><class-id>PetitParser.PPDelegateParser</class-id> <category>accessing</category><body package="PetitParser">children	^ Array with: parser</body></methods><methods><class-id>PetitParser.PPDelegateParser</class-id> <category>initialization</category><body package="PetitParser">setParser: aParser	parser := aParser</body></methods><methods><class-id>PetitParser.PPDelegateParser</class-id> <category>*petitanalyzer-transforming</category><body package="PetitAnalyzer">replace: aParser with: anotherParser	super replace: aParser with: anotherParser.	parser == aParser ifTrue: [ parser := anotherParser ]</body></methods><methods><class-id>PetitParser.PPDelegateParser class</class-id> <category>instance creation</category><body package="PetitParser">on: aParser	^ self new setParser: aParser</body></methods><methods><class-id>PetitParser.PPFlattenParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| start element stop |	start := aStream position.	element := parser parseOn: aStream.	element isPetitFailure ifTrue: [		aStream position: start.		^ element ].	stop := aStream position.	^ self create: aStream collection start: start + 1 stop: stop</body></methods><methods><class-id>PetitParser.PPFlattenParser</class-id> <category>private</category><body package="PetitParser">create: aCollection start: aStartInteger stop: aStopInteger	^ aCollection copyFrom: aStartInteger to: aStopInteger</body></methods><methods><class-id>PetitParser.PPAbstractParserTest</class-id> <category>utilities</category><body package="PetitTests">assert: aParser fail: aCollection	^ self assert: aParser fail: aCollection end: 0</body><body package="PetitTests">assert: aParser fail: aCollection end: anInteger	| stream result |	self 		assert: aParser isPetitParser		description: 'Parser invalid'.	stream := aCollection asPetitStream.	result := aParser parse: stream.	self 		assert: result isPetitFailure		description: 'Parser did not fail'.	self		assert: stream position = anInteger		description: 'Parser failed at wrong position'.	^ result</body><body package="PetitTests">assert: aParser parse: aCollection	^ self assert: aParser parse: aCollection to: nil end: aCollection size</body><body package="PetitTests">assert: aParser parse: aCollection end: anInteger	^ self assert: aParser parse: aCollection to: nil end: anInteger</body><body package="PetitTests">assert: aParser parse: aCollection to: anObject	^ self assert: aParser parse: aCollection to: anObject end: aCollection size</body><body package="PetitTests">assert: aParser parse: aParseObject to: aTargetObject end: anInteger	| stream result |	self 		assert: aParser isPetitParser		description: 'Parser invalid'.	stream := aParseObject asPetitStream.	result := aParser parse: stream.	aTargetObject isNil		ifTrue: [ self deny: result isPetitFailure ]		ifFalse: [ self assert: result = aTargetObject ].	self 		assert: stream position = anInteger		description: 'Parser accepted at wrong position'.	^ result</body><body package="PetitTests">assert: aParser parse: aParserObject toToken: from stop: to	| token |	token := PPToken on: aParserObject start: from stop: to.	^ self assert: aParser parse: aParserObject to: token</body><body package="PetitTests">assert: aParser parse: aParserObject toToken: from stop: to end: end	| token |	token := PPToken on: aParserObject start: from stop: to.	^ self assert: aParser parse: aParserObject to: token end: end</body></methods><methods><class-id>PetitParser.PPAbstractParserTest class</class-id> <category>accessing</category><body package="PetitTests">packageNamesUnderTest	^ #('PetitParser' 'PetitTests')</body></methods><methods><class-id>PetitParser.PPAbstractParserTest class</class-id> <category>testing</category><body package="PetitTests">isAbstract	^ self name = #PPAbstractParserTest</body></methods><methods><class-id>PetitParser.PPTokenTest</class-id> <category>testing-copying</category><body package="PetitTests">testCopyFromTo	| result other |	result := PPToken on: 'abc'.	other := result copyFrom: 2 to: 2.		self assert: other size = 1.	self assert: other start = 2.	self assert: other stop = 2.	self assert: other collection = result collection</body></methods><methods><class-id>PetitParser.PPTokenTest</class-id> <category>testing</category><body package="PetitTests">testCollection	| input result |	input := 'foo    '.	result := self 		parse: input		using: self identifier.	self assert: (result collection = input).	self assert: (result collection == input)</body><body package="PetitTests">testNew	self should: [ PPToken new ] raise: Error.</body><body package="PetitTests">testPrinting	| result |	result := PPToken on: 'var'.	self assert: (result printString includesSubString: 'PPToken(var)')</body><body package="PetitTests">testSize	| result |	result := self 		parse: 'foo'		using: self identifier.	self assert: result size = 3</body><body package="PetitTests">testStart	| result |	result := self 		parse: 'foo'		using: self identifier.	self assert: result start = 1</body><body package="PetitTests">testStop	| result |	result := self 		parse: 'foo'		using: self identifier.	self assert: result stop = 3</body><body package="PetitTests">testValue	| input result |	input := 'foo'.	result := self 		parse: input		using: self identifier.	self assert: result value = input.	self deny: result value == input</body></methods><methods><class-id>PetitParser.PPTokenTest</class-id> <category>testing-comparing</category><body package="PetitTests">testEquality	| token1 token2 |	token1 := self  parse: 'foo' using: self identifier.	token2 := self  parse: 'foo' using: self identifier.	self deny: token1 == token2.	self assert: token1 = token2.	self assert: token1 hash = token2 hash.</body></methods><methods><class-id>PetitParser.PPTokenTest</class-id> <category>testing-querying</category><body package="PetitTests">testColumn	| input parser result |	input := '1' , (String with: Character cr) , '12' , (String with: Character cr with: Character lf) , '123' , (String with: Character lf) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result 		with:  #(1 2 1 2 3 4 1 2 3 4 1 2 3 4)		do: [ :token :line | self assert: token column = line ]</body><body package="PetitTests">testLine	| input parser result |	input := '1' , (String with: Character cr) , '12' , (String with: Character cr with: Character lf) , '123' , (String with: Character lf) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result 		with: #(1 1 2 2 2 2 3 3 3 3 4 4 4 4) 		do: [ :token :line | self assert: token line = line ]</body></methods><methods><class-id>PetitParser.PPTokenTest</class-id> <category>utilities</category><body package="PetitTests">parse: aString using: aParser	^ aParser parse: aString</body></methods><methods><class-id>PetitParser.PPTokenTest</class-id> <category>accessing</category><body package="PetitTests">identifier	^ #word asParser plus token</body></methods><methods><class-id>PetitParser.PPFailingParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	^ PPFailure message: message at: aStream position</body></methods><methods><class-id>PetitParser.PPFailingParser</class-id> <category>printing</category><body package="PetitParser">printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: message</body></methods><methods><class-id>PetitParser.PPFailingParser</class-id> <category>initialization</category><body package="PetitParser">setMessage: aString	message := aString</body></methods><methods><class-id>PetitParser.PPFailingParser</class-id> <category>accessing</category><body package="PetitParser">message	"Answer the error message of the receiving parser."	^ message</body></methods><methods><class-id>PetitParser.PPFailingParser</class-id> <category>*petitanalyzer-matching</category><body package="PetitAnalyzer">match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self message = aParser message ]</body></methods><methods><class-id>PetitParser.PPFailingParser class</class-id> <category>instance creation</category><body package="PetitParser">message: aString	^ self new setMessage: aString</body></methods><methods><class-id>PetitParser.PPTrimmingParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| position element |	position := aStream position.	[ (trimmer parseOn: aStream) isPetitFailure ]		whileFalse.	element := parser parseOn: aStream.	element isPetitFailure ifTrue: [		aStream position: position.		^ element ].	[ (trimmer parseOn: aStream) isPetitFailure ]		whileFalse.	^ element</body></methods><methods><class-id>PetitParser.PPTrimmingParser</class-id> <category>initialization</category><body package="PetitParser">setTrimmer: aParser	trimmer := aParser</body></methods><methods><class-id>PetitParser.PPTrimmingParser class</class-id> <category>instance creation</category><body package="PetitParser">on: aParser trimmer: aTrimParser	^ self new		setParser: aParser;		setTrimmer: aTrimParser;		yourself</body></methods><methods><class-id>PetitParser.PPStream</class-id> <category>accessing</category><body package="PetitParser">collection	"Answer the underlying collection."		^ collection</body><body package="PetitParser-Postload">next: anInteger	^ super next: (readLimit - position min: anInteger)</body><body package="PetitParser">peek	"An improved version of peek, that is slightly faster than the built in version."	^ self atEnd ifFalse: [ collection at: position + 1 ]</body><body package="PetitParser">position: anInteger	"The receiver does not check for invalid arguments passed to this method, as it is solely used with valid indexes for backtracking."	position := anInteger</body><body package="PetitParser">uncheckedPeek	"An unchecked version of peek that throws an error if we try to peek over the end of the stream, even faster than #peek."	^ collection at: position + 1</body></methods><methods><class-id>PetitParser.PPStream</class-id> <category>converting</category><body package="PetitParser">asPetitStream	^ self</body></methods><methods><class-id>PetitParser.PPStream</class-id> <category>printing</category><body package="PetitParser">printOn: aStream	collection isString		ifFalse: [ ^ super printOn: aStream ].	aStream		nextPutAll: (collection copyFrom: 1 to: position);		nextPutAll: '·' asIs;		nextPutAll: (collection copyFrom: position + 1 to: readLimit)</body></methods><methods><class-id>PetitParser.PPRewriterTest</class-id> <category>testing</category><body package="PetitAnalyzer">testDuplicationRemoval	| duplicate before between after result |	duplicate := PPPattern any.	before := PPListPattern any.	between := PPListPattern any.	after := PPListPattern any.	rewriter		replace: before / duplicate / between / duplicate / after		with: before / duplicate / between / after.		result := rewriter execute: $a asParser / $a asParser.	self assert: rewriter hasChanged.	self assert: result children size = 1.	self assert: result children first literal = $a.		result := rewriter execute: $b asParser / $a asParser / $a asParser.	self assert: rewriter hasChanged.	self assert: result children size = 2.	self assert: result children first literal = $b.	self assert: result children last literal = $a.		result := rewriter execute: $a asParser / $b asParser / $a asParser.	self assert: rewriter hasChanged.	self assert: result children size = 2.	self assert: result children first literal = $a.	self assert: result children last literal = $b.		result := rewriter execute: $a asParser / $a asParser / $b asParser.	self assert: rewriter hasChanged.	self assert: result children size = 2.	self assert: result children first literal = $a.	self assert: result children last literal = $b</body><body package="PetitAnalyzer">testPatternRemoval	| pattern result |	pattern := PPPattern kind: PPLiteralObjectParser.	rewriter		replace: pattern / pattern		with: pattern.		result := rewriter execute: $a asParser / $a asParser.	self assert: rewriter hasChanged.	self assert: result class = PPLiteralObjectParser.	self assert: result literal = $a.		result := rewriter execute: $a asParser / $a asParser / $a asParser.	self deny: rewriter hasChanged.	self assert: result class = PPChoiceParser.	self assert: result children size = 3</body><body package="PetitAnalyzer">testPatternReplacement	| pattern result |	pattern := PPPattern kind: PPLiteralObjectParser.	rewriter		replace: pattern		with: pattern , pattern.		result := rewriter execute: $a asParser.	self assert: rewriter hasChanged.	self assert: result class = PPSequenceParser.	self assert: result children first literal = $a.	self assert: result children last literal = $a.		result := rewriter execute: #any asParser.	self deny: rewriter hasChanged.	self assert: result class = PPPredicateObjectParser</body><body package="PetitAnalyzer">testReplaceLiteral	| result |	rewriter		replace: $a asParser 		with: $b asParser.		result := rewriter execute: $a asParser.	self assert: rewriter hasChanged.	self assert: result literal = $b.		result := rewriter execute: $c asParser.	self deny: rewriter hasChanged.	self assert: result literal = $c.		result := rewriter execute: $a asParser , $b asParser , $c asParser.	self assert: rewriter hasChanged.	self assert: result children size = 3.	self assert: result children first literal = $b.	self assert: result children last literal = $c</body><body package="PetitAnalyzer">testSwapTwoPattern	| first second result |	first := PPPattern any.	second := PPPattern any.	rewriter		replace: first , second		with: second , first.		result := rewriter execute: $a asParser , $b asParser.	self assert: rewriter hasChanged.	self assert: result children first literal = $b.	self assert: result children last literal = $a.		result := rewriter execute: $a asParser / $b asParser.	self deny: rewriter hasChanged.	self assert: result children first literal = $a.	self assert: result children last literal = $b</body><body package="PetitAnalyzer">testWrapLiteral	| result |	rewriter		replace: $a asParser		withValueFrom: [ :parser | parser token ].		result := rewriter execute: $a asParser.	self assert: rewriter hasChanged.	self assert: result class = PPTokenParser.	self assert: result children first literal = $a.		result := rewriter execute: $c asParser.	self deny: rewriter hasChanged.	self assert: result literal = $c.		result := rewriter execute: $a asParser , $b asParser.	self assert: rewriter hasChanged.	self assert: result children first class = PPTokenParser.	self assert: result children first children first literal = $a.	self assert: result children last class = PPLiteralObjectParser.	self assert: result children last literal = $b</body></methods><methods><class-id>PetitParser.PPRewriterTest</class-id> <category>running</category><body package="PetitAnalyzer">setUp	rewriter := PPRewriter new</body></methods><methods><class-id>PetitParser.PPRepeatingParser</class-id> <category>printing</category><body package="PetitParser">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ['; print: min; nextPutAll: ', '; nextPutAll: (max = SmallInteger maxVal		ifTrue: [ '*' ] ifFalse: [ max printString ]); nextPut: $]</body></methods><methods><class-id>PetitParser.PPRepeatingParser</class-id> <category>accessing</category><body package="PetitParser">max	"Answer the maximum number of repetitions."	^ max</body><body package="PetitParser">min	"Answer the minimum number of repetitions."		^ min</body></methods><methods><class-id>PetitParser.PPRepeatingParser</class-id> <category>initialization</category><body package="PetitParser">initialize	super initialize.	self setMin: 0; setMax: SmallInteger maxVal</body><body package="PetitParser">setMax: anInteger	max := anInteger</body><body package="PetitParser">setMin: anInteger	min := anInteger</body></methods><methods><class-id>PetitParser.PPRepeatingParser</class-id> <category>*petitanalyzer-testing</category><body package="PetitAnalyzer">isNullable	^ min = 0</body></methods><methods><class-id>PetitParser.PPRepeatingParser</class-id> <category>*petitanalyzer-matching</category><body package="PetitAnalyzer">match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self min = aParser min and: [ self max = aParser max ] ]</body></methods><methods><class-id>PetitParser.PPLimitedRepeatingParser</class-id> <category>initialization</category><body package="PetitParser">setLimit: aParser	limit := aParser</body></methods><methods><class-id>PetitParser.PPLimitedRepeatingParser</class-id> <category>private</category><body package="PetitParser">matchesLimitOn: aStream	| element position |	position := aStream position.	element := limit parseOn: aStream.	aStream position: position.	^ element isPetitFailure not</body></methods><methods><class-id>PetitParser.PPLimitedRepeatingParser</class-id> <category>accessing</category><body package="PetitParser">children	^ Array with: parser with: limit</body><body package="PetitParser">limit	"Answer the parser that limits (or ends) this repetition."		^ limit</body></methods><methods><class-id>PetitParser.PPLimitedRepeatingParser</class-id> <category>*petitanalyzer-transforming</category><body package="PetitAnalyzer">replace: aParser with: anotherParser	super replace: aParser with: anotherParser.	limit == aParser ifTrue: [ limit := anotherParser ]</body></methods><methods><class-id>PetitParser.PPLimitedRepeatingParser class</class-id> <category>instance creation</category><body package="PetitParser">on: aParser limit: aLimitParser	^ (self on: aParser) setLimit: aLimitParser</body></methods><methods><class-id>PetitParser.PPAndParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| element position |	position := aStream position.	element := parser parseOn: aStream.	aStream position: position.	^ element</body></methods><methods><class-id>PetitParser.PPAndParser</class-id> <category>operators</category><body package="PetitParser">and	^ self</body></methods><methods><class-id>PetitParser.PPFailure</class-id> <category>accessing</category><body package="PetitParser">message	"Answer a human readable error message of this parse failure."		^ message</body><body package="PetitParser">position	"Answer the position in the source string that caused this parse failure."	^ position</body></methods><methods><class-id>PetitParser.PPFailure</class-id> <category>testing</category><body package="PetitParser">isPetitFailure	"I am the only class that should implement this method to return true."	^ true</body></methods><methods><class-id>PetitParser.PPFailure</class-id> <category>initialization</category><body package="PetitParser">initializeMessage: aString at: anInteger	message := aString.	position := anInteger</body></methods><methods><class-id>PetitParser.PPFailure</class-id> <category>printing</category><body package="PetitParser">printOn: aStream	aStream		nextPutAll: ('&lt;1s&gt; at &lt;2p&gt;' asIs expandMacrosWith: self message with: position)</body></methods><methods><class-id>PetitParser.PPFailure class</class-id> <category>instance creation</category><body package="PetitParser">message: aString at: anInteger	^ self basicNew initializeMessage: aString at: anInteger</body></methods><methods><class-id>PetitParser.PPListParser</class-id> <category>initialization</category><body package="PetitParser">initialize	super initialize.	self setParsers: #()</body><body package="PetitParser">setParsers: aCollection	parsers := aCollection asArray</body></methods><methods><class-id>PetitParser.PPListParser</class-id> <category>copying</category><body package="PetitParser">copyWith: aParser	^ self species withAll: (parsers copyWith: aParser)</body><body package="PetitParser">postCopy	super postCopy.	parsers := parsers copy</body></methods><methods><class-id>PetitParser.PPListParser</class-id> <category>accessing</category><body package="PetitParser">children	^ parsers</body></methods><methods><class-id>PetitParser.PPListParser</class-id> <category>*petitanalyzer-transforming</category><body package="PetitAnalyzer">replace: aParser with: anotherParser	super replace: aParser with: anotherParser.	parsers keysAndValuesDo: [ :index :parser |		parser == aParser			ifTrue: [ parsers at: index put: anotherParser ] ]</body></methods><methods><class-id>PetitParser.PPListParser</class-id> <category>*petitanalyzer-matching</category><body package="PetitAnalyzer">copyInContext: aDictionary seen: aSeenDictionary	| copy copies |	aSeenDictionary at: self ifPresent: [ :value | ^ value ].	copy := aSeenDictionary at: self put: self copy.	copies := OrderedCollection new.	parsers do: [ :each |		| result |		result := each 			copyInContext: aDictionary			seen: aSeenDictionary.		result isCollection			ifTrue: [ copies addAll: result ]			ifFalse: [ copies add: result ] ].	^ copy		setParsers: copies;		yourself</body></methods><methods><class-id>PetitParser.PPListParser class</class-id> <category>instance creation</category><body package="PetitParser">with: aParser	^ self withAll: (Array with: aParser)</body><body package="PetitParser">with: aFirstParser with: aSecondParser	^ self withAll: (Array with: aFirstParser with: aSecondParser)</body><body package="PetitParser">withAll: aCollection	^ self basicNew setParsers: aCollection</body></methods><methods><class-id>PetitParser.PPChoiceParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."	| element |	1 to: parsers size do: [ :index |		element := (parsers at: index)			parseOn: aStream.		element isPetitFailure			ifFalse: [ ^ element ] ].	^ element</body></methods><methods><class-id>PetitParser.PPChoiceParser</class-id> <category>operators</category><body package="PetitParser">/ aRule 	^ self copyWith: aRule</body></methods><methods><class-id>PetitParser.PPAnalyzerTest</class-id> <category>utilities</category><body package="PetitAnalyzer">assert: aCollection includes: aString epsilon: aBoolean	| parsers checker stream |	parsers := aCollection		collect: [ :each | each end ].	checker := [ :string |		parsers anySatisfy: [ :parser |			(parser parse: string asPetitStream)				isPetitFailure not ] ].	stream := WriteStream on: String new.	32 to: 127 do: [ :index |		(checker value: (String with: (Character value: index)))			ifTrue: [ stream nextPut: (Character value: index) ] ].	self		assert: stream contents = aString		description: 'Expected ' , aString printString , ', but got ' , stream contents printString.	self		assert: (checker value: '') = aBoolean		description: 'Expected epsilon to ' , (aBoolean ifTrue: [ 'be' ] ifFalse: [ 'not be' ]) , '  included'</body></methods><methods><class-id>PetitParser.PPAnalyzerTest</class-id> <category>testing-cycleset</category><body package="PetitAnalyzer">testCycleSetGrammarA	self grammarA do: [ :each | self assert: each cycleSet isEmpty ]</body><body package="PetitAnalyzer">testCycleSetGrammarB	self grammarB do: [ :each | self assert: each cycleSet isEmpty ]</body><body package="PetitAnalyzer">testCycleSetGrammarC	| grammar cycleSet |	grammar := self grammarC.	cycleSet := grammar cycleSet.	self assert: (cycleSet size = 2).	self assert: (cycleSet includes: grammar)</body><body package="PetitAnalyzer">testCycleSetGrammarD	| grammar cycleSet |	grammar := self grammarD.		cycleSet := (grammar at: #S) cycleSet.	self assert: (cycleSet size = 4).	self assert: (cycleSet includes: (grammar at: #A)).	self assert: (cycleSet includes: (grammar at: #S)).		cycleSet := (grammar at: #A) cycleSet.	self assert: (cycleSet size = 4).	self assert: (cycleSet includes: (grammar at: #A)).	self assert: (cycleSet includes: (grammar at: #S)).	cycleSet := (grammar at: #B) cycleSet.	self assert: (cycleSet size = 2).	self assert: (cycleSet includes: (grammar at: #B))</body><body package="PetitAnalyzer">testCycleSetGrammarE	| grammar cycleSet |	grammar := self grammarE.	cycleSet := grammar cycleSet.	self assert: (cycleSet size = 1).	self assert: (cycleSet includes: grammar)</body><body package="PetitAnalyzer">testCycleSetInChoice	| parser cycleSet |	parser := PPUnresolvedParser new.	parser def: parser / $a asParser.	cycleSet := parser cycleSet.	self assert: (cycleSet size = 1).	self assert: (cycleSet includes: parser).		parser := PPUnresolvedParser new.	parser def: $a asParser / parser.	cycleSet := parser cycleSet.	self assert: (cycleSet size = 1).	self assert: (cycleSet includes: parser).</body><body package="PetitAnalyzer">testCycleSetInSequence	| parser cycleSet |	parser := PPUnresolvedParser new.	parser def: parser , $a asParser.	cycleSet := parser cycleSet.	self assert: (cycleSet size = 1).	self assert: (cycleSet includes: parser).		parser := PPUnresolvedParser new.	parser def: nil asParser , parser.	cycleSet := parser cycleSet.	self assert: (cycleSet size = 1).	self assert: (cycleSet includes: parser).		parser := PPUnresolvedParser new.	parser def: $a asParser , parser.	cycleSet := parser cycleSet.	self assert: cycleSet isEmpty</body></methods><methods><class-id>PetitParser.PPAnalyzerTest</class-id> <category>testing-followset</category><body package="PetitAnalyzer">testFollowSetExampleA	| grammar followSets |	grammar := self grammarA.	followSets := (grammar at: #S) followSets.	self assert: (followSets at: (grammar at: #a)) includes: 'bc' epsilon: false.	self assert: (followSets at: (grammar at: #b)) includes: 'bc' epsilon: false.	self assert: (followSets at: (grammar at: #c)) includes: 'd' epsilon: false.	self assert: (followSets at: (grammar at: #d)) includes: '' epsilon: true.	self assert: (followSets at: (grammar at: #e)) includes: 'bc' epsilon: false.	self assert: (followSets at: (grammar at: #S)) includes: '' epsilon: true.	self assert: (followSets at: (grammar at: #A)) includes: 'bc' epsilon: false.	self assert: (followSets at: (grammar at: #B)) includes: 'bc' epsilon: false</body><body package="PetitAnalyzer">testFollowSetExampleB	| grammar followSets |	grammar := self grammarB.	followSets := (grammar at: #E) followSets.	self assert: (followSets at: (grammar at: #E)) includes: ')' epsilon: true.	self assert: (followSets at: (grammar at: #Ep)) includes: ')' epsilon: true.	self assert: (followSets at: (grammar at: #T)) includes: ')+' epsilon: true.	self assert: (followSets at: (grammar at: #Tp)) includes: ')+' epsilon: true.	self assert: (followSets at: (grammar at: #F)) includes: ')*+' epsilon: true</body><body package="PetitAnalyzer">testFollowSetExampleC	self assert: self grammarC followSet includes: '+' epsilon: true</body><body package="PetitAnalyzer">testFollowSetExampleD	| grammar followSets |	grammar := self grammarD.	followSets := (grammar at: #S) followSets.	self assert: (followSets at: (grammar at: #S)) includes: 'a' epsilon: true.	self assert: (followSets at: (grammar at: #A)) includes: 'ab' epsilon: true.	self assert: (followSets at: (grammar at: #B)) includes: 'ab' epsilon: true.	self assert: (followSets at: (grammar at: #a)) includes: 'ab' epsilon: true.	self assert: (followSets at: (grammar at: #b)) includes: 'ab' epsilon: true</body><body package="PetitAnalyzer">testFollowSetExampleE	self assert: self grammarE followSet includes: '' epsilon: true</body></methods><methods><class-id>PetitParser.PPAnalyzerTest</class-id> <category>testing-firstset</category><body package="PetitAnalyzer">testFirstSetExpression	| grammar |	grammar := PPArithmeticParser new.	self assert: grammar start firstSet includes: '(-0123456789' epsilon: false.	self assert: grammar addition firstSet includes: '(-0123456789' epsilon: false.	self assert: grammar factors firstSet includes:  '(-0123456789' epsilon: false.	self assert: grammar multiplication firstSet includes:  '(-0123456789' epsilon: false.	self assert: grammar number firstSet includes: '-0123456789' epsilon: false.	self assert: grammar parentheses firstSet includes: '(' epsilon: false.	self assert: grammar power firstSet includes: '(-0123456789' epsilon: false.	self assert: grammar primary firstSet includes: '(-0123456789' epsilon: false.	self assert: grammar terms firstSet includes: '(-0123456789' epsilon: false</body><body package="PetitAnalyzer">testFirstSetGrammarA	| grammar |	grammar := self grammarA.	self assert: (grammar at: #a) firstSet includes: 'a' epsilon: false.	self assert: (grammar at: #b) firstSet includes: 'b' epsilon: false.	self assert: (grammar at: #c) firstSet includes: 'c' epsilon: false.	self assert: (grammar at: #d) firstSet includes: 'd' epsilon: false.	self assert: (grammar at: #e) firstSet includes: '' epsilon: true.	self assert: (grammar at: #S) firstSet includes: 'abc' epsilon: false.	self assert: (grammar at: #A) firstSet includes: 'ab' epsilon: true.	self assert: (grammar at: #B) firstSet includes: 'b' epsilon: true</body><body package="PetitAnalyzer">testFirstSetGrammarB	| grammar |	grammar := self grammarB.	self assert: (grammar at: #E) firstSet includes: '(i' epsilon: false.	self assert: (grammar at: #Ep) firstSet includes: '+' epsilon: true.	self assert: (grammar at: #T) firstSet includes: '(i' epsilon: false.	self assert: (grammar at: #Tp) firstSet includes: '*' epsilon: true.	self assert: (grammar at: #F) firstSet includes: '(i' epsilon: false</body><body package="PetitAnalyzer">testFirstSetGrammarC	| grammar |	grammar := self grammarC.	self assert: grammar firstSet includes: '1' epsilon: false</body><body package="PetitAnalyzer">testFirstSetGrammarD	| grammar |	grammar := self grammarD.	self assert: (grammar at: #S) firstSet includes: 'ab' epsilon: false.	self assert: (grammar at: #A) firstSet includes: 'ab' epsilon: false.	self assert: (grammar at: #B) firstSet includes: 'a' epsilon: false.	self assert: (grammar at: #a) firstSet includes: 'a' epsilon: false.	self assert: (grammar at: #b) firstSet includes: 'b' epsilon: false</body><body package="PetitAnalyzer">testFirstSetGrammarE	self assert: self grammarE firstSet includes: '' epsilon: false</body><body package="PetitAnalyzer">testFirstSetLambda	| grammar |	grammar := PPLambdaParser new.	self assert: grammar start firstSet includes: '(ABCDEFGHIJKLMNOPQRSTUVWXYZ\abcdefghijklmnopqrstuvwxyz' epsilon: false.	self assert: grammar abstraction firstSet includes: '\' epsilon: false.	self assert: grammar application firstSet includes: '(' epsilon: false.	self assert: grammar expression firstSet includes: '(ABCDEFGHIJKLMNOPQRSTUVWXYZ\abcdefghijklmnopqrstuvwxyz' epsilon: false.	self assert: grammar variable firstSet includes: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' epsilon: false</body></methods><methods><class-id>PetitParser.PPAnalyzerTest</class-id> <category>testing</category><body package="PetitAnalyzer">testAllNamedParsers	| p1 p2 p3 |	p1 := (#digit asParser name: 'a').	p2 := (#digit asParser name: 'b') star.	p3 := (#digit asParser name: 'c') token end.	self assert: p1 allNamedParsers size = 1.	self assert: p1 allNamedParsers first name = 'a'.	self assert: p2 allNamedParsers size = 1.	self assert: p2 allNamedParsers first name = 'b'.	self assert: p3 allNamedParsers size = 1.	self assert: p3 allNamedParsers first name = 'c'</body><body package="PetitAnalyzer">testAllParsers	| p1 p2 p3 |	p1 := #lowercase asParser.	p2 := p1 ==&gt; #asUppercase.	p3 := PPUnresolvedParser new.	p3 def: p2 / p3.	self assert: p1 allParsers size = 1.	self assert: p2 allParsers size = 2.	self assert: p3 allParsers size = 3</body><body package="PetitAnalyzer">testInnerChildren	| p1 p2 p3 |	p1 := (#digit asParser name: 'a').	p2 := (#digit asParser star name: 'b').	p3 := (#digit asParser name: 'c') token star end.	self assert: p1 innerChildren isEmpty.	self assert: p2 innerChildren size = 1.	self assert: (p2 innerChildren allSatisfy: [ :each | each name isNil ]).	self assert: p3 innerChildren size = 2.	self assert: (p3 innerChildren allSatisfy: [ :each | each name isNil ])</body><body package="PetitAnalyzer">testIsNullable	self assert: $a asParser star isNullable.	self assert: nil asParser isNullable.	self deny: $a asParser plus isNullable.		self deny: PPLiteralSequenceParser new isNullable.	self deny: PPLiteralObjectParser new isNullable.	self deny: PPPredicateParser new isNullable.	self deny: PPChoiceParser new isNullable.	self deny: PPSequenceParser new isNullable.	self deny: PPAndParser new isNullable.	self deny: PPTokenParser new isNullable</body><body package="PetitAnalyzer">testIsTerminal	self assert: PPEpsilonParser new isTerminal.	self assert: PPFailingParser new isTerminal.	self assert: PPPluggableParser new isTerminal.	self assert: PPLiteralObjectParser new isTerminal.	self assert: PPLiteralSequenceParser new isTerminal.	self assert: PPPredicateObjectParser new isTerminal.	self assert: PPPredicateSequenceParser new isTerminal.		self deny: ($a asParser / $b asParser) isTerminal.	self deny: ($a asParser , $b asParser) isTerminal.	self deny: ($a asParser and) isTerminal.	self deny: ($a asParser not) isTerminal</body><body package="PetitAnalyzer">testNamedChildren	| p1 p2 p3 p4 |	p1 := (#digit asParser name: 'a').	p2 := (#digit asParser name: 'b') star.	p3 := (#digit asParser name: 'c') token end.	p4 := ((#digit asParser name: 'c') token name: 'd') end.	self assert: p1 namedChildren isEmpty.	self assert: p2 namedChildren size = 1.	self assert: p2 namedChildren first name = 'b'.	self assert: p3 namedChildren size = 1.	self assert: p3 namedChildren first name = 'c'.	self assert: p4 namedChildren size = 1.	self assert: p4 namedChildren first name = 'd'</body></methods><methods><class-id>PetitParser.PPAnalyzerTest</class-id> <category>testing-transform</category><body package="PetitAnalyzer">testDelegateReplace	| one other delegate |	one := $a asParser.	other := $b asParser.	delegate := one token.	self assert: delegate children first == one.	self deny: delegate children first == other.		delegate replace: other with: one.	self assert: delegate children first == one.	self deny: delegate children first == other.		delegate replace: one with: other.	self deny: delegate children first == one.	self assert: delegate children first == other</body><body package="PetitAnalyzer">testListReplace	| one other another list |	one := $a asParser.	other := $b asParser.	another := $c asParser.	list := one , another , one.	self assert: list children first == one.	self assert: list children second == another.	self assert: list children last == one.		list replace: other with: one.	self assert: list children first == one.	self assert: list children second == another.	self assert: list children last == one.		list replace: one with: other.	self assert: list children first == other.	self assert: list children second == another.	self assert: list children last == other.		list replace: another with: one.	self assert: list children first == other.	self assert: list children second == one.	self assert: list children last == other</body><body package="PetitAnalyzer">testRepetitionReplace	| one two otherone othertwo repetition |	one := $a asParser.	two := $b asParser.	otherone := $1 asParser.	othertwo := $2 asParser.		repetition := one starLazy: two.	self assert: repetition children first == one.	self assert: repetition children second == two.		repetition replace: one with: otherone.	self assert: repetition children first == otherone.	self assert: repetition children second == two.		repetition replace: two with: othertwo.	self assert: repetition children first == otherone.	self assert: repetition children second == othertwo</body><body package="PetitAnalyzer">testTransformIdentityGrammarC	| orig tran |	orig := self grammarC.	tran := orig transform: [ :each | each ].	self deny: orig == tran.	self deny: orig children first == tran children first.	self deny: orig children first children first == tran children first children first.	self deny: orig children first children last == tran children first children last.	self deny: orig children last == tran children last.		self assert: orig class == PPChoiceParser.	self assert: orig children first class == PPSequenceParser.	self assert: orig children first children first == orig.	self assert: orig children first children last == orig.	self assert: orig children last class == PPLiteralObjectParser.	self assert: tran class == PPChoiceParser.	self assert: tran children first class == PPSequenceParser.	self assert: tran children first children first == tran.	self assert: tran children first children last == tran.	self assert: tran children last class == PPLiteralObjectParser</body><body package="PetitAnalyzer">testTransformIdentityGrammarE	| orig tran |	orig := self grammarE.	tran := orig transform: [ :each | each ].	self deny: orig == tran.	self deny: orig children first = tran children first.		self assert: orig class == PPDelegateParser.	self assert: orig children first == orig.		self assert: tran class == PPDelegateParser.	self assert: tran children first == tran</body><body package="PetitAnalyzer">testTransformWrapGrammarC	| orig tran |	orig := self grammarC.	tran := orig transform: [ :each | each memoized ].	self assert: orig class == PPChoiceParser.	self assert: orig children first class == PPSequenceParser.	self assert: orig children first children first == orig.	self assert: orig children first children last == orig.	self assert: orig children last class == PPLiteralObjectParser.		self assert: tran class == PPMemoizedParser.	self assert: tran children first class == PPChoiceParser.	self assert: tran children first children first class == PPMemoizedParser.	self assert: tran children first children first children first class == PPSequenceParser.	self assert: tran children first children first children first children first == tran.	self assert: tran children first children first children first children last == tran.	self assert: tran children first children last class == PPMemoizedParser.	self assert: tran children first children last children first class == PPLiteralObjectParser</body><body package="PetitAnalyzer">testTransformWrapGrammarE	| orig tran |	orig := self grammarE.	tran := orig transform: [ :each | each memoized ].		self assert: orig class == PPDelegateParser.	self assert: orig children first == orig.		self assert: tran class == PPMemoizedParser.	self assert: tran children first class == PPDelegateParser.	self assert: tran children first children first == tran</body></methods><methods><class-id>PetitParser.PPAnalyzerTest</class-id> <category>accessing</category><body package="PetitAnalyzer">grammarA	"Güting, Erwig, Übersetzerbau, Springer (p.63)"	| grammar |	grammar := Dictionary new.		" terminals "	grammar at: #a put: $a asParser.	grammar at: #b put: $b asParser.	grammar at: #c put: $c asParser.	grammar at: #d put: $d asParser.	grammar at: #e put: nil asParser.		" non terminals "	grammar at: #B put: (grammar at: #b) / (grammar at: #e).	grammar at: #A put: (grammar at: #a) / (grammar at: #B).	grammar at: #S put: (grammar at: #A) , (grammar at: #B) , (grammar at: #c) , (grammar at: #d).		^ grammar</body><body package="PetitAnalyzer">grammarB	"The canonical grammar to exercise first- and follow-set calculation, probably originally from the dragon-book."	| grammar |	grammar := Dictionary new.	#(E Ep T Tp F) 		do: [ :each | grammar at: each put: (PPUnresolvedParser named: each) ].			(grammar at: #E)		def: (grammar at: #T) , (grammar at: #Ep).	(grammar at: #Ep)	def: ($+ asParser , (grammar at: #T) , (grammar at: #Ep)) optional.		(grammar at: #T)		def: (grammar at: #F) , (grammar at: #Tp).	(grammar at: #Tp)	def: ($* asParser , (grammar at: #F) , (grammar at: #Tp)) optional.		(grammar at: #F)		def: ($( asParser , (grammar at: #E) , $) asParser) / $i asParser.				#(E Ep T Tp F) 		do: [ :each | (grammar at: each) name: each ].		^ grammar</body><body package="PetitAnalyzer">grammarC	"A highly recrusive grammar."	| grammar |	grammar := PPUnresolvedParser new.	grammar def: (grammar , $+ asParser , grammar) / $1 asParser.	^ grammar</body><body package="PetitAnalyzer">grammarD	"A highly ambiguous grammar from: Saichaitanya Jampana. Exploring the problem of ambiguity in context-free grammars. Master’s thesis, Oklahoma State University, July 2005."	| grammar |	grammar := Dictionary new.	#(S A a B b)			do: [ :each | grammar at: each put: (PPUnresolvedParser named: each) ].		(grammar at: #a)		def: $a asParser.	(grammar at: #b)		def: $b asParser.			(grammar at: #S)		def: (grammar at: #A) , (grammar at: #B) / (grammar at: #a).	(grammar at: #A)		def: (grammar at: #S) , (grammar at: #B) / (grammar at: #b).	(grammar at: #B)		def: (grammar at: #B) , (grammar at: #A) / (grammar at: #a).			^ grammar</body><body package="PetitAnalyzer">grammarE	"The most stupid parser, it just references itself and never consumes anything. All algorithms should survive such an attack."	| parser |	parser := PPDelegateParser new.	parser setParser: parser.	^ parser</body></methods><methods><class-id>PetitParser.PPAnalyzerTest class</class-id> <category>accessing</category><body package="PetitAnalyzer">packageNamesUnderTest	^ #('PetitAnalyzer')</body></methods><methods><class-id>PetitParser.PPTokenParser</class-id> <category>accessing</category><body package="PetitParser">tokenClass	^ tokenClass</body><body package="PetitParser">tokenClass: aTokenClass	tokenClass := aTokenClass</body></methods><methods><class-id>PetitParser.PPTokenParser</class-id> <category>private</category><body package="PetitParser">create: aCollection start: aStartInteger stop: aStopInteger	^ self tokenClass on: aCollection start: aStartInteger stop: aStopInteger</body><body package="PetitParser">defaultTokenClass	^ PPToken</body></methods><methods><class-id>PetitParser.PPTokenParser</class-id> <category>initialization</category><body package="PetitParser">initialize	tokenClass := self defaultTokenClass</body></methods><methods><class-id>PetitParser.PPTokenParser</class-id> <category>*petitanalyzer-matching</category><body package="PetitAnalyzer">match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self tokenClass = aParser tokenClass ]</body></methods><methods><class-id>PetitParser.PPUnresolvedParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	self error: self printString , ' need to be resolved before execution.'</body></methods><methods><class-id>PetitParser.PPUnresolvedParser</class-id> <category>testing</category><body package="PetitParser">isUnresolved	^ true</body></methods><methods><class-id>PetitParser.PPParserResource</class-id> <category>running</category><body package="PetitTests">setUp	super setUp.	parsers := Dictionary new</body></methods><methods><class-id>PetitParser.PPParserResource</class-id> <category>accessing</category><body package="PetitTests">parserAt: aParserClass	"Answer a cached instance of aParserClass."		^ parsers at: aParserClass name ifAbsentPut: [ aParserClass new ]</body></methods><methods><class-id>PetitParser.PPCompositeParser</class-id> <category>accessing</category><body package="PetitParser">start	"Answer the production to start this parser with."		self subclassResponsibility</body></methods><methods><class-id>PetitParser.PPCompositeParser</class-id> <category>querying</category><body package="PetitParser">productionAt: aSymbol	"Answer the production named aSymbol."		^ self productionAt: aSymbol ifAbsent: [ nil ]</body><body package="PetitParser">productionAt: aSymbol ifAbsent: aBlock	"Answer the production named aSymbol, if there is no such production answer the result of evaluating aBlock."		(self class ignoredNames includes: aSymbol asString)		ifTrue: [ ^ aBlock value ].	(self class startSymbol = aSymbol)		ifTrue: [ ^ parser ].	^ self instVarAt: (self class allInstVarNames		indexOf: aSymbol asString		ifAbsent: [ ^ aBlock value ])</body><body package="PetitParser">productionNames	"Answer a dictionary of slot indexes and production names."		| productionNames ignoredNames |	productionNames := Dictionary new.	ignoredNames := self class ignoredNames		collect: [ :each | each asSymbol ].	self class allInstVarNames keysAndValuesDo: [ :key :value |		(ignoredNames includes: value asSymbol)			ifFalse: [ productionNames at: key put: value asSymbol ] ].	^ productionNames</body></methods><methods><class-id>PetitParser.PPCompositeParser</class-id> <category>initialization</category><body package="PetitParser">initializeStartingAt: aSymbol	| productionNames |	self initialize.	productionNames := self productionNames.	parser := PPDelegateParser named: aSymbol.	productionNames keysAndValuesDo: [ :key :value |		self instVarAt: key put: (PPDelegateParser named: value) ].	parser setParser: (self perform: aSymbol).	productionNames keysAndValuesDo: [ :key :value |		(self instVarAt: key) setParser: (self perform: value) ]</body></methods><methods><class-id>PetitParser.PPCompositeParser class</class-id> <category>parsing</category><body package="PetitParser">parse: anObject	^ self parse: anObject startingAt: self startSymbol</body><body package="PetitParser">parse: anObject onError: aBlock	^ self parse: anObject startingAt: self startSymbol onError: aBlock</body><body package="PetitParser">parse: anObject startingAt: aSymbol	^ (self newStartingAt: aSymbol) parse: anObject</body><body package="PetitParser">parse: anObject startingAt: aSymbol onError: aBlock	^ (self newStartingAt: aSymbol) parse: anObject onError: aBlock</body></methods><methods><class-id>PetitParser.PPCompositeParser class</class-id> <category>instance creation</category><body package="PetitParser">new	"Answer a new parser starting at the default start symbol."	^ self newStartingAt: self startSymbol</body><body package="PetitParser">newStartingAt: aSymbol	"Answer a new parser starting at aSymbol."	^ self basicNew initializeStartingAt: aSymbol</body></methods><methods><class-id>PetitParser.PPCompositeParser class</class-id> <category>accessing</category><body package="PetitParser">ignoredNames	"Answer a collection of instance-variables that should not be automatically initialized with productions, but that are used internal to the composite parser."	^ PPCompositeParser allInstVarNames</body><body package="PetitParser">startSymbol	"Answer the method that represents the default start symbol."	^ #start</body></methods><methods><class-id>PetitParser.PPLambdaParser</class-id> <category>productions</category><body package="PetitTests">abstraction	^ $\ asParser token trim , variable , $. asParser token trim , expression ==&gt; [ :node | Array with: node second with: node fourth ]</body><body package="PetitTests">application	^ $( asParser token trim , expression , expression , $) asParser token trim ==&gt; [ :node | Array with: node second with: node third ]</body><body package="PetitTests">expression	^ variable / abstraction / application</body><body package="PetitTests">variable	^ (#letter asParser , #word asParser star) token trim ==&gt; [ :token | token value ]</body></methods><methods><class-id>PetitParser.PPLambdaParser</class-id> <category>accessing</category><body package="PetitTests">start	^ expression end</body></methods><methods><class-id>PetitParser.PPLambdaParser class</class-id> <category>curch-booleans</category><body package="PetitTests">and	^ self parse: '\p.\q.((p q) p)'</body><body package="PetitTests">false	^ self parse: '\x.\y.y'</body><body package="PetitTests">ifthenelse	^ self parse: '\p.p'</body><body package="PetitTests">not	^ self parse: '\p.\a.\b.((p b) a)'</body><body package="PetitTests">or	^ self parse: '\p.\q.((p p) q)'</body><body package="PetitTests">true	^ self parse: '\x.\y.x'</body></methods><methods><class-id>PetitParser.PPExtensionTest</class-id> <category>testing-parser</category><body package="PetitTests">testCharacter	| parser |	parser := $a asParser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'</body><body package="PetitTests">testChoice	| parser |	parser := #(1 2) asChoiceParser.	self assert: parser parse: #(1) to: 1.	self assert: parser parse: #(2) to: 2.	self assert: parser parse: #(1 2) to: 1 end: 1.	self assert: parser parse: #(2 1) to: 2 end: 1.	self assert: parser fail: #().	self assert: parser fail: #(3)</body><body package="PetitTests">testClosure	| parser |	parser := [ :stream | stream upTo: $s ] asParser.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 's' to: ''.	self assert: parser parse: 'as' to: 'a'.	self assert: parser parse: 'aas' to: 'aa'.	self assert: parser parse: 'sa' to: '' end: 1.	self assert: parser parse: 'saa' to: '' end: 1.		parser := [ :stream | stream upTo: $s. PPFailure message: 'stream' at: stream position ] asParser.	self assert: parser fail: ''.	self assert: parser fail: 's'.	self assert: parser fail: 'as'</body><body package="PetitTests">testEpsilon	| parser |	parser := nil asParser.	self assert: parser asParser = parser</body><body package="PetitTests">testParser	| parser |	parser := $a asParser.	self assert: parser asParser = parser</body><body package="PetitTests">testRange	| parser |	parser := $a - $c.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser fail: 'd'</body><body package="PetitTests">testSequence	| parser |	parser := #(1 2) asSequenceParser.	self assert: parser parse: #(1 2) to: #(1 2).	self assert: parser parse: #(1 2 3) to: #(1 2) end: 2.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 1).	self assert: parser fail: #(1 1 2)</body><body package="PetitTests">testString	| parser |	parser := 'ab' asParser.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aba' to: 'ab' end: 2.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser fail: 'a'.	self assert: parser fail: 'ac'</body><body package="PetitTests">testSymbol	| parser |	parser := #any asParser.	self assert: parser parse: 'a'.	self assert: parser fail: ''</body></methods><methods><class-id>PetitParser.PPExtensionTest</class-id> <category>testing-stream</category><body package="PetitTests">testStream	| stream |	stream := 'abc' readStream asPetitStream.	self assert: (stream class = PPStream).	self assert: (stream printString = '·abc').	self assert: (stream peek) = $a.	self assert: (stream uncheckedPeek = $a).	self assert: (stream next) = $a.	self assert: (stream printString = 'a·bc').	self assert: (stream asPetitStream = stream)</body><body package="PetitTests">testText	| stream |	stream := 'abc' asText asPetitStream.	self assert: stream class = PPStream</body></methods><methods><class-id>PetitParser.PPPredicateParser</class-id> <category>printing</category><body package="PetitParser">printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: predicateMessage</body></methods><methods><class-id>PetitParser.PPPredicateParser</class-id> <category>accessing</category><body package="PetitParser">block	"Answer the predicate block of the receiver."		^ predicate</body><body package="PetitParser">message	"Answer the failure message."		^ predicateMessage</body></methods><methods><class-id>PetitParser.PPPredicateParser</class-id> <category>*petitanalyzer-matching</category><body package="PetitAnalyzer">match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self block = aParser block and: [ self message = aParser message ] ]</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser</class-id> <category>initialization</category><body package="PetitParser">initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser</class-id> <category>operators</category><body package="PetitParser">negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage 		negated: predicate message: predicateMessage</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	^ (aStream atEnd not and: [ predicate value: aStream uncheckedPeek ])		ifFalse: [ PPFailure message: predicateMessage at: aStream position ]		ifTrue: [ aStream next ]</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser class</class-id> <category>factory-chars</category><body package="PetitParser">blank	^ self chars: (String with: Character space with: Character tab) message: 'blank expected'</body><body package="PetitParser">char: aCharacter	^ self expect: aCharacter message: (String with: $" with: aCharacter with: $") , ' expected'</body><body package="PetitParser">char: aCharacter message: aString	^ self expect: aCharacter message: aString</body><body package="PetitParser">chars: aCollection message: aString	^ self on: (PPCharSetPredicate on: [ :char | aCollection includes: char ]) message: aString</body><body package="PetitParser">cr	^ self char: Character cr message: 'carriage return expected'</body><body package="PetitParser">digit	^ self on: (PPCharSetPredicate on: [ :char | char isDigit ]) message: 'digit expected'</body><body package="PetitParser">hex	^ self 		on: (PPCharSetPredicate on: [ :char | 			(char between: $0 and: $9) 				or: [ (char between: $a and: $f) 				or: [ (char between: $A and: $F) ] ] ])		message: 'hex digit expected'</body><body package="PetitParser">letter	^ self on: (PPCharSetPredicate on: [ :char | char isLetter ]) message: 'letter expected'</body><body package="PetitParser">lf	^ self char: Character lf</body><body package="PetitParser">lowercase	^ self on: (PPCharSetPredicate on: [ :char | char isLowercase ]) message: 'lowercase letter expected'</body><body package="PetitParser">newline	^ self chars: (String with: Character cr with: Character lf) message: 'newline expected'</body><body package="PetitParser">punctuation	^ self chars: '.,"''?!;:#$%&amp;()*+-/&lt;&gt;=@[]\^_{}|~' message: 'punctuation expected'</body><body package="PetitParser">space	^ self on: (PPCharSetPredicate on: [ :char | char isSeparator ]) message: 'separator expected'</body><body package="PetitParser">tab	^ self char: Character tab message: 'tab expected'</body><body package="PetitParser">uppercase	^ self on: (PPCharSetPredicate on: [ :char | char isUppercase ]) message: 'uppercase letter expected'</body><body package="PetitParser">word	^ self on: (PPCharSetPredicate on: [ :char | char isAlphaNumeric ]) message: 'letter or digit expected'</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser class</class-id> <category>instance creation</category><body package="PetitParser">on: aBlock message: aString	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString</body><body package="PetitParser">on: aBlock message: aString negated: aNegatedBlock message: aNegatedString	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser class</class-id> <category>factory-objects</category><body package="PetitParser">any	^ self		on: [ :each | true ] message: 'input expected'		negated: [ :each | false ] message: 'no input expected'</body><body package="PetitParser">anyExceptAnyOf: aCollection	^ self		on: [ :each | (aCollection includes: each) not ] message: 'any except ' , aCollection printString , ' expected'		negated: [ :each | aCollection includes: each ] message: aCollection printString ,  ' not expected'</body><body package="PetitParser">anyOf: aCollection	^ self		on: [ :each | aCollection includes: each ] message: 'any of ' , aCollection printString , ' expected'		negated: [ :each | (aCollection includes: each) not ] message: 'none of ' , aCollection printString ,  'expected'</body><body package="PetitParser">between: min and: max	^ self		on: [ :each | each &gt;= min and: [ each &lt;= max ] ] message: min printString , '..' , max printString , ' expected'		negated: [ :each | each &lt; min or: [ each &gt; max ] ] message: min printString , '..' , max printString , ' not expected'</body><body package="PetitParser">expect: anObject	^ self expect: anObject message: anObject printString , ' expected'</body><body package="PetitParser">expect: anObject message: aString	^ self 		on: [ :each | each = anObject ] message: aString		negated: [ :each | each ~= anObject ] message: 'no ' , aString</body></methods><methods><class-id>PetitParser.PPExpressionParser</class-id> <category>specifying</category><body package="PetitParser">group: aOneArgumentBlock	"Defines a priority group by evaluating aOneArgumentBlock."		operators := Dictionary new.	parser := [ 		aOneArgumentBlock value: self.	 	self buildOn: parser ]			ensure: [ operators := nil ]</body><body package="PetitParser">left: aParser do: aThreeArgumentBlock	"Define an operator aParser that is left-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:left: parser: aParser do: aThreeArgumentBlock</body><body package="PetitParser">postfix: aParser do: aTwoArgumentBlock	"Define a postfix operator aParser. Evaluate aTwoArgumentBlock with the term and the operator."	self operator: #build:postfix: parser: aParser do: aTwoArgumentBlock</body><body package="PetitParser">prefix: aParser do: aTwoArgumentBlock	"Define a prefix operator aParser. Evaluate aTwoArgumentBlock with the operator and the term."	self operator: #build:prefix: parser: aParser do: aTwoArgumentBlock</body><body package="PetitParser">right: aParser do: aThreeArgumentBlock	"Define an operator aParser that is right-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:right: parser: aParser do: aThreeArgumentBlock</body><body package="PetitParser">term: aParser	"Defines the initial term aParser of the receiver."		parser isNil		ifTrue: [ parser := aParser ]		ifFalse: [ self error: 'Unable to redefine the term.' ]</body></methods><methods><class-id>PetitParser.PPExpressionParser</class-id> <category>private</category><body package="PetitParser">build: aParser left: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldLeft: [ :a :op :b | op first value: a value: op second value: b ]</body><body package="PetitParser">build: aParser postfix: aChoiceParser	^ aParser , aChoiceParser star map: [ :term :ops | ops inject: term into: [ :result :operator | operator first value: result value: operator second ] ]</body><body package="PetitParser">build: aParser prefix: aChoiceParser	^ aChoiceParser star , aParser map: [ :ops :term | ops reversed inject: term into: [ :result :operator | operator first value: operator second value: result ] ]</body><body package="PetitParser">build: aParser right: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldRight: [ :a :op :b | op first value: a value: op second value: b ]</body><body package="PetitParser">buildOn: aParser	^ self buildSelectors inject: aParser into: [ :term :selector |		| list |		list := operators at: selector ifAbsent: [ #() ].		list isEmpty			ifTrue: [ term ]			ifFalse: [				self					perform: selector with: term 					with: (list size = 1						ifTrue: [ list first first ==&gt; [ :operator | Array with: list first second with: operator ] ]						ifFalse: [ 							list								inject: PPChoiceParser new								into: [ :choice :each | choice / (each first ==&gt; [ :operator | Array with: each second with: operator ]) ] ]) ] ]</body><body package="PetitParser">buildSelectors	^ #(build:prefix: build:postfix: build:right: build:left:)</body><body package="PetitParser">operator: aSymbol parser: aParser do: aBlock	parser isNil		ifTrue: [ ^ self error: 'You did not specify a term when creating the receiver.' ].	operators isNil		ifTrue: [ ^ self error: 'Use #group: to define precedence groups in descending order.' ].	(operators at: aSymbol ifAbsentPut: [ OrderedCollection new ])		addLast: (Array with: aParser asParser with: aBlock)</body></methods><methods><class-id>PetitParser.PPRule</class-id> <category>initialization</category><body package="PetitAnalyzer">initialize</body><body package="PetitAnalyzer">setOwner: aGrammarSearcher	owner := aGrammarSearcher</body><body package="PetitAnalyzer">setSearch: aParser	search := aParser</body></methods><methods><class-id>PetitParser.PPRule</class-id> <category>matching</category><body package="PetitAnalyzer">canMatch: aParser 	^ true</body><body package="PetitAnalyzer">foundMatchFor: aParser 	self subclassResponsibility</body><body package="PetitAnalyzer">performOn: aParser	(search match: aParser inContext: owner context)		ifFalse: [ ^ nil ].	(self canMatch: aParser)		ifFalse: [ ^ nil ].	^ self foundMatchFor: aParser</body></methods><methods><class-id>PetitParser.PPRule class</class-id> <category>instance creation</category><body package="PetitAnalyzer">new	^ self basicNew initialize</body><body package="PetitAnalyzer">searchFor: aParser	^ self new setSearch: aParser</body></methods><methods><class-id>PetitParser.PPReplaceRule</class-id> <category>initialization</category><body package="PetitAnalyzer">initialize	super initialize.	verificationBlock := [ :parser | true ]</body><body package="PetitAnalyzer">setVerificationBlock: aBlock	verificationBlock := aBlock</body></methods><methods><class-id>PetitParser.PPReplaceRule</class-id> <category>matching</category><body package="PetitAnalyzer">canMatch: aParser 	^ verificationBlock cull: aParser</body></methods><methods><class-id>PetitParser.PPObjectTest</class-id> <category>testing-fancy</category><body package="PetitTests">testFibonacci	"This parser accepts fibonacci sequences with arbitrary start pairs."		| parser |	parser := ((self integer , self integer) end ==&gt; [ :pair | pair first + pair last ])		/ (self integer , (self integer , self integer) and &gt;=&gt; [ :stream :continuation |			| result |			result := continuation value.			(result isPetitFailure or: [ result first + result last first ~= result last last ])				ifFalse: [ parser parseOn: stream ]				ifTrue: [ PPFailure message: 'invalid fibonacci sequence' at: stream position ] ]).	self assert: parser parse: #(1 1) to: 2.	self assert: parser parse: #(1 1 2) to: 3.	self assert: parser parse: #(1 1 2 3) to: 5.	self assert: parser parse: #(1 1 2 3 5) to: 8.	self assert: parser parse: #(1 1 2 3 5 8) to: 13.	self assert: parser parse: #(1 1 2 3 5 8 13) to: 21.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 2 3 4) end: 2</body></methods><methods><class-id>PetitParser.PPObjectTest</class-id> <category>parsers</category><body package="PetitTests">integer	^ PPPredicateObjectParser		on: [ :each | each isInteger ]		message: 'integer expected'</body><body package="PetitTests">string	^ PPPredicateObjectParser		on: [ :each | each isString ]		message: 'string expected'</body></methods><methods><class-id>PetitParser.PPObjectTest</class-id> <category>testing-operators</category><body package="PetitTests">testChoice	| parser |	parser := self integer / self string.	self assert: parser parse: #(123) to: 123.	self assert: parser parse: #('abc') to: 'abc'</body><body package="PetitTests">testSequence	| parser |	parser := self integer , self string.	self assert: parser parse: #(123 'abc') to: #(123 'abc').	self assert: parser fail: #(123 456).	self assert: parser fail: #('abc' 'def').	self assert: parser fail: #('abc' 123)</body></methods><methods><class-id>PetitParser.PPObjectTest</class-id> <category>testing</category><body package="PetitTests">testInteger	self assert: self integer parse: #(123) to: 123.	self assert: self integer fail: #('abc')</body><body package="PetitTests">testString	self assert: self string parse: #('abc') to: 'abc'.	self assert: self string fail: #(123)</body></methods><methods><class-id>PetitParser.PPCompositeParserTest</class-id> <category>accessing</category><body package="PetitTests">parserClass	self subclassResponsibility</body><body package="PetitTests">parserInstance	^ PPParserResource current parserAt: self parserClass</body><body package="PetitTests">parserInstanceFor: aSymbol	^ aSymbol = #start		ifTrue: [ self parserInstance ]		ifFalse: [			self parserInstance				productionAt: aSymbol 				ifAbsent: [ self error: 'Production ' , self parserClass name , '&gt;&gt;' , aSymbol printString , ' not found.' ] ]</body></methods><methods><class-id>PetitParser.PPCompositeParserTest</class-id> <category>running</category><body package="PetitTests">setUp	super setUp.	parser := self parserInstance</body><body package="PetitTests">tearDown	super tearDown.	parser := result := nil</body></methods><methods><class-id>PetitParser.PPCompositeParserTest</class-id> <category>parsing</category><body package="PetitTests">fail: aString rule: aSymbol 	| production |	production := self parserInstanceFor: aSymbol.	result := production end parse: aString.	self		assert: result isPetitFailure		description: 'Able to parse ' , aString printString.	^ result</body><body package="PetitTests">parse: aString 	^ self parse: aString rule: #start</body><body package="PetitTests">parse: aString rule: aSymbol	| production |	production := self parserInstanceFor: aSymbol.	result := production end parse: aString.	self		deny: result isPetitFailure		description: 'Unable to parse ' , aString printString.	^ result</body></methods><methods><class-id>PetitParser.PPCompositeParserTest</class-id> <category>utilities</category><body package="PetitTests">assert: aCollection is: anObject	self parse: aCollection.	self		assert: result = anObject		description: 'Got: ' , result printString , '; Expected: ' , anObject printString		resumable: true</body></methods><methods><class-id>PetitParser.PPCompositeParserTest class</class-id> <category>testing</category><body package="PetitTests">isAbstract	^ self name = #PPCompositeParserTest</body></methods><methods><class-id>PetitParser.PPCompositeParserTest class</class-id> <category>accessing</category><body package="PetitTests">resources	^ Array with: PPParserResource</body></methods><methods><class-id>PetitParser.PPLambdaParserTest</class-id> <category>accessing</category><body package="PetitTests">parserClass	^ PPLambdaParser</body></methods><methods><class-id>PetitParser.PPLambdaParserTest</class-id> <category>testing-curch</category><body package="PetitTests">testAnd	self assert: self parserClass and = #('p' ('q' (('p' 'q') 'p')))</body><body package="PetitTests">testFalse	self assert: self parserClass false = #('x' ('y' 'y'))</body><body package="PetitTests">testIfThenElse	self assert: self parserClass ifthenelse = #('p' 'p')</body><body package="PetitTests">testNot	self assert: self parserClass not = #('p' ('a' ('b' (('p' 'b') 'a'))))</body><body package="PetitTests">testOr	self assert: self parserClass or = #('p' ('q' (('p' 'p') 'q')))</body><body package="PetitTests">testTrue	self assert: self parserClass true = #('x' ('y' 'x'))</body></methods><methods><class-id>PetitParser.PPLambdaParserTest</class-id> <category>testing</category><body package="PetitTests">testAbstraction	self assert: '\x.y' is: #('x' 'y').	self assert: '\x.\y.z' is: #('x' ('y' 'z'))</body><body package="PetitTests">testApplication	self assert: '(x x)' is: #('x' 'x').	self assert: '(x y)' is: #('x' 'y').	self assert: '((x y) z)' is: #(('x' 'y') 'z').	self assert: '(x (y z))' is: #('x' ('y' 'z'))</body><body package="PetitTests">testVariable	self assert: 'x' is: 'x'.	self assert: 'xy' is: 'xy'.	self assert: 'x12' is: 'x12'</body></methods><methods><class-id>PetitParser.PPLambdaParserTest</class-id> <category>testing-utilities</category><body package="PetitTests">testParseOnError	| beenHere |	result := self parserClass		parse: '\x.y'		onError: [ self fail ].	self assert: result = #('x' 'y').		beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ beenHere := true ].	self assert: beenHere.		beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ :fail | beenHere := true. fail ].	self assert: beenHere.	self assert: (result message includesSubString: '$(').	self assert: (result message includesSubString: 'expected').	self assert: (result position = 0).	beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ :msg :pos | 			self assert: (msg includesSubString: '$(').			self assert: (msg includesSubString: 'expected').			self assert: (pos = 0).			beenHere := true ].	self assert: result.	self assert: beenHere</body><body package="PetitTests">testParseStartingAtOnError	| beenHere |	result := self parserClass		parse: 'x'		startingAt: #variable		onError: [ self fail ].	self assert: result = 'x'.		beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ beenHere := true ].	self assert: beenHere.		beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ :fail | beenHere := true. fail ].	self assert: beenHere.	self assert: result message = 'letter expected'.	self assert: result position = 0.	beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ :msg :pos | 			self assert: msg = 'letter expected'.			self assert: pos = 0.			beenHere := true ].	self assert: beenHere</body><body package="PetitTests">testProductionAt	self assert: (parser productionAt: #foo) isNil.	self assert: (parser productionAt: #foo ifAbsent: [ true ]).		self assert: (parser productionAt: #start) notNil.	self assert: (parser productionAt: #start ifAbsent: [ true ]) notNil.		self assert: (parser productionAt: #variable) notNil.	self assert: (parser productionAt: #variable ifAbsent: [ true ]) notNil</body></methods><methods><class-id>PetitParser.PPSearcherTest</class-id> <category>testing</category><body package="PetitAnalyzer">testAnyPattern	| result |	searcher		matches: PPPattern any		do: [ :parser :answer | answer add: parser; yourself ].	result := searcher		execute: ($a asParser)		initialAnswer: OrderedCollection new.	self assert: result size = 1.		result := searcher		execute: ($a asParser star)		initialAnswer: OrderedCollection new.	self assert: result size = 2.		result := searcher		execute: ($a asParser , $b asParser)		initialAnswer: OrderedCollection new.	self assert: result size = 3</body><body package="PetitAnalyzer">testKindPattern	| result |	searcher 		matches: (PPPattern kind: PPLiteralObjectParser)		do: [ :parser :answer | answer add: parser; yourself ].	result := searcher		execute: ($a asParser)		initialAnswer: OrderedCollection new.	self assert: result size = 1.	self assert: (result allSatisfy: [ :each | each class = PPLiteralObjectParser ]).		result := searcher		execute: (#any asParser)		initialAnswer: OrderedCollection new.	self assert: result isEmpty.		result := searcher		execute: ($a asParser / #any asParser , $b asParser)		initialAnswer: OrderedCollection new.	self assert: result size = 2.	self assert: (result allSatisfy: [ :each | each class = PPLiteralObjectParser ])</body><body package="PetitAnalyzer">testMatchesAny	| result |	searcher		matchesAnyOf: (Array 			with: $a asParser			with: $b asParser)		do: [ :parser :answer | answer add: parser; yourself ].	result := searcher		execute: $a asParser , $b asParser , $c asParser		initialAnswer: OrderedCollection new.		self assert: result size = 2.	self assert: result first literal = $a.	self assert: result last literal = $b</body><body package="PetitAnalyzer">testMultiplePattern	| result |	searcher		matches: $a asParser		do: [ :parser :answer | answer first add: parser. answer ].	searcher		matches: PPPattern any		do: [ :parser :answer | answer second add: parser. answer ].	result := searcher		execute: $a asParser , $a asParser , $b asParser		initialAnswer: (Array 			with: OrderedCollection new 			with: OrderedCollection new).		self assert: result first size = 2.	self assert: result first first literal = $a.	self assert: result first last literal = $a.		self assert: result last size = 2.	self assert: result last first class = PPSequenceParser.	self assert: result last last literal = $b</body><body package="PetitAnalyzer">testNamePattern	| result |	searcher 		matches: (PPPattern name: 'foo')		do: [ :parser :answer | answer add: parser; yourself ].	result := searcher 		execute: ($a asParser)		initialAnswer: OrderedCollection new.	self assert: result isEmpty.		result := searcher		execute: ($a asParser name: 'foo')		initialAnswer: OrderedCollection new.	self assert: result size = 1.	self assert: result first name = 'foo'.		result := searcher		execute: ($a asParser name: 'bar') , ($b asParser name: 'foo')		initialAnswer: OrderedCollection new.	self assert: result size = 1.	self assert: result first name = 'foo'</body><body package="PetitAnalyzer">testNewPattern	self 		should: [ PPPattern new ]		raise: Error</body><body package="PetitAnalyzer">testRecursivePattern	| recursive |	recursive := PPDelegateParser new.	recursive setParser: recursive.	searcher 		matches: recursive 		do: [ :parser :answer | parser ].		self assert: (searcher execute: recursive) = recursive.	self assert: (searcher execute: $a asParser) isNil.	self assert: (searcher execute: $a asParser / $b asParser star) isNil</body><body package="PetitAnalyzer">testRepeatedPattern	| pattern result |	searcher		matches: (pattern := PPPattern any) , pattern		do: [ :parser :answer | answer add: parser; yourself ].	result := searcher		execute: ($a asParser , $b asParser)		initialAnswer: OrderedCollection new.	self assert: result isEmpty.		result := searcher		execute: $a asParser , $a asParser		initialAnswer: OrderedCollection new.	self assert: result size = 1.		result := searcher		execute: ($a asParser , ($a asParser , $b asParser))		initialAnswer: OrderedCollection new.	self assert: result isEmpty.		result := searcher		execute: ($b asParser , ($a asParser , $a asParser))		initialAnswer: OrderedCollection new.	self assert: result size = 1</body></methods><methods><class-id>PetitParser.PPSearcherTest</class-id> <category>testing-copy</category><body package="PetitAnalyzer">testCopyMatchAction	| old new |	old := $a asParser ==&gt; [ :token | $b ].	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchDelegate	| old new |	old := $a asParser token trim.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchEpsilon	| old new |	old := nil asParser.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchFailure	| old new |	old := PPFailingParser message: 'problem'.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchList	| old new |	old := $a asParser , $b asParser , $c asParser.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchLiteral	| old new |	old := $a asParser.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchPluggable	| old new |	old := [ :stream | ] asParser.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchPredicate	| old new |	old := #word asParser.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchRecursiveDelegate	| old new |	old := PPDelegateParser new.	old setParser: old.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchRecursiveList	| old new |	old := PPChoiceParser new.	old setParsers: (Array with: old).	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchRepetition	| old new |	old := #word asParser star.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchRepetitionGreedy	| old new |	old := #word asParser starGreedy: #digit asParser.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchRepetitionLazy	| old new |	old := #word asParser starLazy: #digit asParser.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body><body package="PetitAnalyzer">testCopyMatchRepetitionMinMax	| old new |	old := #word asParser min: 5 max: 10.	new := old copyInContext: Dictionary new.	self assert: (old match: old inContext: Dictionary new).	self assert: (old match: new inContext: Dictionary new).	self deny: (old == new).</body></methods><methods><class-id>PetitParser.PPSearcherTest</class-id> <category>testing-lists</category><body package="PetitAnalyzer">testListInfix	| result |	searcher		matches: PPListPattern any , $a asParser , PPListPattern any		do: [ :parser :answer | true ].		result := searcher		execute: $a asParser , $a asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $a asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $a asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $b asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $a asParser , $a asParser , $a asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $a asParser , $a asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $a asParser , $b asParser , $a asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $a asParser , $a asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $b asParser , $a asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $a asParser , $b asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $a asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $b asParser , $b asParser		initialAnswer: false.	self deny: result</body><body package="PetitAnalyzer">testListPostfix	| result |	searcher		matches: PPListPattern any , $b asParser		do: [ :parser :answer | true ].		result := searcher		execute: $a asParser , $a asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $a asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $a asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $b asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $a asParser , $a asParser , $a asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $b asParser , $a asParser , $a asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $a asParser , $b asParser , $a asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $a asParser , $a asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $b asParser , $a asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $a asParser , $b asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $a asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $b asParser , $b asParser		initialAnswer: false.	self assert: result</body><body package="PetitAnalyzer">testListPrefix	| result |	searcher		matches: $a asParser , PPListPattern any		do: [ :parser :answer | true ].		result := searcher		execute: $a asParser , $a asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $a asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $a asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $b asParser , $b asParser		initialAnswer: false.	self deny: result.				result := searcher		execute: $a asParser , $a asParser , $a asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $a asParser , $a asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $a asParser , $b asParser , $a asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $a asParser , $a asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $b asParser , $a asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $a asParser , $b asParser , $b asParser		initialAnswer: false.	self assert: result.		result := searcher		execute: $b asParser , $a asParser , $b asParser		initialAnswer: false.	self deny: result.		result := searcher		execute: $b asParser , $b asParser , $b asParser		initialAnswer: false.	self deny: result</body></methods><methods><class-id>PetitParser.PPSearcherTest</class-id> <category>running</category><body package="PetitAnalyzer">setUp	searcher := PPSearcher new</body></methods><methods><class-id>PetitParser.PPArithmeticParserTest</class-id> <category>testing-operations</category><body package="PetitTests">testAdd	self assert: '1 + 2' is: 3.	self assert: '2 + 1' is: 3.	self assert: '1 + 2.3' is: 3.3.	self assert: '2.3 + 1' is: 3.3.	self assert: '1 + -2' is: -1.	self assert: '-2 + 1' is: -1</body><body package="PetitTests">testAddMany	self assert: '1' is: 1.	self assert: '1 + 2' is: 3.	self assert: '1 + 2 + 3' is: 6.	self assert: '1 + 2 + 3 + 4' is: 10.	self assert: '1 + 2 + 3 + 4 + 5' is: 15</body><body package="PetitTests">testDiv	self assert: '12 / 3' is: 4.	self assert: '-16 / -4' is: 4</body><body package="PetitTests">testDivMany	self assert: '100 / 2' is: 50.	self assert: '100 / 2 / 2' is: 25.	self assert: '100 / 2 / 2 / 5' is: 5.	self assert: '100 / 2 / 2 / 5 / 5' is: 1</body><body package="PetitTests">testMul	self assert: '2 * 3' is: 6.	self assert: '2 * -4' is: -8</body><body package="PetitTests">testMulMany	self assert: '1 * 2' is: 2.	self assert: '1 * 2 * 3' is: 6.	self assert: '1 * 2 * 3 * 4' is: 24.	self assert: '1 * 2 * 3 * 4 * 5' is: 120</body><body package="PetitTests">testPow	self assert: '2 ^ 3' is: 8.	self assert: '-2 ^ 3' is: -8.	self assert: '-2 ^ -3' is: -0.125</body><body package="PetitTests">testPowMany	self assert: '4 ^ 3' is: 64.	self assert: '4 ^ 3 ^ 2' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1 ^ 0' is: 262144</body><body package="PetitTests">testSub	self assert: '1 - 2' is: -1.	self assert: '1.2 - 1.2' is: 0.	self assert: '1 - -2' is: 3.	self assert: '-1 - -2' is: 1</body><body package="PetitTests">testSubMany	self assert: '1' is: 1.	self assert: '1 - 2' is: -1.	self assert: '1 - 2 - 3' is: -4.	self assert: '1 - 2 - 3 - 4' is: -8.	self assert: '1 - 2 - 3 - 4 - 5' is: -13</body></methods><methods><class-id>PetitParser.PPArithmeticParserTest</class-id> <category>testing</category><body package="PetitTests">testNum	self assert: '0' is: 0.	self assert: '0.0' is: 0.0.	self assert: '1' is: 1.	self assert: '1.2' is: 1.2.	self assert: '34' is: 34.	self assert: '56.78' is: 56.78.	self assert: '-9' is: -9.	self assert: '-9.9' is: -9.9</body></methods><methods><class-id>PetitParser.PPArithmeticParserTest</class-id> <category>testing-expression</category><body package="PetitTests">testBrackets	self assert: '(1)' is: 1.	self assert: '(1 + 2)' is: 3.		self assert: '((1))' is: 1.	self assert: '((1 + 2))' is: 3.	self assert: '2 * (3 + 4)' is: 14.	self assert: '(2 + 3) * 4' is: 20.	self assert: '6 / (2 + 4)' is: 1.	self assert: '(2 + 6) / 2' is: 4</body><body package="PetitTests">testPriority	self assert: '2 * 3 + 4' is: 10.	self assert: '2 + 3 * 4' is: 14.	self assert: '6 / 3 + 4' is: 6.	self assert: '2 + 6 / 2' is: 5</body></methods><methods><class-id>PetitParser.PPArithmeticParserTest</class-id> <category>accessing</category><body package="PetitTests">parserClass	^ PPArithmeticParser</body></methods><methods><class-id>PetitParser.PPExpressionParserTest</class-id> <category>testing</category><body package="PetitTests">testPostfixAdd	self assert: '0++' is: 1.	self assert: '0++++' is: 2.	self assert: '0++++++' is: 3.	self assert: '0+++1' is: 2.	self assert: '0+++++1' is: 3.	self assert: '0+++++++1' is: 4</body><body package="PetitTests">testPostfixSub	self assert: '1--' is: 0.	self assert: '2----' is: 0.	self assert: '3------' is: 0.	self assert: '2---1' is: 0.	self assert: '3-----1' is: 0.	self assert: '4-------1' is: 0.</body><body package="PetitTests">testPrefixNegate	self assert: '1' is: 1.	self assert: '-1' is: -1.	self assert: '--1' is: 1.	self assert: '---1' is: -1</body></methods><methods><class-id>PetitParser.PPExpressionParserTest</class-id> <category>accessing</category><body package="PetitTests">parserInstance	| expression parens number |	expression := PPExpressionParser new.	parens := $( asParser token trim , expression , $) asParser token trim		==&gt; [ :nodes | nodes second ].	number := (#digit asParser plus , ($. asParser , #digit asParser plus) optional) token trim		==&gt; [ :token | token value asNumber ].	expression term: parens / number.	expression		group: [ :g |			g prefix: $- asParser token trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser token trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser token trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser token trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser token trim do: [ :a :op :b | a * b ].			g left: $/ asParser token trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser token trim do: [ :a :op :b | a + b ].			g left: $- asParser token trim do: [ :a :op :b | a - b ] ].	^ expression end</body></methods><methods><class-id>PetitParser.PPExpressionParserTest class</class-id> <category>testing</category><body package="PetitTests">shouldInheritSelectors	^ true</body></methods><methods><class-id>PetitParser.PPParserReplaceRule</class-id> <category>initialization</category><body package="PetitAnalyzer">setReplaceParser: aParser	replaceParser := aParser</body></methods><methods><class-id>PetitParser.PPParserReplaceRule</class-id> <category>matching</category><body package="PetitAnalyzer">foundMatchFor: aParser 	^ replaceParser copyInContext: owner context</body></methods><methods><class-id>PetitParser.PPParserReplaceRule class</class-id> <category>instance creation</category><body package="PetitAnalyzer">searchFor: aSearchParser replaceWith: aReplaceParser when: aVerificationBlock	^ (self searchFor: aSearchParser) 		setReplaceParser: aReplaceParser;		setVerificationBlock: aVerificationBlock;		yourself</body></methods><methods><class-id>PetitParser.PPMemento</class-id> <category>accessing</category><body package="PetitParser">position	^ position</body><body package="PetitParser">position: anInteger	position := anInteger</body><body package="PetitParser">result	^ result</body><body package="PetitParser">result: anObject	result := anObject</body></methods><methods><class-id>PetitParser.PPMemento</class-id> <category>accessing-readonly</category><body package="PetitParser">count	^ count</body></methods><methods><class-id>PetitParser.PPMemento</class-id> <category>actions</category><body package="PetitParser">increment	count := count + 1</body></methods><methods><class-id>PetitParser.PPMemento</class-id> <category>initialization</category><body package="PetitParser">initialize	count := 0</body></methods><methods><class-id>PetitParser.PPMemento class</class-id> <category>instance creation</category><body package="PetitParser">new	^ self basicNew initialize</body></methods><methods><class-id>PetitParser.PPProcessor</class-id> <category>initialization</category><body package="PetitAnalyzer">initialize	super initialize.	searches := OrderedCollection new.	context := Dictionary new</body></methods><methods><class-id>PetitParser.PPProcessor</class-id> <category>private</category><body package="PetitAnalyzer">context	^ context</body><body package="PetitAnalyzer">performRule: aRule on: aParser	context := Dictionary new.	^ aRule performOn: aParser</body><body package="PetitAnalyzer">performRulesOn: aParser	| result |	searches do: [ :rule |		result := self performRule: rule on: aParser.		result notNil ifTrue: [ ^ result ] ].	^ nil</body></methods><methods><class-id>PetitParser.PPProcessor</class-id> <category>rules</category><body package="PetitAnalyzer">addRule: aGrammarRule	searches add: (aGrammarRule setOwner: self)</body></methods><methods><class-id>PetitParser.PPProcessor class</class-id> <category>instance creation</category><body package="PetitAnalyzer">new	^ self basicNew initialize</body></methods><methods><class-id>PetitParser.PPSearcher</class-id> <category>rules</category><body package="PetitAnalyzer">matches: aParser do: anAnswerBlock	"Add a search expression aParser, evaluate anAnswerBlock with the matched node and the previous answer."	self addRule: (PPSearchRule searchFor: aParser thenDo: anAnswerBlock)</body><body package="PetitAnalyzer">matchesAnyOf: aCollectionOfParsers do: anAnswerBlock	"Add a collection of search expressions aCollectionOfParsers, evaluate anAnswerBlock with the matched node and the previous answer."		aCollectionOfParsers		do: [ :each | self matches: each do: anAnswerBlock ]</body></methods><methods><class-id>PetitParser.PPSearcher</class-id> <category>public</category><body package="PetitAnalyzer">execute: aParser	"Perform the search rules of the receiver on aParser. Answer the result of the search."	^ self execute: aParser initialAnswer: nil</body><body package="PetitAnalyzer">execute: aParser initialAnswer: anObject	"Perform the search rules of the receiver on aParser. Inject anObject into the matches and answer the result."	| previous |	previous := context.	answer := anObject.	context := Dictionary new.	aParser allParsersDo: [ :each | 		self performRulesOn: each ].	context := previous.	^ answer</body></methods><methods><class-id>PetitParser.PPSearcher</class-id> <category>initialization</category><body package="PetitAnalyzer">setAnswer: anObject	answer := anObject</body></methods><methods><class-id>PetitParser.PPSearcher</class-id> <category>private</category><body package="PetitAnalyzer">answer	^ answer</body></methods><methods><class-id>PetitParser.PPLazyRepeatingParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| start element elements |	start := aStream position.	elements := OrderedCollection new.	[ elements size &lt; min ] whileTrue: [		(element := parser parseOn: aStream) isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements addLast: element ].	[ self matchesLimitOn: aStream ] whileFalse: [		elements size &lt; max ifFalse: [			aStream position: start.			^ PPFailure message: 'overflow' at: start ].		element := parser parseOn: aStream.		element isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements addLast: element ].	^ elements asArray</body></methods><methods><class-id>PetitParser.PPBlockReplaceRule</class-id> <category>initialization</category><body package="PetitAnalyzer">setReplaceBlock: aBlock	replaceBlock := aBlock</body></methods><methods><class-id>PetitParser.PPBlockReplaceRule</class-id> <category>matching</category><body package="PetitAnalyzer">foundMatchFor: aParser 	^ replaceBlock cull: aParser</body></methods><methods><class-id>PetitParser.PPBlockReplaceRule class</class-id> <category>instance creation</category><body package="PetitAnalyzer">searchFor: aSearchParser replaceWith: aReplaceBlock when: aVerificationBlock	^ (self searchFor: aSearchParser) 		setReplaceBlock: aReplaceBlock;		setVerificationBlock: aVerificationBlock;		yourself</body></methods><methods><class-id>PetitParser.PPLiteralParser</class-id> <category>printing</category><body package="PetitParser">printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: literal</body></methods><methods><class-id>PetitParser.PPLiteralParser</class-id> <category>initialization</category><body package="PetitParser">initializeOn: anObject message: aString	literal := anObject.	message := aString</body></methods><methods><class-id>PetitParser.PPLiteralParser</class-id> <category>accessing</category><body package="PetitParser">literal	"Answer the parsed literal."	^ literal</body><body package="PetitParser">message	"Answer the failure message."		^ message</body></methods><methods><class-id>PetitParser.PPLiteralParser</class-id> <category>operators</category><body package="PetitParser">caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		self subclassResponsibility</body></methods><methods><class-id>PetitParser.PPLiteralParser</class-id> <category>*petitanalyzer-matching</category><body package="PetitAnalyzer">match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self literal = aParser literal and: [ self message = aParser message ] ]</body></methods><methods><class-id>PetitParser.PPLiteralParser class</class-id> <category>instance creation</category><body package="PetitParser">on: anObject	^ self on: anObject message: anObject printString , ' expected'</body><body package="PetitParser">on: anObject message: aString	^ self new initializeOn: anObject message: aString</body></methods><methods><class-id>PetitParser.PPMemoizedParser</class-id> <category>private</category><body package="PetitParser">reset: aStream	stream := aStream.	buffer := Array new: aStream size + 1</body></methods><methods><class-id>PetitParser.PPMemoizedParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| memento |	stream == aStream		ifFalse: [ self reset: aStream ].	memento := (buffer at: stream position + 1)		ifNil: [ buffer at: stream position + 1 put: PPMemento new ].	memento position isNil		ifTrue: [			memento result: (stream size - stream position + 2 &lt; memento count				ifTrue: [ PPFailure message: 'overflow' at: stream position ]				ifFalse: [ memento increment. parser parseOn: stream ]).			memento position: stream position ]		ifFalse: [ stream position: memento position ].	^ memento result</body></methods><methods><class-id>PetitParser.PPMemoizedParser</class-id> <category>operators</category><body package="PetitParser">memoized	"Ther is no point in memoizing more than once."	^ self</body></methods><methods><class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>operators</category><body package="PetitParser">caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateSequenceParser on: [ :value | literal sameAs: value ] message: message size: size</body></methods><methods><class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>initialization</category><body package="PetitParser">initializeOn: anObject message: aString	super initializeOn: anObject message: aString.	size := literal size</body></methods><methods><class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| position result |	position := aStream position.	result := aStream next: size.	literal = result ifTrue: [ ^ result ].	aStream position: position.	^ PPFailure message: message at: aStream position</body></methods><methods><class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>accessing</category><body package="PetitParser">size	"Answer the sequence size of the receiver."	^ size</body></methods><methods><class-id>PetitParser.PPPredicateTest</class-id> <category>testing-chars</category><body package="PetitTests">testBlank	| parser |	parser := #blank asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character space) to: Character space.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: (String with: Character cr)</body><body package="PetitTests">testChar	| parser |	parser := $* asParser.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'</body><body package="PetitTests">testCr	| parser |	parser := #cr asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character cr) to: Character cr</body><body package="PetitTests">testDigit	| parser |	parser := #digit asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: ''.	self assert: parser fail: 'a'</body><body package="PetitTests">testHex	| parser |	parser := #hex asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '5' to: $5.	self assert: parser parse: '9' to: $9.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'D' to: $D.	self assert: parser parse: 'F' to: $F.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'e' to: $e.	self assert: parser parse: 'f' to: $f.	self assert: parser fail: ''.	self assert: parser fail: 'g'</body><body package="PetitTests">testLetter	| parser |	parser := #letter asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: '0'</body><body package="PetitTests">testLf	| parser |	parser := #lf asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character lf) to: Character lf</body><body package="PetitTests">testLowercase	| parser |	parser := #lowercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ''.	self assert: parser fail: 'A'.	self assert: parser fail: '0'</body><body package="PetitTests">testNewline	| parser |	parser := #newline asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character cr) to: Character cr.	self assert: parser parse: (String with: Character lf) to: Character lf.	self assert: parser fail: ' '</body><body package="PetitTests">testPunctuation	| parser |	parser := #punctuation asParser.	self assertCharacterSets: parser.	self assert: parser parse: '.' to: $..	self assert: parser parse: ',' to: $,.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '1'</body><body package="PetitTests">testSpace	| parser |	parser := #space asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser parse: ' ' to: Character space.	self assert: parser fail: ''.	self assert: parser fail: 'a'</body><body package="PetitTests">testTab	| parser |	parser := #tab asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab</body><body package="PetitTests">testUppercase	| parser |	parser := #uppercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '0'</body><body package="PetitTests">testWord	| parser |	parser := #word asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: '0' to: $0.	self assert: parser fail: ''.	self assert: parser fail: '-'</body></methods><methods><class-id>PetitParser.PPPredicateTest</class-id> <category>testing-sequence</category><body package="PetitTests">testSequenceParser	| parser |	parser := PPPredicateSequenceParser 		on: [ :value | value first isUppercase ] 		message: 'uppercase 3 letter words'		size: 3.	self assert: parser size = 3.	self assert: parser parse: 'Abc'.	self assert: parser parse: 'ABc'.	self assert: parser parse: 'ABC'.	self assert: parser fail: 'abc'.	self assert: parser fail: 'aBC'.	self assert: parser fail: 'Ab'.		parser := parser negate.	self assert: parser size = 3.	self assert: parser fail: 'Abc'.	self assert: parser fail: 'ABc'.	self assert: parser fail: 'ABC'.	self assert: parser parse: 'abc'.	self assert: parser parse: 'aBC'.	self assert: parser fail: 'Ab'</body></methods><methods><class-id>PetitParser.PPPredicateTest</class-id> <category>testing-objects</category><body package="PetitTests">testAny	| parser |	parser := #any asParser.	self assertCharacterSets: parser.	self assert: parser parse: ' ' to: $ .	self assert: parser parse: '1' to: $1.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''</body><body package="PetitTests">testAnyExceptAnyOf	| parser |	parser := PPPredicateObjectParser anyExceptAnyOf: #($: $,).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ':'.	self assert: parser fail: ','</body><body package="PetitTests">testAnyOf	| parser |	parser := PPPredicateObjectParser anyOf: #($a $z).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: 'x'</body><body package="PetitTests">testBetweenAnd	| parser |	parser := PPPredicateObjectParser between: $b and: $d.	self assertCharacterSets: parser.	self assert: parser fail: 'a'.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser parse: 'd' to: $d.	self assert: parser fail: 'e'</body><body package="PetitTests">testExpect	| parser |	parser := PPPredicateObjectParser expect: $a.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.	self assert: parser fail: ''</body></methods><methods><class-id>PetitParser.PPPredicateTest</class-id> <category>testing</category><body package="PetitTests">testOnMessage	| block parser |	block := [ :char | char = $* ].	parser := PPPredicateObjectParser on: block message: 'starlet'.	self assert: parser block = block.	self assert: parser message = 'starlet'.		self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'</body></methods><methods><class-id>PetitParser.PPPredicateTest</class-id> <category>utilities</category><body package="PetitTests">assertCharacterSets: aParser	"Assert the character set of aParser does not overlap with the character set with the negated parser, and that they both cover the complete character space."	| positives negatives |	positives := self parsedCharacterSet: aParser.	negatives := self parsedCharacterSet: aParser negate.	self charactersDo: [ :char | 		| positive negative |		positive := positives includes: char.		negative := negatives includes: char.		self 			assert: ((positive and: [ negative not ])				or: [ positive not and: [ negative ] ])			description: char printString , ' should be in exactly one set' ]</body><body package="PetitTests">parsedCharacterSet: aParser	| result |	result := WriteStream on: String new.	self charactersDo: [ :char |		(aParser matches: (String with: char))			ifTrue: [ result nextPut: char ] ].	^ result contents</body></methods><methods><class-id>PetitParser.PPPredicateTest</class-id> <category>private</category><body package="PetitTests">charactersDo: aBlock	1 to: 256 do: [ :index | aBlock value: (Character codePoint: index) ]</body></methods><methods><class-id>PetitParser.PPEpsilonParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	^ nil</body></methods><methods><class-id>PetitParser.PPEpsilonParser</class-id> <category>*petitanalyzer-testing</category><body package="PetitAnalyzer">isNullable	^ true</body></methods><methods><class-id>PetitParser.PPOptionalParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| element |	element := parser parseOn: aStream.	^ element isPetitFailure ifFalse: [ element ]</body></methods><methods><class-id>PetitParser.PPOptionalParser</class-id> <category>*petitanalyzer-testing</category><body package="PetitAnalyzer">isNullable	^ true</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>comparing</category><body package="PetitParser">= anObject	^ self class = anObject class and: [ self value = anObject value ]</body><body package="PetitParser">hash	^ self value hash</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>copying</category><body package="PetitParser">copyFrom: aStartInteger to: aStopInteger	^ self class on: collection start: start + aStartInteger - 1 stop: stop + aStopInteger - 3</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>accessing</category><body package="PetitParser">collection	"Answer the underlying collection of this token."	^ collection</body><body package="PetitParser">size	"Answer the size of this token."	^ stop - start + 1</body><body package="PetitParser">start	"Answer the start position of this token in the underlying collection."	^ start</body><body package="PetitParser">stop	"Answer the stop position of this token in the underlying collection."		^ stop</body><body package="PetitParser">value	"Answer the contents of this token."	^ collection copyFrom: start to: stop</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>initialization</category><body package="PetitParser">initializeOn: aSequenceableCollection start: aStartInteger stop: aStopInteger	collection := aSequenceableCollection.	start := aStartInteger.	stop := aStopInteger</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>querying</category><body package="PetitParser">column	"Answer the column number of this token in the underlying collection."		| position |	position := 0.	(NewLineParser , [ :stream |		start &lt;= stream position			ifTrue: [ ^ start - position ].		position := stream position ] asParser		/ #any asParser) star			parse: collection.	 ^ start - position</body><body package="PetitParser">line	"Answer the line number of this token in the underlying collection."		| line |	line := 1.	(NewLineParser , [ :stream |		start &lt;= stream position			ifTrue: [ ^ line ].		line := line + 1 ] asParser		/ #any asParser) star			parse: collection.	^ line</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>printing</category><body package="PetitParser">printOn: aStream	| title |	title := self class printString.	aStream		nextPutAll: ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).	aStream nextPutAll: title.	aStream		nextPut: $(;		nextPutAll: self value;		nextPut: $)</body></methods><methods><class-id>PetitParser.PPToken class</class-id> <category>instance creation</category><body package="PetitParser">new	self		error: (#TokenCanOnlyBeCreatedUs___ADedicatedConstructor_ &lt;&lt; #petitParser				&gt;&gt; 'Token can only be created using a dedicated constructor.') asString</body><body package="PetitParser">on: aSequenceableCollection	^ self on: aSequenceableCollection start: 1 stop: aSequenceableCollection size</body><body package="PetitParser">on: aSequenceableCollection start: aStartInteger stop: aStopInteger	^ self basicNew 		initializeOn: aSequenceableCollection		start: aStartInteger stop: aStopInteger</body></methods><methods><class-id>PetitParser.PPToken class</class-id> <category>initialization</category><body package="PetitParser">initialize	"Platform independent newline sequence. LF: Unix, CR+LF: Windows, and CR: Apple."	NewLineParser := (Character lf asParser) / (Character cr asParser , Character lf asParser optional)</body></methods><methods><class-id>PetitParser.PPParserTest</class-id> <category>testing-utilities</category><body package="PetitTests">testChildren	| p1 p2 p3 |	p1 := #lowercase asParser.	p2 := p1 ==&gt; #asUppercase.	p3 := PPUnresolvedParser new.	p3 def: p2 / p3.	self assert: p1 children isEmpty.	self assert: p2 children size = 1.	self assert: p3 children size = 2</body><body package="PetitTests">testFailure	| failure |	failure := PPFailure message: 'Error' at: 3.		self assert: failure message = 'Error'.	self assert: failure position = 3.	self assert: failure isPetitFailure.	self deny: 4 isPetitFailure.	self deny: 'foo' isPetitFailure</body><body package="PetitTests">testListConstructor	| p1 p2 p3 |	p1 := PPChoiceParser with: $a asParser.	p2 := PPChoiceParser with: $a asParser with: $b asParser.	p3 := PPChoiceParser withAll: (Array with: $a asParser with: $b asParser with: $c asParser).		self assert: p1 children size = 1.	self assert: p2 children size = 2.	self assert: p3 children size = 3</body><body package="PetitTests">testMatches	| parser |	parser := $a asParser.		self assert: (parser matches: 'a').	self deny: (parser matches: 'b').		self assert: (parser matches: 'a' readStream).	self deny: (parser matches: 'b' readStream)</body><body package="PetitTests">testMatchesIn	| parser result |	parser := $a asParser.		result := parser matchesIn: 'abba'.	self assert: result size = 2.	self assert: result first = $a.	self assert: result last = $a.		result := parser matchesIn: 'baaah'.	self assert: result size = 3.	self assert: result first = $a.	self assert: result last = $a</body><body package="PetitTests">testMatchesInEmpty	"Empty matches should properly advance and match at each position and at the end."	| parser result |	parser := [ :stream | stream position ] asParser.		result := parser matchesIn: '123'.	self assert: result asArray = #(0 1 2 3)</body><body package="PetitTests">testMatchesInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.		result := parser matchesIn: 'a123b'.	self assert: result size = 2.	self assert: result first = #($1 $2).	self assert: result last = #($2 $3)</body><body package="PetitTests">testMatchesSkipIn	| parser result |	parser := $a asParser.		result := parser matchesSkipIn: 'abba'.	self assert: result size = 2.	self assert: result first = $a.	self assert: result last = $a.		result := parser matchesSkipIn: 'baaah'.	self assert: result size = 3.	self assert: result first = $a.	self assert: result last = $a</body><body package="PetitTests">testMatchesSkipInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.		result := parser matchesSkipIn: 'a123b'.	self assert: result size = 1.	self assert: result first = #($1 $2)</body><body package="PetitTests">testMatchingRangesIn	| input parser result |	input := 'a12b3'.	parser := #digit asParser plus.	result := parser matchingRangesIn: input.	result := result collect: [ :each | input copyFrom: each first to: each last ].	self assert: result size = 3.	self assert: result first = '12'.	self assert: result second = '2'.	self assert: result last = '3'</body><body package="PetitTests">testMatchingSkipRangesIn	| input parser result |	input := 'a12b3'.	parser := #digit asParser plus.	result := parser matchingSkipRangesIn: input.	result := result collect: [ :each | input copyFrom: each first to: each last ].	self assert: result size = 2.	self assert: result first = '12'.	self assert: result last = '3'</body><body package="PetitTests">testParse	| parser result |	parser := $a asParser.		self assert: (parser parse: 'a') = $a.	self assert: (result := parser parse: 'b') isPetitFailure.	self assert: (result message includesSubString: '$a').	self assert: (result message includesSubString: 'expected').	self assert: (result position = 0).		self assert: (parser parse: 'a' readStream) = $a.	self assert: (result := parser parse: 'b' readStream) isPetitFailure.	self assert: (result message includesSubString: '$a').	self assert: (result message includesSubString: 'expected').	self assert: (result position = 0)</body><body package="PetitTests">testParseOnError0	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result = $a.	result := parser parse: 'b' onError: [ seen := true ].	self assert: result.	self assert: seen</body><body package="PetitTests">testParseOnError1	| parser result seen |	parser := $a asParser.		result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result = $a.		result := parser parse: 'b' onError: [ :failure | 		self assert: (failure position = 0).		self assert: (failure message includesSubString: '$a').		self assert: (failure message includesSubString: 'expected').		seen := true ].	self assert: result.	self assert: seen</body><body package="PetitTests">testParseOnError2	| parser result seen |	parser := $a asParser.		result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result = $a.	result := parser parse: 'b' onError: [ :msg :pos | 		self assert: (msg includesSubString: '$a').		self assert: (msg includesSubString: 'expected').		self assert: pos = 0.		seen := true ].	self assert: result.	self assert: seen</body><body package="PetitTests">testParser	| parser |	parser := PPParser new.		self assert: parser isPetitParser.	self deny: 4 isPetitParser.	self deny: 'foo' isPetitParser</body></methods><methods><class-id>PetitParser.PPParserTest</class-id> <category>testing</category><body package="PetitTests">testAnd	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten and.		self assert: parser parse: 'foobar' to: #('foo' 'bar') end: 3.	self assert: parser fail: 'foobaz'.		parser := 'foo' asParser and.	self assert: parser and = parser</body><body package="PetitTests">testBlock	| parser |	parser := [ :s | s next ] asParser.		self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: '' to: nil</body><body package="PetitTests">testChoice	| parser |	parser := $a asParser / $b asParser.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'ba' to: $b end: 1.	self assert: parser fail: ''.	self assert: parser fail: 'c'.	self assert: parser fail: 'ca'</body><body package="PetitTests">testDelimitedBy	| parser |	parser := $a asParser delimitedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abab' to: #($a $b $a $b).	self assert: parser parse: 'ababab' to: #($a $b $a $b $a $b).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a $b) end: 2.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $b $a $b) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'</body><body package="PetitTests">testDelimitedByWithoutSeparators	| parser |	parser := ($a asParser delimitedBy: $b asParser)		withoutSeparators.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $a).	self assert: parser parse: 'ababa' to: #($a $a $a).	self assert: parser parse: 'ab' to: #($a).	self assert: parser parse: 'abab' to: #($a $a).	self assert: parser parse: 'ababab' to: #($a $a $a).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a) end: 2.	self assert: parser parse: 'abac' to: #($a $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $a) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'</body><body package="PetitTests">testEndOfInput	| parser |	parser := PPEndOfInputParser on: $a asParser.	self assert: parser end = parser.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''.	self assert: parser fail: 'aa'</body><body package="PetitTests">testEndOfInputAfterMatch	| parser |	parser := 'stuff' asParser end.	self assert: parser parse: 'stuff' to: 'stuff'.	self assert: parser fail: 'stufff'.	self assert: parser fail: 'fluff'</body><body package="PetitTests">testEpsilon	| parser |	parser := nil asParser.		self assert: parser parse: '' to: nil.		self assert: parser parse: 'a' to: nil end: 0.	self assert: parser parse: 'ab' to: nil end: 0</body><body package="PetitTests">testFailing	| parser result |	parser := PPFailingParser message: 'Plonk'.	self assert: parser message = 'Plonk'.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.		result := parser parse: 'a'.	self assert: result message = 'Plonk'.	self assert: result printString = 'Plonk at 0'</body><body package="PetitTests">testLiteralObject	| parser |	parser := PPLiteralObjectParser 		on: $a		message: 'letter "a" expected'.	self assert: parser literal = $a.	self assert: parser message = 'letter "a" expected'.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'</body><body package="PetitTests">testLiteralObjectCaseInsensitive	| parser |	parser := $a asParser caseInsensitive.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'B'</body><body package="PetitTests">testLiteralSequence	| parser |	parser := PPLiteralSequenceParser 		on: 'abc'		message: 'sequence "abc" expected'.	self assert: parser size = 3.	self assert: parser literal = 'abc'.	self assert: parser message = 'sequence "abc" expected'.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'</body><body package="PetitTests">testLiteralSequenceCaseInsensitive	| parser |	parser := 'abc' asParser caseInsensitive.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'ABC' to: 'ABC'.	self assert: parser parse: 'abC' to: 'abC'.	self assert: parser parse: 'AbC' to: 'AbC'.		self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'</body><body package="PetitTests">testMax	| parser |	parser := $a asParser max: 2.	self assert: parser min = 0.	self assert: parser max = 2.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2.	self assert: parser parse: 'aaaa' to: #($a $a) end: 2.		self assert: (parser printString endsWith: '[0, 2]')</body><body package="PetitTests">testMaxGreedy	| parser |	parser := #word asParser max: 2 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abc'.		self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser fail: 'abc1'.		self assert: parser parse: '12' to: #($1) end: 1.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser fail: 'abc12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser fail: 'abc123'</body><body package="PetitTests">testMaxLazy	| parser |	parser := #word asParser max: 2 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abc'.		self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser fail: 'abc1'.		self assert: parser parse: '12' to: #() end: 0.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser fail: 'abc12'.		self assert: parser parse: '123' to: #() end: 0.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser fail: 'abc123'</body><body package="PetitTests">testMemoized	| count parser twice |	count := 0.	parser := [ :s | count := count + 1. s next ] asParser memoized.	twice := parser and , parser.		count := 0.	self assert: parser parse: 'a' to: $a.	self assert: count = 1.	count := 0.	self assert: twice parse: 'a' to: #($a $a).	self assert: count = 1.		self assert: parser memoized = parser</body><body package="PetitTests">testMin	| parser |	parser := $a asParser min: 2.	self assert: parser min = 2.	self assert: parser max &gt; parser min.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).		self assert: (parser printString endsWith: '[2, *]')</body><body package="PetitTests">testMinGreedy	| parser |	parser := #word asParser min: 2 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1' to: #($a $b $c $d $e) end: 5.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd12' to: #($a $b $c $d $1) end: 5.	self assert: parser parse: 'abcde12' to: #($a $b $c $d $e $1) end: 6.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5.	self assert: parser parse: 'abcd123' to: #($a $b $c $d $1 $2) end: 6.	self assert: parser parse: 'abcde123' to: #($a $b $c $d $e $1 $2) end: 7.		self assert: parser parse: '1234' to: #($1 $2 $3) end: 3.	self assert: parser parse: 'a1234' to: #($a $1 $2 $3) end: 4.	self assert: parser parse: 'ab1234' to: #($a $b $1 $2 $3) end: 5.	self assert: parser parse: 'abc1234' to: #($a $b $c $1 $2 $3) end: 6.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d $1 $2 $3) end: 7.	self assert: parser parse: 'abcde1234' to: #($a $b $c $d $e $1 $2 $3) end: 8</body><body package="PetitTests">testMinLazy	| parser |	parser := #word asParser min: 2 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1' to: #($a $b $c $d $e) end: 5.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde12' to: #($a $b $c $d $e) end: 5.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde123' to: #($a $b $c $d $e) end: 5.		self assert: parser parse: '1234' to: #($1 $2) end: 2.	self assert: parser parse: 'a1234' to: #($a $1) end: 2.	self assert: parser parse: 'ab1234' to: #($a $b) end: 2.	self assert: parser parse: 'abc1234' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1234' to: #($a $b $c $d $e) end: 5</body><body package="PetitTests">testMinMax	| parser |	parser := $a asParser min: 2 max: 4.	self assert: parser min = 2.	self assert: parser max = 4.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).	self assert: parser parse: 'aaaaa' to: #($a $a $a $a) end: 4.	self assert: parser parse: 'aaaaaa' to: #($a $a $a $a) end: 4.		self assert: (parser printString endsWith: '[2, 4]')</body><body package="PetitTests">testMinMaxGreedy	| parser |	parser := #word asParser min: 2 max: 4 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1'.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde123'.		self assert: parser parse: '1234' to: #($1 $2 $3) end: 3.	self assert: parser parse: 'a1234' to: #($a $1 $2 $3) end: 4.	self assert: parser parse: 'ab1234' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc1234' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1234'</body><body package="PetitTests">testMinMaxLazy	| parser |	parser := #word asParser min: 2 max: 4 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1'.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde123'.		self assert: parser parse: '1234' to: #($1 $2) end: 2.	self assert: parser parse: 'a1234' to: #($a $1) end: 2.	self assert: parser parse: 'ab1234' to: #($a $b) end: 2.	self assert: parser parse: 'abc1234' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1234'</body><body package="PetitTests">testNegate	| parser |	parser := 'foo' asParser negate.		self assert: parser parse: 'f' to: $f end: 1.	self assert: parser parse: 'fo' to: $f end: 1.	self assert: parser parse: 'fob' to: $f end: 1.	self assert: parser parse: 'ffoo' to: $f end: 1.		self assert: parser fail: ''.	self assert: parser fail: 'foo'</body><body package="PetitTests">testNot	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten not.		self assert: parser parse: 'foobaz' to: #('foo' nil) end: 3.	self assert: parser fail: 'foobar'</body><body package="PetitTests">testOptional	| parser |	parser := $a asParser optional.		self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: $a.		self assert: parser parse: 'aa' to: $a end: 1.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: nil end: 0.	self assert: parser parse: 'bb' to: nil end: 0.	self assert: parser parse: 'ba' to: nil end: 0</body><body package="PetitTests">testPluggable	| block parser |	block := [ :stream | stream position ].	parser := block asParser.	self assert: parser block = block</body><body package="PetitTests">testPlus	| parser |	parser := $a asParser plus.		self assert: parser min = 1.	self assert: parser max &gt; parser min.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'aab' to: #($a $a) end: 2.	self assert: parser parse: 'aaab' to: #($a $a $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'ba'</body><body package="PetitTests">testPlusGreedy	| limit parser |	limit := #digit asParser.	parser := #word asParser plusGreedy: limit.		self assert: parser min = 1.	self assert: parser max &gt; parser min.		self assert: parser limit = limit.	self assert: parser children size = 2.	self assert: parser children last = limit.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5.</body><body package="PetitTests">testPlusLazy	| limit parser |	limit := #digit asParser.	parser := #word asParser plusLazy: limit.		self assert: parser min = 1.	self assert: parser max &gt; parser min.		self assert: parser limit = limit.	self assert: parser children size = 2.	self assert: parser children last = limit.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3</body><body package="PetitTests">testSeparatedBy	| parser |	parser := $a asParser separatedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $b $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'</body><body package="PetitTests">testSeparatedByWithoutSeparators	| parser |	parser := ($a asParser separatedBy: $b asParser)		withoutSeparators.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $a).	self assert: parser parse: 'ababa' to: #($a $a $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'</body><body package="PetitTests">testSequence	| parser |	parser := $a asParser , $b asParser.		self assert: parser parse: 'ab' to: #($a $b).		self assert: parser parse: 'aba' to: #($a $b) end: 2.	self assert: parser parse: 'abb' to: #($a $b) end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.	self assert: parser fail: 'ba'.	self assert: parser fail: 'bab'</body><body package="PetitTests">testStar	| parser |	parser := $a asParser star.		self assert: parser min = 0.	self assert: parser max &gt; parser min.		self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).		self assert: parser parse: 'b' to: #() end: 0.	self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'aab' to: #($a $a) end: 2.	self assert: parser parse: 'aaab' to: #($a $a $a) end: 3</body><body package="PetitTests">testStarGreedy	| limit parser |	limit := #digit asParser.	parser := #word asParser starGreedy: limit.		self assert: parser min = 0.	self assert: parser max &gt; parser min.	self assert: parser limit = limit.	self assert: parser children size = 2.	self assert: parser children last = limit.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: '12' to: #($1) end: 1.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5</body><body package="PetitTests">testStarLazy	| limit parser |	limit := #digit asParser.	parser := #word asParser starLazy: limit.		self assert: parser min = 0.	self assert: parser max &gt; parser min.	self assert: parser limit = limit.	self assert: parser children size = 2.	self assert: parser children last = limit.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: '12' to: #() end: 0.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: '123' to: #() end: 0.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3</body><body package="PetitTests">testTimes	| parser |	parser := $a asParser times: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2</body><body package="PetitTests">testUnresolved	| parser |	parser := PPUnresolvedParser new.		self assert: parser isUnresolved.	self should: [ parser parse: '' ] raise: Error.	self should: [ parser parse: 'a' ] raise: Error.	self should: [ parser parse: 'ab' ] raise: Error.		parser := nil asParser.	self deny: parser isUnresolved</body><body package="PetitTests">testWrapped	| parser |	parser := $a asParser wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.		parser := (($a asParser , $b asParser ) wrapped , $c asParser).	self assert: parser parse: 'abc' to: #(#($a $b) $c)</body><body package="PetitTests">testXor	| parser |	parser := ($a asParser / $b asParser)			|  ($b asParser / $c asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'.		" truly symmetric "	parser := ($b asParser / $c asParser)			|  ($a asParser / $b asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'</body></methods><methods><class-id>PetitParser.PPParserTest</class-id> <category>testing-fixtures</category><body package="PetitTests">testSideEffectChoice	"Adding another element to a choice should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 / $b asParser.	p3 := p1 / $c asParser.		self assert: p1 parse: 'a'.	self assert: p1 fail: 'b'.	self assert: p1 fail: 'c'.		self assert: p2 parse: 'a'.	self assert: p2 parse: 'b'.	self assert: p2 fail: 'c'.		self assert: p3 parse: 'a'.	self assert: p3 fail: 'b'.	self assert: p3 parse: 'c'</body><body package="PetitTests">testSideEffectListCopy	| old new |	old := $a asParser , $b asParser.	new := old copy.		self deny: old == new.	self deny: old children == new children.	self assert: old children first == new children first.	self assert: old children last == new children last</body><body package="PetitTests">testSideEffectSequence	"Adding another element to a sequence should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 , $b asParser.	p3 := p1 , $c asParser.		self assert: p1 parse: 'a'.		self assert: p1 parse: 'ab' end: 1.	self assert: p1 parse: 'ac' end: 1.		self assert: p2 fail: 'a'.		self assert: p2 parse: 'ab'.	self assert: p2 fail: 'ac'.	self assert: p3 fail: 'a'.		self assert: p3 fail: 'ab'.	self assert: p3 parse: 'ac'</body></methods><methods><class-id>PetitParser.PPParserTest</class-id> <category>testing-properties</category><body package="PetitTests">testHasProperty	| parser |	parser := PPParser new.	self deny: (parser hasProperty: #foo).	parser propertyAt: #foo put: 123.	self assert: (parser hasProperty: #foo)</body><body package="PetitTests">testPostCopy	| parser copy |	parser := PPParser new.	parser propertyAt: #foo put: true.	copy := parser copy.	copy propertyAt: #foo put: false.	self assert: (parser propertyAt: #foo).	self deny: (copy propertyAt: #foo)</body><body package="PetitTests">testPropertyAt	| parser |	parser := PPParser new.	self should: [ parser propertyAt: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo)</body><body package="PetitTests">testPropertyAtIfAbsent	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo ifAbsent: [ false ])</body><body package="PetitTests">testPropertyAtIfAbsentPut	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsentPut: [ true ]).	self assert: (parser propertyAt: #foo ifAbsentPut: [ false ])</body><body package="PetitTests">testRemoveProperty	| parser |	parser := PPParser new.	self should: [ parser removeProperty: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo)</body><body package="PetitTests">testRemovePropertyIfAbsent	| parser |	parser := PPParser new.	self assert: (parser removeProperty: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo ifAbsent: [ false ])</body></methods><methods><class-id>PetitParser.PPParserTest</class-id> <category>testing-accessing</category><body package="PetitTests">testNamed	| parser |	parser := PPSequenceParser new.	self assert: parser name isNil.		parser := PPChoiceParser named: 'choice'.	self assert: parser name = 'choice'.		parser := $* asParser name: 'star'.	self assert: parser name = 'star'</body><body package="PetitTests">testPrint	| parser |	parser := PPParser new.	self assert: (parser printString includesSubString: 'PPParser').		parser := PPParser named: 'choice'.	self assert: (parser printString includesSubString: 'PPParser(choice').		parser := PPLiteralObjectParser on: $a.	self assert: (parser printString includesSubString: '$a').		parser := PPFailingParser message: 'error'.	self assert: (parser printString includesSubString: 'error').		parser := PPPredicateObjectParser on: [ :c | true ] message: 'error'.	self assert: (parser printString includesSubString: 'error')</body></methods><methods><class-id>PetitParser.PPParserTest</class-id> <category>testing-mapping</category><body package="PetitTests">testAction	| block parser |	block := [ :char | char asUppercase ].	parser := #any asParser ==&gt; block.	self assert: parser block = block.	self assert: parser parse: 'a' to: $A.	self assert: parser parse: 'b' to: $B</body><body package="PetitTests">testAnswer	| parser |	parser := $a asParser answer: $b.		self assert: parser parse: 'a' to: $b.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testFlatten	| parser |	parser := $a asParser flatten.		self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: #($a) to: #($a).		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testFoldLeft2	| parser |	parser := #any asParser star 		foldLeft: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #((a b) c).	self assert: parser parse: #(a b c d) to: #(((a b) c) d).	self assert: parser parse: #(a b c d e) to: #((((a b) c) d) e)</body><body package="PetitTests">testFoldLeft3	| parser |	parser := #any asParser star 		foldLeft: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #((a b c) d e)</body><body package="PetitTests">testFoldRight2	| parser |	parser := #any asParser star 		foldRight: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #(a (b c)).	self assert: parser parse: #(a b c d) to: #(a (b (c d))).	self assert: parser parse: #(a b c d e) to: #(a (b (c (d e))))</body><body package="PetitTests">testFoldRight3	| parser |	parser := #any asParser star 		foldRight: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #(a b (c d e))</body><body package="PetitTests">testMap1	| parser |	parser := #any asParser 		map: [ :a | Array with: a ].	self assert: parser parse: #(a) to: #(a)</body><body package="PetitTests">testMap2	| parser |	parser := (#any asParser , #any asParser) 		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: #(a b) to: #(b a)</body><body package="PetitTests">testMap3	| parser |	parser := (#any asParser , #any asParser , #any asParser)		map: [ :a :b :c | Array with: c with: b with: a ].	self assert: parser parse: #(a b c) to: #(c b a)</body><body package="PetitTests">testMapFail1	self		should: [ #any asParser map: [  ] ]		raise: Error.	self		should: [ #any asParser map: [ :a :b | ] ]		raise: Error</body><body package="PetitTests">testMapFail2	self		should: [ (#any asParser , #any asParser) map: [ :a | ] ]		raise: Error.	self		should: [ (#any asParser , #any asParser) map: [ :a :b :c | ] ]		raise: Error</body><body package="PetitTests">testPermutation	| parser |	parser := #any asParser , #any asParser , #any asParser.	self assert: (parser permutation: #()) parse: '123' to: #().	self assert: (parser permutation: #(1)) parse: '123' to: #($1).	self assert: (parser permutation: #(1 3)) parse: '123' to: #($1 $3).	self assert: (parser permutation: #(3 1)) parse: '123' to: #($3 $1).	self assert: (parser permutation: #(2 2)) parse: '123' to: #($2 $2).	self assert: (parser permutation: #(3 2 1)) parse: '123' to: #($3 $2 $1).		self should: [ parser permutation: #(0) ] raise: Error.	self should: [ parser permutation: #(4) ] raise: Error.	self should: [ parser permutation: #($2) ] raise: Error</body><body package="PetitTests">testToken	| parser |	parser := $a asParser token.	self assert: parser tokenClass = PPToken.	self assert: parser parse: 'a' toToken: 1 stop: 1.		self assert: parser fail: 'b'.	self assert: parser fail: ''.		parser := $a asParser token: PPToken.	self assert: parser tokenClass = PPToken.	self assert: parser parse: 'a' toToken: 1 stop: 1.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testTrim	| parser |	parser := $a asParser token trim.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testTrimBlanks	| parser |	parser := $a asParser token trimBlanks.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.</body><body package="PetitTests">testTrimCustom	| parser |	parser := $a asParser token trim: $b asParser.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'ab' toToken: 1 stop: 1.	self assert: parser parse: 'abb' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'ba' toToken: 2 stop: 2.	self assert: parser parse: 'bba' toToken: 3 stop: 3.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'ab' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'abba' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testTrimSpaces	| parser |	parser := $a asParser token trimSpaces.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testWrapping	| parser result |	parser := #digit asParser plus &gt;=&gt; [ :stream :cc | 		Array 			with: stream position 			with: cc value 			with: stream position ].	self assert: parser parse: '1' to: #(0 ($1) 1).	self assert: parser parse: '12' to: #(0 ($1 $2) 2).	self assert: parser parse: '123' to: #(0 ($1 $2 $3) 3).		result := parser parse: 'a'.	self assert: result first = 0.	self assert: result second isPetitFailure.	self assert: result last = 0</body></methods><methods><class-id>PetitParser.PPActionParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| element |	^ (element := parser parseOn: aStream) isPetitFailure		ifFalse: [ block value: element ]		ifTrue: [ element ]</body></methods><methods><class-id>PetitParser.PPActionParser</class-id> <category>initialization</category><body package="PetitParser">setBlock: aBlock	block := aBlock</body></methods><methods><class-id>PetitParser.PPActionParser</class-id> <category>accessing</category><body package="PetitParser">block	"Answer the action block of the receiver."	^ block</body></methods><methods><class-id>PetitParser.PPActionParser</class-id> <category>*petitanalyzer-matching</category><body package="PetitAnalyzer">match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self block = aParser block ]</body></methods><methods><class-id>PetitParser.PPActionParser class</class-id> <category>instance creation</category><body package="PetitParser">on: aParser block: aBlock	^ (self on: aParser) setBlock: aBlock</body></methods><methods><class-id>PetitParser.PPWrappingParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	^ block value: aStream value: [ parser parseOn: aStream ]</body></methods><methods><class-id>PetitParser.PPNotParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| element position |	position := aStream position.	element := parser parseOn: aStream.	aStream position: position.	^ element isPetitFailure		ifFalse: [ PPFailure message: '' at: aStream position ]</body></methods><methods><class-id>PetitParser.PPCharSetPredicate</class-id> <category>evaluating</category><body package="PetitParser">value: aCharacter	| index |	index := aCharacter asInteger.	index == 0		ifTrue: [ ^ block value: aCharacter ].	index &gt; 255		ifTrue: [ ^ block value: aCharacter ].	^ classification at: index</body></methods><methods><class-id>PetitParser.PPCharSetPredicate</class-id> <category>initialization</category><body package="PetitParser">initializeOn: aBlock	block := aBlock.	classification := Array new: 255.	1 to: classification size do: [ :index |		classification at: index put: (block			value: (Character value: index)) ]</body></methods><methods><class-id>PetitParser.PPCharSetPredicate class</class-id> <category>instance creation</category><body package="PetitParser">on: aBlock	^ self basicNew initializeOn: aBlock</body></methods><methods><class-id>PetitParser.PPSequenceParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	"This is optimized code that avoids unnecessary block activations, do not change."		| start elements element |	start := aStream position.	elements := Array new: parsers size.	1 to: parsers size do: [ :index |		element := (parsers at: index) 			parseOn: aStream.		element isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements at: index put: element ].	^ elements</body></methods><methods><class-id>PetitParser.PPSequenceParser</class-id> <category>operators-mapping</category><body package="PetitParser">map: aBlock	^ aBlock numArgs = self children size		ifTrue: [ self ==&gt; [ :nodes | aBlock valueWithArguments: nodes ] ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]</body><body package="PetitParser">permutation: anArrayOfIntegers	"Answer a permutation of the receivers sequence."		anArrayOfIntegers do: [ :index |		(index isInteger and: [ index between: 1 and: parsers size ])			ifFalse: [ self error: 'Invalid permutation index: ' , index printString ] ].	^ self ==&gt; [ :nodes | anArrayOfIntegers collect: [ :index | nodes at: index ] ]</body></methods><methods><class-id>PetitParser.PPSequenceParser</class-id> <category>operators</category><body package="PetitParser">, aRule	^ self copyWith: aRule</body></methods><methods><class-id>PetitParser.PPSequenceParser</class-id> <category>*petitanalyzer-private</category><body package="PetitAnalyzer">cycleSet: aDictionary	| firstSet |	1 to: parsers size do: [ :index |		firstSet := aDictionary at: (parsers at: index).		(firstSet anySatisfy: [ :each | each isNullable ])			ifFalse: [ ^ parsers copyFrom: 1 to: index ] ].	^ parsers</body><body package="PetitAnalyzer">firstSets: aFirstDictionary into: aSet	| nullable |	parsers do: [ :parser |		nullable := false.		(aFirstDictionary at: parser) do: [ :each |			each isNullable				ifTrue: [ nullable := true ]				ifFalse: [ aSet add: each ] ].		nullable			ifFalse: [ ^ self ] ].	aSet add: PPSentinel instance</body><body package="PetitAnalyzer">followSets: aFollowDictionary firstSets: aFirstDictionary into: aSet	parsers keysAndValuesDo: [ :index :parser |		| followSet firstSet |		followSet := aFollowDictionary at: parser.		index = parsers size			ifTrue: [ followSet addAll: aSet ]			ifFalse: [				(self class withAll: (parsers 					copyFrom: index + 1 to: parsers size))						firstSets: aFirstDictionary						into: (firstSet := IdentitySet new).				(firstSet anySatisfy: [ :each | each isNullable ])					ifTrue: [ followSet addAll: aSet ].				followSet addAll: (firstSet 					reject: [ :each | each isNullable ]) ] ]</body></methods><methods><class-id>PetitParser.PPPattern</class-id> <category>matching</category><body package="PetitAnalyzer">copyInContext: aDictionary seen: aSeenDictionary	^ aDictionary at: self</body><body package="PetitAnalyzer">match: aParser inContext: aDictionary seen: anIdentitySet	(verificationBlock value: aParser value: aDictionary)		ifFalse: [ ^ false ].	^ (aDictionary at: self ifAbsentPut: [ aParser ])		match: aParser inContext: aDictionary seen: anIdentitySet</body></methods><methods><class-id>PetitParser.PPPattern</class-id> <category>comparing</category><body package="PetitAnalyzer">= aParser	^ self == aParser or: [ self name notNil and: [ self name = aParser name ] ]</body><body package="PetitAnalyzer">hash	^ self identityHash</body></methods><methods><class-id>PetitParser.PPPattern</class-id> <category>parsing</category><body package="PetitAnalyzer">parseOn: aStream	"This is just a pattern used for matching. It should not be used in actual grammars."	self shouldNotImplement</body></methods><methods><class-id>PetitParser.PPPattern</class-id> <category>initialization</category><body package="PetitAnalyzer">initializeOn: aBlock	verificationBlock := aBlock</body></methods><methods><class-id>PetitParser.PPPattern class</class-id> <category>instance creation</category><body package="PetitAnalyzer">any	"Matches all parsers."	^ self on: [ :parser :context | true ]</body><body package="PetitAnalyzer">kind: aBehavior	"Matches parsers that are of the class aBehavior."	^ self on: [ :parser :context | parser class = aBehavior ]</body><body package="PetitAnalyzer">name: aString	"Matches parsers with the name aString."	^ self on: [ :parser :context | parser name = aString ]</body><body package="PetitAnalyzer">new	self error: 'Use an explicit constructur on ' , self name</body><body package="PetitAnalyzer">on: aBlock	"Matches parsers that satisfy an arbitrary condition in aBlock."	^ self basicNew initializeOn: aBlock</body></methods><methods><class-id>PetitParser.PPPossessiveRepeatingParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| start element elements |	start := aStream position.	elements := OrderedCollection new.	[ elements size &lt; min ] whileTrue: [		(element := parser parseOn: aStream) isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements addLast: element ].	[ elements size &lt; max ] whileTrue: [	 	(element := parser parseOn: aStream) isPetitFailure			ifTrue: [ ^ elements asArray ].		elements addLast: element ].	^ elements asArray</body></methods><methods><class-id>PetitParser.PPArithmeticParser</class-id> <category>grammar</category><body package="PetitTests">addition	^ (factors separatedBy: ($+ asParser / $- asParser) token trim) 		foldLeft: [ :a :op :b | a perform: op value asSymbol with: b ]</body><body package="PetitTests">factors	^ multiplication / power</body><body package="PetitTests">multiplication	^ (power separatedBy: ($* asParser / $/ asParser) token trim)		foldLeft: [ :a :op :b | a perform: op value asSymbol with: b ]</body><body package="PetitTests">number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) token trim ==&gt; [ :token | token value asNumber ]</body><body package="PetitTests">parentheses	^ $( asParser flatten trim , terms , $) asParser flatten trim ==&gt; #second</body><body package="PetitTests">power	^ (primary separatedBy: $^ asParser token trim) foldRight: [ :a :op :b | a raisedTo: b ]</body><body package="PetitTests">primary	^ number / parentheses</body><body package="PetitTests">terms	^ addition / factors</body></methods><methods><class-id>PetitParser.PPArithmeticParser</class-id> <category>accessing</category><body package="PetitTests">start	^ terms end</body></methods><methods><class-id>PetitParser.PPPluggableParser</class-id> <category>initialization</category><body package="PetitParser">initializeOn: aBlock	block := aBlock</body></methods><methods><class-id>PetitParser.PPPluggableParser</class-id> <category>accessing</category><body package="PetitParser">block	"Answer the pluggable block."	^ block</body></methods><methods><class-id>PetitParser.PPPluggableParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| position result |	position := aStream position.	result := block value: aStream.	result isPetitFailure		ifTrue: [ aStream position: position ].	^ result</body></methods><methods><class-id>PetitParser.PPPluggableParser</class-id> <category>*petitanalyzer-matching</category><body package="PetitAnalyzer">match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self block = aParser block ]</body></methods><methods><class-id>PetitParser.PPPluggableParser class</class-id> <category>instance creation</category><body package="PetitParser">on: aBlock	^ self new initializeOn: aBlock</body></methods><methods><class-id>PetitParser.PPEndOfInputParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| position result |	position := aStream position.	result := parser parseOn: aStream.	(result isPetitFailure or: [ aStream atEnd ])		ifTrue: [ ^ result ].	result := PPFailure		message: 'end of input expected'		at: aStream position.	aStream position: position.	^ result</body></methods><methods><class-id>PetitParser.PPEndOfInputParser</class-id> <category>operators</category><body package="PetitParser">end	^ self</body></methods><methods><class-id>PetitParser.PPComposedTest</class-id> <category>testing</category><body package="PetitTests">testDoubledString	| parser |	parser := ($' asParser , (($' asParser , $' asParser) / $' asParser negate) star flatten , $' asParser) 		==&gt; [ :nodes | nodes second copyReplaceAll: '''''' with: '''' ].	self assert: parser parse: '''''' to: ''.	self assert: parser parse: '''a''' to: 'a'.	self assert: parser parse: '''ab''' to: 'ab'.	self assert: parser parse: '''a''''b''' to: 'a''b'.	self assert: parser parse: '''a''''''''b''' to: 'a''''b'</body><body package="PetitTests">testEvenNumber	"Create a grammar that parses an even number of a's and b's."		| a as b bs s |	a := $a asParser ==&gt; [ :char | as := as + 1 ].	b := $b asParser ==&gt; [ :char | bs := bs + 1 ].	s := (a / b) star &gt;=&gt; [ :stream :cc |		as := bs := 0.		cc value.		(as even and: [ bs even ])			ifFalse: [ PPFailure message: 'Even number of a and b expected' at: 0 ] ].	self assert: s fail: 'a' end: 1.	self assert: s fail: 'b' end: 1.	self assert: s fail: 'ab' end: 2.	self assert: s fail: 'ba' end: 2.	self assert: s fail: 'aaa' end: 3.	self assert: s fail: 'bbb' end: 3.	self assert: s fail: 'aab' end: 3.	self assert: s fail: 'abb' end: 3.		self assert: s parse: ''.	self assert: s parse: 'aa'.	self assert: s parse: 'bb'.	self assert: s parse: 'aaaa'.	self assert: s parse: 'aabb'.	self assert: s parse: 'abab'.	self assert: s parse: 'baba'.	self assert: s parse: 'bbaa'.	self assert: s parse: 'bbbb'</body><body package="PetitTests">testIfThenElse	"S ::= if C then S else S | if C then S | X"	| start if then else cond expr parser |	start := PPDelegateParser new.	if := 'if' asParser token trim.	then := 'then' asParser token trim.	else := 'else' asParser token trim.	cond := 'C' asParser token trim.	expr := 'X' asParser token trim.	start setParser: (if , cond , then , start , else , start) / (if , cond , then , start) / expr.	parser := start end.	self assert: parser parse: 'X'.	self assert: parser parse: 'if C then X'.	self assert: parser parse: 'if C then X else X'.	self assert: parser parse: 'if C then if C then X'.	self assert: parser parse: 'if C then if C then X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X else X'.	self assert: parser fail: 'if C'.	self assert: parser fail: 'if C else X'.	self assert: parser fail: 'if C then if C'</body><body package="PetitTests">testLeftRecursion	"S ::= S 'x' S / '1'"		| parser |	parser := PPDelegateParser new.	parser setParser: ((parser , $x asParser , parser) / $1 asParser) memoized flatten.	self assert: parser parse: '1' to: '1'.	self assert: parser parse: '1x1' to: '1x1'.	self assert: parser parse: '1x1x1' to: '1x1x1'.	self assert: parser parse: '1x1x1x1' to: '1x1x1x1'.	self assert: parser parse: '1x1x1x1x1' to: '1x1x1x1x1'.	self assert: parser parse: '1x1x1x1x1x1' to: '1x1x1x1x1x1'</body><body package="PetitTests">testListOfIntegers	"S ::= S , number | number"		| number list parser |	number := #digit asParser plus token trim		==&gt; [ :node | Number readFrom: (node value readStream) ].	list := (number separatedBy: $, asParser token trim)		==&gt; [ :node | node select: [ :each | each isInteger] ].	parser := list end.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1,2' to: (1 to: 2) asArray.	self assert: parser parse: '1,2,3' to: (1 to: 3) asArray.	self assert: parser parse: '1,2,3,4' to: (1 to: 4) asArray.	self assert: parser parse: '1,2,3,4,5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1, 2' to: (1 to: 2) asArray.	self assert: parser parse: '1, 2, 3' to: (1 to: 3) asArray.	self assert: parser parse: '1, 2, 3, 4' to: (1 to: 4) asArray.	self assert: parser parse: '1, 2, 3, 4, 5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1 ,2' to: (1 to: 2) asArray.	self assert: parser parse: '1 ,2 ,3' to: (1 to: 3) asArray.	self assert: parser parse: '1 ,2 ,3 ,4' to: (1 to: 4) asArray.	self assert: parser parse: '1 ,2 ,3 ,4 ,5' to: (1 to: 5) asArray.		self assert: parser fail: ''.	self assert: parser fail: ','.	self assert: parser fail: '1,'.	self assert: parser fail: '1,,2'</body><body package="PetitTests">testNestedComments	"C ::= B I* E"	"I ::= !E (C | T)"	"B ::= /*"	"E ::= */"	"T ::= ."		| begin end any inside parser |	begin := '/*' asParser.	end := '*/' asParser.	any := #any asParser.		parser := PPDelegateParser new.	inside := end not , (parser / any).	parser setParser: begin , inside star , end.		self assert: parser parse: '/*ab*/cd' end: 6.	self assert: parser parse: '/*a/*b*/c*/'.	self assert: parser fail: '/*a/*b*/c'</body><body package="PetitTests">testPalindrome	"S0 ::= a S1 a | b S1 b | ...	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := PPDelegateParser new.	s0 setParser: ($a asParser , s1 , $a asParser)		/ ($b asParser , s1 , $b asParser)		/ ($c asParser , s1 , $c asParser).		s1 setParser: s0 / nil asParser.	parser := s0 flatten end.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'bb' to: 'bb'.	self assert: parser parse: 'cc' to: 'cc'.		self assert: parser parse: 'abba' to: 'abba'.	self assert: parser parse: 'baab' to: 'baab'.	self assert: parser parse: 'abccba' to: 'abccba'.	self assert: parser parse: 'abaaba' to: 'abaaba'.	self assert: parser parse: 'cbaabc' to: 'cbaabc'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'abccbb'</body><body package="PetitTests">testParseAaaBbb	"S0 ::= a S1 b	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := PPDelegateParser new.	s0 setParser: $a asParser , s1 , $b asParser.	s1 setParser: s0 / nil asParser.	parser := s0 flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aabb' to: 'aabb'.	self assert: parser parse: 'aaabbb' to: 'aaabbb'.	self assert: parser parse: 'aaaabbbb' to: 'aaaabbbb'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'aabbb' to: 'aabb' end: 4.	self assert: parser parse: 'aaabbbb' to: 'aaabbb' end: 6.	self assert: parser parse: 'aaaabbbbb' to: 'aaaabbbb' end: 8.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'aaabb'</body><body package="PetitTests">testParseAaaaaa	"S ::= a a S | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := $a asParser , $a asParser , s0.	s0 setParser: s1 / nil asParser.	parser := s0 flatten.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'aaaa' to: 'aaaa'.	self assert: parser parse: 'aaaaaa' to: 'aaaaaa'.	self assert: parser parse: 'a' to: '' end: 0.	self assert: parser parse: 'aaa' to: 'aa' end: 2.	self assert: parser parse: 'aaaaa' to: 'aaaa' end: 4.	self assert: parser parse: 'aaaaaaa' to: 'aaaaaa' end: 6</body><body package="PetitTests">testParseAbAbAb	"S ::= (A B)+"		| parser |	parser := ($a asParser , $b asParser) plus flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'abab' to: 'abab'.	self assert: parser parse: 'ababab' to: 'ababab'.	self assert: parser parse: 'abababab' to: 'abababab'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'ababa' to: 'abab' end: 4.	self assert: parser parse: 'abababb' to: 'ababab' end: 6.	self assert: parser parse: 'ababababa' to: 'abababab' end: 8.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'bab'</body><body package="PetitTests">testParseAbabbb	"S ::= (A | B)+"	| parser |	parser := ($a asParser / $b asParser) plus flatten.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'b' to: 'b'.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'ba' to: 'ba'.	self assert: parser parse: 'aaa' to: 'aaa'.	self assert: parser parse: 'aab' to: 'aab'.	self assert: parser parse: 'aba' to: 'aba'.	self assert: parser parse: 'baa' to: 'baa'.	self assert: parser parse: 'abb' to: 'abb'.	self assert: parser parse: 'bab' to: 'bab'.	self assert: parser parse: 'bba' to: 'bba'.	self assert: parser parse: 'bbb' to: 'bbb'.	self assert: parser parse: 'ac' to: 'a' end: 1.	self assert: parser parse: 'bc' to: 'b' end: 1.	self assert: parser parse: 'abc' to: 'ab' end: 2.	self assert: parser parse: 'bac' to: 'ba' end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'c'</body><body package="PetitTests">testParseAnBnCn	"PEGs for a non context- free language: 				a^n , b^n , c^n			S &lt;- &amp;P1 P2 	P1 &lt;- AB 'c' 	AB &lt;- 'a' AB 'b' / epsilon	P2 &lt;- 'a'* BC end	BC &lt;- 'b' BC 'c' / epsilon"		| s p1 ab p2 bc |	s := PPDelegateParser new.	p1 := PPDelegateParser new.	ab := PPDelegateParser new.	p2 := PPDelegateParser new.	bc := PPDelegateParser new.		s setParser: (p1 and , p2 end) flatten.	p1 setParser: ab , $c asParser.	ab setParser: ($a asParser , ab , $b asParser) optional.	p2 setParser: $a asParser star , bc.	bc setParser: ($b asParser , bc , $c asParser) optional.		self assert: s parse: 'abc' to: 'abc'.	self assert: s parse: 'aabbcc' to: 'aabbcc'.	self assert: s parse: 'aaabbbccc' to: 'aaabbbccc'.	self assert: s fail: 'bc'.	self assert: s fail: 'ac'.	self assert: s fail: 'ab'.	self assert: s fail: 'abbcc'.	self assert: s fail: 'aabcc'.	self assert: s fail: 'aabbc'</body></methods><methods><class-id>PetitParser.PPComposedTest</class-id> <category>accessing</category><body package="PetitTests">comment	^ ($" asParser , $" asParser negate star , $" asParser) flatten</body><body package="PetitTests">identifier	^ (#letter asParser , #word asParser star) flatten</body><body package="PetitTests">number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten</body></methods><methods><class-id>PetitParser.PPComposedTest</class-id> <category>testing-examples</category><body package="PetitTests">testComment	self assert: self comment parse: '""' to: '""'.	self assert: self comment parse: '"a"' to: '"a"'.	self assert: self comment parse: '"ab"' to: '"ab"'.	self assert: self comment parse: '"abc"' to: '"abc"'.	self assert: self comment parse: '""a' to: '""' end: 2.	self assert: self comment parse: '"a"a' to: '"a"' end: 3.	self assert: self comment parse: '"ab"a' to: '"ab"' end: 4.	self assert: self comment parse: '"abc"a' to: '"abc"' end: 5.	self assert: self comment fail: '"'.	self assert: self comment fail: '"a'.	self assert: self comment fail: '"aa'.	self assert: self comment fail: 'a"'.	self assert: self comment fail: 'aa"'</body><body package="PetitTests">testIdentifier	self assert: self identifier parse: 'a' to: 'a'.	self assert: self identifier parse: 'a1' to: 'a1'.	self assert: self identifier parse: 'a12' to: 'a12'.	self assert: self identifier parse: 'ab' to: 'ab'.	self assert: self identifier parse: 'a1b' to: 'a1b'.	self assert: self identifier parse: 'a_' to: 'a' end: 1.	self assert: self identifier parse: 'a1-' to: 'a1' end: 2.	self assert: self identifier parse: 'a12+' to: 'a12' end: 3.	self assert: self identifier parse: 'ab^' to: 'ab' end: 2.	self assert: self identifier parse: 'a1b*' to: 'a1b' end: 3.	self assert: self identifier fail: ''.	self assert: self identifier fail: '1'.	self assert: self identifier fail: '1a'</body><body package="PetitTests">testNumber	self assert: self number parse: '1' to: '1'.	self assert: self number parse: '12' to: '12'.	self assert: self number parse: '12.3' to: '12.3'.	self assert: self number parse: '12.34' to: '12.34'.	self assert: self number parse: '1..' to: '1' end: 1.	self assert: self number parse: '12-' to: '12' end: 2.	self assert: self number parse: '12.3.' to: '12.3' end: 4.	self assert: self number parse: '12.34.' to: '12.34' end: 5.		self assert: self number parse: '-1' to: '-1'.	self assert: self number parse: '-12' to: '-12'.	self assert: self number parse: '-12.3' to: '-12.3'.	self assert: self number parse: '-12.34' to: '-12.34'.		self assert: self number fail: ''.	self assert: self number fail: '-'.	self assert: self number fail: '.'.	self assert: self number fail: '.1'</body><body package="PetitTests">testReturn	| number spaces return |	number := #digit asParser plus token.	spaces := #space asParser star.	return := (spaces , $^ asParser token , spaces , number)		==&gt; [ :nodes | Array with: #return with: (nodes at: 4) value ].	self assert: return parse: '^1' to: #(return '1').	self assert: return parse: '^12' to: #(return '12').	self assert: return parse: '^ 123' to: #(return '123').	self assert: return parse: '^  1234' to: #(return '1234').		self assert: return fail: '1'.	self assert: return fail: '^'</body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| position result |	position := aStream position.	result := aStream next: size.	(result size = size and: [ predicate value: result ])		ifTrue: [ ^ result ].	aStream position: position.	^ PPFailure message: predicateMessage at: aStream position</body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>operators</category><body package="PetitParser">negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage		negated: predicate message: predicateMessage		size: size</body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>initialization</category><body package="PetitParser">initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString.	size := anInteger</body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>accessing</category><body package="PetitParser">size	"Answer the sequence size of the receiver."	^ size</body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>*petitanalyzer-matching</category><body package="PetitAnalyzer">match: aParser inContext: aDictionary seen: anIdentitySet	^ (super match: aParser inContext: aDictionary seen: anIdentitySet) and: [ self size = aParser size ]</body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser class</class-id> <category>instance creation</category><body package="PetitParser">on: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger 	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger</body><body package="PetitParser">on: aBlock message: aString size: anInteger	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString size: anInteger</body></methods><methods><class-id>PetitParser.PPSearchRule</class-id> <category>matching</category><body package="PetitAnalyzer">canMatch: aParser	owner setAnswer: (answerBlock cull: aParser cull: owner answer).	^ super canMatch: aParser</body><body package="PetitAnalyzer">foundMatchFor: aParser 	^ aParser</body></methods><methods><class-id>PetitParser.PPSearchRule</class-id> <category>initialization</category><body package="PetitAnalyzer">setAnswerBlock: aBlock	answerBlock := aBlock</body></methods><methods><class-id>PetitParser.PPSearchRule class</class-id> <category>instance creation</category><body package="PetitAnalyzer">searchFor: aParser thenDo: aBlock	^ (self searchFor: aParser) setAnswerBlock: aBlock</body></methods><methods><class-id>PetitParser.PPRewriter</class-id> <category>accessing</category><body package="PetitAnalyzer">replace: aSearchParser with: aReplaceParser	self replace: aSearchParser with: aReplaceParser when: [ :node | true ]</body><body package="PetitAnalyzer">replace: aSearchParser with: aReplaceParser when: aValidationBlock	self addRule: (PPParserReplaceRule searchFor: aSearchParser replaceWith: aReplaceParser when: aValidationBlock)</body><body package="PetitAnalyzer">replace: aSearchParser withValueFrom: aReplaceBlock	self replace: aSearchParser withValueFrom: aReplaceBlock when: [ :node | true ]</body><body package="PetitAnalyzer">replace: aSearchParser withValueFrom: aReplaceBlock when: aValidationBlock	self addRule: (PPBlockReplaceRule searchFor: aSearchParser replaceWith: aReplaceBlock when: aValidationBlock)</body></methods><methods><class-id>PetitParser.PPRewriter</class-id> <category>initialization</category><body package="PetitAnalyzer">initialize	super initialize.	changed := false</body></methods><methods><class-id>PetitParser.PPRewriter</class-id> <category>public</category><body package="PetitAnalyzer">execute: aParser	"Perform the replace rules of the receiver on aParser, answer the resulting parser."	| previous result |	previous := context.	changed := false.	context := Dictionary new.	result := aParser transform: [ :each |		| transformed |		transformed := self performRulesOn: each.		transformed isNil			ifTrue: [ each ]			ifFalse: [ changed := true. transformed ] ].	context := previous.	^ result</body></methods><methods><class-id>PetitParser.PPRewriter</class-id> <category>testing</category><body package="PetitAnalyzer">hasChanged	"Answer if the last operation has changed anything."		^ changed</body></methods><methods><class-id>PetitParser.PPGreedyRepeatingParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	| start element elements positions |	start := aStream position.	elements := OrderedCollection new.	[ elements size &lt; min ] whileTrue: [ 		(element := parser parseOn: aStream) isPetitFailure ifTrue: [ 			aStream position: start.			^ element ].		elements addLast: element ].	positions := OrderedCollection with: aStream position.	[ elements size &lt; max and: [ (element := parser parseOn: aStream) isPetitFailure not ] ] whileTrue: [		elements addLast: element.		positions addLast: aStream position ].	[ positions isEmpty ] whileFalse: [		aStream position: positions last.		element := limit parseOn: aStream.		element isPetitFailure ifFalse: [			aStream position: positions last.			^ elements asArray ].		elements isEmpty ifTrue: [			aStream position: start.			^ element ].		elements removeLast.		positions removeLast ].	aStream position: start.	^ PPFailure message: 'overflow' at: start</body></methods><methods><class-id>PetitParser.PPSentinel class</class-id> <category>instance creation</category><body package="PetitAnalyzer">instance	^ instance ifNil: [ instance := self new ]</body></methods><methods><class-id>PetitParser.PPLiteralObjectParser</class-id> <category>operators</category><body package="PetitParser">caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateObjectParser on: [ :value | literal sameAs: value ] message: message</body><body package="PetitParser">negate	^ (PPPredicateObjectParser expect: literal message: message) negate</body></methods><methods><class-id>PetitParser.PPLiteralObjectParser</class-id> <category>parsing</category><body package="PetitParser">parseOn: aStream	^ (aStream atEnd not and: [ literal = aStream uncheckedPeek ])		ifFalse: [ PPFailure message: message at: aStream position ]		ifTrue: [ aStream next ]</body></methods><methods><class-id>PetitParser.PPScriptingTest</class-id> <category>tests</category><body package="PetitTests">testExpressionInterpreter	self 		assert: self expressionInterpreter		parse: '2*(3+4)'		to: 14</body><body package="PetitTests">testExpressionParser	self		assert: self expressionParser		parse: '2*(3+4)'		to: #($2 $* ($( ($3 $+ $4) $)))</body><body package="PetitTests">testSLassign		self assert: self straightLineParser		parse: 'abc:=1'		to: #(#($a #($b $c) ':=' #(#(#($1 #()) #()) #())) #())</body><body package="PetitTests">testSLprint	self 		assert: self straightLineParser		parse: 'print(3,4)'		to: #(('print' $( ((($3 ()) ()) () (($, ((($4 ()) ()) ())))) $)) ())</body></methods><methods><class-id>PetitParser.PPScriptingTest</class-id> <category>examples</category><body package="PetitTests">expressionInterpreter	"Same as #expressionInterpreter but with semantic actions."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 - $9) ==&gt; [ :token | token codePoint - $0 codePoint ].	add def: ((mul , $+ asParser , add) ==&gt; [ :nodes | (nodes at: 1) + (nodes at: 3) ])		/ mul.	mul def: ((prim , $* asParser , mul) ==&gt; [ :nodes | (nodes at: 1) * (nodes at: 3) ])		/ prim.	prim def: (($( asParser , add , $) asParser) ==&gt; [ :nodes | nodes at: 2 ])		/ dec.	^ add end</body><body package="PetitTests">expressionParser	"Simple demo of scripting an expression parser."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 - $9).	add def: (mul , $+ asParser , add)		/ mul.	mul def: (prim , $* asParser , mul)		/ prim.	prim def: ($( asParser , add , $) asParser)		/ dec.	^ add end</body><body package="PetitTests">straightLineParser	| goal stm stmList id char dec exp expList mulExp primExp nonzero num lower upper |	goal := PPUnresolvedParser new.	stmList := PPUnresolvedParser new.	stm := PPUnresolvedParser new.	exp := PPUnresolvedParser new.	expList := PPUnresolvedParser new.	mulExp := PPUnresolvedParser new.	primExp := PPUnresolvedParser new.		lower := $a - $z.	upper := $A - $Z.	char := lower / upper.	nonzero := $1 - $9.	dec := $0 - $9.	id := char, ( char / dec ) star.	num := $0 asParser / ( nonzero, dec star).	goal def: stmList end.	stmList def: stm , ( $; asParser, stm ) star.	stm def: ( id, ':=' asParser, exp )		/ ( 'print' asParser, $( asParser, expList, $) asParser ). 	exp def: mulExp, ( ( $+ asParser / $- asParser ), mulExp ) star.	expList def: exp, ( $, asParser, exp ) star.	mulExp def: primExp, ( ( $* asParser / $/ asParser ), primExp ) star.	primExp def: id		/ num		/ ( $( asParser, stmList, $, asParser, exp, $) asParser ).	^ goal</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="PetitParser-Postload">allButFirst	^ self copyFrom: 2 to: self size</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="PetitParser-Postload">at: anInteger ifAbsent: aBlock 	(anInteger between: 1 and: self size) 		ifTrue: [ ^ self at: anInteger ].	^ aBlock value</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="PetitParser-Postload">copyWithFirst: anObject	^ (self class new: self size + 1)		replaceFrom: 2 to: self size + 1 with: self;		at: 1 put: anObject;		yourself</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="PetitParser-Postload">fifth	^ self at: 5</body><body package="PetitParser-Postload">fourth	^ self at: 4</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="PetitParser-Postload">reversed	| size result src |	size := self size.	result := self species new: size.	src := size + 1.	1 to: size do: [ :index | result at: index put: (self at: (src := src - 1))].	^ result</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="PetitParser-Postload">second	^ self at: 2</body><body package="PetitParser-Postload">third	^ self at: 3</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="PetitParser-Postload">isCollection	^ true</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="PetitParser-Postload">isCollection	^ false</body></methods><methods><class-id>Core.Character class</class-id> <category>accessing untypeable characters</category><body package="PetitParser-Postload">allCharacters	^ (0 to: 256) collect: [ :each | Character value: each ]</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="PetitParser-Postload">asInteger	^ self asNumber truncated</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>testing</category><body package="PetitParser-Postload">includesSubString: aString	^ (self findString: aString startingAt: 1) &gt; 0</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>i18n</category><body package="PetitParser">i18nIgnores	&lt;i18nSelectorsToIgnore&gt;	^#(#'*')</body></methods><methods><class-id>PetitParser.PPParser class</class-id> <category>i18n</category><body package="PetitParser">i18nIgnores	&lt;i18nSelectorsToIgnore&gt;	^#(#'*')</body></methods><methods><class-id>PetitParser.PPAbstractParserTest</class-id> <category>i18n</category><body package="PetitTests">i18nIgnores	&lt;i18nSelectorsToIgnore&gt;	^#(#'*')</body></methods><methods><class-id>PetitParser.PPAbstractParserTest class</class-id> <category>i18n</category><body package="PetitTests">i18nIgnores	&lt;i18nSelectorsToIgnore&gt;	^#(#'*')</body></methods><methods><class-id>Core.Text</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asPetitStream	^ string asPetitStream</body></methods><methods><class-id>Core.Character</class-id> <category>*petitparser-core-operators</category><body package="PetitParser">- aCharacter	"Create a range of characters between the receiver and the argument."		^ PPPredicateObjectParser between: self and: aCharacter</body></methods><methods><class-id>Core.Character</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asParser	"Answer a parser that accepts the receiving character."		^ PPLiteralObjectParser on: self</body></methods><methods><class-id>Core.String</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asParser	"Answer a parser that accepts the receiving string."	^ PPLiteralSequenceParser on: self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asParser	self		notify: (#SequenceableCollectionA___SequenceParserInstead_ &lt;&lt; #petitParser				&gt;&gt; 'SequenceableCollection&gt;&gt;#asParser is no longer supported. If you would like to create a PPSequenceParser from a Collection consider using #asSequenceParser instead.')					asString.	^self asSequenceParser</body><body package="PetitParser">asPetitStream	^ PPStream on: self</body></methods><methods><class-id>Core.Collection</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asChoiceParser	^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])</body><body package="PetitParser">asSequenceParser	^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>*petitparser-converting</category><body package="PetitParser">asParser	"Answer a parser that succeeds and does not consume anything."		^ PPEpsilonParser new</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asParser	"Answer a parser implemented in the receiving one-argument block."	^ PPPluggableParser on: self</body></methods><methods><class-id>Core.Stream</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asPetitStream	^ self contents asPetitStream</body></methods><methods><class-id>Core.Object</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asParser	"Answer a parser accepting the receiving object."	^ PPPredicateObjectParser expect: self</body></methods><methods><class-id>Core.Object</class-id> <category>*petitparser-core-testing</category><body package="PetitParser">isPetitFailure	^ false</body><body package="PetitParser">isPetitParser	^ false</body></methods><methods><class-id>Core.Set</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asParser	self		notify: (#SetAsParserIsNoLongerSu___rderAndShouldBeAvoided &lt;&lt; #petitParser				&gt;&gt; 'Set&gt;&gt;#asParser is no longer supported. If you would like to create a PPChoiceParser from a Collection consider using #asChoiceParser instead. Sets have a unpredictable order and should be avoided')					asString.	^self asChoiceParser</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asParser	"Answer a parser implemented in the receiving one-argument block."	^ PPPluggableParser on: self</body></methods><methods><class-id>Core.Symbol</class-id> <category>*petitparser-core-converting</category><body package="PetitParser">asParser	"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."	^ PPPredicateObjectParser perform: self</body></methods><initialize><class-id>PetitParser.PPToken</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>BlockContext</name><environment>Kernel</environment><super>Kernel.Context</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TestResource</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class></st-source>