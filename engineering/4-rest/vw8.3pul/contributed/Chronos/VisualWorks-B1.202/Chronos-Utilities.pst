<?xml version="1.0"?><st-source><!-- Name: Chronos-UtilitiesBundleName: Chronos-UtilitiesBundleStructure: a Store.BundleForParcelComment: The Chronos-Utilities bundle contains the tools and utilities by means of which the contents of the Chronos Time Zones Repository are generated.  It requires that the Chronos bundle be previously installed. For more information, see the comment of the Chronos bundle, or see the Chronos web site (http://www.chronos-st.org).NOTICE: All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005-2006 by Alan L. Lovejoy.  All Rights Reserved. Usage is controlled by the Chronos License (which is included in the distribution as the contents of the file {chronos-license.txt}, and is also available from the Chronos web site {http://www.chronos-st.org/License.html}).DevelopmentPrerequisites: #(#(#bundle 'Chronos' ''))Parcel: nilParcelName: Chronos-UtilitiesPrerequisiteParcels: #(#('Chronos' ''))Version: B 1.28Date: 5:00:39 PM January 27, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (aug15.1) of August 7, 2015 on January 27, 2016 at 5:00:39 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TZAdministrational</name><environment>Chronos</environment><super>Passport.PassportObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Utility</category><attributes><package>Chronos-TZAdmin-Utility</package></attributes></class><comment><class-id>Chronos.TZAdministrational</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleToken</name><environment>Chronos</environment><super>Chronos.TZAdministrational</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resourcePath lineNumber startPosition endPosition </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleToken</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleTemporalLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleTemporalLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleCalendricalLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleTemporalLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleCalendricalLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleNonNumericYearLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleCalendricalLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleNonNumericYearLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleMinOrMaxYearLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleNonNumericYearLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleMinOrMaxYearLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleTimeTypeLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleTimeTypeLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleWeekOfMonthDayOfWeekLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleCalendricalLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleWeekOfMonthDayOfWeekLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleDayOfMonthConstrainedWeekOfMonthDayOfWeekLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleWeekOfMonthDayOfWeekLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleDayOfMonthConstrainedWeekOfMonthDayOfWeekLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleTypeSymbol</name><environment>Chronos</environment><super>Chronos.TZARuleToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleTypeSymbol</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZALinkRuleToken</name><environment>Chronos</environment><super>Chronos.TZARuleTypeSymbol</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZALinkRuleToken</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>OlsonTZDBRule</name><environment>Chronos</environment><super>Chronos.TZAdministrational</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Parsing</category><attributes><package>Chronos-TZAdmin-Parsing</package></attributes></class><comment><class-id>Chronos.OlsonTZDBRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>OlsonTZDBTransitionRule</name><environment>Chronos</environment><super>Chronos.OlsonTZDBRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name startYear endYear yearType month dayOfMonth timeOfDay offsetDelta timeSubType </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Parsing</category><attributes><package>Chronos-TZAdmin-Parsing</package></attributes></class><comment><class-id>Chronos.OlsonTZDBTransitionRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZATransitionRuleToken</name><environment>Chronos</environment><super>Chronos.TZARuleTypeSymbol</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZATransitionRuleToken</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZALeapSecondRuleToken</name><environment>Chronos</environment><super>Chronos.TZARuleTypeSymbol</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZALeapSecondRuleToken</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZAAbstractTransitionRule</name><environment>Chronos</environment><super>Passport.PassportMagnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeSubType offsetDeltaSeconds </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZAAbstractTransitionRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZATransitionRule</name><environment>Chronos</environment><super>Chronos.TZAAbstractTransitionRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key startYear endYear yearType relativity transitionSecondsSinceStartOfDay </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZATransitionRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZASingleTransitionRule</name><environment>Chronos</environment><super>Chronos.TZATransitionRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transitionDayOfYear </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZASingleTransitionRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleEndToken</name><environment>Chronos</environment><super>Chronos.TZARuleToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleEndToken</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZAHourMinuteSecondLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleTemporalLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZAHourMinuteSecondLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleTimeOfDayLiteral</name><environment>Chronos</environment><super>Chronos.TZAHourMinuteSecondLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relativity timeType </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleTimeOfDayLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZANonTransitionRule</name><environment>Chronos</environment><super>Chronos.TZAAbstractTransitionRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZANonTransitionRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZATimezoneRule</name><environment>Chronos</environment><super>Passport.PassportMagnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key ruleKey prevLink stdTimeOffsetSecondsFromUT timeTypeNameSpec transitionDateAndTime </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZATimezoneRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZABasicTZRule</name><environment>Chronos</environment><super>Chronos.TZATimezoneRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>annualPolicyElement </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZABasicTZRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZAInvariantOffsetDeltaTZRule</name><environment>Chronos</environment><super>Chronos.TZABasicTZRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>offsetDeltaSeconds </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZAInvariantOffsetDeltaTZRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZAWeekOfMonthDayOfWeekSpec</name><environment>Chronos</environment><super>Chronos.TZAdministrational</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraintOperator dayOfMonth dayOfWeek minDayOfMonthOrdinal </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZDatabase-Kernel</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZAWeekOfMonthDayOfWeekSpec</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>OlsonTZDBRulesetProcessor</name><environment>Chronos</environment><super>Chronos.TZAdministrational</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbVersion zoneInfoSourcesDirectory tzParser parseDuration generationDuration fileCount </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.OlsonTZDBRulesetProcessor</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)Transcript clear.OlsonTZDBRulesetProcessor processTimeZoneRulesTranscript cr.OlsonTZDBRulesetCompiler processTimeZoneRulesOlsonTZDBRulesetProcessor has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	fileCount	&lt;ArithmeticValue&gt;	description of fileCount	generationDuration	&lt;Object&gt;	description of generationDuration	parseDuration	&lt;Object&gt;	description of parseDuration	tzParser	&lt;OlsonTZDBRulesetParser&gt;	description of tzParser	zoneInfoSourcesDirectory	&lt;FileReference&gt;	description of zoneInfoSourcesDirectory</body></comment><class><name>TZATransitionRuleGovernedTZRule</name><environment>Chronos</environment><super>Chronos.TZATimezoneRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transitionRuleKey </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZATransitionRuleGovernedTZRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleInteger</name><environment>Chronos</environment><super>Chronos.TZARuleLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleInteger</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>OlsonTZDBLeapSecondRule</name><environment>Chronos</environment><super>Chronos.OlsonTZDBRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dateAndTime key delta </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Parsing</category><attributes><package>Chronos-TZAdmin-Parsing</package></attributes></class><comment><class-id>Chronos.OlsonTZDBLeapSecondRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleLastWeekOfMonthDayOfWeekLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleWeekOfMonthDayOfWeekLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleLastWeekOfMonthDayOfWeekLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZATimeZone</name><environment>Chronos</environment><super>Chronos.TZAdministrational</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key zoneRules </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZATimeZone</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZADateAndTimeSpec</name><environment>Chronos</environment><super>Chronos.DateAndTimeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relativity </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZDatabase-Kernel</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZADateAndTimeSpec</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZAZoneRuleToken</name><environment>Chronos</environment><super>Chronos.TZARuleTypeSymbol</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZAZoneRuleToken</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZATimeTypeSpec</name><environment>Chronos</environment><super>Chronos.ChronosObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Utility</category><attributes><package>Chronos-TZAdmin-Utility</package></attributes></class><comment><class-id>Chronos.TZATimeTypeSpec</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZABinaryTimeTypeSpec</name><environment>Chronos</environment><super>Chronos.TZATimeTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>standardTimeTypeName nonStandardTimeTypeName </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Utility</category><attributes><package>Chronos-TZAdmin-Utility</package></attributes></class><comment><class-id>Chronos.TZABinaryTimeTypeSpec</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>OlsonTZDBRulesetCompiler</name><environment>Chronos</environment><super>Chronos.OlsonTZDBRulesetProcessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transitionRules zoneRules linkRules leapSecondRules zoneDescriptorsByTzKey zoneDescriptorsByCountry timeZonePolicyFactories leapSecondSchedule </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Compiling</category><attributes><package>Chronos-TZAdmin-API</package></attributes></class><comment><class-id>Chronos.OlsonTZDBRulesetCompiler</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)Transcript cr.OlsonTZDBRulesetCompiler processTimeZoneRulesOlsonTZDBRulesetCompiler has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	leapSecondRules	&lt;Collection&gt;	description of leapSecondRules	linkRules	&lt;Dictionary&gt;	description of linkRules	timeZonePolicySpecs	&lt;Dictionary&gt;	description of timeZonePolicySpecs	transitionRules	&lt;Dictionary&gt;	description of transitionRules	zoneRules	&lt;Dictionary&gt;	description of zoneRules</body></comment><class><name>TZAMonthLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleCalendricalLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZAMonthLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleParametricTimeTypeLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleTimeTypeLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameSuffix </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleParametricTimeTypeLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleTokenInvalid</name><environment>Chronos</environment><super>Chronos.TZARuleLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expecting line </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleTokenInvalid</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleSameYearLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleNonNumericYearLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleSameYearLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>OlsonTZDBLinkRule</name><environment>Chronos</environment><super>Chronos.OlsonTZDBRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registeredName alias </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Parsing</category><attributes><package>Chronos-TZAdmin-Parsing</package></attributes></class><comment><class-id>Chronos.OlsonTZDBLinkRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZATransitionRuleEvent</name><environment>Chronos</environment><super>Passport.PassportMagnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transitionRule </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Utility</category><attributes><package>Chronos-TZAdmin-Utility</package></attributes></class><comment><class-id>Chronos.TZATransitionRuleEvent</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZATransitionRuleStartEvent</name><environment>Chronos</environment><super>Chronos.TZATransitionRuleEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Utility</category><attributes><package>Chronos-TZAdmin-Utility</package></attributes></class><comment><class-id>Chronos.TZATransitionRuleStartEvent</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZAParametricTimeTypeSpec</name><environment>Chronos</environment><super>Chronos.TZATimeTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeTypeNamePrefix timeTypeNameSuffix </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Utility</category><attributes><package>Chronos-TZAdmin-Utility</package></attributes></class><comment><class-id>Chronos.TZAParametricTimeTypeSpec</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleTimeSubtypeLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleTimeSubtypeLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZAUnaryTimeTypeSpec</name><environment>Chronos</environment><super>Chronos.TZATimeTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeTypeName </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Utility</category><attributes><package>Chronos-TZAdmin-Utility</package></attributes></class><comment><class-id>Chronos.TZAUnaryTimeTypeSpec</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZAZoneDescriptor</name><environment>Chronos</environment><super>Chronos.TZAdministrational</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key countryCode geographicCoordinates </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Utility</category><attributes><package>Chronos-TZAdmin-Utility</package></attributes></class><class><name>OlsonTZDBRulesetParser</name><environment>Chronos</environment><super>Chronos.TZAdministrational</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tokenizer lineCount ruleCounts zoneCount </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Parsing</category><attributes><package>Chronos-TZAdmin-Parsing</package></attributes></class><comment><class-id>Chronos.OlsonTZDBRulesetParser</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)Transcript clear.OlsonTZDBRulesetProcessor processTimeZoneRulesOlsonTZDBRulesetParser has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	lineCount	&lt;ArithmeticValue&gt;	description of lineCount	ruleCounts	&lt;Array&gt;	description of ruleCounts	tokenizer	&lt;OlsonTZDBRulesetTokenizer&gt;	description of tokenizer	zoneCount	&lt;ArithmeticValue&gt;	description of zoneCount</body></comment><class><name>TZARuleYearType</name><environment>Chronos</environment><super>Chronos.TZARuleLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleYearType</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZAAnnualTransitionRule</name><environment>Chronos</environment><super>Chronos.TZATransitionRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>annualDate </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZAAnnualTransitionRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZATransitionRuleset</name><environment>Chronos</environment><super>Chronos.TZAdministrational</super><private>false</private><indexed-type>none</indexed-type><inst-vars>foreverPast schedule timeZonePolicySpecs timeZonePolicy </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZATransitionRuleset</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleBinaryTimeTypeLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleTimeTypeLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nonStandardName </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleBinaryTimeTypeLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZADateAndTimeLiteral</name><environment>Chronos</environment><super>Chronos.TZARuleCalendricalLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars>monthOrdinal dayOfMonth secondsSinceStartOfDay dateAndTimeSpec relativity </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZADateAndTimeLiteral</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleDefaultToken</name><environment>Chronos</environment><super>Chronos.TZARuleToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleDefaultToken</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>WindowsToOlsonTZKeyMapGenerator</name><environment>Chronos</environment><super>Passport.PassportObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePath targetPath targetExtension </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Windows Timezone Map Generator</category><attributes><package>Chronos-Windows Timezone Map Generator</package></attributes></class><comment><class-id>Chronos.WindowsToOlsonTZKeyMapGenerator</class-id><body>This class is both Windows-specific and VisualWorks-specific. It's purpose is to translate Java's Windows-to-Olson time zone mappings into a form consumable by Chronos, and to store the result in the canonical location in the Chronos Time Zone Repository.</body></comment><class><name>OlsonTZDBZoneRule</name><environment>Chronos</environment><super>Chronos.OlsonTZDBRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name stdTimeOffsetFromUT transitionRule timeTypeNameSpec transitionDateAndTime </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Parsing</category><attributes><package>Chronos-TZAdmin-Parsing</package></attributes></class><comment><class-id>Chronos.OlsonTZDBZoneRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZAAlwaysStandardTimeTZRule</name><environment>Chronos</environment><super>Chronos.TZABasicTZRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Compiling</category><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></class><comment><class-id>Chronos.TZAAlwaysStandardTimeTZRule</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>OlsonTZDBRulesetTokenizer</name><environment>Chronos</environment><super>Chronos.TZAdministrational</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resourcePath cr lf stream lineStream lineNumber nextChar atEnd ruleTypeFactories monthNames dayOfWeekNames lastWeekOfMOnthDayOfWeekNames </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZARuleIdentifier</name><environment>Chronos</environment><super>Chronos.TZARuleLiteral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZOlsonRulesetSources-Tokenizing</category><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></class><comment><class-id>Chronos.TZARuleIdentifier</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><class><name>TZATransitionRuleEndEvent</name><environment>Chronos</environment><super>Chronos.TZATransitionRuleEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-TZAdmin-Utility</category><attributes><package>Chronos-TZAdmin-Utility</package></attributes></class><comment><class-id>Chronos.TZATransitionRuleEndEvent</class-id><body>	[Chronos] All code (classes and methods, and all associated documentation,) distributed as part of the Chronos Date/Time library are © Copyright 2005 by Alan L. Lovejoy.  All Rights Reserved. Usage is strictly controlled by the Chronos License (which is included in the distribution as the contents of the file &lt;chronos-license.txt&gt;.)</body></comment><shared-variable><name>RuleTypeFactories</name><environment>Chronos.OlsonTZDBRulesetTokenizer</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></shared-variable><shared-variable><name>MonthNames</name><environment>Chronos.OlsonTZDBRulesetTokenizer</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></shared-variable><shared-variable><name>LastWeekOfMonthDayOfWeekNames</name><environment>Chronos.OlsonTZDBRulesetTokenizer</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></shared-variable><shared-variable><name>DayOfWeekNames</name><environment>Chronos.OlsonTZDBRulesetTokenizer</environment><private>false</private><constant>false</constant><category>globals</category><initializer>nil</initializer><attributes><package>Chronos-TZAdmin-Tokenizing</package></attributes></shared-variable><shared-variable><name>ZoneRuleIndex</name><environment>Chronos.OlsonTZDBRulesetProcessor</environment><private>false</private><constant>false</constant><category>constants</category><initializer>2</initializer><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></shared-variable><shared-variable><name>LinkRuleIndex</name><environment>Chronos.OlsonTZDBRulesetProcessor</environment><private>false</private><constant>false</constant><category>constants</category><initializer>3</initializer><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></shared-variable><shared-variable><name>LeapSecondRuleIndex</name><environment>Chronos.OlsonTZDBRulesetProcessor</environment><private>false</private><constant>false</constant><category>constants</category><initializer>4</initializer><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></shared-variable><shared-variable><name>TransitionRuleIndex</name><environment>Chronos.OlsonTZDBRulesetProcessor</environment><private>false</private><constant>false</constant><category>constants</category><initializer>1</initializer><attributes><package>Chronos-TZAdmin-Compiling</package></attributes></shared-variable><shared-variable><name>ZoneRuleIndex</name><environment>Chronos.OlsonTZDBRulesetParser</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-TZAdmin-Parsing</package></attributes></shared-variable><shared-variable><name>LinkRuleIndex</name><environment>Chronos.OlsonTZDBRulesetParser</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-TZAdmin-Parsing</package></attributes></shared-variable><shared-variable><name>LeapSecondRuleIndex</name><environment>Chronos.OlsonTZDBRulesetParser</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-TZAdmin-Parsing</package></attributes></shared-variable><shared-variable><name>TransitionRuleIndex</name><environment>Chronos.OlsonTZDBRulesetParser</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Chronos-TZAdmin-Parsing</package></attributes></shared-variable><methods><class-id>Chronos.TZAdministrational class</class-id> <category>class initialization</category><body package="Chronos-TZAdmin-Utility">initialize	ChronosEnvironment canonical tzAdministrationalInstalled</body></methods><methods><class-id>Chronos.TZAdministrational class</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Utility">appOrLibraryName	^'Chronos'</body></methods><methods><class-id>Chronos.TZARuleToken</class-id> <category>printing</category><body package="Chronos-TZAdmin-Tokenizing">locationString	| stream |	stream := (String new: 25) writeStream.	self printLocationOn: stream.	^stream contents</body><body package="Chronos-TZAdmin-Tokenizing">printLocationOn: stream 	stream		nextPutAll: 'File: ';		print: resourcePath;		nextPutAll: ' line=';		print: lineNumber;		nextPutAll: ' column position=';		print: startPosition.	startPosition &lt; endPosition 		ifTrue: 			[stream				nextPutAll: '..';				print: endPosition]</body><body package="Chronos-TZAdmin-Tokenizing">printOn: stream	stream 		nextPut: ${;		nextPutAll: self type;		nextPutAll: ' | '.	self printLocationOn: stream.	stream 		nextPut: $};		space.	self printValueOn: stream</body><body package="Chronos-TZAdmin-Tokenizing">printValueOn: stream 	stream		nextPutAll: self nameOfValue;		nextPut: $=;		print: self value.</body><body package="Chronos-TZAdmin-Tokenizing">valueString	| stream |	stream := (String new: 25) writeStream.	self printValueOn: stream.	^stream contents</body></methods><methods><class-id>Chronos.TZARuleToken</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">endPosition	^endPosition</body><body package="Chronos-TZAdmin-Tokenizing">lineNumber	^lineNumber</body><body package="Chronos-TZAdmin-Tokenizing">resourcePath	^resourcePath</body><body package="Chronos-TZAdmin-Tokenizing">startPosition	^startPosition</body><body package="Chronos-TZAdmin-Tokenizing">type	^self class type</body><body package="Chronos-TZAdmin-Tokenizing">value	^self type</body></methods><methods><class-id>Chronos.TZARuleToken</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Tokenizing">initialize	lineNumber := -1.	startPosition := -1.	endPosition  := -1.</body><body package="Chronos-TZAdmin-Tokenizing">setResourcePath: aResourcePath lineNumber: aLineNumber startPosition: start endPosition: end	resourcePath := aResourcePath.	lineNumber := aLineNumber.	startPosition := start.	endPosition := end.</body></methods><methods><class-id>Chronos.TZARuleToken</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">isEndSymbol	^false</body><body package="Chronos-TZAdmin-Tokenizing">isHourMinuteSecondLiteral	^false</body><body package="Chronos-TZAdmin-Tokenizing">isSameYearLiteral	^false</body><body package="Chronos-TZAdmin-Tokenizing">representsZeroOffsetSecondsDeltaInTimeZoneRule	^false</body></methods><methods><class-id>Chronos.TZARuleToken</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#type</body></methods><methods><class-id>Chronos.TZARuleToken</class-id> <category>parsing</category><body package="Chronos-TZAdmin-Tokenizing">ifInvalidToken: invalidTokenAction ifEndSymbol: endSymbolAction	"By default, do nothing."</body></methods><methods><class-id>Chronos.TZARuleToken</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Tokenizing">= aTZRuleToken	self == aTZRuleToken ifTrue: [^true].	self class == aTZRuleToken class ifFalse: [^false].	^self value = aTZRuleToken value</body><body package="Chronos-TZAdmin-Tokenizing">hash	^self value hash</body></methods><methods><class-id>Chronos.TZARuleToken</class-id> <category>error handling</category><body package="Chronos-TZAdmin-Tokenizing">halt	self halt: self type, ': ', self locationString</body></methods><methods><class-id>Chronos.TZARuleToken class</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">type	^self name</body></methods><methods><class-id>Chronos.TZARuleToken class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Tokenizing">resourcePath: aResourcePath lineNumber: lineNumber position: position 	^self new 		setResourcePath: aResourcePath		lineNumber: lineNumber		startPosition: position		endPosition: position</body><body package="Chronos-TZAdmin-Tokenizing">resourcePath: aResourcePath lineNumber: lineNumber startPosition: start endPosition: end 	^self new 		setResourcePath: aResourcePath		lineNumber: lineNumber		startPosition: start		endPosition: end</body></methods><methods><class-id>Chronos.TZARuleLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">value	^value</body><body package="Chronos-TZAdmin-Tokenizing">value: anObject	value := anObject</body></methods><methods><class-id>Chronos.TZARuleLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#value</body></methods><methods><class-id>Chronos.TZARuleNonNumericYearLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#year</body></methods><methods><class-id>Chronos.TZARuleMinOrMaxYearLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">value	^value ifTrue: [PassportInfinity positive] ifFalse: [PassportInfinity negative]</body></methods><methods><class-id>Chronos.TZARuleMinOrMaxYearLiteral</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">isMaximunYearLiteral	^value</body><body package="Chronos-TZAdmin-Tokenizing">isMinimunYearLiteral	^value not</body></methods><methods><class-id>Chronos.TZARuleTimeTypeLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#name</body></methods><methods><class-id>Chronos.TZARuleTimeTypeLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">name	^value</body></methods><methods><class-id>Chronos.TZARuleTimeTypeLiteral</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">isBinaryType	^false</body><body package="Chronos-TZAdmin-Tokenizing">isParametricType	^false</body></methods><methods><class-id>Chronos.TZARuleTimeTypeLiteral</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Tokenizing">= aTZRuleToken	self == aTZRuleToken ifTrue: [^true].	self class == aTZRuleToken class ifFalse: [^false].	^self name = aTZRuleToken name</body><body package="Chronos-TZAdmin-Tokenizing">hash	^self name hash</body></methods><methods><class-id>Chronos.TZARuleTimeTypeLiteral</class-id> <category>converting</category><body package="Chronos-TZAdmin-Tokenizing">asTimeTypeSpec	^TZATimeTypeSpec timeTypeName: self name</body></methods><methods><class-id>Chronos.TZARuleWeekOfMonthDayOfWeekLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">dayOfWeek	^value</body></methods><methods><class-id>Chronos.TZARuleWeekOfMonthDayOfWeekLiteral</class-id> <category>converting</category><body package="Chronos-TZAdmin-Tokenizing">asAnnualDateInMonth: monthOrdinal 	^self asWeekOfMonthDayOfWeekInMonth: monthOrdinal</body><body package="Chronos-TZAdmin-Tokenizing">asDateInYear: year month: monthOrdinal	^(self asWeekOfMonthDayOfWeekInMonth: monthOrdinal) inYear: year</body><body package="Chronos-TZAdmin-Tokenizing">asWeekOfMonthDayOfWeekInMonth: monthOrdinal 	^self subclassResponsibility</body></methods><methods><class-id>Chronos.TZARuleDayOfMonthConstrainedWeekOfMonthDayOfWeekLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#dayOfWeek</body></methods><methods><class-id>Chronos.TZARuleDayOfMonthConstrainedWeekOfMonthDayOfWeekLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">constraintOperator	^value constraintOperator</body><body package="Chronos-TZAdmin-Tokenizing">dayOfMonth	^value dayOfMonth</body><body package="Chronos-TZAdmin-Tokenizing">dayOfWeek	^value dayOfWeek</body></methods><methods><class-id>Chronos.TZARuleDayOfMonthConstrainedWeekOfMonthDayOfWeekLiteral</class-id> <category>converting</category><body package="Chronos-TZAdmin-Tokenizing">asWeekOfMonthDayOfWeekInMonth: monthOrdinal 	^value asWeekOfMonthDayOfWeekInMonth: monthOrdinal</body></methods><methods><class-id>Chronos.TZARuleTypeSymbol</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">keyword	^self subclassResponsibility</body><body package="Chronos-TZAdmin-Tokenizing">value	^self keyword</body></methods><methods><class-id>Chronos.TZARuleTypeSymbol</class-id> <category>parsing</category><body package="Chronos-TZAdmin-Tokenizing">parseWithSyntax: aParser for: aVisitor	^self subclassResponsibility</body></methods><methods><class-id>Chronos.TZALinkRuleToken</class-id> <category>parsing</category><body package="Chronos-TZAdmin-Tokenizing">parseWithSyntax: aParser for: aVisitor	^aParser parseLinkRuleFor: aVisitor</body></methods><methods><class-id>Chronos.TZALinkRuleToken</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">keyword	^#LINK</body></methods><methods><class-id>Chronos.OlsonTZDBRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Parsing">key	^self subclassResponsibility</body><body package="Chronos-TZAdmin-Parsing">sortValue	^self key</body></methods><methods><class-id>Chronos.OlsonTZDBRule</class-id> <category>visitor collaboration</category><body package="Chronos-TZAdmin-Parsing">defineIn: aTZRuleVisitor	^self subclassResponsibility</body></methods><methods><class-id>Chronos.OlsonTZDBTransitionRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Parsing">dayOfMonth	^dayOfMonth</body><body package="Chronos-TZAdmin-Parsing">dayOfMonth: anObject	dayOfMonth := anObject</body><body package="Chronos-TZAdmin-Parsing">endYear	^endYear</body><body package="Chronos-TZAdmin-Parsing">endYear: anObject	endYear := anObject</body><body package="Chronos-TZAdmin-Parsing">key	^name key</body><body package="Chronos-TZAdmin-Parsing">month	^month</body><body package="Chronos-TZAdmin-Parsing">month: anObject	month := anObject</body><body package="Chronos-TZAdmin-Parsing">name	^name</body><body package="Chronos-TZAdmin-Parsing">name: anObject	name := anObject</body><body package="Chronos-TZAdmin-Parsing">offsetDelta	^offsetDelta</body><body package="Chronos-TZAdmin-Parsing">offsetDelta: anObject	offsetDelta := anObject</body><body package="Chronos-TZAdmin-Parsing">offsetDeltaSeconds	^offsetDelta asSeconds</body><body package="Chronos-TZAdmin-Parsing">relativity	^timeOfDay relativity</body><body package="Chronos-TZAdmin-Parsing">sortValue	^startYear value</body><body package="Chronos-TZAdmin-Parsing">startYear	^startYear</body><body package="Chronos-TZAdmin-Parsing">startYear: anObject	startYear := anObject</body><body package="Chronos-TZAdmin-Parsing">timeOfDay	^timeOfDay</body><body package="Chronos-TZAdmin-Parsing">timeOfDay: anObject	timeOfDay := anObject</body><body package="Chronos-TZAdmin-Parsing">timeSubType	^timeSubType</body><body package="Chronos-TZAdmin-Parsing">timeSubType: anObject	timeSubType := anObject</body><body package="Chronos-TZAdmin-Parsing">yearType	^yearType</body><body package="Chronos-TZAdmin-Parsing">yearType: anObject	yearType := anObject</body></methods><methods><class-id>Chronos.OlsonTZDBTransitionRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Parsing">printOn: stream	stream		nextPutAll: 'Transition Rule: ';		nextPutAll: name valueString;		nextPutAll: ' startYear: ';		nextPutAll: startYear valueString;		nextPutAll: ' endYear: ';		nextPutAll: endYear valueString;		nextPutAll: ' month: ';		nextPutAll: month valueString;		nextPutAll: ' dayOfMonth: ';		nextPutAll: dayOfMonth valueString;		nextPutAll: ' timeOfDay: ';		nextPutAll: timeOfDay valueString;		nextPutAll: ' offsetDelta: ';		nextPutAll: offsetDelta valueString;		nextPutAll: ' timeSubType: ';		nextPutAll: timeSubType valueString</body></methods><methods><class-id>Chronos.OlsonTZDBTransitionRule</class-id> <category>testing</category><body package="Chronos-TZAdmin-Parsing">isAnnualTransition	^self isSingleTransition not</body><body package="Chronos-TZAdmin-Parsing">isSingleTransition	^endYear isSameYearLiteral or: [startYear = endYear]</body></methods><methods><class-id>Chronos.OlsonTZDBTransitionRule</class-id> <category>visitor collaboration</category><body package="Chronos-TZAdmin-Parsing">defineIn: aTZRuleVisitor	^aTZRuleVisitor defineTransitionRule: self</body></methods><methods><class-id>Chronos.OlsonTZDBTransitionRule</class-id> <category>converting</category><body package="Chronos-TZAdmin-Parsing">asNormalizedTransitionRule	^self isSingleTransition 		ifTrue: 			[TZASingleTransitionRule 				key: name value				startYear: startYear value				endYear: (endYear isSameYearLiteral 						ifTrue: [startYear value]						ifFalse: [endYear value])				yearType: yearType value				timeSubType: timeSubType value				offsetDelta: offsetDelta asSeconds				transitionDayOfYear: ((dayOfMonth asAnnualDateInMonth: month value) dayOfYearOrdinalInYear: startYear value)				transitionSecondsSinceStartOfDay: timeOfDay secondsSinceStartOfDay				relatitivity: timeOfDay relativity]		ifFalse: 			[TZAAnnualTransitionRule 				key: name value				startYear: startYear value				endYear: (endYear isSameYearLiteral 						ifTrue: [startYear value]						ifFalse: [endYear value])				yearType: yearType value				timeSubType: timeSubType value				offsetDelta: offsetDelta asSeconds				annualDate: (dayOfMonth asAnnualDateInMonth: month value)				transitionSecondsSinceStartOfDay: timeOfDay secondsSinceStartOfDay				relatitivity: timeOfDay relativity]</body></methods><methods><class-id>Chronos.TZATransitionRuleToken</class-id> <category>parsing</category><body package="Chronos-TZAdmin-Tokenizing">parseWithSyntax: aParser for: aVisitor	^aParser parseTransitionRuleFor: aVisitor</body></methods><methods><class-id>Chronos.TZATransitionRuleToken</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">keyword	^#RULE</body></methods><methods><class-id>Chronos.TZALeapSecondRuleToken</class-id> <category>parsing</category><body package="Chronos-TZAdmin-Tokenizing">parseWithSyntax: aParser for: aVisitor	^aParser parseLeapSecondRuleFor: aVisitor</body></methods><methods><class-id>Chronos.TZALeapSecondRuleToken</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">keyword	^#LEAP</body></methods><methods><class-id>Chronos.TZAAbstractTransitionRule</class-id> <category>converting</category><body package="Chronos-TZAdmin-Compiling">annualPolicyElementFor: aTZRule transitioningTo: nextTransitionRule 	| commonAbbreviation |	commonAbbreviation := aTZRule commonAbbreviationUsing: self.	^nextTransitionRule 		newAnnualPolicyElementWithStdTimeOffsetSeconds: aTZRule stdTimeOffsetSecondsFromUT		offsetDeltaSeconds: self offsetDeltaSeconds		commonAbbreviation: commonAbbreviation</body><body package="Chronos-TZAdmin-Compiling">asNormalizedTransitionRule	^self</body><body package="Chronos-TZAdmin-Compiling">asTransitionRuleToEndOfYear	^self</body><body package="Chronos-TZAdmin-Compiling">commonAbbreviationFrom: aTimeTypeNameSpec 	^aTimeTypeNameSpec 		nameFromSubtype: self timeSubType		isStandardTime: self isStandardTime</body></methods><methods><class-id>Chronos.TZAAbstractTransitionRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">offsetDeltaSeconds	^offsetDeltaSeconds</body><body package="Chronos-TZAdmin-Compiling">ruleType	^self subclassResponsibility</body><body package="Chronos-TZAdmin-Compiling">timeSubType	^timeSubType</body></methods><methods><class-id>Chronos.TZAAbstractTransitionRule</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Compiling">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	timeSubType := ''.	offsetDeltaSeconds := 0</body><body package="Chronos-TZAdmin-Compiling">setOffsetDeltaSeconds: seconds	self assertMutability.	offsetDeltaSeconds := seconds</body><body package="Chronos-TZAdmin-Compiling">setTimeSubType: tsType	self assertMutability.	timeSubType := tsType == nil ifTrue: [''] ifFalse: [tsType].</body></methods><methods><class-id>Chronos.TZAAbstractTransitionRule</class-id> <category>testing</category><body package="Chronos-TZAdmin-Compiling">hasNoEndYear	^true</body><body package="Chronos-TZAdmin-Compiling">hasNoStartYear	^true</body><body package="Chronos-TZAdmin-Compiling">isStandardTime	^offsetDeltaSeconds = 0</body></methods><methods><class-id>Chronos.TZAAbstractTransitionRule</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Compiling">= otherTransitionRule	^self == otherTransitionRule</body><body package="Chronos-TZAdmin-Compiling">hash	^self identityHash</body></methods><methods><class-id>Chronos.TZAAbstractTransitionRule</class-id> <category>private</category><body package="Chronos-TZAdmin-Compiling">newAnnualPolicyElementWithStdTimeOffsetSeconds: stdTimeOffsetSecondsFromUTC offsetDeltaSeconds: offsetDelta commonAbbreviation: commonAbbreviation 	^self subclassResponsibility</body></methods><methods><class-id>Chronos.TZAAbstractTransitionRule class</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">appOrLibraryName	^'Chronos'</body></methods><methods><class-id>Chronos.TZATransitionRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">endYear	^endYear</body><body package="Chronos-TZAdmin-Compiling">key	^key</body><body package="Chronos-TZAdmin-Compiling">relativity	^relativity</body><body package="Chronos-TZAdmin-Compiling">startYear	^startYear</body><body package="Chronos-TZAdmin-Compiling">transitionSecondsSinceStartOfDay	^transitionSecondsSinceStartOfDay</body><body package="Chronos-TZAdmin-Compiling">yearType	^yearType</body></methods><methods><class-id>Chronos.TZATransitionRule</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Compiling">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	transitionSecondsSinceStartOfDay := 0</body><body package="Chronos-TZAdmin-Compiling">setKey: aKey startYear: sYear endYear: eYear yearType: yType	self assertMutability.	key := aKey.	startYear := sYear.	endYear := eYear.	yearType := yType.</body></methods><methods><class-id>Chronos.TZATransitionRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Compiling">printOn: stream	stream		nextPutAll: self ruleType;		nextPutAll: ' key=';		print: key;		nextPutAll: ' startYear=';		print: startYear;		nextPutAll: ' endYear=';		print: endYear;		nextPutAll: ' yearType=';		print: yearType;		nextPutAll: ' timeSubType=';		print: timeSubType;		nextPutAll: ' offsetDeltaSeconds=';		print: offsetDeltaSeconds</body></methods><methods><class-id>Chronos.TZATransitionRule</class-id> <category>testing</category><body package="Chronos-TZAdmin-Compiling">hasNoEndYear	^endYear = PassportInfinity positive</body><body package="Chronos-TZAdmin-Compiling">hasNoStartYear	^startYear = PassportInfinity negative</body></methods><methods><class-id>Chronos.TZATransitionRule</class-id> <category>converting</category><body package="Chronos-TZAdmin-Compiling">asTransitionRuleToEndOfYear	^TZANonTransitionRule 		timeSubType: self timeSubType		offsetDelta: self offsetDeltaSeconds</body></methods><methods><class-id>Chronos.TZASingleTransitionRule</class-id> <category>private</category><body package="Chronos-TZAdmin-Compiling">newAnnualPolicyElementWithStdTimeOffsetSeconds: stdTimeOffsetSecondsFromUTC offsetDeltaSeconds: offsetDelta commonAbbreviation: commonAbbreviation 	^UntilAnnualDayOfYearTimeZoneTransitionFactory 		offsetSeconds: stdTimeOffsetSecondsFromUTC + offsetDelta		stdTimeOffsetSeconds: stdTimeOffsetSecondsFromUTC		commonAbbreviation: commonAbbreviation		transitionDayOfYear: transitionDayOfYear		transitionSecondsSinceStartOfDay: transitionSecondsSinceStartOfDay		relativity: relativity</body></methods><methods><class-id>Chronos.TZASingleTransitionRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">ruleType	^#SingleTransitionRule</body><body package="Chronos-TZAdmin-Compiling">transitionDayOfYear	^transitionDayOfYear</body></methods><methods><class-id>Chronos.TZASingleTransitionRule</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Compiling">setTransitionDayOfYear: dayOfYear transitionSecondsSinceStartOfDay: seconds relativity: timeRelativity	self assertMutability.	transitionDayOfYear := dayOfYear.	transitionSecondsSinceStartOfDay := seconds.	relativity := timeRelativity.</body></methods><methods><class-id>Chronos.TZASingleTransitionRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Compiling">printOn: stream	super printOn: stream.	stream		nextPutAll: ' transitionDayOfYear=';		print: transitionDayOfYear;		nextPutAll: ' transitionSecondsSinceStartOfDay=';		print: transitionSecondsSinceStartOfDay;		nextPutAll: ' relativity=';		print: relativity</body></methods><methods><class-id>Chronos.TZASingleTransitionRule</class-id> <category>private-comparing</category><body package="Chronos-TZAdmin-Compiling">compareToAnnualTransitionRule: anAnnualTransitionRule	| diff |	diff := anAnnualTransitionRule annualDate minDayOfYearOrdinal - transitionDayOfYear.	diff = 0 ifFalse: [^diff].	^anAnnualTransitionRule transitionSecondsSinceStartOfDay - transitionSecondsSinceStartOfDay</body><body package="Chronos-TZAdmin-Compiling">compareToSingleTransitionRule: aSingleTransitionRule	| diff |	diff := aSingleTransitionRule transitionDayOfYear - transitionDayOfYear.	diff = 0 ifFalse: [^diff].	^aSingleTransitionRule transitionSecondsSinceStartOfDay - transitionSecondsSinceStartOfDay</body></methods><methods><class-id>Chronos.TZASingleTransitionRule</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Compiling">compareTo: otherRule	self == otherRule ifTrue: [^0].	^[otherRule compareToSingleTransitionRule: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == otherRule and: [ex message selector == #compareToSingleTransitionRule:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.TZASingleTransitionRule class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Compiling">key: aKey startYear: sYear endYear: eYear yearType: yType timeSubType: tsType offsetDelta: offsetDeltaSeconds transitionDayOfYear: dayOfYear transitionSecondsSinceStartOfDay: transitionSeconds relatitivity: relativity 	^(self new)		setKey: aKey			startYear: sYear			endYear: eYear			yearType: yType;		setTimeSubType: tsType;		setOffsetDeltaSeconds: offsetDeltaSeconds;		setTransitionDayOfYear: dayOfYear			transitionSecondsSinceStartOfDay: transitionSeconds			relativity: relativity;		beImmutable</body></methods><methods><class-id>Chronos.TZARuleEndToken</class-id> <category>parsing</category><body package="Chronos-TZAdmin-Tokenizing">ifInvalidToken: invalidTokenAction ifEndSymbol: endSymbolAction	^endSymbolAction value: self</body><body package="Chronos-TZAdmin-Tokenizing">parseWithSyntax: aParser for: aVisitor	^aParser handleLegalEndSymbol: self for: aVisitor</body></methods><methods><class-id>Chronos.TZARuleEndToken</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">isEndSymbol	^true</body></methods><methods><class-id>Chronos.TZAHourMinuteSecondLiteral</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">isHourMinuteSecondLiteral	^true</body><body package="Chronos-TZAdmin-Tokenizing">representsZeroOffsetSecondsDeltaInTimeZoneRule	^self asSeconds = 0</body></methods><methods><class-id>Chronos.TZAHourMinuteSecondLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#seconds</body></methods><methods><class-id>Chronos.TZAHourMinuteSecondLiteral</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Tokenizing">initialize	super initialize.	value := 0</body></methods><methods><class-id>Chronos.TZAHourMinuteSecondLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">asSeconds	^value</body></methods><methods><class-id>Chronos.TZARuleTimeOfDayLiteral</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">timeIsNominal	"What Olson calls 'wall clock time.'"	^timeType = #nominal</body><body package="Chronos-TZAdmin-Tokenizing">timeIsStandard	^timeType = #standard</body><body package="Chronos-TZAdmin-Tokenizing">timeIsUTC	^timeType = #universal</body></methods><methods><class-id>Chronos.TZARuleTimeOfDayLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">relativity	^relativity</body><body package="Chronos-TZAdmin-Tokenizing">secondsSinceStartOfDay	^value</body></methods><methods><class-id>Chronos.TZARuleTimeOfDayLiteral</class-id> <category>printing</category><body package="Chronos-TZAdmin-Tokenizing">printValueOn: stream 	super printValueOn: stream.	stream		nextPutAll: ' relativity=';		print: relativity.</body></methods><methods><class-id>Chronos.TZARuleTimeOfDayLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#secondsSinceStartOfDay</body></methods><methods><class-id>Chronos.TZARuleTimeOfDayLiteral</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Tokenizing">beNominalTime	"What Olson calls 'wall clock time.'"	relativity := #nominal</body><body package="Chronos-TZAdmin-Tokenizing">beStandardTime	relativity := #standard</body><body package="Chronos-TZAdmin-Tokenizing">beUniversalTime	relativity := #universal</body><body package="Chronos-TZAdmin-Tokenizing">initialize	super initialize.	relativity := #nominal</body></methods><methods><class-id>Chronos.TZANonTransitionRule</class-id> <category>private</category><body package="Chronos-TZAdmin-Compiling">newAnnualPolicyElementWithStdTimeOffsetSeconds: stdTimeOffsetSecondsFromUTC offsetDeltaSeconds: offsetDelta commonAbbreviation: commonAbbreviation 	^UntilEndOfYearTimeZoneTransitionFactory 		offsetSeconds: stdTimeOffsetSecondsFromUTC + offsetDelta		stdTimeOffsetSeconds: stdTimeOffsetSecondsFromUTC		commonAbbreviation: commonAbbreviation</body></methods><methods><class-id>Chronos.TZANonTransitionRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">ruleType	^#NonTransitionRule</body></methods><methods><class-id>Chronos.TZANonTransitionRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Compiling">printOn: stream	stream		nextPutAll: self ruleType;		nextPutAll: ' timeSubType=';		print: timeSubType;		nextPutAll: ' offsetDeltaSeconds=';		print: offsetDeltaSeconds</body></methods><methods><class-id>Chronos.TZANonTransitionRule</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Compiling">compareTo: otherRule	^self shouldNotImplement</body></methods><methods><class-id>Chronos.TZANonTransitionRule class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Compiling">timeSubType: tsType  offsetDelta: offsetDeltaSeconds	^self new 		setTimeSubType: tsType;		setOffsetDeltaSeconds: offsetDeltaSeconds;		beImmutable</body></methods><methods><class-id>Chronos.TZATimezoneRule</class-id> <category>private</category><body package="Chronos-TZAdmin-Compiling">basicGenerateTZAnnualPolicyElementsFor: aTZRulesetCompiler forFinalYearSince: effectiveDateAndTime untilTransitionDateAndTimeOn: stream 	^self subclassResponsibility</body><body package="Chronos-TZAdmin-Compiling">setRuleKey	| stream |	stream := (String new: 50) writeStream.	stream		nextPutAll: self key;		nextPut: $:;		print: self stdTimeOffsetSecondsFromUT;		nextPut: $:;		nextPutAll: timeTypeNameSpec key.	ruleKey := stream contents asSymbol</body></methods><methods><class-id>Chronos.TZATimezoneRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">effectiveDateAndTime	| prev |	prev := self prevWithEarlierFinalYear.	^prev == nil ifFalse: [prev transitionDateAndTime]</body><body package="Chronos-TZAdmin-Compiling">effectiveYear	| effectiveDateAndTime |	effectiveDateAndTime := self effectiveDateAndTime.	^effectiveDateAndTime == nil ifFalse: [effectiveDateAndTime year]</body><body package="Chronos-TZAdmin-Compiling">finalFullyDefinedYear	^transitionDateAndTime == nil ifFalse: [transitionDateAndTime year - 1]</body><body package="Chronos-TZAdmin-Compiling">finalYear	^transitionDateAndTime == nil 		ifFalse: 			[transitionDateAndTime isAtStartOfYear 				ifTrue: [transitionDateAndTime year - 1]				ifFalse: [transitionDateAndTime year]]</body><body package="Chronos-TZAdmin-Compiling">key	^key</body><body package="Chronos-TZAdmin-Compiling">prevLink	^prevLink</body><body package="Chronos-TZAdmin-Compiling">prevWithEarlierFinalYear	| this prev |	this := self.	[prev := this prevLink.	prev == nil ifTrue: [^nil].	this finalYear = prev finalYear]  whileTrue: [this := prev].	^prev</body><body package="Chronos-TZAdmin-Compiling">relativity	^transitionDateAndTime == nil		ifTrue: [#nominal]		ifFalse: [transitionDateAndTime relativity]</body><body package="Chronos-TZAdmin-Compiling">ruleKey	^ruleKey</body><body package="Chronos-TZAdmin-Compiling">stdTimeOffsetSecondsFromUT	^stdTimeOffsetSecondsFromUT</body><body package="Chronos-TZAdmin-Compiling">timeTypeNameSpec	^timeTypeNameSpec</body><body package="Chronos-TZAdmin-Compiling">transitionDateAndTime	^transitionDateAndTime</body><body package="Chronos-TZAdmin-Compiling">type	^self subclassResponsibility</body></methods><methods><class-id>Chronos.TZATimezoneRule</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Compiling">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	stdTimeOffsetSecondsFromUT := 0.</body><body package="Chronos-TZAdmin-Compiling">setKey: aSymbol stdTimeOffsetSeconds: offsetSeconds timeTypeNameSpec: nameSpec transitionDateAndTime: aDateAndTimeSpec	self assertMutability.	key := aSymbol.	stdTimeOffsetSecondsFromUT := offsetSeconds.	timeTypeNameSpec := nameSpec.	transitionDateAndTime := aDateAndTimeSpec.	self setRuleKey</body><body package="Chronos-TZAdmin-Compiling">setPrevLink: aTZRule	self assertMutability.	prevLink := aTZRule</body></methods><methods><class-id>Chronos.TZATimezoneRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Compiling">printOn: stream	stream		nextPutAll: self type;		nextPutAll: ': ';		print: self key;		nextPutAll: ' stdTimeOffsetSecondsFromUT: ';		print: stdTimeOffsetSecondsFromUT;		nextPutAll: ' timeTypeName: ';		print: timeTypeNameSpec.</body><body package="Chronos-TZAdmin-Compiling">printOnTransitionDateAndTimeOn: stream	transitionDateAndTime == nil		ifFalse: 			[stream 				nextPutAll: ' until: ';				print: transitionDateAndTime]</body></methods><methods><class-id>Chronos.TZATimezoneRule</class-id> <category>testing</category><body package="Chronos-TZAdmin-Compiling">fullyDefinesFinalYear	^transitionDateAndTime == nil or: [transitionDateAndTime isAtStartOfYear].</body><body package="Chronos-TZAdmin-Compiling">isAlwaysStandardTime	^false</body></methods><methods><class-id>Chronos.TZATimezoneRule</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Compiling">compareTo: otherTZRule 	| otherTransitionDateAndTime |	self == otherTZRule ifTrue: [^0].	otherTransitionDateAndTime := otherTZRule transitionDateAndTime.	transitionDateAndTime == otherTransitionDateAndTime ifTrue: [^0].	^transitionDateAndTime == nil 		ifTrue: [1]		ifFalse: 			[otherTransitionDateAndTime == nil 				ifTrue: [-1]				ifFalse: [transitionDateAndTime compareTo: otherTransitionDateAndTime]]</body></methods><methods><class-id>Chronos.TZATimezoneRule</class-id> <category>queries</category><body package="Chronos-TZAdmin-Compiling">commonAbbreviationUsing: aTransitionRule 	^aTransitionRule commonAbbreviationFrom: self timeTypeNameSpec</body></methods><methods><class-id>Chronos.TZATimezoneRule</class-id> <category>converting</category><body package="Chronos-TZAdmin-Compiling">asNormalizedTimeZoneRule	^self</body></methods><methods><class-id>Chronos.TZATimezoneRule</class-id> <category>enumerating</category><body package="Chronos-TZAdmin-Compiling">allPreviousWithSameFinalYearDo: block1 	transitionDateAndTime == nil ifTrue: [^self].	prevLink == nil 		ifFalse: 			[self finalYear = prevLink finalYear 				ifTrue: 					[prevLink allPreviousWithSameFinalYearDo: block1.					block1 value: prevLink]]</body></methods><methods><class-id>Chronos.TZATimezoneRule</class-id> <category>compiler collaboration</category><body package="Chronos-TZAdmin-Compiling">generateAnnualTZPolicyElementsFor: aTZRulesetCompiler since: startingTime toEndOfYearOn: stream 	^self subclassResponsibility</body><body package="Chronos-TZAdmin-Compiling">generateTimeZonePolicyElementsFor: aTZRulesetCompiler fromStartOfYear: startYear toLastFullyDefinedYearOn: stream 	^self subclassResponsibility</body><body package="Chronos-TZAdmin-Compiling">generateTimeZonePolicyElementsFor: aTZRulesetCompiler on: stream	| annualPolicyElementStream prevWithEarlierFinalYear startingTime effectiveYear prevZoneRule |	annualPolicyElementStream := nil.	prevWithEarlierFinalYear := self prevWithEarlierFinalYear.	prevWithEarlierFinalYear == nil 		ifTrue: [effectiveYear := nil]		ifFalse: 			[startingTime := prevWithEarlierFinalYear transitionDateAndTime.			effectiveYear := startingTime year.			startingTime isAtStartOfYear				ifFalse: 					[annualPolicyElementStream := (Array new: 3) writeStream.					prevWithEarlierFinalYear						generateTZAnnualPolicyElementsFor: aTZRulesetCompiler						forFinalYearUntilTransitionDateAndTimeOn: annualPolicyElementStream]].	prevZoneRule := nil.	self allPreviousWithSameFinalYearDo: 		[:zoneRule | 		annualPolicyElementStream == nil 			ifTrue: 				[self fullyDefinesFinalYear 					ifFalse: 						[^self							generateTimeZonePolicyElementsFor: aTZRulesetCompiler 							fromStartOfYear: effectiveYear 							toLastFullyDefinedYearOn: stream].				annualPolicyElementStream := (Array new: 3) writeStream]			ifFalse: 				[prevZoneRule == nil					ifTrue: 						[zoneRule generateAnnualTZPolicyElementsFor: aTZRulesetCompiler since: startingTime toEndOfYearOn: annualPolicyElementStream.						stream nextPut: (TimeZoneAnnualTransitionPolicyFactory key: self key effectiveYear: effectiveYear annuallyRecurringTransitions: annualPolicyElementStream contents).							effectiveYear := effectiveYear + 1.						self fullyDefinesFinalYear 							ifFalse: 								[^self									generateTimeZonePolicyElementsFor: aTZRulesetCompiler 									fromStartOfYear: effectiveYear 									toLastFullyDefinedYearOn: stream].						annualPolicyElementStream := (Array new: 3) writeStream]].		zoneRule 			generateTZAnnualPolicyElementsFor: aTZRulesetCompiler			forFinalYearUntilTransitionDateAndTimeOn: annualPolicyElementStream.		prevZoneRule := zoneRule.		startingTime := zoneRule transitionDateAndTime].	annualPolicyElementStream == nil 		ifFalse: 			[self generateAnnualTZPolicyElementsFor: aTZRulesetCompiler since: startingTime toEndOfYearOn: annualPolicyElementStream.			stream nextPut: (TimeZoneAnnualTransitionPolicyFactory key: self key effectiveYear: effectiveYear annuallyRecurringTransitions: annualPolicyElementStream contents).			effectiveYear := effectiveYear + 1.			(transitionDateAndTime == nil or: [effectiveYear &lt;= self finalYear]) ifFalse: [^self]].	^self 		generateTimeZonePolicyElementsFor: aTZRulesetCompiler 		fromStartOfYear: effectiveYear 		toLastFullyDefinedYearOn: stream</body><body package="Chronos-TZAdmin-Compiling">generateTZAnnualPolicyElementsFor: aTZRulesetCompiler forFinalYearUntilTransitionDateAndTimeOn: stream 	| effectiveDateAndTime |	effectiveDateAndTime := nil.	self allPreviousWithSameFinalYearDo: 			[:prevZoneRule | 			prevZoneRule 				basicGenerateTZAnnualPolicyElementsFor: aTZRulesetCompiler				forFinalYearSince: effectiveDateAndTime				untilTransitionDateAndTimeOn: stream.			effectiveDateAndTime := prevZoneRule transitionDateAndTime].	self 		basicGenerateTZAnnualPolicyElementsFor: aTZRulesetCompiler		forFinalYearSince: effectiveDateAndTime		untilTransitionDateAndTimeOn: stream</body></methods><methods><class-id>Chronos.TZATimezoneRule class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Compiling">key: aSymbol stdTimeOffsetSeconds: offsetSeconds timeTypeNameSpec: nameSpec transitionDateAndTime: aDateAndTimeSpec	^(TZAAlwaysStandardTimeTZRule new)		setKey: aSymbol			stdTimeOffsetSeconds: offsetSeconds			timeTypeNameSpec: nameSpec			transitionDateAndTime: aDateAndTimeSpec</body><body package="Chronos-TZAdmin-Compiling">key: aSymbol stdTimeOffsetSeconds: offsetSeconds timeTypeNameSpec: nameSpec transitionDateAndTime: aDateAndTimeSpec offsetDeltaSeconds: anInteger 	^(TZAInvariantOffsetDeltaTZRule new)		setKey: aSymbol			stdTimeOffsetSeconds: offsetSeconds			timeTypeNameSpec: nameSpec			transitionDateAndTime: aDateAndTimeSpec;		setOffsetDeltaSeconds: anInteger</body><body package="Chronos-TZAdmin-Compiling">key: aSymbol stdTimeOffsetSeconds: offsetSeconds timeTypeNameSpec: nameSpec transitionDateAndTime: aDateAndTimeSpec transitionRuleKey: transitionRuleKey 	^(TZATransitionRuleGovernedTZRule new)		setKey: aSymbol			stdTimeOffsetSeconds: offsetSeconds			timeTypeNameSpec: nameSpec			transitionDateAndTime: aDateAndTimeSpec;		setTransitionRuleKey: transitionRuleKey</body></methods><methods><class-id>Chronos.TZATimezoneRule class</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">appOrLibraryName	^'Chronos'</body></methods><methods><class-id>Chronos.TZABasicTZRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">annualPolicyElementForEffectiveYear: effectiveYear 	| endYear |	endYear := self finalYear.	(effectiveYear == nil or: [endYear == nil or: [effectiveYear &lt; endYear or: [effectiveYear = endYear and: [transitionDateAndTime isAtStartOfYear ]]]]) 		ifFalse: 			[^UntilAnnualDayOfYearTimeZoneTransitionFactory 				offsetSeconds: self offsetSecondsFromUT				stdTimeOffsetSeconds: self stdTimeOffsetSecondsFromUT				commonAbbreviation: (timeTypeNameSpec nameFromSubtype: '' isStandardTime: self isAlwaysStandardTime)				transitionDayOfYear: transitionDateAndTime dayOfYearOrdinal				transitionSecondsSinceStartOfDay: transitionDateAndTime secondsSinceStartOfDay				relativity: transitionDateAndTime relativity].	annualPolicyElement == nil 		ifTrue: 			[annualPolicyElement := 				UntilEndOfYearTimeZoneTransitionFactory 					offsetSeconds: self offsetSecondsFromUT					stdTimeOffsetSeconds: self stdTimeOffsetSecondsFromUT					commonAbbreviation: (timeTypeNameSpec nameFromSubtype: '' isStandardTime: self isAlwaysStandardTime)].	^annualPolicyElement</body><body package="Chronos-TZAdmin-Compiling">offsetDeltaSeconds	^0</body><body package="Chronos-TZAdmin-Compiling">offsetSecondsFromUT	^self stdTimeOffsetSecondsFromUT + self offsetDeltaSeconds</body></methods><methods><class-id>Chronos.TZABasicTZRule</class-id> <category>private</category><body package="Chronos-TZAdmin-Compiling">basicGenerateTZAnnualPolicyElementsFor: aTZRulesetCompiler forFinalYearSince: effectiveDateAndTime untilTransitionDateAndTimeOn: stream 	stream nextPut: 		(UntilAnnualDayOfYearTimeZoneTransitionFactory 			offsetSeconds: self offsetSecondsFromUT			stdTimeOffsetSeconds: self stdTimeOffsetSecondsFromUT			commonAbbreviation: (timeTypeNameSpec nameFromSubtype: '' isStandardTime: self isAlwaysStandardTime)			transitionDayOfYear: transitionDateAndTime dayOfYearOrdinal			transitionSecondsSinceStartOfDay: transitionDateAndTime secondsSinceStartOfDay			relativity: self relativity)</body></methods><methods><class-id>Chronos.TZABasicTZRule</class-id> <category>compiler collaboration</category><body package="Chronos-TZAdmin-Compiling">generateAnnualTZPolicyElementsFor: aTZRulesetCompiler since: startingTime toEndOfYearOn: stream 	stream nextPut: (self annualPolicyElementForEffectiveYear: nil)</body><body package="Chronos-TZAdmin-Compiling">generateTimeZonePolicyElementsFor: aTZRulesetCompiler fromStartOfYear: startYear toLastFullyDefinedYearOn: stream 	| annualPolicyElementStream |	(startYear == nil or: [self fullyDefinesFinalYear or: [self finalYear &gt; startYear]])		ifTrue: 			[annualPolicyElementStream := (Array new: 3) writeStream.			annualPolicyElementStream 				nextPut: (self annualPolicyElementForEffectiveYear: startYear).			stream nextPut: 				(TimeZoneAnnualTransitionPolicyFactory 					key: self key					effectiveYear: startYear					annuallyRecurringTransitions: annualPolicyElementStream contents)]</body></methods><methods><class-id>Chronos.TZAInvariantOffsetDeltaTZRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">offsetDeltaSeconds	^offsetDeltaSeconds</body><body package="Chronos-TZAdmin-Compiling">type	^#InvariantOffsetDeltaTZRule</body></methods><methods><class-id>Chronos.TZAInvariantOffsetDeltaTZRule</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Compiling">initialize	"Initialize a newly created instance. This method must answer the receiver. Fail if the receiver is not mutable."	super initialize.	offsetDeltaSeconds := 0</body><body package="Chronos-TZAdmin-Compiling">setOffsetDeltaSeconds: anInteger	self assertMutability.	offsetDeltaSeconds := anInteger</body></methods><methods><class-id>Chronos.TZAInvariantOffsetDeltaTZRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Compiling">printOn: stream	super printOn: stream.	stream		nextPutAll: ' offsetDeltaSeconds=';		print: offsetDeltaSeconds.	self printOnTransitionDateAndTimeOn: stream.</body></methods><methods><class-id>Chronos.TZAWeekOfMonthDayOfWeekSpec</class-id> <category>printing</category><body package="Chronos-TZAdmin-Tokenizing">printOn: stream 	stream 		nextPutAll: (ANSIDayOfWeekKeys at: dayOfWeek);		nextPutAll: constraintOperator;		print: dayOfMonth</body></methods><methods><class-id>Chronos.TZAWeekOfMonthDayOfWeekSpec</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">constraintOperator	^constraintOperator</body><body package="Chronos-TZAdmin-Tokenizing">constraintOperator: anObject	constraintOperator := anObject</body><body package="Chronos-TZAdmin-Tokenizing">dayOfMonth	^dayOfMonth</body><body package="Chronos-TZAdmin-Tokenizing">dayOfMonth: anObject	dayOfMonth := anObject.</body><body package="Chronos-TZAdmin-Tokenizing">dayOfWeek	^dayOfWeek</body><body package="Chronos-TZAdmin-Tokenizing">dayOfWeek: anObject	dayOfWeek := anObject</body><body package="Chronos-TZAdmin-Tokenizing">minDayOfMonthOrdinal	minDayOfMonthOrdinal == nil 		ifTrue: 			[minDayOfMonthOrdinal := 				constraintOperator == #&gt;= 					ifTrue: [dayOfMonth]					ifFalse: 						[constraintOperator == #&gt; 							ifTrue: [dayOfMonth + 1]							ifFalse: 								[constraintOperator == #&lt;= 									ifTrue: [dayOfMonth - 6]									ifFalse: 										["&lt;" dayOfMonth - 7]]]].	^minDayOfMonthOrdinal</body></methods><methods><class-id>Chronos.TZAWeekOfMonthDayOfWeekSpec</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Tokenizing">initialize	constraintOperator := #&gt;=.	dayOfMonth := 1.	dayOfWeek := 7</body></methods><methods><class-id>Chronos.TZAWeekOfMonthDayOfWeekSpec</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Tokenizing">= anObject 	self == anObject ifTrue: [^true].	self class == anObject class ifFalse: [^false].	^constraintOperator = anObject constraintOperator and: 			[dayOfWeek = anObject dayOfWeek 				and: [self minDayOfMonthOrdinal = anObject minDayOfMonthOrdinal]]</body><body package="Chronos-TZAdmin-Tokenizing">hash	^(self minDayOfMonthOrdinal + dayOfWeek) hash</body></methods><methods><class-id>Chronos.TZAWeekOfMonthDayOfWeekSpec</class-id> <category>converting</category><body package="Chronos-TZAdmin-Tokenizing">asWeekOfMonthDayOfWeekInMonth: monthOrdinal 	^WeekOfMonthDayOfWeekFactory		month: monthOrdinal		minDayOfMonth: self minDayOfMonthOrdinal		dayOfWeek: dayOfWeek</body></methods><methods><class-id>Chronos.TZAWeekOfMonthDayOfWeekSpec class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Tokenizing">constraintOperator: operator dayOfMonth: dayOfMonth dayOfWeek: dayOfWeek	^self new		constraintOperator: operator;		dayOfMonth: dayOfMonth;		dayOfWeek: dayOfWeek</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetProcessor</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">dbVersion	^dbVersion == nil ifTrue: ['unknown'] ifFalse: [dbVersion]</body><body package="Chronos-TZAdmin-Compiling">dbVersion: aString	dbVersion := aString</body><body package="Chronos-TZAdmin-Compiling">fileCount	^fileCount</body><body package="Chronos-TZAdmin-Compiling">lineCount	^tzParser lineCount</body><body package="Chronos-TZAdmin-Compiling">zoneInfoSourcesDirectory	^zoneInfoSourcesDirectory</body><body package="Chronos-TZAdmin-Compiling">zoneInfoSourcesDirectory: anObject	zoneInfoSourcesDirectory := anObject</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetProcessor</class-id> <category>ruleset processing</category><body package="Chronos-TZAdmin-Compiling">value	self parseRuleset.	self reportParseResults.	self generate.	self reportGenerationResults</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetProcessor</class-id> <category>ruleset parsing</category><body package="Chronos-TZAdmin-Compiling">parseRuleset	parseDuration := 		DurationFactory toRun: 			[self preParsing.			self basicParseRuleset].</body><body package="Chronos-TZAdmin-Compiling">reportParseResults	Transcript		cr;		show: 'Parsed ' , fileCount printString 					, ' timezone ruleset files, containing ' , self lineCount printString 					, ' total lines.';		cr;		show: 'Leap Second Rules parsed: ', tzParser leapSecondRuleCount printString;		cr;		show: 'Transition rules parsed: ', tzParser transitionRuleCount printString;		cr;		show: 'Link Rules parsed: ', tzParser linkRuleCount printString;		cr;		show: 'Zone Rules parsed: ', tzParser zoneRuleCount printString;		cr;		show: 'Time Zones parsed: ', tzParser zoneCount printString;		cr;		show: 'Duration to parse: ' , parseDuration printString</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetProcessor</class-id> <category>ruleset generation</category><body package="Chronos-TZAdmin-Compiling">generate	generationDuration := 		DurationFactory toRun: 			[self preGeneration.			self basicGenerate.			self postGeneration].</body><body package="Chronos-TZAdmin-Compiling">reportGenerationResults	"By default, do nothing."</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetProcessor</class-id> <category>private</category><body package="Chronos-TZAdmin-Compiling">basicGenerate	"By default, do nothing."</body><body package="Chronos-TZAdmin-Compiling">basicParseRuleset	zoneInfoSourcesDirectory contentsDo: 			[:fr | 			(fr hasExtensionUsingSeparator: $.) 				ifFalse: 					[tzParser on: fr.					tzParser parseRuleSetFor: self.					fileCount := fileCount + 1]]</body><body package="Chronos-TZAdmin-Compiling">postGeneration	"By default, do nothing."</body><body package="Chronos-TZAdmin-Compiling">preGeneration	"By default, do nothing."</body><body package="Chronos-TZAdmin-Compiling">preParsing	fileCount := 0.</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetProcessor</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Compiling">initialize	tzParser := OlsonTZDBRulesetParser new.</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetProcessor</class-id> <category>TZRule definition</category><body package="Chronos-TZAdmin-Compiling">defineLeapSecondRule: aTZLeapSecondRule	"By default, do nothing."</body><body package="Chronos-TZAdmin-Compiling">defineLinkRule: aTZLinkRule	"By default, do nothing."</body><body package="Chronos-TZAdmin-Compiling">defineTransitionRule: aTZTransitionRule	"By default, do nothing."</body><body package="Chronos-TZAdmin-Compiling">defineZoneRule: aTZZoneRule	"By default, do nothing."</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetProcessor class</class-id> <category>actions</category><body package="Chronos-TZAdmin-Compiling">processTimeZoneRules	^self processTimeZoneRulesForVersion: 'unknown'</body><body package="Chronos-TZAdmin-Compiling">processTimeZoneRulesForVersion: dbVersion	^self 		processTimeZoneRulesFrom: 			(ChronosSystemFacade resourceRepositoryContext				resourcePathTo: #OlsonZoneInfoSourcesDirectory				ifNone: 					[EnvironmentFacade						signal: Error						message: 'The system has no reference to the directory containing the Olson Time Zone Database source files.'])			version:  dbVersion</body><body package="Chronos-TZAdmin-Compiling">processTimeZoneRulesFrom: aFileDirectoryReference version: dbVersion 	^((self new)		zoneInfoSourcesDirectory: aFileDirectoryReference;		dbVersion: dbVersion) value</body></methods><methods><class-id>Chronos.TZATransitionRuleGovernedTZRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">transitionRuleKey	^transitionRuleKey</body><body package="Chronos-TZAdmin-Compiling">type	^#TransitionRuleGoverenedTZRule</body></methods><methods><class-id>Chronos.TZATransitionRuleGovernedTZRule</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Compiling">setTransitionRuleKey: aSymbol	self assertMutability.	transitionRuleKey := aSymbol</body></methods><methods><class-id>Chronos.TZATransitionRuleGovernedTZRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Compiling">printOn: stream	super printOn: stream.	stream		nextPutAll: ' transitionRuleKey=';		print: transitionRuleKey.	self printOnTransitionDateAndTimeOn: stream.</body></methods><methods><class-id>Chronos.TZATransitionRuleGovernedTZRule</class-id> <category>compiler collaboration</category><body package="Chronos-TZAdmin-Compiling">generateAnnualTZPolicyElementsFor: aTZRulesetCompiler since: startingTime toEndOfYearOn: stream 	| transitionRuleset |	transitionRuleset := aTZRulesetCompiler transitionRulesetAt: transitionRuleKey.	transitionRuleset generateAnnualTZPolicyElementsFor: self since: startingTime toEndOfYearOn: stream</body><body package="Chronos-TZAdmin-Compiling">generateTimeZonePolicyElementsFor: aTZRulesetCompiler fromStartOfYear: startYear toLastFullyDefinedYearOn: stream 	(startYear == nil or: [self fullyDefinesFinalYear or: [self finalYear &gt; startYear]]) 		ifTrue: 			[| transitionRuleset |			transitionRuleset := aTZRulesetCompiler transitionRulesetAt: transitionRuleKey.			transitionRuleset 				generateAnnualTZPolicyElementsFromStartOfYear: startYear 				toLastFullyDefinedYearFor: self 				on: stream]</body></methods><methods><class-id>Chronos.TZATransitionRuleGovernedTZRule</class-id> <category>private</category><body package="Chronos-TZAdmin-Compiling">basicGenerateTZAnnualPolicyElementsFor: aTZRulesetCompiler forFinalYearSince: effectiveDateAndTime untilTransitionDateAndTimeOn: stream 	| transitionRuleset |	transitionRuleset := aTZRulesetCompiler transitionRulesetAt: transitionRuleKey.	effectiveDateAndTime == nil 		ifTrue: 			[transitionRuleset 				generateAnnualTZPolicyElementsFor: self				sinceStartOfYearUntil: transitionDateAndTime				on: stream]		ifFalse: 			[transitionRuleset 				generateAnnualTZPolicyElementsFor: self				since: self effectiveDateAndTime				until: transitionDateAndTime				on: stream]</body></methods><methods><class-id>Chronos.TZARuleInteger</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Tokenizing">initialize	super initialize.	value := 0</body></methods><methods><class-id>Chronos.TZARuleInteger</class-id> <category>converting</category><body package="Chronos-TZAdmin-Tokenizing">asAnnualDateInMonth: monthOrdinal 	^DayOfMonthFactory		month: monthOrdinal		day: self value</body></methods><methods><class-id>Chronos.OlsonTZDBLeapSecondRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Parsing">dateAndTime	^dateAndTime</body><body package="Chronos-TZAdmin-Parsing">dateAndTime: aDateAndTimeToken	dateAndTime := aDateAndTimeToken. 	key := self dateAndTimeSpec secondsSinceEpoch</body><body package="Chronos-TZAdmin-Parsing">dateAndTimeSpec	^dateAndTime asDateAndTimeSpec</body><body package="Chronos-TZAdmin-Parsing">delta	^delta</body><body package="Chronos-TZAdmin-Parsing">delta: anObject	delta := anObject</body><body package="Chronos-TZAdmin-Parsing">key	^key</body><body package="Chronos-TZAdmin-Parsing">relativity	^dateAndTime relativity</body></methods><methods><class-id>Chronos.OlsonTZDBLeapSecondRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Parsing">printOn: stream	stream		nextPutAll: 'Leap Second: delta=';		print: delta;		nextPutAll: ' seconds @';		nextPutAll: dateAndTime valueString;		nextPutAll: '; relativity=';		print: self relativity</body></methods><methods><class-id>Chronos.OlsonTZDBLeapSecondRule</class-id> <category>visitor collaboration</category><body package="Chronos-TZAdmin-Parsing">defineIn: aTZRuleVisitor	^aTZRuleVisitor defineLeapSecondRule: self</body></methods><methods><class-id>Chronos.TZARuleLastWeekOfMonthDayOfWeekLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#'lastWeekOfMonth-dayOfWeek'</body></methods><methods><class-id>Chronos.TZARuleLastWeekOfMonthDayOfWeekLiteral</class-id> <category>converting</category><body package="Chronos-TZAdmin-Tokenizing">asWeekOfMonthDayOfWeekInMonth: monthOrdinal 	^WeekOfMonthDayOfWeekFactory		month: monthOrdinal		week: WeekOfMonthDayOfWeekFactory lastWeekOfMonth		dayOfWeek: self dayOfWeek</body></methods><methods><class-id>Chronos.TZATimeZone</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">key	^key</body><body package="Chronos-TZAdmin-Compiling">key: aSymbol	key := aSymbol</body></methods><methods><class-id>Chronos.TZATimeZone</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Compiling">add: aTZRule 	| prevRule |	zoneRules isEmpty 		ifFalse: 			[prevRule := zoneRules last.			aTZRule setPrevLink: prevRule].	zoneRules add: aTZRule beImmutable</body><body package="Chronos-TZAdmin-Compiling">initialize	zoneRules := SortedCollection new.</body></methods><methods><class-id>Chronos.TZATimeZone</class-id> <category>converting</category><body package="Chronos-TZAdmin-Compiling">asTimeZonePolicyFactoryFor: aTZDBRulesetCompiler 	| prevZoneRule stream sortedList offsetPolicySpecs zoneDescriptor |	prevZoneRule := nil.	stream := (Array new: 18) writeStream.	zoneRules do: 			[:nextZoneRule | 			(prevZoneRule == nil or: [prevZoneRule finalYear = nextZoneRule finalYear]) 				ifFalse: 					[prevZoneRule generateTimeZonePolicyElementsFor: aTZDBRulesetCompiler						on: stream].			prevZoneRule := nextZoneRule].	prevZoneRule generateTimeZonePolicyElementsFor: aTZDBRulesetCompiler		on: stream.	sortedList := SortedCollection sortBlock: [:a :b | a &gt; b].	offsetPolicySpecs := stream contents.	sortedList addAll: offsetPolicySpecs.	"sortedList first offsetPolicyAtomSpecsDo: [:offsetPolicyAtomSpec | offsetPolicyAtomSpec specifiesSingleTransition ifTrue: [self halt: 'Invalid Single Transition']]."	"byEffectiveYear := Dictionary new.	offsetPolicySpecs do: 			[:spec | 			| year |			year := spec effectiveYear.			(byEffectiveYear at: (year == nil ifTrue: [#foreverPast] ifFalse: [year])				ifAbsentPut: [OrderedCollection new]) add: spec].	byEffectiveYear keysAndValuesDo: 			[:effectiveYear :list | 			list size = 1 ifFalse: [Transcript cr; show: self key printString; show: ' effectiveYear='; show: effectiveYear printString; show: ' count='; show: list size printString]]."	zoneDescriptor := aTZDBRulesetCompiler zoneDescriptorAt: key.	^TimeZonePolicyFactory 		newKey: key		defaultName: (TimeZonePolicyFactory windowsTimeZoneNameFromTZKey: key ifAbsent: [])		geographicCoordinates: (zoneDescriptor == nil ifFalse: [zoneDescriptor geographicCoordinates])		annualTransitionPolicyArray: sortedList asArray</body></methods><methods><class-id>Chronos.TZATimeZone class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Compiling">key: aSymbol	^self new key: aSymbol</body></methods><methods><class-id>Chronos.TZADateAndTimeSpec</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Tokenizing">setRelativity: aRelativitySymbol	relativity := aRelativitySymbol</body></methods><methods><class-id>Chronos.TZADateAndTimeSpec</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">relativity	^relativity</body></methods><methods><class-id>Chronos.TZADateAndTimeSpec</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">isAtStartOfYear	^relativity == #nominal and: [super isAtStartOfYear]</body></methods><methods><class-id>Chronos.TZADateAndTimeSpec class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Tokenizing">year: y month: m day: d relativity: relativitySymbol	^self new		setYear: y monthOrdinal: m dayOfMonthOrdinal: d calendar: Gregorian;		setRelativity: relativitySymbol</body><body package="Chronos-TZAdmin-Tokenizing">year: y month: m day: d  seconds: seconds relativity: relativitySymbol	^self new		setYear: y monthOrdinal: m dayOfMonthOrdinal: d calendar: Gregorian;		setSecondsSinceStartOfDay: seconds;		setRelativity: relativitySymbol</body></methods><methods><class-id>Chronos.TZAZoneRuleToken</class-id> <category>parsing</category><body package="Chronos-TZAdmin-Tokenizing">parseWithSyntax: aParser for: aVisitor	^aParser parseZoneRuleFor: aVisitor</body></methods><methods><class-id>Chronos.TZAZoneRuleToken</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">keyword	^#ZONE</body></methods><methods><class-id>Chronos.TZATimeTypeSpec</class-id> <category>converting</category><body package="Chronos-TZAdmin-Utility">asTimeTypeSpec	^self</body></methods><methods><class-id>Chronos.TZATimeTypeSpec</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Utility">key	^self nameFromSubtype: '' isStandardTime: true</body></methods><methods><class-id>Chronos.TZATimeTypeSpec</class-id> <category>queries</category><body package="Chronos-TZAdmin-Utility">nameFromSubtype: subtype isStandardTime: isStandardTime	^self subclassResponsibility</body></methods><methods><class-id>Chronos.TZATimeTypeSpec</class-id> <category>printing</category><body package="Chronos-TZAdmin-Utility">printOn: stream	stream		nextPutAll: '{TZ time-type: '</body></methods><methods><class-id>Chronos.TZATimeTypeSpec class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Utility">standardTimeTypeName: standardName nonStandardTimeTypeName: nonStandardName 	^(TZABinaryTimeTypeSpec new)		setStandardTimeTypeName: standardName			nonStandardTimeTypeName: nonStandardName;		beImmutable</body><body package="Chronos-TZAdmin-Utility">timeTypeName: aSymbol 	^(TZAUnaryTimeTypeSpec new)		setTimeTypeName: aSymbol;		beImmutable</body><body package="Chronos-TZAdmin-Utility">timeTypeNamePrefix: prefixSymbol timeTypeNameSuffix: suffixSymbol 	^TZAParametricTimeTypeSpec new 		setTimeTypeNamePrefix: prefixSymbol timeTypeNameSuffix: suffixSymbol;		beImmutable</body></methods><methods><class-id>Chronos.TZABinaryTimeTypeSpec</class-id> <category>queries</category><body package="Chronos-TZAdmin-Utility">nameFromSubtype: subtype isStandardTime: isStandardTime	^isStandardTime ifTrue: [standardTimeTypeName] ifFalse: [nonStandardTimeTypeName]</body></methods><methods><class-id>Chronos.TZABinaryTimeTypeSpec</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Utility">nonStandardTimeTypeName	^nonStandardTimeTypeName</body><body package="Chronos-TZAdmin-Utility">standardTimeTypeName	^standardTimeTypeName</body></methods><methods><class-id>Chronos.TZABinaryTimeTypeSpec</class-id> <category>printing</category><body package="Chronos-TZAdmin-Utility">printOn: stream	super printOn: stream.	stream		nextPutAll: standardTimeTypeName;		nextPut: $/;		nextPutAll: nonStandardTimeTypeName;		nextPut: $}</body></methods><methods><class-id>Chronos.TZABinaryTimeTypeSpec</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Utility">setStandardTimeTypeName: standardName nonStandardTimeTypeName: nonStandardName	self assertMutability.	standardTimeTypeName := standardName asSymbol.	nonStandardTimeTypeName := nonStandardName asSymbol</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetCompiler</class-id> <category>private</category><body package="Chronos-TZAdmin-API">basicGenerate	zoneRules keysAndValuesDo: 			[:key :timeZone | 			timeZonePolicyFactories at: key put: (timeZone asTimeZonePolicyFactoryFor: self)].</body><body package="Chronos-TZAdmin-API">generateAliases	linkRules 		keysAndValuesDo: 			[:canonicalKey :links | links do: [:linkRule | TimeZonePolicyFactory alias: canonicalKey as: linkRule aliasingKey]].	TimeZonePolicyFactory persistAliases</body><body package="Chronos-TZAdmin-API">generateDefaultTimeZoneLocalizationPolicyDefinitions	TimeZoneLocalizationPolicy initialize.	zoneDescriptorsByCountry keysAndValuesDo: 			[:countryCode :zoneDescriptorList | 			| locPolicy |			locPolicy := TimeZoneLocalizationPolicy at: countryCode ifAbsent: [].			locPolicy := locPolicy == nil ifTrue: [TimeZoneLocalizationPolicy new] ifFalse: [locPolicy asMutable initializeZoneMap].			zoneDescriptorList do: 					[:zoneDescriptor | 					| tzPolicyFactory |					tzPolicyFactory := timeZonePolicyFactories at: zoneDescriptor key.					tzPolicyFactory defaultAnnualTransitionPolicy annuallyRecurringTransitionsDo: 							[:index :annualTransition | 							locPolicy 								addZoneWithKey: tzPolicyFactory key 								abbreviation: annualTransition commonAbbreviation 								offsetSecondsFromUT: annualTransition offsetSecondsFromUT 								stdTimeOffsetSecondsFromUT: annualTransition stdTimeOffsetSecondsFromUT]].			locPolicy definesDefaultMappings ifFalse: [locPolicy computeDefaultMappings].			locPolicy				setKey: countryCode;				forceRegistration]</body><body package="Chronos-TZAdmin-API">generateTZRepository	TimeZonePolicyFactory createTZRepositoryFrom: timeZonePolicyFactories.	self generateAliases.	self persistCanonicalTimeZoneKeys.	self generateDefaultTimeZoneLocalizationPolicyDefinitions.	(ChronosSystemFacade resourceRepositoryContext)		version: self dbVersion;		logVersionAndTimestamp</body><body package="Chronos-TZAdmin-API">parseZoneTab	| rp stream zoneDescriptor |	rp := zoneInfoSourcesDirectory , 'zone.tab'.	zoneDescriptorsByTzKey  := IdentityDictionary new.	zoneDescriptorsByCountry := IdentityDictionary new.	[stream := rp readStream.	[stream skipSeparators.	stream atEnd] 		whileFalse: 			[zoneDescriptor := TZAZoneDescriptor readFrom: stream.			zoneDescriptor == nil				ifFalse:					[zoneDescriptorsByTzKey at: zoneDescriptor key put: zoneDescriptor.					(zoneDescriptorsByCountry at: zoneDescriptor countryCode ifAbsentPut: [OrderedCollection new]) add: zoneDescriptor.					ChronosFunction skipToNextLineOf: stream]]] 				ensure: [stream close].	^zoneDescriptorsByCountry</body><body package="Chronos-TZAdmin-API">persistCanonicalTimeZoneKeys	ChronosSystemFacade resourceRepositoryContext persistCanonicalTimeZoneKeys</body><body package="Chronos-TZAdmin-API">postGeneration	super postGeneration.	self generateTZRepository.	leapSecondSchedule		beUTC;		storeInRepository</body><body package="Chronos-TZAdmin-API">preGeneration	super preGeneration.	timeZonePolicyFactories := IdentityDictionary new.	self parseZoneTab</body><body package="Chronos-TZAdmin-API">preParsing	super preParsing.	transitionRules := IdentityDictionary new.	zoneRules := IdentityDictionary new.	linkRules := IdentityDictionary new.	leapSecondSchedule := LeapSecondSchedule new.</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetCompiler</class-id> <category>accessing</category><body package="Chronos-TZAdmin-API">transitionRulesetAt: key	^transitionRules at: key</body><body package="Chronos-TZAdmin-API">zoneDescriptorAt: tzKey	^zoneDescriptorsByTzKey at: tzKey ifAbsent: []</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetCompiler</class-id> <category>TZRule definition</category><body package="Chronos-TZAdmin-API">defineLeapSecondRule: aTZLeapSecondRule 	leapSecondSchedule 		addLeapSeconds: aTZLeapSecondRule delta		at: aTZLeapSecondRule dateAndTimeSpec		isRelativeToUT: aTZLeapSecondRule relativity == #universal</body><body package="Chronos-TZAdmin-API">defineLinkRule: aTZLinkRule	| list |	list := linkRules at: aTZLinkRule key ifAbsentPut: [OrderedCollection new].	list add: aTZLinkRule</body><body package="Chronos-TZAdmin-API">defineTransitionRule: aTZTransitionRule	| ruleSet |	ruleSet := transitionRules at: aTZTransitionRule key ifAbsentPut: [TZATransitionRuleset new].	ruleSet add: aTZTransitionRule</body><body package="Chronos-TZAdmin-API">defineZoneRule: aTZZoneRule 	| timeZone zoneRule |	zoneRule := aTZZoneRule asNormalizedTimeZoneRule.	timeZone := zoneRules at: zoneRule key ifAbsentPut: [TZATimeZone key: zoneRule key].	timeZone add: zoneRule</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetCompiler</class-id> <category>ruleset generation</category><body package="Chronos-TZAdmin-API">reportGenerationResults	Transcript		cr;		show: 'Duration to generate: ' , generationDuration printString</body></methods><methods><class-id>Chronos.TZAMonthLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#month</body></methods><methods><class-id>Chronos.TZAMonthLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">monthOrdinal	^value</body></methods><methods><class-id>Chronos.TZARuleParametricTimeTypeLiteral</class-id> <category>printing</category><body package="Chronos-TZAdmin-Tokenizing">printValueOn: stream 	super printValueOn: stream.	stream		nextPutAll: ' nameSuffix=';		print: nameSuffix</body></methods><methods><class-id>Chronos.TZARuleParametricTimeTypeLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">name	^value, '%s', nameSuffix</body><body package="Chronos-TZAdmin-Tokenizing">namePrefix	^value</body><body package="Chronos-TZAdmin-Tokenizing">namePrefix: anObject	value := anObject</body><body package="Chronos-TZAdmin-Tokenizing">nameSuffix	^nameSuffix</body><body package="Chronos-TZAdmin-Tokenizing">nameSuffix: anObject	nameSuffix := anObject</body></methods><methods><class-id>Chronos.TZARuleParametricTimeTypeLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#namePrefix</body></methods><methods><class-id>Chronos.TZARuleParametricTimeTypeLiteral</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">isParametricType	^true</body></methods><methods><class-id>Chronos.TZARuleParametricTimeTypeLiteral</class-id> <category>converting</category><body package="Chronos-TZAdmin-Tokenizing">asTimeTypeSpec	^TZATimeTypeSpec 		timeTypeNamePrefix: self namePrefix		timeTypeNameSuffix: self nameSuffix</body></methods><methods><class-id>Chronos.TZARuleTokenInvalid</class-id> <category>printing</category><body package="Chronos-TZAdmin-Tokenizing">printValueOn: stream 	super printValueOn: stream.	stream		nextPutAll: ' expecting=';		print: expecting;		cr;		nextPutAll: 'Line contents: ';		nextPutAll: line</body></methods><methods><class-id>Chronos.TZARuleTokenInvalid</class-id> <category>parsing</category><body package="Chronos-TZAdmin-Tokenizing">ifInvalidToken: invalidTokenAction ifEndSymbol: endSymbolAction	^invalidTokenAction value: self</body><body package="Chronos-TZAdmin-Tokenizing">parseWithSyntax: aParser for: aVisitor	^aParser handleInvalidToken: self context: #ruleSymbol for: aVisitor</body></methods><methods><class-id>Chronos.TZARuleTokenInvalid</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#found</body></methods><methods><class-id>Chronos.TZARuleTokenInvalid</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">expecting	^expecting</body><body package="Chronos-TZAdmin-Tokenizing">expecting: anObject	expecting := anObject</body><body package="Chronos-TZAdmin-Tokenizing">line	^line</body><body package="Chronos-TZAdmin-Tokenizing">line: anObject	line := anObject</body></methods><methods><class-id>Chronos.TZARuleTokenInvalid</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Tokenizing">initialize	super initialize.	line := ''</body></methods><methods><class-id>Chronos.TZARuleSameYearLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">value	^#sameAsStartingYear</body></methods><methods><class-id>Chronos.TZARuleSameYearLiteral</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">isSameYearLiteral	^true</body></methods><methods><class-id>Chronos.OlsonTZDBLinkRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Parsing">alias	^alias</body><body package="Chronos-TZAdmin-Parsing">alias: anObject	alias := anObject</body><body package="Chronos-TZAdmin-Parsing">aliasingKey	^alias key</body><body package="Chronos-TZAdmin-Parsing">key	^registeredName key</body><body package="Chronos-TZAdmin-Parsing">registeredName	^registeredName</body><body package="Chronos-TZAdmin-Parsing">registeredName: anObject	registeredName := anObject</body><body package="Chronos-TZAdmin-Parsing">sortValue	^alias key</body></methods><methods><class-id>Chronos.OlsonTZDBLinkRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Parsing">printOn: stream	stream 		nextPutAll: 'Alias: ';		nextPutAll: registeredName valueString;		nextPutAll: ' as: ';	 	print: alias valueString</body></methods><methods><class-id>Chronos.OlsonTZDBLinkRule</class-id> <category>visitor collaboration</category><body package="Chronos-TZAdmin-Parsing">defineIn: aTZRuleVisitor	^aTZRuleVisitor defineLinkRule: self</body></methods><methods><class-id>Chronos.TZATransitionRuleEvent</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Utility">= otherTransitionRuleEvent	self == otherTransitionRuleEvent ifTrue: [^true].	^(self compareTo: otherTransitionRuleEvent) = 0 ifTrue: [transitionRule = otherTransitionRuleEvent transitionRule] ifFalse: [false]</body><body package="Chronos-TZAdmin-Utility">compareTo: otherEvent	self == otherEvent ifTrue: [^0].	^self year - otherEvent year</body></methods><methods><class-id>Chronos.TZATransitionRuleEvent</class-id> <category>operations</category><body package="Chronos-TZAdmin-Utility">applyTo: aSetOfActiveTransitionRules	self subclassResponsibility</body></methods><methods><class-id>Chronos.TZATransitionRuleEvent</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Utility">endYear	^transitionRule endYear + 1</body><body package="Chronos-TZAdmin-Utility">startYear	^transitionRule startYear</body><body package="Chronos-TZAdmin-Utility">transitionRule	^transitionRule</body><body package="Chronos-TZAdmin-Utility">type	^self subclassResponsibility</body><body package="Chronos-TZAdmin-Utility">year	^self subclassResponsibility</body></methods><methods><class-id>Chronos.TZATransitionRuleEvent</class-id> <category>testing</category><body package="Chronos-TZAdmin-Utility">isEndEvent	^false</body><body package="Chronos-TZAdmin-Utility">isStartEvent	^false</body></methods><methods><class-id>Chronos.TZATransitionRuleEvent</class-id> <category>printing</category><body package="Chronos-TZAdmin-Utility">printOn: stream	stream 		nextPutAll: self type;		nextPut: $[;		print: self year;		nextPutAll: ']: ';		print: transitionRule</body></methods><methods><class-id>Chronos.TZATransitionRuleEvent</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Utility">setTransitionRule: aTZTransitionRule	self assertMutability.	transitionRule := aTZTransitionRule asNormalizedTransitionRule</body></methods><methods><class-id>Chronos.TZATransitionRuleEvent class</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Utility">appOrLibraryName	^'Chronos'</body></methods><methods><class-id>Chronos.TZATransitionRuleEvent class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Utility">transitionRule: aTZTransitionRule	^self new		setTransitionRule: aTZTransitionRule;		beImmutable</body></methods><methods><class-id>Chronos.TZATransitionRuleStartEvent</class-id> <category>operations</category><body package="Chronos-TZAdmin-Utility">applyTo: aSetOfActiveTransitionRules	aSetOfActiveTransitionRules add: transitionRule</body></methods><methods><class-id>Chronos.TZATransitionRuleStartEvent</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Utility">compareTo: otherEvent	| diff |	diff := super compareTo: otherEvent.	diff = 0 ifFalse: [^diff].	^otherEvent isEndEvent		ifTrue: [1]		ifFalse: [0]</body></methods><methods><class-id>Chronos.TZATransitionRuleStartEvent</class-id> <category>testing</category><body package="Chronos-TZAdmin-Utility">isStartEvent	^true</body></methods><methods><class-id>Chronos.TZATransitionRuleStartEvent</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Utility">type	^#TransitionRuleStart</body><body package="Chronos-TZAdmin-Utility">year	^self startYear</body></methods><methods><class-id>Chronos.TZAParametricTimeTypeSpec</class-id> <category>queries</category><body package="Chronos-TZAdmin-Utility">nameFromSubtype: subtype isStandardTime: isStandardTime	| stream |	stream := (String new: 5) writeStream.	stream		nextPutAll: timeTypeNamePrefix;		nextPutAll: subtype;		nextPutAll: timeTypeNameSuffix.	^stream contents</body></methods><methods><class-id>Chronos.TZAParametricTimeTypeSpec</class-id> <category>printing</category><body package="Chronos-TZAdmin-Utility">printOn: stream	super printOn: stream.	stream		nextPutAll: timeTypeNamePrefix;		nextPutAll: '%s';		nextPutAll: timeTypeNameSuffix;		nextPut: $}</body></methods><methods><class-id>Chronos.TZAParametricTimeTypeSpec</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Utility">setTimeTypeNamePrefix: prefixSymbol timeTypeNameSuffix: suffixSymbol	self assertMutability.	timeTypeNamePrefix := prefixSymbol asSymbol.	timeTypeNameSuffix := suffixSymbol asSymbol</body></methods><methods><class-id>Chronos.TZAParametricTimeTypeSpec</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Utility">timeTypeNamePrefix	^timeTypeNamePrefix</body><body package="Chronos-TZAdmin-Utility">timeTypeNameSuffix	^timeTypeNameSuffix</body></methods><methods><class-id>Chronos.TZARuleTimeSubtypeLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#timeSubtype</body></methods><methods><class-id>Chronos.TZAUnaryTimeTypeSpec</class-id> <category>queries</category><body package="Chronos-TZAdmin-Utility">nameFromSubtype: subtype isStandardTime: isStandardTime	^timeTypeName</body></methods><methods><class-id>Chronos.TZAUnaryTimeTypeSpec</class-id> <category>printing</category><body package="Chronos-TZAdmin-Utility">printOn: stream 	super printOn: stream.	stream nextPutAll: self timeTypeName;		nextPut: $}</body></methods><methods><class-id>Chronos.TZAUnaryTimeTypeSpec</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Utility">setTimeTypeName: aSymbol	self assertMutability.	timeTypeName := aSymbol asSymbol</body></methods><methods><class-id>Chronos.TZAUnaryTimeTypeSpec</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Utility">timeTypeName	^timeTypeName</body></methods><methods><class-id>Chronos.TZAZoneDescriptor</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Utility">countryCode	^countryCode</body><body package="Chronos-TZAdmin-Utility">countryCode: aStringOrSymbol	countryCode := aStringOrSymbol == nil ifFalse: [aStringOrSymbol asSymbol]</body><body package="Chronos-TZAdmin-Utility">geographicCoordinates	^geographicCoordinates</body><body package="Chronos-TZAdmin-Utility">geographicCoordinates: anObject	geographicCoordinates := anObject</body><body package="Chronos-TZAdmin-Utility">key	^TimeZonePolicyFactory canonicalKeyAt: key ifNone: [key]</body><body package="Chronos-TZAdmin-Utility">key: aStringOrSymbol	key := aStringOrSymbol == nil ifFalse: [aStringOrSymbol asSymbol]</body></methods><methods><class-id>Chronos.TZAZoneDescriptor class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Utility">readFrom: stream 	"{TZAZoneDescriptor readFrom: 'US	+340308-1181434	America/Los_Angeles	Pacific Time' readStream}"	| countryCode geoCoord tzKey |	[stream atEnd ifTrue: [^nil].	stream peek = $#] whileTrue: [ChronosFunction skipToNextLineOf: stream].	countryCode := ChronosFunction  nextFrom: stream until: [:ch | ch isSeparator].	ChronosFunction  skipOver: stream while: [:ch | ch isSeparator].	geoCoord := GeographicCoordinateSpec readFrom: stream.	ChronosFunction  skipOver: stream while: [:ch | ch isSeparator].	tzKey := ChronosFunction nextFrom: stream until: [:ch | ch isSeparator].	^self new		key: tzKey;		countryCode: countryCode;		geographicCoordinates: geoCoord</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetParser</class-id> <category>parsing</category><body package="Chronos-TZAdmin-Parsing">handleInvalidToken: invalidToken context: context for: aVisitor 	EnvironmentFacade		signal: Error		message: '{TZRuleSetParser&gt;&gt;' , context 				, '} Syntax error encountered in TimeZone ruleset source file: ' 					, invalidToken printString</body><body package="Chronos-TZAdmin-Parsing">handleLegalEndSymbol: endSymbol for: aVisitor	self close.	"Transcript		cr; 		show: '{TZRulesetParser} Parsed ';		show: self lineNumber printString;		show: ' lines from: ';		tab; tab;		show: self fileReference asNative asString"</body><body package="Chronos-TZAdmin-Parsing">handleUnexpectedEndSymbol: endSymbol context: context for: aVisitor 	EnvironmentFacade 		signal: Error		message: '{TZRuleSetParser&gt;&gt;' , context 				, '} Syntax error encountered in TimeZone ruleset source file: Unexpected end-of-file at ' 					, endSymbol locationString</body><body package="Chronos-TZAdmin-Parsing">parseLeapSecondRuleFor: aVisitor 	| dateAndTime index delta relativity |	self incrementRuleCount: LeapSecondRuleIndex.	dateAndTime := tokenizer leapSecondDateAndTimeToken.	dateAndTime 		ifInvalidToken: [:token | self handleInvalidToken: token context: #parseLeapSecondRuleFor: for: aVisitor]		ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseLeapSecondRuleFor: for: aVisitor].	index := nil.	tokenizer 		nextNonSeparatorMustSatisfy: [:char | (index := #($+ $-) indexOf: char ifAbsent: []) notNil]		otherwise: [:invalidToken | self handleInvalidToken: invalidToken  context: #parseLeapSecondRuleFor: for: aVisitor].	index == nil ifTrue: [self halt].	delta := #(1 -1) at: index.	tokenizer 		nextNonSeparatorMustSatisfy: [:char | (index := #($S $R $s $r) indexOf: char ifAbsent: []) notNil]		otherwise: [:invalidToken | self handleInvalidToken: invalidToken context: #parseLeapSecondRuleFor: for: aVisitor].	tokenizer skipUntil: [:ch | ch isSeparator].	relativity := #(#universal #nominal #universal #nominal) at: index.	dateAndTime relativity: relativity.	^(OlsonTZDBLeapSecondRule new		dateAndTime: dateAndTime;		delta: delta) defineIn: aVisitor</body><body package="Chronos-TZAdmin-Parsing">parseLinkRuleFor: aVisitor	| registeredName alias |	self incrementRuleCount: LinkRuleIndex.	registeredName := tokenizer identifierToken.	registeredName ifInvalidToken: [:token | self handleInvalidToken: token context: #parseLinkRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseLinkRuleFor: for: aVisitor].	alias := tokenizer identifierToken.	alias ifInvalidToken: [:token | self handleInvalidToken: token context: #parseLinkRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseLinkRuleFor: for: aVisitor].	^(OlsonTZDBLinkRule new		registeredName: registeredName;		alias: alias) defineIn: aVisitor</body><body package="Chronos-TZAdmin-Parsing">parseRuleSetFor: aVisitor 		[[| rule |	rule := tokenizer ruleTypeSymbol.	rule parseWithSyntax: self for: aVisitor.	rule isEndSymbol] whileFalse] ensure: [self close].	lineCount := lineCount + tokenizer lineNumber.</body><body package="Chronos-TZAdmin-Parsing">parseTransitionRuleFor: aVisitor	| name startYear endYear yearType month dayOfMonth timeOfDay offsetDelta timeSubType |	self incrementRuleCount: TransitionRuleIndex.	name := tokenizer identifierToken.	name ifInvalidToken: [:token | self handleInvalidToken: token context: #parseTransitionRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseTransitionRuleFor: for: aVisitor].	startYear := tokenizer startingYearToken.	startYear ifInvalidToken: [:token | self handleInvalidToken: token context: #parseTransitionRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseTransitionRuleFor: for: aVisitor].	endYear := tokenizer endingYearToken.	endYear ifInvalidToken: [:token | self handleInvalidToken: token context: #parseTransitionRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseTransitionRuleFor: for: aVisitor].	yearType := tokenizer yearTypeToken.	yearType ifInvalidToken: [:token | self handleInvalidToken: token context: #parseTransitionRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseTransitionRuleFor: for: aVisitor].	month := tokenizer monthToken.	month ifInvalidToken: [:token | self handleInvalidToken: token context: #parseTransitionRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseTransitionRuleFor: for: aVisitor].	dayOfMonth := tokenizer dayOfMonthToken.	dayOfMonth ifInvalidToken: [:token | self handleInvalidToken: token context: #parseTransitionRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseTransitionRuleFor: for: aVisitor].	timeOfDay := tokenizer timeOfDayToken.	timeOfDay ifInvalidToken: [:token | self handleInvalidToken: token context: #parseTransitionRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseTransitionRuleFor: for: aVisitor].	offsetDelta := tokenizer hourMinuteSecondToken.	offsetDelta ifInvalidToken: [:token | self handleInvalidToken: token context: #parseTransitionRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseTransitionRuleFor: for: aVisitor].	timeSubType := tokenizer timeSubTypeToken.	timeSubType ifInvalidToken: [:token | self handleInvalidToken: token context: #parseTransitionRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol: token context: #parseTransitionRuleFor: for: aVisitor].	^(OlsonTZDBTransitionRule new		name: name;		startYear: startYear;		endYear: endYear;		yearType: yearType;		month: month;		dayOfMonth: dayOfMonth;		timeOfDay: timeOfDay;		offsetDelta: offsetDelta;		timeSubType: timeSubType) defineIn: aVisitor</body><body package="Chronos-TZAdmin-Parsing">parseZoneRuleFor: aVisitor 	| name stdTimeOffset transitionRule timeTypeNameSpec transitionDate zoneRule |	zoneCount := zoneCount + 1.	name := tokenizer identifierToken.	name ifInvalidToken: [:token | self handleInvalidToken:token context: #parseZoneRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol:token context: #parseZoneRuleFor: for: aVisitor].		stdTimeOffset := tokenizer hourMinuteSecondToken.	stdTimeOffset ifInvalidToken: [:token | self handleInvalidToken:token context: #parseZoneRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol:token context: #parseZoneRuleFor: for: aVisitor].	transitionRule := tokenizer transitionRuleToken.	transitionRule ifInvalidToken: [:token | self handleInvalidToken:token context: #parseZoneRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol:token context: #parseZoneRuleFor: for: aVisitor].	name key = #Factory ifTrue: ["This can safely be ignored." tokenizer skipLine. ^self].	timeTypeNameSpec := tokenizer timeTypeToken.	timeTypeNameSpec ifInvalidToken: [:token | self handleInvalidToken:token context: #parseZoneRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol:token context: #parseZoneRuleFor: for: aVisitor].	transitionDate := tokenizer zoneRuleTransitionDateToken.	zoneRule := OlsonTZDBZoneRule new.	zoneRule name:name.	[self incrementRuleCount: ZoneRuleIndex.	zoneRule 		stdTimeOffsetFromUT: stdTimeOffset;		transitionRule: transitionRule;		timeTypeNameSpec: timeTypeNameSpec;		transitionDateAndTime: transitionDate.	transitionDate == nil] whileFalse: 			[transitionDate ifInvalidToken: [:token | self handleInvalidToken:token context: #parseZoneRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol:token context: #parseZoneRuleFor: for: aVisitor].			zoneRule defineIn: aVisitor.			zoneRule := zoneRule copy.			tokenizer skipLine; skipWhitespaceAndComments.			stdTimeOffset := tokenizer hourMinuteSecondToken.			stdTimeOffset ifInvalidToken: [:token | self handleInvalidToken:token context: #parseZoneRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol:token context: #parseZoneRuleFor: for: aVisitor].			transitionRule := tokenizer transitionRuleToken.			transitionRule ifInvalidToken: [:token | self handleInvalidToken:token context: #parseZoneRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol:token context: #parseZoneRuleFor: for: aVisitor].			timeTypeNameSpec := tokenizer timeTypeToken.			timeTypeNameSpec ifInvalidToken: [:token | self handleInvalidToken:token context: #parseZoneRuleFor: for: aVisitor] ifEndSymbol: [:token | self handleUnexpectedEndSymbol:token context: #parseZoneRuleFor: for: aVisitor].			transitionDate := tokenizer zoneRuleTransitionDateToken].	zoneRule defineIn: aVisitor.</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetParser</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Parsing">leapSecondRuleCount	^ruleCounts at: LeapSecondRuleIndex</body><body package="Chronos-TZAdmin-Parsing">lineCount	^lineCount</body><body package="Chronos-TZAdmin-Parsing">linkRuleCount	^ruleCounts at: LinkRuleIndex</body><body package="Chronos-TZAdmin-Parsing">resourcePath	^tokenizer == nil		ifFalse: [tokenizer resourcePath]</body><body package="Chronos-TZAdmin-Parsing">transitionRuleCount	^ruleCounts at: TransitionRuleIndex</body><body package="Chronos-TZAdmin-Parsing">zoneCount	^zoneCount</body><body package="Chronos-TZAdmin-Parsing">zoneRuleCount	^ruleCounts at: ZoneRuleIndex</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetParser</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Parsing">close	tokenizer == nil ifFalse: [tokenizer close]</body><body package="Chronos-TZAdmin-Parsing">initialize	lineCount := 0.	ruleCounts := Array new: 4 withAll: 0.	zoneCount := 0.</body><body package="Chronos-TZAdmin-Parsing">on: aFileReference	tokenizer == nil		ifTrue: [tokenizer := OlsonTZDBRulesetTokenizer on: aFileReference]		ifFalse: [tokenizer on: aFileReference].</body><body package="Chronos-TZAdmin-Parsing">open	tokenizer == nil ifFalse: [tokenizer open]</body><body package="Chronos-TZAdmin-Parsing">release	super release.	tokenizer == nil ifFalse: [tokenizer release]</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetParser</class-id> <category>testing</category><body package="Chronos-TZAdmin-Parsing">atEnd	^tokenizer == nil ifTrue: [true] ifFalse: [tokenizer atEnd]</body><body package="Chronos-TZAdmin-Parsing">isOpen	^tokenizer == nil ifTrue: [false] ifFalse: [tokenizer isOpen]</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetParser</class-id> <category>private</category><body package="Chronos-TZAdmin-Parsing">incrementRuleCount: index	| count |	count := ruleCounts at: index.	count := count + 1.	ruleCounts at: index put: count</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetParser class</class-id> <category>class initialization</category><body package="Chronos-TZAdmin-Parsing">initialize	TransitionRuleIndex := 1.	ZoneRuleIndex := 2.	LinkRuleIndex := 3.	LeapSecondRuleIndex := 4.</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetParser class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Parsing">on: aResourcePath	^self new on: aResourcePath</body></methods><methods><class-id>Chronos.TZARuleYearType</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">value	^value asSymbol</body></methods><methods><class-id>Chronos.TZARuleYearType</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#yearType</body></methods><methods><class-id>Chronos.TZAAnnualTransitionRule</class-id> <category>private</category><body package="Chronos-TZAdmin-Compiling">newAnnualPolicyElementWithStdTimeOffsetSeconds: stdTimeOffsetSecondsFromUTC offsetDeltaSeconds: offsetDelta commonAbbreviation: commonAbbreviation 	^UntilAnnualDateTimeZoneTransitionFactory 		offsetSeconds: stdTimeOffsetSecondsFromUTC + offsetDelta		stdTimeOffsetSeconds:  stdTimeOffsetSecondsFromUTC		commonAbbreviation: commonAbbreviation		annualDate: annualDate		transitionSecondsSinceStartOfDay: transitionSecondsSinceStartOfDay		relativity: relativity</body></methods><methods><class-id>Chronos.TZAAnnualTransitionRule</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Compiling">setAnnualDate: anAnnualDate transitionSecondsSinceStartOfDay: seconds relativity: timeRelativity	self assertMutability.	annualDate := anAnnualDate.	transitionSecondsSinceStartOfDay := seconds.	relativity := timeRelativity.</body></methods><methods><class-id>Chronos.TZAAnnualTransitionRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">annualDate	^annualDate</body><body package="Chronos-TZAdmin-Compiling">ruleType	^#AnnualTransitionRule</body></methods><methods><class-id>Chronos.TZAAnnualTransitionRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Compiling">printOn: stream	super printOn: stream.	stream		nextPutAll: ' annualDate=';		print: annualDate;		nextPutAll: ' transitionSecondsSinceStartOfDay=';		print: transitionSecondsSinceStartOfDay;		nextPutAll: ' relativity=';		print: relativity</body></methods><methods><class-id>Chronos.TZAAnnualTransitionRule</class-id> <category>private-comparing</category><body package="Chronos-TZAdmin-Compiling">compareToAnnualTransitionRule: anAnnualTransitionRule	| diff |	diff := anAnnualTransitionRule annualDate compareTo: annualDate.	diff = 0 ifFalse: [^diff].	^anAnnualTransitionRule transitionSecondsSinceStartOfDay - transitionSecondsSinceStartOfDay</body><body package="Chronos-TZAdmin-Compiling">compareToSingleTransitionRule: aSingleTransitionRule	| diff |	diff := aSingleTransitionRule transitionDayOfYear - annualDate minDayOfYearOrdinal.	diff = 0 ifFalse: [^diff].	^aSingleTransitionRule transitionSecondsSinceStartOfDay - transitionSecondsSinceStartOfDay</body></methods><methods><class-id>Chronos.TZAAnnualTransitionRule</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Compiling">compareTo: otherRule	self == otherRule ifTrue: [^0].	^[otherRule compareToAnnualTransitionRule: self]		on: MessageNotUnderstood		do: [:ex |				(ex receiver == otherRule and: [ex message selector == #compareToAnnualTransitionRule:])					ifTrue: [ex return]					ifFalse: [ex pass]]</body></methods><methods><class-id>Chronos.TZAAnnualTransitionRule class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Compiling">key: aKey startYear: sYear endYear: eYear yearType: yType timeSubType: tsType offsetDelta: offsetDeltaSeconds annualDate: annualDate transitionSecondsSinceStartOfDay: transitionSeconds relatitivity: relativity 	^(self new)		setKey: aKey			startYear: sYear			endYear: eYear			yearType: yType;		setTimeSubType: tsType;		setOffsetDeltaSeconds: offsetDeltaSeconds;		setAnnualDate: annualDate			transitionSecondsSinceStartOfDay: transitionSeconds			relativity: relativity;		beImmutable</body></methods><methods><class-id>Chronos.TZATransitionRuleset</class-id> <category>operations</category><body package="Chronos-TZAdmin-Compiling">generateAnnualTZPolicyElementsFor: aTZRule since: startingTime toEndOfYearOn: stream 	self 		generateAnnualTZPolicyElementsFor: aTZRule		since: startingTime		until: nil		on: stream</body><body package="Chronos-TZAdmin-Compiling">generateAnnualTZPolicyElementsFor: aTZRule since: startingTime until: endingTime on: stream 	| tzPolicySequence tzPolicyElement |	tzPolicySequence := self timeZonePolicyFor: aTZRule.	tzPolicyElement := 		tzPolicySequence 			annualTransitionPolicyEffectiveInYear: startingTime year			ifNone: 				[| defaultRule |				defaultRule := self defaultInitialTransitionRule.				stream nextPut: (defaultRule annualPolicyElementFor: aTZRule transitioningTo: defaultRule).				^self].	tzPolicyElement annuallyRecurringTransitionsDo: 			[:index :annualPolicy | 			annualPolicy specifiesIntraYearTransition 				ifTrue: 					[(annualPolicy transitionOccursAfter: startingTime) 						ifTrue: 							[(annualPolicy transitionOccursOnOrAfter: endingTime) 								ifTrue: 									[stream nextPut: 										(UntilAnnualDayOfYearTimeZoneTransitionFactory 											offsetSeconds: annualPolicy offsetSecondsFromUT											stdTimeOffsetSeconds: annualPolicy stdTimeOffsetSecondsFromUT											commonAbbreviation: annualPolicy commonAbbreviation											transitionDayOfYear: endingTime dayOfYearOrdinal											transitionSecondsSinceStartOfDay: endingTime secondsSinceStartOfDay											relativity: endingTime relativity).									^self]								ifFalse: [stream nextPut: annualPolicy]]]				ifFalse: [stream nextPut: 							(endingTime == nil								ifTrue: [annualPolicy]								ifFalse: 									[UntilAnnualDayOfYearTimeZoneTransitionFactory 										offsetSeconds: annualPolicy offsetSecondsFromUT										stdTimeOffsetSeconds: annualPolicy stdTimeOffsetSecondsFromUT										commonAbbreviation: annualPolicy commonAbbreviation										transitionDayOfYear: endingTime dayOfYearOrdinal										transitionSecondsSinceStartOfDay: endingTime secondsSinceStartOfDay										relativity: endingTime relativity]).							^self]]</body><body package="Chronos-TZAdmin-Compiling">generateAnnualTZPolicyElementsFor: aTZRule sinceStartOfYearUntil: endingDateAndTime on: stream 	self 		generateAnnualTZPolicyElementsFor: aTZRule		since: (TZADateAndTimeSpec year: endingDateAndTime year month: 1 day: 1 relativity: endingDateAndTime relativity)		until: endingDateAndTime		on: stream</body><body package="Chronos-TZAdmin-Compiling">generateAnnualTZPolicyElementsFromStartOfYear: startYear toLastFullyDefinedYearFor: aTZRule on: stream 	| tzPolicy endYear |	endYear := aTZRule finalFullyDefinedYear.	endYear == nil ifTrue: [endYear := PassportInfinity positive].	tzPolicy := self timeZonePolicyFor: aTZRule.	tzPolicy everyAnnualTransitionPolicyEverInEffectSinceYear: startYear		do: 			[:tzPolicyElement | 			| effectiveYear |			effectiveYear := tzPolicyElement effectiveYear.			(effectiveYear == nil or: [startYear notNil and: [effectiveYear &lt; startYear]])				ifTrue: [stream nextPut: (tzPolicyElement effectiveYear: startYear)]				ifFalse: 					[endYear &lt; effectiveYear						ifTrue: [^self]						ifFalse: [stream nextPut: tzPolicyElement]]]</body></methods><methods><class-id>Chronos.TZATransitionRuleset</class-id> <category>private</category><body package="Chronos-TZAdmin-Compiling">defaultInitialTransitionRule	^TZANonTransitionRule "A tranistion rule appropriate as the universal predecessor rule."		timeSubType: '' 		offsetDelta: 0</body><body package="Chronos-TZAdmin-Compiling">generateTimeZonePolicyElementsFor: aTZRule on: stream 	| prevTransitionRule prevYear nextYear activeRules atomStream transitionRuleToEndOfYear |	prevTransitionRule := self defaultInitialTransitionRule.	prevYear := nil.	activeRules := foreverPast copy.	activeRules isEmpty 		ifTrue: 			[stream nextPut: 				(TimeZoneAnnualTransitionPolicyFactory 					key: aTZRule key					effectiveYear: prevYear					annuallyRecurringTransitions: 						(Array with: 							(prevTransitionRule 								annualPolicyElementFor: aTZRule 								transitioningTo: prevTransitionRule)))].	atomStream := (Array new: 3) writeStream.	schedule do: 			[:event | 			nextYear := event year.			(prevYear = nextYear or: [activeRules isEmpty and: [prevYear == nil]])				ifFalse: 					[activeRules do: 						[:nextTransitionRule | 							atomStream nextPut: (prevTransitionRule annualPolicyElementFor: aTZRule transitioningTo: nextTransitionRule).							prevTransitionRule := nextTransitionRule].					transitionRuleToEndOfYear := prevTransitionRule asTransitionRuleToEndOfYear.					atomStream nextPut: (prevTransitionRule annualPolicyElementFor: aTZRule transitioningTo: transitionRuleToEndOfYear).					prevTransitionRule := transitionRuleToEndOfYear.					stream nextPut: 						(TimeZoneAnnualTransitionPolicyFactory 							key: aTZRule key							effectiveYear: prevYear							annuallyRecurringTransitions: atomStream contents).					atomStream := (Array new: 3) writeStream].			event applyTo: activeRules.			prevYear := nextYear].	activeRules do: 		[:nextTransitionRule | 			atomStream nextPut: (prevTransitionRule annualPolicyElementFor: aTZRule transitioningTo: nextTransitionRule).			prevTransitionRule := nextTransitionRule].	transitionRuleToEndOfYear := prevTransitionRule asTransitionRuleToEndOfYear.	atomStream nextPut: (prevTransitionRule annualPolicyElementFor: aTZRule transitioningTo: transitionRuleToEndOfYear).	stream nextPut: 		(TimeZoneAnnualTransitionPolicyFactory 			key: aTZRule key			effectiveYear: prevYear			annuallyRecurringTransitions: atomStream contents)</body><body package="Chronos-TZAdmin-Compiling">newTimeZonePolicyFor: aTZRule	| stream |	stream := (Array new: 20) writeStream.	self generateTimeZonePolicyElementsFor: aTZRule on: stream.	^(TimeZonePolicyFactory 		key: aTZRule key		defaultName: nil 		geographicCoordinates: nil		annualTransitionPolicyArray: stream contents reverse)</body><body package="Chronos-TZAdmin-Compiling">timeZonePolicyFor: aTZRule 	^timeZonePolicy at: aTZRule ruleKey		ifAbsentPut: [self newTimeZonePolicyFor: aTZRule]</body></methods><methods><class-id>Chronos.TZATransitionRuleset</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Compiling">add: aTZTransitionRule	| transitionRule |	transitionRule := aTZTransitionRule asNormalizedTransitionRule.	transitionRule hasNoStartYear 		ifTrue: [foreverPast add: transitionRule]		ifFalse: [schedule add: (TZATransitionRuleStartEvent transitionRule: transitionRule)].	transitionRule hasNoEndYear 		ifFalse: [schedule add: (TZATransitionRuleEndEvent transitionRule: transitionRule)].</body><body package="Chronos-TZAdmin-Compiling">initialize	foreverPast := SortedCollection new.	schedule := SortedCollection new.	timeZonePolicy := IdentityDictionary new.</body></methods><methods><class-id>Chronos.TZARuleBinaryTimeTypeLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">name	^value, '/', nonStandardName</body><body package="Chronos-TZAdmin-Tokenizing">nonStandardName	^nonStandardName</body><body package="Chronos-TZAdmin-Tokenizing">nonStandardName: anObject	nonStandardName := anObject</body><body package="Chronos-TZAdmin-Tokenizing">standardName	^value</body><body package="Chronos-TZAdmin-Tokenizing">standardName: anObject	value := anObject</body></methods><methods><class-id>Chronos.TZARuleBinaryTimeTypeLiteral</class-id> <category>printing</category><body package="Chronos-TZAdmin-Tokenizing">printValueOn: stream 	super printValueOn: stream.	stream		nextPutAll: ' nonStandardName=';		print: nonStandardName</body></methods><methods><class-id>Chronos.TZARuleBinaryTimeTypeLiteral</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">isBinaryType	^true</body></methods><methods><class-id>Chronos.TZARuleBinaryTimeTypeLiteral</class-id> <category>converting</category><body package="Chronos-TZAdmin-Tokenizing">asTimeTypeSpec	^TZATimeTypeSpec 		standardTimeTypeName: self standardName		nonStandardTimeTypeName: self nonStandardName</body></methods><methods><class-id>Chronos.TZADateAndTimeLiteral</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">dayOfMonth	^dayOfMonth == nil ifTrue: [1] ifFalse: [dayOfMonth]</body><body package="Chronos-TZAdmin-Tokenizing">dayOfMonth: anObject	dayOfMonth := anObject</body><body package="Chronos-TZAdmin-Tokenizing">monthOrdinal	^monthOrdinal == nil ifTrue: [1] ifFalse: [monthOrdinal]</body><body package="Chronos-TZAdmin-Tokenizing">monthOrdinal: anObject	monthOrdinal := anObject</body><body package="Chronos-TZAdmin-Tokenizing">relativity	^relativity</body><body package="Chronos-TZAdmin-Tokenizing">relativity: aSymbol	relativity := aSymbol</body><body package="Chronos-TZAdmin-Tokenizing">secondsSinceStartOfDay	^secondsSinceStartOfDay == nil ifTrue: [0] ifFalse: [secondsSinceStartOfDay]</body><body package="Chronos-TZAdmin-Tokenizing">secondsSinceStartOfDay: anObject	secondsSinceStartOfDay := anObject</body><body package="Chronos-TZAdmin-Tokenizing">sortValue	^self asDateAndTimeSpec</body><body package="Chronos-TZAdmin-Tokenizing">year	^value</body><body package="Chronos-TZAdmin-Tokenizing">year: anObject	value := anObject</body></methods><methods><class-id>Chronos.TZADateAndTimeLiteral</class-id> <category>printing</category><body package="Chronos-TZAdmin-Tokenizing">printValueOn: stream 	super printValueOn: stream.	stream		nextPutAll: ' month=';		print: self monthOrdinal;		nextPutAll: ' dayOfMonth=';		print: self dayOfMonth;		nextPutAll: ' secondsSinceStartOfDay=';		print: self secondsSinceStartOfDay</body></methods><methods><class-id>Chronos.TZADateAndTimeLiteral</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#year</body></methods><methods><class-id>Chronos.TZADateAndTimeLiteral</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Tokenizing">initialize	super initialize.	secondsSinceStartOfDay := 0.	relativity := #nominal.</body></methods><methods><class-id>Chronos.TZADateAndTimeLiteral</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Tokenizing">= aTZRuleToken	self == aTZRuleToken ifTrue: [^true].	self class == aTZRuleToken class ifFalse: [^false].	^self asDateAndTimeSpec = aTZRuleToken asDateAndTimeSpec</body><body package="Chronos-TZAdmin-Tokenizing">hash	^self asDateAndTimeSpec hash</body></methods><methods><class-id>Chronos.TZADateAndTimeLiteral</class-id> <category>converting</category><body package="Chronos-TZAdmin-Tokenizing">asDateAndTimeSpec	dateAndTimeSpec == nil 		ifTrue: 			[dateAndTimeSpec := 				TZADateAndTimeSpec 					year: self year					month: self monthOrdinal					day: self dayOfMonth					seconds: self secondsSinceStartOfDay					relativity: relativity].	^dateAndTimeSpec</body></methods><methods><class-id>Chronos.TZARuleDefaultToken</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">value	^nil</body></methods><methods><class-id>Chronos.TZARuleDefaultToken</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">representsZeroOffsetSecondsDeltaInTimeZoneRule	^true</body></methods><methods><class-id>Chronos.WindowsToOlsonTZKeyMapGenerator</class-id> <category>operations</category><body package="Chronos-Windows Timezone Map Generator">generate: block1	| sourceStream list |		self setSourcePath.		list := SortedCollection sortBlock: [:a :b | a key &lt;= b key].	[sourceStream := sourcePath readStream.		[ChronosFunction skipSeparators: sourceStream.	sourceStream atEnd] whileFalse: 				[| line tokens |				line := ChronosFunction nextLineFrom: sourceStream.				tokens := ChronosFunction componentsFromString: line separator: $:.				tokens size &gt; 3					ifTrue: [list add: tokens first-&gt;tokens last]].				list do: [:assoc | block1 value: assoc]] 			ensure: 				[sourceStream == nil ifFalse: [sourceStream close]]</body></methods><methods><class-id>Chronos.WindowsToOlsonTZKeyMapGenerator</class-id> <category>resource path binding</category><body package="Chronos-Windows Timezone Map Generator">setSourcePath	"This method is Windows-specific."	"Looking for '&lt;jrePath&gt;lib\tzmappings'"	| envVarValue classPaths path jreList |	envVarValue := EnvironmentFacade current valueOfEnvironmentVariableAt: 'JRE_HOME'.	envVarValue size &gt; 0 		ifTrue: 			[path := ResourcePath fromString: envVarValue.			path := path , 'tzmappings'.			path exists 				ifTrue: 					[sourcePath := path.					^self]]		ifFalse: 			[envVarValue := EnvironmentFacade current valueOfEnvironmentVariableAt: 'CLASSPATH'.			classPaths := Pathname fromString: envVarValue separator: $;.			classPaths componentsDo: 					[:classPath | 					path := ResourcePath fromString: classPath.					[path suffixString = 'lib' or: [path isRoot]] 						whileFalse: [path := path prefix].					path isRoot 						ifFalse: 							[('jre*' match: path prefix suffixString) 								ifTrue: 									[path := path , 'tzmappings'.									path exists 										ifTrue: 											[sourcePath := path.											^self]]]]].	"VisualWorks-specific and Windows-specific code:"	path := (ResourcePath fromString: (EnvironmentFacade current valueOfEnvironmentVariableAt: 'windir')) prefix, 'Program Files', 'Java'.	jreList := OrderedCollection new.	path contentsDo: [:rp | | fn accessMap | fn := rp asNative. ('jre*' match: rp suffixString) ifTrue: [accessMap := fn accessTimepoints. jreList add: fn-&gt;(accessMap at: #created)]].	path := jreList inject: nil into: [:latest :each | latest == nil ifTrue: [each] ifFalse: [each value &gt; latest value ifTrue: [each] ifFalse: [latest]]].	sourcePath := ((ResourcePathContext platformDefault facadeAt: #platform) constructResourcePathFromNativeResourceID: path key), 'lib', 'tzmappings'.</body></methods><methods><class-id>Chronos.WindowsToOlsonTZKeyMapGenerator class</class-id> <category>accessing</category><body package="Chronos-Windows Timezone Map Generator">appOrLibraryName	^'Chronos'</body><body package="Chronos-Windows Timezone Map Generator">targetPathWithExtension: extension	"WindowsToOlsonTZKeyMapGenerator targetPathWithExtension: nil"	| targetPath |	targetPath := 		(ChronosSystemFacade resourceRepositoryContext 			resourcePathTo: #TZForeignKeyMappings			ifNone: [ResourcePath currentDirectory]) , 'windows'.	extension == nil 		ifFalse: [targetPath := targetPath appendingExtension: extension].	^targetPath</body></methods><methods><class-id>Chronos.WindowsToOlsonTZKeyMapGenerator class</class-id> <category>operations</category><body package="Chronos-Windows Timezone Map Generator">generate	"WindowsToOlsonTZKeyMapGenerator generate"	| targetStream |	targetStream := (self targetPathWithExtension: nil) writeStream.	[self new generate: 		[:assoc | 			targetStream				nextPutAll: assoc key;				nextPut: $|;				nextPutAll: assoc value;				cr]] ensure: [targetStream close]</body><body package="Chronos-Windows Timezone Map Generator">generateHTML	"WindowsToOlsonTZKeyMapGenerator generateHTML"	| targetStream |	targetStream := (self targetPathWithExtension:  'html') writeStream.	[targetStream		nextPutAll: '&lt;table border=1&gt;'; cr;		nextPutAll: '&lt;tbody&gt;'; cr;		nextPutAll: '&lt;tr&gt;'; cr.		self new generate: 		[:assoc | 			targetStream				nextPutAll: '&lt;td&gt;';				nextPutAll: assoc key;				nextPutAll: '&lt;/td&gt;&lt;td&gt;';				nextPutAll: assoc value;				nextPutAll: '&lt;/td&gt;';				nextPutAll: '&lt;/tr&gt;';				cr].	targetStream		nextPutAll: '&lt;/tbody&gt;'; cr;		nextPutAll: '&lt;/table&gt;'; cr] ensure: [targetStream close]</body></methods><methods><class-id>Chronos.OlsonTZDBZoneRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Parsing">printOn: stream	stream		nextPutAll: 'Zone Rule: ';		nextPutAll: name valueString;		nextPutAll: ' stdTimeOffsetFromUT: ';		nextPutAll: stdTimeOffsetFromUT valueString;		nextPutAll: ' transitionRule: ';		nextPutAll: transitionRule valueString;		nextPutAll: ' timeTypeName: ';		nextPutAll: timeTypeNameSpec valueString.	transitionDateAndTime == nil		ifFalse: 			[stream 				nextPutAll: ' until: ';				nextPutAll: transitionDateAndTime valueString]</body></methods><methods><class-id>Chronos.OlsonTZDBZoneRule</class-id> <category>converting</category><body package="Chronos-TZAdmin-Parsing">asNormalizedTimeZoneRule	| offsetSeconds nameSpec transitionDateAndTimeSpec |	offsetSeconds := stdTimeOffsetFromUT asSeconds.	nameSpec := timeTypeNameSpec asTimeTypeSpec.	transitionDateAndTime == nil 		ifTrue: [transitionDateAndTimeSpec := nil]		ifFalse: [transitionDateAndTimeSpec := transitionDateAndTime asDateAndTimeSpec].	transitionRule representsZeroOffsetSecondsDeltaInTimeZoneRule 		ifTrue: 			[^TZATimezoneRule 				key: self key				stdTimeOffsetSeconds: offsetSeconds				timeTypeNameSpec: nameSpec				transitionDateAndTime: transitionDateAndTimeSpec].	transitionRule isHourMinuteSecondLiteral 		ifTrue: 			[^TZATimezoneRule 				key: self key				stdTimeOffsetSeconds: offsetSeconds				timeTypeNameSpec: nameSpec				transitionDateAndTime: transitionDateAndTimeSpec				offsetDeltaSeconds: transitionRule asSeconds].	^TZATimezoneRule 		key: self key		stdTimeOffsetSeconds: offsetSeconds		timeTypeNameSpec: nameSpec		transitionDateAndTime: transitionDateAndTimeSpec		transitionRuleKey: transitionRule key</body></methods><methods><class-id>Chronos.OlsonTZDBZoneRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Parsing">key	^name key</body><body package="Chronos-TZAdmin-Parsing">name	^name</body><body package="Chronos-TZAdmin-Parsing">name: anObject	name := anObject</body><body package="Chronos-TZAdmin-Parsing">sortValue	^transitionDateAndTime == nil ifFalse: [transitionDateAndTime sortValue]</body><body package="Chronos-TZAdmin-Parsing">stdTimeOffsetFromUT	^stdTimeOffsetFromUT</body><body package="Chronos-TZAdmin-Parsing">stdTimeOffsetFromUT: anObject	stdTimeOffsetFromUT := anObject</body><body package="Chronos-TZAdmin-Parsing">stdTimeOffsetSecondsFromUT	^stdTimeOffsetFromUT asSeconds</body><body package="Chronos-TZAdmin-Parsing">timeTypeNameSpec	^timeTypeNameSpec</body><body package="Chronos-TZAdmin-Parsing">timeTypeNameSpec: anObject	timeTypeNameSpec := anObject</body><body package="Chronos-TZAdmin-Parsing">transitionDateAndTime	^transitionDateAndTime</body><body package="Chronos-TZAdmin-Parsing">transitionDateAndTime: anObject	transitionDateAndTime := anObject</body><body package="Chronos-TZAdmin-Parsing">transitionRule	^transitionRule</body><body package="Chronos-TZAdmin-Parsing">transitionRule: anObject	transitionRule := anObject</body></methods><methods><class-id>Chronos.OlsonTZDBZoneRule</class-id> <category>visitor collaboration</category><body package="Chronos-TZAdmin-Parsing">defineIn: aTZRuleVisitor	^aTZRuleVisitor defineZoneRule: self</body></methods><methods><class-id>Chronos.TZAAlwaysStandardTimeTZRule</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Compiling">type	^#AlwaysStandardTimeTZRule</body></methods><methods><class-id>Chronos.TZAAlwaysStandardTimeTZRule</class-id> <category>printing</category><body package="Chronos-TZAdmin-Compiling">printOn: stream	super printOn: stream.	self printOnTransitionDateAndTimeOn: stream.</body></methods><methods><class-id>Chronos.TZAAlwaysStandardTimeTZRule</class-id> <category>testing</category><body package="Chronos-TZAdmin-Compiling">isAlwaysStandardTime	^true</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id> <category>tokens</category><body package="Chronos-TZAdmin-Tokenizing">dateAndTimeToken: allElementsRequired 	| year startPosition monthOrdinal dayOfMonth secondsSinceStartOfDay next dayOfWeek weekOfMonthDayOfWeekSpec index relativity |	next := self skipSeparatorsThenPeek.	allElementsRequired 		ifTrue: [(next = cr or: [next == nil]) ifTrue: [self rejectExpecting: #dateAndTimeToken]]		ifFalse: [(next = cr or: [next = $# or: [next == nil]]) ifTrue: [^nil]].	startPosition := self readPosition.	year := self nextUnsignedIntegerOnError: [:found | ^self reject: found from: startPosition expecting: #dateAndTimeToken] ifAbsent: [^nil].	next := self skipSeparatorsThenPeek.	allElementsRequired 		ifTrue: [(next = cr or: [next == nil]) ifTrue: [self rejectExpecting: #month]]		ifFalse: 			[(next = cr or: [next = $# or: [next == nil]]) 				ifTrue: 					[^(TZADateAndTimeLiteral 						resourcePath: resourcePath 						lineNumber: lineNumber						startPosition: startPosition						endPosition: self readPosition - 1) year: year]].	startPosition := self readPosition.	monthOrdinal := self monthOrdinalFromMonthNameOnError: [:found | ^self reject: found from: startPosition expecting: #monthName] ifAbsent: [^self rejectExpecting: #month].	next := self skipSeparatorsThenPeek.	allElementsRequired 		ifTrue: [(next = cr or: [next == nil]) ifTrue: [self rejectExpecting: #dayOfMonth]]		ifFalse: 			[(next = cr or: [next = $# or: [next == nil]]) 				ifTrue: 					[^(TZADateAndTimeLiteral 						resourcePath: resourcePath 						lineNumber: lineNumber						startPosition: startPosition						endPosition: self readPosition - 1)						year: year;						monthOrdinal: monthOrdinal]].	startPosition := self readPosition.	next isDigit 		ifTrue: [dayOfMonth := self nextUnsignedIntegerOnError: [:found | ^self reject: found from: startPosition expecting: #dayOfMonth] ifAbsent: [^self rejectExpecting: #dayOfMonth]]		ifFalse: 			[next isLetter 				ifTrue: 					[next = $l 						ifTrue: 							[dayOfWeek := 								self 									lastWeekOfMonthDayOfWeekOrdinalOnError: [:found | ^self reject: found from: startPosition expecting: #dayOfWeekOfLastWeekOfMonth]									ifAbsent: [^self rejectExpecting: #dayOfWeekOfLastWeekOfMonth].							dayOfMonth := 								(WeekOfMonthDayOfWeekFactory 									month: monthOrdinal 									week: WeekOfMonthDayOfWeekFactory lastWeekOfMonth 									dayOfWeek: dayOfWeek)									dayOfMonthOrdinalInYear: year]						ifFalse: 							[weekOfMonthDayOfWeekSpec := 								self dayOfMonthConstrainedWeekOfMonthDayOfWeekOnError: [:found :expecting | ^self reject: found from: startPosition expecting: expecting]								ifAbsent: [^self rejectExpecting: #dayOfMonth].							dayOfMonth := (weekOfMonthDayOfWeekSpec asWeekOfMonthDayOfWeekInMonth: monthOrdinal) dayOfMonthOrdinalInYear: year ]]				ifFalse: [^self rejectExpecting: #dayOfMonth]].	next := self skipSeparatorsThenPeek.	allElementsRequired 		ifTrue: [(next = cr or: [next == nil]) ifTrue: [self rejectExpecting: #timeOfDay]]		ifFalse: 			[(next = cr or: [next = $# or: [next == nil]]) 				ifTrue: 					[^(TZADateAndTimeLiteral 						resourcePath: resourcePath 						lineNumber: lineNumber						startPosition: startPosition						endPosition: self readPosition - 1)						year: year;						monthOrdinal: monthOrdinal;						dayOfMonth: dayOfMonth]].	startPosition := self readPosition.	secondsSinceStartOfDay := 		self nextHourMinuteSecondOnError: [:found :expecting | ^self reject: found from: startPosition expecting: expecting] ifAbsent: [^self rejectExpecting: #timeOfDay].	index := #($w $s $u $g $z) indexOf: self peek ifAbsent: [0].	index = 0 ifTrue: [index := 1] ifFalse: [self advance].	relativity := #(nominal standard universal universal universal) at: index.	^(TZADateAndTimeLiteral 		resourcePath: resourcePath 		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1)		year: year;		monthOrdinal: monthOrdinal;		dayOfMonth: dayOfMonth;		secondsSinceStartOfDay: secondsSinceStartOfDay;		relativity: relativity</body><body package="Chronos-TZAdmin-Tokenizing">defaultToken	| token |	token := TZARuleDefaultToken resourcePath: resourcePath lineNumber: lineNumber position: self readPosition.	self advance.	^token</body><body package="Chronos-TZAdmin-Tokenizing">endSymbol	^TZARuleEndToken resourcePath: resourcePath lineNumber: lineNumber position: self readPosition</body><body package="Chronos-TZAdmin-Tokenizing">hourMinuteSecondToken	| startPosition seconds ch isNegative |	self skipSeparators.	startPosition := self readPosition.	ch := self peek.	ch isDigit 		ifTrue: [isNegative := false]		ifFalse: 			[isNegative := ch = $-.			isNegative ifFalse: [ch = $+ ifFalse: [^self rejectExpecting: #hourMinuteSecondToken]].			self advance].	seconds := 		self 			nextHourMinuteSecondOnError: [:found :expecting | ^self reject: found from: startPosition expecting: expecting]			ifAbsent: [^atEnd ifTrue: [self endSymbol] ifFalse: [self rejectExpecting: #hourMinuteSecondToken]].	^(TZAHourMinuteSecondLiteral 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition -1) value: (isNegative ifTrue: [seconds negated] ifFalse: [seconds])</body><body package="Chronos-TZAdmin-Tokenizing">identifierToken	| startPosition name |	self skipSeparators.	atEnd ifTrue: [^self endSymbol].	startPosition := self readPosition.	name := self upToSeparator.	^(TZARuleIdentifier 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1) key: name</body><body package="Chronos-TZAdmin-Tokenizing">integerToken	| startPosition integer ch isNegative |	self skipSeparators.	atEnd ifTrue: [^self endSymbol].	startPosition := self readPosition.	ch := self peek.	ch isDigit 		ifTrue: [isNegative := false]		ifFalse: 			[isNegative := ch = $-.			isNegative ifFalse: [ch = $+ ifFalse: [^self rejectExpecting: #integerToken]].			self advance.			ch := self peek.			ch == nil ifTrue: [^self endSymbol]].	integer := 		self 			nextUnsignedIntegerOnError: [:found | ^self reject: found from: startPosition expecting: #integer] 			ifAbsent: [^atEnd ifTrue: [self endSymbol] ifFalse: [self rejectExpecting: #integer]].	^(TZARuleInteger 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition -1) value: (isNegative ifTrue: [integer negated] ifFalse: [integer])</body><body package="Chronos-TZAdmin-Tokenizing">monthToken	| startPosition ordinal |	self skipSeparators.	atEnd ifTrue: [^self endSymbol].	startPosition := self readPosition.	ordinal := self 				monthOrdinalFromMonthNameOnError: [:found | ^self reject: found from: startPosition expecting: #monthToken]				ifAbsent: [^self rejectExpecting: #monthToken].	^(TZAMonthLiteral 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1) value: ordinal</body><body package="Chronos-TZAdmin-Tokenizing">reject: string from: startPosition expecting: tokenType 	^((TZARuleTokenInvalid 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1)		value: string;		expecting: tokenType;		line: self lineContents) halt</body><body package="Chronos-TZAdmin-Tokenizing">rejectExpecting: tokenType	^((TZARuleTokenInvalid resourcePath: resourcePath lineNumber: lineNumber position: self readPosition)		value: (String with: self next);		expecting: tokenType;		line: self lineContents) halt</body><body package="Chronos-TZAdmin-Tokenizing">ruleTypeSymbol	| ch string startPosition |	ch := self skipWhitespaceAndComments.	ch == nil ifTrue: [^self endSymbol].	ch isLetter ifFalse: [^self rejectExpecting: #ruleTypeSymbol].	startPosition := self readPosition.	string := self upToSeparator asUppercase.	^(ruleTypeFactories at: string		ifAbsent: 			[^self 				reject: string				from: startPosition				expecting: #ruleTypeSymbol]) 			resourcePath: resourcePath			lineNumber: lineNumber			startPosition: startPosition			endPosition: self readPosition - 1</body><body package="Chronos-TZAdmin-Tokenizing">skipWhitespaceAndComments	| next |	self skipWhile: [:ch | ch isSeparator] onLineEnd: nil.		[next := self peekOnLineEnd: nil.	next = $#] whileTrue: 				["It's a comment--skip to the next line."				self skipLine.				self skipWhile: [:ch | ch isSeparator] onLineEnd: nil].	^next</body><body package="Chronos-TZAdmin-Tokenizing">timeOfDayToken	| startPosition secondsSinceStartOfDay index ch |	self skipSeparators.	startPosition := self readPosition.	secondsSinceStartOfDay := 		self 			nextHourMinuteSecondOnError: [:found :expecting  | ^self reject: found from: startPosition expecting: expecting]			ifAbsent: [^atEnd ifTrue: [self endSymbol] ifFalse: [self rejectExpecting: #timeOfDayToken]].	ch := self peek.	index := #($w $s $u $g $z) indexOf: ch ifAbsent: [0].	index = 0 ifTrue: [index := 1] ifFalse: [self advance].	^(TZARuleTimeOfDayLiteral 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1)		value: secondsSinceStartOfDay;		perform: (#(#beNominalTime #beStandardTime #beUniversalTime #beUniversalTime #beUniversalTime) 					at: index)</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">advance	^nextChar == nil 		ifTrue: 			[(lineStream == nil or: [lineStream atEnd]) 				ifTrue: [self lineFault ifFalse: [^false]].			lineStream next.			true]		ifFalse: 			[nextChar := nil.			true]</body><body package="Chronos-TZAdmin-Tokenizing">advanceIf: predicate onLineEnd: onLineEnd 	nextChar == nil 		ifTrue: 			[(lineStream == nil or: [lineStream atEnd]) 				ifTrue: 					[onLineEnd == nil ifFalse: [onLineEnd value].					self lineFault ifFalse: [^false]].			nextChar := lineStream next.			nextChar == nil ifTrue: [nextChar := cr]].	^(predicate value: nextChar) 		ifTrue: 			[nextChar := nil.			true]		ifFalse: [false]</body><body package="Chronos-TZAdmin-Tokenizing">advanceIfNot: predicate onLineEnd: onLineEnd	nextChar == nil 		ifTrue: 			[(lineStream == nil or: [lineStream atEnd]) 				ifTrue: 					[onLineEnd == nil ifFalse: [onLineEnd value].					self lineFault ifFalse: [^false]].			nextChar := lineStream next.			nextChar == nil ifTrue: [nextChar := cr]].	^(predicate value: nextChar) 		ifTrue: [false]		ifFalse: 			[nextChar := nil.			true]</body><body package="Chronos-TZAdmin-Tokenizing">dayOfMonthConstrainedWeekOfMonthDayOfWeekOnError: onError ifAbsent: ifAbsent	| name dayOfWeekOrdinal operator dayOfMonth |	atEnd ifTrue: [^ifAbsent value].	self readPosition.	name := (self nextWhile: [:ch | ch isLetter]) asLowercase asSymbol.	dayOfWeekOrdinal := dayOfWeekNames at: name ifAbsent: [^onError value: name value: #dayOfWeekName].	self readPosition.	operator := (self nextWhile: [:ch | #($= $&lt; $&gt;) includes: ch]) asSymbol.	operator size = 0 ifTrue: [^onError value: '' value: #constraintOperator].	self readPosition.	dayOfMonth := 		self 			nextUnsignedIntegerOnError: [:found | ^onError value: found value: #dayOfMonth]			ifAbsent: [^onError value: '' value: #dayOfMonth].	^TZAWeekOfMonthDayOfWeekSpec constraintOperator: operator dayOfMonth: dayOfMonth dayOfWeek: dayOfWeekOrdinal</body><body package="Chronos-TZAdmin-Tokenizing">lastWeekOfMonthDayOfWeekOrdinalOnError: onError ifAbsent: ifAbsent	| name |	atEnd ifTrue: [^ifAbsent value].	name := (self nextWhile: [:ch | ch isLetter]) asLowercase asSymbol.	name size = 0 ifTrue: [^ifAbsent value].	^lastWeekOfMOnthDayOfWeekNames at: name ifAbsent: [^onError value: name].</body><body package="Chronos-TZAdmin-Tokenizing">lineContents	atEnd ifTrue: [^''].	lineStream == nil ifTrue: [^''].	lineStream position: 0.	^lineStream contents</body><body package="Chronos-TZAdmin-Tokenizing">lineFault	| last |	stream == nil ifTrue: [^self open].	nextChar := nil.	stream atEnd 		ifTrue: 			[atEnd := true.			^false].	lineStream == nil ifFalse: [lineNumber := lineNumber + 1].	lineStream := (String new: 80) newReadWriteStream.	"Note: 'stream upTo: Character cr' is not portable among all Smalltalk implementations."		[| ch |	ch := stream peek.	ch == nil 		ifTrue: 			[lineStream position: 0.			^lineStream atEnd 				ifTrue: 					[lineStream := nil.					atEnd := true.					false]				ifFalse: [true]].	last := ch.	ch = cr or: [ch = lf]] 			whileFalse: [lineStream nextPut: stream next].	lineStream position: 0.	stream next.	last = cr ifTrue: [stream peekFor: lf].	"Line-end convention transparency"	^true</body><body package="Chronos-TZAdmin-Tokenizing">lineStream	lineStream == nil		ifTrue: [self lineFault].	^lineStream</body><body package="Chronos-TZAdmin-Tokenizing">monthOrdinalFromMonthNameOnError: onError ifAbsent: ifAbsent	| name |	name := (self nextWhile: [:ch | ch isLetter]) asLowercase asSymbol.	name size = 0 ifTrue: [^ifAbsent value].	^monthNames at: name ifAbsent: [^onError value: name].</body><body package="Chronos-TZAdmin-Tokenizing">nextHourMinuteSecondOnError: onError ifAbsent: ifAbsent	| hour secondsSinceStartOfDay minute second |	hour := self nextUnsignedIntegerOnError: [:found | ^onError value: found value: #hour] ifAbsent: [^ifAbsent value].	hour &gt; 24 ifTrue: [^onError value: hour value: #hour]. 	secondsSinceStartOfDay := hour * SecondsPerHour.	self peek = $: ifFalse: [^secondsSinceStartOfDay].		self advance.	minute := self nextUnsignedIntegerOnError: [:found |  ^onError value: found value: #minute] ifAbsent: [^onError value: '' value: #minute].	hour = 24 ifTrue: [minute = 0 ifFalse: [^onError value: #minute]].	secondsSinceStartOfDay := secondsSinceStartOfDay + (minute * SecondsPerMinute).	self peek = $: ifFalse: [^secondsSinceStartOfDay].		self advance.	second := self nextUnsignedIntegerOnError: [:found |  ^onError value: found value: #second] ifAbsent: [^onError value: '' value: #second].	hour = 24 ifTrue: [second = 0 ifFalse: [^onError value: #second]].	secondsSinceStartOfDay := secondsSinceStartOfDay + second.	^secondsSinceStartOfDay</body><body package="Chronos-TZAdmin-Tokenizing">nextUnsignedIntegerOnError: onError ifAbsent: ifAbsent	| integer ch |	integer := 0.	ch := self peekOnLineEnd: [^ifAbsent value].	ch isDigit ifFalse: [^onError value: (String with: ch)].	[ch isDigit] whileTrue: 			[integer := integer * 10 + self next digitValue.			ch := self peekOnLineEnd: [^integer]].	^integer</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id> <category>tokens-zone rule</category><body package="Chronos-TZAdmin-Tokenizing">timeTypeToken	| startPosition name nameSuffix |	self skipSeparators.	atEnd ifTrue: [^self endSymbol].	startPosition := self readPosition.	name := self nextUntil: [:ch | ch = $% or: [ch = $/ or: [ch isSeparator]]].	^self peek isSeparator 		ifTrue: 			[(TZARuleTimeTypeLiteral 				resourcePath: resourcePath				lineNumber: lineNumber				startPosition: startPosition				endPosition: self readPosition - 1) value: name]		ifFalse: 			[(self peekFor: $/) 				ifTrue: 					[nameSuffix := self upToSeparator.					(TZARuleBinaryTimeTypeLiteral 						resourcePath: resourcePath						lineNumber: lineNumber						startPosition: startPosition						endPosition: self readPosition - 1)						standardName: name;						nonStandardName: nameSuffix]				ifFalse: 					[(self peekFor: $%) 						ifFalse: 							[^self 								reject: name								from: startPosition								expecting: #timeTypeToken].					(self peekFor: $s) 						ifFalse: 							[^self 								reject: name								from: startPosition								expecting: #timeTypeToken].					nameSuffix := self upToSeparator.					(TZARuleParametricTimeTypeLiteral 						resourcePath: resourcePath						lineNumber: lineNumber						startPosition: startPosition						endPosition: self readPosition - 1)						namePrefix: name;						nameSuffix: nameSuffix]]</body><body package="Chronos-TZAdmin-Tokenizing">transitionRuleToken	| next |	next := self skipSeparatorsThenPeek.	next == nil ifTrue: [^self endSymbol].	next = $- ifTrue: [^self defaultToken].	^next isLetter 		ifTrue: [self identifierToken]		ifFalse: 			[next isDigit 				ifTrue: [self hourMinuteSecondToken]				ifFalse: [self rejectExpecting: #transitionRuleToken]]</body><body package="Chronos-TZAdmin-Tokenizing">zoneRuleTransitionDateToken	^self dateAndTimeToken: false</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id> <category>tokens-transition rule</category><body package="Chronos-TZAdmin-Tokenizing">dayOfMonthConstrainedWeekOfMonthDayOfWeekToken	| startPosition weekOfMonthDayOfWeekSpec |	atEnd ifTrue: [^self endSymbol].	startPosition := self readPosition.	weekOfMonthDayOfWeekSpec := 		self 			dayOfMonthConstrainedWeekOfMonthDayOfWeekOnError: [:found :expecting | ^self reject: found from: startPosition expecting: expecting]			ifAbsent: [^self rejectExpecting: #dayOfMonthConstrainedWeekOfMonthDayOfWeekToken].	^(TZARuleDayOfMonthConstrainedWeekOfMonthDayOfWeekLiteral 		resourcePath: resourcePath 		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1) value: weekOfMonthDayOfWeekSpec</body><body package="Chronos-TZAdmin-Tokenizing">dayOfMonthToken	| ch |	ch := self skipSeparatorsThenPeek.	ch == nil ifTrue: [^self endSymbol].	^ch isDigit 		ifTrue: [self integerToken]		ifFalse: 			[ch isLetter 				ifTrue: [self weekOfMonthDayOfWeekToken]				ifFalse: [self rejectExpecting: #dayOfMonthToken]]</body><body package="Chronos-TZAdmin-Tokenizing">endingYearToken	| ch |	ch := self skipSeparatorsThenPeek.	ch == nil ifTrue: [^self endSymbol].	^ch isDigit 		ifTrue: [self integerToken]		ifFalse: 			[ch isLetter 				ifTrue: [self minOrMaxOrSameYearToken]				ifFalse: [ch = $- ifTrue: [self integerToken] ifFalse: [self rejectExpecting: #endingYearToken]]]</body><body package="Chronos-TZAdmin-Tokenizing">lastWeekOfMonthDayOfWeekToken	| startPosition ordinal |	atEnd ifTrue: [^self endSymbol].	startPosition := self readPosition.	ordinal := 		self 			lastWeekOfMonthDayOfWeekOrdinalOnError: [:found | ^self reject: found from: startPosition expecting: #lastWeekOfMonthDayOfWeekToken]			ifAbsent: [^self rejectExpecting: #lastWeekOfMonthDayOfWeekToken].	^(TZARuleLastWeekOfMonthDayOfWeekLiteral 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1) value: ordinal</body><body package="Chronos-TZAdmin-Tokenizing">minOrMaxOrSameYearToken	| startPosition next value |	self skipSeparators.	next := self peek.	next == nil ifTrue: [^self endSymbol].	next asLowercase = $m ifTrue: [^self minOrMaxYearToken].	startPosition := self readPosition.	value := (self nextWhile: [:ch | ch isLetter]) asLowercase.	value = 'only'		ifFalse: 			[^self 				reject: value				from: startPosition				expecting: #minOrMaxOrSameYearToken].	^TZARuleSameYearLiteral 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1</body><body package="Chronos-TZAdmin-Tokenizing">minOrMaxYearToken	| startPosition value index |	self skipSeparators.	atEnd ifTrue: [^self endSymbol].	startPosition := self readPosition.	value := (self nextWhile: [:ch | ch isLetter]) asLowercase asSymbol.	index := #(#max #min #maximum #minimum) indexOf: value				ifAbsent: 					[^self 						reject: value						from: startPosition						expecting: #minOrMaxYearToken].	^(TZARuleMinOrMaxYearLiteral 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1) 			value: (#(true false true false) at: index)</body><body package="Chronos-TZAdmin-Tokenizing">startingYearToken	| ch |	ch := self skipSeparatorsThenPeek.	ch == nil ifTrue: [^self endSymbol].	^ch isDigit 		ifTrue: [self integerToken]		ifFalse: 			[ch isLetter 				ifTrue: [self minOrMaxYearToken]				ifFalse: [ch = $- ifTrue: [self integerToken] ifFalse: [self rejectExpecting: #startingYearToken]]]</body><body package="Chronos-TZAdmin-Tokenizing">timeSubTypeToken	| startPosition next type |	self skipSeparators.	next := self peek.	next == nil ifTrue: [^self endSymbol].	next = $- ifTrue: [^self defaultToken].	startPosition := self readPosition.	type := self upToSeparator.	^(TZARuleTimeSubtypeLiteral 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1) value: type</body><body package="Chronos-TZAdmin-Tokenizing">weekOfMonthDayOfWeekToken	| next |	next := self peek.	next == nil ifTrue: [^self endSymbol].	^next = $l 		ifTrue: [self lastWeekOfMonthDayOfWeekToken]		ifFalse: [self dayOfMonthConstrainedWeekOfMonthDayOfWeekToken]</body><body package="Chronos-TZAdmin-Tokenizing">yearTypeToken	| startPosition next type |	self skipSeparators.	next := self peek.	next == nil ifTrue: [^self endSymbol].	next = $- ifTrue: [^self defaultToken].	startPosition := self readPosition.	type := self upToSeparator.	^(TZARuleYearType 		resourcePath: resourcePath		lineNumber: lineNumber		startPosition: startPosition		endPosition: self readPosition - 1) value: type</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id> <category>stream protocol (Chronos)</category><body package="Chronos-TZAdmin-Tokenizing">nextNonSeparatorMustSatisfy: predicate otherwise: handleInvalid	| startPosition |	self skipSeparators.	startPosition := self readPosition.	(predicate value: self next) 		ifFalse: [handleInvalid value: (TZARuleTokenInvalid resourcePath: resourcePath lineNumber: lineNumber position: startPosition)]</body><body package="Chronos-TZAdmin-Tokenizing">nextUntil: predicate 	| ch resultStream |	self atEnd ifTrue: [^nil].	resultStream := (String new: 10) writeStream.	[ch := self peekOnLineEnd: [^resultStream contents].	self advanceIfNot: predicate onLineEnd: [^resultStream contents]] whileTrue: 			[resultStream nextPut: ch].	^resultStream contents</body><body package="Chronos-TZAdmin-Tokenizing">nextUntil: predicate  onLineEnd: onLineEnd	| ch resultStream |	self atEnd ifTrue: [^nil].	resultStream := (String new: 10) writeStream.	[ch := self peekOnLineEnd: onLineEnd.	self advanceIfNot: predicate onLineEnd: onLineEnd] whileTrue: 			[resultStream nextPut: ch].	^resultStream contents</body><body package="Chronos-TZAdmin-Tokenizing">nextWhile: predicate 	| ch resultStream |	self atEnd ifTrue: [^nil].	resultStream := (String new: 10) writeStream.	[ch := self peekOnLineEnd: [^resultStream contents].	self advanceIf: predicate onLineEnd: [^resultStream contents]] whileTrue: 			[resultStream nextPut: ch].	^resultStream contents</body><body package="Chronos-TZAdmin-Tokenizing">nextWhile: predicate  onLineEnd: onLineEnd	| ch resultStream |	self atEnd ifTrue: [^nil].	resultStream := (String new: 10) writeStream.	[ch := self peekOnLineEnd: onLineEnd.	self advanceIf: predicate onLineEnd: onLineEnd] whileTrue: 			[resultStream nextPut: ch].	^resultStream contents</body><body package="Chronos-TZAdmin-Tokenizing">peekFor: aChar onLineEnd: onLineEnd	nextChar == nil 		ifTrue: 			[(lineStream == nil or: [lineStream atEnd]) 				ifTrue: 					[onLineEnd == nil ifFalse: [onLineEnd value].					self lineFault ifFalse: [^false]].			nextChar := lineStream next.			nextChar == nil ifTrue: [nextChar := cr]].	^(aChar = nextChar) 		ifTrue: 			[nextChar := nil.			true]		ifFalse: [false]</body><body package="Chronos-TZAdmin-Tokenizing">peekOnLineEnd: onLineEnd 	^nextChar == nil 		ifTrue: 			[(lineStream == nil or: [lineStream atEnd]) 				ifTrue: 					[onLineEnd == nil ifFalse: [^onLineEnd value].					^self lineFault ifTrue: [cr] ifFalse: [nil]].			nextChar := lineStream next]		ifFalse: [nextChar]</body><body package="Chronos-TZAdmin-Tokenizing">skipLine	"Note: 'stream skipTo: Character cr' is not portable among all Smalltalk implementations."	nextChar := nil.	lineStream == nil 		ifTrue: 			[| last |			stream atEnd ifTrue: [^false].						[| ch |			ch := stream peek.			last := ch.			ch == nil or: [ch = cr or: [ch = lf]]] 					whileFalse: [stream next].			stream next.			last = cr ifTrue: [stream peekFor: lf]	"Line-end convention transparency"]		ifFalse: 			[lineStream := nil.			self lineFault].	lineNumber := lineNumber + 1.	^true</body><body package="Chronos-TZAdmin-Tokenizing">skipSeparators	self skipWhile: [:ch | ch isSeparator] onLineEnd: [^false].	^true</body><body package="Chronos-TZAdmin-Tokenizing">skipSeparatorsThenPeek	self skipWhile: [:ch | ch isSeparator] onLineEnd: [^cr].	^self peek</body><body package="Chronos-TZAdmin-Tokenizing">skipUntil: predicate	[self advanceIfNot: predicate onLineEnd: [^false]] whileTrue.	^true</body><body package="Chronos-TZAdmin-Tokenizing">skipUntil: predicate onLineEnd: onLineEnd	[self advanceIfNot: predicate onLineEnd: onLineEnd] whileTrue.</body><body package="Chronos-TZAdmin-Tokenizing">skipWhile: predicate	[self advanceIf: predicate onLineEnd: [^false]] whileTrue.	^true</body><body package="Chronos-TZAdmin-Tokenizing">skipWhile: predicate onLineEnd: onLineEnd	[self advanceIf: predicate onLineEnd: onLineEnd] whileTrue.</body><body package="Chronos-TZAdmin-Tokenizing">upToSeparator	^self nextUntil: [:ch | ch isSeparator]</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id> <category>stream protocol (ANSI)</category><body package="Chronos-TZAdmin-Tokenizing">next	^nextChar == nil 		ifTrue: 			[(lineStream == nil or: [lineStream atEnd]) ifTrue: [^self lineFault ifTrue: [cr] ifFalse: [nil]].			lineStream next]		ifFalse: 			[| ch |			ch := nextChar.			nextChar := nil.			ch]</body><body package="Chronos-TZAdmin-Tokenizing">nextLine	| line |	lineStream == nil 		ifTrue: 			[self lineFault 				ifTrue: 					[line := lineStream contents.					self skipLine]				ifFalse: [line := nil]]		ifFalse: 			[line := lineStream upToEnd.			nextChar == nil				ifFalse: [line := (String with: nextChar), line].			self skipLine].	^line</body><body package="Chronos-TZAdmin-Tokenizing">nextMatchFor: aChar	^aChar = self next</body><body package="Chronos-TZAdmin-Tokenizing">peek	^self peekOnLineEnd: [^cr]</body><body package="Chronos-TZAdmin-Tokenizing">peekFor: aChar 	^self 		peekFor: aChar		onLineEnd: 			[aChar = cr 				ifTrue: 					[self advance.					true]				ifFalse: [false]]</body><body package="Chronos-TZAdmin-Tokenizing">skipTo: aChar 		[self 		peekFor: aChar		onLineEnd: 			[^aChar = cr 				ifTrue: 					[self advance.					true]				ifFalse: [false]]] 			whileFalse: 				[atEnd ifTrue: [^false].				self advance]</body><body package="Chronos-TZAdmin-Tokenizing">upTo: aChar 	| ch resultStream |	nextChar = aChar 		ifTrue: 			[nextChar := nil.			^Array new].	resultStream := (String new: 10) writeStream.		[self advanceIfNot: [:next | (ch := next) = aChar]		onLineEnd: [^resultStream contents]] 			whileTrue: [resultStream nextPut: ch].	self advance.	^resultStream contents</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">lineNumber	^lineNumber</body><body package="Chronos-TZAdmin-Tokenizing">readPosition	atEnd ifTrue: [^0].	^nextChar == nil		ifTrue: [self lineStream position]		ifFalse: [self lineStream position - 1]</body><body package="Chronos-TZAdmin-Tokenizing">resourcePath	^resourcePath</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id> <category>initialize-release</category><body package="Chronos-TZAdmin-Tokenizing">close	stream == nil ifFalse: [stream close].	stream := nil.	lineStream := nil.	nextChar := nil.</body><body package="Chronos-TZAdmin-Tokenizing">initialize	cr := Character cr.	lf := Character lf.	stream := nil.	lineStream := nil.	lineNumber := 1.	atEnd := true.	ruleTypeFactories := self class ruleTypeFactories.	monthNames := self class monthNames.	dayOfWeekNames := self class dayOfWeekNames.	lastWeekOfMOnthDayOfWeekNames := self class lastWeekOfMOnthDayOfWeekNames.</body><body package="Chronos-TZAdmin-Tokenizing">on: aResourcePath	resourcePath := aResourcePath.	self open</body><body package="Chronos-TZAdmin-Tokenizing">open	self close.	stream := resourcePath readStream.	atEnd := stream atEnd.	lineNumber := 1.	self lineFault</body><body package="Chronos-TZAdmin-Tokenizing">release	super release.	self close</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id> <category>tokens-leap rule</category><body package="Chronos-TZAdmin-Tokenizing">leapSecondDateAndTimeToken	^self dateAndTimeToken: true</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id> <category>testing</category><body package="Chronos-TZAdmin-Tokenizing">atEnd	^atEnd</body><body package="Chronos-TZAdmin-Tokenizing">isOpen	^stream notNil</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer class</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">dayOfWeekNames	"TZRulesetTokenizer dayOfWeekNames"	DayOfWeekNames == nil ifTrue: [DayOfWeekNames := self newDayOfWeekNames].	^DayOfWeekNames</body><body package="Chronos-TZAdmin-Tokenizing">lastWeekOfMOnthDayOfWeekNames	"TZRulesetTokenizer lastWeekOfMOnthDayOfWeekNames"	LastWeekOfMonthDayOfWeekNames == nil ifTrue: [LastWeekOfMonthDayOfWeekNames := self newLastWeekOfMonthDayOfWeekNames].	^LastWeekOfMonthDayOfWeekNames</body><body package="Chronos-TZAdmin-Tokenizing">monthNames	"TZRulesetTokenizer monthNames"	MonthNames == nil ifTrue: [MonthNames := self newMonthNames].	^MonthNames</body><body package="Chronos-TZAdmin-Tokenizing">ruleTypeFactories	"TZRulesetTokenizer ruleTypeFactories"	RuleTypeFactories == nil ifTrue: [RuleTypeFactories := self newRuleTypeFactories].	^RuleTypeFactories</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer class</class-id> <category>instance creation</category><body package="Chronos-TZAdmin-Tokenizing">on: aResourcePath	^self new on: aResourcePath</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer class</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">newDayOfWeekNames	| map dayOfWeekKeys |	map := IdentityDictionary new.	dayOfWeekKeys := ANSIDayOfWeekKeys.	1 to: dayOfWeekKeys size do: [:ordinal | 		| dayOfWeekKey key |		dayOfWeekKey := dayOfWeekKeys at: ordinal.		key := dayOfWeekKey asLowercase asSymbol.		map at: key put: ordinal.		key := (dayOfWeekKey copyFrom: 1 to: 3) asLowercase asSymbol.		map at: key put: ordinal].	^map</body><body package="Chronos-TZAdmin-Tokenizing">newLastWeekOfMonthDayOfWeekNames	| map dayOfWeekKeys |	map := IdentityDictionary new.	dayOfWeekKeys := ANSIDayOfWeekKeys.	1 to: dayOfWeekKeys size do: [:ordinal | 		| dayOfWeekKey key |		dayOfWeekKey := dayOfWeekKeys at: ordinal.		key := ('last', dayOfWeekKey asLowercase) asSymbol.		map at: key put: ordinal.		key := ('last', ((dayOfWeekKey copyFrom: 1 to: 3) asLowercase)) asSymbol.		map at: key put: ordinal].	^map</body><body package="Chronos-TZAdmin-Tokenizing">newMonthNames	| map monthKeys |	map := IdentityDictionary new.	monthKeys := ISOMonthKeys.	1 to: monthKeys size		do: 			[:ordinal | 			| monthKey key |			monthKey := monthKeys at: ordinal.			key := monthKey asLowercase asSymbol.			map at: key put: ordinal.			key := (monthKey copyFrom: 1 to: 3) asLowercase asSymbol.			map at: key put: ordinal].	^map</body><body package="Chronos-TZAdmin-Tokenizing">newRuleTypeFactories	| map |	map := Dictionary new.	map		at: 'RULE' put: TZATransitionRuleToken;		at: 'ZONE' put: TZAZoneRuleToken;		at: 'LINK' put: TZALinkRuleToken;		at: 'LEAP' put: TZALeapSecondRuleToken.	^map</body></methods><methods><class-id>Chronos.OlsonTZDBRulesetTokenizer class</class-id> <category>class initialization</category><body package="Chronos-TZAdmin-Tokenizing">initialize	"TZRulesetTokenizer initialize"	RuleTypeFactories := nil.	MonthNames := nil.	DayOfWeekNames := nil</body></methods><methods><class-id>Chronos.TZARuleIdentifier</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Tokenizing">key	^value</body><body package="Chronos-TZAdmin-Tokenizing">key: aString	self value: aString</body><body package="Chronos-TZAdmin-Tokenizing">value: anObject	super value: anObject asSymbol</body></methods><methods><class-id>Chronos.TZARuleIdentifier</class-id> <category>private</category><body package="Chronos-TZAdmin-Tokenizing">nameOfValue	^#identifier</body></methods><methods><class-id>Chronos.TZATransitionRuleEndEvent</class-id> <category>operations</category><body package="Chronos-TZAdmin-Utility">applyTo: aSetOfActiveTransitionRules	aSetOfActiveTransitionRules remove: transitionRule</body></methods><methods><class-id>Chronos.TZATransitionRuleEndEvent</class-id> <category>comparing</category><body package="Chronos-TZAdmin-Utility">compareTo: otherEvent	| diff |	diff := super compareTo: otherEvent.	diff = 0 ifFalse: [^diff].	^otherEvent isEndEvent		ifTrue: [0]		ifFalse: [-1]</body></methods><methods><class-id>Chronos.TZATransitionRuleEndEvent</class-id> <category>testing</category><body package="Chronos-TZAdmin-Utility">isEndEvent	^true</body></methods><methods><class-id>Chronos.TZATransitionRuleEndEvent</class-id> <category>accessing</category><body package="Chronos-TZAdmin-Utility">type	^#TransitionRuleEnd</body><body package="Chronos-TZAdmin-Utility">year	^self endYear</body></methods><initialize><class-id>Chronos.TZAdministrational</class-id></initialize><initialize><class-id>Chronos.OlsonTZDBRulesetParser</class-id></initialize><initialize><class-id>Chronos.OlsonTZDBRulesetTokenizer</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>DateAndTimeSpec</name><environment>Chronos</environment><super>Chronos.DateSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hour minute second nanosecondsSinceSecond </inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-DateTimeInterval</category><attributes><package>Chronos-DateTimeInterval</package></attributes></class><class><name>PassportObject</name><environment>Passport</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			private Smalltalk.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class><class><name>ChronosObject</name><environment>Chronos</environment><super>Passport.Immutable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			Chronos.*			ChronosConstants.*			</imports><category>Chronos-Foundation</category><attributes><package>Chronos-Foundation</package></attributes></class><class><name>PassportMagnitude</name><environment>Passport</environment><super>Passport.Immutable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Passport.*			</imports><category>Passport-Kernel</category><attributes><package>Passport-Kernel</package></attributes></class></st-source>